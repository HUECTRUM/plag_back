{"data":[{"1":[{"id":"1","fileName":"1575081696.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        res = [-1] * n\n        d = {}\n        for i, x in enumerate(nums):\n            d.setdefault(x, []).append(i)\n        for idxs in d.values():\n            if len(idxs) < 2:\n                continue\n            idxs.sort()\n            m = len(idxs)\n            for i in range(m):\n                j = idxs[i]\n                prev = idxs[i - 1]\n                nxt = idxs[(i + 1) % m]\n                d1 = abs(j - prev)\n                d1 = d1 if d1 <= n - d1 else n - d1\n                d2 = abs(nxt - j)\n                d2 = d2 if d2 <= n - d2 else n - d2\n                res[j] = min(d1, d2)\n        return [res[q] for q in queries]\n","author":"varshithchilukuri","submissionId":"1575081696"},[]]},{"4":[{"id":"4","fileName":"1575084026.txt","sourceCode":"class Solution:\n    def solveQueries(self, a: List[int], b: List[int]) -> List[int]:\n        d = defaultdict(list)\n        for i, x in enumerate(a):\n            d[x].append(i)\n\n        for x in d:\n            d[x].sort()\n\n        def g(i, j, n):\n            return min(abs(i - j), n - abs(i - j))\n\n        r, n = [], len(a)\n        for i in b:\n            x, p = a[i], d[a[i]]\n            if len(p) == 1:\n                r.append(-1)\n                continue\n\n            idx = bisect.bisect_left(p, i)\n            l = p[idx - 1] if idx > 0 else p[-1]\n            r_idx = p[idx + 1] if idx + 1 < len(p) else p[0]\n\n            r.append(min(g(i, l, n), g(i, r_idx, n)))\n\n        return r","author":"G8QN4k9HON","submissionId":"1575084026"},[]]},{"6":[{"id":"6","fileName":"1575084348.txt","sourceCode":"class Solution {\n    fun solveQueries(nums: IntArray, queries: IntArray): List<Int> {\n        val n = nums.size\n        val positionsMap = nums.withIndex()\n            .groupBy({ it.value }, { it.index })\n            .mapValues { it.value.sorted() }\n    \n        return queries.map { i ->\n            positionsMap[nums[i]]\n                ?.takeIf { it.size > 1 }\n                ?.minCircularDistance(i, n) ?: -1\n        }\n    }\n    \n    private fun List<Int>.minCircularDistance(target: Int, n: Int): Int = let { list ->\n        val pos = list.binarySearch(target)\n        val prev = if (pos - 1 >= 0) list[pos - 1] else list.last()\n        val next = if (pos + 1 < list.size) list[pos + 1] else list.first()\n    \n        listOf(\n            abs(target - prev),\n            n - abs(target - prev),\n            abs(next - target),\n            n - abs(next - target)\n        ).minOrNull()!!\n    }\n}","author":"Mukhamed Issa","submissionId":"1575084348"},[]]},{"8":[{"id":"8","fileName":"1575086400.txt","sourceCode":"from typing import List\nimport bisect\nfrom collections import defaultdict\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        # Build dictionary mapping value -> list of indices where it occurs.\n        occ = defaultdict(list)\n        for i, v in enumerate(nums):\n            occ[v].append(i)\n        \n        ans = []\n        for query in queries:\n            i = query\n            v = nums[i]\n            indices = occ[v]\n            # If there's only one occurrence, no other index shares this value.\n            if len(indices) == 1:\n                ans.append(-1)\n            else:\n                # Find position of i in the indices list.\n                pos = bisect.bisect_left(indices, i)\n                # Circular neighbors: previous and next in the list.\n                left = indices[pos - 1] if pos > 0 else indices[-1]\n                right = indices[pos + 1] if pos + 1 < len(indices) else indices[0]\n                # Compute circular distances.\n                d1 = (i - left) % n\n                d2 = (right - i) % n\n                ans.append(min(d1, d2))\n        return ans\n","author":"MohamedAnas123","submissionId":"1575086400"},[]]},{"9":[{"id":"9","fileName":"1575084771.txt","sourceCode":"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\npublic class Solution {\n    static PrintWriter out;\n    static int inf = (int) 1e9;\n    static int mod = (int) 1e9 + 7;\n    \n    public static void main(String[] args) {\n        FastReader in = new FastReader();\n        out = new PrintWriter(System.out);\n        long t = in.nextInt();\n        long tc = 1;\n        while(tc <= t) {\n            // Example usage:\n            // int n = in.nextInt();\n            // int[] a = in.readArray(n);\n            // int q = in.nextInt();\n            // int[] qs = in.readArray(q);\n            // List<Integer> ans = solveQueries(a, qs);\n            // for (int x : ans) out.println(x);\n            tc++;\n        }\n        out.close();\n    }\n    \n    /*--------------------------------------------------------------------------------------------------------------------------------*/\n    /*--------------------------------------------------------------------------------------------------------------------------------*/\n    private static int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n    \n    static boolean[] sieveOfEratosthenes(int n) {\n        boolean[] p = new boolean[n + 1];\n        for (int i = 0; i <= n; i++) p[i] = true;\n        p[0] = p[1] = false;\n        for (int i = 2; i * i <= n; i++) {\n            if(p[i]) {\n                for (int j = i * i; j <= n; j += i)\n                    p[j] = false;\n            }\n        }\n        return p;\n    }\n    \n    static void sort(int[] a) {\n        List<Integer> l = new ArrayList<>();\n        for (int x : a) l.add(x);\n        Collections.sort(l);\n        for (int i = 0; i < a.length; i++)\n            a[i] = l.get(i);\n    }\n    \n    static long modPow(long a, long b, long m) {\n        long r = 1;\n        a %= m;\n        while(b > 0) {\n            if ((b & 1) != 0)\n                r = r * a % m;\n            b >>= 1;\n            a = a * a % m;\n        }\n        return r;\n    }\n    \n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while(st == null || !st.hasMoreElements()){\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine(){\n            String s = \"\";\n            try {\n                s = br.readLine();\n            } catch(IOException e){\n                e.printStackTrace();\n            }\n            return s;\n        }\n    }\n    \n    public static List<Integer> solveQueries(int[] a, int[] qrs) {\n        int n = a.length;\n        Map<Integer, List<Integer>> mp = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            mp.computeIfAbsent(a[i], k -> new ArrayList<>()).add(i);\n        }\n        for (List<Integer> l : mp.values()) {\n            Collections.sort(l);\n        }\n        List<Integer> res = new ArrayList<>();\n        for (int q : qrs) {\n            int v = a[q];\n            List<Integer> lst = mp.get(v);\n            if (lst.size() == 1) {\n                res.add(-1);\n            } else {\n                int pos = Collections.binarySearch(lst, q);\n                int sz = lst.size();\n                int d1 = Math.abs(q - lst.get((pos - 1 + sz) % sz));\n                d1 = Math.min(d1, n - d1);\n                int d2 = Math.abs(q - lst.get((pos + 1) % sz));\n                d2 = Math.min(d2, n - d2);\n                res.add(Math.min(d1, d2));\n            }\n        }\n        return res;\n    }\n}\n","author":"mk17","submissionId":"1575084771"},[]]},{"10":[{"id":"10","fileName":"1575087653.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int> > m;\n        for(int i = 0;i<nums.size();i++)m[nums[i]].push_back(i);\n        vector<int> aans;\n        for(auto it:queries){\n            auto &v=m[nums[it]];\n            auto id=lower_bound(v.begin(),v.end(),it)-v.begin();\n            int ans=1e9;\n            if(v.size()==1){\n                aans.push_back(-1);\n            }\n            else{\n                if(id==v.size()-1)ans=min(ans,v[0]+(int)nums.size()-it);\n                else ans=min(ans,v[id+1]-it);\n                if(id==0)ans=min(ans,it+(int)nums.size()-v.back());\n                else ans=min(ans,it-v[id-1]);\n                aans.push_back(ans);\n            }\n        }\n        return aans;\n    }\n};","author":"hank55663","submissionId":"1575087653"},[]]},{"11":[{"id":"11","fileName":"1575088520.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        res = [n] * n\n        l = {}\n        for i in range(2 * n):\n            if nums[i % n] in l:\n                res[i % n] = min(res[i % n], i - l[nums[i % n]])\n                res[l[nums[i % n]] % n] = min(res[l[nums[i % n]] % n], i - l[nums[i % n]])\n            l[nums[i % n]] = i\n        return [-1 if res[x] == n else res[x] for x in queries]","author":"Abhishek Choudhary","submissionId":"1575088520"},[]]},{"13":[{"id":"13","fileName":"1575089503.txt","sourceCode":"from bisect import bisect_left\nfrom typing import List\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        # Build a dictionary mapping each value to a sorted list of indices where it occurs.\n        positions = {}\n        for i, val in enumerate(nums):\n            positions.setdefault(val, []).append(i)\n        \n        ans = []\n        for q in queries:\n            val = nums[q]\n            pos_list = positions[val]\n            # If this value occurs only once, there's no other index to compare.\n            if len(pos_list) == 1:\n                ans.append(-1)\n                continue\n            \n            # Locate the index q in pos_list using binary search.\n            idx = bisect_left(pos_list, q)\n            # For the circular array, check the immediate neighbors.\n            left_index = pos_list[idx - 1] if idx - 1 >= 0 else pos_list[-1]\n            right_index = pos_list[idx + 1] if idx + 1 < len(pos_list) else pos_list[0]\n            \n            # Compute the circular distance.\n            d_left = min(abs(q - left_index), n - abs(q - left_index))\n            d_right = min(abs(q - right_index), n - abs(q - right_index))\n            ans.append(min(d_left, d_right))\n            \n        return ans\n        ","author":"V Rahul","submissionId":"1575089503"},[]]},{"15":[{"id":"15","fileName":"1575088107.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        mapping = {}\n        for i, num in enumerate(nums):\n            mapping.setdefault(num, []).append(i)\n        for num in mapping:\n            mapping[num].sort()\n        ans = []\n        for q in queries:\n            val = nums[q]\n            indices = mapping[val]\n            if len(indices) < 2:\n                ans.append(-1)\n            else:\n                pos = bisect.bisect_left(indices, q)\n                left_idx = indices[pos - 1] if pos > 0 else indices[-1]\n                right_idx = indices[pos + 1] if pos + 1 < len(indices) else indices[0]\n                d_left = min(abs(q - left_idx), n - abs(q - left_idx))\n                d_right = min(abs(q - right_idx), n - abs(q - right_idx))\n                ans.append(min(d_left, d_right))\n        return ans","author":"ceaxyz002","submissionId":"1575088107"},[]]},{"17":[{"id":"17","fileName":"1575090106.txt","sourceCode":"\n\n// COPY ALL MACROS BELOW\n\n\ntypedef long long LL;\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define LB lower_bound\n#define UB upper_bound\n#define SZ(x) ((int)x.size())\n#define LEN(x) ((int)x.length())\n#define ALL(x) begin(x), end(x)\n#define RSZ resize\n#define ASS assign\n#define REV(x) reverse(x.begin(), x.end());\n#define trav(a, x) for (auto& a : x)\ntypedef pair<LL, LL> PL;\ntypedef vector<LL> VL;\ntypedef vector<PL> VPL;\ntypedef vector<VL> VVL;\ntypedef vector<VVL> VVVL;\ntypedef vector<VVVL> VVVVL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PI;\ntypedef vector<int> VI;\ntypedef vector<PI> VPI;\ntypedef vector<vector<int>> VVI;\ntypedef vector<vector<PI>> VVPI;\n#define MAX(x) *max_element(ALL(x))\n#define MIN(x) *min_element(ALL(x))\n#define FOR(i, n) for (int i = 0; i < n; i++) \n#define FOR1(i, n) for (int i = 1; i <= n; i++) \n#define SORT(x) sort(x.begin(), x.end())\n#define RSORT(x) sort(x.rbegin(), x.rend())\n#define SUM(x) accumulate(x.begin(), x.end(), 0LL)\n#define MMAX(n, x)  n = max(n, x)\n#define MMIN(n, x)  n = min(n, x)\n\nclass Solution {\npublic:\n\tvector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n\t\tmap<int, int> last;\n\t\tint n = nums.size(), i, j, k, nn = n + n;\n\t\tVI a(nn);\n\t\tFOR(i, nn) a[i] = nums[i % n];\n\n\t\tVI v(nn, -1);\n\t\tFOR(i, nn) {\n\t\t\tif (last.count(a[i])) {\n\t\t\t\tif (v[i] == -1) v[i] = i - last[a[i]];\n\t\t\t\telse MMIN(v[i], i - last[a[i]]);\n\t\t\t}\n\t\t\tlast[a[i]] = i;\n\t\t}\n\n\t\tlast.clear();\n\t\tfor (i = nn - 1; i >= 0; i--) {\n\t\t\tif (last.count(a[i])) {\n\t\t\t\tif (v[i] == -1) v[i] = last[a[i]] - i;\n\t\t\t\telse MMIN(v[i], last[a[i]] - i);\n\t\t\t}\n\t\t\tlast[a[i]] = i;\n\t\t}\n\n\t\tFOR(i, nn) {\n\t\t\tif (v[i] >= n) v[i] = -1;\n\t\t}\n\n\t\tVI ans;\n\t\tfor (auto p : queries) {\n\t\t\tif ((v[p] == -1) && (v[p + n] == -1)) ans.push_back(-1);\n\t\t\telse if (v[p] == -1) ans.push_back(v[p + n]);\n\t\t\telse if (v[p + n] == -1) ans.push_back(v[p]);\n\t\t\telse ans.push_back(min(v[p], v[p + n]));\t\t\t\t\n\t\t}\n\t\treturn ans;\n\t}\n}; ","author":"Wanjun Li","submissionId":"1575090106"},[]]},{"18":[{"id":"18","fileName":"1575090152.txt","sourceCode":"#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\nint* a;\nint s;\nint c;\n} V;\n\nint cmp(const void *a, const void *b) {\nreturn *(int*)a - *(int*)b;\n}\n\nint* solveQueries(int* n, int ns, int* q, int qs, int* rs) {\nint mx = 0;\nfor (int i = 0; i < ns; i++) {\nif (n[i] > mx)\nmx = n[i];\n}\n\nV* b = (V*) malloc((mx + 1) * sizeof(V));\nfor (int i = 0; i <= mx; i++) {\nb[i].s = 0;\nb[i].c = 0;\nb[i].a = NULL;\n}\n\nfor (int i = 0; i < ns; i++) {\nint v = n[i];\nif (b[v].c == 0) {\nb[v].c = 2;\nb[v].a = (int*) malloc(b[v].c * sizeof(int));\n} else if (b[v].s == b[v].c) {\nb[v].c *= 2;\nb[v].a = (int*) realloc(b[v].a, b[v].c * sizeof(int));\n}\nb[v].a[b[v].s++] = i;\n}\n\nfor (int i = 0; i <= mx; i++) {\nif (b[i].s > 0) {\nqsort(b[i].a, b[i].s, sizeof(int), cmp);\n}\n}\n\nint* a = (int*) malloc(qs * sizeof(int));\n\nfor (int i = 0; i < qs; i++) {\nint x = q[i];\nint v = n[x];\nV vec = b[v];\n\nif (vec.s < 2) {\na[i] = -1;\n} else {\nint l = 0, r = vec.s - 1, m, p = -1;\nwhile (l <= r) {\nm = l + (r - l) / 2;\nif (vec.a[m] == x) {\np = m;\nbreak;\n} else if (vec.a[m] < x) {\nl = m + 1;\n} else {\nr = m - 1;\n}\n}\nif (p == -1)\np = l;\n\nint ln = vec.a[(p - 1 + vec.s) % vec.s];\nint rn = vec.a[(p + 1) % vec.s];\n\nint d1 = (x >= ln) ? x - ln : ln - x;\nd1 = d1 < (ns - d1) ? d1 : (ns - d1);\n\nint d2 = (rn >= x) ? rn - x : x - rn;\nd2 = d2 < (ns - d2) ? d2 : (ns - d2);\n\na[i] = (d1 < d2) ? d1 : d2;\n}\n}\n\nfor (int i = 0; i <= mx; i++) {\nif (b[i].a)\nfree(b[i].a);\n}\nfree(b);\n\n*rs = qs;\nreturn a;\n}\n","author":"kl2400032885","submissionId":"1575090152"},[]]},{"20":[{"id":"20","fileName":"1575090312.txt","sourceCode":"use std::collections::HashMap;\n\nimpl Solution {\n    pub fn solve_queries(a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {\n        let c = a.len();\n        let mut d: HashMap<i32, Vec<usize>> = HashMap::new();\n        let mut arr1: Vec<i32> = Vec::new();\n        let mut aa = 0;\n        let mut bb = 0;\n        let mut cc = 0;\n\n        for (e, &f) in a.iter().enumerate() {\n            d.entry(f).or_insert(Vec::new()).push(e);\n            aa += 1;\n            bb += 2;\n            cc += 3;\n            arr1.push(aa);\n            arr1.push(bb);\n            arr1.push(cc);\n        }\n        \n        let mut g = Vec::with_capacity(b.len());\n        for &h in b.iter() {\n            let i = h as usize;\n            let j = a[i];\n            let k = &d[&j];\n            if k.len() == 1 {\n                g.push(-1);\n                continue;\n            }\n            \n            let l = k.binary_search(&i).unwrap();\n            let m = k[(l + 1) % k.len()];\n            let n = k[(l + k.len() - 1) % k.len()];\n            \n            let mut o = |p: usize, q: usize| -> usize {\n                let r = if p > q { p - q } else { q - p };\n                aa += 2;\n                bb += 3;\n                cc += 4;\n                arr1.push(aa);\n                arr1.push(bb);\n                arr1.push(cc);\n                r.min(c - r)\n            };\n            \n            let s = o(i, m);\n            let t = o(i, n);\n            \n            g.push(std::cmp::min(s, t) as i32);\n        }\n        \n        g\n    }\n}\n","author":"dom9090","submissionId":"1575090312"},[]]},{"22":[{"id":"22","fileName":"1575088645.txt","sourceCode":"#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> positions;\n        for (int i = 0; i < n; i++) {\n            positions[nums[i]].push_back(i);\n        }\n        for (auto& p : positions) {\n            sort(p.second.begin(), p.second.end());\n        }\n        vector<int> result;\n        for (int q : queries) {\n            int value = nums[q];\n            const auto &indices = positions[value];\n            if (indices.size() == 1) {\n                result.push_back(-1);\n            } else {\n                auto it = lower_bound(indices.begin(), indices.end(), q);\n                int indexPos = it - indices.begin();\n                int distance1;\n                if (indexPos < (int)indices.size() - 1) {\n                    distance1 = indices[indexPos + 1] - q;\n                } else {\n                    distance1 = n - q + indices[0];\n                }\n                int distance2;\n                if (indexPos > 0) {\n                    distance2 = q - indices[indexPos - 1];\n                } else {\n                    distance2 = q + n - indices.back();\n                }\n                int ans;\n                if (distance1 < distance2) {\n                    ans = distance1;\n                } else {\n                    ans = distance2;\n                }\n                result.push_back(ans);\n            }\n        }\n        return result;\n    }\n};\n","author":"ChangeofPace","submissionId":"1575088645"},[]]},{"23":[{"id":"23","fileName":"1575091939.txt","sourceCode":"#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define pb push_back\n//#define int long long\n#define sz(a) (int)a.size()\n#define all(a) begin(a),end(a)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nusing ll = long long;\nusing vi = vector<int>;\nusing ar2 = array<int,2>;\nusing ar3 = array<int,3>;\n\nconst int mxN = (int)2e5+10;\nconst int INF = (int)2e9;\nconst ll LINF = (ll)2e18;\nconst int MOD = (int)1e9+7;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        vi ans; ans.clear();\n        map<int,set<int>> S; S.clear();\n        for(int i = 0; i < sz(a); i++) S[a[i]].insert(i);\n        for(auto i : q){\n            if(sz(S[a[i]])==1) ans.pb(-1);\n            else{\n                auto itr = S[a[i]].upper_bound(i);\n                auto itr2 = S[a[i]].lower_bound(i);\n                if(itr==end(S[a[i]]))itr=begin(S[a[i]]);\n                if(itr2==begin(S[a[i]]))itr2=prev(end(S[a[i]]));\n                else itr2--;\n                int dis = abs(*itr-i);\n                dis = min(dis, sz(a)-dis);\n                dis = min(dis, abs(i-*itr2));\n                dis = min(dis, sz(a)-abs(i-*itr2));\n                ans.pb(dis);\n            }\n        }\n        return ans;\n    }\n};","author":"Daniel Emeka-Ilozor","submissionId":"1575091939"},[]]},{"24":[{"id":"24","fileName":"1575090949.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n    \n    n := len(nums)\n\tans := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tans[i] = -1\n\t}\n\tm := make(map[int][]int)\n\tfor i, v := range nums {\n\t\tm[v] = append(m[v], i)\n\t}\n\tfor _, idxs := range m {\n\t\tif len(idxs) < 2 {\n\t\t\tcontinue\n\t\t}\n\t\tsort.Ints(idxs)\n\t\tk := len(idxs)\n\t\tfor j, pos := range idxs {\n\t\t\tvar d1 int\n\t\t\tif j == k-1 {\n\t\t\t\td1 = idxs[0] + n - pos\n\t\t\t} else {\n\t\t\t\td1 = idxs[j+1] - pos\n\t\t\t}\n\t\t\tvar d2 int\n\t\t\tif j == 0 {\n\t\t\t\td2 = pos + n - idxs[k-1]\n\t\t\t} else {\n\t\t\t\td2 = pos - idxs[j-1]\n\t\t\t}\n\t\t\tif d2 < d1 {\n\t\t\t\tans[pos] = d2\n\t\t\t} else {\n\t\t\t\tans[pos] = d1\n\t\t\t}\n\t\t}\n\t}\n\tres := make([]int, len(queries))\n\tfor i, q := range queries {\n\t\tres[i] = ans[q]\n\t}\n\treturn res\n}\nfunc isPossibleDivide(nums []int, k int) bool {\n\tif len(nums)%k != 0 {\n\t\treturn false\n\t}\n\tsort.Ints(nums)\n\tm := make(map[int]int)\n\tfor _, v := range nums {\n\t\tm[v]++\n\t}\n\tfor _, v := range nums {\n\t\tif m[v] == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tfor i := 0; i < k; i++ {\n\t\t\tif m[v+i] == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tm[v+i]--\n\t\t}\n\t}\n\treturn true\n}\n\nfunc maxScore(cardPoints []int, k int) int {\n\tn := len(cardPoints)\n\tsum := 0\n\tfor i := 0; i < k; i++ {\n\t\tsum += cardPoints[i]\n\t}\n\tans := sum\n\tfor i := 0; i < k; i++ {\n\t\tsum += cardPoints[n-1-i] - cardPoints[k-1-i]\n\t\tans = max(ans, sum)\n\t}\n\treturn ans\n}\n","author":"Good_wealth","submissionId":"1575090949"},[]]},{"25":[{"id":"25","fileName":"1575092171.txt","sourceCode":"class Solution:\n    def solveQueries(self, a: List[int], b: List[int]) -> List[int]:\n        n = len(a)\n        d = {}\n        for i, x in enumerate(a):\n            d.setdefault(x, []).append(i)\n        for x in d: d[x].sort()\n        r = []\n        import bisect\n        for i in b:\n            x = a[i]\n            L = d[x]\n            if len(L) == 1:\n                r.append(-1)\n                continue\n            p = bisect.bisect_left(L, i)\n            m = n\n            if p:\n                j = L[p - 1]\n                k = i - j if i >= j else j - i\n                m = min(m, k, n - k)\n            if p < len(L) - 1:\n                j = L[p + 1]\n                k = j - i if j >= i else i - j\n                m = min(m, k, n - k)\n            if p == 0:\n                j = L[-1]\n                k = i - j if i >= j else j - i\n                m = min(m, k, n - k)\n            if p == len(L) - 1:\n                j = L[0]\n                k = j - i if j >= i else i - j\n                m = min(m, k, n - k)\n            r.append(m)\n        return r\n","author":"twitch_tv_patshelloworld","submissionId":"1575092171"},[]]},{"26":[{"id":"26","fileName":"1575092511.txt","sourceCode":"import bisect\nfrom collections import defaultdict\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        temp = defaultdict(list)\n        for i, j in enumerate(nums):\n            temp[j].append(i)\n    \n        for i in temp:\n            temp[i].sort()\n        \n        res = []\n        for q in queries:\n            v = nums[q]\n            if len(temp[v]) == 1:\n                res.append(-1)\n                continue\n    \n            pos = bisect.bisect_left(temp[v], q)\n    \n            idxL = temp[v][pos-1] if pos > 0 else temp[v][-1]\n            idxR = temp[v][pos+1] if pos+1 < len(temp[v]) else temp[v][0]\n            res.append(min(min(abs(q-idxL), n-abs(q-idxL)), min(abs(q-idxR), n-abs(q-idxR))))\n        return res","author":"Varun Agnihotri","submissionId":"1575092511"},[]]},{"28":[{"id":"28","fileName":"1575093099.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n=len(nums)\n        mprev = {}\n        dist=[n+1]*n\n        for i,v in enumerate(nums):\n            if v in mprev: \n                j = mprev[v]\n                dist[i] = min(dist[i], i-j)\n                dist[j] = min(dist[j], i-j)\n            mprev[v] = i\n        for i,v in enumerate(nums):\n            j = mprev[v]\n            dist[i] = min(dist[i], i-j+n)\n            dist[j] = min(dist[j], i-j+n)\n        # print(dist)\n        for i,v in enumerate(dist):\n            if v>=n: dist[i]=-1\n        return [dist[i] for i in queries]\n        ","author":"Nguyễn Thảo","submissionId":"1575093099"},[]]},{"29":[{"id":"29","fileName":"1575092221.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        by_val = collections.defaultdict(list)\n        for i, num in enumerate(nums):\n            by_val[num].append(i)\n\n        N = len(nums)\n        def distance(x, y):\n            delta = abs(x - y)\n            return min(delta, N - delta)\n\n        ret = []\n        for q in queries:\n            v = nums[q]\n            lst = by_val[v]\n            L = len(lst)\n            if L == 1:\n                ret.append(-1)\n                continue\n            j = bisect.bisect_left(lst, q)\n            dist = 1<<34\n            dist2 = distance(lst[(j + 1) % L], q)\n            dist = min(dist, dist2)\n            dist2 = distance(lst[(j - 1 + L) % L], q)\n            dist = min(dist, dist2)\n            ret.append(dist)\n        return ret\n","author":"HardCoreSWE","submissionId":"1575092221"},[]]},{"31":[{"id":"31","fileName":"1575093120.txt","sourceCode":"template<typename T> void cmin(T &x,const T &y) { if(y<x) x=y; }\ntemplate<typename T> void cmax(T &x,const T &y) { if(x<y) x=y; }\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& qs) {\n        int n = a.size(), q = qs.size();\n\n        for (int i = 0; i < n; i++) {\n            a.push_back(a[i]);\n        }\n\n        vector<int> near(n, n * 2);\n        map<int, int> lst;\n        for (int i = 0; i < n * 2; i++) {\n            if (lst.count(a[i])) {\n                cmin(near[i % n], i - lst[a[i]]); \n            }\n            lst[a[i]] = i;\n        }\n        lst.clear();\n        for (int i = n * 2 - 1; i >= 0; i--) {\n            if (lst.count(a[i])) {\n                cmin(near[i % n], lst[a[i]] - i); \n            }\n            lst[a[i]] = i;\n        }\n\n        vector<int> ans(q);\n        for (int i = 0; i < q; i++) {\n            ans[i] = near[qs[i]];\n            if (ans[i] == n) ans[i] = -1;\n        }\n        return ans;\n    }\n};","author":"OTTFF","submissionId":"1575093120"},[]]},{"32":[{"id":"32","fileName":"1575093221.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> mp;\n        int n = nums.size();\n        for (int i = 0; i < 3 * n; i++) {\n            int x = nums[i % n];\n            mp[x].push_back(i);\n        }\n        vector<int> sol;\n        for (int q : queries) {\n            int x = nums[q];\n            q += n;\n            auto& v = mp[x];\n            auto i = lower_bound(v.begin(), v.end(), q) - v.begin();\n            int dl = q - v[i - 1];\n            int dr = v[i + 1] - q;\n            int d = min(dl, dr);\n            sol.push_back(d == n ? -1 : d);\n        }\n        return sol;\n    }\n};","author":"Shik Chen","submissionId":"1575093221"},[]]},{"33":[{"id":"33","fileName":"1575092678.txt","sourceCode":"class Solution {\n    fun solveQueries(a: IntArray, b: IntArray): List<Int> {\n        val m = mutableMapOf<Int, MutableList<Int>>()\n        val n = a.size\n        for(i in 0 until n) m.getOrPut(a[i]) { mutableListOf() }.add(i)\n        for(k in m.keys) m[k]!!.sort()\n        val r = mutableListOf<Int>()\n        for(i in b) {\n            val v = a[i]\n            val l = m[v]!!\n            if(l.size==1){ r.add(-1); continue }\n            val p = l.binarySearch(i)\n            var d = Int.MAX_VALUE\n            val l1 = if(p==0) l.last() else l[p-1]\n            d = minOf(d, minOf(Math.abs(i-l1), n-Math.abs(i-l1)))\n            val l2 = if(p==l.size-1) l.first() else l[p+1]\n            d = minOf(d, minOf(Math.abs(i-l2), n-Math.abs(i-l2)))\n            r.add(d)\n        }\n        return r\n    }\n}\n","author":"dkasd_12","submissionId":"1575092678"},[]]},{"34":[{"id":"34","fileName":"1575091861.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        prev_pos = [None] * n\n        next_pos = [None] * n\n        found = {}\n        for i, num in enumerate(nums):\n            if num in found:\n                prev_pos[i] = found[num]\n            found[num] = i\n        for i, num in enumerate(nums):\n            if num in found and prev_pos[i] is None:\n                prev_pos[i] = found[num]\n        found = {}\n        for i in range(n-1, -1, -1):\n            num = nums[i]\n            if num in found:\n                next_pos[i] = found[num]\n            found[num] = i\n        for i in range(n-1, -1, -1):\n            num = nums[i]\n            if num in found and next_pos[i] is None:\n                next_pos[i] = found[num]\n        def d(i, j):\n            result = abs(i - j)\n            result = min(result, n - result)\n            if result == 0:\n                return -1\n            return result\n        result = []\n        for q in queries:\n            left_res = d(q, prev_pos[q])\n            right_res = d(q, next_pos[q])\n            result.append(min(left_res, right_res))\n        return result\n\n\n        ","author":"swrush98","submissionId":"1575091861"},[]]},{"36":[{"id":"36","fileName":"1575093748.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        ind = collections.defaultdict(list)\n        n = len(nums)\n        for i,v in enumerate(nums):\n            ind[v] += [i-n, i, i+n]\n            \n        for row in ind.values():\n            row.sort()\n            \n        res = []\n        for _,q in enumerate(queries):\n            v = nums[q]\n            i = bisect.bisect_left(ind[v], q)\n            tmp = n\n            # print(i, q, ind[v], ind[v][i+1] if i+1 < len(ind[v]) else 0)\n            if i + 1 < len(ind[v]):\n                tmp = min(tmp, ind[v][i+1] - q)\n            if i-1 >= 0:\n                tmp = min(tmp, q-ind[v][i-1])\n            # print(q, tmp)\n                \n            res += [tmp if tmp != n else -1]\n        return res\n            ","author":"peichaoD","submissionId":"1575093748"},[]]},{"38":[{"id":"38","fileName":"1575094094.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), k = queries.size();\n        vector<int> result(k);\n        unordered_map<int, vector<int>> indices;\n        for(int i = 0; i < n; ++i) indices[nums[i]].push_back(i);\n        for(int i = 0; i < k; ++i) {\n            int j = queries[i];\n            auto& vec = indices[nums[j]];\n            if(vec.size() == 1) result[i] = -1;\n            else {\n                int lo = 0, hi = vec.size() - 1;\n                while(lo != hi) {\n                    int mid = (lo + hi) / 2;\n                    if(vec[mid] >= j) hi = mid;\n                    else lo = mid + 1;\n                }\n                result[i] = min(\n                    lo < vec.size() - 1 ? vec[lo + 1] - vec[lo] : n - vec[lo] + vec[0],\n                    lo > 0 ? vec[lo] - vec[lo - 1] : vec[lo] + n - vec.back()\n                );\n            }\n        }\n        return result;\n    }\n};","author":"Stanley Jian","submissionId":"1575094094"},[]]},{"39":[{"id":"39","fileName":"1575094310.txt","sourceCode":"from collections import defaultdict\nfrom bisect import bisect_left\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        pos = defaultdict(list)\n        for i, n in enumerate(nums):\n            pos[n].append(i)\n        res = []\n        for q in queries:\n            v = nums[q]\n            idx = pos[v]\n            if len(idx) == 1:\n                res.append(-1)\n            else:\n                i = bisect_left(idx, q)\n                li = idx[(i-1 + len(idx)) % len(idx)]\n                ri = idx[(i+1) % len(idx)]\n                res.append(min(min(abs(q-li), len(nums)-abs(q-li)), min(abs(ri-q), len(nums)-abs(ri-q))))\n        return res\n                ","author":"Siddh","submissionId":"1575094310"},[]]},{"40":[{"id":"40","fileName":"1575094605.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        ans = [inf] * n\n        prev = {}\n        for i, x in enumerate(nums):\n            prev[x] = i\n        for i, x in enumerate(nums):\n            j = prev[x]\n            ans[i] = min(ans[i], (i - j) % n, (j - i) % n)\n            ans[j] = min(ans[j], (i - j) % n, (j - i) % n)\n            prev[x] = i\n        return [ans[i] if ans[i] != 0 else -1 for i in queries]","author":"Haoyu Weng","submissionId":"1575094605"},[]]},{"41":[{"id":"41","fileName":"1575094195.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        first = defaultdict(int)\n        for i in range(len(nums)):\n            if nums[i] not in first:\n                first[nums[i]] = i\n        last = defaultdict(int)\n        n = len(nums)\n        for i in range(len(nums)):\n            last[nums[i]] = i\n        f = [-1]*n\n        ct1 = defaultdict(lambda: -1)\n        for i in range(len(nums)):\n            f[i] = ct1[nums[i]]\n            ct1[nums[i]] = i\n        r = [-1]*n\n        ct2 = defaultdict(lambda: -1)\n        for i in range(len(nums) - 1, -1, -1):\n            r[i] = ct2[nums[i]]\n            ct2[nums[i]] = i\n        res = []\n        for i in queries:\n            d = -1\n            if f[i]!=-1:\n                d = i - f[i]\n            if r[i]!=-1:\n                if d==-1 or r[i] - i < d:\n                    d = r[i] - i\n            #print(last[\n            if first[nums[i]]!=i:\n                if d==-1 or len(nums) - i + first[nums[i]] < d:\n                    d = len(nums) - i + first[nums[i]]\n            if last[nums[i]]!=i:\n                if d==-1 or i + len(nums) - last[nums[i]] < d:\n                    d = i + len(nums) - last[nums[i]]\n            res.append(d)\n        return res","author":"jacobj2","submissionId":"1575094195"},[]]},{"42":[{"id":"42","fileName":"1575094848.txt","sourceCode":"class Solution:\n    def solveQueries(self, a: List[int], queries: List[int]) -> List[int]:\n        n = len(a)\n\n        aaa = a+a+a\n\n        # val -> sorted occurrences by idx\n        occurrences = defaultdict(list)\n\n        for i,x in enumerate(aaa):\n            occurrences[x].append(i)\n\n        # print(occurrences)\n\n        # query the middle\n\n        # srfind?\n\n        # bisect_left[targ] - 1 I think\n        # you are guaranteed to find something\n\n        # O(nlogn)\n\n        ret = []\n\n        for idx in queries:\n            idx = idx + n\n            x = aaa[idx]\n\n            xoccurrences = occurrences[x]\n\n            left = xoccurrences[bisect_left(xoccurrences, idx) - 1]\n            right = xoccurrences[bisect_right(xoccurrences, idx)]\n\n            left_dist = idx - left\n            right_dist = right - idx\n\n            if left_dist == n:\n                ret.append(-1)\n            else:\n                ret.append(min(left_dist, right_dist))\n\n        return ret\n","author":"david_hoengy","submissionId":"1575094848"},[]]},{"43":[{"id":"43","fileName":"1575094209.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> a = nums;\n        for (int i = 0; i < nums.size(); ++i) {\n            a.push_back(nums[i]);\n        }\n        \n        map<int, int> pos;\n        vector<int> next(a.size(), -1), prev(a.size(), -1);\n        for (int i = a.size() - 1; i >= 0; --i) {\n            if (pos.count(a[i])) {\n                next[i] = pos[a[i]];\n            }\n            pos[a[i]] = i;\n        }\n        pos.clear();\n        for (int i = 0; i < a.size(); ++i) {\n            if (pos.count(a[i])) {\n                prev[i] = pos[a[i]];\n            }\n            pos[a[i]] = i;\n        }\n        \n        vector<int> ans;\n        for (int v : queries) {\n            int dis = nums.size();\n            if (next[v] != -1) {\n                dis = next[v] - v;\n            }\n            if (prev[v + nums.size()] != -1) {\n                dis = min(dis, v + (int) nums.size() - prev[v + nums.size()]);\n            }\n            if (dis == nums.size()) {\n                dis = -1;\n            }\n            ans.push_back(dis);\n        }\n        return ans;\n    }\n};","author":"Yang Xiao","submissionId":"1575094209"},[]]},{"44":[{"id":"44","fileName":"1575093878.txt","sourceCode":"class Solution {\npublic:\n    unordered_map<int, vector<int> > f;\n    int n;\n    \n    int dist(int q){\n        q = labs(q);\n        return min(q, n - q);\n    }\n    \n    vector<int> solveQueries(vector<int>& a, vector<int>& Q) {\n        n = a.size();\n        int i, r, w, L;\n        f = unordered_map<int, vector<int> >();\n        for (i = 0; i < n; ++i) f[a[i]].push_back(i);\n        vector<int> res;\n        for (auto q : Q){\n            w = lower_bound(f[a[q]].begin(), f[a[q]].end(), q) - f[a[q]].begin();\n            L = f[a[q]].size();\n            if (L == 1){\n                res.push_back(-1);\n                continue;\n            }\n            r = min(dist(q - f[a[q]][(w + L - 1) % L]), dist(q - f[a[q]][(w + 1) % L]));\n            res.push_back(r);\n        }\n        \n        return res;\n    }\n};","author":"Ma Lin","submissionId":"1575093878"},[]]},{"45":[{"id":"45","fileName":"1575094518.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        \n        balson = defaultdict(list)\n        for i in range(len(nums)):\n            balson[nums[i]].append(i)\n        \n        ans = []\n        \n        \n        def dist(x, y, leng):\n            print(x, y, leng)\n            dx = min(x, y)\n            dy = max(x, y)\n            \n            return min(dy - dx, (leng - dy + dx))\n            \n        \n        leng = len(nums)\n        \n        print(balson)\n        \n        \n        \n        for jh in range(len(queries)):\n            ea = queries[jh]\n            if len(balson[nums[ea]]) == 1:\n                ans.append(-1)\n                print('hit')\n                continue\n            else:\n                bas = bisect.bisect_left(balson[nums[ea]], ea)\n                \n                \n                botalov = balson[nums[ea]][bas - 1]\n                topalov = balson[nums[ea]][(bas + 1) % len(balson[nums[ea]])]\n                ans.append(min(dist(ea, botalov, leng), dist(ea, topalov, leng)))\n        return ans\n                \n                \n                \n        ","author":"JJZin","submissionId":"1575094518"},[]]},{"46":[{"id":"46","fileName":"1575095040.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        g=defaultdict(list)\n        n=len(nums)\n        for i,x in enumerate(nums):\n            g[x].append(i)\n            g[x].append(n+i)\n            g[x].append(2*n+i)\n        for x in g:\n            g[x].sort()\n        ans=[]\n        for i in queries:\n            a=g[nums[i]]\n            if len(a)<=3:\n                ans.append(-1)\n                continue\n            cur=n+i\n            pos=bisect_left(a,cur)\n            ans.append(min(a[pos]-a[pos-1],a[pos+1]-a[pos]))\n        return ans","author":"Sandeep P","submissionId":"1575095040"},[]]},{"47":[{"id":"47","fileName":"1575095375.txt","sourceCode":"class Solution:\n    def solveQueries(self, A: List[int], Q: List[int]) -> List[int]:\n        idxs = defaultdict(list)\n        for i, x in enumerate(A):\n            idxs[x].append(i)\n        res = []\n        n = len(A)\n        dis = lambda i, j: min(abs(i-j), min(i, j) + n - max(i, j))\n        for q in Q:\n            x = A[q]\n            if len(idxs[x]) <= 1:\n                res.append(-1)\n            else:\n                I = idxs[x]\n                i = bisect_left(I, q)\n                m = len(I)\n                res.append(min(dis(I[i], I[(i-1)%m]), dis(I[(i+1)%m], I[i])))\n        return res","author":"delphih","submissionId":"1575095375"},[]]},{"48":[{"id":"48","fileName":"1575095142.txt","sourceCode":"from sortedcontainers import SortedList\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        idcs = defaultdict(list)\n        for i,x in enumerate(nums):\n            idcs[x].append(i)\n        res = []\n        for i,q in enumerate(queries):\n            x = nums[q]\n            l = idcs[x]\n            if len(l)==1:\n                res.append(-1)\n                continue\n            idx = bisect_left(l, q)\n            lb = l[(idx-1)%len(l)]\n            r = l[(idx+1)%len(l)]\n            msf = min((q-lb)%n, (r-q)%n)\n            res.append(msf)\n        return res","author":"glump1","submissionId":"1575095142"},[]]},{"50":[{"id":"50","fileName":"1575095370.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = {}\n        n = len(nums)\n        for i in range(n):\n            if d.get(nums[i]) == None: d[nums[i]] = list()\n            d[nums[i]].append(i)\n        ans = [-1]*n\n        for i in d.keys():\n            if len(d[i]) > 1:\n                m = len(d[i])\n                for j in range(m):\n                    v = d[i][j]\n                    va = abs(v-d[i][(j+1) % m])\n                    vb = abs(v-d[i][(j-1) % m])\n                    ans[v] = min(va,n-va,vb,n-vb)\n        #print(d)\n        bans = list()\n        for q in queries:\n            bans.append(ans[q])\n        return bans","author":"Alexander Wen","submissionId":"1575095370"},[]]},{"51":[{"id":"51","fileName":"1575095737.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        num_indexes = defaultdict(list)\n        for i in range(len(nums)):\n            num_indexes[nums[i]].append(i)\n\n        # now go through queries\n        result = []\n        for idx in queries:\n            # go to corresponding num\n            corresponding = num_indexes[nums[idx]]\n            if len(corresponding) > 1:\n                # find corresponding\n                locat = bisect.bisect_left(corresponding, idx)\n                # now go either left or right\n                left_dist = float('inf')\n                if locat - 1 >= 0:\n                    left_dist = idx - corresponding[locat-1]\n                else:\n                    # it wraps around\n                    left_dist = len(nums)-corresponding[-1]+idx\n                right_dist = float('inf')\n                if locat + 1 < len(corresponding):\n                    right_dist = corresponding[locat+1] - idx\n                else:\n                    # wrap around\n                    right_dist = len(nums)-idx + corresponding[0]\n                # print(\"for\", idx, left_dist, right_dist)\n                result.append(min(left_dist, right_dist))\n            else:\n                result.append(-1)\n\n        return result","author":"Eliot H","submissionId":"1575095737"},[]]},{"53":[{"id":"53","fileName":"1575096413.txt","sourceCode":"use std::collections::HashMap;\nimpl Solution {\n    pub fn solve_queries(nums: Vec<i32>, queries: Vec<i32>) -> Vec<i32> {\n        let n = nums.len();\n        let mut map: HashMap<i32, Vec<usize>> = HashMap::new();\n        for (i, &x) in nums.iter().enumerate() {\n            map.entry(x).or_default().push(i);\n        }\n        for v in map.values_mut() {\n            v.sort_unstable();\n        }\n        queries\n            .into_iter()\n            .map(|q| {\n                let i = q as usize;\n                let x = nums[i];\n                let v = &map[&x];\n                if v.len() < 2 {\n                    return -1;\n                }\n                let p = v.binary_search(&i).unwrap();\n                let l = if p > 0 { v[p - 1] } else { *v.last().unwrap() };\n                let r = if p + 1 < v.len() { v[p + 1] } else { v[0] };\n                let dl = if i >= l { i - l } else { i + n - l };\n                let dr = if r >= i { r - i } else { r + n - i };\n                dl.min(dr) as i32\n            })\n            .collect()\n    }\n}","author":"parallel_stream","submissionId":"1575096413"},[]]},{"54":[{"id":"54","fileName":"1575095432.txt","sourceCode":"#define sz(x) int(size(x))\n#define all(x) (x).begin(),(x).end()\n#define lb(x, v) (lower_bound(all(x), v) - (x).begin())\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& queries) {\n        int N = int(size(a));\n        map<int,vector<int>> idx;\n        for(int i = 0; int& x: a) {\n            idx[x].emplace_back(i++);\n        }\n        int Q = int(size(queries));\n        vector<int> ret(Q, -1);\n        for(int i = 0; auto& pos: queries) {\n            int v = a[pos];\n            auto& vec = idx[v];\n            if(sz(vec) == 1) {\n                i++;\n                continue;\n            }\n            int lb = lb(vec, pos);\n\n            int cand = N;\n            int nxt = (lb + sz(vec)-1)%sz(vec);\n            \n            int d = abs(vec[lb] - vec[nxt]);\n            cand = min(cand, min(d, N-d));\n\n            nxt = (lb + 1) % sz(vec);\n            d = abs(vec[lb] - vec[nxt]);\n            cand = min(cand, min(d, N-d));\n            \n            ret[i++] = cand;\n        }\n\n        return ret;\n    }\n};","author":"raararaara","submissionId":"1575095432"},[]]},{"55":[{"id":"55","fileName":"1575096564.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = defaultdict(list)\n        for i, x in enumerate(nums):\n            d[x].append(i)\n        ans = []\n        for q in queries:\n            x = nums[q]\n            l = d[x]\n            if len(l) == 1:\n                ans.append(-1)\n                continue\n            index = bisect.bisect_left(l, q)\n            best = inf\n            if index + 1 < len(l):\n                best = l[index + 1] - q\n            else:\n                best = l[0] + len(nums) - q\n            if index:\n                best = min(best, q - l[index - 1])\n            else:\n                best = min(best, q + len(nums) - l[-1])\n            ans.append(best)\n        return ans\n","author":"Chuan-Chih Chou","submissionId":"1575096564"},[]]},{"57":[{"id":"57","fileName":"1575096550.txt","sourceCode":"from collections import defaultdict\nimport bisect\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n\n        pos = defaultdict(list)\n        for idx, num in enumerate(nums):\n            pos[num].append(idx)\n        \n        result = []\n        for query in queries:\n            value = nums[query]\n            indices = pos[value]\n            \n            if len(indices) < 2:\n                result.append(-1)\n                continue\n            \n            i = bisect.bisect_left(indices, query)\n            \n            left_index = indices[i - 1] if i > 0 else indices[-1]\n            right_index = indices[i + 1] if i + 1 < len(indices) else indices[0]\n            \n            d_left = (query - left_index) % n\n            d_right = (right_index - query) % n\n            \n            result.append(min(d_left, d_right))\n        \n        return result","author":"Mohak Acharya","submissionId":"1575096550"},[]]},{"58":[{"id":"58","fileName":"1575096595.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> vec;\n        for(int i = 0; i < nums.size(); i++) vec[nums[i]].push_back(i);\n        vector<int> dist(nums.size(), -1);\n        int n = nums.size();\n        for(auto [_, a]: vec){\n            for(int i = 0; i < a.size(); i++){\n                int x = (a[i] - a[(i + a.size() - 1) % a.size()] + n + n) % n;\n                int y = (a[(i + 1) % a.size()] - a[i] + n + n) % n;\n                if(x == 0) x = n;\n                if(y == 0) y = n;\n                dist[a[i]] = min(x, y);\n                if(dist[a[i]] == n) dist[a[i]] = -1;\n            }\n        }\n        vector<int> ans;\n        for(int x: queries) ans.push_back(dist[x]);\n        return ans;\n    }\n};","author":"Daulet","submissionId":"1575096595"},[{"id":"1545","similarity":0.7032967032967034,"totOverlap":128,"longestOverlap":18}]],"1545":[{"id":"1545","fileName":"611236159.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int size = nums.size();\n        unordered_map<int, vector<int>> um;\n        for (int i = 0; i < size; ++i) {\n            um[nums[i]].push_back(i);\n        }\n        vector<int> ans(size, 0);\n        for (auto it = um.begin(); it != um.end(); ++it) {\n            vector<int>& v = it->second;\n            int vsize = v.size();\n            for (int i = 0; i < vsize; ++i) {\n                \n                int pre = (v[i] - v[(i - 1 + vsize) % vsize] + size) % size;\n                int next = (v[(i + 1) % vsize] - v[i] + size) % size;\n\n                if (pre == 0) pre = INT_MAX;\n                if (next == 0) next = INT_MAX;\n\n                \n                // int pre = i - 1 < 0 ? INT_MAX : min(v[i] - v[i - 1], v[i - 1] - v[i] + size);\n                // int next = i + 1 >= vsize ? INT_MAX : min(v[i + 1] - v[i], v[i] - v[i + 1] + size);\n                \n                ans[v[i]] = min(pre, next);\n                \n                if (ans[v[i]] == INT_MAX) ans[v[i]] = -1;\n            }\n        }\n        vector<int> rtn(q.size(), 0);\n        for (int i = 0; i < q.size(); ++i) {\n            rtn[i] = ans[q[i]];\n        }\n        return rtn;\n    }\n};","author":"jushuai_lfx","submissionId":"611236159"},[{"id":"58","similarity":0.7032967032967034,"totOverlap":128,"longestOverlap":18}]]},{"59":[{"id":"59","fileName":"1575096760.txt","sourceCode":"class Solution\n{\npublic:\n  vector<int> solveQueries(vector<int> &nums, vector<int> &queries)\n  {\n    map<int, vector<int>> mp;\n    int n = nums.size(), m, r, l;\n    vector<int> d(n, -1);\n    for (int i = 0; i < n; i++)\n    {\n      mp[nums[i]].push_back(i);\n    }\n\n    for (auto &it : mp)\n    {\n      auto &v = it.second;\n      sort(v.begin(), v.end());\n      m = v.size();\n      if (m == 1)\n      {\n        continue;\n      }\n      for (int i = 0; i < m; i++)\n      {\n        r = (i == m - 1 ? n - v[i] + v[0] : v[i + 1] - v[i]);\n        l = (i == 0 ? n - v[m - 1] + v[i] : v[i] - v[i - 1]);\n\n        d[v[i]] = min(l, r);\n      }\n    }\n    vector<int> ans;\n    for (auto &it : queries)\n    {\n      ans.push_back(d[it]);\n    }\n    return ans;\n  }\n};","author":"Khushal Midha","submissionId":"1575096760"},[]]},{"60":[{"id":"60","fileName":"1575096121.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, TreeSet<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (!map.containsKey(nums[i])) {\n                map.put(nums[i], new TreeSet<>());\n            }\n            map.get(nums[i]).add(i);\n        }\n        ArrayList<Integer> ans = new ArrayList<>();\n        for (int i = 0; i < queries.length; i++) {\n            TreeSet<Integer> set = map.get(nums[queries[i]]);\n            if (set.size() == 1) {\n                ans.add(-1);\n                continue;\n            }\n            int x = Integer.MAX_VALUE;\n            if (set.lower(queries[i]) != null) {\n                x = Math.min(x, queries[i] - set.lower(queries[i]));\n            }\n            else {\n                x = Math.min(x, nums.length - (set.last() - queries[i]));\n            }\n            if (set.higher(queries[i]) != null) {\n                x = Math.min(x, set.higher(queries[i]) - queries[i]);\n            }\n            else {\n                x = Math.min(x, nums.length - (queries[i] - set.first()));\n            }\n            if (x == Integer.MAX_VALUE) ans.add(-1);\n            else ans.add(x);\n        }\n        return ans;\n    }\n}","author":"Victor Liu","submissionId":"1575096121"},[]]},{"61":[{"id":"61","fileName":"1575097261.txt","sourceCode":"constexpr int MAXN = 200010;\nconstexpr int MAXM = 1000100;\n\nint a[MAXN], pre[MAXN], nxt[MAXN], p[MAXM];\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n      int n = nums.size();\n      for (int i = 0; i < n; ++i) {\n        a[i] = nums[i];\n        a[i + n] = nums[i];\n      }\n      for (int x : nums) {\n        p[x] = -1;\n      }\n      for (int i = 0; i < 2 * n; ++i) {\n        pre[i] = p[a[i]];\n        p[a[i]] = i;\n      }\n      for (int x : nums) {\n        p[x] = -1;\n      }\n      for (int i = 2 * n - 1; i >= 0; --i) {\n        nxt[i] = p[a[i]];\n        p[a[i]] = i;\n      }\n      int m = queries.size();\n      vector<int> ret(m);\n      for (int i = 0; i < m; ++i) {\n        int x = queries[i];\n        int l = pre[x + n], r = nxt[x];\n        l = l == -1 ? -1 : (x + n - l < n ? x + n - l : -1);\n        r = r == -1 ? -1 : (r - x < n ? r - x : -1);\n        if (l == -1 && r == -1) {\n          ret[i] = -1;\n        } else if (l == -1) {\n          ret[i] = r;\n        } else if (r == -1) {\n          ret[i] = l;\n        } else {\n          ret[i] = min(l, r);\n        }\n      }\n      return ret;\n    }\n};","author":"Xiaomeng Yang","submissionId":"1575097261"},[]]},{"62":[{"id":"62","fileName":"1575096782.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        pos = {}\n        for i, val in enumerate(nums):\n            if val not in pos:\n                pos[val] = []\n            pos[val].append(i)\n        \n        res = []\n        for q in queries:\n            v = nums[q]\n            ind = pos[v]\n            if len(ind) == 1:\n                res.append(-1)\n                continue\n            \n            posi = bisect.bisect_left(ind, q)\n            \n            left = ind[posi - 1] if posi - 1 >= 0 else ind[-1]\n            right = ind[posi + 1] if posi + 1 < len(ind) else ind[0]\n            \n            dl = abs(q - left)\n            dl = min(dl, n - dl)\n            dr = abs(q - right)\n            dr = min(dr, n - dr)\n            \n            res.append(min(dl, dr))\n        \n        return res","author":"Cry Andrich","submissionId":"1575096782"},[{"id":"1186","similarity":0.7983870967741935,"totOverlap":99,"longestOverlap":15},{"id":"1454","similarity":0.775,"totOverlap":93,"longestOverlap":19}]],"1186":[{"id":"1186","fileName":"1575135365.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        from collections import defaultdict\n        import bisect\n        n = len(nums)\n        pos = defaultdict(list)\n        for i, x in enumerate(nums):\n            pos[x].append(i)\n        ans = []\n        for q in queries:\n            x = nums[q]\n            lst = pos[x]\n            if len(lst) == 1:\n                ans.append(-1)\n            else:\n                idx = bisect.bisect_left(lst, q)\n                left = lst[idx - 1] if idx > 0 else lst[-1]\n                right = lst[idx + 1] if idx + 1 < len(lst) else lst[0]\n                dleft = abs(q - left)\n                dright = abs(right - q)\n                dleft = min(dleft, n - dleft)\n                dright = min(dright, n - dright)\n                ans.append(min(dleft, dright))\n        return ans\n","author":"Nikhil2979","submissionId":"1575135365"},[{"id":"62","similarity":0.7983870967741935,"totOverlap":99,"longestOverlap":15}]],"1454":[{"id":"1454","fileName":"611233672.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        from bisect import bisect_left\n        n = len(nums)\n        mapping = {}\n        for idx, num in enumerate(nums):\n            if num not in mapping:\n                mapping[num] = []\n            mapping[num].append(idx)\n        \n        ans = []\n        for q in queries:\n            target = nums[q]\n            pos_list = mapping[target]\n            if len(pos_list) == 1:\n                ans.append(-1)\n                continue\n            \n            pos = bisect_left(pos_list, q)\n\n            prev_index = pos_list[pos - 1] \n            next_index = pos_list[(pos + 1) % len(pos_list)]\n            \n            d1 = abs(q - prev_index)\n            d1 = min(d1, n - d1)\n            \n            d2 = abs(q - next_index)\n            d2 = min(d2, n - d2)\n            \n            ans.append(min(d1, d2))\n            \n        return ans\n        ","author":"srrrrr","submissionId":"611233672"},[{"id":"62","similarity":0.775,"totOverlap":93,"longestOverlap":19}]]},{"63":[{"id":"63","fileName":"1575097324.txt","sourceCode":"class Solution {\npublic:\n  vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n    const int n = nums.size();\n    unordered_map<int, vector<int>> idx;\n    for (int i = 0; i < n; ++i) {\n      idx[nums[i]].push_back(i);\n    }\n\n    vector<int> dist(n);\n    for (const auto& kv : idx) {\n      const int k = kv.first;\n      const auto& v = kv.second;\n      const int m = v.size();\n      if (m == 1) {\n        dist[v[0]] = -1;\n      }\n      else {\n        for (int i = 0; i < m; ++i) {\n          int dl = v[i] - (i == 0 ? v.back() - n : v[i - 1]);\n          int dr = (i == m - 1 ? v.front() + n : v[i + 1]) - v[i];\n          dist[v[i]] = min(dl, dr);\n        }\n      }\n    }\n\n    vector<int> ret;\n    ret.reserve(queries.size());\n    for (int q : queries) {\n      ret.push_back(dist[q]);\n    }\n    return ret;\n  }\n};","author":"Zejun Wu","submissionId":"1575097324"},[]]},{"64":[{"id":"64","fileName":"1575096713.txt","sourceCode":"from bisect import bisect_left\nclass Solution:\n    def solveQueries(self, a: List[int], q: List[int]) -> List[int]:\n        d = defaultdict(list)\n        n = len(a)\n        for i in range(n):\n            v = a[i]\n            d[v].append(i)\n        ans = []\n        for idxx in q:\n            v = a[idxx]\n            if len(d[v]) == 1:\n                ans.append(-1)\n                continue\n            idx = bisect_left(d[v], idxx)\n            left = d[v][(idx - 1) % len(d[v])]\n            right = d[v][(idx + 1) % len(d[v])]\n            mn = abs(idxx - left)\n            mn = min(mn, abs(idxx - right))\n            mn = min(mn, min(idxx, left) + 1 + n - max(idxx, left) - 1)\n            mn = min(mn, min(idxx, right) + 1 + n - max(idxx, right) - 1)\n            ans.append(mn)\n        return ans","author":"Manan Rathod","submissionId":"1575096713"},[]]},{"65":[{"id":"65","fileName":"1575097269.txt","sourceCode":"typedef pair<int, int> pii;\nclass Solution {\nprivate:\n    void update(int& mi, int x) {\n        if (mi == -1) mi = x;\n        else mi = min(mi, x);\n    }\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<int> dist(n, -1);\n        unordered_map<int, pii> locs{};\n        for(int i = 0; i < n; i++) {\n            if (!locs.count(nums[i])) {\n                locs[nums[i]] = make_pair(i, i);\n            } else {\n                update(dist[locs[nums[i]].second], i - locs[nums[i]].second);\n                update(dist[i], i - locs[nums[i]].second);\n                locs[nums[i]].second = i;\n            }\n        }\n        for(auto [x, loc]: locs) {\n            auto [first, last] = loc;\n            if (first == last) continue;\n            update(dist[first], first - last + n);\n            update(dist[last], first - last + n);\n        }\n        vector<int> ans{};\n        for(int j = 0; j < m; j++) {\n            ans.push_back(dist[queries[j]]);\n        }\n        return ans;\n    }\n};","author":"Yucheng Dai","submissionId":"1575097269"},[]]},{"67":[{"id":"67","fileName":"1575097395.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = size(nums);\n        map<int, vector<int>> m;\n        for (int i = 0; i < n; i++) {\n            m[nums[i]].push_back(i);\n        }\n        \n        vector<int> ans;\n        for (int i : queries) {\n            vector<int>& v = m[nums[i]];\n            if (size(v) == 1) {\n                ans.push_back(-1);\n            } else {\n                int k = lower_bound(begin(v), end(v), i) - begin(v);\n                cout << i << ' ' << k << endl;\n                int mn = n;\n                if (k > 0) mn = min(mn, v[k] - v[k - 1]);\n                else mn = min(mn, v[k] + n - v.back());\n                if (k + 1 < size(v)) mn = min(mn, v[k + 1] - v[k]);\n                else mn = min(mn, n - v[k] + v[0]);\n                ans.push_back(mn);\n            }\n        }\n        return ans;\n    }\n};","author":"cole","submissionId":"1575097395"},[]]},{"69":[{"id":"69","fileName":"1575097610.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n\n        n = len(nums)\n\n        d = defaultdict(list)\n        dist = []\n        for i, num in enumerate(nums):\n            if not d[num]:\n                dist.append(-1)\n            else:\n                first, last = d[num][0], d[num][-1]\n                if dist[first] != -1:\n                    dist[first] = min(dist[first], n - i + first)\n                else:\n                    dist[first] = n - i + first\n\n                if dist[last] != -1:\n                    dist[last] = min(dist[last], i - last)\n                else:\n                    dist[last] = i - last\n\n                dist.append(min(n - i + first, i - last))\n                \n            d[num].append(i)\n\n        res = []\n        for idx in queries:\n            res.append(dist[idx])\n        return res","author":"Shuqi Shang","submissionId":"1575097610"},[]]},{"70":[{"id":"70","fileName":"1575097359.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        ind = defaultdict(SortedList)\n        for i, x in enumerate(nums):\n            ind[x].add(i)\n        \n        ans = []\n        for q in queries:\n            if len(ind[nums[q]]) == 1:\n                ans.append(-1)\n                continue\n            \n            idx = ind[nums[q]].bisect_left(q)\n            left = ind[nums[q]][idx - 1] if idx > 0 else ind[nums[q]][-1]\n            right = ind[nums[q]][idx + 1] if idx < len(ind[nums[q]]) - 1 else ind[nums[q]][0]\n            ans.append(min(abs(q - left), n - abs(q - left), abs(q - right), n - abs(q - right)))\n        \n        return ans","author":"Anchor Being","submissionId":"1575097359"},[]]},{"74":[{"id":"74","fileName":"1575097731.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        indices = defaultdict(list)\n        for i in range(len(nums)):\n            indices[nums[i]].append(i)\n\n        out = []\n        for q in queries:\n            val = nums[q]\n            index = bisect_left(indices[val], q)\n            if len(indices[val]) == 1:\n                out.append(-1)\n            else:\n                #print(indices[val])\n                left = indices[val][(index-1)%len(indices[val])]\n                right = indices[val][(index+1)%len(indices[val])]\n                #print(right)\n                close = min(abs(left-q), abs(right-q), abs(len(nums)-q+right), abs(len(nums)-left+q))\n                out.append(close)\n        return out","author":"Brandon Collins","submissionId":"1575097731"},[]]},{"75":[{"id":"75","fileName":"1575097765.txt","sourceCode":"from typing import List\nimport bisect\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        value_to_indices = {}\n        for idx, value in enumerate(nums):\n            if value not in value_to_indices:\n                value_to_indices[value] = []\n            value_to_indices[value].append(idx)\n        \n        def circular_distance(i: int, j: int) -> int:\n            diff = abs(i - j)\n            return min(diff, n - diff)\n        \n        result = []\n        for query_index in queries:\n            target_value = nums[query_index]\n            indices = value_to_indices[target_value]\n            \n            if len(indices) == 1:\n                result.append(-1)\n                continue\n            \n            pos = bisect.bisect_left(indices, query_index)\n            left_neighbor = indices[pos - 1] if pos > 0 else indices[-1]\n            right_neighbor = indices[pos + 1] if pos < len(indices) - 1 else indices[0]\n            \n            dist_left = circular_distance(query_index, left_neighbor)\n            dist_right = circular_distance(query_index, right_neighbor)\n            \n            result.append(min(dist_left, dist_right))\n        \n        return result\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    \n    nums1 = [1, 3, 1, 4, 1, 3, 2]\n    queries1 = [0, 3, 5]\n    print(\"Example 1 Output:\", solution.solveQueries(nums1, queries1))\n    \n    nums2 = [1, 2, 3, 4]\n    queries2 = [0, 1, 2, 3]\n    print(\"Example 2 Output:\", solution.solveQueries(nums2, queries2))\n","author":"Kamaleswari__P","submissionId":"1575097765"},[]]},{"76":[{"id":"76","fileName":"1575098608.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < nums.size(); i++)mp[nums[i]].push_back(i);\n        for (auto &i : mp)sort(begin(i.second),end(i.second));\n        vector<int> ans;\n        for (int q : queries) {\n            vector<int>& v = mp[nums[q]];\n            if (v.size() < 2) { \n                ans.push_back(-1);\n                continue; \n            }\n            int idx = lower_bound(begin(v),end(v), q) - begin(v);\n            if (v[idx] != q)idx--;\n            int l = v[(idx - 1 + v.size()) % v.size()],r= v[(idx + 1) % v.size()],x = abs(q - l), y = abs(q - r),n=nums.size();\n            ans.push_back(min(min(x, n - x), min(y, n - y)));\n        }\n        return ans;\n    }\n};\n","author":"Shubham Jha","submissionId":"1575098608"},[]]},{"77":[{"id":"77","fileName":"1575097727.txt","sourceCode":"from bisect import bisect_right\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        seen = {}\n        \n        for i, x in enumerate(nums):\n            if x not in seen:\n                seen[x] = [i]\n            else:\n                seen[x].append(i)\n                \n        for v, idx in seen.items():\n            seen[v] = [i - n for i in idx] + idx + [i + n for i in idx]\n            \n        answer = []\n        for idx in queries:\n            x = nums[idx]\n            if len(seen[x]) == 3:\n                answer.append(-1)\n            else:\n                r_idx = bisect_right(seen[x], idx)\n                right = seen[x][r_idx]\n                \n                l_idx = bisect_right(seen[x], idx - 1) - 1\n                left = seen[x][l_idx]\n                \n                answer.append(min(right - idx, idx - left))\n                \n        \n        return answer","author":"Maruzensky","submissionId":"1575097727"},[]]},{"78":[{"id":"78","fileName":"1575098368.txt","sourceCode":"class Solution(object):\n    def solveQueries(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        dic = {}\n        n = len(nums)\n        \n        for i in range(n):\n            if nums[i] not in dic:\n                dic[nums[i]] = []\n                \n            dic[nums[i]].append(i)\n        \n        \n\n        ans = []\n        \n        for q in queries:\n         #   print(nums[q])\n            if len(dic[nums[q]])==1:\n                ans.append(-1)\n            else:\n                temp = dic[nums[q]]\n                loc = bisect.bisect_left(temp, q)\n                \n              #  print(loc,temp)\n                d1 = temp[(loc+1)%len(temp)] - q \n                if d1 < 0:\n                    d1 += n\n                d2 = q - temp[(loc-1)%len(temp)]\n                if d2 < 0:\n                    d2 += n\n                ans.append(min(d1,d2))\n        return ans\n    \n                \n            \n        ","author":"hxu10","submissionId":"1575098368"},[]]},{"79":[{"id":"79","fileName":"1575098561.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = defaultdict(list)\n        for i,c in enumerate(nums):\n            d[c].append(i)\n        ret = []\n        for i in queries:\n            c = nums[i]\n            if len(d[c]) == 1:\n                ret.append(-1)\n                continue\n            idx = bisect_left(d[c], i)\n            v = 1e10\n            if idx < len(d[c]) - 1:\n                v = min(v,d[c][idx+1] - i)\n            else:\n                v = min(v, d[c][0]+len(nums)-i)\n            if idx > 0:\n                v = min(v, i - d[c][idx-1])\n            else:\n                v = min(v, i + len(nums) - d[c][-1])\n            ret.append(v)\n        return ret\n                ","author":"nemokwy","submissionId":"1575098561"},[]]},{"80":[{"id":"80","fileName":"1575098538.txt","sourceCode":"typedef long long ll;\nconst static auto _ = [] { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr; }();\n// Don't forget long long due to overflow !!!!!!!!!\n\nclass Solution {\npublic:\n\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> x(nums.size() * 3);\n        for (int i = 0; i < nums.size(); ++i) {\n            x[i] = x[nums.size() + i] = x[2*nums.size() + i] = nums[i];\n        }\n\n        map<int, vector<int>> pos;\n        for (int i = 0; i < x.size(); ++i) {\n            pos[x[i]].push_back(i);\n        }\n\n        vector<int> tot;\n        for(auto idx : queries) {\n            idx += nums.size();\n            int curr = x[idx];\n            auto & v = pos[curr];\n\n            int ans = INT_MAX;\n            auto it = upper_bound(v.begin(), v.end(), idx);\n            if(it != v.end()) ans = min(ans, *it - idx);\n\n            auto itt = lower_bound(v.begin(), v.end(), idx);\n            if(itt != v.begin()) {\n                --itt;\n                ans = min(ans, idx - *itt);\n            }\n\n            if(ans == INT_MAX || ans == nums.size()) tot.push_back(-1);\n            else tot.push_back(ans);\n        }\n\n        return tot;\n    }\n\n};","author":"Kareem Elgoker","submissionId":"1575098538"},[]]},{"81":[{"id":"81","fileName":"1575098740.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        loc = defaultdict(list)\n        for i, x in enumerate(nums): \n            loc[x].append(i)\n        # print(loc)\n        ans = []\n        for i in queries: \n            x = nums[i]\n            if len(loc[x]) == 1: ans.append(-1)\n            else: \n                k = bisect_left(loc[x], i)\n                lo = (k-1) % len(loc[x])\n                hi = (k+1) % len(loc[x])\n                v1 = abs(i-loc[x][lo])\n                v2 = abs(loc[x][hi]-i)\n                dist = min(v1, n-v1, v2, n-v2)\n                ans.append(dist)\n        return ans ","author":"bnlvv","submissionId":"1575098740"},[]]},{"82":[{"id":"82","fileName":"1575098674.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> dp(nums.size(), INT_MAX);\n        unordered_map<int, int> m;\n        for (int i = 0; i < nums.size(); i++) {\n            int n = nums[i];\n            if (m.count(n)) {\n                int j = m[n];\n                dp[i] = i - j;\n                dp[j] = min(dp[j], i - j);\n            }\n            m[n] = i;\n        }\n        for (int i = 0; i < nums.size(); i++) {\n            int n = nums[i];\n            if (m[n] != i) {\n                int j = m[n];\n                dp[i] = min(dp[i], i + (int)nums.size() - j);\n                dp[j] = min(dp[j], i + (int)nums.size() - j);\n            }\n            m[n] = i;\n        }\n        // for (int i = 0; i < nums.size(); i++) cout << dp[i] << \" \";\n        // cout << endl;\n        vector<int> res;\n        for (int q : queries) {\n            res.push_back(dp[q] == INT_MAX ? -1 : dp[q]);\n        }\n        return res;\n    }\n};","author":"raincoat911","submissionId":"1575098674"},[]]},{"83":[{"id":"83","fileName":"1575098779.txt","sourceCode":"// import java.util.*;\n// import java.util.function.*;\n\n// public class Main {\n//     public static void main(String[] args) throws Exception {\n//         System.out.println(new Solution().solve());\n//     }\n// }\n\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, TreeSet<Integer>> pos = new HashMap<>();\n        int n = nums.length;\n        for (int i = 0; i < n; i++)\n            pos.computeIfAbsent(nums[i], asd -> new TreeSet<>()).add(i);\n\n        List<Integer> ans = new ArrayList<>();\n        for (int i : queries) {\n            var p = pos.get(nums[i]);\n            if (p.size() == 1) {\n                ans.add(-1);\n                continue;\n            }\n\n            int dist = n + 1;\n            if (i == p.first())\n                dist = Math.min(dist, n + i - p.last());\n            else\n                dist = Math.min(dist, i - p.lower(i));\n\n            if (i == p.last())\n                dist = Math.min(dist, n - i + p.first());\n            else\n                dist = Math.min(dist, p.higher(i) - i);\n            ans.add(dist);\n        }\n\n        return ans;\n    }\n}","author":"Sarthak Mathur","submissionId":"1575098779"},[]]},{"84":[{"id":"84","fileName":"1575099007.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], qs: List[int]) -> List[int]:\n        n = len(nums)\n        m = {}\n        for i, x in enumerate(nums):\n            m.setdefault(x, []).append(i)\n        for x in m:\n            m[x].sort()\n        ans = []\n        for q in qs:\n            v = nums[q]\n            arr = m[v]\n            if len(arr) == 1:\n                ans.append(-1)\n                continue\n            i = bisect_left(arr, q)\n            best = float(\"inf\")\n            if i > 0:\n                d = abs(q - arr[i-1])\n                best = min(best, d, n-d)\n            if i < len(arr)-1:\n                d = abs(arr[i+1] - q)\n                best = min(best, d, n-d)\n            if i == 0:\n                d = abs(q - arr[-1])\n                best = min(best, d, n-d)\n            if i == len(arr)-1:\n                d = abs(arr[0] - q)\n                best = min(best, d, n-d)\n            ans.append(best)\n        return ans\n        \n    \n        \n        ","author":"ARUL SELVAN S","submissionId":"1575099007"},[]]},{"85":[{"id":"85","fileName":"1575098691.txt","sourceCode":"class Solution(object):\n    def solveQueries(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        N = len(nums)\n        pos = {}\n        best = [N] * N\n        for i in xrange(2 * N):\n            if nums[i % N] not in pos:\n                pos[nums[i]] = i\n            else:\n                d = i - pos[nums[i % N]]\n                best[i % N] = min(best[i % N], d)\n                best[pos[nums[i % N]] % N] = min(best[pos[nums[i % N]] % N], d)\n                pos[nums[i % N]] = i\n        ans = [-1] * len(queries)\n        for i in xrange(len(queries)):\n            if best[queries[i]] != N:\n                ans[i] = best[queries[i]]\n        return ans","author":"lsUGGYJUIX","submissionId":"1575098691"},[]]},{"86":[{"id":"86","fileName":"1575098635.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        first = {}\n        last = {}\n        nxt = {}\n        back = {}\n        prior = {}\n        for i,n in enumerate(nums):\n            if n not in first:\n                first[n] = i\n            last[n] = i\n\n        for i,n in enumerate(nums):\n            if n in prior:\n                nxt[prior[n]] = i\n                back[i] = prior[n]\n            prior[n] = i\n\n        ans = []\n        size = len(nums)\n\n        for i in queries:\n            n = nums[i]\n\n            l = back[i] if i in back else -inf\n            r = nxt[i] if i in nxt else -inf\n\n            fN = first[n] if i != first[n] else -inf\n            lN = last[n] if i != last[n] else -inf\n\n\n            #print(l, r, \"HERE\")\n\n            mn = min(abs(i-l), abs(i-r), abs(i-fN), abs(i-lN), abs(i + size - lN), abs(size - i + fN))\n            if mn == inf:\n                mn = -1\n            ans.append(mn)\n        return ans\n        ","author":"Kyle","submissionId":"1575098635"},[]]},{"87":[{"id":"87","fileName":"1575099560.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> a(2 * n);\n        for (int i = 0; i < n; i++) {\n            a[i] = nums[i];\n            a[i + n] = nums[i];\n        }\n        \n        vector<int> ls(2 * n), rs(2 * n);\n        for (int i = 0; i < 2 * n; i++) {\n            ls[i] = rs[i] = -1;\n        }\n        \n        map<int,int> mp;\n        for (int i = 0; i < 2 * n; i++) {\n            if (mp.count(a[i])) {\n                ls[i] = mp[a[i]];\n            }\n            mp[a[i]] = i;\n        }\n        \n        mp.clear();\n        for (int i = 2 * n - 1; i >= 0; i--) {\n            if (mp.count(a[i])) {\n                rs[i] = mp[a[i]];\n            }\n            mp[a[i]] = i;\n        }\n        \n        vector<int> ans(queries.size());\n        for (int i = 0; i < queries.size(); i++) {\n            ans[i] = -1;\n            int pos = queries[i];\n            \n            if (ls[pos] >= 0 && (ans[i] < 0 || ans[i] > pos - ls[pos])) {\n                ans[i] = pos - ls[pos];\n            }\n            \n            if (rs[pos] >= 0 && (ans[i] < 0 || ans[i] > rs[pos] - pos)) {\n                ans[i] = rs[pos] - pos;\n            }\n            \n            pos = queries[i] + n;\n            if (ls[pos] >= 0 && (ans[i] < 0 || ans[i] > pos - ls[pos])) {\n                ans[i] = pos - ls[pos];\n            }\n            \n            if (rs[pos] >= 0 && (ans[i] < 0 || ans[i] > rs[pos] - pos)) {\n                ans[i] = rs[pos] - pos;\n            }            \n            \n            if (ans[i] >= n) {\n                ans[i] = -1;\n            }\n        }\n        \n        return ans;\n    }\n};","author":"Linh Nguyen","submissionId":"1575099560"},[]]},{"88":[{"id":"88","fileName":"1575099469.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) \n    {\n        int n = nums.size();\n        unordered_map<int, vector<int>>Map;\n        for (int i=0; i<n; i++)\n            Map[nums[i]].push_back(i);\n        \n        for (auto& [k,arr]: Map)\n        {\n            if (arr.size()==1) continue;\n            int a = arr[0], b = arr.back();\n            arr.insert(arr.begin(), b-n);\n            arr.push_back(a+n);\n        }\n        \n        vector<int>rets;\n        for (int idx: queries)\n        {\n            if (Map[nums[idx]].size()==1)\n                rets.push_back(-1);\n            else\n            {\n                auto& arr = Map[nums[idx]];\n                auto iter = lower_bound(arr.begin(), arr.end(), idx);\n                int a = *next(iter) - *iter;\n                int b = *iter - *prev(iter);\n                rets.push_back(min(a,b));\n            }\n        }\n        \n        return rets;\n            \n        \n    }\n};","author":"wisdompeak","submissionId":"1575099469"},[]]},{"89":[{"id":"89","fileName":"1575099342.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        cdict = defaultdict(list)\n        for i, v in enumerate(nums):\n            cdict[v].append(i)\n\n        n = len(nums)\n\n        print(cdict)\n        res = []\n        for q in queries:\n            cnum = nums[q]\n            if len(cdict[cnum]) == 1:\n                res.append(-1)\n            else:\n                cidx = bisect.bisect_left(cdict[cnum], q)\n                cset = set([(cidx+1) % len(cdict[cnum]), (cidx-1) % len(cdict[cnum])])\n                cset.discard(cidx)\n                cmin = min(cset, key=lambda x: min(n-abs(cdict[cnum][x]-q), abs(cdict[cnum][x]-q)))\n                res.append(min(n-abs(cdict[cnum][cmin]-q), abs(cdict[cnum][cmin]-q)))\n                    \n        return res\n                ","author":"Practicer","submissionId":"1575099342"},[]]},{"90":[{"id":"90","fileName":"1575099120.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        map<int, vector<int>> m;\n        int n = a.size();\n        for(int i = 0; i<n; i++) {\n            m[a[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(auto &x : q) {\n            int mid, lo = 0, hi = m[a[x]].size()-1;\n            if(hi == 0) {\n                ans.push_back(-1);\n                continue;\n            }\n            while(lo<=hi) {\n                mid = (lo+hi)/2;\n                if(m[a[x]][mid]>=x)hi = mid-1;\n                else lo = mid+1;\n            }\n            int ret = min(m[a[x]][lo]+n-m[a[x]].back(), n-m[a[x]][lo] + m[a[x]][0]);\n            if(lo>0)ret = min(ret, m[a[x]][lo] - m[a[x]][lo-1]);\n            if(lo<m[a[x]].size()-1)ret = min(ret, m[a[x]][lo+1] - m[a[x]][lo]);\n            ans.push_back(ret);\n        }\n        return ans;\n    }\n};","author":"Divyansh Bisht","submissionId":"1575099120"},[]]},{"91":[{"id":"91","fileName":"1575099562.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> occ;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            occ[nums[i]].push_back(i);\n        }\n        vector<int> answer;\n        for (auto q: queries) {\n            auto &occ_q = occ[nums[q]];\n            if (occ_q.size() == 1) {\n                answer.push_back(-1);\n                continue;\n            }\n            int distance = 1e9;\n            auto idx = lower_bound(occ_q.begin(), occ_q.end(), q) - occ_q.begin();\n            if (idx != 0) {\n                distance = min(distance, occ_q[idx] - occ_q[idx - 1]);\n            }\n            else {\n                distance = min(distance, occ_q[idx] + n - occ_q.back());\n            }\n            if (idx != occ_q.size() - 1) {\n                distance = min(distance, occ_q[idx + 1] - occ_q[idx]);\n            }\n            else {\n                distance = min(distance, occ_q[0] + n - occ_q[idx]);\n            }\n            answer.push_back(distance);\n        }\n        return answer;\n    }\n};","author":"enip2473","submissionId":"1575099562"},[{"id":"496","similarity":0.75,"totOverlap":132,"longestOverlap":23}]],"496":[{"id":"496","fileName":"1575117035.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> m;\n        const int n = nums.size();\n        \n        for(int i = 0; i < nums.size(); i ++)\n        {\n            m[nums[i]].push_back(i);\n        }\n        vector<int> res;\n        \n        for(int idx: queries)\n        {\n            int i = nums[idx];\n            if(m.find(i) == m.end() || m[i].size() == 1)\n            {\n                res.push_back(-1);\n                continue;\n            }\n            \n            auto& v = m[i];\n            \n            int loc = lower_bound(v.begin(), v.end(), idx) - v.begin();\n            int val = n;\n            \n            if(loc > 0)\n            {\n                val = min(val, v[loc]-v[loc-1]);\n            }\n            else\n            {\n                val = min(val, v[loc]+n-v.back());\n            }\n            \n            if(loc < v.size()-1)\n            {\n                val = min(val, v[loc+1]-v[loc]);\n            }\n            else\n            {\n                val = min(val, *v.begin()+n-v[loc]);\n            }\n            \n            res.push_back(val);\n        }\n        \n        return res;\n    }\n};","author":"ForGive","submissionId":"1575117035"},[{"id":"91","similarity":0.75,"totOverlap":132,"longestOverlap":23}]]},{"93":[{"id":"93","fileName":"1575099705.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, set<int>> pos;\n        for(int i = 0; i < nums.size(); i++) {\n            pos[nums[i]].insert(i);\n        }\n        int n = nums.size();\n        vector<int> ans;\n        for(auto &q : queries) {\n            set<int> &s = pos[nums[q]];\n            if (s.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            else {\n                vector<int> cands;\n                auto higher = s.upper_bound(q);\n                if (*s.rbegin() != q) \n                    cands.push_back(*s.rbegin());\n                if (*s.begin() != q) \n                    cands.push_back(*s.begin());\n                if (higher != s.end()) {\n                    cands.push_back(*higher);\n                }\n                auto lower = s.lower_bound(q);\n                if (lower != s.begin()) {\n                    cands.push_back(*prev(lower));\n                }\n                int md = 10000000;\n                for(auto e : cands) {\n                    if (e == q) continue;\n                    else {\n                        int hi = max(e, q);\n                        int lo = min(e, q);\n                        md = min(md, min(hi - lo, n + lo - hi));\n                    }\n                    // cout << \"Q: \" << q << ' ' << e << ' ' << q - e << endl;\n                }\n                ans.push_back(md);\n            }\n        }\n        return ans;\n    }\n};","author":"Ian McKibben","submissionId":"1575099705"},[]]},{"94":[{"id":"94","fileName":"1575099753.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        d = {}\n        for i, x in enumerate(nums):\n            d.setdefault(x, []).append(i)\n        \n        res = [-1] * n\n        for x, idx in d.items():\n            if len(idx) < 2:\n                continue\n            idx.sort()\n            k = len(idx)\n            for i in range(k):\n                c = idx[i]\n                nxt = idx[(i + 1) % k]\n                prev = idx[(i - 1) % k]\n                res[c] = min(min(abs(c - nxt), n - abs(c - nxt)), min(abs(c - prev), n - abs(c - prev)))\n        \n        return [res[q] for q in queries]\n","author":"All","submissionId":"1575099753"},[]]},{"96":[{"id":"96","fileName":"1575099011.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        def loop(d):\n            return min(d, len(nums) - d)\n        locs = defaultdict(list)\n        qi2loci = [None] * len(nums)\n        for i, num in enumerate(nums):\n            locs[num].append(i)\n            qi2loci[i] = len(locs[num]) - 1\n        ret = []\n        for qi in queries:\n            num = nums[qi]\n            if len(locs[num]) == 1:\n                ret.append(-1)\n            else:\n                mod = len(locs[num])\n                # print(qi, num, (qi - locs[num][(qi2loci[qi] - 1) % mod]), abs(qi - locs[num][(qi2loci[qi] + 1) % mod]))\n                this = min(\n                    loop(abs(qi - locs[num][(qi2loci[qi] - 1) % mod])), \n                    loop(abs(qi - locs[num][(qi2loci[qi] + 1) % mod]))\n                )\n                ret.append(this)\n        return ret","author":"lihaicoder","submissionId":"1575099011"},[]]},{"97":[{"id":"97","fileName":"1575099957.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, TreeSet<Integer>> numToInds = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (!numToInds.containsKey(nums[i])) {\n                numToInds.put(nums[i], new TreeSet<>());\n            }\n            numToInds.get(nums[i]).add(i);\n        }\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < queries.length; i++) {\n            int ind = queries[i];\n            int num = nums[ind];\n            TreeSet<Integer> inds = numToInds.get(num);\n            Integer prev = inds.lower(ind);\n            Integer next = inds.higher(ind);\n            if (prev == null && next == null) {\n                result.add(-1);\n                continue;\n            } \n            if (prev == null) {\n                prev = inds.last();\n            } \n            if (next == null) {\n                next = inds.first();\n            }\n            result.add(Math.min(Math.min(nums.length - Math.abs(next - ind), Math.abs(next - ind)), \n                    Math.min(nums.length - Math.abs(ind - prev), Math.abs(ind - prev))));\n        }\n        return result;\n    }\n}","author":"Feng W","submissionId":"1575099957"},[]]},{"98":[{"id":"98","fileName":"1575099976.txt","sourceCode":"class Solution {\npublic:\n    typedef long long ll;\n    typedef long double ld;\n    #define pb push_back\n    #define be(a) a.begin(), a.end()\n    #define vi vector<int>\n    #define vl vector<ll>\n    #define vs vector<string>\n    #define vc vector<char>\n    #define yes cout<<\"YES\"<<endl;\n    #define no cout<<\"NO\"<<endl;\n    #define loop(i,n) for(int i=0;i<n;i++)\n\n    int bins(vi& arr, int tar) {\n        int l = 0, r = arr.size() - 1, ans = -1;\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            if (arr[mid] > tar) {\n                ans = mid;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n\n    int bins2(vi& arr, int tar) {\n        int l = 0, r = arr.size() - 1, ans = -1;\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            if (arr[mid] < tar) {\n                ans = mid;\n                l = mid + 1;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return ans;\n    }\n\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> ans(queries.size(), -1);\n        int n = nums.size();\n        map<int, vi> sus;\n        for (int i = 0; i < n; i++) {\n            sus[nums[i]].pb(i);\n        }\n        for (int i = 0; i < queries.size(); i++) {\n            int idx = queries[i];\n            int val = nums[idx];\n\n            if (sus.find(val) == sus.end() || sus[val].size() == 1) {\n                ans[i] = -1; \n                continue;\n            }\n\n            vi& positions = sus[val];\n            int pos = bins(positions, idx);\n            int pos2 = bins2(positions, idx);\n\n            int minDist = INT_MAX;\n            if (pos != -1) {\n                minDist = min(minDist, abs(positions[pos] - idx));\n            }\n            if (pos2 != -1) {\n                minDist = min(minDist, abs(positions[pos2] - idx));\n            }\n            int first = positions.front();\n            int last = positions.back();\n            minDist = min({minDist, (n - abs(idx - first)), (n - abs(idx - last))});\n\n            ans[i] = minDist;\n        }\n\n        return ans;\n    }\n};\n","author":"s1ege","submissionId":"1575099976"},[]]},{"99":[{"id":"99","fileName":"1575099989.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> x;\n        for(int i = 0; i < nums.size(); i++){\n            x[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(int q: queries){\n            if(x[nums[q]].size() == 1){\n                ans.push_back(-1);\n                continue;\n            }\n            auto it = lower_bound(x[nums[q]].begin(), x[nums[q]].end(), q);\n            int index = it - x[nums[q]].begin();\n            int ldiff = 0;\n            int rdiff = 0;\n            if(index == 0)\n                ldiff = q + nums.size() - x[nums[q]].back();\n            else\n                ldiff = q - x[nums[q]][index - 1];\n            if(index == x[nums[q]].size() - 1)\n                rdiff = x[nums[q]][0] + nums.size() - q;\n            else\n                rdiff = x[nums[q]][index + 1] - q;\n            ans.push_back(min(ldiff, rdiff));\n        }\n        return ans;\n    }\n};","author":"hero777","submissionId":"1575099989"},[]]},{"100":[{"id":"100","fileName":"1575100308.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int>a;\n        for(auto i:nums) a.push_back(i);\n        for(auto i:nums) a.push_back(i);\n        for(auto i:nums) a.push_back(i);\n        map<int,int>mp;\n        int n=nums.size();\n       \n        vector<int>front(3*n,n),from_back(3*n,n);\n        for(int i=0;i<2*n;i++){\n            if(mp.count(a[i])){\n                from_back[i]=i-mp[a[i]];\n            }\n            mp[a[i]]=i;\n        }\n        \n        mp.clear();\n        for(int i=3*n-1;i>=n;i--){\n             if(mp.count(a[i])){\n                front[i]=mp[a[i]]-i;\n            }\n            mp[a[i]]=i;\n        }\n        vector<int>ans;\n        for(auto i:queries){\n            int x=min(from_back[n+i],front[n+i]);\n            if(x==n) x=-1;\n            ans.push_back(x);\n        }\n        return ans;\n    }\n};","author":"Terror_404","submissionId":"1575100308"},[]]},{"101":[{"id":"101","fileName":"1575099834.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int,set<int>> mpp;\n        for(int i = 0 ; i < n ; i++){\n            mpp[nums[i]].insert(i);\n        }\n        for(auto& [x , st] : mpp){\n            if(st.size() > 1){\n                int mx = *prev(st.end());\n                int mn = *st.begin();\n                st.insert(mn + n);\n                st.insert(mx - n);\n            }\n        }\n        vector<int> ans(queries.size());\n        int idx = 0;\n        for(auto& query : queries){\n            int num = nums[query];\n            if(mpp[num].size() == 1){\n                ans[idx++] = -1;\n                continue;\n            }\n            auto it1 = mpp[num].upper_bound(query);\n            auto it2 = mpp[num].upper_bound(query-1);\n            it2--;\n            ans[idx++] = min( query - *it2 , *it1 - query);\n            \n        }\n        return ans;\n    }\n};","author":"sujal das","submissionId":"1575099834"},[]]},{"102":[{"id":"102","fileName":"1575100431.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        res = []\n        p = defaultdict(list)\n        for i, v in enumerate(nums): p[v].append(i)\n        for q in queries: \n            v = p[nums[q]]\n            if len(v) == 1: res.append(-1)\n            else:\n                i = bisect_left(v, q)\n                l, r = v[i - 1] if i else v[-1], v[i + 1] if i < len(v) - 1 else v[0]\n                res.append(min(abs(q - l), n - abs(q - l), abs(q - r), n - abs(q - r)))\n        return res","author":"LTHW","submissionId":"1575100431"},[]]},{"103":[{"id":"103","fileName":"1575100375.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> locss;\n        int N = nums.size();\n        for (int i = 0; i < N; ++i) {\n            locss[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        ans.reserve(queries.size());\n        for (int q : queries) {\n            int x = nums[q];\n            vector<int>& locs = locss[x];\n            assert(!locs.empty());\n            if (locs.size() == 1) {\n                ans.push_back(-1);\n            } else {\n                int i = lower_bound(locs.begin(), locs.end(), q)-locs.begin();\n                assert(i < locs.size());\n                assert(locs[i] == q);\n                int dist;\n                int nxt = i+1;\n                if (nxt == locs.size()) {\n                    nxt = 0;\n                    dist = locs[nxt]+N-locs[i];\n                } else {\n                    dist = locs[nxt]-locs[i];\n                }\n                int pre = i-1;\n                if (pre < 0) {\n                    pre += locs.size();\n                    dist = min(dist, locs[i]-(locs[pre]-N));\n                } else {\n                    dist = min(dist, locs[i]-locs[pre]);\n                }\n                ans.push_back(dist);\n\n                \n            }\n        }\n        return ans;\n    }\n};","author":"SirTechnical","submissionId":"1575100375"},[]]},{"105":[{"id":"105","fileName":"1575100481.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n = nums.size(), m = q.size();\n        unordered_map<int, vector<int>> mp;\n        for(int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n\n        vector<int> ret(m);\n        for(int i = 0; i < m; i++) {\n            auto& v = mp[nums[q[i]]];\n            if(v.size() == 1) {\n                ret[i] = -1;\n                continue;\n            }\n\n            int sz = v.size();\n            auto it = lower_bound(v.begin(), v.end(), q[i]);\n            int idx = it - v.begin();\n            int nxt = idx + 1, prev = idx - 1;\n            if(prev < 0)\n                prev = sz - 1;\n            if(nxt == sz)\n                nxt = 0;\n\n            int can1 = (v[nxt] - v[idx]) % n, can2 = (v[idx] - v[prev]) % n;\n            if(can1 < 0)\n                can1 += n;\n            if(can2 < 0)\n                can2 += n;\n\n            ret[i] = min(can1, can2);\n        }\n        return ret;\n    }\n};","author":"HFDnpkp1cs","submissionId":"1575100481"},[]]},{"106":[{"id":"106","fileName":"1575100989.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, List<Integer>> indices = new HashMap<>();\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            indices.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        int[] closest = new int[n];\n        for (Map.Entry<Integer, List<Integer>> entry : indices.entrySet()) {\n            int val = entry.getKey();\n            List<Integer> list = entry.getValue();\n            int s = list.size();\n            if (s == 1) {\n                closest[list.get(0)] = -1;\n            }\n            else if (s == 2) {\n                int a = list.get(0);\n                int b = list.get(1);\n                int dist = Math.min(Math.abs(a - b), n - Math.abs(a - b));\n                closest[a] = dist;\n                closest[b] = dist;\n            }\n            else {\n                for (int i = 0; i < s; i++) {\n                    int x = list.get(i);\n                    int a = list.get((i - 1 + s) % s);\n                    int b = list.get((i + 1) % s);\n                    int dist = Math.min(Math.min(Math.abs(x - a), n - Math.abs(x - a)), Math.min(Math.abs(x - b), n - Math.abs(x - b)));\n                    System.out.println(dist);\n                    closest[x] = dist;\n                }\n            }\n        }\n\n        List<Integer> ans = new ArrayList<>();\n        for (int x : queries) {\n            ans.add(closest[x]);\n        }\n        return ans;\n    }\n}","author":"sahasrad","submissionId":"1575100989"},[]]},{"107":[{"id":"107","fileName":"1575100339.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& qr) {\n        int n = a.size();\n        map<int,vector<int>> mp;\n        for (int i=0; i<n; i++) {\n            mp[a[i]].push_back(i);\n        }\n        int q = qr.size();\n        vector<int> ans(q);\n        for (int i=0; i<q; i++) {\n            int j = qr[i];\n            int x = a[j];\n            if (mp[x].size() == 1) ans[i] = -1;\n            else {\n                auto &v = mp[x];\n                auto it = lower_bound(v.begin(), v.end(), j);\n                int t = 1e9;\n                if (next(it) == v.end()) {\n                    int nj = *v.begin();\n                    t = min(t, abs(j-nj));\n                    t = min(t, abs(j-nj+n));\n                    t = min(t, abs(j-nj-n));\n                }\n                else {\n                    int nj = *next(it);\n                    t = min(t, abs(j-nj));\n                    t = min(t, abs(j-nj+n));\n                    t = min(t, abs(j-nj-n));\n                }\n                if (it == v.begin()) {\n                    int nj = *v.rbegin();\n                    t = min(t, abs(j-nj));\n                    t = min(t, abs(j-nj+n));\n                    t = min(t, abs(j-nj-n));\n                }\n                else {\n                    int nj = *prev(it);\n                    t = min(t, abs(j-nj));\n                    t = min(t, abs(j-nj+n));\n                    t = min(t, abs(j-nj-n));\n                }\n                ans[i] = t;\n            }\n        }\n        return ans;\n        \n    }\n};","author":"umeshbahadur1729","submissionId":"1575100339"},[]]},{"108":[{"id":"108","fileName":"1575100778.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        table = defaultdict(list)\n        for p, n in enumerate(nums):\n            table[n].append(p)\n        \n        result = []\n        L = len(nums)\n        for pos0 in queries:\n            pos_list = table[nums[pos0]]\n            if len(pos_list) == 1:\n                result.append(-1)\n            elif pos_list[0] == pos0:\n                result.append(min(pos_list[1] - pos0, (pos0 - pos_list[-1]) % L))\n            elif pos_list[-1] == pos0:\n                result.append(min(pos0 - pos_list[-2], (pos_list[0] - pos0) % L))\n            else:\n                index = bisect.bisect_left(pos_list, pos0)\n                result.append(min(pos0 - pos_list[index - 1], pos_list[index + 1] - pos0))\n        \n        return result","author":"John smith","submissionId":"1575100778"},[]]},{"109":[{"id":"109","fileName":"1575101218.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        first, last = {}, {}\n        for i, num in enumerate(nums):\n            if num not in first:\n                first[num] = i\n            last[num] = i\n\n        n = len(nums)\n        nxt, prev = [-inf] * n, [-inf] * n\n        nxtDict, prevDict = {}, {}\n        for i, num in enumerate(nums):\n            if num in prevDict:\n                prev[i] = prevDict[num]\n            elif first[num] != last[num]:\n                prev[i] = last[num] - n\n            prevDict[num] = i\n\n        for i in reversed(range(n)):\n            num = nums[i]\n            if num in nxtDict:\n                nxt[i] = nxtDict[num]\n            elif first[num] != last[num]:\n                nxt[i] = first[num] + n\n            nxtDict[num] = i\n\n        # print(prev, nxt)\n\n        res = []\n        for q in queries:\n            if prev[q] == -inf:\n                res.append(-1)\n            else:\n                res.append(min(q - prev[q], nxt[q] - q))\n        return res","author":"zsq007","submissionId":"1575101218"},[]]},{"110":[{"id":"110","fileName":"1575101174.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> res(n, -1);\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++) mp[nums[i]].push_back(i);\n        for (auto &p : mp) {\n            auto &v = p.second;\n            if(v.size() < 2) continue;\n            process(v, res, n);\n        }\n        vector<int> ans;\n        for (auto x : queries) ans.push_back(res[x]);\n        return ans;\n    }\nprivate:\n    void process(vector<int>& v, vector<int>& res, int n) {\n        sort(v.begin(), v.end());\n        int k = v.size();\n        for (int i = 0; i < k; i++) {\n            int cur = v[i], prev = v[(i + k - 1) % k], next = v[(i + 1) % k];\n            int d1 = cur >= prev ? cur - prev : cur + n - prev;\n            int d2 = next >= cur ? next - cur : next + n - cur;\n            res[cur] = min(d1, d2);\n        }\n    }\n};\n","author":"Tarun V","submissionId":"1575101174"},[]]},{"113":[{"id":"113","fileName":"1575101261.txt","sourceCode":"from typing import List\nimport bisect\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        d = {}\n        for i, num in enumerate(nums):\n            d.setdefault(num, []).append(i)\n        for key in d:\n            d[key].sort()\n        res = []\n        for q in queries:\n            val = nums[q]\n            indices = d[val]\n            if len(indices) == 1:\n                res.append(-1)\n                continue\n            pos = bisect.bisect_left(indices, q)\n            cand = float('inf')\n            if pos > 0:\n                diff = abs(q - indices[pos - 1])\n                cand = min(cand, diff, n - diff)\n            if pos < len(indices) - 1:\n                diff = abs(indices[pos + 1] - q)\n                cand = min(cand, diff, n - diff)\n            if pos == 0:\n                diff = abs(q - indices[-1])\n                cand = min(cand, diff, n - diff)\n            if pos == len(indices) - 1:\n                diff = abs(q - indices[0])\n                cand = min(cand, diff, n - diff)\n            res.append(cand)\n        return res\n\nif __name__ == \"__main__\":\n    s = Solution()\n    nums1 = [1, 3, 1, 4, 1, 3, 2]\n    queries1 = [0, 3, 5]\n    print(s.solveQueries(nums1, queries1))  # [2, -1, 3]\n    nums2 = [1, 2, 3, 4]\n    queries2 = [0, 1, 2, 3]\n    print(s.solveQueries(nums2, queries2))  # [-1, -1, -1, -1]\n","author":"ciggA8R8La","submissionId":"1575101261"},[]]},{"115":[{"id":"115","fileName":"1575101392.txt","sourceCode":"class Solution {\n\n    private int find(List<Integer> list, int query) {\n        int l = 0, r = list.size();\n        while (l < r) {\n            int mid = (l + r) / 2;\n            if (list.get(mid) < query) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        }\n        return l;\n    }\n\n    private int getDist(int idx1, int idx2, int n) {\n        int dist1 = Math.abs(idx1 - idx2);\n        int dist2 = n - dist1;\n        return Math.min(dist1, dist2);\n    }\n\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0;i < nums.length;i ++) {\n            map.putIfAbsent(nums[i], new ArrayList<>());\n            map.get(nums[i]).add(i);\n        }\n        List<Integer> ans = new ArrayList<>();\n        int n = nums.length;\n        for (int query : queries) {\n            int val = nums[query];\n            List<Integer> list = map.getOrDefault(val, new ArrayList<>());\n            if (list.size() == 1) {\n                ans.add(-1);\n            } else {\n                int index = find(list, query), minDist = Integer.MAX_VALUE;\n                int dist = getDist(list.get((index - 1 + list.size()) % list.size()), list.get(index), n);\n                minDist = Math.min(minDist, dist);\n                dist = getDist(list.get(index), list.get((index + 1) % list.size()), n);\n                minDist = Math.min(minDist, dist);\n                ans.add(minDist);\n            }\n        }\n        return ans;\n    }\n\n\n}","author":"Wei Liu","submissionId":"1575101392"},[]]},{"116":[{"id":"116","fileName":"1575101379.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int total = nums.size();\n        std::unordered_map<int, std::set<int>> nums_to_pos;\n        for (int i = 0; i < nums.size(); ++i) {\n            nums_to_pos[nums[i]].insert(i);\n            nums_to_pos[nums[i]].insert(i - total);\n            nums_to_pos[nums[i]].insert(i + total);\n        }\n\n        std::vector<int> ans;\n        for (int query: queries) {\n            int n = nums[query];\n            auto iter = nums_to_pos[n].find(query);\n            auto prev_iter = iter, next_iter = iter;\n            prev_iter--;\n            next_iter++;\n            int prev_pos = *prev_iter;\n            int next_pos = *next_iter;\n            int result = std::min(query - prev_pos, next_pos - query);\n            if (result == total) {\n                result = -1;\n            }\n            ans.push_back(result);\n        }\n        return ans;\n        \n    }\n};","author":"Qimu Z","submissionId":"1575101379"},[]]},{"118":[{"id":"118","fileName":"1575101549.txt","sourceCode":"import collections\nimport math\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        match = collections.defaultdict(list)\n        index = collections.defaultdict(dict)\n\n        for (i, n) in enumerate(nums):\n            index[n][i] = len(match[n])\n            match[n].append(i)\n\n        ans = []\n        for i in queries:\n            n = nums[i]\n            if len(match[n]) == 1:\n                ans.append(-1)\n            else:\n                a = None\n                ind = index[n][i]\n                if ind == 0:\n                    a = len(nums) - match[n][-1] + i\n                else:\n                    a = i - match[n][ind - 1]\n\n                if ind + 1 == len(match[n]):\n                    a = min(a, len(nums) - i + match[n][0])\n                else:\n                    a = min(a, match[n][ind + 1] - i)\n                    \n                ans.append(a)\n        return ans\n            ","author":"allen_nie","submissionId":"1575101549"},[]]},{"119":[{"id":"119","fileName":"1575101504.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        value_to_indices = {}\n        for i, num in enumerate(nums):\n            if num in value_to_indices:\n                value_to_indices[num].append(i)\n            else:\n                value_to_indices[num] = [i]\n        \n        for value in value_to_indices:\n            value_to_indices[value].sort()\n        \n        def get_min_distance(query_idx, indices, n):\n            if len(indices) == 1:\n                return -1\n                \n            pos = 0\n            left, right = 0, len(indices) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if indices[mid] <= query_idx:\n                    pos = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            \n            min_dist = float('inf')\n            if pos > 0:\n                min_dist = min(min_dist, get_circular_dist(query_idx, indices[pos-1], n))\n            if pos < len(indices) - 1:\n                min_dist = min(min_dist, get_circular_dist(query_idx, indices[pos+1], n))\n            if indices[pos] != query_idx:\n                min_dist = min(min_dist, get_circular_dist(query_idx, indices[pos], n))\n            if pos == 0 and indices[-1] != query_idx:\n                min_dist = min(min_dist, get_circular_dist(query_idx, indices[-1], n))\n            if pos == len(indices) - 1 and indices[0] != query_idx:\n                min_dist = min(min_dist, get_circular_dist(query_idx, indices[0], n))\n            \n            return min_dist\n        \n        def get_circular_dist(i, j, n):\n            dist1 = abs(i - j)\n            return min(dist1, n - dist1)\n        \n        answer = []\n        for q in queries:\n            indices = value_to_indices[nums[q]]\n            answer.append(-1 if len(indices) == 1 else get_min_distance(q, indices, n))\n        \n        return answer","author":"bhargav yarlagadda","submissionId":"1575101504"},[]]},{"120":[{"id":"120","fileName":"1575101557.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> idx = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            idx.putIfAbsent(nums[i], new ArrayList<>());\n            idx.get(nums[i]).add(i);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int i : queries) {\n            if (idx.get(nums[i]).size() == 1) ans.add(-1);\n            else {\n                List<Integer> lst = idx.get(nums[i]);\n                int firidx = lst.get(0), lstidx = lst.get(lst.size() - 1);\n                int j = Collections.binarySearch(lst, i);\n                int res = 1<<30;\n                if (j > 0) res = Math.min(res, lst.get(j) - lst.get(j - 1));\n                else res = Math.min(res, n - lstidx + lst.get(j));\n                if (j + 1 < lst.size()) res = Math.min(res, lst.get(j + 1) - lst.get(j));\n                else res = Math.min(res, n - lst.get(j) + firidx);\n                ans.add(res);\n            }\n        }\n        return ans;\n    }\n}","author":"alicezhangmeijun","submissionId":"1575101557"},[]]},{"121":[{"id":"121","fileName":"1575101526.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        const int n = nums.size();\n        unordered_map<int, vector<int>> m;\n        for (int i = 0; i < n; ++i) {\n            m[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for (int query : queries) {\n            auto it = m.find(nums[query]);\n            const int k = it->second.size();\n            if (k <= 1) {\n                ans.push_back(-1);\n            } else {\n                int idx = lower_bound(it->second.begin(), it->second.end(), query) - it->second.begin();\n                int x = abs(it->second[(idx + k - 1) % k] - it->second[idx]);\n                int y = abs(it->second[idx] - it->second[(idx + 1) % k]);\n                ans.push_back(min({x, n - x, y, n - y}));\n            }\n        }\n        return ans;\n    }\n};","author":"JeffreyLC","submissionId":"1575101526"},[]]},{"122":[{"id":"122","fileName":"1575101799.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        l = defaultdict(list)\n        for i in range(len(nums)):\n            l[nums[i]].append(i)\n        ret = [0] * len(queries)\n        def calc(idx):\n            if len(l[nums[idx]]) == 1:\n                return -1\n            i = bisect_left(l[nums[idx]], idx)\n            ret = -1\n            if i > 0:\n                ret = idx - l[nums[idx]][i-1]\n            else:\n                ret = idx + n - l[nums[idx]][-1]\n            if i + 1 < len(l[nums[idx]]):\n                if ret < 0 or ret > l[nums[idx]][i + 1] - idx:\n                    ret = l[nums[idx]][i + 1] - idx\n            else:\n                if ret < 0 or ret > l[nums[idx]][0] + n - idx:\n                    ret = l[nums[idx]][0] + n - idx\n            if ret == n:\n                return -1\n            return ret\n        for i in range(len(queries)):\n            ret[i] = calc(queries[i])\n        return ret","author":"Thinkingface","submissionId":"1575101799"},[]]},{"123":[{"id":"123","fileName":"1575101458.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        unordered_map<int, set<int>> ma;\n        for (int i = 0; i < n; i++)\n            ma[nums[i]].insert(i);\n        vector<int> res(m);\n        for (int i = 0; i < m; i++)\n        {\n            int j = queries[i];\n            int num = nums[j];\n            auto& se = ma[num];\n            int dist = INT_MAX;\n            auto it1 = se.upper_bound(j);\n            if (it1 != se.end())\n                dist = min(dist, *it1 - j);\n            else\n            {\n                int k = *se.begin();\n                if (k != j)\n                    dist = min(dist, n - j + k);\n            }\n            auto it2 = se.lower_bound(j);\n            if (it2 != se.begin())\n                dist = min(dist, j - *(--it2));\n            else\n            {\n                int k = *se.rbegin();\n                if (k != j)\n                    dist = min(dist, j + (n - k));\n            }\n            res[i] = dist == INT_MAX ? -1 : dist;\n        }\n        return res;\n    }\n};","author":"birds3345","submissionId":"1575101458"},[]]},{"124":[{"id":"124","fileName":"1575101815.txt","sourceCode":"class Solution:\n  def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n    def d(i, j):\n      r = abs(i - j)\n      return min(r, n - r)\n\n    def f(q):\n      i = nums[q]\n      p = pos[i]\n      m = len(p)\n      if m == 1:\n        return -1\n      idx = bisect_left(p, q)\n      l = p[idx - 1]\n      r = p[(idx + 1) % m]\n      return min(d(l, q), d(q, r))\n\n    n = len(nums)\n    pos = defaultdict(list)\n    for i, num in enumerate(nums):\n      pos[num].append(i)\n    return [f(q) for q in queries]\n        ","author":"LeeetCode","submissionId":"1575101815"},[]]},{"127":[{"id":"127","fileName":"1575101819.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> m;\n        for (int i = 0; i < n; i++) m[nums[i]].push_back(i);\n        for (auto &p : m) sort(p.second.begin(), p.second.end());\n        \n        vector<int> ans;\n        for (int q : queries) {\n            int val = nums[q];\n            if (m[val].size() < 2) {\n                ans.push_back(-1);\n                continue;\n            }\n            auto &v = m[val];\n            int best = n;\n            auto it = lower_bound(v.begin(), v.end(), q);\n            if (it != v.end() && *it != q) {\n                int d = abs(q - *it);\n                best = min(best, min(d, n - d));\n            }\n            if (it != v.begin()) {\n                it--;\n                if (*it != q) {\n                    int d = abs(q - *it);\n                    best = min(best, min(d, n - d));\n                }\n            }\n            int idx = lower_bound(v.begin(), v.end(), q) - v.begin();\n            int left = (idx - 1 + v.size()) % v.size();\n            int right = (idx + 1) % v.size();\n            if(v[left] != q) {\n                int d = abs(q - v[left]);\n                best = min(best, min(d, n - d));\n            }\n            if(v[right] != q) {\n                int d = abs(q - v[right]);\n                best = min(best, min(d, n - d));\n            }\n            ans.push_back(best);\n        }\n        return ans;\n    }\n};\n","author":"Jacob Ma","submissionId":"1575101819"},[]]},{"129":[{"id":"129","fileName":"1575102032.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = defaultdict(list)\n        for i, num in enumerate(nums):\n            d[num].append(i - len(nums))\n        for i, num in enumerate(nums):\n            d[num].append(i)\n        for i, num in enumerate(nums):\n            d[num].append(i + len(nums))\n        res = []\n        for q in queries:\n            num = nums[q]\n            if len(d[num]) == 3:\n                res.append(-1)\n            else:\n                index = bisect.bisect_left(d[num], q)\n                v = []\n                if index - 1 != -1:\n                    v.append(q - d[num][index - 1])\n                if index + 1 < len(d[num]):\n                    v.append(d[num][index + 1] - q)\n\n                res.append(min(v))\n        return res","author":"jacksonc","submissionId":"1575102032"},[]]},{"130":[{"id":"130","fileName":"1575102228.txt","sourceCode":"class Solution {\npublic:\n  vector<int> solveQueries(vector<int> &a, vector<int> &q) {\n    int n = a.size(), m = q.size();\n    unordered_map<int, vector<int>> pos;\n    for (int i = 0; i < n; i++) {\n      pos[a[i]].push_back(i - n);\n    }\n    for (int i = 0; i < n; i++) {\n      pos[a[i]].push_back(i);\n    }\n    for (int i = 0; i < n; i++) {\n      pos[a[i]].push_back(i + n);\n    }\n    vector<int> ans(m);\n    for (int i = 0; i < m; i++) {\n      int v = a[q[i]];\n      auto it = ranges::lower_bound(pos[v], q[i]);\n      assert(it != pos[v].begin());\n      assert(it != --pos[v].end());\n      int d = min(*it - *prev(it), *next(it) - *it);\n      ans[i] = d == n ? -1 : d;\n    }\n    return ans;\n  }\n};","author":"Sam Huang","submissionId":"1575102228"},[]]},{"131":[{"id":"131","fileName":"1575102282.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T> using v = vector<T>;\ntemplate<typename T> using um = unordered_map<T, v<T>>;\n\ntemplate<typename T>\nT d(T a, T b, T n) {\n    T x = abs(a - b);\n    return min(x, n - x);\n}\n\ntemplate<typename T>\nT mn(T x) { return x ^ 0; }\n\ntemplate<typename T>\nT bs(const v<T>& arr, T val) {\n    return lower_bound(arr.begin(), arr.end(), val) - arr.begin();\n}\n\ntemplate<typename T>\nvoid srt(v<T>& arr) { sort(arr.begin(), arr.end()); }\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& b) {\n        int n = mn(a.size());\n        um<int> m;\n        for (int i = 0; i < n; i++) m[mn(a[i])].push_back(mn(i));\n        for (auto& p : m) srt(p.second);\n        v<int> r;\n        r.reserve(b.size());\n        for (int x : b) {\n            int y = mn(a[x]);\n            auto& v = m[y];\n            if (v.size() == 1) r.push_back(-1);\n            else {\n                int i = bs(v, x);\n                int l = v[(i - 1 + v.size()) % v.size()];\n                int r1 = v[(i + 1) % v.size()];\n                r.push_back(min(d(x, l, n), d(x, r1, n)));\n            }\n        }\n        return r;\n    }\n};\n","author":"Abhay Dixit","submissionId":"1575102282"},[]]},{"133":[{"id":"133","fileName":"1575102474.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        lefts = [-1] * len(nums)\n        rights = [-1] * len(nums)\n        lover = {}\n        lnew = {}\n        for i, num in enumerate(nums[::-1]):\n            if not num in lover:\n                lover[num] = i + 1\n        for i, num in enumerate(nums):\n            lefts[i] = min(i - lnew.get(num, -float('inf')), i + lover.get(num, float('inf')))\n            lnew[num] = i\n        rover = {}\n        rnew = {}\n        for i, num in enumerate(nums):\n            if not num in rover:\n                rover[num] = i + 1\n        for i, num in enumerate(nums[::-1]):\n            ri = len(nums) - 1 - i\n            rights[ri] = min(i - rnew.get(num, -float('inf')), i + rover.get(num, float('inf')))\n            rnew[num] = i\n        \n        ret = [min(lefts[i], rights[i]) for i in queries]\n        n = len(nums)\n        return [x if x != n else -1 for x in ret]","author":"Richard","submissionId":"1575102474"},[]]},{"134":[{"id":"134","fileName":"1575101400.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> valueToIndices = new HashMap<>();\n        \n        // Populate the map - O(n) time\n        for (int i = 0; i < n; i++) {\n            valueToIndices.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        \n        // Precompute minimum distances for all values - O(n) time\n        Map<Integer, Integer> indexToMinDist = new HashMap<>();\n        \n        for (Map.Entry<Integer, List<Integer>> entry : valueToIndices.entrySet()) {\n            List<Integer> indices = entry.getValue();\n            \n            if (indices.size() <= 1) {\n                // No other occurrence exists\n                for (int idx : indices) {\n                    indexToMinDist.put(idx, -1);\n                }\n                continue;\n            }\n            \n            // For each index, find the minimum distance to another occurrence\n            for (int i = 0; i < indices.size(); i++) {\n                int curr = indices.get(i);\n                int prev = indices.get((i > 0) ? i - 1 : indices.size() - 1);\n                int next = indices.get((i < indices.size() - 1) ? i + 1 : 0);\n                \n                // Calculate minimum distance considering the circular nature\n                int distToPrev = Math.min(Math.abs(curr - prev), n - Math.abs(curr - prev));\n                int distToNext = Math.min(Math.abs(curr - next), n - Math.abs(curr - next));\n                \n                indexToMinDist.put(curr, Math.min(distToPrev, distToNext));\n            }\n        }\n        \n        // Process queries - O(q) time\n        List<Integer> answer = new ArrayList<>();\n        for (int queryIndex : queries) {\n            answer.add(indexToMinDist.get(queryIndex));\n        }\n        \n        return answer;\n    }\n}","author":"Supratim Das","submissionId":"1575101400"},[{"id":"332","similarity":0.7397260273972602,"totOverlap":162,"longestOverlap":26},{"id":"1331","similarity":0.7453703703703703,"totOverlap":161,"longestOverlap":23}]],"332":[{"id":"332","fileName":"1575111810.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        int[] res = new int[n];\n        Arrays.fill(res, -1);        \n        for (Map.Entry<Integer, List<Integer>> entry : map.entrySet()) {\n            List<Integer> indices = entry.getValue();\n            if (indices.size() < 2) continue;             \n            int size = indices.size();\n            for (int i = 0; i < size; i++) {\n                int curr = indices.get(i);\n                int prev = indices.get((i - 1 + size) % size);\n                int next = indices.get((i + 1) % size);\n                int a = Math.min(Math.abs(curr - prev), n - Math.abs(curr - prev));\n                int b = Math.min(Math.abs(next - curr), n - Math.abs(next - curr));                \n                res[curr] = Math.min(a, b);\n            }\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int query : queries) {\n            ans.add(res[query]);\n        }\n        return ans;\n    }\n}","author":"Aspirin-","submissionId":"1575111810"},[{"id":"134","similarity":0.7397260273972602,"totOverlap":162,"longestOverlap":26}]],"1331":[{"id":"1331","fileName":"1575139214.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n           int n = nums.length;\n        Map<Integer, List<Integer>> indexMap = new HashMap<>();\n        int[] minDistances = new int[n];\n        List<Integer> answer = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            indexMap.putIfAbsent(nums[i], new ArrayList<>());\n            indexMap.get(nums[i]).add(i);\n        }\n\n        for (Map.Entry<Integer, List<Integer>> entry : indexMap.entrySet()) {\n            List<Integer> indices = entry.getValue();\n            Collections.sort(indices); \n            int size = indices.size();\n\n            for (int i = 0; i < size; i++) {\n                int currentIndex = indices.get(i);\n                if (size == 1) {\n                    minDistances[currentIndex] = -1;\n                } else {\n                    int nextIndex = indices.get((i + 1) % size);\n                    int prevIndex = indices.get((i - 1 + size) % size);\n\n                    int forwardDistance = Math.min(Math.abs(nextIndex - currentIndex),\n                            n - Math.abs(nextIndex - currentIndex));\n                    int backwardDistance = Math.min(Math.abs(prevIndex - currentIndex),\n                            n - Math.abs(prevIndex - currentIndex));\n\n                    minDistances[currentIndex] = Math.min(forwardDistance, backwardDistance);\n                }\n            }\n        }\n\n        for (int queryIndex : queries) {\n            answer.add(minDistances[queryIndex]);\n        }\n\n        return answer;\n    }\n}\n\n","author":"Vyomrana02","submissionId":"1575139214"},[{"id":"332","similarity":0.7453703703703703,"totOverlap":161,"longestOverlap":23}]]},{"135":[{"id":"135","fileName":"1575102711.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], ques: List[int]) -> List[int]:\n\n        nums+= nums\n        ans = [+float('inf') for _ in range(len(nums))]\n        \n        prev = {}\n        for i in range(len(nums)):\n            if nums[i] in prev:\n                ans[i] = min(ans[i], abs(i - prev[nums[i]]))\n            prev[nums[i]] = i\n\n        n = len(nums)\n        n >>=1\n        for key in prev:\n            prev[key] = -2*n+prev[key]\n        for i in range(len(nums)):\n            if nums[i] in prev:\n                ans[i] = min(ans[i], abs(i - prev[nums[i]]))\n            prev[nums[i]] = i\n        \n\n        prev= {}\n        for i in range(len(nums)-1,-1,-1):\n            if nums[i] in prev:\n                ans[i] = min(ans[i], abs(i - prev[nums[i]]))\n            prev[nums[i]] = i\n\n        return [ans[q] if ans[q] < (len(nums)>>1) else -1 for q in ques]\n            ","author":"lebron87","submissionId":"1575102711"},[]]},{"136":[{"id":"136","fileName":"1575102257.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        int[] close = new int[n];\n        Arrays.fill(close, Integer.MAX_VALUE);\n\n        Map <Integer, Integer> mp = new HashMap();\n        for(int i = 0; i < 2 * n; i++){\n            if(mp.containsKey(nums[i % n])){\n                // System.out.println(mp.get(nums[i % n]) + \" \" + i + \" type1\");\n                close[i % n] = Math.min(close[i % n], i - mp.get(nums[i % n]));\n            }\n            mp.put(nums[i % n], i);\n        }\n\n        mp = new HashMap();\n        for(int i = 2 * n - 1; i >= 0; i--){\n            if(mp.containsKey(nums[i % n])){\n                // System.out.println(mp.get(nums[i % n]) + \" \" + i);\n                close[i % n] = Math.min(close[i % n], mp.get(nums[i % n]) - i);\n            }\n            mp.put(nums[i % n], i);\n        }\n        \n        // int[] answer = new int[queries.length];\n        List <Integer> answer = new ArrayList();\n        for(int i = 0; i < queries.length; i++){\n            int x = close[queries[i]] == n ? -1 : close[queries[i]];\n            answer.add(x);\n        }\n        return answer;\n    }\n}","author":"Sri Akshya","submissionId":"1575102257"},[]]},{"138":[{"id":"138","fileName":"1575102794.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], qs: List[int]) -> List[int]:\n        d = defaultdict(list)\n        n = len(nums)\n        for i in range(n):\n            d[nums[i]].append(i)\n        ans = [-1] * n\n        for k in d:\n            a = d[k]\n            na = len(a)\n            if na <= 1:\n                continue\n            ans[a[0]] = min(a[1] - a[0], n + a[0] - a[na-1])\n            ans[a[na-1]] = min(a[na-1] - a[na-2], n + a[0] - a[na-1])\n            for i in range(1, na-1):\n                ans[a[i]] = min(a[i] - a[i-1], a[i+1] - a[i])\n        res = []\n        for q in qs:\n            res.append(ans[q])\n        return res\n        ","author":"xs_pg","submissionId":"1575102794"},[]]},{"139":[{"id":"139","fileName":"1575102763.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        unordered_map<int, vector<int>> v;\n        for (int i=0; i<nums.size(); ++i) {\n            v[nums[i]].push_back(i);\n        }\n        vector<int> res;\n        for (int i: q) {\n            int x=nums[i];\n            if (v.find(x)==v.end()) {\n                res.push_back(-1);\n            } else {\n                if (v[x].size()<=1) {\n                    res.push_back(-1);\n                } else {\n                    auto d=lower_bound(v[x].begin(), v[x].end(), i);\n                    if (d==v[x].begin()) {\n                        res.push_back(min(int(i+nums.size()-*prev(v[x].end())), int(*next(d)-i)));\n                    } else if (next(d)==v[x].end()) {\n                        res.push_back(min(int(*v[x].begin()+nums.size()-i), int(i-*prev(d))));\n                    } else {\n                        res.push_back(min(int(*next(d)-i), int(i-*prev(d))));\n                    }\n                }\n            }\n        }\n        return res;\n    }\n};","author":"lozy219","submissionId":"1575102763"},[]]},{"140":[{"id":"140","fileName":"1575102698.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n\n        n = len(nums)\n        # store prev and next for each num?\n        prev = [-1] * n\n        next = [-1] * n\n        last = {}\n        for i_unadj in range(n * 3):\n            i = i_unadj % n\n            num = nums[i]\n            if num in last:\n                if last[num] != i:\n                    next[last[num]] = i\n                    prev[i] = last[num]\n            last[num] = i\n\n        ans = []\n        for iq, q in enumerate(queries):\n            # print(f'query {iq}: {q}: nums[query]={nums[q]}')\n            if prev[q] == -1:\n                # print(f'only element')\n                ans.append(-1)\n            else:\n                ans.append(min((next[q] - q) % n, (q - next[q]) % n, (prev[q] - q) % n, (q - prev[q]) % n))\n\n        return ans","author":"miqro","submissionId":"1575102698"},[]]},{"141":[{"id":"141","fileName":"1575102839.txt","sourceCode":"class Solution:\n  def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n    n = len(nums)\n    num_to_indices = defaultdict(list)\n    for i in range(n):\n      num_to_indices[nums[i]].append(i)\n    \n    n_queries = len(queries)\n    ret = [0 for _ in range(n_queries)]\n    for i in range(n_queries):\n      index = queries[i]\n      num = nums[index]\n      indices = num_to_indices[num]\n      if len(indices) == 1:\n        ret[i] = -1\n        continue\n\n      i0 = bisect.bisect_left(indices, index)\n      ret[i] = min(\n        n + indices[i0] - indices[-1] if i0 == 0 else indices[i0] - indices[i0 - 1],\n        n + indices[0] - indices[i0] if i0 + 1 == len(indices) else indices[i0 + 1] - indices[i0]\n      )\n    return ret\n      ","author":"hope_ma","submissionId":"1575102839"},[]]},{"142":[{"id":"142","fileName":"1575102860.txt","sourceCode":"//████████╗██╗███╗░░██╗  ██╗░░░░░███████╗\n//╚══██╔══╝██║████╗░██║  ██║░░░░░██╔════╝\n//░░░██║░░░██║██╔██╗██║  ██║░░░░░█████╗░░\n//░░░██║░░░██║██║╚████║  ██║░░░░░██╔══╝░░\n//░░░██║░░░██║██║░╚███║  ███████╗███████╗\n//░░░╚═╝░░░╚═╝╚═╝░░╚══╝  ╚══════╝╚══════╝\n//   __________________\n//  | ________________ |\n//  ||          ____  ||\n//  ||   /    |      ||\n//  ||  /__   |      ||\n//  || /      |____  ||\n//  ||________________||\n//  |__________________|\n//  ###################\n//   ###################\n//            ____       \n//     _________________\n// An AC a day keeps the doctor away.\n\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <iomanip>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <array>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\ntemplate<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n#define vt vector\n#define all(x) begin(x), end(x)\n#define allr(x) rbegin(x), rend(x)\n#define ub upper_bound\n#define lb lower_bound\n#define db double\n#define ld long db\n#define ll long long\n#define ull unsigned long long\n#define vll vt<ll>  \n#define vvll vt<vll>\n#define pll pair<ll, ll>    \n#define vpll vt<pll>\n#define vvpll vt<vpll>\n#define vc vt<char> \n#define vvc vt<vc>\n#define vi vt<int>\n#define vvi vt<vi>\n#define vvvi vt<vvi>\n#define pii pair<int, int>\n#define vpii vt<pii>\n#define vs vt<string>\n#define vvs vt<vs>\n#define vb vt<bool>\n#define vvb vt<vb>\n#define vvpii vt<vpii>\n#define vd vt<db>\n#define ar(x) array<int, x>\n#define var(x) vt<ar(x)>\n#define vvar(x) vt<var(x)>\n#define al(x) array<ll, x>\n#define vall(x) vt<al(x)>\n#define vvall(x) vt<vall(x)>\n#define mset(m, v) memset(m, v, sizeof(m))\n#define pb push_back\n#define ff first\n#define ss second\n#define sv string_view\n#define MP make_pair\n#define MT make_tuple\n#define rsz resize\n#define sum(x) (ll)accumulate(all(x), 0LL)\n#define srt(x) sort(all(x))\n#define srtR(x) sort(allr(x))\n#define srtU(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())\n#define SORTED(x) is_sorted(all(x))\n#define rev(x) reverse(all(x))\n#define MAX(a) *max_element(all(a)) \n#define MIN(a) *min_element(all(a))\n#define ROTATE(a, p) rotate(begin(a), begin(a) + p, end(a))\n#define i128 __int128\n\n//SGT DEFINE\n#define lc i * 2 + 1\n#define rc i * 2 + 2\n#define lp lc, left, middle\n#define rp rc, middle + 1, right\n#define entireTree 0, 0, n - 1\n#define midPoint left + (right - left) / 2\n#define pushDown push(i, left, right)\n#define iter int i, int left, int right\n\n#define IOS ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n\nstruct custom {\n    static const uint64_t C = 0x9e3779b97f4a7c15; const uint32_t RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();\n    size_t operator()(uint64_t x) const { return __builtin_bswap64((x ^ RANDOM) * C); }\n    size_t operator()(const std::string& s) const { size_t hash = std::hash<std::string>{}(s); return hash ^ RANDOM; } };\ntemplate <class K, class V> using umap = std::unordered_map<K, V, custom>; template <class K> using uset = std::unordered_set<K, custom>;\ntemplate<class T> using max_heap = priority_queue<T>;\ntemplate<class T> using min_heap = priority_queue<T, vector<T>, greater<T>>;\n    \n    \ntemplate <typename T1, typename T2>  istream &operator>>(istream& in, pair<T1, T2>& input) {    return in >> input.ff >> input.ss; }\n    \ntemplate <typename T> istream &operator>>(istream &in, vector<T> &v) { for (auto &el : v) in >> el; return in; }\n\ntemplate<class T>\nvoid output_vector(vt<T>& a, int off_set = 0) {\n    int n = a.size();\n    for(int i = off_set; i < n; i++) {\n        cout << a[i] << (i == n - 1 ? 'n' : ' ');\n    }\n}\n\ntemplate<typename T, typename Compare>\nvi closest_left(const vt<T>& a, Compare cmp) {\n    int n = a.size(); vi closest(n); iota(all(closest), 0);\n    for (int i = 0; i < n; i++) {\n        auto& j = closest[i];\n        while(j && cmp(a[i], a[j - 1])) j = closest[j - 1];\n    }\n    return closest;\n}\n\ntemplate<typename T, typename Compare> // auto right = closest_right<int>(a, std::less<int>());\nvi closest_right(const vt<T>& a, Compare cmp) {\n    int n = a.size(); vi closest(n); iota(all(closest), 0);\n    for (int i = n - 1; i >= 0; i--) {\n        auto& j = closest[i];\n        while(j < n - 1 && cmp(a[i], a[j + 1])) j = closest[j + 1];\n    }\n    return closest;\n}\n\ntemplate<typename T, typename V = string>\nvt<pair<T, int>> encode(const V& s) {\n    vt<pair<T, int>> seg;\n    for(auto& ch : s) {\n        if(seg.empty() || ch != seg.back().ff) seg.pb({ch, 1});\n        else seg.back().ss++;\n    }\n    return seg;\n}\n\n    \ntemplate<typename K, typename V>\nauto operator<<(std::ostream &o, const std::map<K, V> &m) -> std::ostream& {\n    o << \"{\"; int i = 0;\n    for (const auto &[key, value] : m) { if (i++) o << \" , \"; o << key << \" : \" << value; }\n    return o << \"}\";\n}\n\n#ifdef LOCAL\n#define debug(x...) debug_out(#x, x)\nvoid debug_out(const char* names) { std::cerr << std::endl; }\ntemplate <typename T, typename... Args>\nvoid debug_out(const char* names, T value, Args... args) {\n    const char* comma = strchr(names, ',');\n    std::cerr << \"[\" << (comma ? std::string(names, comma) : names) << \" = \" << value << \"]\";\n    if (sizeof...(args)) { std::cerr << \", \"; debug_out(comma + 1, args...); }   \n    else { std::cerr << std::endl; }\n}\ntemplate<typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& o, const std::pair<T1, T2>& p) { return o << \"{\" << p.ff << \" , \" << p.ss << \"}\"; }\nauto operator<<(auto &o, const auto &x) -> decltype(end(x), o) {\n    o << \"{\"; int i = 0; for (const auto &e : x) { if (i++) o << \" , \"; o << e; } return o << \"}\";\n} // remove for leetcode\n#include <sys/resource.h>\n#include <sys/time.h>\nvoid printMemoryUsage() {\n    struct rusage usage;\n    getrusage(RUSAGE_SELF, &usage);\n    double memoryMB = usage.ru_maxrss / 1024.0;\n    cerr << \"Memory usage: \" << memoryMB << \" MB\" << \"n\";\n}\n\n#define startClock clock_t tStart = clock();\n#define endClock std::cout << std::fixed << std::setprecision(10) << \"nTime Taken: \" << (double)(clock() - tStart) / CLOCKS_PER_SEC << \" seconds\" << std::endl;\n#else\n#define debug(...)\n#define startClock\n#define endClock\n\n#endif\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define eps 1e-9\n#define M_PI 3.14159265358979323846\nconst static string pi = \"3141592653589793238462643383279\";\nconst static ll INF = 1LL << 62;\nconst static int inf = 1e9 + 100;\nconst static int MK = 20;\nconst static int MX = 1e5 + 5;\nconst static int MOD = 1e9 + 7;\nll gcd(ll a, ll b) { while (b != 0) { ll temp = b; b = a % b; a = temp; } return a; }\nll lcm(ll a, ll b) { return (a / gcd(a, b)) * b; }\nint pct(ll x) { return __builtin_popcountll(x); }\nll have_bit(ll x, int b) { return x & (1LL << b); }\nint min_bit(ll x) { return __builtin_ctzll(x); }\nint max_bit(ll x) { return 63 - __builtin_clzll(x); } \nconst vvi dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {1, 1}, {-1, -1}, {1, -1}, {-1, 1}}; // UP, DOWN, LEFT, RIGHT\nconst vc dirChar = {'U', 'D', 'L', 'R'};\nint modExpo(ll base, ll exp, ll mod) { ll res = 1; base %= mod; while(exp) { if(exp & 1) res = (res * base) % mod; base = (base * base) % mod; exp >>= 1; } return res; }\nint modExpo_on_string(ll a, string exp, int mod) { ll b = 0; for(auto& ch : exp) b = (b * 10 + (ch - '0')) % (mod - 1); return modExpo(a, b, mod); }\nll sum_even_series(ll n) { return (n / 2) * (n / 2 + 1);} \nll sum_odd_series(ll n) {return n - sum_even_series(n);} // sum of first n odd number is n ^ 2\nll sum_of_square(ll n) { return n * (n + 1) * (2 * n + 1) / 6; } // sum of 1 + 2 * 2 + 3 * 3 + 4 * 4 + ... + n * n\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& Q) {\n        int n = a.size(); \n        map<int, vi> mp;\n        for(int i = 0; i < n; i++) {\n            mp[a[i]].pb(i);\n        }\n        vi res;\n        auto get = [&](int x, int y) -> int {\n            if(x > y) swap(x, y);\n            return min(y - x, n - y + x);\n        };\n        debug(a, Q);\n        for(auto& x : Q) {\n            const auto& curr = mp[a[x]];\n            if(curr.size() <= 1) {\n                res.pb(-1);\n                continue;\n            }\n            int mn = inf;\n            auto it = ub(all(curr), x);\n            if(it != end(curr)) mn = min(mn, get(x, *it));\n            it--;\n            if(it != begin(curr)) mn = min(mn, get(x, *prev(it)));\n            if(x != *begin(curr)) mn = min(mn, get(x, *begin(curr)));\n            if(x != *prev(end(curr))) mn = min(mn, get(x, *prev(end(curr))));\n            debug(x, curr);\n            res.pb(mn);\n        }\n        return res;\n    }\n};\n\n#ifdef LOCAL\nvoid solve() {\n    int n, q; cin >> n >> q;\n    vi a(n), b(q); cin >> a >> b;\n    debug(a, b, n, q);\n    Solution sol;\n    cout << sol.solveQueries(a, b) << endl;\n}\n\nsigned main() {\n    // careful for overflow, check for long long, use unsigned long long for random generator\n    // when mle, look if problem require read in file, typically old problems\n    IOS;\n    startClock\n    //generatePrime();\n\n    int t = 1;\n    //cin >> t;\n    for(int i = 1; i <= t; i++) {   \n        //cout << \"Case #\" << i << \": \";  \n        solve();\n    }\n\n    endClock\n    #ifdef LOCAL\n      printMemoryUsage();\n    #endif\n\n    return 0;\n}\n#endif\n\n//███████████████████████████████████████████████████████████████████████████████████████████████████████\n//█░░░░░░░░░░░░░░█░░░░░░██████████░░░░░░█░░░░░░░░░░░░███░░░░░░░░░░█░░░░░░██████████░░░░░░█░░░░░░░░░░░░░░█\n//█░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀░░░░░░░░░░██░░▄▀░░█░░▄▀▄▀▄▀▄▀░░░░█░░▄▀▄▀▄▀░░█░░▄▀░░░░░░░░░░██░░▄▀░░█░░▄▀▄▀▄▀▄▀▄▀░░█\n//█░░▄▀░░░░░░░░░░█░░▄▀▄▀▄▀▄▀▄▀░░██░░▄▀░░█░░▄▀░░░░▄▀▄▀░░█░░░░▄▀░░░░█░░▄▀▄▀▄▀▄▀▄▀░░██░░▄▀░░█░░▄▀░░░░░░░░░░█\n//█░░▄▀░░█████████░░▄▀░░░░░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░███░░▄▀░░███░░▄▀░░░░░░▄▀░░██░░▄▀░░█░░▄▀░░█████████\n//█░░▄▀░░░░░░░░░░█░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░███░░▄▀░░███░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░█████████\n//█░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░███░░▄▀░░███░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░██░░░░░░█\n//█░░▄▀░░░░░░░░░░█░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░███░░▄▀░░███░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░█\n//█░░▄▀░░█████████░░▄▀░░██░░▄▀░░░░░░▄▀░░█░░▄▀░░██░░▄▀░░███░░▄▀░░███░░▄▀░░██░░▄▀░░░░░░▄▀░░█░░▄▀░░██░░▄▀░░█\n//█░░▄▀░░░░░░░░░░█░░▄▀░░██░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀░░░░▄▀▄▀░░█░░░░▄▀░░░░█░░▄▀░░██░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀░░░░░░▄▀░░█\n//█░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀░░██░░░░░░░░░░▄▀░░█░░▄▀▄▀▄▀▄▀░░░░█░░▄▀▄▀▄▀░░█░░▄▀░░██░░░░░░░░░░▄▀░░█░░▄▀▄▀▄▀▄▀▄▀░░█\n//█░░░░░░░░░░░░░░█░░░░░░██████████░░░░░░█░░░░░░░░░░░░███░░░░░░░░░░█░░░░░░██████████░░░░░░█░░░░░░░░░░░░░░█\n//███████████████████████████████████████████████████████████████████████████████████████████████████████\n","author":"tin_le","submissionId":"1575102860"},[]]},{"143":[{"id":"143","fileName":"1575103023.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> mp;\n        int n=nums.size();\n        for(int i=0;i<n;i++)\n            {\n                mp[nums[i]].push_back(i);\n            }\n        vector<int> ans;\n        for(int i=0;i<n;i++)\n            {\n                int res=-1;\n                int ind=-1;\n                int st=0,end=mp[nums[i]].size()-1;\n                int sz=mp[nums[i]].size();\n                while(st<=end)\n                    {\n                        int mid=(st+end)/2;\n                        if(mp[nums[i]][mid]>i)\n                        {\n                            ind=mp[nums[i]][mid];\n                            end=mid-1;\n                        }\n                        else\n                        {\n                            st=mid+1;\n                        }\n                    }\n                if(ind!=-1) \n                {\n                    if(res==-1) res=ind-i;\n                }\n                if(mp[nums[i]][sz-1]!=i) \n                {\n                    if(res==-1) res=i+(n-mp[nums[i]][sz-1]);\n                    else res=min(res,i+n-mp[nums[i]][sz-1]);\n                }\n                st=0,end=sz-1;\n                ind =-1;\n                while(st<=end)\n                    {\n                        int mid=(st+end)/2;\n                        if(mp[nums[i]][mid]<i)\n                        {\n                            ind=mp[nums[i]][mid];\n                            st=mid+1;\n                        }\n                        else\n                        {\n                            end=mid-1;\n                        }\n                    }\n                if(ind!=-1)\n                {\n                    if(res!=-1) res=min(res,i-ind);\n                    else res=i-ind;\n                }\n                if(mp[nums[i]][0]!=i)\n                {\n                    if(res==-1)\n                    {\n                        res=mp[nums[i]][0]+n-i;\n                    }\n                    else\n                    {\n                        res=min(res,mp[nums[i]][0]+n-i);\n                    }\n                    \n                }\n                ans.push_back(res);\n            }\n        vector<int> res;\n        for(auto j : queries) res.push_back(ans[j]);\n        return res;\n        \n    }\n};","author":"Neel Y Tandel","submissionId":"1575103023"},[]]},{"144":[{"id":"144","fileName":"1575103060.txt","sourceCode":"vector<int> a(1e6 + 5, -1);\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> dis(n, n);\n        std::fill(a.begin(), a.end(), -1);\n        for (int i = 0; i < n; i++) {\n            int x = nums[i];\n            if (a[x] != -1)  {\n                dis[i] = i - a[x];\n                dis[a[x]] = min(dis[a[x]], i - a[x]);\n            }\n            a[x] = i;\n        }\n        for (int i = 0; i < n; i++) {\n            int x = nums[i];\n            if (a[x] != 0) {\n                dis[i] = min(dis[i], n - a[x] + i);\n                dis[a[x]] = min(dis[a[x]], n - a[x] + i);\n            }\n        }\n        vector<int> ans;\n        for (auto i : queries) {\n            if (dis[i] == n) ans.push_back(-1);\n                else ans.push_back(dis[i]);\n        }\n        return ans;\n    }\n};","author":"Lpl","submissionId":"1575103060"},[]]},{"145":[{"id":"145","fileName":"1575103074.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        ll = len(nums)\n        d = defaultdict(list)\n        for i, v in enumerate(nums):\n            d[v].append(i)\n\n        for k, v in d.items():\n            if len(v) > 1:\n                d[k] =[v[-1] - ll] +  v + [v[0] + ll]\n\n\n        answer = []\n        for q in queries:\n            v = nums[q]\n            locs = d[v]\n            if len(locs) == 1:\n                answer.append(-1)\n                continue\n                \n            p = bisect_left(locs, q)\n            best = min(locs[p] - locs[p - 1], locs[p + 1] - locs[p])\n            answer.append(best)\n\n\n        return answer\n            \n        ","author":"Yiping","submissionId":"1575103074"},[]]},{"146":[{"id":"146","fileName":"1575103006.txt","sourceCode":"from collections import defaultdict\nimport bisect\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        lst = defaultdict(list)\n        for i, num in enumerate(nums):\n            lst[num].append(i)\n        \n        res = []\n        for q in queries:\n            num = nums[q]\n            if len(lst[num]) == 1:\n                res.append(-1)\n                continue\n            idx = bisect.bisect_left(lst[num], q)\n            l = len(lst[num])\n            left, right  = (idx - 1) % l, (idx + 1) % l\n            left, right = lst[num][left], lst[num][right]\n            # print(lst[num], left, right, q)\n            l = len(nums)\n            l_dist, r_dist = min(abs(q - left), l - abs(q - left)), min(abs(q - right), l - abs(q - right))\n            res.append(min(l_dist, r_dist))\n        \n        return res\n            ","author":"xy-li","submissionId":"1575103006"},[]]},{"147":[{"id":"147","fileName":"1575103214.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        store = defaultdict(list)\n        for idx, i in enumerate(nums):\n            store[i].append(idx)\n\n        res = []\n        for q in queries:\n            num = nums[q]\n            n = len(store[num])\n            if n == 1:\n                res.append(-1)\n            else:\n                idx = bisect_left(store[num], q)\n                if idx == n - 1:\n                    left = store[num][0] - q + len(nums)\n                else:\n                    other_idx = store[num][idx + 1]\n                    left = other_idx - q\n\n                if idx == 0:\n                    right = q - store[num][-1] + len(nums)\n                else:\n                    other_idx = store[num][idx - 1]\n                    right = q - other_idx \n                res.append(min(left, right))\n\n        return res","author":"rukt","submissionId":"1575103214"},[]]},{"148":[{"id":"148","fileName":"1575102407.txt","sourceCode":"#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef priority_queue<int> pq;\ntypedef priority_queue<int, vector<int>, greater<int>> pqg;\n#define fastio ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define sz(x) (int)(x).size()\n#define rep(i, a, b) for(int i = a; i < b; ++i)\n#define repr(i, a, b) for(int i = a; i >= b; --i)\n#define deb(x) cout << #x << \" = \" << x << endl;\n#define INF 1e9\n#define LINF 1e18\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int m = nums.size();\n        vector<int> ans;\n        unordered_map<int, vector<int>> indices;\n        for (int i = 0; i < m; i++) {\n            indices[nums[i]].push_back(i);\n        }\n        for (auto &p : indices) {\n            sort(p.second.begin(), p.second.end());\n        }\n        for (int q : queries) {\n            int value = nums[q];\n            const vector<int>& pos = indices[value];\n            if (pos.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            auto it = lower_bound(pos.begin(), pos.end(), q);\n            int idx = it - pos.begin();\n            int left = (idx == 0 ? pos.back() : pos[idx - 1]);\n            int right = (idx == pos.size() - 1 ? pos.front() : pos[idx + 1]);\n            int d1 = abs(q - left);\n            d1 = min(d1, m - d1);\n            int d2 = abs(right - q);\n            d2 = min(d2, m - d2);\n            ans.push_back(min(d1, d2));\n        }\n        return ans;\n    }\n};\n","author":"miku","submissionId":"1575102407"},[]]},{"150":[{"id":"150","fileName":"1575103286.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        counter = collections.defaultdict(list)\n        for i, num in enumerate(nums):\n            counter[num].append(i)\n        res = []\n        # print(counter)\n        for q in queries:\n            idx = counter[nums[q]]\n            if len(idx) == 1:\n                res.append(-1)\n                continue\n            p = bisect.bisect_left(idx, q)\n            if p == 0:\n                prev_dist = q+n - idx[-1]\n            else:\n                prev_dist = q - idx[p-1]\n                \n            if p == len(idx)-1:\n                next_dist = idx[0]+n - q\n            else:\n                next_dist = idx[p+1] - q\n                \n            res.append(min(prev_dist, next_dist))\n        return res","author":"Mark33","submissionId":"1575103286"},[]]},{"152":[{"id":"152","fileName":"1575103287.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        num2idx = collections.defaultdict(list)\n        n = len(nums)\n        for i, num in enumerate(nums):\n            num2idx[num].append(i)\n\n        result = []\n        for q in queries:\n            target = nums[q]\n            array = num2idx[target]\n            result.append(self.find_closest(array, q, n))\n        return result\n\n    def find_closest(self, array, idx, n)-> int:\n        if len(array) == 1:\n            return -1\n        start = 0\n        end = len(array) - 1\n        target = 0\n        while start <= end:\n            mid = start + (end - start)//2\n            if array[mid] == idx:\n                target = mid\n                break\n            elif array[mid] < idx:\n                start = mid + 1\n            else:\n                end = mid - 1\n        if target == 0:\n            left = array[-1] \n            left_dis = idx + n - left \n        else:\n            left = array[target - 1]\n            left_dis = idx - left\n        if target == len(array) - 1:\n            right = array[0]\n            right_dis = right + n - idx\n        else:\n            right = array[target + 1]\n            right_dis = right - idx\n        return min(left_dis, right_dis)","author":"juggernutx","submissionId":"1575103287"},[]]},{"153":[{"id":"153","fileName":"1575103301.txt","sourceCode":"from bisect import bisect_left\n\nclass Solution:\n    def solveQueries(self, nums: List[int], qs: List[int]) -> List[int]:\n        n = len(nums)\n        d = {}\n        for i, v in enumerate(nums):\n            d.setdefault(v, []).append(i)\n        for k in d:\n            d[k].sort()\n        r = []\n        for q in qs:\n            v = nums[q]\n            a = d[v]\n            if len(a) < 2:\n                r.append(-1)\n                continue\n            i = bisect_left(a, q)\n            if i == 0:\n                dl = q + n - a[-1]\n            else:\n                dl = q - a[i - 1]\n            if i == len(a) - 1:\n                dr = a[0] + n - q\n            else:\n                dr = a[i + 1] - q\n            r.append(min(dl, dr))\n        return r\n\ndef seg_tree_sample(a):\n    n = len(a)\n    s = 1\n    while s < n: s *= 2\n    t = [0] * (2 * s)\n    for i in range(n):\n        t[s + i] = a[i]\n    for i in range(s - 1, 0, -1):\n        t[i] = t[2 * i] + t[2 * i + 1]\n    def q(l, r):\n        l += s; r += s; s_ = 0\n        while l <= r:\n            if l & 1:\n                s_ += t[l]\n                l += 1\n            if not r & 1:\n                s_ += t[r]\n                r -= 1\n            l //= 2; r //= 2\n        return s_\n    return t, q\n\ndef binary_search_sample(a, x):\n    l, r = 0, len(a) - 1\n    while l <= r:\n        m = (l + r) // 2\n        if a[m] == x: return m\n        if a[m] < x: l = m + 1\n        else: r = m - 1\n    return -1\n","author":"8iRTeedKTz","submissionId":"1575103301"},[]]},{"154":[{"id":"154","fileName":"1575103400.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = defaultdict(list)\n        for i in range(len(nums)):\n            d[nums[i]].append(i)\n        ans = []\n        for i in queries:\n            p = d[nums[i]]\n            ind = bisect.bisect_left(p,i)\n            if len(p)==1:\n                ans.append(-1)\n            else:\n                res = 0\n                if ind>0 and ind<len(p)-1:\n                    res = min(i-p[ind-1], p[ind+1]-i)\n                elif ind==0:\n                    res = min(p[ind+1]-i, i+len(nums)-p[-1])\n                elif ind==len(p)-1:\n                    res = min(i-p[ind-1], len(nums)-i+p[0])\n                ans.append(res)\n        return ans","author":"Shivam Kumar","submissionId":"1575103400"},[]]},{"155":[{"id":"155","fileName":"1575103416.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int, vector<int>> positions;\n        vector<int> closest (n);\n\n        for (int i = 0; i < n; i++)\n            positions[nums[i]].push_back(i);\n\n        for (auto it = positions.begin(); it != positions.end(); it++) {\n            for (int i = 0; i < it->second.size(); i++) {\n                int before = i == 0 ? it->second[it->second.size() - 1] : it->second[i - 1];\n                int after = i == it->second.size() - 1 ? it->second[0] : it->second[i + 1];\n                int closestBefore = before < it->second[i] ? min(it->second[i] - before, n - it->second[i] + before) : min(before - it->second[i], n - before + it->second[i]);\n                int closestAfter = after < it->second[i] ? min(it->second[i] - after, n - it->second[i] + after) : min(after - it->second[i], n - after + it->second[i]);\n                closest[it->second[i]] = min(closestBefore, closestAfter);\n            }\n        }\n\n        vector<int> res (queries.size());\n        for (int i = 0; i < res.size(); i++) {\n            res[i] = closest[queries[i]];\n            if (res[i] == 0) res[i] = -1;\n        }\n        return res;\n    }\n};","author":"Matt Akin","submissionId":"1575103416"},[]]},{"156":[{"id":"156","fileName":"1575103890.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<int> result(m, -1);\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; ++i) {\n            mp[nums[i]].push_back(i);\n        }\n        int count = -1;\n        for (int query : queries) {\n            ++count;\n            // cout << query << \" \" << mp[nums[query]].size() << endl;\n            if (mp[nums[query]].size() == 1) {\n                continue;\n            }\n            vector<int>::iterator it = lower_bound(mp[nums[query]].begin(), mp[nums[query]].end(), query);\n            int left = it == mp[nums[query]].begin() ? n - mp[nums[query]].back() + *it : *it - *(it - 1);\n            int right = it + 1 == mp[nums[query]].end() ? mp[nums[query]].front() + n - *it : *(it + 1) - *it;\n            // cout << left << \" \" << right << endl;\n            result[count] = min(left, right);\n        }\n        return result;\n    }\n};","author":"Mark Qi","submissionId":"1575103890"},[]]},{"158":[{"id":"158","fileName":"1575103418.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        INF = float('inf')\n        ans = [INF] * n\n        \n        seen = {}\n        for i in range(n):\n            j = nums[i]\n            if j in seen:\n                dist = i - seen[j]\n                ans[i] = min(ans[i], dist)\n                ans[seen[j]] = min(ans[seen[j]], dist)\n            seen[j] = i\n        \n        seen = {}\n        for i in range(n - 1, -1, -1):\n            j = nums[i]\n            if j in seen:\n                dist = seen[j] - i\n                ans[i] = min(ans[i], dist)\n                ans[seen[j]] = min(ans[seen[j]], dist)\n            seen[j] = i\n        \n        pos = {}\n        for i, j in enumerate(nums):\n            if j not in pos:\n                pos[j] = []\n            pos[j].append(i)\n        for j, indices in pos.items():\n            if len(indices) >= 2:\n                first, last = indices[0], indices[-1]\n                d = first + n - last\n                ans[first] = min(ans[first], d)\n                ans[last] = min(ans[last], d)\n        \n        result = []\n        for q in queries:\n            result.append(ans[q] if ans[q] != INF else -1)\n        return result","author":"Sujith Kumar K","submissionId":"1575103418"},[]]},{"159":[{"id":"159","fileName":"1575103431.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d={}\n        n=len(nums)\n        for i in range(n):\n            if nums[i] in d:\n                d[nums[i]].append(i)\n            else:\n                d[nums[i]] = [i]\n        a=[-1]*len(nums)\n        for i in d:\n            if len(d[i]) >= 2:\n                a[d[i][0]] = min(d[i][1] - d[i][0], d[i][0] + n - d[i][-1]) \n                a[d[i][-1]] = min(d[i][-1] - d[i][-2], d[i][0] + n - d[i][-1])\n                for j in range(1,len(d[i])-1):\n                    a[d[i][j]] = min(d[i][j] - d[i][j-1], d[i][j+1] - d[i][j])\n        ta=[]\n        for i in queries:\n            ta.append(a[i])\n        return ta\n","author":"Ageera Saiteja","submissionId":"1575103431"},[]]},{"161":[{"id":"161","fileName":"1575103976.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> pos;\n        int n = nums.size();\n        for(int i = 0; i< n; i++)\n        {\n            int x = nums[i];\n            pos[x].push_back(i-n);\n            pos[x].push_back(i);\n            pos[x].push_back(i+n);\n        }\n        \n        for(auto &p : pos)\n        {\n            sort(p.second.begin(), p.second.end());\n        }\n        \n        vector<int> r;\n        for(auto &u : queries)\n        {\n            int x = nums[u];\n            auto &V = pos[x];\n            auto it = upper_bound(V.begin(), V.end(), u);\n            auto ti = lower_bound(V.begin(), V.end(), u);\n            ti--;\n            int ans = min(u-*ti, *it-u);\n            if(ans == n)\n            {\n                ans = -1;\n            }\n            r.push_back(ans);\n        }\n        return r;\n    }\n};","author":"Marmaduke","submissionId":"1575103976"},[]]},{"162":[{"id":"162","fileName":"1575104019.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> indices;\n        for (int i = 0; i < n; ++i) {\n            indices[nums[i]].push_back(i);\n        }\n        vector<int> res;\n        for (auto& query : queries) {\n            int ans = n + 1;\n            int num = nums[query];\n            if (indices[num].size() > 1) {\n                auto lb = lower_bound(indices[num].begin(), indices[num].end(), query);\n                if (lb == prev(indices[num].end())) {\n                    ans = min(ans, n - *lb - 1 + indices[num][0] + 1);\n                } else {\n                    ans = min(ans, *next(lb) - *lb);\n                }\n                if (lb == indices[num].begin()) {\n                    ans = min(ans, n - *prev(indices[num].end()) - 1 + *lb + 1);\n                } else {\n                    ans = min(ans, *lb - *prev(lb));\n                }\n            }\n            if (ans > n) ans = -1;\n            res.push_back(ans);\n        }\n        return res;\n    }\n};","author":"whitewale","submissionId":"1575104019"},[]]},{"163":[{"id":"163","fileName":"1575104084.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        int n = (int) nums.size();\n\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].emplace_back(i);\n        }\n\n        vector<int> res;\n\n        for (int& i: queries) {\n            int val = nums[i];\n            auto& arr = mp[val];\n            int len = (int) arr.size();\n\n            if (len == 1) {\n                res.push_back(-1);\n                continue;\n            }\n            \n            int pos = lower_bound(arr.begin(), arr.end(), i) - arr.begin();\n            int mn = n;\n            \n            for (int j: {1, -1}) {\n                int x = (pos + j + len) % len;\n                int diff = abs(i - arr[x]);\n                mn = min(mn, min(diff, n - diff));\n                // cout << val << \" \" << arr[x] << endl;\n            }\n\n            res.push_back(mn);\n        }\n        \n        return res;\n    }\n};","author":"Ajay Singh Deopa","submissionId":"1575104084"},[]]},{"164":[{"id":"164","fileName":"1575104052.txt","sourceCode":"/**\n * @Author: Qirun Zeng qirunzen@gmail.com\n * @Date: 2025-03-16 10:28:03\n * @LastEditors: Qirun Zeng\n * @LastEditTime: 2025-03-16 10:28:03\n * @Description: file content\n */\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <numeric>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> ump;\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            ump[nums[i]].push_back(i);\n        }\n        vector<int> ret;\n        for (auto q : queries) {\n            auto &arr = ump[nums[q]];\n            if (arr.size() == 1) {\n                ret.push_back(-1);\n                continue;\n            }\n            int l = 0, r = arr.size() - 1;\n            int idx = 0;\n            while (l <= r) {\n                int mid = (l+r) >> 1;\n                if (arr[mid] <= q) {\n                    idx = mid;\n                    l = mid+1;\n                } else {\n                    r = mid-1;\n                }\n            }\n            if (idx == arr.size()-1) {\n                ret.push_back(min(arr[idx]-arr[idx-1], n+arr[0]-arr[idx]));\n            } else if (idx == 0) {\n                ret.push_back(min(arr[1]-arr[0], n+arr[0]-arr.back()));\n            } else {\n                ret.push_back(min(arr[idx]-arr[idx-1], arr[idx+1]-arr[idx]));\n            }\n        }\n        return ret;\n    }\n};","author":"qirunzeng","submissionId":"1575104052"},[]]},{"165":[{"id":"165","fileName":"1575104047.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> m;\n        int i = 0;\n        for (int num : nums) {\n            m[num].push_back(i++);\n        }\n        \n        vector<int> res;\n        \n        for (int q : queries) {\n            int num = nums[q];\n            if (m[num].size() == 1) {\n                res.push_back(-1);\n            } else {\n                int idx = lower_bound(m[num].begin(), m[num].end(), q) - m[num].begin();\n                int M = m[num].size();\n                int l = (idx - 1 + M) % M;\n                int r = (idx + 1) % M;\n                int a = min(abs(m[num][idx]-m[num][l]), (int)nums.size() - abs(m[num][idx]-m[num][l]));\n                int b = min(abs(m[num][r]-m[num][idx]), (int)nums.size() - abs(m[num][r]-m[num][idx]));\n                res.push_back(min(a, b));\n            }\n        }\n        \n        return res;\n    }\n};","author":"NaoJoeMiao","submissionId":"1575104047"},[]]},{"166":[{"id":"166","fileName":"1575104148.txt","sourceCode":"#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define sz(s) (int)(s).size()\n#define all(s) s.begin(),s.end()\n\nvoid Speed() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n}\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> mp;\n        for(int i = 0; i < sz(nums); i++){\n            mp[nums[i]].push_back(i);\n        }      \n\n        int n = sz(nums);\n\n        auto check = [&](int i, int j) -> int{\n            if(i == j) return 1e9;\n            return min(abs(i - j), n - max(i, j) + min(i, j));\n        };\n\n        vector<int> ans;\n        for(auto it : queries){\n            int x = nums[it];\n            if(sz(mp[x]) == 1){\n                ans.push_back(-1);\n                continue;\n            }\n            auto idx = upper_bound(all(mp[x]), it) - mp[x].begin();\n            int res = min(check(mp[x][0], it), check(mp[x].back(), it));\n            if(idx == sz(mp[x])) idx--;\n            for(int k = 0; k < 3 && idx >= 0; k++){\n                res = min(res, check(mp[x][idx], it));\n                idx--;\n            }\n            ans.push_back(res);\n        }\n        return ans;\n    }\n};","author":"Anas Maged","submissionId":"1575104148"},[]]},{"168":[{"id":"168","fileName":"1575104125.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int, int> last;\n        map<int, int> first;\n        vector<int> ans(n, n);\n        for(int i = 0; i < n; i++){\n            if(first.find(nums[i]) == first.end()) first[nums[i]] = i;\n            if(last.find(nums[i]) != last.end()) ans[i] = min(i - last[nums[i]], n - i + first[nums[i]]);\n            last[nums[i]] = i;\n        }\n        \n        first.clear();\n        last.clear();\n        reverse(nums.begin(), nums.end());\n        \n        for(int i = 0; i < n; i++){\n            if(first.find(nums[i]) == first.end()) first[nums[i]] = i;\n            if(last.find(nums[i]) != last.end()) {\n                ans[n - i - 1] = min(ans[n-i-1], min(i - last[nums[i]], n - i + first[nums[i]]));\n            }\n            last[nums[i]] = i;\n        }\n        \n        vector<int> re;\n        for(int i : queries){\n            re.push_back((ans[i] < n) ? ans[i] : -1);\n        }\n        return re;\n    }\n};","author":"lukewu28","submissionId":"1575104125"},[]]},{"169":[{"id":"169","fileName":"1575104261.txt","sourceCode":"map<int,vector<int>> indices;\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        indices.clear();\n        int n=nums.size();\n        for(int i=0;i<n;i++) indices[nums[i]].push_back(i);\n        vector<int> ans;\n        for(int q: queries){\n            if(indices[nums[q]].size()==1){\n                ans.push_back(-1);\n                continue;\n            }\n            int index=lower_bound(indices[nums[q]].begin(),indices[nums[q]].end(),q)-indices[nums[q]].begin();\n            int m=indices[nums[q]].size(),prev=indices[nums[q]][(index-1+m)%m],next=indices[nums[q]][(index+1)%m];\n            int res=min(abs(q-prev),(n-abs(q-prev)));\n            res=min(res,min(abs(q-next),(n-abs(q-next))));\n            ans.push_back(res);\n        }\n        return ans;\n    }\n};","author":"justDummy","submissionId":"1575104261"},[]]},{"170":[{"id":"170","fileName":"1575104217.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        graph = [sys.maxsize] * len(nums)  # for each element at index i, find the previous element\n        \n        cnt = collections.defaultdict(list)\n        for i in range(len(nums)):\n            \n            v = nums[i]\n            \n            if v in cnt:\n                first = cnt[v][0]\n                last = cnt[v][-1]\n                \n                dist1 = len(nums) + first - i\n                dist2 = i - last\n                \n                graph[i] = min(graph[i], dist1)\n                graph[first] = min(graph[first], dist1)\n                \n                graph[i] = min(graph[i], dist2)\n                graph[last] = min(graph[last], dist2)\n                \n            cnt[v].append(i)\n        \n        res = []\n        for q in queries:\n            if graph[q] == sys.maxsize:\n                res.append(-1)\n            else:\n                res.append(graph[q])\n                \n        return res\n            ","author":"lichuan199010","submissionId":"1575104217"},[]]},{"171":[{"id":"171","fileName":"1575104298.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        map<int,vector<int>> mp;\n        vector<int> ans;\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        for(auto x:q){\n            int z=nums[x];\n            int idx=lower_bound(mp[z].begin(),mp[z].end(),x)-mp[z].begin();\n            if(mp[z].size()<2) {ans.push_back(-1);continue;}\n            int cur=INT_MAX;\n            if(idx>0) cur=min(cur,abs(mp[z][idx]-mp[z][idx-1]));\n            else cur=min(cur,abs(mp[z][idx]+n-mp[z].back()));\n            if(idx<mp[z].size()-1){\n                cur=min(cur,abs(mp[z][idx]-mp[z][idx+1]));\n            }\n            else cur=min(cur,abs(-mp[z][idx]+n+mp[z][0]));\n            ans.push_back(cur);\n        }\n        return ans;\n    }\n};","author":"Arpan Tomar","submissionId":"1575104298"},[]]},{"172":[{"id":"172","fileName":"1575104510.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums, queries):\n        n = len(nums)\n        # Initialize the result for each index in nums as -1.\n        result = [-1] * n\n        \n        from collections import defaultdict\n        positions = defaultdict(list)\n        # Build a dictionary mapping each number to the list of indices where it occurs.\n        for i, num in enumerate(nums):\n            positions[num].append(i)\n        \n        # For each number that appears more than once, compute the minimum circular distance for each occurrence.\n        for num, pos_list in positions.items():\n            if len(pos_list) < 2:\n                continue  # Only one occurrence; result remains -1.\n            m = len(pos_list)\n            for j, idx in enumerate(pos_list):\n                # Get the previous and next occurrence (using circular indexing)\n                prev_idx = pos_list[j - 1]  # Python negative index wraps around.\n                next_idx = pos_list[(j + 1) % m]\n                \n                # Calculate the circular distances.\n                d1 = abs(idx - prev_idx)\n                d1 = min(d1, n - d1)\n                d2 = abs(next_idx - idx)\n                d2 = min(d2, n - d2)\n                \n                result[idx] = min(d1, d2)\n                \n        # For each query, return the precomputed result.\n        return [result[q] for q in queries]\n\n\n# Example usage:\nif __name__ == \"__main__\":\n    sol = Solution()\n    \n    # Example 1:\n    nums = [1, 3, 1, 4, 1, 3, 2]\n    queries = [0, 3, 5]\n    print(sol.solveQueries(nums, queries))  # Expected output: [2, -1, 3]\n    \n    # Example 2:\n    nums = [1, 2, 3, 4]\n    queries = [0, 1, 2, 3]\n    print(sol.solveQueries(nums, queries))  # Expected output: [-1, -1, -1, -1]\n","author":"karthikeyan","submissionId":"1575104510"},[{"id":"553","similarity":1.0,"totOverlap":184,"longestOverlap":92}]],"553":[{"id":"553","fileName":"1575118803.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums, queries):\n        n = len(nums)\n        # Initialize the result for each index in nums as -1.\n        result = [-1] * n\n        \n        from collections import defaultdict\n        positions = defaultdict(list)\n        # Build a dictionary mapping each number to the list of indices where it occurs.\n        for i, num in enumerate(nums):\n            positions[num].append(i)\n        \n        # For each number that appears more than once, compute the minimum circular distance for each occurrence.\n        for num, pos_list in positions.items():\n            if len(pos_list) < 2:\n                continue  # Only one occurrence; result remains -1.\n            m = len(pos_list)\n            for j, idx in enumerate(pos_list):\n                # Get the previous and next occurrence (using circular indexing)\n                prev_idx = pos_list[j - 1]  # Python negative index wraps around.\n                next_idx = pos_list[(j + 1) % m]\n                \n                # Calculate the circular distances.\n                d1 = abs(idx - prev_idx)\n                d1 = min(d1, n - d1)\n                d2 = abs(next_idx - idx)\n                d2 = min(d2, n - d2)\n                \n                result[idx] = min(d1, d2)\n                \n        # For each query, return the precomputed result.\n        return [result[q] for q in queries]\n\n\n# Example usage:\nif __name__ == \"__main__\":\n    sol = Solution()\n    \n    # Example 1:\n    nums = [1, 3, 1, 4, 1, 3, 2]\n    queries = [0, 3, 5]\n    print(sol.solveQueries(nums, queries))  # Expected output: [2, -1, 3]\n    \n    # Example 2:\n    nums = [1, 2, 3, 4]\n    queries = [0, 1, 2, 3]\n    print(sol.solveQueries(nums, queries))  # Expected output: [-1, -1, -1, -1]\n","author":"kishour","submissionId":"1575118803"},[{"id":"172","similarity":1.0,"totOverlap":184,"longestOverlap":92}]]},{"175":[{"id":"175","fileName":"1575104523.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = defaultdict(list)\n        for i, num in enumerate(nums):\n            d[num] += [i]\n            \n        out = []\n        l = len(nums)\n        \n        def circular(freq, ind, l):\n            if len(freq) == 1:\n                return -1\n            if len(freq) == ind + 1:\n                # admissible = {freq[0], freq[ind - 1]}\n                distance = min(freq[ind]-freq[ind-1], freq[0]+ l -freq[ind])\n                return distance\n            if ind == 0:\n                distance = min(freq[1]-freq[0], freq[0]+ l - freq[-1])\n                return distance\n            distance = min (freq[ind+1]-freq[ind],freq[ind]-freq[ind-1])\n            return distance\n                \n            \n        for query in queries:\n            num = nums[query]\n            freq = d[num]\n            ind = bisect.bisect_left(freq, query)\n            distance = circular(freq, ind, l)\n            out += [distance]\n        return out\n                \n                ","author":"Aluminum57","submissionId":"1575104523"},[]]},{"177":[{"id":"177","fileName":"1575104686.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> v(n, INT_MAX);\n        map<int, pair<int, int>> mp;\n        for(int I = 0 ; I < n ; ++I){\n            int i = nums[I];\n            if(mp.find(i) == mp.end()){\n                mp[i] = {I,I};\n            }\n            else{\n                auto [a,b] = mp[i];\n                int L = I - b;\n                int R = a + n - I;\n                v[a] = min(v[a], R);\n                v[b] = min(v[b], L);\n                v[I] = min(L,R);\n                mp[i] = {a, I};\n            }\n        }\n        vector<int> res;\n        for(int i : queries)\n            res.push_back(v[i] == INT_MAX ? -1 : v[i]);\n        return res;\n    }\n};","author":"育志 林","submissionId":"1575104686"},[]]},{"178":[{"id":"178","fileName":"1575104328.txt","sourceCode":"class Solution {\nprivate:\n    #define INF (int)1e18\n    #define all(x) (x).begin(), (x).end()\n\n    using i64 = long long;\n    using u64 = unsigned long long;\n\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<i64, vector<i64>> valueToind;\n        i64 n = nums.size();\n        for (i64 i = 0; i < n; ++i) {\n            valueToind[nums[i]].push_back(i);\n        }\n        \n        vector<int> answer;\n        for (i64 q : queries) {\n            i64 v = nums[q];\n            auto& indices = valueToind[v];\n            if (indices.size() == 1) {\n                answer.push_back(-1);\n                continue;\n            }\n            \n            auto it = lower_bound(all(indices), q);\n            i64 pos = it - indices.begin();\n            \n            i64 left, right;\n            (pos > 0) ? left = indices[pos - 1] : left = indices.back();\n            \n            if (pos < indices.size() - 1) {\n                right = indices[pos + 1];\n            } else {\n                right = indices[0];\n            }\n            \n            i64 dl = std::min(abs(q - left), n - abs(q - left));\n            i64 dr = std::min(abs(q - right), n - abs(q - right));\n            answer.push_back(min(dl, dr));\n        }\n        \n        return answer;\n    }\n};","author":"Heisenberg","submissionId":"1575104328"},[]]},{"179":[{"id":"179","fileName":"1575104925.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> idxs;\n        for(int i = 0; i < n; i++)\n            idxs[nums[i]].push_back(i);\n\n        int qs = queries.size();\n        vector<int> out(qs, -1);\n        for(int i = 0; i < qs; i++) {\n            int q = queries[i];\n            const auto& idxL = idxs[nums[q]];\n            if(idxL.size() == 1)\n                continue;\n\n            auto it = lower_bound(idxL.begin(), idxL.end(), q);\n            int l, r;\n            if(it == idxL.begin())\n                l = *idxL.rbegin();\n            else\n                l = *(it - 1);\n            if(it + 1 == idxL.end())\n                r = *idxL.begin();\n            else\n                r = *(it + 1);\n\n            int dl, dr;\n            if(l < q)\n                dl = q - l;\n            else\n                dl = q + n - l;\n            if(q < r)\n                dr = r - q;\n            else\n                dr = n - q + r;\n            out[i] = min(dl, dr);\n        }\n        return out;\n    }\n};","author":"Atul","submissionId":"1575104925"},[]]},{"180":[{"id":"180","fileName":"1575104943.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = defaultdict(list)\n        for i, x in enumerate(nums):\n            d[x].append(i)\n        ret = []\n        for q in queries:\n            x = nums[q]\n            arr = d[x]\n            if len(arr) < 2:\n                ret.append(-1)\n            else:\n                b = bisect.bisect_left(arr, q)\n                if b == 0:\n                    ret.append(min(arr[1] - arr[0], arr[0] + len(nums) - arr[-1]))\n                elif b == len(arr) - 1:\n                    ret.append(min(arr[-1] - arr[-2], arr[0] + len(nums) - arr[-1]))\n                else:\n                    ret.append(min(arr[b] - arr[b - 1], arr[b + 1] - arr[b]))\n        return ret","author":"henrysux","submissionId":"1575104943"},[]]},{"181":[{"id":"181","fileName":"1575104982.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, TreeSet<Integer>> map = new HashMap<Integer, TreeSet<Integer>>();\n        for (int i = 0; i < nums.length; i++) {\n            if (!map.containsKey(nums[i])) {\n                map.put(nums[i], new TreeSet<>());\n                map.get(nums[i]).add(i);\n            }\n            else{\n                map.get(nums[i]).add(i);\n            }\n        }\n        ArrayList<Integer> ans = new ArrayList<>();\n        for (int q: queries) {\n            int num = nums[q];\n            TreeSet<Integer> set = map.get(num);\n            if (set.size() == 1) {\n                ans.add(-1);\n                continue;\n            }\n            int minDist = Integer.MAX_VALUE;\n            Integer lower = set.lower(q);\n            Integer higher = set.higher(q);\n            if (lower != null) {\n                minDist = q - lower;\n                //System.out.println(\"lower\" + ((int)lower - q));\n            }\n            else {\n                Integer max = set.lower(Integer.MAX_VALUE);\n                int ans1 = nums.length - (int)max + q;\n                minDist = Math.min(minDist, ans1);\n                //System.out.println(\"skip left\" + ans1);\n            }\n            if (higher != null) {\n                minDist = Math.min(minDist, higher - q);\n                //System.out.println(\"higher\" + ((int)higher - q));\n            }\n            else {\n                Integer max = set.higher(Integer.MIN_VALUE);\n                int ans1 = nums.length - q + max;\n                //System.out.println(\"skip right\" + ans1);\n                minDist = Math.min(minDist, ans1);\n            }\n            ans.add(minDist);\n            // case edge\n\n        }\n        return ans;\n    }\n}","author":"Hastorius","submissionId":"1575104982"},[]]},{"182":[{"id":"182","fileName":"1575104853.txt","sourceCode":"from collections import defaultdict\nimport bisect\n\nclass Solution(object):\n    def solveQueries(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        # Step 1: Build dictionary of value -> sorted list of indices\n        index_dict = defaultdict(list)\n        for i in range(n):\n            index_dict[nums[i]].append(i)\n        \n        # Step 2: Process each query\n        answer = []\n        for q in queries:\n            v = nums[q]\n            L = index_dict[v]\n            if len(L) == 1:\n                # Only one occurrence, no other index with same value\n                answer.append(-1)\n            else:\n                # Find position of q in L\n                m = bisect.bisect_left(L, q)\n                # Previous index in circular list L\n                prev_idx = L[(m - 1) % len(L)]\n                # Next index in circular list L\n                next_idx = L[(m + 1) % len(L)]\n                # Circular distances\n                dist_prev = min(abs(q - prev_idx), n - abs(q - prev_idx))\n                dist_next = min(abs(q - next_idx), n - abs(q - next_idx))\n                # Minimum distance to another index\n                min_dist = min(dist_prev, dist_next)\n                answer.append(min_dist)\n        \n        return answer\n        ","author":"Sudhish Rithvik","submissionId":"1575104853"},[{"id":"1245","similarity":1.0,"totOverlap":156,"longestOverlap":78}]],"1245":[{"id":"1245","fileName":"1575136829.txt","sourceCode":"from collections import defaultdict\nimport bisect\n\nclass Solution(object):\n    def solveQueries(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        # Step 1: Build dictionary of value -> sorted list of indices\n        index_dict = defaultdict(list)\n        for i in range(n):\n            index_dict[nums[i]].append(i)\n        \n        # Step 2: Process each query\n        answer = []\n        for q in queries:\n            v = nums[q]\n            L = index_dict[v]\n            if len(L) == 1:\n                # Only one occurrence, no other index with same value\n                answer.append(-1)\n            else:\n                # Find position of q in L\n                m = bisect.bisect_left(L, q)\n                # Previous index in circular list L\n                prev_idx = L[(m - 1) % len(L)]\n                # Next index in circular list L\n                next_idx = L[(m + 1) % len(L)]\n                # Circular distances\n                dist_prev = min(abs(q - prev_idx), n - abs(q - prev_idx))\n                dist_next = min(abs(q - next_idx), n - abs(q - next_idx))\n                # Minimum distance to another index\n                min_dist = min(dist_prev, dist_next)\n                answer.append(min_dist)\n        \n        return answer","author":"Dedeepya Yakkala","submissionId":"1575136829"},[{"id":"182","similarity":1.0,"totOverlap":156,"longestOverlap":78}]]},{"183":[{"id":"183","fileName":"1575105036.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n    int n = nums.size();\n    unordered_map<int, vector<int>> indexMap; // Using unordered_map for faster lookup\n\n    // Store indices of each number\n    for (int i = 0; i < n; i++) {\n        indexMap[nums[i]].push_back(i);\n    }\n\n    vector<int> answer(queries.size(), -1);\n\n    for (int i = 0; i < queries.size(); i++) {\n        int target = nums[queries[i]];\n        if (indexMap[target].size() < 2) {\n            continue; // Not enough occurrences\n        }\n\n        int minDist = INT_MAX;\n        int queryIndex = queries[i];\n\n        // Find the index of the query in the vector of indices for the target number\n        auto it = lower_bound(indexMap[target].begin(), indexMap[target].end(), queryIndex);\n        int id = it - indexMap[target].begin();\n\n        // Handle edge cases\n        if (id == indexMap[target].size()) {\n            id = 0; // Wrap around to the start if necessary\n        }\n\n        // Calculate distances to the nearest occurrences\n        int l = (id - 1 + indexMap[target].size()) % indexMap[target].size();\n        int r = (id + 1) % indexMap[target].size();\n\n        int dist = abs(indexMap[target][l] - queryIndex);\n        int circularDist = min(dist, n - dist);\n        minDist = min(minDist, circularDist);\n        dist = abs(indexMap[target][r] - queryIndex);\n        circularDist = min(dist, n - dist);\n        minDist = min(minDist, circularDist);\n\n        answer[i] = minDist;\n    }\n\n    return answer;\n}\n\n};","author":"Maverick","submissionId":"1575105036"},[]]},{"185":[{"id":"185","fileName":"1575105064.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        res = []\n        dic = defaultdict(list)\n        n = len(nums)\n        a = Counter(nums)\n        nums = nums + nums\n        for i in range(len(nums)):\n            dic[nums[i]].append(i)\n        for query in queries:\n            ans = 1e9\n            # First position\n            val = nums[query]\n            idx = dic[val]\n            ans = min(ans, idx[bisect_right(idx, query)] - query, query + n - idx[bisect_left(idx, query + n) - 1])\n            if idx[0] != query:\n                ans = min(ans, query - idx[bisect_left(idx, query) - 1])\n            res.append(ans if a[nums[query]] > 1 else -1)\n        return res","author":"Geoffrey","submissionId":"1575105064"},[]]},{"187":[{"id":"187","fileName":"1575105221.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = defaultdict(list)\n        for i, num in enumerate(nums):\n            d[num].append(i)\n        n = len(nums)\n        m = len(queries)\n        res = [-1] * m\n        for i, q in enumerate(queries):\n            j = nums[q]\n            if len(d[j]) != 1:\n                idx = bisect_left(d[j], q)\n                if idx == 0:\n                    res[i] = min(d[j][1] - q, n - d[j][-1] + q)\n                elif idx == len(d[j]) - 1:\n                    res[i] = min(q - d[j][-2], n - q + d[j][0])\n                else:\n                    res[i] = min(q - d[j][idx-1], d[j][idx+1] - q)\n        return res","author":"Remineva","submissionId":"1575105221"},[{"id":"1549","similarity":0.8714285714285714,"totOverlap":122,"longestOverlap":20}]],"1549":[{"id":"1549","fileName":"611236230.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d=defaultdict(list)\n        for i,x in enumerate(nums):\n            d[x].append(i)\n        n=len(queries)\n        lst=[-1]*n\n        for i,q in enumerate(queries):\n            x=nums[q]\n            if len(d[x])!=1:\n                idx=bisect_left(d[x],q)\n                if idx==0:\n                    lst[i]=min(d[x][1]-q,q+len(nums)-d[x][-1])\n                elif idx==len(d[x])-1:\n                    lst[i]=min(q-d[x][-2],len(nums)-q+d[x][0])\n                else:\n                    lst[i]=min(d[x][idx+1]-q,q-d[x][idx-1])\n        return lst","author":"浅木夏织","submissionId":"611236230"},[{"id":"187","similarity":0.8714285714285714,"totOverlap":122,"longestOverlap":20}]]},{"188":[{"id":"188","fileName":"1575105242.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        const int n = int(nums.size());\n        \n        map<int, set<int>> mp;\n        for(int i = 0; i < n; i++) {\n            mp[nums[i]].emplace(i);\n        }\n\n        int INF = int(1e9) + 5;\n        \n        vector<int> res;\n        for(auto& id: queries) {\n            auto x = nums[id];\n            if(int(mp[x].size()) == 1) {\n                res.emplace_back(-1);\n            } else {\n                int ans = INF;\n                //* nxt\n                {\n                    auto it = mp[x].upper_bound(id);\n                    if(it != mp[x].end()) {\n                        ans = min(ans, (*it) - id);\n                    }\n                }\n                //* prev\n                {\n                    auto it = mp[x].lower_bound(id);\n                    if(it != mp[x].begin()) {\n                        it--;\n                        ans = min(ans, id - (*it));\n                    }\n                }\n                //* lst\n                {\n                    int oo = *mp[x].rbegin();\n                    if(oo != id) {\n                        ans = min(ans, (n - 1) - oo + 1 + id);\n                    }\n                }\n                //* bgn\n                {\n                    int oo = *mp[x].begin();\n                    if(oo != id) {\n                        ans = min(ans, (n - 1) - id + 1 + oo);\n                    }\n                }\n\n                res.emplace_back(ans);\n            }\n        }\n        return res;\n    }\n};","author":"dhuamanilu","submissionId":"1575105242"},[]]},{"191":[{"id":"191","fileName":"1575105313.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& arr, vector<int>& q) {\n        map<int , set<int>>mp;\n        int n = arr.size();\n        for(int i = 0 ; i < n ; i++ ) {\n             int num = arr[i];\n            mp[num].insert(i);\n            mp[num].insert(i + n);\n            mp[num].insert(i - n);\n        }\n        vector<int>ans(q.size());\n        for(int i = 0 ; i < q.size() ; i ++ ) {\n             int idx = q[i];\n             int num = arr[idx];\n             if(mp[num].size() == 3) {\n                  ans[i] = -1;\n                 continue;\n             }\n            else {\n                int d = 2 * n;\n                auto it = mp[num].lower_bound(idx);\n                if(it != mp[num].begin()) {\n                    auto gt = it;\n                    gt--;\n                    d = min(d , *it - *gt);\n                }\n                auto gt = it;\n                gt++;\n                d = min(d , *gt - *it);\n                ans[i] = d;\n            }\n        }\n        return ans;\n    }\n};","author":"Prasann Trivedi","submissionId":"1575105313"},[]]},{"192":[{"id":"192","fileName":"1575105301.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> mp;\n        int n = nums.size();\n        for (int i = 0; i < n; i++)\n            mp[nums[i]].push_back(i);\n        vector<int> res;\n        for (int x : queries) {\n            int ans = 1e9, ele = nums[x];\n            if (mp[ele].size() > 1) {\n                if (mp[ele][0] != x)\n                    ans = min(x - mp[ele][0], n - x + mp[ele][0]);\n                if (mp[ele].back() != x)\n                    ans = min({ans, mp[ele].back() - x, n - mp[ele].back() + x});\n                auto it = upper_bound(mp[ele].begin(), mp[ele].end(), x);\n                if (it != mp[ele].end())\n                    ans = min(ans, *it - x);\n                it = lower_bound(mp[ele].begin(), mp[ele].end(), x);\n                if (it != mp[ele].begin()) {\n                    it--;\n                    ans = min(ans, x - *it);\n                }\n            }\n            if (ans == 1e9)\n                ans = -1;\n            res.push_back(ans);\n        }\n        return res;\n    }\n};","author":"Abhishek Srivastava","submissionId":"1575105301"},[]]},{"193":[{"id":"193","fileName":"1575105288.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        indices = defaultdict(list)\n\n        for i, num in enumerate(nums):\n            indices[num].append(i)\n\n        distances = [-1] * len(nums)\n\n        for num_indices in indices.values():\n            if len(num_indices) < 2:\n                continue\n\n            for i in range(len(num_indices)):\n                distance_before = num_indices[i] - num_indices[i - 1] + (len(nums) if i == 0 else 0)\n                distance_after = num_indices[(i + 1) % len(num_indices)] - num_indices[i] + (len(nums) if i == len(num_indices) - 1 else 0)\n                distances[num_indices[i]] = min(distance_before, distance_after)\n\n        return [distances[query] for query in queries]","author":"Ivan Vasilenko","submissionId":"1575105288"},[]]},{"194":[{"id":"194","fileName":"1575105340.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> ans = new ArrayList<>();\n        Map<Integer, TreeSet<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.putIfAbsent(nums[i], new TreeSet<Integer>());\n            map.get(nums[i]).add(i);\n        }\n        int index = 0;\n        for (int query : queries) {\n            int num = nums[query];\n            \n            TreeSet<Integer> ts = map.get(num);\n            Integer higher = ts.higher(query);\n            Integer lower = ts.lower(query);\n            \n            if (higher == null && lower == null) {\n                ans.add(-1);\n            } else if (higher == null) {\n                ans.add(Math.min(query - lower, ts.first() - query + nums.length));\n            } else if (lower == null) {\n                ans.add(Math.min(higher - query, query - ts.last() + nums.length));\n            } else {\n                ans.add(Math.min(higher - query, query - lower));\n            }\n        }\n                        \n        return ans;\n    }\n}","author":"DestyFog","submissionId":"1575105340"},[]]},{"195":[{"id":"195","fileName":"1575105358.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        res = []\n\n        '''\n        for i in queries:\n            cur_val = nums[i]\n            for j in range(i, len(nums)) :\n                if nums[j] == cur_val and i != j :\n                    res.append(abs(i - j))\n                \n        '''\n\n        n = len(nums)\n        # 1) Build dictionary: value -> sorted list of indices\n        positions = defaultdict(list)\n        for i, val in enumerate(nums):\n            positions[val].append(i)\n    \n        # 2) Prepare answer array\n        answer = []\n    \n        # 3) For each query index q\n        for q in queries:\n            val = nums[q]\n            idx_list = positions[val]\n    \n            # If value appears only once, answer is -1\n            if len(idx_list) == 1:\n                answer.append(-1)\n                continue\n    \n            # Otherwise, binary search to find q's position in idx_list\n            idx = bisect.bisect_left(idx_list, q)\n    \n            # Because q must be in idx_list, adjust if bisect_left lands after the actual position\n            if idx == len(idx_list) or idx_list[idx] != q:\n                idx -= 1\n    \n            # Neighbors in the circular sense of idx_list\n            prev_idx = (idx - 1) % len(idx_list)\n            next_idx = (idx + 1) % len(idx_list)\n    \n            candidate_positions = [idx_list[prev_idx], idx_list[next_idx]]\n    \n            # Compute circular distance for each neighbor\n            best_dist = float('inf')\n            for cand in candidate_positions:\n                # skip if cand == q, though typically cand won't be q since\n                # we are taking the prev or next in the positions list\n                if cand == q:\n                    continue\n    \n                direct = abs(q - cand)\n                circ = n - direct\n                dist = min(direct, circ)\n                best_dist = min(best_dist, dist)\n    \n            answer.append(best_dist)\n    \n        return answer","author":"Tung Nguyen","submissionId":"1575105358"},[]]},{"197":[{"id":"197","fileName":"1575105496.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> res = new ArrayList<>();\n\n        Map<Integer, TreeSet<Integer>> map = new HashMap<>();\n        int n = nums.length;\n        for(int i=0;i<n;i++){\n            int x = nums[i];\n\n            map.computeIfAbsent(x, y -> new TreeSet<>()).add(i);\n        }\n\n\n        for(int i : queries){\n            int val = nums[i];\n\n            if(map.get(val).size() == 1){\n                res.add(-1);\n                continue;\n            }\n            int ans = Integer.MAX_VALUE;\n            TreeSet<Integer> set = map.get(val);\n            if(set.lower(i) != null){\n                ans = min(ans, i - set.lower(i));\n            }else{\n                ans = min(ans, min(set.last() - i, i + (n - set.last())));\n            }\n            \n            if(set.higher(i) != null){\n                ans = min(ans, set.higher(i) - i);\n            }else{\n                ans = min(ans, min(i - set.first(), n - i + set.first()));\n            }\n            \n            \n            res.add(ans);\n        }\n\n        return res;\n    }\n\n    private int min(int a, int b){\n        return Math.min(a,b);\n    }\n}","author":"Nikhil Agrawal","submissionId":"1575105496"},[]]},{"198":[{"id":"198","fileName":"1575105416.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        indices = dict()\n        for i in range(len(nums)):\n            if nums[i] not in indices:\n                indices[nums[i]] = [i]\n            else:\n                indices[nums[i]].append(i)\n\n        ans = []\n        n = len(nums)\n        for q in queries:\n            if len(indices[nums[q]]) == 1:\n                ans.append(-1)\n                continue\n\n            arr = indices[nums[q]]\n            lo = 0\n            hi = len(arr) - 1\n            while lo < hi:\n                m = (lo + hi) // 2\n                if arr[m] < q: lo = m+1\n                else: hi = m\n\n            prev = (arr[lo] - arr[lo - 1] + n) % n\n            next = (arr[(lo + 1) % len(arr)] - arr[lo] + n) % n\n            ans.append(min(prev,next))\n\n        return ans\n\n            ","author":"Shiva Oswal","submissionId":"1575105416"},[]]},{"199":[{"id":"199","fileName":"1575105424.txt","sourceCode":"#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <set>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cassert>\n#include <string>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i = a; i < b; i++)\n#define S(x) scanf(\"%d\",&x)\n#define S2(x,y) scanf(\"%d%d\",&x,&y)\n#define P(x) printf(\"%dn\",x)\n#define all(v) v.begin(),v.end()\n#define FF first\n#define SS second\n#define pb push_back\n#define mp make_pair\n\ntypedef long long int LL;\ntypedef pair<int, int > pii;\ntypedef vector<int > vi;\n\nconst int N = 1000001;\nint first[N], ans[N], idx[N];\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        memset(ans, -1, sizeof(ans));\n        memset(first, -1, sizeof(first));\n        memset(idx, -1, sizeof(idx));\n        vector<int> res;\n        int n = nums.size();\n        rep(i,0,n) {\n            int p = idx[nums[i]];\n            if(p != -1) {\n                ans[i] = i - p;\n                if(first[nums[i]] != -1) {\n                    ans[i] = min(ans[i], first[nums[i]] + n - i);\n                }\n            } else first[nums[i]] = i;\n            idx[nums[i]] = i;\n        }\n        memset(first, -1, sizeof(first));\n        memset(idx, -1, sizeof(idx));\n        for(int i = n - 1; i >= 0; i--) {\n            int p = idx[nums[i]];\n            if(p != -1) {\n                if(ans[i] == -1) ans[i] = p - i;\n                else ans[i] = min(p - i, ans[i]);\n                if(first[nums[i]] != -1) {\n                    ans[i] = min(ans[i], -first[nums[i]] + n + i);\n                }\n            } else first[nums[i]] = i;\n            idx[nums[i]] = i;\n        }\n\n        \n        rep(i,0,queries.size()) {\n            res.pb(ans[queries[i]]);\n        }\n        return res;\n    }\n};","author":"__shadow","submissionId":"1575105424"},[]]},{"200":[{"id":"200","fileName":"1575105674.txt","sourceCode":"from typing import *\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dp = [float(\"inf\")] * len(nums)\n        pos = {}\n        for i, n in enumerate(nums):\n            pos[n] = i\n        for i, n in enumerate(nums):\n            j = pos[n]\n            if i == j:\n                continue\n            if i < j:\n                dp[i] = min(dp[i], j-i, i+len(nums)-j)\n            else: # i > j\n                dp[i] = min(dp[i], i-j, j+len(nums)-i)\n            pos[n] = i\n\n        pos = {}\n        for i in range(len(nums)-1, -1, -1):\n            n = nums[i]\n            pos[n] = i\n        for i in range(len(nums)-1, -1, -1):\n            n = nums[i]\n            j = pos[n]\n            if i == j:\n                continue\n            if i < j:\n                dp[i] = min(dp[i], j-i, i+len(nums)-j)\n            else: # i > j\n                dp[i] = min(dp[i], i-j, j+len(nums)-i)\n            pos[n] = i\n\n        for i in range(len(dp)):\n            if dp[i] == float(\"inf\"):\n                dp[i] = -1\n\n        res = [dp[d] for d in queries]\n        return res\n","author":"Andrei Cioara","submissionId":"1575105674"},[]]},{"201":[{"id":"201","fileName":"1575105574.txt","sourceCode":"#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define sz(a) (int)(a).size()\n#define all(a) begin(a),end(a)\ntypedef vector<int> vi;\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=sz(nums);\n        nums.insert(nums.begin(),all(nums));\n        nums.insert(nums.end(),nums.begin(),nums.begin()+n);\n        vector<int>pre(3*n),pro(3*n);\n        {\n            vector<int>a(2e6,-1);\n            rep(i,0,3*n){pre[i]=a[nums[i]];a[nums[i]]=i;}\n        }\n        {\n            vector<int>a(2e6,3*n);\n            for(int i=3*n-1;i>=0;i--){pro[i]=a[nums[i]];a[nums[i]]=i;}\n        }\n        vector<int>res;\n        for(auto q:queries){\n            q+=n;\n            int ans=3*n+10;\n            if(pre[q]>-1)ans=min(q-pre[q],ans);\n            if(pro[q]<3*n)ans=min(ans,pro[q]-q);\n            if(ans>=n)ans=-1;\n            res.emplace_back(ans);\n        }\n        return res;\n    }\n};","author":"TKTYI","submissionId":"1575105574"},[]]},{"202":[{"id":"202","fileName":"1575105466.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n\n        vector<int> temp = nums;\n        for(auto &it: nums) temp.push_back(it);\n        \n        vector<int> v;\n        \n        map<int, vector<int>> mpp;\n        for(int i=0; i<temp.size(); i++){\n            mpp[temp[i]].push_back(i);\n        }\n\n        for(auto it: queries){\n            int cur = temp[it];\n\n            if(mpp.find(cur) == mpp.end() || mpp[cur].size() == 2){\n                v.push_back(-1);\n                continue;\n            } \n        int aa = INT_MAX;\n            int bigger = upper_bound(mpp[cur].begin(), mpp[cur].end(), it) - mpp[cur].begin();\n            if(bigger < mpp[cur].size()) aa = min(aa, abs(mpp[cur][bigger] - it));\n\n            int smaller = lower_bound(mpp[cur].begin(), mpp[cur].end(), it) - mpp[cur].begin();\n            smaller--;\n            if(smaller >= 0) aa = min(aa, abs(mpp[cur][smaller] - it));\n\n\n            it += n;\n            bigger = upper_bound(mpp[cur].begin(), mpp[cur].end(), it) - mpp[cur].begin();\n            if(bigger < mpp[cur].size()) aa = min(aa, abs(mpp[cur][bigger] - it));\n\n            smaller = lower_bound(mpp[cur].begin(), mpp[cur].end(), it) - mpp[cur].begin();\n            smaller--;\n            if(smaller >= 0) aa = min(aa, abs(mpp[cur][smaller] - it));\n            \n            v.push_back(aa);\n        }\n        return v;\n    }\n};","author":"Jashanpreet Singh","submissionId":"1575105466"},[]]},{"203":[{"id":"203","fileName":"1575105564.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        num_to_idxs = collections.defaultdict(list)\n        for i, num in enumerate(nums):\n            num_to_idxs[num].append(i)\n\n        result = []\n        for q in queries:\n            num = nums[q]\n            idxs = num_to_idxs[num]\n            if len(idxs) < 2:\n                result.append(-1)\n                continue\n\n            i = bisect.bisect_left(idxs, q)\n            k = len(idxs)\n            l = idxs[(i - 1) % k]\n            r = idxs[(i + 1) % k]\n\n            result.append(min(self.dist(q, l, n), self.dist(q, r, n)))\n        return result\n\n    def dist(self, a, b, n):\n        diff = abs(a - b)\n        return min(diff, n - diff)","author":"mmb L","submissionId":"1575105564"},[]]},{"204":[{"id":"204","fileName":"1575105634.txt","sourceCode":"#define f first\n#define s second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (long long)(x).size()\n#define pii pair<long long, long long>\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = sz(nums);\n        map<int, int> mp;\n        vector<int> made;\n        for (auto x : nums) {\n            mp[x]++;\n            made.pb(x);\n        }\n        for (auto x : nums) {\n            made.pb(x);\n        }\n        for (auto x : nums) {\n            made.pb(x);\n        }\n\n        map<int, vector<int>> L, R;\n        vector<int> posL(3 * n, -1), posR(3 * n, -1);\n        for (int i = 0; i < 3 * n; i++) {\n            if (L[made[i]].empty()) {\n                posL[i] = -1;\n            }\n            else {\n                posL[i] = L[made[i]].back();\n            }\n            L[made[i]].pb(i);\n        }\n\n        for (int i = 3 * n - 1; i >= 0; i--) {\n            if (R[made[i]].empty()) {\n                posR[i] = -1;\n            }\n            else {\n                posR[i] = R[made[i]].back();\n            }\n            R[made[i]].pb(i);\n        }\n\n        vector<int> ans;\n        for (auto x : queries) {\n            if (mp[nums[x]] == 1) {\n                ans.pb(-1);\n            }\n            else {\n                int l = posL[x + n], r = posR[x + n];\n                int val = min(x + n - l, r - x - n);\n                ans.pb(val);\n            }\n        }\n        return ans;\n    }\n};\n","author":"Siddharth Joshi","submissionId":"1575105634"},[]]},{"206":[{"id":"206","fileName":"1575105771.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n       unordered_map<int, vector<int>> occ;\n    int n = nums.size();\n\n    for (int i = 0; i < n; ++i) {\n        occ[nums[i]].push_back(i);\n    }\n\n    vector<int> ans;\n\n    for (int q : queries) {\n        int val = nums[q];\n         vector<int>& v = occ[val];\n\n        if (v.size() == 1) {\n            ans.push_back(-1);\n            continue;\n        }\n\n        int res = INT_MAX;\n\n        auto it = lower_bound(v.begin(), v.end(), q);\n        int pos = it - v.begin();\n\n        if (pos > 0) {\n            int left = v[pos - 1];\n            if (left != q) {\n                int dist = min(abs(q - left), n - abs(q - left));\n                res = min(res, dist);\n            }\n        } else {\n            int left = v.back();\n            if (left != q) {\n                int dist = min(abs(q - left), n - abs(q - left));\n                res = min(res, dist);\n            }\n        }\n\n        if (pos < v.size() && v[pos] != q) {\n            int right = v[pos];\n            int dist = min(abs(q - right), n - abs(q - right));\n            res = min(res, dist);\n        } else if (pos + 1 < v.size()) {\n            int right = v[pos + 1];\n            int dist = min(abs(q - right), n - abs(q - right));\n            res = min(res, dist);\n        } else {\n            int right = v[0];\n            if (right != q) {\n                int dist = min(abs(q - right), n - abs(q - right));\n                res = min(res, dist);\n            }\n        }\n\n        ans.push_back(res);\n    }\n\n    return ans;\n\n        \n    }\n};","author":"Rachit Agrawal","submissionId":"1575105771"},[]]},{"207":[{"id":"207","fileName":"1575105733.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int,vector<int>> m;\n        for(int i = 0; i<nums.size(); ++i){\n            m[nums[i]].push_back(i);\n        }\n        for(int i = 0; i<nums.size(); ++i){\n            m[nums[i]].push_back(i+n);\n        }\n        vector<int> ans;\n        for(auto q : queries){\n            int ele = nums[q];\n            auto it1 = lower_bound(m[ele].begin(),m[ele].end(),q);\n            auto it2 = it1;\n            ++it2;\n            int dis = 1e9, pos = -1;\n            if(it2!=m[ele].end()){\n                dis = (*it2-q);\n                pos = *it2;\n                if(pos>=n) pos -= n;\n            }\n            it2 = it1;\n            if(it1!=m[ele].begin()){\n                --it2;\n                int j = *it2;\n                if(q-j<dis){\n                    dis = q-j;\n                }\n            }\n            else{\n                int j = m[ele].back();\n                if((n-j+n) + q <dis){\n                    dis = 2*n + q-j;\n                }\n            }\n            if(dis>=n) dis = -1;\n            ans.push_back(dis);\n        }\n        return ans;\n    }\n};","author":"Swapnil Tyagi","submissionId":"1575105733"},[]]},{"208":[{"id":"208","fileName":"1575105743.txt","sourceCode":"class Solution {\npublic:\n  vector<int> solveQueries(vector<int>& a, vector<int>& queries) {\n    int n = (int) a.size();\n    unordered_map<int, vector<int>> mp;\n    for (int i = 0; i < n; i++) {\n      mp[a[i]].emplace_back(i);\n    }\n    vector<int> ans;\n    auto Get = [&](int a, int b) -> int {\n      if (a > b) {\n        swap(a, b);\n      }\n      return min(b - a, a + n - b);\n    };\n    for (auto& i : queries) {\n      int x = a[i];\n      if ((int) mp[x].size() == 1) {\n        ans.emplace_back(-1);\n        continue;\n      }\n      int res = (int) 1e9;\n      {\n        auto it = upper_bound(mp[x].begin(), mp[x].end(), i);\n        if (it != mp[x].end()) {\n          res = min(res, Get(i, *it));\n        }\n      }\n      {\n        auto it = lower_bound(mp[x].begin(), mp[x].end(), i);\n        if (it != mp[x].begin()) {\n          res = min(res, Get(i, *prev(it)));\n        }\n      }\n      if (mp[x][0] != i) {\n        res = min(res, Get(i, mp[x][0]));\n      }\n      if (mp[x].back() != i) {\n        res = min(res, Get(i, mp[x].back()));\n      }\n      ans.emplace_back(res);\n    }\n    return ans;\n  }\n};","author":"C0ldSmi1e","submissionId":"1575105743"},[]]},{"209":[{"id":"209","fileName":"1575105964.txt","sourceCode":"from collections import defaultdict\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        pos = defaultdict(list)\n        for i in range(len(nums)): pos[nums[i]].append(i)\n\n        def dist(a, b): return min(abs(b - a), len(nums) - max(b, a) + min(b, a))\n        \n        answers = [-1] * len(nums)\n        for x in pos:\n            if len(pos[x]) == 1: continue\n            for j in range(len(pos[x])):\n                # print(x, j, pos[x][j], pos[x])\n                answers[pos[x][j]] = min(dist(pos[x][j], pos[x][j - 1]), dist(pos[x][j], pos[x][(j + 1) % len(pos[x])]))\n        return [answers[x] for x in queries]","author":"LouisCheng","submissionId":"1575105964"},[]]},{"211":[{"id":"211","fileName":"1575105685.txt","sourceCode":"from collections import defaultdict\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dic = defaultdict(list)\n        n = len(nums)\n        for i, num in enumerate(nums):\n            dic[num].append(i)\n        res = []\n\n        def binary_search(lis, v):\n            lo = 0\n            hi = len(cur) - 1\n            # print(num, cur)\n            while lo <= hi:\n                mid = (lo + hi) // 2\n                if cur[mid] == v:\n                    return mid\n                if cur[mid] < v:\n                    lo = mid + 1\n                else:\n                    hi = mid - 1\n            return None\n        \n        for q in queries:\n            num = nums[q]\n            if len(dic[num]) == 1:\n                res.append(-1)\n            else:\n                cur = dic[num]\n                lo = binary_search(cur, q)\n                # print(q, lo)\n                min_v = float('inf')\n                if lo == 0:\n                    min_v = n - cur[-1] + cur[lo]\n                else:\n                    min_v = cur[lo] - cur[lo - 1]\n                if lo == len(cur) - 1:\n                    min_v = min(min_v, n - cur[lo] + cur[0])\n                else:\n                    min_v = min(min_v, cur[lo + 1] - cur[lo])\n                res.append(min_v)\n        return res","author":"svmh","submissionId":"1575105685"},[]]},{"212":[{"id":"212","fileName":"1575105990.txt","sourceCode":"/*\n\tJAI JAGANNATH!\n*/\n//@Author : zanj0\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ff              first\n#define ss              second\n#define pb              push_back\n#define MOD             1000000007\n#define inf             1e18\n\ntypedef long long int lli;\n\n\nclass Solution {\npublic:\n\tint GetDistance(int i, int j, int n) {\n\t\tint ret = INT_MAX;\n\t\tif (j > i) {\n\t\t\tret = j - i;\n\t\t\tret = min(ret, n - 1 - j + i +  1);\n\t\t} else {\n\t\t\treturn GetDistance(j, i, n);\n\t\t}\n        return ret;\n\t}\n\tvector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n\n\t\tint n = nums.size();\n\t\tvector<int> all = nums;\n\t\tmap<lli, set<lli>> idx;\n\t\tvector<int> ret;\n\t\tfor (int i = 0; i < all.size(); i++) {\n\t\t\tidx[all[i]].insert(i);\n\t\t}\n\t\tfor (auto& it : queries) {\n\n\t\t\tint value = nums[it];\n\t\t\tauto it2 = idx[value].upper_bound(it);\n\t\t\tint now = INT_MAX;\n\t\t\tif (it2 != idx[value].end()) {\n\t\t\t\tint len = GetDistance(*it2, it, n);\n\t\t\t\tnow = min(now, len);\n\t\t\t}\n\t\t\tit2--;\n\t\t\tif (it2 != idx[value].begin()) {\n\t\t\t\tit2--;\n\t\t\t\tint len = GetDistance(*it2, it, n);\n\t\t\t\tnow = min(now, len);\n\t\t\t}\n\t\t\tif (idx[value].size() > 1) {\n\t\t\t\tif (it != *idx[value].begin())now = min(now, GetDistance(*idx[value].begin(), it, n));\n\t\t\t\tif (it != *idx[value].rbegin())now = min(now, GetDistance(*idx[value].rbegin(), it, n ));\n\t\t\t}\n\t\t\tif (now == INT_MAX) now = -1;\n\t\t\tret.pb(now);\n\t\t}\n\n\t\treturn ret;\n\n\t}\n};\n\n#ifdef LOCAL\nint main() {\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tcout << \"Compiled!\" << endl;\n}\n#endif\n\n","author":"Agnibha Chakraborty","submissionId":"1575105990"},[]]},{"213":[{"id":"213","fileName":"1575106055.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] a, int[] qs) {\n        int n = a.length;\n        Map<Integer,TreeSet<Integer>> m = new HashMap<>();\n        for(int i=0; i<n; ++i){\n            m.computeIfAbsent(a[i], p-> new TreeSet<>()).add(i);\n        }\n        int qn = qs.length;\n        List<Integer> res = new ArrayList<>();\n        for(int i=0; i<qn; ++i){\n            int q = qs[i];\n            int v = a[q];\n            TreeSet<Integer> idx = m.get(v);\n            if(idx == null || idx.size()==1){\n                res.add(-1);\n            }else{                \n                int cur = 2*n;\n                Integer higher = idx.higher(q);\n                if(higher != null){\n                    int cv = higher - q;\n                    cur = Math.min(cur, cv);\n                }\n                Integer lower = idx.lower(q);\n                if(lower!= null){\n                    int cv2 = q-lower;\n                    cur = Math.min(cur, cv2);                    \n                }\n                Integer first = idx.first();\n                if(first != null){\n                    int cv3 = n-q+first;\n                    cur = Math.min(cur, cv3);\n                }\n                Integer last = idx.last();\n                if(last != null){\n                    int cv4 = n-last + q;\n                    cur = Math.min(cur, cv4);\n                }\n                res.add(cur);\n            }\n            \n        }\n        return res;\n    }\n}","author":"JOZLEETCODE","submissionId":"1575106055"},[]]},{"215":[{"id":"215","fileName":"1575106226.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        nums = nums + nums + nums\n        prev = [-1] * n\n        next = [-1] * n\n        d = dict()\n        for i, a in enumerate(nums):\n            if n <= i < 2 * n: prev[i - n] = (i - d[a])\n            d[a] = i\n        d = dict()\n        for i in range(3 * n - 1, -1, -1):\n            a = nums[i]\n            if n <= i < 2 * n: next[i - n] = (d[a] - i)\n            d[a] = i\n        res = [-1] * len(queries)\n        for i, q in enumerate(queries):\n            dist = min(prev[q], next[q])\n            if dist == n: continue\n            res[i] = dist\n        return res","author":"echeresh","submissionId":"1575106226"},[]]},{"216":[{"id":"216","fileName":"1575106248.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        for (int i=0; i<n; i++) {\n            nums.push_back(nums[i]);\n        }\n        vector<int> prev(2*n, -1);\n        vector<int> next(2*n, -1);\n        unordered_map<int, int> mp;\n        for (int i=0; i<2*n; i++) {\n            int elem = nums[i];\n            if (mp.count(elem)) {\n                prev[i] = mp[elem];\n            }\n            mp[elem] = i;\n        }\n        mp.clear();\n        for (int i=2*n-1; i>=0; i--) {\n            int elem = nums[i];\n            if (mp.count(elem)) {\n                next[i] = mp[elem];\n            }\n            mp[elem] = i;\n        }\n        vector<int> ans;\n        for (auto& idx: queries) {\n            int res = 1e9;\n            if (prev[idx] != -1) {\n                res = min(res, idx-prev[idx]);\n            }\n            if (next[idx] != -1) {\n                res = min(res, next[idx]-idx);\n            }\n            idx += n;\n            if (prev[idx] != -1) {\n                res = min(res, idx-prev[idx]);\n            }\n            if (next[idx] != -1) {\n                res = min(res, next[idx]-idx);\n            }\n            ans.push_back(res == n ? -1 : res);\n        }\n        return ans;\n    }\n};","author":"Manikya Sharma","submissionId":"1575106248"},[]]},{"217":[{"id":"217","fileName":"1575105854.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        answer = []\n        n = len(nums)\n        ordered = {}\n        for i, num in enumerate(nums):\n            ordered.setdefault(num, []).append(i)\n        map_ = {}\n        for num in ordered:\n            map_[num] = {}\n            for ii, index in enumerate(ordered[num]):\n                map_[num][index] = ii\n        for i in queries:\n            array = ordered[nums[i]]\n            m = len(array)\n            if m == 1:\n                answer.append(-1)\n                continue\n            ii = map_[nums[i]][i]\n            left = array[(ii - 1) % m]\n            right = array[(ii + 1) % m]\n            answer.append(min((i - left) % n, (right - i) % n))\n        return answer","author":"Michael Yu","submissionId":"1575105854"},[]]},{"218":[{"id":"218","fileName":"1575106299.txt","sourceCode":"from typing import List\nimport numpy as np\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        arr = np.array(nums)\n        out = np.full(n, -1, dtype=np.int64)\n        idx_order = np.argsort(arr)\n        sorted_vals = arr[idx_order]\n        diff_vals = np.diff(sorted_vals)\n        bounds = np.concatenate(([0], np.where(diff_vals != 0)[0] + 1, [n]))\n        for i in range(len(bounds) - 1):\n            group = idx_order[bounds[i]:bounds[i+1]]\n            if group.size < 2:\n                continue\n            grp_sorted = np.sort(group)\n            seg = np.diff(np.concatenate((grp_sorted, [grp_sorted[0] + n])))\n            cand = np.minimum(seg, np.roll(seg, 1))\n            out[grp_sorted] = cand\n        return out[queries].tolist()","author":"coder","submissionId":"1575106299"},[]]},{"219":[{"id":"219","fileName":"1575106432.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, set<int>> idx;\n        for(int i=0;i<nums.size();++i){\n            idx[nums[i]].insert(i);\n            idx[nums[i]].insert(i+nums.size());\n            idx[nums[i]].insert(i-nums.size());\n        }\n\n        vector<int> res;\n        for(int i:queries){\n            auto it = idx[nums[i]].lower_bound(i);\n            ++it;\n            int a = (*it) - i;\n            --it;\n            --it;\n            int b = i - (*it);\n            if(min(a,b) < nums.size()) res.push_back(min(a,b));\n            else res.push_back(-1);\n        }\n        return res;\n    }\n};","author":"3whhA6pFsT","submissionId":"1575106432"},[]]},{"220":[{"id":"220","fileName":"1575106385.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int lenVal = nums.size();\n        vector<int> difArr(lenVal, -1);\n        unordered_map<int, vector<int>> posDic;\n        int idx = 0;\n        while (idx < lenVal) {\n            posDic[nums[idx]].push_back(idx);\n            idx++;\n        }\n        auto dicIt = posDic.begin();\n        while (dicIt != posDic.end()) {\n            vector<int>& posSeq = dicIt->second;\n            if (posSeq.size() < 2) {\n                ++dicIt;\n                continue;\n            }\n            sort(posSeq.begin(), posSeq.end());\n            int totPos = posSeq.size();\n            int posInd = 0;\n            while (posInd < totPos - 1) {\n                int stepVal = posSeq[posInd + 1] - posSeq[posInd];\n                int circVal = (stepVal <= (lenVal - stepVal)) ? stepVal : (lenVal - stepVal);\n                if (difArr[posSeq[posInd]] == -1) \n                    difArr[posSeq[posInd]] = circVal;\n                else \n                    difArr[posSeq[posInd]] = (circVal < difArr[posSeq[posInd]] ? circVal : difArr[posSeq[posInd]]);\n                if (difArr[posSeq[posInd + 1]] == -1) \n                    difArr[posSeq[posInd + 1]] = circVal;\n                else \n                    difArr[posSeq[posInd + 1]] = (circVal < difArr[posSeq[posInd + 1]] ? circVal : difArr[posSeq[posInd + 1]]);\n                posInd++;\n            }\n            int wrapCalc = lenVal - posSeq.back() + posSeq.front();\n            int wrapCirc = (wrapCalc <= (lenVal - wrapCalc)) ? wrapCalc : (lenVal - wrapCalc);\n            if (difArr[posSeq.back()] == -1) \n                difArr[posSeq.back()] = wrapCirc;\n            else \n                difArr[posSeq.back()] = (wrapCirc < difArr[posSeq.back()] ? wrapCirc : difArr[posSeq.back()]);\n            if (difArr[posSeq.front()] == -1) \n                difArr[posSeq.front()] = wrapCirc;\n            else \n                difArr[posSeq.front()] = (wrapCirc < difArr[posSeq.front()] ? wrapCirc : difArr[posSeq.front()]);\n            ++dicIt;\n        }\n        vector<int> outRes(queries.size(), 0);\n        int uInd = 0;\n        while (uInd < queries.size()) {\n            int tmpVal = difArr[queries[uInd]];\n            int remVal = ((tmpVal + 7) - 7);\n            outRes[uInd] = remVal;\n            uInd++;\n        }\n        return outRes;\n    }\n};","author":"rokkc","submissionId":"1575106385"},[]]},{"221":[{"id":"221","fileName":"1575105918.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        dct_idx = defaultdict(list)\n        for i, num in enumerate(nums):\n            dct_idx[num].append(i)\n        res = []\n        for q in queries:\n            val = nums[q]\n            lst_pos = dct_idx[val]\n            if len(lst_pos) == 1:\n                res.append(-1)\n                continue\n            pos = bisect.bisect_left(lst_pos, q)\n            idx_left = lst_pos[pos - 1] if pos > 0 else lst_pos[-1]\n            idx_right = lst_pos[pos + 1] if pos < len(lst_pos) - 1 else lst_pos[0]\n            res.append(\n                min(\n                    min(abs(q - idx_left), n - abs(q - idx_left)),\n                    min(abs(idx_right - q), n - abs(idx_right - q)),\n                )\n            )\n        return res\n","author":"ianCheng","submissionId":"1575105918"},[{"id":"426","similarity":0.7735849056603774,"totOverlap":82,"longestOverlap":33}]],"426":[{"id":"426","fileName":"1575115169.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        positions = defaultdict(list)\n        for i, num in enumerate(nums):\n            positions[num].append(i)\n        ans = []\n        for q in queries:\n            num = nums[q]\n            indices = positions[num]\n            if len(indices) < 2:\n                ans.append(-1)\n            else:\n                i = bisect.bisect_left(indices, q)\n                before = indices[i-1] if i > 0 else indices[-1]\n                after = indices[i+1] if i < len(indices)-1  else indices[0]\n                ans.append(min((q-before)%len(nums), (after-q)%len(nums)))\n        return ans","author":"a______","submissionId":"1575115169"},[{"id":"221","similarity":0.7735849056603774,"totOverlap":82,"longestOverlap":33}]]},{"222":[{"id":"222","fileName":"1575106475.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int> >mp;\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int>ans;\n        for(auto it:queries){\n            if(mp[nums[it]].size()==1){\n                ans.push_back(-1);\n            }\n            else{\n                int mn=1e9;\n                int idx=upper_bound(mp[nums[it]].begin(),mp[nums[it]].end(),it)-mp[nums[it]].begin();\n                if(idx==mp[nums[it]].size()){\n                    idx=0;\n                }\n                mn=min(mn,min(n-abs(it-mp[nums[it]][idx]),abs(it-mp[nums[it]][idx])));\n                idx=lower_bound(mp[nums[it]].begin(),mp[nums[it]].end(),it)-mp[nums[it]].begin()-1;\n                if(idx==-1){\n                    idx=mp[nums[it]].size()-1;\n                }\n                mn=min(mn,min(n-abs(it-mp[nums[it]][idx]),abs(it-mp[nums[it]][idx])));\n                ans.push_back(mn);\n            }\n        }\n        return ans;\n    }\n};","author":"Mahmoud Ashour","submissionId":"1575106475"},[]]},{"223":[{"id":"223","fileName":"1575106555.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        # n=len(queries)\n        # ans=[-1]*n\n        # i=0 # pointer for quieres\n        # while i>0:\n        index_map = defaultdict(list)\n        n = len(nums)\n        # Preprocess the array to map each value to its sorted list of indices\n        for idx, num in enumerate(nums):\n            index_map[num].append(idx)\n        # Sort the indices for each value\n        for num in index_map:\n            index_map[num].sort()\n        \n        answer = []\n        for q in queries:\n            current_value = nums[q]\n            indices = index_map[current_value]\n            # If only one occurrence, append -1\n            if len(indices) == 1:\n                answer.append(-1)\n                continue\n            # Find the position of q in the sorted list using bisect\n            pos = bisect.bisect_left(indices, q)\n            m = len(indices)\n            # Calculate previous and next positions in the circular list\n            prev_pos = (pos - 1) % m\n            next_pos = (pos + 1) % m\n            prev_idx = indices[prev_pos]\n            next_idx = indices[next_pos]\n            # Compute distances considering circular nature\n            distance_prev = min(abs(q - prev_idx), n - abs(q - prev_idx))\n            distance_next = min(abs(q - next_idx), n - abs(q - next_idx))\n            minimal_distance = min(distance_prev, distance_next)\n            answer.append(minimal_distance)\n        return answer\n    \n                \n                 \n                \n                ","author":"Sandeep","submissionId":"1575106555"},[]]},{"224":[{"id":"224","fileName":"1575106409.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,set<int>> mem;\n        for (int i = 0; i < (int) nums.size(); i++) {\n            mem[nums[i]].insert(i);\n        }\n        vector<int> ret;\n        for (auto &p : queries) {\n            int val = nums[p];\n            auto cur = mem[val].lower_bound(p);\n            auto after = mem[val].end();\n            if (cur != mem[val].end()) {\n                after = next(cur);\n            }\n            auto before = mem[val].end();\n            if (cur != mem[val].begin()) {\n                before = prev(cur);\n            }\n            auto first = mem[val].begin();\n            auto last = mem[val].end();\n            if (mem[val].size()) last = prev(last);\n\n            int ans = INT_MAX;\n            if (after != mem[val].end()) ans = min(ans, *after - p);\n            if (before != mem[val].end()) ans = min(ans, p - *before);\n            if (first != mem[val].end() && first != cur) ans = min(ans, *first + (int) nums.size() - p);\n            if (last != mem[val].end() && last != cur) ans = min(ans, p + (int) nums.size() - *last);\n\n            if (ans == INT_MAX) ret.push_back(-1);\n            else ret.push_back(ans);\n        }\n        return ret;\n    }\n};","author":"allforest01","submissionId":"1575106409"},[]]},{"225":[{"id":"225","fileName":"1575106664.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> M;\n        int n = nums.size();\n        for (int i = 0; i < nums.size(); i ++) {\n            if (M.count(nums[i])) {\n                M[nums[i]].push_back(i);\n            } else {\n                M[nums[i]] = vector<int>();\n                M[nums[i]].push_back(i);\n            }\n        }\n        vector<int> ret;\n        for (auto& x: queries) {\n            int num = nums[x];\n            int sz = M[num].size();\n            if (sz == 1) ret.push_back(-1);\n            else {\n                int idx = lower_bound(M[num].begin(), M[num].end(), x) - M[num].begin();\n                int ib = M[num][(idx - 1 + sz) % sz];\n                int dist1 = min(min(abs(x - ib), abs(ib + n - x)), abs(x + n - ib));\n                int ia = M[num][(idx + 1 + sz) % sz];\n                int dist2 = min(min(abs(ia - x), abs(x + n - ia)), abs(ia + n - x));\n                \n                ret.push_back(min(dist1, dist2));\n            }\n        }\n        return ret;\n    }\n};","author":"hkhzzz","submissionId":"1575106664"},[]]},{"229":[{"id":"229","fileName":"1575106712.txt","sourceCode":"\n#ifdef LOCAL_RUN\n#include \"debug_leet.h\"\n    #else\n    #define trace(...) ;\n    #define dbg(...) ;\n    #define dbgc(...) ;\n    #define debug(x) ;\n    #define debuga(a, n) ;\n    #define debug2(x, y) ;\n    #define debug3(x, y, z) ;\n    #define debug4(x, y, z, w) ;\n    #define debug5(a,b,c,d,e) ;\n    #define lassert(x) ;\n    #define dassert(x, ...) ;\n    int recur_depth = 0; bool rec_indent = true;\n    const bool isLocal = false;\n    template <typename Arg, typename... Args>\n    void display(TreeNode* root) {}\n    #endif\n\n    #define pb push_back\n    #define eb emplace_back\n    #define popb pop_back\n    #define all(v) begin(v), end(v)\n    #define rall(v) (v).rbegin(),(v).rend()\n    #define make_unique(v) (v).erase(unique(all(v)), (v).end())\n    #define sz(c) ((int) c.size())\n    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)\n    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)\n    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)\n    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)\n    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n    #define mem(a,b) memset(a,b,sizeof(a))\n    #define abs(x) (((x) < 0) ? -(x) : (x))\n    #define sqr(x) ((x) * (x))\n    #define sqrt(x) sqrt(abs(x))\n    #define has(c,x) (c.find(x) != c.end())\n    #define pw(x) (1LL << (x))\n    #define ibit(x,i) (((x) >> (i)) & 1)\n    #define data(v) v.data(), sz(v) // vi -> vai\n    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)\n\n    typedef stringstream sstr;\n    typedef long long ll;\n    typedef long double ld;\n    typedef pair<int, int> pii;\n    typedef pair<ll,ll> pll;\n    typedef pair<ld,ld> pdd;\n    typedef vector<int> vi;\n    typedef vector<ll> vll;\n    typedef vector<pii> vpii;\n    typedef vector<vi> vvi;\n    typedef vector<vll> vvll;\n    typedef valarray<int> vai;\n    template <class T>\n    using min_pq = priority_queue<T, vector<T>, greater<T>>;\n    template <class T>\n    using vc = vector<T>;\n    template <class T>\n    using vvc = vector<vc<T>>;\n    template <class T>\n    using vvvc = vector<vvc<T>>;\n    template <class T>\n    using vvvvc = vector<vvvc<T>>;\n    template <class T>\n    using vvvvvc = vector<vvvvc<T>>;\n\n    template<class F>\n    struct y_comb{\n        F f;\n        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }\n        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }\n    };\n    template<class F>\n    decltype(auto) yf(F &&f){\n        return y_comb<decay_t<F>>(forward<F>(f));\n    }\n\n    inline int ni(){ int x; cin >> x;   return x; }\n    inline ll  nl() { ll  x; cin >> x; return x; }\n\n    template <class T> void mmin(T& a, const T& b) {\n        a = (a) < (b) ? (a) : (b);\n    }\n    template <class T> void mmax(T& a, const T& b) {\n        a = (a) > (b) ? (a) : (b);\n    }\n    template <class T> int LB(vc<T> &a, T x){\n        return int(lower_bound(all(a), x) - a.begin());\n    }\n    template <class T> int UB(vc<T> &a, T x){\n        return int(upper_bound(all(a), x) - a.begin());\n    }\n    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){\n        if(r < 0) r = sz(a);\n        return *max_element(a.begin()+l, a.begin()+r);\n    }\n    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){\n        if(r < 0) r = sz(a);\n        return *min_element(a.begin()+l, a.begin()+r);\n    }\n    template <class T> auto vv(int d1, T x){\n        return vc<T>(d1, x);\n    }\n    template <class T> auto vv(int d1, int d2, T x){\n        return vc<vc<T>>(d1, vc<T>(d2, x));\n    }\n    template <class T> auto vv(int d1, int d2, int d3, T x){\n        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));\n    }\n    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){\n        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));\n    }\n    void outv(auto &v){\n        for(auto &x: v) {cout<< x <<\" \";} cout<<endl;\n    }\n    void rvec(int &n, auto &v){\n        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);\n    }\n    template <typename Arg, typename... Args>\n    void read(Arg&& arg, Args&&... args){\n        cin >> std::forward<Arg>(arg); using expander = int[];\n        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};\n    }\n    template <typename Arg, typename... Args>\n    void out(Arg&& arg, Args&&... args){\n        cout << std::forward<Arg>(arg); using expander = int[];\n        (void)expander{0, (void(cout << \" \" << std::forward<Args>(args)),0)...};\n        cout << endl;\n    }\n    namespace tuple_utils{\n        template<class ...Ts, size_t ...Is>\n        ostream& println_tuple_impl(ostream& os, tuple<Ts...> tuple, index_sequence<Is...>){\n            static_assert(sizeof...(Is)==sizeof...(Ts),\"Indices must have same number of elements as tuple types!\");\n            static_assert(sizeof...(Ts)>0, \"Cannot insert empty tuple into stream.\");\n            auto last = sizeof...(Ts) - 1; // assuming index sequence 0,...,N-1\n            return ((os << get<Is>(tuple) << (Is != last ? \", \" : \")\")),...);\n        }\n    }\n    template<class ...Ts> ostream& operator<<(ostream& os, const tuple<Ts...> & tuple) {\n        os << \"(\";\n        return tuple_utils::println_tuple_impl(os, tuple, index_sequence_for<Ts...>{});\n    }\n    template <class Integer, class F>\n    Integer find_first_false(Integer l, Integer r, F&& f) {\n        --l; // ++r;\n        while (r - l > 1) {\n            Integer m = midpoint(l, r);\n            if (f(m)) l = m;\n            else r = m;\n        }\n        return r;\n    }\n    template <class Integer, class F>\n    Integer find_last_true(Integer l, Integer r, F &&f) {\n        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;\n    }\n    template <class Integer, class F>\n    Integer find_first_true(Integer l, Integer r, F &&f) {\n        return find_first_false(l, r, [&f](Integer i) { return !f(i); });\n    }\n    template <class T, class F>\n    T last_true(T lo, T hi, F&& f) { \n        lo--; // if all are false, return lo-1\n        while(lo < hi){\n            T mid = lo + (hi - lo + 1) / 2;\n            if(f(mid)) lo = mid; \n            else hi = mid - 1;\n        }\n        return lo;\n    }\n    template <class T, class F>\n    T first_true(T lo, T hi, F&& f) { \n        // return last_true(lo, hi, [&](T x){ return !f(x); }) + 1;\n        hi++; // if all are false, return hi+1\n        while(lo < hi){\n            T mid = lo + (hi - lo) / 2;\n            if(f(mid)) hi = mid; \n            else lo = mid + 1;\n        }\n        return lo;\n    }\n    auto init = []() {\n        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';\n    }();\n\n    ll pwr(ll base, ll p, ll mod){\n        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;\n            base=(base*base)%mod; p/=2;}\n        return ans;\n    }\n    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }\n    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }\n\n    const long double PI = (long double)(3.1415926535897932384626433832795);\n    const ll  mx_ll   = numeric_limits<ll> :: max();\n    const int mx_int  = numeric_limits<int> :: max();\n\n    const int oo = 0x3f3f3f3f;\n    const ll  OO = 0x3f3f3f3f3f3f3f3fll;\n    const double eps = 1e-9;\n    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};\n    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};\n\nconst int maxn = 1e5 + 3;\nconst int mod = 1e9+7;\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& queries) {\n        int hi = MAX(a) + 1, n = sz(a);\n        vvi ids(hi);\n        forn(i, n) ids[a[i]].pb(i);\n        vi ans;\n        for(int i: queries) {\n            int x = a[i];\n            if(sz(ids[x]) == 1) {\n                ans.pb(-1);\n                continue;\n            }\n            int o = LB(ids[x], i);\n            assert(ids[x][o] == i);\n            // int d = n;\n            int r = ids[x][(o + 1) % sz(ids[x])];\n            int l = ids[x][(o - 1 + sz(ids[x])) % sz(ids[x])];\n            int d = min({\n                max(r,i) - min(r,i),\n                max(l,i) - min(l,i),\n                n - max(r,i) + min(r, i),\n                n - max(l,i) + min(l, i)\n            });\n            // if(o+1 < sz(ids[x])) mmin(d, ids[x][o+1] - i);\n            // if(o > 0) mmin(d, i - ids[x][o-1]);\n            ans.pb(d);\n        }\n        return ans;\n    }\n};\n\n#ifdef LOCAL_RUN\nvoid _solve(){\n    Solution sol;\n\n}\n\n\n/*************************************************************************/\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    //cout.precision(15);\n    // return 0;\n    while(cin.peek() == 32 or cin.peek() == 10) cin.get();\n    while(cin.peek() != EOF){\n        _solve();\n        while(cin.peek() == 32 or cin.peek() == 10) cin.get();\n    }\n}\n#endif\n","author":"Jose Coves","submissionId":"1575106712"},[]]},{"231":[{"id":"231","fileName":"1575106825.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int maxVal = 0;\n        for (int x : nums)\n            maxVal = max(maxVal, x);\n        vector<int> pos(maxVal+1, -1), first(maxVal+1, n+1), last(maxVal+1, -1);\n        for (int i = 0; i < n; i++) {\n            first[nums[i]] = min(first[nums[i]], i);\n            last[nums[i]] = max(last[nums[i]], i);\n        }\n        vector<int> left(n), right(n);\n        for (int i = 0; i < n; i++) {\n            if (pos[nums[i]] == -1)\n                left[i] = n+1;\n            else\n                left[i] = i-pos[nums[i]];\n            pos[nums[i]] = i;\n        }\n        pos = vector<int>(maxVal+1, -1);\n        for (int i = n-1; i >= 0; i--) {\n            if (pos[nums[i]] == -1)\n                right[i] = n+1;\n            else\n                right[i] = pos[nums[i]]-i;\n            pos[nums[i]] = i;\n        }\n        vector<int> ans;\n        for (int q : queries) {\n            int val = min(right[q], left[q]);\n            if (first[nums[q]] != q)\n                val = min(val, n-(q-first[nums[q]]));\n            if (last[nums[q]] != q)\n                val = min(val, n-(last[nums[q]]-q));\n            if (val == n+1)\n                ans.push_back(-1);\n            else\n                ans.push_back(val);\n        }\n        return ans;\n    }\n};","author":"Abhishek Sajwan","submissionId":"1575106825"},[]]},{"232":[{"id":"232","fileName":"1575106814.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int r=0;\n        map<int,int> mp; \n        int n = nums.size();\n        vector<int> a(n+1,INT_MAX);\n        for(int i=0;i<n;i++){\n            int q = nums[i];\n            if(mp.find(nums[i])!=mp.end()){\n                int l= mp[q];\n                if(i != l){\n                if(l<i){\n                    a[l] = min(a[l],i-l);\n                    a[i] = min(a[i],i-l);\n                }\n                else {\n                    a[l] = min(a[l],n-l +i);\n                    a[i] = min(a[i],n-l+i);\n                }\n                }\n            }\n            mp[q] = i;\n            if(i == n-1 && r == 0){\n                r++;\n                i= -1;\n            }\n        }\n        cout<<\"Array is \"<<endl;\n        for(int i : a)cout<<i<<\" \"; cout<<endl;\n        vector<int> ans;\n        for(int i=0;i<queries.size();i++){\n            int q = queries[i];\n            if(a[q] == INT_MAX){\n                ans.push_back(-1);\n            }\n            else ans.push_back(a[q]);\n        }\n        return ans;\n    }\n};","author":"devanshksg","submissionId":"1575106814"},[]]},{"233":[{"id":"233","fileName":"1575106833.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dct=defaultdict(list)\n        ln=0\n        for i in range(len(nums)):\n            dct[nums[i]].append(i)\n            ln+=1\n\n        res=[]\n        for i in queries:\n            if len(dct[nums[i]])==1:\n                res.append(-1)\n            else:\n                ind = dct[nums[i]]\n                pos = bisect_left(ind, i)\n                l = ind[pos - 1] if pos > 0 else ind[-1]\n                r = ind[pos + 1] if pos < len(ind) - 1 else ind[0]\n                \n                tl = abs(i - l)\n                dl = min(tl, ln - tl)\n                tr = abs(i - r)\n                dr = min(tr, ln - tr)\n                \n                res.append(min(dl, dr))\n        return res","author":"Shreehari","submissionId":"1575106833"},[]]},{"234":[{"id":"234","fileName":"1575106893.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int, vector<int>> rec;\n\n        for(int i=0; i<n; ++i) {\n            rec[nums[i]].emplace_back(i);\n        }\n\n        vector<int> res;\n\n        int target;\n        for(int i:queries) {\n            target = nums[i];\n            if(rec[target].size() == 1) {\n                res.emplace_back(-1);\n            } else {\n                int pos = -1;\n                auto it = lower_bound(rec[target].begin(), rec[target].end(), i);\n                if (it != rec[target].end() && *it == i) {\n                    pos = it - rec[target].begin();\n                }\n            \n                int best = n; \n                int left = (pos - 1 + rec[target].size()) % rec[target].size();\n                int right = (pos + 1) % rec[target].size();\n            \n                int d1 = abs(i - rec[target][left]);\n                int d2 = abs(i - rec[target][right]);\n\n                d1 = min(d1, n - d1);\n                d2 = min(d2, n - d2);\n                \n                res.emplace_back(min(d1, d2));\n            }\n        }\n\n        return res;\n    }\n};","author":"JiahangZhang","submissionId":"1575106893"},[]]},{"236":[{"id":"236","fileName":"1575106682.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] qs) {\n        HashMap<Integer, TreeSet<Integer>> h = new HashMap<>();\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            int x = nums[i];\n            h.putIfAbsent(x, new TreeSet<>());\n            h.get(x).add(i);\n        }\n        List<Integer> ans = new LinkedList<>();\n        for (int pos : qs) {\n            int x = nums[pos];\n            TreeSet<Integer> t = h.get(x);\n            t.remove(pos);\n            Integer p = t.lower(pos), q = t.higher(pos), r1 = t.isEmpty() ? null : t.first(), r2 = t.isEmpty() ? null : t.last();\n            if (p == null && q == null)\n                ans.add(-1);\n            else if (p == null)\n                ans.add(Math.min(q - pos, pos + n - r2));\n            else if (q == null)\n                ans.add(Math.min(pos - p, r1 + n - pos));\n            else\n                ans.add(Math.min(pos - p, q - pos));\n            t.add(pos);\n        }\n        return ans;\n    }\n}","author":"liyangzi6p626","submissionId":"1575106682"},[]]},{"237":[{"id":"237","fileName":"1575106848.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, set<int>>pos;\n        int n = nums.size();\n        for(int i=0;i<n;i++){\n            pos[nums[i]].insert(i);\n            pos[nums[i]].insert(i+n);\n            pos[nums[i]].insert(i-n);\n        }\n        int m = queries.size();\n        vector<int>ret(m, -1);\n        for(int i=0;i<m;i++){\n            int x = queries[i];\n            pos[nums[x]].erase(x);\n            pos[nums[x]].erase(x+n);\n            pos[nums[x]].erase(x-n);\n            auto it = pos[nums[x]].upper_bound(x);\n            int minn = 2e9;\n            if(it != pos[nums[x]].end()){\n                int dist = (*it - x);\n                if(dist < minn)ret[i] = dist, minn = dist;\n            }\n            if(it != pos[nums[x]].begin()){\n                it--;\n                int dist = x - *it;\n                if(dist < minn)ret[i] = dist, minn = dist;\n            }\n            pos[nums[x]].insert(x);\n            pos[nums[x]].insert(x+n);\n            pos[nums[x]].insert(x-n);\n        }\n        return ret;\n    }\n};","author":"tonyli00000","submissionId":"1575106848"},[]]},{"239":[{"id":"239","fileName":"1575107039.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> val2index;\n        for (int i = 0; i < nums.size(); i++) val2index[nums[i]].push_back(i);\n\n        vector<int> answer;\n        for (auto& q : queries) {\n            vector<int>& array = val2index[nums[q]];\n            if (array.size() == 1) {\n                answer.push_back(-1);\n            }\n            else {\n                auto itCurr = lower_bound(array.begin(), array.end(), q);\n                int prevIndex = (itCurr == array.begin()) ? *array.rbegin() : *prev(itCurr);\n                int nextIndex = (next(itCurr) == array.end()) ? *array.begin() : *next(itCurr);\n                answer.push_back(min(\n                    ((*itCurr - prevIndex) + nums.size()) % nums.size(),\n                    ((nextIndex - *itCurr) + nums.size()) % nums.size()\n                ));\n            }\n        }\n        return answer;\n    }\n};","author":"Pepe","submissionId":"1575107039"},[]]},{"240":[{"id":"240","fileName":"1575106939.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        q = len(queries)\n\n        closest = [-1] * n\n        valinds = {}\n        for i in range(n):\n            if nums[i] not in valinds:\n                valinds[nums[i]] = []\n            valinds[nums[i]].append(i)\n\n        ans = []\n        for i in queries:\n            inds = valinds[nums[i]]\n            if len(inds) == 1:\n                ans.append(-1)\n                continue\n\n            m = len(inds)\n            lo, hi = 0, m - 1\n            while lo < hi:\n                mid = (lo + hi) // 2\n                if inds[mid] == i:\n                    lo = hi = mid\n                    break\n                elif inds[mid] < i: lo = mid + 1\n                else: hi = mid - 1\n\n            lodist = hidist = inf\n            if lo == m - 1: #last instance of this number\n                hidist = inds[0] + n - i\n            else:\n                hidist = inds[lo + 1] - inds[lo]\n            if lo == 0:\n                lodist = i + n - inds[-1]\n            else:\n                lodist = inds[lo] - inds[lo - 1]\n\n            ans.append(min(hidist, lodist))\n\n        return ans","author":"Andrew H. Pometta","submissionId":"1575106939"},[]]},{"241":[{"id":"241","fileName":"1575107153.txt","sourceCode":"int pre[1000010], nxt[1000010];\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        for(int i = 0; i < n; ++i){\n            nums.push_back(nums[i]);\n        }\n        vector<int> ans;\n        \n        memset(pre,-1,sizeof pre);\n        memset(nxt,-1,sizeof nxt);\n        for(int i = 0; i < nums.size(); ++i){\n            if(~pre[nums[i]]){\n                ans.push_back(i - pre[nums[i]]);\n            }\n            else ans.push_back(-1);\n            pre[nums[i]] = i;\n        }\n        for(int i = nums.size() - 1; ~i; --i){\n            if(~nxt[nums[i]]){\n                if(~ans[i])\n                    ans[i] = min(ans[i],nxt[nums[i]] - i);\n                else\n                    ans[i] = nxt[nums[i]] - i;\n            }\n            nxt[nums[i]] = i;\n        }\n        vector<int> ret;\n        for(auto i:queries){\n            ret.push_back(min(ans[i], ans[i + n]));\n            if(ret.back() >= n)\n                ret.back() = -1;\n        }\n        return ret;\n    }\n};","author":"f1016142506","submissionId":"1575107153"},[]]},{"242":[{"id":"242","fileName":"1575107101.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& arr, vector<int>& q) {  // circular array\n        unordered_map<int, vector<int>> mp;\n        for(int i = 0; i < arr.size(); i++) {\n            mp[arr[i]].push_back(i);\n        }\n        vector<int> ret(q.size(), -1);\n        int n = arr.size();\n        \n        for(int i = 0; i < q.size(); i++) {\n            if(mp.find(arr[q[i]]) == mp.end() || mp[arr[q[i]]].size() <= 1){\n                ret[i] = -1;\n            } else {\n                // binary search\n                int idx = q[i];\n                auto &v = mp[arr[idx]];\n                int subidx = lower_bound(v.begin(), v.end(), idx) - v.begin();\n                int mi = INT_MAX;\n                if(subidx == 0) {\n                    mi = min(abs(idx - v.back() + n), abs(v[1] - idx));\n                } else if(subidx == v.size() - 1) {\n                    mi = min(abs(v[0] - idx + n), abs(idx - v[subidx - 1]));\n                } else {\n                    mi = min(mi, v[subidx + 1] - v[subidx]);\n                    mi = min(mi, v[subidx] - v[subidx - 1]);\n                }\n                ret[i] = mi;\n            }\n        }\n        return ret;\n    }\n};","author":"gy3T3vtplO","submissionId":"1575107101"},[]]},{"243":[{"id":"243","fileName":"1575107200.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        map<int,vector<int>> mp;\n        vector<int> b;\n        for(auto i:a)b.push_back(i);\n        for(auto i:a)b.push_back(i);\n        for(auto i:a)b.push_back(i);\n        \n        for(int i=0;i<b.size();i++){\n            mp[b[i]].push_back(i);\n        }\n        \n        vector<int> ans;\n        for(auto i:q){\n            int v=a[i];\n            int ind=i+a.size();\n            int l=0,h=mp[v].size();\n            int f=-1,s=-1;\n            \n            while(l<=h){\n                int m=l+h;\n                m>>=1;\n                if(mp[v][m] < ind){\n                    f=mp[v][m];\n                    l=m+1;\n                }else{\n                    h=m-1;\n                }\n            }\n            \n            \n            l=0,h=mp[v].size();\n            while(l<=h){\n                int m=l+h;\n                m>>=1;\n                if(mp[v][m] > ind){\n                    s=mp[v][m];\n                    h=m-1;\n                }else{\n                    l=m+1;\n                }\n            }\n            // cout<<f<<\" \"<<s<<\"n\";\n            if(f == -1)f=INT_MAX;\n            if(s == -1)s=INT_MAX;\n            int anss=min(abs(ind-f),abs(ind-s));\n            // if(f == -1 && s == -1)anss = -1;\n            if(anss >= a.size())anss=-1;\n            ans.push_back(anss);\n        }\n        return ans;\n    }\n};","author":"stackenqueue2","submissionId":"1575107200"},[]]},{"244":[{"id":"244","fileName":"1575107147.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> indices_of;\n        int n = nums.size();\n        for (int i=0; i < n; ++i) {\n            indices_of[nums[i]].emplace_back(i - n);\n        }\n        vector<int> index_in_indices_of(n);\n        for (int i=0; i < n; ++i) {\n            index_in_indices_of[i] = indices_of[nums[i]].size();\n            indices_of[nums[i]].emplace_back(i);\n        }\n        for (int i=0; i < n; ++i) {\n            indices_of[nums[i]].emplace_back(i + n);\n        }\n        vector<int> result(queries.size());\n        for (int i=0; i < queries.size(); ++i) {\n            int q = queries[i];\n            int nums_q = nums[q];\n            int idx = index_in_indices_of[q];\n            int a = indices_of[nums_q][idx-1];\n            int b = indices_of[nums_q][idx];\n            int c = indices_of[nums_q][idx+1];\n            int d1 = b - a;\n            int d2 = c - b;\n            int dist = min(d1, d2);\n            if (dist == n) {\n                dist = -1;\n            }\n            result[i] = dist;\n        }\n        return result;\n    }\n};","author":"Daniel Keyes","submissionId":"1575107147"},[]]},{"246":[{"id":"246","fileName":"1575107280.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        idxes = defaultdict(list)\n        jdxes = {}\n        n = len(nums)\n        for i, num in enumerate(nums):\n            jdxes[i] = len(idxes[num])\n            idxes[num].append(i)\n        # print(\"idxes\", dict(idxes))\n        # print(\"jdxes\", jdxes)\n        \n        ans = []\n        for q in queries:\n            l = idxes[nums[q]]\n            p = len(l)\n            # print(\"qp\", q, p, \"idx\", l)\n            if p < 2:\n                ans.append(-1)\n            else:\n                j = jdxes[q]\n                if j == 0:\n                    ans.append(min(abs(q - l[-1] + n), abs(q - l[1])))\n                elif j == p-1:\n                    ans.append(min(abs(l[0] - q + n), abs(q - l[p-2])))\n                else:\n                    ans.append(min(abs(q - l[j-1]), abs(q - l[j+1])))\n                # a, b = l[(j-1) % p], l[(j+1) % p]\n                # ans.append(min(abs(a-q), abs(b-q)))\n        return ans\n            ","author":"louissito","submissionId":"1575107280"},[]]},{"247":[{"id":"247","fileName":"1575107366.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n    dict := make(map[int][]int)\n\n    for i := 0; i < len(nums); i++ {\n        dict[nums[i]] = append(dict[nums[i]], i)\n    }\n\n    res := make([]int, 0)\n\n    for i := 0; i < len(queries); i++ {\n        list := dict[nums[queries[i]]]\n        if len(list) == 1 {res = append(res, -1); continue}\n        index := sort.SearchInts(list, queries[i])\n        var left, right int\n\n        if index+1 == len(list) {\n            right = len(nums)-list[index]+list[0]\n            left = list[index]-list[index-1]\n        } else if index == 0 {\n            right = list[index+1]-list[index]\n            left = len(nums)-list[len(list)-1]+list[index]\n        } else {\n            right = list[index+1]-list[index]\n            left = list[index]-list[index-1]\n        }\n        res = append(res, min(left, right))\n    } \n    \n    return res\n}","author":"Muzakkiy","submissionId":"1575107366"},[]]},{"248":[{"id":"248","fileName":"1575107531.txt","sourceCode":"from typing import List\nimport bisect\n\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = {}\n        n = len(nums)\n        for i, x in enumerate(nums):\n            if x not in d:\n                d[x] = []\n            d[x].append(i)\n\n        def find(idx, x):\n            if x not in d or len(d[x]) == 1:\n                return -1\n            r = bisect.bisect_right(d[x], idx)\n            if r == len(d[x]):\n                r = d[x][0]\n            else:\n                r = d[x][r]\n            l = bisect.bisect_left(d[x], idx) - 1\n            if l < 0:\n                l = d[x][-1]\n            else:\n                l = d[x][l]\n            return min(abs(l - idx), n - abs(l - idx), abs(r - idx), n - abs(r - idx))\n\n        ans = []\n        for idx in queries:\n            x = nums[idx]\n            ans.append(find(idx, x))\n        return ans","author":"pikapika","submissionId":"1575107531"},[]]},{"249":[{"id":"249","fileName":"1575107523.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int [] nums2 = new int[3 * nums.length];\n        for (int i = 0; i < nums2.length; i++) nums2[i] = nums[i % nums.length];\n        TreeMap<Integer, TreeSet<Integer>> d = new TreeMap<> ();\n        for (int i = 0; i < nums2.length; i++) {\n            d.putIfAbsent(nums2[i], new TreeSet<> ());\n            d.get(nums2[i]).add(i);\n        }\n\n        List<Integer> x = new ArrayList<> ();\n        for (int i = 0; i < queries.length; i++) {\n            queries[i] += nums.length;\n            Integer lower = d.get(nums2[queries[i]]).lower(queries[i]);\n            Integer higher = d.get(nums2[queries[i]]).higher(queries[i]);\n            int res = nums.length;\n            if (lower != null) {\n                res = Math.min(res, queries[i] - lower);\n            } if (higher != null) {\n                res = Math.min(res, higher - queries[i]);\n            } \n            if (res == nums.length) res = -1;\n            x.add(res);\n        } return x;\n    }\n}","author":"anthonyli633a","submissionId":"1575107523"},[]]},{"251":[{"id":"251","fileName":"1575107701.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        ans = []\n        loc = defaultdict(list)\n        for i, num in enumerate(nums):\n            loc[num].append(i)\n        for q in queries:\n            num = nums[q]\n            if len(loc[num]) == 1: \n                ans.append(-1)\n            else:\n                idx = bisect.bisect_left(loc[num], q)\n                if 0 < idx < len(loc[num])-1:\n                    ans.append(min(loc[num][idx+1]-q, q-loc[num][idx-1]))\n                elif idx == 0:\n                    ans.append(min(loc[num][1]-q, q+n-loc[num][-1]))\n                else:\n                    ans.append(min(q-loc[num][-2], loc[num][0]+n-q))\n        return ans","author":"Yang","submissionId":"1575107701"},[]]},{"252":[{"id":"252","fileName":"1575107769.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int q = queries.size(), n = nums.size();\n        vector<int> ans(q, 1e9);\n        map<int, set<int>> mpp;\n        for (int i = 0; i < n; i++) mpp[nums[i]].insert(i);\n        for (int i = 0; i < q; i++) {\n            auto it = mpp[nums[queries[i]]].find(queries[i]);\n            if (mpp[nums[queries[i]]].size() <= 1) continue;\n            if (it != mpp[nums[queries[i]]].begin()) {\n                auto jt = prev(it);\n                ans[i] = min({\n                    ans[i], \n                    abs(*it - *jt),\n                    n - abs(*it - *jt)\n                });\n            } else {\n                auto jt = mpp[nums[queries[i]]].rbegin();\n                ans[i] = min({\n                    ans[i], \n                    abs(*it - *jt),\n                    n - abs(*it - *jt)\n                });\n            }\n            it = next(it);\n            if (it != mpp[nums[queries[i]]].end()) {\n                auto jt = prev(it);\n                ans[i] = min({\n                    ans[i], \n                    abs(*it - *jt),\n                    n - abs(*it - *jt)\n                });\n            } else {\n                auto jt = prev(it);\n                it = mpp[nums[queries[i]]].begin();\n                ans[i] = min({\n                    ans[i], \n                    abs(*it - *jt),\n                    n - abs(*it - *jt)\n                });\n            }\n        }\n        for (auto &i: ans) {\n            if (i == 1e9) i = -1;\n        }\n        return ans;\n    }\n};","author":"Bitan Das","submissionId":"1575107769"},[]]},{"253":[{"id":"253","fileName":"1575107592.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        \n        ans = [-1 for _ in range(len(queries))]\n        # binary searches, remember, it is circular array!\n        di = dict()\n        for i in range(len(nums)):\n            if nums[i] not in di:\n                di.update({nums[i] : [] })\n            di[nums[i]].append(i)\n        for i in range(len(queries)):\n            idx = queries[i]\n            val = nums[idx]\n            if len(di[val]) == 1:\n                continue\n            if idx == di[val][-1]:\n                min_dis = min(abs(di[val][-1] - di[val][-2]), abs(len(nums) - di[val][-1] + di[val][0]))\n                ans[i] = min_dis\n                continue\n            elif idx == di[val][0]:\n                min_dis = min(abs(di[val][0] - di[val][1]), abs(len(nums) - di[val][-1] + di[val][0]))\n                ans[i] = min_dis\n                continue\n            # binary search\n            lo = 0\n            hi = len(di[val]) - 1\n            while True:\n                mid = (lo + hi) // 2\n                if idx == di[val][mid]:\n                    min_dis = min(di[val][mid] - di[val][mid - 1], di[val][mid + 1] - di[val][mid])\n                    ans[i] = min_dis\n                    break\n                elif idx == di[val][mid + 1]:\n                    min_dis = min(di[val][mid + 1] - di[val][mid], di[val][mid + 2] - di[val][mid + 1])\n                    ans[i] = min_dis\n                    break\n                elif idx < di[val][mid]:\n                    hi = mid\n                else:\n                    lo = mid + 1\n                    \n        return ans\n            \n            \n            ","author":"jachetheboss","submissionId":"1575107592"},[]]},{"254":[{"id":"254","fileName":"1575107996.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> positions;\n        for (int i = 0; i < nums.size(); ++i) {\n            positions[nums[i]].push_back(i);\n        }\n        vector<int> result;\n        result.reserve(queries.size());\n        for (int query : queries) {\n            int elem = nums[query];\n            vector<int>& indices = positions[elem];\n            if (indices.size() == 1) {\n                result.push_back(-1);\n            } else {\n                // Binary search the position of this index\n                auto iter = lower_bound(indices.begin(), indices.end(), query);\n                if (iter == indices.begin()) {\n                    // First element\n                    int distance_forward = *(iter + 1) - *iter;\n                    int distance_backward = nums.size() - indices.back() + indices.front();\n                    result.push_back(min(distance_forward, distance_backward));\n                } else if (iter + 1 == indices.end()) {\n                    // Last element\n                    int distance_forward = nums.size() - indices.back() + indices.front();\n                    int distance_backward = *iter - *(iter - 1); \n                    result.push_back(min(distance_forward, distance_backward));\n                } else {\n                    int distance_forward = *(iter + 1) - *iter;\n                    int distance_backward = *iter - *(iter - 1);\n                    result.push_back(min(distance_forward, distance_backward));\n                }\n            }\n        }\n        return result;\n    }\n};","author":"timothyleong97","submissionId":"1575107996"},[]]},{"256":[{"id":"256","fileName":"1575108082.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        D = defaultdict(deque)\n        \n        for i, val in enumerate(nums):\n            D[val].append(i)\n\n        for k in D:\n            q = D[k]\n\n            if len(q) <= 1:\n                continue\n\n            q.appendleft(q[-1]-n)\n            q.append(q[1]+n)\n\n        ret = []\n\n        for index in queries:\n            value = nums[index]\n            q = D[value]\n\n            if len(q) == 1:\n                ret.append(-1)\n                continue\n\n            l, r = 0, len(q)-1\n\n            while l < r:\n                m = (l+r)//2\n\n                if q[m] > index:\n                    r = m-1\n                elif q[m] < index:\n                    l = m+1\n                else:\n                    l = m\n                    break\n\n            #print(index, q, l)\n            ret.append(min(q[l]-q[l-1], q[l+1]-q[l]))\n\n        return ret\n            \n\n        ","author":"承緯 劉","submissionId":"1575108082"},[]]},{"257":[{"id":"257","fileName":"1575107811.txt","sourceCode":"import bisect\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        mp = defaultdict(list)\n\n        for i, num in enumerate(nums):\n            mp[num].append(i)\n\n        result = [-1] * len(queries)\n        n = len(nums)\n\n        for i, query in enumerate(queries):\n            num = nums[query]\n\n            lst = mp[num]\n            if len(lst) >= 2:\n                index = bisect.bisect_left(lst, query)\n                if index == 0:\n                    result[i] = min(lst[index + 1] - lst[index], n - lst[-1] + lst[index])\n                elif index == len(lst) - 1:\n                    result[i] = min(lst[index] - lst[index - 1], n - lst[index] + lst[0])\n                else:\n                    result[i] = min(lst[index + 1] - lst[index], lst[index] - lst[index - 1])\n                \n\n        return result","author":"Rithik Bansal","submissionId":"1575107811"},[]]},{"259":[{"id":"259","fileName":"1575108263.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        from collections import defaultdict\n        L = defaultdict(list)\n\n        for i, x in enumerate(nums):\n            L[x].append(i)\n        \n        ans = []\n        for q in queries:\n            if len(L[nums[q]]) == 1:\n                ans.append(-1)\n                continue\n            i = bisect.bisect_left(L[nums[q]], q)\n            if i == 0:\n                ans.append(min(L[nums[q]][1] - q, q + n - L[nums[q]][-1]))\n            elif i == len(L[nums[q]]) - 1:\n                ans.append(min(q - L[nums[q]][-2], L[nums[q]][0] + n - q))\n            else:\n                ans.append(min(L[nums[q]][i+1] - q, q - L[nums[q]][i-1]))\n        return ans\n        ","author":"Jack Chen","submissionId":"1575108263"},[]]},{"260":[{"id":"260","fileName":"1575108359.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        m = {}\n        def find_index(sorted_array, target):\n            index = bisect.bisect_left(sorted_array, target)\n            if index < len(sorted_array) and sorted_array[index] == target:\n                return index\n            return -1  # Return -1 if the element is not found\n        for i in range(len(nums)):\n            n = nums[i]\n            if not n in m:\n                m[n] = []\n            m[n].append(i)\n        for k, v in m.items():\n            v.sort()\n        res = []\n        def calc(v1, v2, size):\n            res = size\n            if v1 > v2:\n                res = v1 - v2\n                res = min(v2+size - v1, res)\n            if v2 > v1:\n                res = v2 - v1\n                res = min(v1+size - v2, res)\n            return res\n        for q in queries:\n            n = nums[q]\n            lst = m[n]\n            if len(lst) == 1:\n                res.append(-1)\n                continue\n            idx = find_index(lst, q)\n            prev = lst[idx-1]\n            next = lst[(idx+1)%len(lst)]\n            res.append(min(calc(q, prev, len(nums)), calc(q, next, len(nums))))\n        return res","author":"Kalomidin","submissionId":"1575108359"},[]]},{"261":[{"id":"261","fileName":"1575107658.txt","sourceCode":"int records[1000001];\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector <int> lefts(nums.size(), -1), rights(nums.size(), -1), answers(queries.size());\n        for (int i = 0; i != nums.size(); ++i) {\n            records[nums[i]] = i;\n        }\n        for (int i = 0; i != nums.size(); ++i) {\n            if (records[nums[i]] != i) {\n                lefts[i] = abs(i - records[nums[i]]);\n                lefts[i] = min(lefts[i], (int)nums.size() - lefts[i]);\n            }\n            records[nums[i]] = i;\n        }\n        /*for (int i : lefts) {\n            cout << i << ' ';\n        }\n        cout << 'n';*/\n        for (int i = nums.size() - 1; i >= 0; --i) {\n            records[nums[i]] = i;\n        }\n        for (int i = nums.size() - 1; i >= 0; --i) {\n            if (records[nums[i]] != i) {\n                rights[i] = abs(i - records[nums[i]]);\n                rights[i] = min(rights[i], (int)nums.size() - rights[i]);\n            }\n            records[nums[i]] = i;\n        }\n        /*for (int i : rights) {\n            cout << i << ' ';\n        }\n        cout << 'n';*/\n        for (int i = 0; i != queries.size(); ++i) {\n            answers[i] = min(lefts[queries[i]], rights[queries[i]]);\n        }\n        return answers;\n    }\n};","author":"Peter Lin","submissionId":"1575107658"},[]]},{"262":[{"id":"262","fileName":"1575108367.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        inds = defaultdict(list)\n        for i,n in enumerate(nums):\n            inds[n].append(i)\n\n        def query(i):\n            n = nums[i]\n            if len( inds[n] ) == 1:\n                return -1\n\n            options = []\n            i_ind = bisect.bisect_left( inds[n], i)\n            if i_ind > 0:\n                options.append( i - inds[n][i_ind-1] )\n            else:\n                options.append( len(nums)+i - inds[n][-1] )\n            if i_ind < len( inds[n] )-1:\n                options.append( inds[n][i_ind+1] - i )\n            else:\n                options.append( inds[n][0] + len(nums) - i )\n\n            return min(options)\n            \n        return [query(q) for q in queries]\n        ","author":"technique_god","submissionId":"1575108367"},[]]},{"263":[{"id":"263","fileName":"1575108529.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int> > dict;\n\n        int n = nums.size();\n        for (int i = 0; i < nums.size(); ++i)\n            {\n                dict[ nums[i] ].push_back(i);\n                //cout << nums[i] << \",\" << i << endl;\n            }\n\n        vector<int> res;\n        for (auto& q : queries)\n            {\n                int val = nums[ q ];\n\n                if (dict[val].size() == 1)\n                {\n                    res.push_back(-1);\n                    continue;\n                }\n\n                auto it = upper_bound(dict[val].begin(), dict[val].end(), q);\n                int cur = INT_MAX;\n                if (it != dict[val].end())\n                {                  \n                   int pos = *it;\n                   cur = min(cur, abs(q - pos));\n                } \n                else\n                {                   \n                   int pos = *dict[val].begin();\n                   cur = min(cur, abs(q - (n + pos)));\n                }\n                \n                it = lower_bound(dict[val].begin(), dict[val].end(), q);\n                if (it != dict[val].begin())\n                {\n                    --it;                    \n                    int pos = *it;\n                    cur = min(cur, abs(q - pos));\n                }\n                else\n                {                    \n                    int pos =  *dict[val].rbegin();\n                    cur = min(cur, abs(q + n - pos));\n                }\n\n                res.push_back(cur);\n            }\n\n        return res;\n    }\n};","author":"pandapower","submissionId":"1575108529"},[]]},{"264":[{"id":"264","fileName":"1575108239.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> indices;\n        for (int i = 0; i < nums.size(); ++i)\n            indices[nums[i]].push_back(i);\n\n        vector<int> ans;\n        for (auto query : queries) {\n            // Try lower_bound and also the element before that\n            auto & ids = indices[nums[query]];\n            if (ids.size() <= 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            auto it = upper_bound(begin(ids), end(ids), query);\n            int res = INT_MAX;\n            if (it != end(ids))\n                res = min(res, *it - query);\n            else\n                res = min(res, (int)nums.size() - query + ids.front());\n            it = lower_bound(begin(ids), end(ids), query);\n            // Try the previous index\n            if (it != begin(ids)) \n                res = min(res, query - *prev(it));\n            else\n                res = min(res, (int)nums.size() - ids.back() + query);\n            ans.push_back(res);\n        }\n        return ans;\n    }\n};","author":"Clark Li","submissionId":"1575108239"},[]]},{"265":[{"id":"265","fileName":"1575108716.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> map = new HashMap();\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n        \tif (!map.containsKey(nums[i]))\n        \t\tmap.put(nums[i], new ArrayList());\n        \tmap.get(nums[i]).add(i);\n        }\n        List<Integer> result = new ArrayList();\n        for (int q : queries) {\n        \tint num = nums[q];\n        \tList<Integer> index = map.get(num);\n    \t\tint len = index.size();\n        \tif (len == 1)\n        \t\tresult.add(-1);\n        \telse {\n        \t\tint find = Collections.binarySearch(index, q);\n        \t\tint before = (find == 0) ?  q + n - index.get(len - 1) : q - index.get(find - 1);\n        \t\tint after = (find == len - 1) ? index.get(0) + n - q : index.get(find + 1) - q;\n        \t\tresult.add(Math.min(after, before));\n        \t}\n        }\n        return result;\n    }\n}","author":"realstar","submissionId":"1575108716"},[{"id":"1296","similarity":0.7046979865771812,"totOverlap":105,"longestOverlap":9}]],"1296":[{"id":"1296","fileName":"1575138441.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer,List<Integer>> map = new HashMap<>();\n        int n = nums.length;\n        for( int i=0; i<n; i++ ) {\n            map.putIfAbsent( nums[i], new ArrayList<Integer>() );\n            map.get(nums[i]).add(i);\n        }\n\n        List<Integer> res = new ArrayList<>();\n        for( int query : queries ) {\n            List<Integer> indices = map.get( nums[query] );\n            if( indices.size() == 1 )\n                res.add( -1 );\n            else {\n                int cur = Collections.binarySearch( indices, query );\n                int len = indices.size();\n                int prev = ( cur == 0 ) ? query + n - indices.get( len-1 ) : query-indices.get(cur-1);\n                int next = ( cur == len-1 ) ? n - query + indices.get( 0 ) : indices.get(cur+1)-query;\n                res.add( Math.min( prev, next ) );\n            }\n        }\n        return res;\n    }\n}","author":"Pankaj Jangid","submissionId":"1575138441"},[{"id":"265","similarity":0.7046979865771812,"totOverlap":105,"longestOverlap":9}]]},{"266":[{"id":"266","fileName":"1575108617.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        nums = nums\n        d = defaultdict(lambda:[])\n        for i in range(len(nums)):\n            d[nums[i]].append(i)\n        d2 = {}\n        for i in d:\n            for j in range(len(d[i])):\n                if len(d[i]) < 2:\n                    d2[d[i][j]] = -1\n                else:\n                    if 0 < j < len(d[i]) - 1:\n                        d2[d[i][j]] = min(d[i][j] - d[i][j-1], d[i][j+1] - d[i][j])\n                    elif j == 0:\n                        d2[d[i][j]] = min(len(nums) + d[i][j] - d[i][j-1], d[i][j+1] - d[i][j])\n                    elif j == len(d[i]) - 1:\n                        d2[d[i][j]] = min(d[i][j] - d[i][j-1], len(nums) + d[i][0] - d[i][j])\n        ans = []\n        for i in queries:\n            ans.append(d2[i])\n\n        return ans","author":"Amit Bansal","submissionId":"1575108617"},[]]},{"267":[{"id":"267","fileName":"1575108629.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int, set<int>> v2idx;\n        for (int i = 0; i < n; i++) {\n            if (v2idx.find(nums[i]) == v2idx.end()) {\n                v2idx[nums[i]] = set<int>();\n            }\n            v2idx[nums[i]].insert(i);\n        }\n        auto dist = [&n](int a, int b) {\n            int d = a-b;\n            d = (d % n + n) % n;\n            return min(d, n-d);\n        };\n        \n        vector<int> res;\n        for (auto q : queries) {\n            int idx = q;\n            int val = nums[idx];\n            if (v2idx[val].size() == 1) {\n                res.push_back(-1);\n            } else {\n                set<int>& s = v2idx[val];\n                auto iter = s.find(idx);\n                auto prev = iter;\n                if (prev == s.begin()) {\n                    prev = s.end();\n                }\n                prev--;\n                \n                auto next = iter;\n                ++next;\n                if (next == s.end()) {\n                    next = s.begin();\n                }\n                res.push_back(min(dist(*prev, *iter), dist(*iter, *next)));\n            }\n        }\n        return res;\n    }\n};","author":"loriex","submissionId":"1575108629"},[]]},{"268":[{"id":"268","fileName":"1575108729.txt","sourceCode":"#include<bits/stdc++.h>\nusing namespace std ; \nusing int64 = long long ; \nconstexpr int64 INF = 1e18 ; \n\nclass Solution {\npublic:\n    vector<int> a ; \n    int n ; \n    vector< vector<int>> info ; \n    int max_val ; \n    int m ; \n\n    int dis( int pos1 , int pos2 ) {\n        if( pos1 > pos2 ) {\n            swap( pos1, pos2 ) ;\n        }\n        int t1 = pos2 - pos1 ;\n        int t2 = n - t1 ;\n        return min( t1 , t2 ) ; \n    }\n    int solve( int pos ) { \n\n        int val = a[pos] ; \n        auto &p = info[val] ; \n        int tm = p.size() ; \n        if( tm == 1 ) {\n            return -1 ; \n        }\n\n        \n        auto q = lower_bound( p.begin(), p.end(), pos ) ;\n        int j = q - p.begin() ;\n\n        \n\n        int pre = (( j - 1 ) % tm + tm ) % tm ; \n        int aft = ( (j+1) % tm ) ; \n        \n        int d1 = dis( p[pre] , pos ) ; \n        int d2 = dis( pos , p[aft] ) ; \n\n        return min( d1 , d2 ) ; \n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        \n        a = nums ; \n        n = a.size() ; \n\n        max_val = *max_element( a.begin() , a.end() ) ; \n\n        info.assign( max_val + 1 , {} ) ; \n\n        for( int i = 0 ; i < n ; i++ ) {\n            int val = a[i] ; \n            info[ val ].emplace_back( i ) ; \n        }\n\n        m = queries.size() ; \n        vector<int> ret( m  , -1 ) ;\n        for( int j = 0 ; j < m ; j++ ) {\n            int q = queries[j] ; \n            ret[j] = solve( q ) ;\n        }\n        return ret ; \n    }\n};\n\nint ma2in( )  { \n    Solution  t; \n\n    vector<int> a , nums ,  queries ;\n    int n ; \n\n    nums = {1,3,1,4,1,3,2}, queries = {0,3,5} ;\n\n    nums = {1,2,3,4}, queries = {0,1,2,3} ;\n    \n    auto ans = t. solveQueries( nums , queries ) ; \n\n    for( auto x : ans ) {\n        cout << x << \"n\" ; \n    }\n    // cout << ans << \"n\" ;\n\n    return 0 ; \n}\n","author":"luck","submissionId":"1575108729"},[]]},{"269":[{"id":"269","fileName":"1575108763.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        indices = {}\n        for i, num in enumerate(nums):\n            if num not in indices:\n                indices[num] = []\n            indices[num].append(i)\n\n        result = []\n\n        # query is the starting index\n        for query in queries:\n            num = nums[query]\n            if len(indices[num]) == 1:\n                result.append(-1)\n                continue\n\n            if query == indices[num][0]:\n                result.append(min(\n                    indices[num][1] - indices[num][0],\n                    len(nums) - (indices[num][-1] - indices[num][0])\n                ))\n            elif query == indices[num][-1]:\n                result.append(min(\n                    indices[num][-1] - indices[num][-2],\n                    len(nums) - (indices[num][-1] - indices[num][0])\n                ))\n            else:\n                left = 0\n                right = len(indices[num]) - 1\n                while left <= right:\n                    mid = (left + right) // 2\n                    if indices[num][mid] == query:\n                        left = mid \n                        break\n                    elif indices[num][mid] > query:\n                        right = mid - 1\n                    else:\n                        left = mid + 1\n\n                result.append(min(\n                    indices[num][left] - indices[num][left - 1],\n                    indices[num][left + 1] - indices[num][left]\n                ))\n        return result","author":"messyhair","submissionId":"1575108763"},[]]},{"270":[{"id":"270","fileName":"1575108638.txt","sourceCode":"#define vi vector<int>\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\n#define pb push_back\n#define lb lower_bound\n#define umap unordered_map\n#define F(i, a, b) for (int i = a; i < b; i++)\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& b) {\n        int n = sz(a);\n        umap<int, vi> mp;\n        F(i, 0, n) mp[a[i]].pb(i);\n        for (auto &p : mp) sort(all(p.second));\n        vi r;\n        for (int q : b) {\n            auto &v = mp[a[q]];\n            if (sz(v) < 2) { r.pb(-1); continue; }\n            int p = lb(all(v), q) - v.begin();\n            int j1 = v[(p + 1) % sz(v)], j2 = v[(p + sz(v) - 1) % sz(v)];\n            int d1 = min(abs(q - j1), n - abs(q - j1));\n            int d2 = min(abs(q - j2), n - abs(q - j2));\n            r.pb(min(d1, d2));\n        }\n        return r;\n    }\n};","author":"Ayan","submissionId":"1575108638"},[]]},{"272":[{"id":"272","fileName":"1575108978.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n\n        n = len(nums)\n        \n        pos_map = defaultdict(list)\n\n        for i, num in enumerate(nums):\n            pos_map[num].append(i)\n\n        ans = []\n        for q in queries:\n            num = nums[q]\n            if len(pos_map[num]) == 1:\n                ans.append(-1)\n            else:\n                idx = bisect_left(pos_map[num], q)\n                if idx == 0:\n                    d1 = pos_map[num][1] - pos_map[num][0]\n                    d2 = n + pos_map[num][0] - pos_map[num][-1]\n                elif idx == len(pos_map[num]) - 1:\n                    d1 = pos_map[num][-1] - pos_map[num][-2]\n                    d2 = n + pos_map[num][0] - pos_map[num][-1]\n                else:\n                    d1 = pos_map[num][idx] - pos_map[num][idx-1]\n                    d2 = pos_map[num][idx+1] - pos_map[num][idx]\n                ans.append(min(d1, d2))\n                    \n        return ans\n        ","author":"ShadowLau","submissionId":"1575108978"},[]]},{"273":[{"id":"273","fileName":"1575108997.txt","sourceCode":"#include <bits/stdc++.h>\n#pragma GCC optimize(2)\n#define rep(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep_(i, a, b) for (int i = (a); i > (b); i--)\n#define CEIL_DIV(a, b) ((b) == 0 ? 0 : (((a) >= 0) ? ((a) + (b) - 1) / (b) : (a) / (b)))\n#define FLOOR_DIV(a, b) (((a) / (b)) - ((a) % (b) != 0 &&(((a) < 0) != ((b) < 0))))\n#define mst(x, a) memset(x, a, sizeof(x))\n#define all(a) begin(a), end(a)\n#define lowbit(x) ((x) & (-(x)))\n#define bitcnt(x) (__builtin_popcountll(x))\n#define se second\n#define fi first\n#define pb push_back\n#define maxe max_element\n#define mine min_element\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, ll> pil;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\nconstexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\nconstexpr static int inf = 0x3f3f3f3f, mod = 1e9 + 7;\nconst ll infl = 0x3f3f3f3f3f3f3f3fll;\ntemplate<class T> bool chmax(T &a, T b) {\n    if (a >= b) return false;\n    a = b; return true;\n}\ntemplate<class T> bool chmin(T &a, T b) {\n    if (a <= b) return false;\n    a = b; return true;\n}\ntemplate<class T> bool chsum(T &a, T b) {\n    a = (a + b + mod) % mod;\n    return 0;\n}\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        const int n = nums.size();\n        const int m = queries.size();\n        unordered_map<int, vi> val2pos;\n        rep(i, 0, n) {\n            val2pos[nums[i]].pb(i);\n        }\n\n        for (auto &kv : val2pos) {\n            sort(all(kv.se));\n        }\n\n        vi indexOf(n, -1);\n        for (auto &kv : val2pos) {\n            auto &pos = kv.se;\n            rep(p, 0, pos.size()) {\n                indexOf[pos[p]] = p;\n            }\n        }\n\n        vi res(m);\n        rep(i, 0, m) {\n            int idx = queries[i];\n            auto &pos = val2pos[nums[idx]];\n            int sz = pos.size();\n            if (sz < 2) {\n                res[i] = -1;\n            } else {\n                int pprev = (indexOf[idx] + sz - 1) % sz;\n                int pnext = (indexOf[idx] + 1) % sz;\n                int distPrev = helper(idx, pos[pprev], n);\n                int distNext = helper(idx, pos[pnext], n);\n                res[i] = min(distPrev, distNext);\n            }\n        }\n\n        return res;\n    }\nprivate:\n    inline int helper(int a, int b, int n) {\n        return min(abs(b - a), n - abs(b - a));\n    }\n};","author":"Ryan","submissionId":"1575108997"},[]]},{"274":[{"id":"274","fileName":"1575108593.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        TreeSet<Integer>[] TSs = new TreeSet[1000001];\n        for (int i = 0; i < nums.length; i++) {\n            if (TSs[nums[i]] == null)\n                TSs[nums[i]] = new TreeSet<>();\n            TSs[nums[i]].add(i);\n        }\n        List<Integer> res = new ArrayList<>();\n        for (int query : queries) {\n            int num = nums[query];\n            if (TSs[num] == null || TSs[num].size() == 1) {\n                res.add(-1);\n            } else {\n                Integer a = TSs[num].floor(query - 1);\n                Integer b = TSs[num].higher(query);\n                if (a == null) {\n                    a = nums.length - TSs[num].last() + query;\n                } else {\n                    a = query - a;\n                }\n                if (b == null) {\n                    b = nums.length + TSs[num].first() - query;\n                } else {\n                    b = b - query;\n                }\n                res.add(Math.min(a, b));\n            }\n        }\n        return res;\n    }\n}","author":"watercyb","submissionId":"1575108593"},[]]},{"275":[{"id":"275","fileName":"1575109057.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = defaultdict(lambda:[])\n        for i, v in enumerate(nums):\n            d[v].append(i)\n\n        answer = []\n        for i in queries:\n            t = nums[i]\n            if len(d[t]) == 1:\n                answer.append(-1)\n            else:\n                md = len(nums)\n                ind = bisect_left(d[t], i)\n                n = len(nums)\n                if ind == 0:\n                    md = min(i + n - d[t][-1], d[t][1] - i)\n                elif ind == len(d[t]) - 1:\n                    md = min(d[t][0] + n - i, i - d[t][ind - 1])\n                else:\n                    md = min(i - d[t][ind - 1], d[t][ind + 1] - i)\n                answer.append(md)\n        return answer","author":"Josh","submissionId":"1575109057"},[]]},{"277":[{"id":"277","fileName":"1575109024.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n\n        n = len(nums)\n        seen = defaultdict(list)\n        res = [-1] * len(queries)\n\n        def get_dist(i, j):\n\n            if i > j:\n                i, j = j, i\n                \n            return min(j - i, n - j + i)\n                \n                \n\n        for i, v in enumerate(nums):\n            seen[v].append(i)\n\n        for i, v in enumerate(queries):\n\n            qi = v\n            v = nums[v]\n\n            if len(seen[v]) <= 1:\n                continue\n\n            idx = bisect.bisect_left(seen[v], qi)\n            # print(i, idx, qi, seen[v])\n\n            nei = idx - 1\n            if idx == 0:\n                nei = -1\n            \n            nei = seen[v][nei]\n\n            # print(nei, qi)\n            res[i] = get_dist(nei, qi)\n\n            nei = idx + 1\n            if idx == len(seen[v]) - 1:\n                nei = 0\n            \n            \n            \n            nei = seen[v][nei]\n\n            # print(nei, qi)\n            res[i] = min(res[i], get_dist(nei, qi))\n\n        return res","author":"Manyu","submissionId":"1575109024"},[]]},{"280":[{"id":"280","fileName":"1575109229.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        ix = collections.defaultdict(list)\n        for i, x in enumerate(nums):\n            ix[x].append(i)\n            ix[x].append(i - n)\n            ix[x].append(i + n)\n        for x in ix:\n            ix[x].sort()\n\n        sol = []\n        for j in queries:\n            y = nums[j]\n            jj = bisect.bisect_left(ix[y], j)\n            mindist = n\n            if jj > 0:\n                mindist = min(mindist, abs(ix[y][jj - 1] - j))\n            if jj + 1 < len(ix[y]):\n                mindist = min(mindist, abs(ix[y][jj + 1] - j))\n            if mindist == n:\n                sol.append(-1)\n            else:\n                sol.append(mindist)\n\n        return sol\n","author":"Behrooz Sepehry","submissionId":"1575109229"},[]]},{"281":[{"id":"281","fileName":"1575108833.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n=len(nums)\n        nums=nums+nums\n        closestDist = [n]*(2*n)\n        dct = {}\n        \n        for idx,x in enumerate(nums):\n            if x in dct:\n                closestDist[idx]=idx-dct[x]\n            dct[x]=idx\n        dct = {}\n\n        for idx in range(len(nums)-1,-1,-1):\n            x=nums[idx]\n            if x in dct:\n                closestDist[idx]=min(closestDist[idx],dct[x]-idx)\n            dct[x]=idx\n        \n        result = []\n        for q in queries:\n            result.append(min(closestDist[q],closestDist[q+n]))\n\n        for i in range(len(result)):\n            if result[i]==n:\n                result[i]=-1;\n        \n        return result\n        ","author":"Sundeep Chenreddy","submissionId":"1575108833"},[]]},{"282":[{"id":"282","fileName":"1575109255.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n, m = len(nums), len(queries)\n        value_to_indices = collections.defaultdict(list)\n        for i, num in enumerate(nums):\n            value_to_indices[num].append(i)\n        \n        res = [float('inf')] * m\n        \n        for i, query in enumerate(queries):\n            q = value_to_indices[nums[query]]\n            j = bisect.bisect_left(q, query)\n            if len(q) > 1:\n                x, y = j, (j + 1) % len(q)\n                res[i] = min(res[i], (q[y] - q[x]) % n)\n                \n                x, y = (j - 1) % len(q), j\n                res[i] = min(res[i], (q[y] - q[x]) % n)\n                \n        return [-1 if x == float('inf') else x for x in res]","author":"gan14008","submissionId":"1575109255"},[]]},{"283":[{"id":"283","fileName":"1575109569.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer,TreeSet<Integer>> hm = new HashMap<>();\n        int n= nums.length;\n        for(int i=0; i<n; i++){\n            int num = nums[i];\n            if(!hm.containsKey(num)) hm.put(num, new TreeSet<>());\n            hm.get(num).add(i);\n        }\n\n        List<Integer> a = new ArrayList<>();\n        int j=0;\n        for(int idx: queries){\n            int val = nums[idx];\n            Integer left = hm.get(val).lower(idx);\n            Integer right = hm.get(val).higher(idx);\n            int ans = n;\n\n            if(left == null){\n                Integer temp = hm.get(val).lower(n);\n                if(temp != idx){\n                    ans = Math.min(ans, idx+n-temp);\n                }\n            }else{\n                ans = Math.min(ans, idx-left);\n            }\n\n            if(right == null){\n                Integer temp = hm.get(val).higher(-1);\n                if(temp != idx){\n                    ans = Math.min(ans, temp+n-idx);\n                }\n            }else{\n                ans = Math.min(ans, right-idx);\n            }\n\n            a.add(ans == n ? -1 : ans);\n        }\n        return a;\n    }\n}","author":"Arpit Rathore","submissionId":"1575109569"},[]]},{"284":[{"id":"284","fileName":"1575109801.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> idx;\n        for (int i = 0; i < n; i++) {\n            idx[nums[i]].push_back(i);\n        }\n        vector<int> ret;\n        for (int q: queries) {\n            int num = nums[q];\n            if ((int)idx[num].size() == 1) {\n              ret.push_back(-1);\n              continue;\n            }\n            auto it = lower_bound(idx[num].begin(), idx[num].end(), q);\n            if (it == idx[num].begin()) {\n                int now = *it;\n                int now_m_1 = *(prev(idx[num].end())) - n;\n                int now_p_1 = *(next(it));\n            ret.push_back(min(now-now_m_1, now_p_1-now));\n            } else if (it == prev(idx[num].end())) {\n                int now = *it;\n                int now_m_1 = *(prev(it));\n                int now_p_1 = *(idx[num].begin()) + n;\n            ret.push_back(min(now-now_m_1, now_p_1-now));\n            } else {\n                int now = *it;\n                int now_m_1 = *(prev(it));\n                int now_p_1 = *(next(it));\n            ret.push_back(min(now-now_m_1, now_p_1-now));\n            }\n        }\n        return ret;\n        \n    }\n};","author":"Yi Yao","submissionId":"1575109801"},[]]},{"285":[{"id":"285","fileName":"1575109869.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n\n        vector<int> answer;\n        map<int,vector<int>> mp;\n\n        for(int i = 0; i < nums.size(); i++){\n            mp[nums[i]].push_back(i);\n        }\n\n        for(auto &it: mp){\n            sort(it.second.begin(), it.second.end());\n        }\n\n        for(auto &it: queries){\n            int num = nums[it];\n            if(mp[num].size() < 2){ \n                answer.push_back(-1);\n                continue;\n            }\n            auto indx1 = lower_bound(mp[num].begin(), mp[num].end(), it) - mp[num].begin();\n            int left = (indx1 - 1 + mp[num].size()) % mp[num].size();\n            int right = (indx1 + 1) % mp[num].size();\n\n            int leftd = min(abs(it - mp[num][left]), (int)nums.size() - abs(it - mp[num][left]));\n            int rightd = min(abs(mp[num][right] - it), (int)nums.size() - abs(mp[num][right] - it));\n            int res = min(leftd, rightd);\n            answer.push_back(res);\n        } \n        return answer;\n    }\n};","author":"Lakshay Tewtiya","submissionId":"1575109869"},[]]},{"287":[{"id":"287","fileName":"1575110039.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(),m = queries.size();\n        unordered_map<int,vector<int>>pos;\n        for(int i=0;i<n;i++)pos[nums[i]].push_back(i);\n        vector<int>ans;\n        for(int i=0;i<m;i++){\n            int val = nums[queries[i]];\n            if(pos[val].size()==1)ans.push_back(-1);\n            else{\n                int mini = INT_MAX;\n                auto it = lower_bound(pos[val].begin(),pos[val].end(),queries[i]);\n                if(next(it)!=pos[val].end()){\n                    mini = min(mini,(*next(it))-queries[i]);\n                }\n                else{\n                    int firstIndex = pos[val][0];\n                    mini = min(mini,n-1-queries[i]+firstIndex+1);\n                }\n                if(it!=pos[val].begin()){\n                    mini = min(mini,queries[i]-(*prev(it)));\n                }\n                else{\n                    int lastValue = pos[val].back();\n                    mini = min(mini,queries[i]+(n-lastValue));\n                }\n                ans.push_back(mini);\n            }\n        }\n        return ans;\n    }\n};","author":"neatHyperTxt","submissionId":"1575110039"},[]]},{"288":[{"id":"288","fileName":"1575109839.txt","sourceCode":"#include <bits/stdc++.h>\n#define ll long long int\n#define FASTIO std::ios::sync_with_stdio(false);\n#define pb push_back\n#define mp make_pair\n#define pi pair <ll,ll>\n#define F first\n#define S second\n#define inf 1e18\n#define pi pair <ll,ll>\n#define g(x) cout<<x<<endl\n#define all(x) x.begin(),x.end()\n#define rall(a) a.rbegin(), a.rend()\n#define input_from_file  freopen(\"input.txt\", \"r\", stdin);\n#define mod 1000000007ll\n#define sz 400005\n#define bitcnt(x) __builtin_popcountll(x)\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map <ll,vector <ll> > ma;\n        for(ll i = 0;i < nums.size();i++){\n            ma[nums[i]].pb(i);\n        }\n        vector <int> ans;\n        int n = nums.size();\n        for(auto x:queries){\n            if(ma[nums[x]].size() == 1){\n                ans.pb(-1);\n            }else {\n                ll pos = lower_bound(all(ma[nums[x]]),x) - ma[nums[x]].begin();\n                ll prev = pos-1;\n                ll nxt = pos+1;\n                ll dist = inf;\n                ll lst = ma[nums[x]].size()-1;\n                if(prev >= 0){\n                    dist = min(dist,abs(ma[nums[x]][pos]-ma[nums[x]][prev]));\n                    dist = min(dist,ma[nums[x]][prev] + n - ma[nums[x]][pos]);\n                    // dist = min(dist, ma[nums[x]][prev] + )\n                    \n                }\n                else {\n                   dist = min(dist,ma[nums[x]][pos]+ n - ma[nums[x]][lst]);\n                }\n                if(nxt <= lst){\n                    dist = min(dist,abs(ma[nums[x]][pos]-ma[nums[x]][nxt]));\n                    dist = min(dist,ma[nums[x]][pos]+ n - ma[nums[x]][nxt]);\n                }\n                else {\n                    dist = min(dist,ma[nums[x]][0] + n-ma[nums[x]][pos]);\n                }\n                ans.pb(dist);\n            }\n        }\n        return ans;\n    }\n};","author":"saketw","submissionId":"1575109839"},[]]},{"289":[{"id":"289","fileName":"1575109875.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        map<int,vector<int>> mp;\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(int i=0;i<queries.size();i++){\n            int val=nums[queries[i]];\n            int res=-1;\n            auto itr=mp.find(val);\n            if(itr==mp.end() || itr->second.size()==1){\n                ans.push_back(res);\n                continue;\n            }\n            int sz=itr->second.size();\n            int idx=lower_bound(itr->second.begin(),itr->second.end(),queries[i])-itr->second.begin();\n            int a=queries[i]-itr->second[(idx-1+sz)%sz];\n            // cout<<a<<\" \";\n            if(a<0) {\n                a=queries[i]+n-itr->second[(idx-1+sz)%sz];\n            }\n            // cout<<a<<\" \";\n            res=a;\n            int b=itr->second[(idx+1)%sz]-queries[i];\n            // cout<<b<<\" \";\n            if(b<0){\n                b=itr->second[(idx+1)%sz]+n-queries[i];\n            }\n            // cout<<b<<endl;\n            res=min(res,b);\n            ans.push_back(res);\n        }\n        return ans;\n    }\n};","author":"Ritik Arora","submissionId":"1575109875"},[]]},{"292":[{"id":"292","fileName":"1575110122.txt","sourceCode":"\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int, vector<int>> mp;\n        \n        \n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n\n        int q = queries.size();\n        vector<int> ans(q, -1);\n        \n        \n        for (int i = 0; i < q; i++) {\n            int index = queries[i];\n            int value = nums[index];\n            \n           \n            if (mp[value].size() == 1) {\n                ans[i] = -1;\n                continue;\n            }\n            \n            \n            auto& indices = mp[value];\n            \n            \n            auto it = lower_bound(indices.begin(), indices.end(), index);\n            int minDist = INT_MAX;\n            \n            \n            if (it != indices.begin()) {\n                minDist = min(minDist, abs(index - *prev(it)));\n            }\n            if (it != indices.end() && *it != index) {\n                minDist = min(minDist, abs(index - *it));\n            }\n            if (it != indices.end() && it + 1 != indices.end()) {\n                minDist = min(minDist, abs(index - *(it + 1)));\n            }\n\n            \n            int firstIndex = indices.front();\n            int lastIndex = indices.back();\n            minDist = min({minDist, index + n - lastIndex, firstIndex + n - index});\n\n            ans[i] = minDist;\n        }\n        \n        return ans;\n    }\n};\n","author":"Vardhannn","submissionId":"1575110122"},[]]},{"293":[{"id":"293","fileName":"1575110116.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> mp;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> res;\n        for (auto &i : queries) {\n            int num = nums[i];\n            if (mp[num].size() == 1) {\n                res.push_back(-1);\n                continue;\n            }\n            auto it = lower_bound(mp[num].begin(), mp[num].end(), i);\n            int dist = INT_MAX;\n            if (it != mp[num].begin()) {\n                dist = min(dist, i - *prev(it));\n            }\n            if (next(it) != mp[num].end()) {\n                dist = min(dist, *next(it) - i);\n            }\n            dist = min(dist, n - abs(mp[num].front() - i));\n            dist = min(dist, n - abs(mp[num].back() - i));\n            res.push_back(dist);\n        }\n        return res;\n    }\n};\n","author":"Aditya Roy Chowdhury","submissionId":"1575110116"},[{"id":"849","similarity":0.7277777777777777,"totOverlap":131,"longestOverlap":31}]],"849":[{"id":"849","fileName":"1575126749.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        map<int, vector<int>> m;\n        int n = a.size();\n\n        for(int i = 0; i < n; i++){\n            m[a[i]].push_back(i);\n        }\n        vector<int> ans;\n        \n        for(auto &i: q){\n            int k = a[i];\n            int minn = n + 1;\n\n            if(m[k].size() == 1){\n                ans.push_back(-1);\n                continue;\n            }\n            \n            auto itr = lower_bound(m[k].begin(), m[k].end(), i);\n\n            if (itr != m[k].end() && *itr != i) {\n                minn = min(minn, *itr - i);\n            }\n            \n            if (itr != m[k].begin()) {\n                itr--;\n                minn = min(minn, i - *itr);\n            }\n\n            itr = upper_bound(m[k].begin(), m[k].end(), i);\n\n            if (itr != m[k].end()) {\n                minn = min(minn, *itr - i);\n            }\n            \n            minn = min({minn, i + n - m[k].back(), m[k].front() + n - i});\n\n            ans.push_back(minn);\n        }\n        return ans;\n    }\n};","author":"Pushkar Mourya","submissionId":"1575126749"},[{"id":"293","similarity":0.7277777777777777,"totOverlap":131,"longestOverlap":31}]]},{"294":[{"id":"294","fileName":"1575110124.txt","sourceCode":"// SHRISHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH\n//boilerplate code\n\n\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define vi vector<int>\n#define vll vector<ll>\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define mp make_pair\n#define f first\n#define s second\n#define mod 1000000007\n#define INF 1e9\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((int)(x).size())\n// #define endl \"n\"\n\nclass Solution {\npublic:\n    deque<int> computeMinDistances(vi& a, int n) {\n        deque<int> d(n, -1);\n        map<int, deque<int>> m;\n        \n        for (int i = 0; i < n; i++) {\n            m[a[i]].pb(i);\n        }\n\n        for (auto &p : m) {\n            deque<int>& v = p.s;\n            if (sz(v) < 2) {\n                continue;\n            }\n\n            int s = sz(v);\n            for (int i = 0; i < s; i++) {\n                int c = v[i];\n                int l = v[(i - 1 + s) % s];\n                int r = v[(i + 1) % s];\n\n                int d1 = min(abs(c - l), n - abs(c - l));\n                int d2 = min(abs(r - c), n - abs(r - c));\n\n                d[c] = min(d1, d2);\n            }\n        }\n        return d;\n    }\n\n    vi solveQueries(vi& a, vi& q) {\n        int n = sz(a);\n        deque<int> d = computeMinDistances(a, n);\n        vi res;\n        for (int i : q) {\n            res.pb(d[i]);\n        }\n        return res;\n    }\n};\n","author":"Shrishti Dubey","submissionId":"1575110124"},[]]},{"296":[{"id":"296","fileName":"1575110178.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        index = defaultdict(list)\n        m = len(queries)\n        result = [-1] * m\n        for i in range(n):\n            index[nums[i]].append(i)\n        for j, query in enumerate(queries):\n            if len(index[nums[query]]) == 1:\n                continue\n            else:\n                idx = bisect_left(index[nums[query]], query)\n                d1, d2 = 2e9, 2e9\n                if idx > 0:\n                    d1 = (query - index[nums[query]][idx - 1]) % n\n                elif index[nums[query]][-1] != query:\n                    d1 = (query - index[nums[query]][-1]) % n\n                if idx < len(index[nums[query]]) - 1:\n                    d2 = (index[nums[query]][idx + 1] - query) % n\n                elif index[nums[query]][0] != query:\n                    d2 = (index[nums[query]][0] - query) % n\n\n                result[j] = min(d1, d2)\n        return result\n","author":"Harish Ramaswamy","submissionId":"1575110178"},[]]},{"297":[{"id":"297","fileName":"1575110249.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = collections.defaultdict(list)\n        for i, v in enumerate(nums):\n            d[v].append(i)\n\n        result = []\n        for q in queries:\n            v = nums[q]\n            if len(d[v]) == 1:\n                result.append(-1)\n                continue\n            index = bisect.bisect_left(d[v], q)\n            right = 0\n            if index == len(d[v])-1:\n                right = d[v][0] + len(nums) - q\n            else:\n                right = d[v][index+1] - q\n            left = 0\n            if index == 0:\n                left = q+len(nums) - d[v][-1]\n            else:\n                left = q - d[v][index-1]\n            result.append(min(left, right))\n        return result","author":"Kai Yang","submissionId":"1575110249"},[]]},{"299":[{"id":"299","fileName":"1575110252.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int, vector<int>> mp;\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n\n        vector<int> z(n, -1);\n        for(auto &l: mp){\n            auto &v = l.second;\n            int m = v.size();\n            if(m==1) continue;\n            for(int i=0;i<m;i++){\n                if((v[i]-v[(i-1+m)%m]+n)%n<=(v[(i+1)%m] - v[i]+n)%n){\n                    z[v[i]] = (v[i]-v[(i-1+m)%m]+n)%n;\n                } else {\n                    z[v[i]] = (v[(i+1)%m] - v[i]+n)%n;\n                }\n            }\n        }\n        vector<int> ans;\n        for(int x: queries){\n            ans.push_back(z[x]);\n        }\n        return ans;\n        \n    }\n};","author":"Parag Goyal","submissionId":"1575110252"},[]]},{"167":[{"id":"167","fileName":"1575104157.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int m=q.size(),n=nums.size();\n        vector<int> ans(m);\n        unordered_map<int,int> prev;\n        vector<int> res(n,n);\n        for (int i=0;i<2*n-1;i++) {\n            if (prev.count(nums[i%n])) {\n                int p=prev[nums[i%n]];\n                res[p%n]=min(res[p%n],i-p);\n                res[i%n]=min(res[i%n],i-p);\n            } \n            prev[nums[i%n]]=i;\n        }\n        for (int i=0;i<m;i++) {\n            ans[i]=(res[q[i]]==n)?-1:res[q[i]];\n        }\n        return ans;\n    }\n};","author":"Guna_C","submissionId":"1575104157"},[{"id":"167","similarity":0.7133333333333334,"totOverlap":107,"longestOverlap":28}]],"300":[{"id":"300","fileName":"1575110288.txt","sourceCode":"#include <print>\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> dis(n, INT_MAX);\n\n        unordered_map<int, int> pre;\n        for(int i=0; i<2 * n; i++) {\n            if(pre.count(nums[i % n])) {\n                int pos = pre[nums[i % n]];\n                dis[i % n] = min(dis[i % n], i - pos);\n                dis[pos % n] = min(dis[pos % n], i - pos);\n                // println(\"i:{} pos:{} nums:{}\", i, pos, nums[i % n]);\n            }\n            pre[nums[i % n]] = i;\n        }\n\n        int m = queries.size();\n        vector<int> ans(m, -1);\n        for(int i=0; i<m; i++) {\n            int q = queries[i];\n            if(dis[q] < n) {\n                ans[i] = dis[q];\n            }\n        }\n        return ans;\n    }\n};","author":"jason7708","submissionId":"1575110288"},[{"id":"397","similarity":0.7417218543046358,"totOverlap":112,"longestOverlap":16},{"id":"300","similarity":0.7133333333333334,"totOverlap":107,"longestOverlap":28}]],"397":[{"id":"397","fileName":"1575114085.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, int> mp; //{val, idx}\n        vector<int> minDist(n, INT_MAX);\n        for(int i = 0; i < 2 * n; i++){\n            int val = nums[i % n];\n            if(mp.count(val)){\n                int pre_idx = mp[val];\n                int dist = i - pre_idx;\n                if(dist < n){\n                    minDist[i % n] = min(minDist[i % n], dist);\n                    minDist[pre_idx % n] = min(minDist[pre_idx % n], dist);\n                }\n            }\n            mp[val] = i;\n        }\n        int q = queries.size();\n        vector<int> res(q, -1);\n        for(int i = 0; i < q; i++){\n            int val = queries[i];\n            if(minDist[val] != INT_MAX)\n                res[i] = minDist[val];\n        }\n        return res;\n    }\n};","author":"PeterChenX","submissionId":"1575114085"},[{"id":"300","similarity":0.7417218543046358,"totOverlap":112,"longestOverlap":16}]]},{"301":[{"id":"301","fileName":"1575110432.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        int[] arr = new int[n * 2];\n        for (int i = 0; i < nums.length; i++) {\n            arr[i] = nums[i];\n            arr[i + n] = nums[i];\n        }\n        int[][] pos = new int[2][n * 2];\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < n * 2; i++) {\n            int p = map.getOrDefault(arr[i], -n * 20);\n            pos[0][i] = p;\n            map.put(arr[i], i);\n        }\n        map.clear();\n        for (int i = n * 2 - 1; i >= 0; i--) {\n            int p = map.getOrDefault(arr[i], n * 20);\n            pos[1][i] = p;\n            map.put(arr[i], i);\n        }\n        List<Integer> list = new ArrayList<>();\n        for (int query : queries) {\n            int d1 = Math.min(query - pos[0][query], pos[1][query] - query);\n            int d2 = Math.min(query + n - pos[0][query + n], pos[1][query + n] - query - n);\n            int d = Math.min(d1, d2);\n            if (d < n) {\n                list.add(d);\n            } else {\n                list.add(-1);\n            }\n        }\n        return list;\n    }\n}","author":"cc4414","submissionId":"1575110432"},[]]},{"302":[{"id":"302","fileName":"1575110206.txt","sourceCode":"\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\ntypedef unordered_map<int,int> umi;\ntypedef unordered_map<char,int> umci;\ntypedef map<int, int> aomi;\ntypedef map<char,int> aomci;\ntypedef map<int, int, greater<int>> domi;\ntypedef unordered_set<int> usi;\ntypedef unordered_set<char> usc;\ntypedef set<int> aosi;\ntypedef set<int, greater<int>> dosi;\ntypedef unordered_multiset<int> umsi;\ntypedef multiset<int> aomsi;\ntypedef multiset<int, greater<int>> domsi;\ntypedef priority_queue<int, vector<int>, greater<int>> minHeap;\ntypedef priority_queue<int> maxHeap;\ntypedef pair<int,int> pi;\ntypedef pair<long long, int> pli;\ntypedef pair<long long, long long> pll;\n#define PB push_back\n#define PPB pop_back\n#define LB lower_bound\n#define UB upper_bound\n#define AREP(i, a)   for(auto &i: a)\n#define REP(i, a, b)    for(auto i = a; i<b; i++)\n#define REPE(i, a, b)    for(auto i = a; i<=b; i++)\n#define RREP(i, a, b)   for(auto i = a; i>=b; i--)\n#define asort(v)    sort(v.begin(), v.end());\n#define dsortvi(v)  sort(v.begin(), v.end(), greater<int>());\n\n\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int m = 2 * n;\n\n        vi vec = nums;\n        AREP(i, nums)\n            vec.PB(i);\n\n        vi minDis(n, INT_MAX);\n        umi mp;\n\n        REP(i, 0, m){\n            int val = vec[i];\n            if(mp.find(val) != mp.end()){\n                int prev = mp[val];\n                int dist = (i-prev) % n;\n                minDis[prev % n] = min(minDis[prev%n], dist);\n                minDis[i%n] = min(minDis[i%n], dist);\n            }\n            mp[val] = i;\n        }\n\n        AREP(i, queries)\n            if(minDis[i])\n                i = minDis[i];\n            else\n                i = -1;\n        return queries;\n    }\n};","author":"Yash Wairagade","submissionId":"1575110206"},[]]},{"303":[{"id":"303","fileName":"1575110319.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n = nums.size();\n        \n        vector<int>p=nums;\n        for(auto x:nums)\n            p.push_back(x);\n        for(auto x:nums)\n            p.push_back(x);\n\n        unordered_map<int,int>mp;\n        vector<int>pre(3*n,-1),suf(3*n,-1);\n        vector<int>ans(n,0);\n        for(int i=0;i<3*n;i++)\n        {\n            if(mp[nums[i%n]])\n                pre[i] = mp[nums[i%n]]-1;\n            mp[nums[i%n]]=i+1;\n        }\n        mp.clear();\n        for(int i=3*n-1;i>=0;i--)\n        {\n              if(mp[nums[i%n]])\n                suf[i] = mp[nums[i%n]]-1;\n            mp[nums[i%n]]=i+1;  \n\n            if(i>=n&&i<2*n)\n            {\n                int ind1 = pre[i];\n                int ind2 = suf[i];\n                int len = min(i-ind1,ind2-i);\n                if(len==n)\n                    ans[i-n]=-1;\n                else\n                    ans[i-n]=len;\n            }\n        }\n\n        vector<int>res;\n        for(auto x:q)\n            res.push_back(ans[x]);\n\n        return res;\n        \n    }\n};","author":"Khem Singh","submissionId":"1575110319"},[]]},{"304":[{"id":"304","fileName":"1575110695.txt","sourceCode":"class Solution {\n        int calcCircularDistance(int a, int b, int n) {\n            return min(abs(a - b), n - abs(a - b));\n        }\n    public:\n        vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n            unordered_map<int, vector<int>> pos;\n            int n = nums.size();\n            vector<int> data(n, -1);\n            for (int i = 0; i < n; i++) {\n                pos[nums[i]].push_back(i);\n            }\n            for (auto i : pos) {\n                int m = i.second.size();\n                if (m > 1) {\n                    for (int j = 0; j < m; j++) {\n                        data[i.second[j]] = min(calcCircularDistance(i.second[j], i.second[(j + 1) % m], n), \n                            calcCircularDistance(i.second[j], i.second[(j + m - 1) % m], n));\n                    }\n                }\n            }\n            vector<int> result;\n            for (int i = 0; i < queries.size(); i++) {\n                result.push_back(data[queries[i]]);\n            }\n            return result;\n          }\n    };","author":"tsigave","submissionId":"1575110695"},[{"id":"1158","similarity":0.7333333333333333,"totOverlap":121,"longestOverlap":24}]],"1158":[{"id":"1158","fileName":"1575134504.txt","sourceCode":"class Solution {\nprivate:\n    int dist(int &i, int &j, int &n){\n        return min(abs(i-j), n-abs(i-j));\n    }\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        unordered_map<int, vector<int>> mp;\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans(n, -1);\n\n        for(auto &el:mp){\n            int m=el.second.size();\n            if(m==1) continue;\n\n            for(int j=0;j<m;j++){\n                ans[el.second[j]] = min(\n                    dist(el.second[j],el.second[(j+1)%m],n),\n                    dist(el.second[j],el.second[(j+m-1)%m],n));\n            }\n        }\n        vector<int> answer;\n        for(int &el: queries){\n            answer.push_back(ans[el]);\n        }\n        return answer;\n    }\n};","author":"Pranav Todkar","submissionId":"1575134504"},[{"id":"304","similarity":0.7333333333333333,"totOverlap":121,"longestOverlap":24}]]},{"305":[{"id":"305","fileName":"1575110565.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> ans;\n        vector<int> v(nums.size(), INT_MAX);\n        int n = nums.size();\n        unordered_map<int,int> mp;\n        for(int i = 0; i < n*2; ++i){\n            int idx = i % n;\n            if(mp.count(nums[idx])){\n                v[idx] = min(v[idx], i - mp[nums[idx]]);\n                v[mp[nums[idx]] % n] = min(v[mp[nums[idx]] % n], i - mp[nums[idx]]);\n            }\n                \n            mp[nums[idx]] = i;\n        }\n        \n\n        for(auto i : queries){\n            ans.push_back(v[i] == n ? -1 : v[i]);\n        }\n        return ans;\n    }\n};","author":"a7174812","submissionId":"1575110565"},[]]},{"306":[{"id":"306","fileName":"1575110433.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        m = defaultdict(list)\n        for i, n in enumerate(nums):\n            m[n].append(i)\n\n        res = []\n        for i in queries:\n            n = nums[i]\n            if len(m[n]) == 1:\n                res.append(-1)\n            else:\n                idx = bisect_left(m[n], i)\n                l = (idx - 1) % len(m[n])\n                r = (idx + 1) % len(m[n])\n                dl = min(abs(m[n][l] - i), len(nums) - abs(m[n][l] - i))\n                dr = min(abs(m[n][r] - i), len(nums) - abs(m[n][r] - i))\n                res.append(min(dl, dr))\n\n        return res","author":"oOoOoOoOo","submissionId":"1575110433"},[]]},{"307":[{"id":"307","fileName":"1575110186.txt","sourceCode":"\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> arr;\n\n        for (int x : nums) arr.push_back(x);\n        for (int x : nums) arr.push_back(x);\n        for (int x : nums) arr.push_back(x);\n\n        unordered_map<int, int> prev;\n        unordered_map<int, int> nex;\n\n        int m = 3 * n;\n        vector<int> left(m, -1);\n        vector<int> right(m, n);\n\n        for (int i = 0; i < m; ++i) {\n            int val = arr[i];\n            if (prev.find(val) != prev.end()) {\n                left[i] = prev[val];\n            }\n            prev[val] = i;\n        }\n\n        for (int i = m - 1;i >= 0; i--) {\n            int val = arr[i];\n            if (nex.find(val) != nex.end()) {\n                right[i] = nex[val];\n            }\n            nex[val] = i;\n        }\n        int qn = queries.size();\n        vector<int> ans(qn, -1);\n\n        for (int i = 0; i < qn; ++i) {\n            int idx = queries[i] + n;\n            ans[i] = min(right[idx] - idx, idx - left[idx]);\n            if (ans[i] == n) ans[i] = -1;\n        }\n\n        return ans;\n\n    }\n};\n","author":"Ashish Singh","submissionId":"1575110186"},[{"id":"1917","similarity":0.7446808510638298,"totOverlap":175,"longestOverlap":15}]],"1917":[{"id":"1917","fileName":"611251404.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        unordered_map<int,int>info1;\n        int n = nums.size();\n        unordered_map<int,int>cnt;\n        unordered_map<int,int>info2;\n        vector<int>ans(n,n+1);\n        for(int i = n-1;i>=0;i--){\n            int val = nums[i];\n            if(info1.find(val) == info1.end()){\n                info1[val] = i-n;\n            }\n        }\n        for(int i = 0;i<n;i++){\n            int val = nums[i];\n            if(info1.find(val) != info1.end()){\n                int pos = info1[val];\n                ans[i] = min(ans[i],i-pos);\n            }\n            info1[val] = i;\n            if(info2.find(val) == info2.end()){\n                info2[val] = i+n;\n            }\n            cnt[val]++;\n        }\n        \n        for(int i = n-1;i>=0;i--){\n            int val = nums[i];\n            if(info2.find(val) != info2.end()){\n                int pos = info2[val];\n                ans[i] = min(ans[i],pos-i);\n            }\n            info2[val] = i;\n        }\n        for(int i = 0;i<n;i++){\n            if(cnt[nums[i]] == 1){\n                ans[i] = -1;\n            }\n        }\n        int m = q.size();\n        vector<int>ret(m,0);\n        for(int i = 0;i<m;i++){\n            int id = q[i];\n            ret[i] = ans[id];\n        }\n        return ret;\n    }\n};","author":"sheldon","submissionId":"611251404"},[{"id":"307","similarity":0.7446808510638298,"totOverlap":175,"longestOverlap":15}]]},{"308":[{"id":"308","fileName":"1575110652.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dic = defaultdict(list)\n        for i, num in enumerate(nums):\n            dic[num].append(i)\n        ans = []\n        # print(dic)\n        for i in queries:\n            j = bisect_left(dic[nums[i]], i)\n            # print(num, j, i)\n            if len(dic[nums[i]]) == 1:\n                ans.append(-1)\n            else:\n                n = len(dic[nums[i]])\n                k = dic[nums[i]][(j-1) % n]\n                l = dic[nums[i]][(j+1) % n]\n                # print(k, l, \"asdfas\", nums[i])\n                m = len(nums)\n                curr = min(abs(k-i), abs(l-i), abs(k+m-i), abs(l+m-i), abs(i+m-k), abs(i+m-l))\n                ans.append(curr)\n                \n        return ans\n    \n# [1,3,1,4,1,3,2]\n# [0,3,5]\n# [1,2,3,4]\n# [0,1,2,3]\n# [6,12,17,9,16,7,6]\n# [5,6,0,4]","author":"Pankaj","submissionId":"1575110652"},[]]},{"310":[{"id":"310","fileName":"1575110611.txt","sourceCode":"/********************************************\n * author : Jie Chen (4rd Year CS)\n * school : Rochester Institute of Technology\n * created: 03.15.2025 22:32:50\n*********************************************/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef BROKEN_CODE\n#include <bits/lc_parser.h>\n#include <bits/debug.h>\n#else\n#define dbg(...) 10082002\n#define dbp(...) \"Need Internship\"\n#endif\n\nusing i64 = long long;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& queries) {\n        int n = a.size();\n        unordered_map<int, vector<int>> pos;\n        for (int i = 0; i < n; i++) {\n            pos[a[i]].push_back(i);\n        }\n        \n        vector<int> res(n);\n        for (const auto& [x, g] : pos) {\n            int t = g.size();\n            if (t == 1) {\n                res[g[0]] = -1;\n            } else {\n                for (int i = 0; i < t; i++) {\n                    int ans = n;\n                    if (i == 0) {\n                        int suf = g[t - 1];\n                        ans = min(ans, n - suf + g[i]);\n                    } else {\n                        ans = min(ans, g[i] - g[i - 1]);\n                    }\n                    if (i == t - 1) {\n                        int pre = g[0];\n                        ans = min(ans, pre + (n - g[i]));\n                    } else {\n                        ans = min(ans, g[i + 1] - g[i]);\n                    }\n                    res[g[i]] = ans;\n                }\n            }\n        }\n\n        int m = queries.size();\n        vector<int> ans(m);\n        for (int i = 0; i < m; i++) {\n            ans[i] = res[queries[i]];\n        }\n\n        return ans;\n    }\n};\n\n#ifdef BROKEN_CODE\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    exec(&Solution::JustJie); // CHANGE FOR PROBLEM\n}\n#endif\n\n// ~ JustJie","author":"Jie Chen","submissionId":"1575110611"},[]]},{"311":[{"id":"311","fileName":"1575110985.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n\n        index_map = dict()\n\n        for i, num in enumerate(nums):\n            index_map[num] = index_map.get(num, []) + [i]\n\n        res = []\n\n        for q in queries:\n            curr_num = nums[q]\n            indices = index_map[curr_num]\n\n            if len(indices) == 1:\n                res.append(-1)\n                continue\n\n            # binary search q in indices\n            l = 0\n            r = len(indices) - 1\n            ind = -1\n            while l <= r:\n                mid = (l + r) // 2\n                if indices[mid] == q:\n                    ind = mid\n                    break\n                elif indices[mid] < q:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n\n            # checking for circular property\n            prev, next = float('inf'), float('inf')\n            if ind == 0:\n                prev = indices[-1]\n                next = indices[ind+1]\n\n            elif ind == len(indices) - 1:\n                prev = indices[ind-1]\n                next = indices[0]\n\n            else:\n                prev = indices[ind-1]\n                next = indices[ind+1]\n\n\n            res.append(min(abs(q - prev), len(nums) - abs(q - prev), abs(next - q), len(nums) - abs(next - q)))\n\n        return res","author":"Srinivas Boga","submissionId":"1575110985"},[]]},{"313":[{"id":"313","fileName":"1575110736.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for(int i = 0; i < n; i++) mp[nums[i]].push_back(i);\n        vector<int> a(n);\n        for(auto &p: mp){\n            auto &v = p.second;\n            for(int i = 0; i < v.size(); i++){\n                a[v[i]] = i;\n            }\n        }\n        vector<int> res(q.size());\n        for(int i = 0; i < q.size(); i++){\n            int qq = q[i], val = nums[qq];\n            auto &v = mp[val];\n            if(v.size() < 2) res[i] = -1;\n            else {\n                int x = a[qq], c = (x + 1) % v.size(), d = (x - 1 + v.size()) % v.size();\n                int d1 = abs(qq - v[c]), d2 = abs(qq - v[d]);\n                d1 = min(d1, n - d1);\n                d2 = min(d2, n - d2);\n                res[i] = min(d1, d2);\n            }\n        }\n        return res;\n    }\n};\n","author":"Ethan","submissionId":"1575110736"},[]]},{"314":[{"id":"314","fileName":"1575111087.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,set<int>> mp;\n        int n = nums.size();\n        for(int i=0;i<n;i++){\n            mp[nums[i]].insert(i);\n        }\n        vector<int> ans(queries.size());\n        for(int i=0;i<queries.size();i++){\n            int x = queries[i];\n            if(mp[nums[x]].size()==1) ans[i] = -1;\n            else {\n                auto itr = mp[nums[x]].find(x);\n                if(itr==mp[nums[x]].begin()){\n                    int v1 = *itr, v2 = *(++itr), v3 = *(mp[nums[x]].rbegin());\n                    int d1 = v2-v1;\n                    int d2 = v1-v3+n;\n                    ans[i] = min(d1,d2);\n                }\n                else if(*itr==*mp[nums[x]].rbegin()){\n                    int v1 = *itr, v3 = *(--itr), v2 = *(mp[nums[x]].begin());\n                    int d1 = v2-v1+n;\n                    int d2 = v1-v3;\n                    ans[i] = min(d1,d2);\n                }\n                else{\n                    auto it = itr;\n                    int v1 = *itr, v2 = *(++itr), v3 = *(--it);\n                    int d1 = v2-v1;\n                    int d2 = v1-v3;\n                    ans[i] = min(d1,d2);\n                }\n            }\n        }\n        return ans;\n    }\n};","author":"anurag073","submissionId":"1575111087"},[]]},{"315":[{"id":"315","fileName":"1575111278.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        # construct map from value to index\n        val_to_ind = collections.defaultdict(list)\n        for idx, v in enumerate(nums):\n            val_to_ind[v].append(idx)\n\n        # construct result\n        res = []\n        for idx in queries:\n            val = nums[idx]\n            arr = val_to_ind[val]\n            if len(arr) == 1:\n                # if only one element return -1\n                res.append(-1)\n            else:\n                # binary search to find the location in arr\n                pos = bisect.bisect_left(arr, idx)\n                # check left and right\n                dist = float('inf')\n                if pos == 0:\n                    dist = min(arr[pos+1] - idx, idx + n - arr[-1])  \n                elif pos == len(arr) - 1:\n                    dist = min(idx - arr[pos-1], arr[0] + n - idx )\n                else:\n                    dist = min(idx-arr[pos-1], arr[pos+1] - idx)\n\n                res.append(dist)\n            \n        return res\n                \n                    \n                \n        ","author":"gambler147","submissionId":"1575111278"},[]]},{"316":[{"id":"316","fileName":"1575111101.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n    \n        value_positions = defaultdict(list)\n        for i, val in enumerate(nums):\n            value_positions[val].append(i)\n\n        for val in value_positions:\n            value_positions[val].sort()\n\n        index_in_positions = [None] * n \n        \n        for val, positions in value_positions.items():\n            for pos_in_list, idx in enumerate(positions):\n                index_in_positions[idx] = pos_in_list\n        \n        def circular_dist(i, j, length):\n            diff = abs(i - j)\n            return min(diff, length - diff)\n        \n        results = []\n        \n        for q in queries:\n            val = nums[q]\n            positions = value_positions[val]\n            \n            if len(positions) < 2:\n                results.append(-1)\n                continue\n            \n            pos = index_in_positions[q]\n            pred_idx = positions[(pos - 1) % len(positions)]\n            succ_idx = positions[(pos + 1) % len(positions)]\n            dist_pred = circular_dist(q, pred_idx, n) if pred_idx != q else float('inf')\n            dist_succ = circular_dist(q, succ_idx, n) if succ_idx != q else float('inf')\n            \n            answer_q = min(dist_pred, dist_succ)\n            results.append(answer_q)\n        \n        return results","author":"Boris Chen","submissionId":"1575111101"},[]]},{"317":[{"id":"317","fileName":"1575110751.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        inds = defaultdict(list)\n        for i, val in enumerate(nums):\n            inds[val].append(i)\n        # print(inds)\n        res = []\n        for q in queries:\n            res.append(inf)\n            val = nums[q]\n            i = bisect.bisect_left(inds[val], q)\n            # print(inds[val], val, i)\n            if len(inds[val]) == 1:\n                res[-1] = -1\n                continue\n            if i > 0:\n                res[-1] = min(res[-1], inds[val][i] - inds[val][i - 1])\n            else:\n                res[-1] = min(res[-1], inds[val][i] + n - inds[val][-1])\n            if i + 1 < len(inds[val]):\n                res[-1] = min(res[-1], inds[val][i + 1] - inds[val][i])\n            else:\n                res[-1] = min(res[-1], inds[val][0] + n - inds[val][i]) \n        return res\n        ","author":"Burger Monstah","submissionId":"1575110751"},[]]},{"318":[{"id":"318","fileName":"1575111324.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> mp;\n        int n = nums.size();\n        for (int i = 0; i < n; i++)\n            mp[nums[i]].push_back(i);\n\n        vector<int> ans(n, -1);\n\n        for (auto& [k, v] : mp) {\n            if (v.size() == 1)\n                continue;\n\n            int y = v.size();\n            for (int i = 0; i < y; i++) {\n                int idx = v[i];\n                int nxt, prev;\n\n                nxt = ((i + 1 < y) ? v[i + 1] - v[i] : n - v[i] + v[0]);\n                prev = ((i > 0) ? v[i]-v[i - 1] : n - v.back() + v[0]);\n\n                ans[idx] = min(nxt, prev);\n            }\n        }\n\n        vector<int> q;\n        for (auto& x : queries)\n            q.push_back(ans[x]);\n        return q;\n    }\n};","author":"Aryan Sethi","submissionId":"1575111324"},[]]},{"319":[{"id":"319","fileName":"1575111369.txt","sourceCode":"class Solution {\n    public:\n        vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n            int n = nums.size();\n            map<int, vector<int>> inds;\n            for (int i = 0; i < n; ++i) {\n                inds[nums[i]].push_back(i);\n            }\n            vector<int> closest(n, -1);\n            for (auto [num, ind] : inds) {\n                int s = ind.size();\n                if (s == 1) {\n                    continue;\n                }\n                // for (int i : ind) cout << i << ' ';\n                // cout << 'n';\n                for (int i = 0; i < s; ++i) {\n                    int prev = ind[(i - 1 + s) % s];\n                    if (prev > ind[i]) {\n                        prev -= n;\n                    }\n                    int next = ind[(i + 1) % s];\n                    if (next < ind[i]) {\n                        next += n;\n                    }\n                    int dis = min(ind[i] - prev, next - ind[i]);\n                    closest[ind[i]] = max(closest[ind[i]], dis);\n                }\n            }\n\n            vector<int> res;\n            for (int q : queries) {\n                res.push_back(closest[q]);\n            }\n\n            return res;\n\n        }\n    };","author":"Sameer Rawat","submissionId":"1575111369"},[]]},{"320":[{"id":"320","fileName":"1575111288.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n=len(nums)\n        arr = nums+nums+nums\n        #print(arr)\n        res=[]\n        mp=defaultdict(list)\n        for i,x in enumerate(arr):\n            mp[x].append(i)\n        #print(mp)\n        for i in queries:\n            i+=n\n            x=arr[i]\n            A=mp[x]\n            idx=bisect.bisect_left(A,i)\n            # print(A)\n            # print(idx)\n            if len(A)<=3:\n                res.append(-1)\n            else:\n                t=min(abs(A[idx-1]-A[idx]), abs(A[idx+1]-A[idx]))\n                res.append(t)\n            \n        return res\n        ","author":"commallama","submissionId":"1575111288"},[]]},{"321":[{"id":"321","fileName":"1575111062.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int,pair<int,int>> mp;\n        for (int i = 0; i < n; i++) {\n            if (mp.find(nums[i]) == mp.end()) {\n                mp[nums[i]] = make_pair(i, i);\n                nums[i] = -1;\n            }\n            else {\n                int val = nums[i];\n                int init = mp[val].first;\n                int prev = mp[val].second;\n                nums[i] = min(i - prev, n - i + init);\n                if (nums[prev] == -1 || nums[prev] > i - prev)\n                    nums[prev] = i - prev;\n\n                nums[init] = min(nums[init], n - i + init);\n                mp[val].second = i;\n            }\n        }\n\n        for (int& query : queries) {\n            query = nums[query];\n        }\n\n        return queries;\n    }\n};","author":"Edward","submissionId":"1575111062"},[]]},{"322":[{"id":"322","fileName":"1575111480.txt","sourceCode":"class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer[] $queries\n     * @return Integer[]\n     */\n    function solveQueries($nums, $queries) {\n        $tmp = array_merge($nums, $nums);\n        $count = count($nums);\n        $prev = [];\n        $d = [];\n        foreach ($nums as $index => $num) {\n            $d[$index] = PHP_INT_MAX;\n        }\n        foreach ($tmp as $index => $num) {\n            if ($prev[$num] !== null && $index - $prev[$num] !== $count) {\n                $p = $prev[$num] % $count;\n                $i = $index % $count;\n                $d[$p] = min($d[$p], $index - $prev[$num]);\n                $d[$i] = min($d[$i], $index - $prev[$num]);\n            }\n            $prev[$num] = $index;\n        }\n        $ans = [];\n        foreach ($queries as $query) {\n            $ans[] = ($d[$query] === PHP_INT_MAX ? -1 : $d[$query]);\n        }\n        return $ans;\n    }\n}","author":"YWJamesLin","submissionId":"1575111480"},[]]},{"323":[{"id":"323","fileName":"1575111529.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        ans = []\n        m = defaultdict(list)\n        for i, num in enumerate(nums+nums):\n            m[num].append(i)\n\n        for q in queries:\n            if len(m[nums[q]])<=2:\n                ans.append(-1)\n            else:\n                curr = len(nums)\n                ind = bisect_left(m[nums[q]], q)\n                if ind > 0:\n                    curr = min(curr, m[nums[q]][ind]-m[nums[q]][ind-1])\n                if ind < len(m[nums[q]])-1:\n                    curr = min(curr, m[nums[q]][ind+1]-m[nums[q]][ind])\n                ind = bisect_left(m[nums[q]], q+len(nums))\n                if ind > 0:\n                    curr = min(curr, m[nums[q]][ind]-m[nums[q]][ind-1])\n                if ind < len(m[nums[q]])-1:\n                    curr = min(curr, m[nums[q]][ind+1]-m[nums[q]][ind])\n                ans.append(curr)\n        return ans\n        ","author":"Chitraksh Kumar","submissionId":"1575111529"},[]]},{"324":[{"id":"324","fileName":"1575111350.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        result = []\n        #nums = nums + nums\n        \n        m = defaultdict(list)\n        \n        for i, n in enumerate(nums):\n            m[n].append(i)\n            \n        for q in queries:\n            n = nums[q]\n            \n            if len(m[n]) == 1:\n                result.append(-1)\n            else:\n                p = bisect_left(m[n], q)\n                \n                if p > 0:\n                    a = m[n][p] - m[n][p - 1]\n                else:\n                    a = len(nums) - m[n][-1] + m[n][p]\n                    \n                if p < len(m[n]) - 1:\n                    b = m[n][p + 1] - m[n][p]\n                else:\n                    b = len(nums) - m[n][p] + m[n][0]\n                \n                result.append(min(a, b))\n                \n        return result","author":"padth","submissionId":"1575111350"},[]]},{"326":[{"id":"326","fileName":"1575111494.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = defaultdict(list)\n        l = len(nums)\n        for i, n in enumerate(nums):\n            d[n].append(i)\n            d[n].append(i-l)\n            d[n].append(i+l)\n        for it in d:\n            d[it].sort()\n        inf = float('inf')\n        ans = []\n        for q in queries:\n            n = nums[q]\n            ni = bisect.bisect_left(d[n], q)\n            cands = []\n            if ni > 0:\n                cands.append(d[n][ni-1])\n            if ni + 1 < len(d[n]):\n                cands.append(d[n][ni+1])\n            pans = inf\n            for c in cands:\n                cand = abs(c - q)\n                if cand == l:\n                    continue\n                pans = min(pans, cand)\n            if pans is inf:\n                ans.append(-1)\n            else:\n                ans.append(pans)\n        return ans","author":"Waxon Waxoff","submissionId":"1575111494"},[]]},{"327":[{"id":"327","fileName":"1575111615.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dic = defaultdict(list)\n\n        for idx, i in enumerate(nums):\n            dic[i].append(idx)\n\n        res = []\n        for idx in queries:\n            num = nums[idx]\n            idxs = dic[num]\n            if len(idxs) == 1:\n                res.append(-1)\n                continue\n            dic_idx = bisect.bisect_left(idxs, idx)\n            left, right = dic_idx - 1, (dic_idx + 1) % len(idxs)\n            left_idx, right_idx = idxs[left], idxs[right]\n            dist = inf\n            print(left_idx, right_idx)\n            if left_idx > idx:\n                dist = min(dist, len(nums) - left_idx + idx)\n            elif left_idx != idx:\n                dist = min(dist, idx - left_idx)\n            if right_idx < idx:\n                dist = min(dist, len(nums) - idx + right_idx)\n            elif right_idx != idx:\n                dist = min(dist, right_idx - idx)\n            res.append(dist)\n\n        return res","author":"Naman Gupta","submissionId":"1575111615"},[]]},{"329":[{"id":"329","fileName":"1575111741.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> m;\n        int n = nums.size();\n        vector<int> prev(n, -1), next(n, -1);\n        \n        for (int i = 0; i < n; ++i) {\n            int v = nums[i];\n\n            if (!m[v].empty()) {\n                int j = m[v].back();\n                prev[i] = j;\n                next[j] = i;\n            }\n            \n            m[v].push_back(i);\n        }\n\n        for (const auto& p : m) {\n            if (p.second.size() > 2) {\n                int i = p.second.front();\n                int j = p.second.back();\n\n                prev[i] = j;\n                next[j] = i;\n            }\n        }\n        \n        int ql = queries.size();\n        vector<int> ans(ql, -1);\n\n        for (int i = 0; i < ql; ++i) {\n            int idx = queries[i];\n            int pi = prev[idx];\n            int ni = next[idx];\n\n            int tmp = INT_MAX;\n            if (pi != -1) {\n                tmp = min(abs(idx - pi), n - abs(idx - pi));\n            }\n\n            if (ni != -1) {\n                tmp = min(tmp, abs(ni - idx));\n                tmp = min(tmp, n - abs(ni - idx));\n            }\n\n            if (tmp != INT_MAX) {\n                ans[i] = tmp;\n            }\n        }\n\n        return ans;\n    }\n};","author":"shchen527","submissionId":"1575111741"},[]]},{"333":[{"id":"333","fileName":"1575111820.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        vector<int>next(n,-1),prev(n,-1);\n        unordered_map<int,int>mp;\n        for(int i=n-1;i>=0;i--){\n            if(!mp.count(nums[i])){\n                mp[nums[i]]=i;\n            }\n        }\n        for(int i=0;i<n;i++){\n            if(mp.count(nums[i])){\n                prev[i]=mp[nums[i]];\n                if(mp[nums[i]]==i)prev[i]=-1;\n            }\n            mp[nums[i]]=i;\n        }\n        mp.clear();\n        for(int i=0;i<n;i++){\n            if(!mp.count(nums[i])){\n                mp[nums[i]]=i;\n            }\n        }\n\n        for(int i=n-1;i>=0;i--){\n            if(mp.count(nums[i])){\n                next[i]=mp[nums[i]];\n                if(mp[nums[i]]==i)next[i]=-1;\n            }\n            mp[nums[i]]=i;\n        }\n\n        // for(auto ele:prev){\n        //     cout<<ele<<\" \";\n        // }cout<<endl;\n        vector<int>ans(queries.size(),-1);\n        for(int i=0;i<queries.size();i++){\n            int index=queries[i];\n            int p=prev[index];\n            int nx=next[index];\n            int d1=INT_MAX,d2=INT_MAX;\n            if(p!=-1){\n                if(p<index){\n                    d1=index-p;\n                }\n                else{\n                    d1=index+(n-p);\n                }\n            }\n            if(nx!=-1){\n                if(index<nx){\n                    d2=nx-index;\n                }\n                else{\n                    d2=n-index+nx;\n                }\n            }\n\n            ans[i]=min(d1,d2);\n            if(ans[i]==INT_MAX)ans[i]=-1;\n        }\n\n        return ans;\n    }\n};","author":"Dhruv Verma","submissionId":"1575111820"},[]]},{"334":[{"id":"334","fileName":"1575111431.txt","sourceCode":"class Solution {\npublic:\n  vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n    unordered_map<int, vector<int>> num_to_indexes;\n    int n = nums.size();\n    for (int i = 0; i < n; ++i) {\n      num_to_indexes[nums[i]].push_back(i);\n    }\n    vector<int> res;\n    for (int q : queries) {\n      int num = nums[q];\n      if (num_to_indexes[num].size() == 1) {\n        res.push_back(-1);\n        continue;\n      }\n      vector<int>& indexes = num_to_indexes[num];\n      auto it = lower_bound(indexes.begin(), indexes.end(), q);\n      int curr = INT_MAX;\n      if (it != indexes.begin()) {\n        curr = min(curr, *it - *std::prev(it));\n      } else {\n        curr = min(curr, *it + n - indexes.back());\n      }\n      if (it != std::prev(indexes.end())) {\n        curr = min(curr, *std::next(it) - *it);\n      } else {\n        curr = min(curr, indexes.front() + n - *it);\n      }\n      res.push_back(curr);\n    }\n    return res;\n  }\n};","author":"FighterNan","submissionId":"1575111431"},[{"id":"1319","similarity":0.7011494252873564,"totOverlap":122,"longestOverlap":35}]],"1319":[{"id":"1319","fileName":"1575138820.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        int n = nums.size();\n        \n        for(int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        \n        vector<int> ans;\n        \n        for(int i : queries) {\n            int val = nums[i];\n            if(mp[val].size() == 1) {\n                ans.push_back(-1);\n            } else {\n                int minDist = n;\n                \n                auto& positions = mp[val];\n                auto it = lower_bound(positions.begin(), positions.end(), i);\n                int pos = it - positions.begin();\n                \n                if (pos > 0) {\n                    minDist = min(minDist, i - positions[pos-1]);\n                }\n                \n                if (pos + 1 < positions.size()) {\n                    minDist = min(minDist, positions[pos+1] - i);\n                }\n                \n                if (pos == 0 && positions.size() > 1) {\n                    minDist = min(minDist, n - positions.back() + i);\n                }\n                \n                if (pos == positions.size() - 1 && positions.size() > 1) {\n                    minDist = min(minDist, n - i + positions[0]);\n                }\n                \n                ans.push_back(minDist);\n            }\n        }\n        \n        return ans;\n    }\n};\n","author":"Madhav Garg","submissionId":"1575138820"},[{"id":"334","similarity":0.7011494252873564,"totOverlap":122,"longestOverlap":35}]]},{"335":[{"id":"335","fileName":"1575111884.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        md = [float('inf')] * len(nums)\n        id = dict()\n        for i in range(len(nums)):\n            if nums[i] in id:\n                md[id[nums[i]]] = min(md[id[nums[i]]], i - id[nums[i]])\n                md[i] = i - id[nums[i]]\n            id[nums[i]] = i\n        for i in range(len(nums)):\n            if id[nums[i]] != i:\n                md[i] = min(i + len(nums) - id[nums[i]], md[i])\n                md[id[nums[i]]] = min(md[id[nums[i]]], i + len(nums) - id[nums[i]])\n        l = []\n        for i in queries:\n            if md[i] == float('inf'):\n                l.append(-1)\n            else:\n                l.append(md[i])\n        return l\n            \n                \n            \n            \n        ","author":"dennis458","submissionId":"1575111884"},[]]},{"336":[{"id":"336","fileName":"1575111905.txt","sourceCode":"inf = float('inf')\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        v2p = {}\n        n = len(nums)\n        left = [-1] * n\n        for i, v in enumerate(nums):\n            if v in v2p:\n                left[i] = v2p[v]\n            v2p[v] = i\n        \n        v2p = {}\n        right = [-1] * n\n        for i in range(n-1, -1, -1):\n            v = nums[i]\n            if v in v2p:\n                right[i] = v2p[v]\n            v2p[v] = i\n        \n        v2p = {}\n        left2 = [-1] * n\n        for i, v in enumerate(nums):\n            if v in v2p:\n                left2[i] = v2p[v]\n            else:\n                v2p[v] = i\n        \n        v2p = {}\n        right2 = [-1] * n\n        for i in range(n-1, -1, -1):\n            v = nums[i]\n            if v in v2p:\n                right2[i] = v2p[v]\n            else:\n                v2p[v] = i\n        \n        # print(left)\n        # print(right)\n        res = []\n        def dist(i, j):\n            return min(abs(i-j), min(i,j)+n-max(i,j))\n        for i in queries:\n            d = inf\n            if left[i] >= 0:\n                d = min(d, dist(i, left[i]))\n            if right[i] >= 0:\n                d = min(d, dist(i, right[i]))\n            if left2[i] >= 0:\n                d = min(d, dist(i, left2[i]))\n            if right2[i] >= 0:\n                d = min(d, dist(i, right2[i]))\n            if d < inf:\n                res.append(d)\n            else:\n                res.append(-1)\n        return res\n\"\"\"\n[1,3,1,4,1,3,2]\n[0,3,5]\n[1,2,3,4]\n[0,1,2,3]\n[14,14,4,2,19,19,14,19,14]\n[2,4,8,6,3]\n\"\"\"","author":"Persephone","submissionId":"1575111905"},[]]},{"337":[{"id":"337","fileName":"1575111899.txt","sourceCode":"class Solution(object):\n    def distance(self, nums, a, b):\n        if a > b:\n            a,b = b,a\n        n = len(nums)\n        d1 = b - a\n        d2 = a+n - b\n        return min(d1,d2)\n\n    def bs(self, nums, start, end, target):\n        if start == end:\n            return start\n        if end-start == 1:\n            if nums[start] == target:\n                return start\n            return end\n\n        mid = (start+end)//2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            return self.bs(nums, start, mid-1,target)\n        return self.bs(nums,mid+1,end,target)\n    \n    def solveQueries(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        indexMap = {}\n        for i in range(0, len(nums)):\n            n = nums[i]\n            if n not in indexMap:\n                indexMap[n] = []\n            indexMap[n].append(i)\n\n        result = []\n        for query in queries:\n            n = nums[query]\n            if len(indexMap[n]) == 1:\n                result.append(-1)\n                continue\n            if len(indexMap[n]) == 2:\n                result.append(self.distance(nums, indexMap[n][0], indexMap[n][1]))\n            else:\n                index = self.bs(indexMap[n], 0, len(indexMap[n])-1, query)\n                i1 = index+1\n                if i1 >= len(indexMap[n]):\n                    i1 = 0\n                i2 = index-1\n                if i2 < 0:\n                    i2 = len(indexMap[n])-1\n                d1 = self.distance(nums, query, indexMap[n][i1])\n                d2 = self.distance(nums, query, indexMap[n][i2])\n\n                result.append(min(d1,d2))\n\n        return result","author":"jimsshom","submissionId":"1575111899"},[]]},{"338":[{"id":"338","fileName":"1575111937.txt","sourceCode":"from bisect import bisect_left\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        idx = {}\n        for i,x in enumerate(nums):\n            if idx.get(x) is None:\n                idx[x] = []\n            idx[x].append(i)\n        n = len(nums)\n        m = len(queries)\n        ans = [-1] * m \n        for i,q in enumerate(queries):\n            x = nums[q]\n            if len(idx[x]) == 1: continue \n            j = bisect_left(idx[x], q)\n            if j > 0:\n                mn = min(idx[x][j]-idx[x][j-1], n - idx[x][j]+idx[x][j-1])\n            else:\n                mn = min(idx[x][-1]-idx[x][0], n-idx[x][-1]+idx[x][0])\n                \n            if j < len(idx[x]) - 1:\n                mn = min(mn, idx[x][j+1]-idx[x][j], n - idx[x][j+1]+idx[x][j]  )\n            else:\n                mn = min(mn, idx[x][-1] - idx[x][0], n - idx[x][-1] + idx[x][0] )\n            \n            ans[i] = mn \n        return ans \n            \n            ","author":"abhishek vaish","submissionId":"1575111937"},[]]},{"339":[{"id":"339","fileName":"1575111993.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,set<int>> mp;\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]].insert(i);\n        }\n        int n=nums.size();\n        vector<int> ans;\n        for(auto i:queries){\n            auto num = nums[i];\n            auto it = mp[num].lower_bound(i);\n            if(mp[num].size()==1){\n                ans.push_back(-1);\n                continue;\n            }\n            auto itb = it;\n            itb--;\n            int val = INT_MAX;\n            if(it!=mp[num].begin()){\n                val = min(val,*it-*itb);\n            }\n            else{\n                itb = --mp[num].end();\n                val=min(val,n-*itb+*it);\n            }\n            auto itf = it;\n            itf++;\n            if(itf==mp[num].end()){\n                itf=mp[num].begin();\n                val = min(val,n-*it+*itf);\n            }\n            else{\n                val=min(val,*itf-*it);\n            }\n            ans.push_back(val);\n        }\n        return ans;\n    }\n};","author":"Avirat Joshi","submissionId":"1575111993"},[{"id":"785","similarity":0.727810650887574,"totOverlap":123,"longestOverlap":10}]],"785":[{"id":"785","fileName":"1575124999.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n      auto v = nums;\n        int n = v.size();\n        map <int, set <int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[v[i]].insert(i);\n        }\n        \n        \n        vector <int> ans;\n        for (auto x : queries) {\n            int val = nums[x];\n            auto it = mp[val].upper_bound(x);\n            if (mp[val].size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            int cs = (int)1e9;\n            if (it != mp[val].end()) {\n                cs = min(cs, *it - x);\n            }\n            else {\n                int y = *mp[val].begin();\n                cs = min(cs, n - x + y);\n            }\n            it--;\n            if (it != mp[val].begin()) {\n                it--;\n                cs = min(cs, x - *it);\n            }\n            else {\n                int y = *mp[val].rbegin();\n                cs = min(cs, x + n - y);\n            }\n            ans.push_back(cs);\n        }\n\n        return ans;\n    }\n};","author":"Ineesh","submissionId":"1575124999"},[{"id":"339","similarity":0.727810650887574,"totOverlap":123,"longestOverlap":10}]]},{"340":[{"id":"340","fileName":"1575112039.txt","sourceCode":"import bisect\n\nclass Solution:\n    def solveQueries(self, A: List[int], queries: List[int]) -> List[int]:\n        n = len(A)\n        A = A + A\n        indices = {}\n        for i in range(len(A)):\n            num = A[i]\n            if num not in indices:\n                indices[num] = []\n            indices[num].append(i)\n        \n        ans = [inf] * len(queries)\n        for i in range(len(queries)):\n            idx = queries[i]\n            if A[idx] in indices:\n                B = indices[A[idx]]\n                # print(B)\n                \n                which = bisect.bisect_left(B, idx)\n                tmp = inf\n                for j in (which - 1, which, which + 1):\n                    if 0 <= j < len(B) and idx != B[j]:\n                        tmp = min(tmp, abs(idx - B[j]))\n                ans[i] = min(ans[i], tmp)\n\n\n                which = bisect.bisect_left(B, idx + n)\n                tmp = inf\n                for j in (which - 1, which, which + 1):\n                    if 0 <= j < len(B) and idx + n != B[j]:\n                        tmp = min(tmp, abs(idx + n - B[j]))\n                ans[i] = min(ans[i], tmp)\n\n        for i in range(len(ans)):\n            if not (0 <= ans[i] < n):\n                ans[i] = -1\n        return ans\n        \n        ","author":"lydxlx","submissionId":"1575112039"},[]]},{"341":[{"id":"341","fileName":"1575112041.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define R cin>>\n#define ll long long\n#define ln cout<<'n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10fn\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}\ntemplate<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?\" \":\"\");pr(b...);}\ntemplate<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nconst ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};\ntypedef pair<ll,ll> P;\n\nclass Solution {\npublic:\n  vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n    ll n=a.size();\n    map<ll,vector<ll>> m;\n    rep(i,a.size()) m[a[i]].pb(i);\n    vector<int> ans;\n    rep(i,q.size()) {\n      ll x=a[q[i]];\n      if(m[x].size()==1) {\n        ans.pb(-1);\n        continue;\n      }\n      ll k=lower_bound(all(m[x]),q[i])-m[x].begin();\n      ll M=MAX;\n      {\n        ll y;\n        if(k) y=m[x][k-1];\n        else y=m[x].back();\n        M=min({M,abs(q[i]-y),n-q[i]+y,n-y+q[i]});\n      }\n      {\n        ll y;\n        if(k+1<m[x].size()) y=m[x][k+1];\n        else y=m[x][0];\n        M=min({M,abs(q[i]-y),n-q[i]+y,n-y+q[i]});\n      }\n      ans.pb(M);\n    }\n    return ans;\n  }\n};","author":"kzyKT","submissionId":"1575112041"},[]]},{"342":[{"id":"342","fileName":"1575112030.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> ans;\n        for(int i=0;i<n;i++) nums.push_back(nums[i]);\n        for(int i=0;i<n;i++) nums.push_back(nums[i]);\n        map<int, set<int>> mp;\n        for(int i=0;i<3*n;i++) mp[nums[i]].insert(i);\n\n        for(auto e: queries){\n            e+= n;\n            if(mp[nums[e]].size() == 3) ans.push_back(-1);\n            else{\n                auto iter = mp[nums[e]].find(e);\n                if(iter == mp[nums[e]].begin()){\n                    iter++;\n                    ans.push_back(*iter - e);\n                }\n                else{\n                    auto iter2 = iter;\n                    iter2++;\n                    iter--;\n                    int temp = min(*iter2 - e, e - *iter);\n                    ans.push_back(temp);\n                }\n            }\n        }\n\n        return ans;\n    }\n};","author":"Ayush Gupta","submissionId":"1575112030"},[]]},{"343":[{"id":"343","fileName":"1575112186.txt","sourceCode":"from collections import defaultdict\nimport bisect\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        mp = defaultdict(list)\n        n = len(nums)\n        for i in range(2):\n            k=i\n        for i, num in enumerate(nums):\n            mp[num].append(i)\n        ans = []\n        for q in queries:\n            val = nums[q]\n            ind = mp[val]\n            if len(ind) == 1:\n                ans.append(-1)\n                continue\n            pos = bisect.bisect_left(ind, q)\n            ld = float('inf')\n            rd = float('inf')\n            if pos > 0:\n                ld = q - ind[pos - 1]\n            if pos < len(ind) - 1:\n                rd = ind[pos + 1] - q\n            cl = n - abs(q - ind[-1]) if ind[-1] != q else float('inf')\n            cr = n - abs(q - ind[0]) if ind[0] != q else float('inf')\n            ans.append(min(ld, rd, cl, cr))\n        return ans\n","author":"Rahul S","submissionId":"1575112186"},[]]},{"344":[{"id":"344","fileName":"1575112189.txt","sourceCode":"use std::collections::HashMap;\n\n// fn main() {\n//     // let mut stdin = LineSource::new(BufReader::new(io::stdin()));\n//     // macro_rules! input(($($tt:tt)*) => (proconio::input!(from &mut stdin, $($tt)*)));\n// }\n\n// #[allow(dead_code)]\n// struct Solution;\n\nimpl Solution {\n    pub fn solve_queries(nums: Vec<i32>, queries: Vec<i32>) -> Vec<i32> {\n        let mut ans = vec![];\n        let mut pos = HashMap::new();\n        for (i, &num) in nums.iter().enumerate() {\n            pos.entry(num).or_insert(vec![]).push(i);\n        }\n        for i in queries {\n            let i = i as usize;\n            let ve = pos.get(&nums[i]).unwrap();\n            if ve.len() == 1 {\n                ans.push(-1);\n                continue;\n            }\n            let ve_i = ve.iter().position(|&v| v == i).unwrap();\n            let left = if ve_i == 0 {\n                *ve.last().unwrap()\n            } else {\n                ve[ve_i - 1]\n            };\n            let right = if ve_i == ve.len() - 1 {\n                *ve.first().unwrap()\n            } else {\n                ve[ve_i + 1]\n            };\n            ans.push(\n                i.abs_diff(left)\n                    .min(i.abs_diff(left + nums.len()))\n                    .min((i + nums.len()).abs_diff(left))\n                    .min(i.abs_diff(right))\n                    .min(i.abs_diff(right + nums.len()))\n                    .min((i + nums.len()).abs_diff(right)) as i32,\n            );\n        }\n        ans\n    }\n}\n","author":"nayo0513","submissionId":"1575112189"},[]]},{"346":[{"id":"346","fileName":"1575112366.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] qs) {\n        int n = nums.length;\n        int[] dist = new int[n];\n        Arrays.fill(dist, -1);\n        Map<Integer, Integer> map = new HashMap<>();\n\n        for (int i = 0; i < n; i++) {\n            if (!map.containsKey(nums[i])) {\n                map.put(nums[i], i);\n            } else {\n                int pre = map.get(nums[i]);\n                map.put(nums[i], i);\n                dist[i] = i - pre;\n                if (dist[pre] == -1) {\n                    dist[pre] = i - pre;\n                } else {\n                    dist[pre] = Math.min(dist[pre], i - pre);\n                } \n            }\n        }\n\n        map.clear();\n        int offset = n/2 + 1;\n        for (int k = 0; k < n; k++) {\n            int id = k + offset;\n            if (id >= n) id -= n;\n            \n            if (!map.containsKey(nums[id])) {\n                map.put(nums[id], id);\n            } else {\n                int pre = map.get(nums[id]);\n                map.put(nums[id], id);\n                int d = id - pre;\n                if (d < 0) d += n;\n                \n                dist[id] = Math.min(d, dist[id]);\n                dist[pre] = Math.min(dist[pre], d);\n            }\n        }\n\n        List<Integer> ans = new ArrayList<>();\n        for (int i = 0; i < qs.length; i++) {\n            ans.add(dist[qs[i]]);\n        }\n        return ans;\n    }\n\n}","author":"Yishan Chen","submissionId":"1575112366"},[]]},{"347":[{"id":"347","fileName":"1575112398.txt","sourceCode":"from bisect import bisect_left\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        ind = {}\n        for i, num in enumerate(nums):\n            if num not in ind:\n                ind[num] = []\n\n            ind[num].append(i)\n\n        ans = []\n        for q in queries:\n            a = ind[nums[q]]\n            i = bisect_left(a, q)\n            if len(a) == 1:\n                ans.append(-1)\n            elif i == len(a)-1:\n                ans.append(min(a[i]-a[i-1], len(nums)+a[0]-a[i]))\n            elif i == 0:\n                ans.append(min(a[i+1]-a[i], len(nums)+a[i]-a[-1]))\n            else:\n                ans.append(min(a[i+1]-a[i], a[i]-a[i-1]))\n            \n        return ans\n            \n        ","author":"ApoapsisAlpha","submissionId":"1575112398"},[]]},{"348":[{"id":"348","fileName":"1575112062.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> ans(queries.size(), -1);\n        unordered_map<int, vector<int>> indices;\n        int n = nums.size();\n        for(int i = 0; i < n; ++i){\n            auto itr = indices.find(nums[i]);\n            if(itr == indices.end()){\n                indices[nums[i]] = {i};\n            }else{\n                itr->second.push_back(i);\n            }\n        }\n        for(int i = 0; i < queries.size(); ++i){\n            int idx = queries[i];\n            int val = nums[idx];\n            \n            //find another j such that nums[j] == val in nums and closest to idx\n            auto &temp = indices[val];\n            if(temp.size() == 1){\n                ans[i] = -1;\n                continue;\n            }\n            // for(auto &indice:temp){\n            //     cout << indice << \" \";\n            // }\n            // cout << endl;\n            int x = lower_bound(temp.begin(), temp.end(), idx) - temp.begin();\n            //check next\n            int nextX = (x+1)%((int)temp.size());\n            int prevX = (x-1+(int)temp.size())%((int)temp.size());\n            \n            //calc distance\n            int d1 = (temp[nextX] - temp[x] + n)%n;\n            int d2 = (temp[x] - temp[prevX] + n) % n;\n            ans[i] = min(d1, d2);\n            \n        }\n    \n        return ans;\n    }\n};","author":"Arghadeep Das","submissionId":"1575112062"},[]]},{"349":[{"id":"349","fileName":"1575112425.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        q_inds = {}\n        for i, q in enumerate(queries):\n            q_inds.setdefault(q, [])\n            q_inds[q].append(i)\n\n        first = {}\n        last = {}\n        closest = {}\n        for i, num in enumerate(nums):\n            if num in first.keys():\n                j = first[num]\n                closest[i] = min(closest.get(i, float(\"inf\")), j + n - i)\n                closest[j] = min(closest.get(j, float(\"inf\")), j + n - i)\n            else: first[num] = i\n            if num in last.keys():\n                j = last[num]\n                closest[i] = min(closest.get(i, float(\"inf\")), i - j)\n                closest[j] = min(closest.get(j, float(\"inf\")), i - j)\n            last[num] = i\n\n        return [closest.get(i, -1) for i in queries]\n        \"\"\"\n        idx_lsts = {}\n        for i, num in enumerate(nums):\n            idx_lsts.setdefault(num, [])\n            idx_lsts[num].append(i)\n        \"\"\"\n        ","author":"sveng101","submissionId":"1575112425"},[]]},{"351":[{"id":"351","fileName":"1575112481.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        import collections\n        from collections import defaultdict\n        d=defaultdict(list)\n        for i,n in enumerate(nums):\n            d[n].append(i)\n            \n        res=[]\n        import bisect\n        for q in queries:\n            if len(d[ nums[q] ])==1:\n                res.append(-1)\n            else:\n                index= bisect.bisect_left(d[nums[q]], q )\n                if index>=1 and (index< len( d[nums[q]])-1):\n                    min_dis= min( d[nums[q]][index]- d[nums[q]][index-1],  d[nums[q]][index+1]- d[nums[q]][index] )\n                elif index==0:\n                    min_dis= min( d[nums[q]][index+1]- d[nums[q]][index] ,  d[nums[q]][index]+1+ len(nums)-1-  d[nums[q]][-1] )\n                elif index==len( d[nums[q]])-1:\n                    min_dis= min(d[nums[q]][index]- d[nums[q]][index-1], d[nums[q]][0]+1+ len(nums)-1- d[nums[q]][index] )\n                \n                res.append(min_dis)\n\n        return res\n            ","author":"CSris","submissionId":"1575112481"},[]]},{"352":[{"id":"352","fileName":"1575112525.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n= nums.size();\n        \n        map<int,vector<int>> mp;\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        \n        \n        map<int,int> mp2;\n        for(auto it:mp){\n            vector<int> v= it.second;\n            int n= v.size();\n            \n            for(int i=0;i<n;i++){\n                int op1= (i-1+n)%n;\n                int op2= (i+1)%n;\n                int indx= v[i];\n                \n                int d=1e9;\n                int x= nums.size();\n                if(op1!=i) d= min({d,abs(v[op1]-indx),x-abs(v[op1]-indx)});\n                if(op2!=i) d= min({d,abs(v[op2]-indx),x-abs(v[op2]-indx)});\n                // mp2[indx]= min(abs(v[op1]-indx),abs(v[op2]-indx));\n                if(d==1e9) mp2[indx]= -1;\n                else mp2[indx]= d;\n            }\n        }\n        \n        vector<int> ans;\n        for(int i=0;i<queries.size();i++){\n            int indx= queries[i];\n            \n            // if(mp2.count(indx)==0){\n            //     ans.push_back(-1);\n            // }else{\n                ans.push_back(mp2[indx]);\n            // }\n        }\n        \n        return ans;\n    }\n};","author":"shresth024","submissionId":"1575112525"},[]]},{"354":[{"id":"354","fileName":"1575112550.txt","sourceCode":"class Solution:\n    # W441 @ 1h27m : 2m task + 0m idea + 8m code + 4m tests | TOTAL = 14 min\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n\n        def calc_dist(arr):\n            result = [None] * n\n            last = {}\n            for idx in range(2 * n):\n                idx %= n\n                val = arr[idx]\n                if val in last and last[val] != idx:\n                    dist = abs(last[val] - idx)\n                    result[idx] = min(dist, n - dist)\n                last[val] = idx\n            # print(arr, result)\n            return result\n        \n        prev_dist = calc_dist(nums)\n        next_dist = calc_dist(nums[::-1])[::-1]\n\n        result = []\n        for q in queries:\n            prev, next = prev_dist[q], next_dist[q]\n            if prev != None:\n                min_dist = min(prev, next)\n                result.append(min_dist)\n            else:\n                result.append(-1)\n        return result\n\n\"\"\"Ideas:\n\"\"\"\n","author":"sergey_chebotarev","submissionId":"1575112550"},[]]},{"355":[{"id":"355","fileName":"1575112516.txt","sourceCode":"from bisect import bisect_left\nfrom typing import List\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        pos = {}\n        for i, v in enumerate(nums):pos.setdefault(v, []).append(i)\n        for v in pos:pos[v].sort()\n        def circular_dist(a, b):\n            dif = abs(a - b)\n            return min(dif, n - dif)\n        def find_closest(inds, q):\n            if len(inds) == 1 and inds[0] == q:return -1\n            ids = bisect_left(inds, q)\n            def get_right_candidate(start):\n                for o_s in range(len(inds)):\n                    c_d = inds[(start + o_s) % len(inds)]\n                    if c_d != q:return c_d\n                return None \n            def get_left_candidate(start):\n                for o_s in range(len(inds)):\n                    c_d = inds[(start - o_s) % len(inds)]\n                    if c_d != q:return c_d\n                return None\n            rcan,lcan,cand = get_right_candidate(ids),get_left_candidate(ids - 1),[]\n            if rcan is not None:cand.append(rcan)\n            if lcan is not None:cand.append(lcan)\n            if not cand:return -1\n            return min(circular_dist(q, c) for c in cand)\n        ans = []\n        for q in queries:\n            v = nums[q]\n            ans.append(find_closest(pos[v], q))\n        return ans","author":"cosmic-striker","submissionId":"1575112516"},[]]},{"357":[{"id":"357","fileName":"1575112583.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n\n        int mx = 1e6 + 1, N = nums.size();\n        for(int i = 0; i<N; i++){\n            nums.push_back(nums[i]);\n        }\n\n        N *= 2;\n        vector<int> mp(mx, -1), prefix(N, -1), suffix(N, -1);\n\n        for(int i =0; i<N; i++){\n            prefix[i] = mp[nums[i]];\n            mp[nums[i]] = i;\n        }\n\n        vector<int> mp2(mx, -1);\n        \n        for(int i =N-1; i>= 0; i--){\n            suffix[i] = mp2[nums[i]];\n            mp2[nums[i]] = i;\n        }\n\n        vector<int> ans;\n        for(int i : queries){\n            int poss1 = prefix[i+N/2] == -1 ? -1 : i+N/2 - prefix[i+N/2];\n            int poss2 = suffix[i] == -1 ? -1 : suffix[i] - i;\n\n            poss1 = poss1 == N / 2 ? -1 : poss1;\n            poss2 = poss2 == N/2 ? -1 : poss2;\n\n            if(poss1 == -1 && poss2 == -1) ans.push_back(-1);\n            else if(poss1 ==-1) ans.push_back(poss2);\n            else if(poss2 == -1) ans.push_back(poss1);\n            else ans.push_back(min(poss1, poss2));\n        }\n        \n        return ans;\n    }\n};","author":"Pravinkumar S","submissionId":"1575112583"},[]]},{"360":[{"id":"360","fileName":"1575112699.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        idxes = {}\n        for i, n in enumerate(nums):\n            if n not in idxes:\n                idxes[n] = []\n            idxes[n].append(i)\n\n        # print(idxes)\n        def execQuery(i):\n            if nums[i] not in idxes or len(idxes[nums[i]]) == 1:\n                return -1\n            tgtIdxes = idxes[nums[i]]\n            lo, hi = 0, len(tgtIdxes)-1\n            while lo < hi:\n                mid = (lo + hi) // 2\n                if tgtIdxes[mid] >= i:\n                    hi = mid\n                else:\n                    lo = mid + 1\n\n            ldist, rdist = None, None\n            if lo == 0:\n                ldist = tgtIdxes[0] + len(nums) - tgtIdxes[-1]\n            else:\n                ldist = tgtIdxes[lo] - tgtIdxes[lo-1]\n\n            if lo == len(tgtIdxes)-1:\n                rdist = tgtIdxes[0] + len(nums) - tgtIdxes[-1]\n            else:\n                rdist = tgtIdxes[lo+1] - tgtIdxes[lo]\n\n            # print(i, nums[i], lo, ldist, rdist)\n            return min(ldist, rdist)\n\n        return [execQuery(q) for q in queries]\n            ","author":"Andrew Lo Zhi Sheng","submissionId":"1575112699"},[]]},{"362":[{"id":"362","fileName":"1575112706.txt","sourceCode":"from bisect import bisect_left as bsl\ndef fd(i,j,n):\n    return abs(j-i)\ndef bd(i,j,n):\n    i,j=min(i,j),max(i,j)\n    return (n-j)+i\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d={}\n        for i in nums:\n            d[i]=[]\n        for i in range(len(nums)):\n            d[nums[i]].append(i)\n        n=len(nums)\n        ans=[-1]*len(queries)\n        for j in range(len(queries)):\n            i=queries[j]\n            if len(d[nums[i]])>1:\n                ind=bsl(d[nums[i]],i)\n                pre=d[nums[i]][ind-1]\n                suf=d[nums[i]][(ind+1)%len(d[nums[i]])]\n                a=float('inf')\n                #print(ind,pre,suf,fd(ind,pre,n),fd(ind,suf,n),bd(ind,pre,n),bd(ind,suf,n))\n                a=min(fd(i,pre,n),fd(i,suf,n),bd(i,pre,n),bd(i,suf,n))\n                ans[j]=a\n        return ans\n                \n\n                \n            ","author":"vek0r","submissionId":"1575112706"},[]]},{"363":[{"id":"363","fileName":"1575112723.txt","sourceCode":"class Solution {\npublic:\nvector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n    vector<int> res;\n    unordered_map<int, vector<int>> m;\n    for (int i = 0; i < nums.size(); ++i) {\n        m[nums[i]].push_back(i);\n    }\n    int sz = nums.size();\n    for (int i : queries) {\n        int dist = INT_MAX;\n        auto &ids = m[nums[i]];\n        auto it = lower_bound(begin(ids), end(ids), i);\n        if (it != begin(ids)) {\n            int j = *prev(it);\n            dist = min(i - j, sz + j - i); \n        }\n        else {\n            int j = *rbegin(ids);\n            if (j != i) \n                dist = min({dist, sz + i - j});            \n        }\n        if (next(it) != end(ids)) {\n            int j = *next(it);\n            dist = min({dist, j - i, sz + i - j});             \n        }\n        else {\n            int j = *begin(ids);\n            if (j != i) \n                dist = min({dist, sz + j - i});\n        }\n        res.push_back(dist == INT_MAX ? -1 : dist);\n    }\n    return res;\n}\n};","author":"Vlad","submissionId":"1575112723"},[]]},{"364":[{"id":"364","fileName":"1575112805.txt","sourceCode":"class Solution\n{\n    public List<Integer> solveQueries(int[] as, int[] idxes)\n    {\n        List<Integer> res = new ArrayList<>();\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < as.length; i++)\n        {\n            int a = as[i];\n            map.putIfAbsent(a, new ArrayList<>());\n            map.get(a).add(i);\n        }\n        Map<Integer, Integer> map2 = new HashMap<>();\n        for (List<Integer> list : map.values())\n        {\n            if (list.size() == 1)\n            {\n                map2.put(list.get(0), -1);\n                continue;\n            }\n            for (int i = 0; i < list.size(); i++)\n            {\n                int currIdx = list.get(i);\n                if (i == 0)\n                {\n                    int prevIdx = list.getLast();\n                    int nextIdx = list.get(i + 1);\n                    int dist = Math.min(nextIdx - currIdx, as.length - 1 - prevIdx + currIdx + 1);\n                    map2.put(currIdx, dist);\n                }\n                else if (i == list.size() - 1)\n                {\n                    int prevIdx = list.get(i - 1);\n                    int nextIdx = list.getFirst();\n                    int dist = Math.min(currIdx - prevIdx, as.length - 1 - currIdx + nextIdx + 1);\n                    map2.put(currIdx, dist);\n                }\n                else\n                {\n                    int prevIdx = list.get(i - 1);\n                    int nextIdx = list.get(i + 1);\n                    int dist = Math.min(currIdx - prevIdx, nextIdx - currIdx);\n                    map2.put(currIdx, dist);\n                }\n            }\n        }\n        for (int idx : idxes)\n        {\n            int dist = map2.get(idx);\n            res.add(dist);\n        }\n        return res;\n    }\n}","author":"LeetCoding_Pro","submissionId":"1575112805"},[]]},{"366":[{"id":"366","fileName":"1575112850.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        const int l = nums.size();\n        unordered_map<int, vector<int>> ind;\n\n        for (int i = 0; i < l; i++) {\n            int v = nums[i];\n            ind[v].push_back(i);\n        }\n\n        vector<int> r;\n        for (int q : queries) {\n            int v = nums[q];\n            auto& vec = ind[v];\n            if (vec.size() == 1) {\n                r.push_back(-1);\n                continue;\n            }\n            auto it = lower_bound(vec.begin(), vec.end(), q);\n            int md = INT_MAX;\n            if (it != vec.begin()) {\n                md = min(md, q - *(it - 1));\n            } else {\n                int id = *(vec.end() - 1);\n                md = min(md, l -id + q);\n                cout <<\"X\";\n            }\n            it++;\n            if (it != vec.end()) {\n                md = min(md, *it - q);\n            } else {\n                int id = *(vec.begin());\n                md = min(md, l - q + id);\n                cout <<\"Y\";\n            }\n            r.push_back(md);\n        }\n        return r;\n    }\n};","author":"oserres","submissionId":"1575112850"},[]]},{"368":[{"id":"368","fileName":"1575112872.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& v, vector<int>& q) \n    {\n        int n=v.size();\n        unordered_map<int,vector<int> >mp;\n        for(int i=0;i<n;i++)\n        {\n            mp[v[i]].push_back(i);\n        }\n        vector<int>ans;\n        \n        for(int i=0;i<q.size();i++)\n        {\n            int a=v[q[i]];\n            // vector<int>mp[a]=mp[a];\n            int m=mp[a].size();\n            auto ind=(lower_bound(mp[a].begin(),mp[a].end(),q[i])-mp[a].begin());\n            int lw=ind-1,up=((ind+1)%m);\n            lw+=m;\n            lw%=m;\n            int L=mp[a][lw],R=mp[a][up],C=mp[a][ind];\n            int tans=n+10;\n            if(L!=C)\n            {\n                if(L<C)\n                    tans=min(tans,min(C-L,n-C+L));\n                else\n                    tans=min(tans,min(L-C,n-L+C));\n            }\n            if(R!=C)\n            {\n                if(R<C)\n                    tans=min(tans,min(C-R,n-C+R));\n                else\n                    tans=min(tans,min(R-C,n-R+C));\n            }\n            if(tans<=n)\n            ans.push_back(tans);\n            else\n                ans.push_back(-1);\n        }\n        return ans;\n    }\n};","author":"Neelabh Rana","submissionId":"1575112872"},[]]},{"369":[{"id":"369","fileName":"1575112930.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        ret = []\n        d = defaultdict(list)\n        for i,v in enumerate(nums):\n            d[v].append(i)\n        for q in queries:\n            arr = d[nums[q]]\n            # print(nums[q], arr)\n            sz = len(arr)\n            if sz == 1:\n                ret.append(-1)\n            else:\n                idx = bisect.bisect_left(arr, q)\n                if idx == 0:\n                    first = arr[idx] + n - arr[(idx - 1)%sz]\n                else:  \n                    first = abs(arr[(idx-1)%sz] - arr[idx])\n                if idx == sz - 1:\n                    second = n - arr[idx] + arr[(idx + 1)%sz]\n                else:\n                    second = abs(arr[(idx+1) % sz] - arr[idx])\n                ret.append(min(first, second))\n        return ret\n                ","author":"Krishnakumar R","submissionId":"1575112930"},[]]},{"372":[{"id":"372","fileName":"1575113087.txt","sourceCode":"class Solution {\npublic:\n    int D[1000006], D2[1000006], ans[1000006];\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        for(int i=0; i<n; i++) nums.push_back(nums[i]);\n        for(int i=0; i<n; i++) ans[i]=1000000000;\n        for(int i=0; i<nums.size(); i++){\n            if(D[nums[i]]==0){ \n                D[nums[i]] = i + 1;\n                ans[(i>=n?i-n:i)] = 1000000000;\n                continue;\n            }\n            ans[(i>=n?i-n:i)] = min({ans[(i>=n?i-n:i)], (i+1) - D[nums[i]]});\n            D[nums[i]] = i + 1;\n        }\n        for(int i=nums.size()-1; i>=0; i--){\n            if(D2[nums[i]]==0){ \n                D2[nums[i]] = i + 1;\n                continue;\n            }\n            ans[(i>=n?i-n:i)] = min({ans[(i>=n?i-n:i)], -(i+1) + D2[nums[i]]});\n            D2[nums[i]] = i + 1;\n        }\n       \n        vector<int> luu;\n        for(int v: queries){\n            if(ans[v] >=n) luu.push_back(-1);\n            else luu.push_back(ans[v]);\n        }\n        return luu;\n    }\n};","author":"Huy Phước","submissionId":"1575113087"},[]]},{"373":[{"id":"373","fileName":"1575112763.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = {}\n        for i,x in enumerate(nums):\n            if x in d:\n                d[x].append(i)\n            else:\n                d[x] = [i]\n        ans = []\n        for i in queries:\n            q = nums[i]\n            tmp = -1\n            if q in d and len(d[q]) > 1:\n                x = bisect_left(d[q],i)\n                if x == len(d[q])-1:\n                    a = d[q][x-1]\n                    b = d[q][0]\n                else:\n                    a = d[q][x-1]\n                    b = d[q][x+1]\n                tmp = min(abs(i-a),abs(i-b),len(nums)-abs(i-a),len(nums)-abs(i-b))\n            ans.append(tmp)\n        return ans","author":"Carisa-Li","submissionId":"1575112763"},[]]},{"374":[{"id":"374","fileName":"1575113007.txt","sourceCode":"typedef vector<int> vi;\n\nclass Solution {\npublic:\n    void setNext(vi &a, vi &nxt) {\n        int n = a.size();\n        nxt.resize(n);\n        unordered_map<int,int> m;\n        for (int i = 0; i < n; i++) {\n            int x = a[i];\n            m[x] = i - n;\n        }\n        for (int i = 0; i < n; i++) {\n            int v = a[i];\n            int x = m[v];\n            nxt[i] = i - x;\n            if (nxt[i] == n) nxt[i] = -1;\n            m[v] = i;\n        }\n    }\n    vector<int> solveQueries(vector<int>& a, vector<int>& queries) {\n        vi nxt, prev;\n        setNext(a, nxt);\n        reverse(a.begin(), a.end());\n        setNext(a, prev);\n        reverse(a.begin(), a.end());\n        reverse(prev.begin(), prev.end());\n        vector<int> ret;\n        for (auto &q: queries) {\n            ret.push_back(min(nxt[q], prev[q]));\n        }\n        return ret;\n    }\n};","author":"Adi","submissionId":"1575113007"},[]]},{"375":[{"id":"375","fileName":"1575113069.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> l(nums.size(), 1e9);\n        vector<int> r(nums.size(), 1e9);\n        unordered_map<int, int> hm;\n        int n = nums.size();\n        for (int i=0; i<nums.size(); i++) {\n            if (hm[nums[i]] && hm[nums[i]] > i+1-n)\n                l[i%n] = min(l[i%n], i+1 - hm[nums[i]]);\n\n            if (i<n)\n                nums.push_back(nums[i]);\n\n            hm[nums[i]] = i+1;\n        }\n\n        hm.clear();\n        for (int i=nums.size()-1; i>=0; i--) {\n            if (hm[nums[i]] && hm[nums[i]] <= i+n)\n                r[i%n] = min(r[i%n], hm[nums[i]] - (i+1));\n\n            hm[nums[i]] = i+1;\n        }\n\n        vector<int> ans(queries.size());\n        for (int i=0; i<queries.size(); i++) {\n            ans[i] = min(l[queries[i]], r[queries[i]]);\n            if (ans[i]==1e9)\n                ans[i] = -1;\n        }\n\n        return ans;\n\n        \n    }\n};","author":"Arcan3","submissionId":"1575113069"},[]]},{"376":[{"id":"376","fileName":"1575113308.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, TreeSet<Integer>> val2Indexes = new HashMap<>();\n        int m = nums.length;\n        for (int i = 0; i < m; i++) {\n            val2Indexes.putIfAbsent(nums[i], new TreeSet<>());\n            val2Indexes.get(nums[i]).add(i);\n            val2Indexes.get(nums[i]).add(i + m);\n        }\n        \n        int n = queries.length;\n        List<Integer> res = new ArrayList<>();\n        for (int q : queries) {\n            int v = nums[q];\n            \n            TreeSet<Integer> indexes = val2Indexes.get(v);\n            if (indexes == null || indexes.size() == 2) {\n                res.add(-1);\n                continue;\n            }\n            \n            \n            Integer l1 = indexes.lower(q);\n            int dis1 = l1 == null ? Integer.MAX_VALUE : q - l1;\n            int dis = dis1;\n            \n            Integer h1 = indexes.higher(q);\n            int dis2 = h1 == null ? Integer.MAX_VALUE : h1 - q; \n            dis = Math.min(dis, dis2);\n            \n            Integer l2 = indexes.lower(q + m);\n            int dis3 = l2 == null ? Integer.MAX_VALUE : q + m - l2;\n            dis = Math.min(dis, dis3);\n            \n            Integer h2 = indexes.higher(q + m);\n            int dis4 = h2 == null ? Integer.MAX_VALUE : h2 - q - m; \n            dis = Math.min(dis, dis4);\n            \n            res.add(dis);\n        }\n        return res;\n    }\n}","author":"googlehsiehhh","submissionId":"1575113308"},[]]},{"378":[{"id":"378","fileName":"1575113277.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, int> last, vis, prevl, prevr, firstl, firstr;\n        int n=nums.size();\n        for(int i=0; i<n; i++){\n            firstl[nums[i]]=-1;\n            firstr[nums[i]]=-1;\n        }\n        \n        for(int i=0; i<n; i++){\n            if(vis[nums[i]]){\n                prevl[i]=last[nums[i]];\n            }\n            else{\n                firstl[nums[i]]=i;\n                prevl[i]=-1;\n            }\n            vis[nums[i]]=1;\n            last[nums[i]]=i;\n        }\n\n        vis.clear();\n        last.clear();\n        for(int i=n-1; i>=0; i--){\n            if(vis[nums[i]]){\n                prevr[i]=last[nums[i]];\n            }\n            else{\n                firstr[nums[i]]=i;\n                prevr[i]=-1;\n            }\n            vis[nums[i]]=1;\n            last[nums[i]]=i;\n        }\n\n        // for(int i=0; i<n; i++){\n        //     cout << firstl[nums[i]] << \" \";\n        // }cout << \"n\";\n\n        vector<int> ret;\n        for(int i: queries){\n            int ans=1e9;\n            if(prevr[i]==-1 && prevl[i]==-1){\n                ret.push_back(-1);\n                continue;\n            }\n\n            if(prevl[i]!=-1){\n                ans=min(ans, i-prevl[i]);\n            }\n            else{\n                ans=min(ans, n-firstr[nums[i]]+i);\n            }\n            if(prevr[i]!=-1){\n                ans=min(ans, prevr[i]-i);\n            }\n            else{\n                ans=min(ans, n-i+firstl[nums[i]]);\n            }\n            ret.push_back(ans);\n\n\n        }\n        return ret;\n    }\n};","author":"coldspeed","submissionId":"1575113277"},[]]},{"379":[{"id":"379","fileName":"1575113314.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: list[int], queries: list[int]) -> list[int]:\n        indexList = []\n        d = defaultdict(list)\n        for i in range(len(nums)):\n            d[nums[i]].append(i)\n            indexList.append(len(d[nums[i]])-1)\n        result = []\n        for i in queries:\n            cur = nums[i]\n            if cur not in d or len(d[cur]) == 1:\n                result.append(-1)\n            else:\n                curIndex = indexList[i]\n                if curIndex == 0:\n                    lessVal = len(nums)-d[cur][-1]+d[cur][0]\n                else:\n                    lessVal = d[cur][curIndex]-d[cur][curIndex-1]\n                if curIndex == len(d[cur])-1:\n                    moreVal = len(nums)-d[cur][-1]+d[cur][0]\n                else:\n                    moreVal = d[cur][curIndex+1]-d[cur][curIndex]\n                result.append(lessVal if lessVal < moreVal else moreVal)\n        return result","author":"Noah Schenk","submissionId":"1575113314"},[]]},{"380":[{"id":"380","fileName":"1575113332.txt","sourceCode":"class Solution {\npublic:\n    int mod(int n, int p) {\n        return (n % p + p) % p;\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for(int i=0;i<nums.size();i++) {\n            mp[nums[i]].push_back(i);\n        }\n        \n        vector<int> ans(queries.size());\n        for(int i=0;i<queries.size();i++) {\n            int query = queries[i];\n            int val = nums[query];\n            int size = mp[val].size();\n            if(size == 1) {\n                ans[i] = -1;\n                continue;\n            }\n            int index = lower_bound(mp[val].begin(), mp[val].end(), query) - mp[val].begin();\n            int smallerInd = mp[val][mod(index-1, size)];\n            int biggerInd = mp[val][mod(index+1, size)];\n            ans[i] = min({abs(query - smallerInd), abs(biggerInd - query), abs(query + n - smallerInd), abs(biggerInd + n - query)});\n        }\n        return ans;\n    } \n};","author":"Aviral Agrawal","submissionId":"1575113332"},[]]},{"381":[{"id":"381","fileName":"1575113287.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        map<int, vector<int>> adj;\n        for (int i = 0; i < n; i++) {\n            adj[nums[i]].push_back(i);\n        }\n        \n        vector<int> answer;\n        for (auto idx : queries) {\n            int val = nums[idx];\n            if (adj[val].size() == 1) {\n                answer.push_back(-1);\n            } else {\n                auto& p = adj[val];\n                auto it = lower_bound(p.begin(), p.end(), idx);\n                \n                int prev_idx = (it == p.begin()) ? p.back() : *prev(it);\n                int next_idx = (it == p.end() - 1) ? p.front() : *next(it);\n                \n                int dist1 = (idx - prev_idx + n) % n;\n                int dist2 = (next_idx - idx + n) % n;\n\n                answer.push_back(min(dist1, dist2));\n            }\n        }\n        return answer;\n    }\n};","author":"Pankaj Ananda Bhosale","submissionId":"1575113287"},[]]},{"382":[{"id":"382","fileName":"1575113511.txt","sourceCode":"class Solution {\npublic:\n    int findSmallerIdx(vector<int>& nums, int target) {\n        int left = 0, right = nums.size() - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            if (nums[mid] >= target) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        if (left == 0) {\n            return -1;\n        } else {\n            return nums[left - 1];\n        }\n    }\n\n   int findBiggerIdx(vector<int>& nums, int target) {\n        int left = 0, right = nums.size() - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            if (nums[mid] <= target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        if (right == nums.size() - 1) {\n            return -1;\n        } else {\n            return nums[right + 1];\n        }\n    }\n\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> numMap;\n        for (int i = 0; i < nums.size(); i++) {\n            numMap[nums[i]].push_back(i);\n        }\n\n        int n = nums.size();\n        vector<int> res;\n        for (int i = 0; i < queries.size(); i++) {\n            int idx = queries[i];\n            int smallerIdx = findSmallerIdx(numMap[nums[idx]], idx);\n            int biggerIdx = findBiggerIdx(numMap[nums[idx]], idx);\n\n            // if (idx == 8) {\n            //     cout << \"smallerIdx:\" << smallerIdx << \" biggerIdx:\" << biggerIdx << endl;\n            // }\n\n            if (smallerIdx == -1 && biggerIdx == -1) {\n                res.push_back(-1);\n            } else if (smallerIdx == -1) {\n                res.push_back(min(biggerIdx - idx, idx + n - numMap[nums[idx]].back()));\n            } else if (biggerIdx == -1) {\n                res.push_back(min(idx - smallerIdx, numMap[nums[idx]][0] + n - idx));\n            } else {\n                int idxDiff = min(idx - smallerIdx, biggerIdx - idx);\n                idxDiff = min(idxDiff, idx + n - biggerIdx);\n                idxDiff = min(idxDiff, smallerIdx + n - idx);\n                res.push_back(idxDiff);\n            }\n        }\n\n        return res;\n    }\n};","author":"NTU_Anonymous","submissionId":"1575113511"},[]]},{"383":[{"id":"383","fileName":"1575113588.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        pos = defaultdict(list)\n        for i in range(len(nums)):\n            pos[nums[i]].append(i)\n        ans = [-1] * len(nums)\n        for n, p in pos.items():\n            if len(p) < 2: continue\n            for i in range(len(p)-1):\n                d = p[i+1] - p[i]\n                ans[p[i]] = d if ans[p[i]] < 0 else min(d, ans[p[i]])\n                ans[p[i+1]] = d if ans[p[i+1]] < 0 else min(d, ans[p[i+1]])\n            d = len(nums) - p[-1] + p[0]\n            ans[p[0]] = min(ans[p[0]], d)\n            ans[p[-1]] = min(ans[p[-1]], d)\n        return [ans[q] for q in queries]","author":"r09922a12","submissionId":"1575113588"},[]]},{"384":[{"id":"384","fileName":"1575113665.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& vv, vector<int>& queries) {\n        vector<int>v(vv.begin(),vv.end());\n        int n=vv.size();\n        for(auto i:vv)v.push_back(i);\n        map<int,int>l,r;\n        vector<int>lv(2*n),rv(2*n);\n        for(int i=0;i<2*n;i++){\n            if(l.find(v[i])==l.end()|| l[v[i]]==i-n){\n                lv[i]=-1;\n            }\n            else lv[i]=l[v[i]];\n            l[v[i]]=i;\n            \n        }\n        for(int i=2*n-1;i>=0;i--){\n            if(r.find(v[i])==r.end() || r[v[i]]==i+n){\n                rv[i]=-1;\n            }\n            else rv[i]=r[v[i]];\n            r[v[i]]=i;\n            \n        }\n        vector<int>ans;\n        for(auto i:queries){\n            if(rv[i]==-1){ans.push_back(-1);continue;}\n            \n            int t=min(rv[i]-i,i+n-lv[i+n]);\n            ans.push_back(t);\n        }\n        return ans;\n        \n    }\n};","author":"LevelUp","submissionId":"1575113665"},[]]},{"385":[{"id":"385","fileName":"1575113600.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int, vector<int>> mp;\n        for(int i=0; i<n; i++){\n            mp[nums[i]].push_back(i);\n        }\n        for(auto &x:mp){\n            if(x.second.size()>1){\n                x.second.push_back(-(n-x.second.back()));\n                x.second.push_back(n+x.second[0]);\n            }\n            sort(x.second.begin(), x.second.end());\n        }\n        vector<int> ans;\n        for(auto &q:queries){\n            int val = nums[q];\n            if(mp[val].size() < 2){\n                ans.push_back(-1);\n            }else{\n                int ind = lower_bound(mp[val].begin(), mp[val].end(), q)-mp[val].begin();\n                int x = 1e9;\n                if(ind != 0) x = min(x, abs(mp[val][ind-1]-q));\n                if(ind != mp[val].size()-1) x = min(x, mp[val][ind+1]-q);\n                ans.push_back(x);\n            }\n        }\n        return ans;\n    }\n};","author":"Shashi Raj","submissionId":"1575113600"},[]]},{"386":[{"id":"386","fileName":"1575113543.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> v = nums;\n        for(int i = 0; i < n; ++i)\n            {\n                v.push_back(v[i]);\n            }\n\n        vector<int> ans(n, 1e9);\n        unordered_map<int, int> mp;\n        for(int i = 0; i < 2*n-1; ++i)\n            {\n                \n                int a = v[i];\n                if(mp.count(a)>0)\n                {\n                    if(i >= n)\n                    {\n                        ans[i-n] = min(ans[i-n], i-mp[a]);\n                    }\n                    else\n                    ans[i] = min(ans[i], i-mp[a]);\n                }\n                mp[v[i]] = i;\n\n                \n            }\n        mp.clear();\n\n         for(int i = 2*n-1; i >= 0; --i)\n            {\n                \n                int a = v[i];\n                if(mp.count(a)>0)\n                {\n                    if(i < n)\n                    ans[i] = min(ans[i], mp[a]-i);\n                }\n                mp[v[i]] = i;\n\n                \n            }\n        int m = queries.size();\n        vector<int> an(m, 1e9);\n        for(int i = 0; i < m; ++i)\n            {\n                int a = queries[i];\n                an[i] = ans[a];\n                if(an[i] == n)\n                    an[i] = -1;\n            }\n\n        return an;\n    }\n};","author":"Neerav","submissionId":"1575113543"},[{"id":"1212","similarity":0.7045454545454546,"totOverlap":155,"longestOverlap":11}]],"1212":[{"id":"1212","fileName":"1575136032.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<int> ans(m, -1);\n        vector<int> tmp(n, -1);\n        \n        unordered_map<int, int> prev;\n        \n        for (int i = 2*n-1; i >= 0; i--) {\n            int a = nums[i%n];\n\n            \n            if (prev.find(a)!= prev.end()) {\n                if (tmp[i%n] == -1) \n                    tmp[i%n] = prev[a] - i;\n                else\n                    tmp[i%n] = min(tmp[i%n], prev[a] - i);\n            }\n            \n            prev[a] = i;\n        }\n        \n        //     for (auto x : tmp) {\n        //     cout << x << \" \";\n        // } cout << endl;\n        \n        prev.clear();\n        for (int i = 0; i < 2*n; i++) {\n            int a = nums[i%n];\n            \n            if (prev.find(a)!= prev.end()) {\n                if (tmp[i%n] == -1) \n                    tmp[i%n] = i - prev[a];\n                else\n                    tmp[i%n] = min(tmp[i%n], i - prev[a]);\n            }\n            \n            prev[a] = i;\n        }\n        \n        // for (auto x : tmp) {\n        //     cout << x << \" \";\n        // } cout << endl;\n        \n        for (int i = 0; i < m; i++) {\n            if (tmp[queries[i]] == n)\n                continue;\n            ans[i] = tmp[queries[i]];\n        }\n        \n        return ans;\n    }\n};","author":"huzy","submissionId":"1575136032"},[{"id":"386","similarity":0.7045454545454546,"totOverlap":155,"longestOverlap":11}]]},{"387":[{"id":"387","fileName":"1575113480.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, set<int>> vals;\n        int n = nums.size();\n        for (int i=0; i<n; i++) {\n            vals[nums[i]].insert(i);\n        }\n        vector<int> ans;\n        for (auto q: queries) {\n            int val = nums[q];\n            if (vals[val].size() <= 1) {\n                ans.push_back(-1);\n            } else {\n                auto it1 = vals[val].upper_bound(q);\n                if (it1 == vals[val].end()) it1 = vals[val].begin();\n                auto it2 = vals[val].lower_bound(q);\n                if (it2 != vals[val].begin()) {\n                    it2 = prev(it2);\n                } else {\n                    it2 = prev(vals[val].end());\n                }\n                int ind1 = *it1;\n                int ind2 = *it2;\n                // cout << ind1 << \", \" << ind2 << endl;\n                int dist = min(abs(q - ind1), abs(q - ind2));\n                dist = min(dist, (ind1 - q + n) % n);\n                dist = min(dist, (q - ind1 + n) % n);\n                dist = min(dist, (ind2 - q + n) % n);\n                dist = min(dist, (q - ind2 + n) % n);\n                ans.push_back(dist);\n            }\n        }\n        return ans;\n    }\n};","author":"Nagender","submissionId":"1575113480"},[]]},{"388":[{"id":"388","fileName":"1575113840.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        locations = defaultdict(list)\n        n = len(nums)\n        memo = [-1] * n\n        for i, num in enumerate(nums):\n            locations[num].append(i)\n        for num, location in locations.items():\n            k = len(location)\n            if k < 2: continue\n            for i in range(k):\n                dist_left = min(abs(location[i] - location[(i-1)%k]), n - abs(location[i] - location[(i-1)%k]))\n                dist_right = min(abs(location[i] - location[(i+1)%k]), n - abs(location[i] - location[(i+1)%k]))\n                memo[location[i]] = min(dist_left, dist_right)\n\n        return [memo[query] for query in queries]","author":"bambi","submissionId":"1575113840"},[]]},{"389":[{"id":"389","fileName":"1575113812.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        idx2={}\n        poss = {}\n        ans=[]\n        n=len(nums)\n        for i, x in enumerate(nums):\n            if x not in poss:\n                poss[x]=[]\n            idx2[i] = len(poss[x])\n            poss[x].append(i)\n\n        # print(poss)\n        # print(idx2)\n        for i, qi in enumerate(queries):\n            x=nums[qi]\n            j = idx2[qi]\n            xposs = poss[x]\n            # print(i, qi, xposs, j)\n            if len(xposs) == 1:\n                ans.append(-1)\n            else:\n                left = xposs[j-1]\n                mid = xposs[j]\n                right = xposs[(j+1) % len(xposs)]\n                d1 = mid-left if (mid >= left) else (mid+n-left)\n                d2 = right-mid if right >= mid else (right+n-mid)\n                here = min(d1,d2)\n                # print('weird', left, mid, right, d1, d2, here)\n                ans.append(here)\n        return ans\n            ","author":"eatfood","submissionId":"1575113812"},[]]},{"390":[{"id":"390","fileName":"1575113927.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& queries) {\n        const int INF = 1e6 + 5;\n        vector<int> pos(INF, -1), f(INF, -1);\n        int N = a.size();\n        vector<int> ans(N, INF);\n        for (int i = 0; i < N; i++) {\n            int x = a[i];\n            if (f[x] == -1) f[x] = i;\n            if (pos[x] != -1) {\n                int dist = i - pos[x];\n                ans[i] = min(ans[i], dist);\n                ans[pos[x]] = min(ans[pos[x]], dist);\n            }\n            pos[x] = i;\n        }\n        for (int i = 1; i < INF; i++) {\n            if (pos[i] != -1 && pos[i] != f[i]) {\n                int dist = N - pos[i] + f[i];\n                ans[pos[i]] = min(ans[pos[i]], dist);\n                ans[f[i]] = min(ans[f[i]], dist);\n            }\n        }\n        vector<int> res;\n        for (auto q: queries) {\n            if (ans[q] == INF) ans[q] = -1;\n            res.push_back(ans[q]);\n        }     \n        return res;\n    }\n};","author":"__keep_it_simple__","submissionId":"1575113927"},[]]},{"392":[{"id":"392","fileName":"1575113806.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), q = queries.size();\n        vector<int> res(q, -1);\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        // cout << \"---n\";\n        for (int i = 0; i < q; i++) {\n            int q_idx = queries[i];\n            int val = nums[q_idx];\n            if (mp[val].size() == 1) continue;\n            int l = 0, r = mp[val].size(), find = -1;\n            while (l < r) {\n                int mid = l + (r - l) / 2;\n                if (mp[val][mid] == q_idx) {\n                    find = mid;\n                    break;\n                } else if (mp[val][mid] > q_idx) r = mid;\n                else l = mid + 1;\n            }\n            if (find != -1) {\n                // cout << q_idx << 'n';\n                int len = mp[val].size();\n                int small = mp[val][((find - 1) % len + len) % len], bigger = mp[val][(find + 1) % len];\n                // cout << small << ' ' << find << ' ' << bigger << 'n';\n                if (small <= q_idx) {\n                    res[i] = min(q_idx - small, small + n - q_idx);\n                } else {\n                    res[i] = min(small - q_idx, q_idx + n - small);\n                }\n                if (bigger <= q_idx) {\n                    res[i] = min(res[i], min(q_idx - bigger, bigger + n - q_idx));\n                } else {\n                    res[i] = min(res[i], min(bigger - q_idx, q_idx + n - bigger));\n                }\n            }\n        }\n        return res;\n    }\n};","author":"k487237","submissionId":"1575113806"},[]]},{"393":[{"id":"393","fileName":"1575114021.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dic = defaultdict(list)\n        for i, num in enumerate(nums):\n            dic[num].append(i)\n        ans = []\n        for val in queries:\n            if len(dic[nums[val]]) <= 1:\n                ans.append(-1)\n            else:\n                curr = float(\"inf\")\n                idx = bisect_left(dic[nums[val]], val)\n                # print(dic[nums[val]], val, idx)\n                if idx > 0:\n                    curr = min(curr, val - dic[nums[val]][idx-1])\n                else:\n                    curr = min(curr, (val + len(nums) - dic[nums[val]][idx-1]))\n                    \n                if idx < len(dic[nums[val]]) - 1:\n                    curr = min(curr, dic[nums[val]][idx+1] - val)\n                else:\n                    curr = min(curr, dic[nums[val]][0] + len(nums) - val)\n                    \n                ans.append(curr)\n        return ans\n                    ","author":"chengxia you","submissionId":"1575114021"},[]]},{"394":[{"id":"394","fileName":"1575114023.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> minDist(n, -1);\n        unordered_map<int, vector<int>> m;\n        \n        for (int i = 0; i < n; i++) {\n            m[nums[i]].push_back(i);\n        }\n        \n        for (auto& p : m) {\n            auto& its = p.second;\n            if (its.size() == 1) continue;\n            \n            for (int i = 0; i < its.size(); i++) {\n                int it = its[i];\n                int md = n;\n                \n                int prev = its[(i + its.size() - 1) % its.size()];\n                md = min(md, min(abs(it - prev), n - abs(it - prev)));\n                \n                int next = its[(i + 1) % its.size()];\n                md = min(md, min(abs(it - next), n - abs(it - next)));\n                \n                minDist[it] = md;\n            }\n        }\n        \n        vector<int> ans(queries.size());\n        for (int i = 0; i < queries.size(); i++) {\n            ans[i] = minDist[queries[i]];\n        }\n        \n        return ans;\n    }\n};","author":"Tushar","submissionId":"1575114023"},[{"id":"754","similarity":1.0,"totOverlap":184,"longestOverlap":92},{"id":"892","similarity":0.8786127167630058,"totOverlap":152,"longestOverlap":47}]],"754":[{"id":"754","fileName":"1575124351.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n = nums.size();\n        vector<int> ans(n, -1);\n        unordered_map<int, vector<int>> m;\n        \n        for (int i = 0; i < n; i++) {\n            m[nums[i]].push_back(i);\n        }\n        \n        for (auto& p : m) {\n            auto& v = p.second;\n            if (v.size() == 1) \n                continue;  \n\n            for (int i = 0; i < v.size(); i++) {\n                int it = v[i];\n                int md = n;\n                \n                int prev = v[(i + v.size() - 1) % v.size()];\n                md = min(md, min(abs(it - prev), n - abs(it - prev)));\n                \n                int next = v[(i + 1) % v.size()];\n                md = min(md, min(abs(it - next), n - abs(it - next)));\n                \n                ans[it] = md;\n            }\n        }\n        \n        vector<int> k(q.size());\n        for (int i = 0; i < q.size(); i++) {\n            k[i] = ans[q[i]];\n        }\n        \n        return k;\n    }\n};\n","author":"Yash Garg","submissionId":"1575124351"},[{"id":"394","similarity":1.0,"totOverlap":184,"longestOverlap":92}]],"892":[{"id":"892","fileName":"1575128122.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        \n        \n        vector<int> minDistances(n, -1);\n        \n      \n        unordered_map<int, vector<int>> indices;\n        for (int i = 0; i < n; i++) {\n            indices[nums[i]].push_back(i);\n        }\n        \n      \n        for (auto& [value, positions] : indices) {\n            // Skip values with only one occurrence\n            if (positions.size() <= 1) continue;\n            \n            // For each position, find minimum distance to any other position\n            for (int i = 0; i < positions.size(); i++) {\n                int curr = positions[i];\n                int minDist = n; // Initialize with maximum possible distance\n                \n            \n                int prev = positions[(i + positions.size() - 1) % positions.size()];\n                minDist = min(minDist, min(abs(curr - prev), n - abs(curr - prev)));\n                \n          \n                int next = positions[(i + 1) % positions.size()];\n                minDist = min(minDist, min(abs(curr - next), n - abs(curr - next)));\n                \n                minDistances[curr] = minDist;\n            }\n        }\n        \n        // Answer queries directly\n        vector<int> answer;\n        for (int queryIdx : queries) {\n            answer.push_back(minDistances[queryIdx]);\n        }\n        \n        return answer;\n    }\n};","author":"Prashun Raj","submissionId":"1575128122"},[{"id":"394","similarity":0.8786127167630058,"totOverlap":152,"longestOverlap":47}]]},{"395":[{"id":"395","fileName":"1575114064.txt","sourceCode":"class Solution {\npublic:\n    typedef long long ll;\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<ll,vector<ll> > mp;\n        vector<ll> v;\n        for(ll i=0;i<nums.size();i++)\n            mp[nums[i]].push_back(i);\n        for(auto &i: mp)\n            sort(i.second.begin(),i.second.end());\n        for(ll i=0;i<queries.size();i++)\n        {\n            if(mp[nums[queries[i]]].size()<2)\n            {\n                v.push_back(-1);\n                continue;\n            }\n            ll x=LLONG_MAX,y=LLONG_MAX;\n            ll idx=lower_bound(mp[nums[queries[i]]].begin(),mp[nums[queries[i]]].end(),queries[i])-mp[nums[queries[i]]].begin();\n            if(idx<mp[nums[queries[i]]].size()-1)\n                x=mp[nums[queries[i]]][idx+1]-queries[i];\n            else if(idx==mp[nums[queries[i]]].size()-1)\n                x=nums.size()-queries[i]+mp[nums[queries[i]]][0];\n            \n            if(idx==0)\n            y=queries[i]+(nums.size()-mp[nums[queries[i]]][mp[nums[queries[i]]].size()-1]);\n            else if(idx>0)\n            y=queries[i]-mp[nums[queries[i]]][idx-1];\n                v.push_back(min(x,y));\n                \n        }\n        vector<int> x(v.begin(),v.end());\n        return x;\n    }\n};","author":"mittaludit768","submissionId":"1575114064"},[]]},{"398":[{"id":"398","fileName":"1575114176.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        pos = defaultdict(list)\n        for i, x in enumerate(nums):\n            pos[x].append(i)\n\n        n = len(nums)\n        res = []\n        for q in queries:\n            x = nums[q]\n            if len(pos[x]) == 1:\n                res.append(-1)\n            else:\n                ind = bisect.bisect_left(pos[x], q)\n                temp = 0\n                if ind == len(pos[x]) - 1:\n                    temp = min(n + pos[x][0] - pos[x][ind], pos[x][ind] - pos[x][ind - 1])\n                elif ind == 0:\n                    temp = temp = min(pos[x][ind + 1] - pos[x][ind], pos[x][ind] + n - pos[x][-1])\n                else:\n                    temp = min(pos[x][ind + 1] - pos[x][ind], pos[x][ind] - pos[x][ind - 1])\n                res.append(temp)\n        return res\n        ","author":"sokui","submissionId":"1575114176"},[]]},{"399":[{"id":"399","fileName":"1575113688.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int m = queries.length, n = nums.length;\n        Map<Integer, TreeSet<Integer>> numToIndices = new HashMap<>();\n        for(int i = 0; i < n; i++) {\n            TreeSet<Integer> curr = numToIndices.computeIfAbsent(nums[i], k -> new TreeSet<>());\n            curr.add(i);\n            curr.add(n+i);\n            curr.add(i-n);\n        }\n        List<Integer> res = new ArrayList<>();\n        for(int query : queries) {\n            int num = nums[query];\n            if(numToIndices.get(num).size() == 3) { //only has query and circle queries\n                res.add(-1);\n                continue;\n            }\n            Integer low = numToIndices.get(num).lower(query);\n            Integer high = numToIndices.get(num).higher(query);\n            int loDist = low == null ? Integer.MAX_VALUE : Math.abs(low-query);\n            int hiDist = high == null ? Integer.MAX_VALUE : Math.abs(high-query);\n            int minDist = Math.min(loDist, hiDist);\n            res.add(minDist);   \n        }\n        return res;\n    }\n}","author":"Nicholas Ulman","submissionId":"1575113688"},[]]},{"400":[{"id":"400","fileName":"1575114179.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> arr(2 * n);\n        for (int i = 0 ; i < n ; i++) arr[i] = arr[n + i] = nums[i];\n        map<int,vector<int>> h;\n        for (int i = 0 ; i < 2 * n ; i++) h[arr[i]].push_back(i);\n        vector<int> ans;\n        for (auto i : queries) {\n            if (h[nums[i]].size() <= 2) {\n                ans.push_back(-1);\n                continue;\n            }\n            int ans1 = n;\n            auto mx = upper_bound(h[nums[i]].begin(), h[nums[i]].end(), i);\n            \n            ans1 = min(n, *mx - i);\n            auto mx2 = lower_bound(h[nums[i]].begin(), h[nums[i]].end(), i + n);\n            ans1 = min(ans1, i + n - *(mx2 - 1) );\n            ans.push_back(ans1);\n        }\n        return ans;\n        \n    }\n};","author":"Swaroop vaze","submissionId":"1575114179"},[]]},{"401":[{"id":"401","fileName":"1575114235.txt","sourceCode":"int min(int a, int b) {\n    return a < b ? a : b;\n}\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> tAns(nums.size(), INT_MAX);\n        unordered_map<int, int> dict;\n        \n        for(int idx = 0; idx < nums.size(); idx++) {\n            auto i = nums[idx];\n            \n            if(dict.count(i)) {\n                auto prevIdx = dict[i];\n                \n                tAns[prevIdx] = min(tAns[prevIdx], idx - prevIdx);\n                \n                tAns[idx] = idx - prevIdx;\n            }\n            \n            dict[i] = idx;\n        }\n        \n        for(int idx = 0; idx < nums.size(); idx++) {\n            auto i = nums[idx];\n            \n            if(dict.count(i)) {\n                auto prevIdx = dict[i];\n                \n                tAns[prevIdx] = min(tAns[prevIdx], idx + nums.size() - prevIdx);\n                \n                tAns[idx] = min(tAns[idx], idx + nums.size() - prevIdx);\n            }\n            \n            dict[i] = idx;\n        }\n        \n        \n        for(auto &i : tAns) {\n            if(i == INT_MAX || i == nums.size()) {\n                i = -1;\n            }\n        }\n        \n        vector<int> ans;\n        \n        for(auto &query : queries) {\n            ans.push_back(tAns[query]);\n        }\n        \n        return ans;\n    }\n};","author":"zxxxxy1998","submissionId":"1575114235"},[]]},{"402":[{"id":"402","fileName":"1575114183.txt","sourceCode":"function solveQueries(nums: number[], queries: number[]): number[] {\n    const n = nums.length;\n    const posMap = new Map<number, number[]>();\n    for (let i = 0; i < n; i++) {\n        if (!posMap.has(nums[i])) posMap.set(nums[i], []);\n        posMap.get(nums[i])!.push(i);\n    }\n    \n    const res: number[] = [];\n    for (const q of queries) {\n        const value = nums[q];\n        const indices = posMap.get(value)!;\n        if (indices.length < 2) {\n            res.push(-1);\n        } else {\n            const pos = binarySearch(indices, q);\n            const prevIdx = pos === 0 ? indices[indices.length - 1] : indices[pos - 1];\n            const nextIdx = pos === indices.length - 1 ? indices[0] : indices[pos + 1];\n            let d1 = Math.abs(q - prevIdx);\n            let d2 = Math.abs(nextIdx - q);\n            d1 = Math.min(d1, n - d1);\n            d2 = Math.min(d2, n - d2);\n            res.push(Math.min(d1, d2));\n        }\n    }\n    return res;\n}\n\nfunction binarySearch(arr: number[], target: number): number {\n    let low = 0, high = arr.length - 1;\n    while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        if (arr[mid] === target) return mid;\n        else if (arr[mid] < target) low = mid + 1;\n        else high = mid - 1;\n    }\n    return -1;\n}\n","author":"Swayam","submissionId":"1575114183"},[]]},{"403":[{"id":"403","fileName":"1575114257.txt","sourceCode":"from sortedcontainers import SortedList\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        left = defaultdict(SortedList)\n        right = defaultdict(SortedList)\n        n = len(nums)\n        for i, e in enumerate(nums):\n            right[e].add(i)\n        \n        res = []\n        for i in range(n):\n            num = nums[i]\n            currMin = 1000000000\n            if num in left:\n                currMin = min(currMin, i - left[num][-1])\n                currMin = min(currMin, left[num][0] + (n - i))\n            \n            right[num].remove(i)\n            if not right[num]:\n                del right[num]\n            left[num].add(i)\n            \n            if num in right:\n                currMin = min(currMin, right[num][0] - i)\n                currMin = min(currMin, i + (n - right[num][-1]))\n            if currMin == 1000000000:\n                res.append(-1)\n            else:\n                res.append(currMin)\n            \n        ans = []\n        for q in queries:\n            ans.append(res[q])\n        return ans","author":"resposible_display","submissionId":"1575114257"},[]]},{"404":[{"id":"404","fileName":"1575114367.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector <vector<int>> v(100005);\n        int n = nums.size();\n        for(int i=0;i<nums.size();i++){\n            v[nums[i]].push_back(i);\n        }\n        vector <int> ans(queries.size());\n        int p = 0;\n        for(auto &z : queries){\n            int x = nums[z];\n            if(v[x].size() == 1){\n                ans[p++]=-1;\n                continue;\n            }\n            int ind = lower_bound(v[x].begin(),v[x].end(),z)-v[x].begin();\n            int val = 1e6;\n            if(ind>0) val=min(val,abs(z-v[x][ind-1]));\n            else      val=min(val,abs(n-v[x][v[x].size()-1]+z));\n            if((ind+1)<(v[x].size())) val=min(val,abs(z-v[x][ind+1]));\n            else                      val=min(val,abs(n-z+v[x][0]));\n            ans[p++]=val;\n        }\n        return ans;\n    }\n};","author":"gok_2001","submissionId":"1575114367"},[]]},{"405":[{"id":"405","fileName":"1575114371.txt","sourceCode":"import bisect\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = dict()\n        n = len(nums)\n        for i in range(0, n):\n            if nums[i] not in d:\n                d[nums[i]] = []\n            d[nums[i]].append(i)\n\n        ans = []\n\n        for i in queries:\n            cur = d[nums[i]]\n            if len(cur) == 1:\n                ans.append(-1)\n            else:\n                k = bisect_left(cur, i)\n                if k == len(cur)-1:\n                    ans.append(min(abs(i-cur[0]), abs(i-cur[k-1]), n - abs(cur[0]-i), n - abs(cur[k-1]-i)))\n                elif k == 0:\n                    ans.append(min(abs(i-cur[k+1]), abs(i-cur[-1]), n - abs(cur[k+1]-i), n - abs(cur[-1]-i)))\n                else:\n                    ans.append(min(abs(i-cur[k+1]), abs(i-cur[k-1]), n - abs(cur[k+1]-i), n - abs(cur[k-1]-i)))\n\n        return ans","author":"Likith","submissionId":"1575114371"},[]]},{"406":[{"id":"406","fileName":"1575114294.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, int[]> map = new HashMap<>(); // first, last.\n        var prev = new int[n];\n        Arrays.fill(prev, -1);\n        var next = new int[n];\n        Arrays.fill(next, -1);\n        for(int i = 0; i < n; ++i) {\n            int v = nums[i];\n            var x = map.get(v);\n            if (x == null) {\n                map.put(v, new int[] {i, i});\n            } else {\n                var last = x[1];\n                prev[i] = last;\n                next[last] = i;\n                x[1] = i;\n            }\n        }\n        List<Integer> result = new ArrayList<>();\n        for(int i : queries) {\n            int v = nums[i];\n            var x = map.get(v);\n            if (x[0] == x[1]) {\n                result.add(-1);\n            } else {\n                int right = 0;\n                if (next[i] == -1) {\n                    right = x[0] + n - i;\n                } else {\n                    right = next[i] - i;\n                }\n                int left = 0;\n                if (prev[i] == -1) {\n                    left = i + n - x[1];\n                } else {\n                    left = i - prev[i];\n                }\n                result.add(Math.min(left, right));\n            }\n        }\n        return result;\n    }\n}","author":"heshan1234","submissionId":"1575114294"},[]]},{"407":[{"id":"407","fileName":"1575114280.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        const int n = nums.size();\n\n        vector<int> res(n);\n        unordered_map<int, vector<int>> mp;\n        for(int i = 0; i < n; i++) {\n            int e = nums[i];\n            if(mp.find(e) == mp.end()) {\n                mp[e].push_back(i);\n                res[i] = -1;\n            } else {\n                int last = mp[e].back();\n                mp[e].push_back(i);\n                if(res[last] == -1) {\n                    res[last] = res[i] = abs(last - i);\n                } else {\n                    res[last] = min(res[last], abs(last - i));\n                    res[i] = abs(last - i);\n                }\n            }\n        }\n\n        for(auto p : mp) {\n            if(p.second.size() <= 1)\n                continue;\n            int l = p.second[0], r = p.second.back();\n            int k = n - r + l;\n            res[l] = min(res[l], k);\n            res[r] = min(res[r], k);\n        }\n        \n        vector<int> ans;\n        for(auto query : queries)\n            ans.push_back(res[query]);\n        return ans;\n    }\n};","author":"Neelabhra Roy","submissionId":"1575114280"},[]]},{"408":[{"id":"408","fileName":"1575114389.txt","sourceCode":"class Solution {\npublic:\n    int oo = 10000000;\n    map<int, set<int>> h;\n    vector<int> solveQueries(vector<int>& a, vector<int>& que) {\n        for (int i = 0; i < a.size(); i ++) h[a[i]].insert(i);\n        vector<int> ans;\n        for (int q : que) {\n            set<int> &s = h[a[q]];\n            int x = oo, y = oo;\n            if (s.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            auto it = s.upper_bound(q);\n            if (it != s.end()) {\n                cout<<\"upper\"<<endl;\n                x = *it - q;\n            } else {\n                it = s.begin();\n                x = a.size() - q + *it;\n            }\n            it = s.find(q);\n            if (it != s.begin()) {\n                --it;\n                y = q - *it;\n            } else {\n                y = q;\n                it = --s.end();\n                y += a.size() - *it;\n            }\n            // cout<<x<<' '<<y<<endl;\n            ans.push_back(min(x, y));\n        }\n\n        return ans;\n    }\n};","author":"pipipi","submissionId":"1575114389"},[]]},{"410":[{"id":"410","fileName":"1575114469.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        mp = defaultdict(list)\n\n        for i,num in enumerate(nums):\n            mp[num].append(i)\n\n        ans = [-1] * len(queries)\n        m = len(nums)\n        for i in range(len(queries)):\n            idx = queries[i]\n            val = nums[idx]\n            \n            if len(mp[val]) == 1:\n                continue\n            elif len(mp[val]) == 2:\n                ans[i] = min(mp[val][1] - mp[val][0], m - mp[val][1] + mp[val][0])\n            else:\n                dd = bisect_left(mp[val], idx)\n                left = mp[val][dd] - mp[val][dd-1] if dd > 0 else (m - mp[val][-1] + mp[val][dd])\n                right = mp[val][dd+1] - mp[val][dd] if dd+1< len(mp[val]) else (m - mp[val][dd] + mp[val][0])\n                ans[i] = min(left, right)\n\n        return ans\n            ","author":"Gabriel Sasu","submissionId":"1575114469"},[]]},{"411":[{"id":"411","fileName":"1575114555.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n        int n = nums.size();\n        \n        vector<int> arr;\n        arr = nums;\n        arr.insert(arr.end(), nums.begin(), nums.end());\n        arr.insert(arr.end(), nums.begin(), nums.end());\n\n        map<int,int> mpp;\n\n        vector<int> dp(arr.size(), 1e9);\n        \n        for(int i=0; i<arr.size(); i++) {\n            int ele = arr[i];\n            if(mpp.find(ele) != mpp.end()) {\n                int idx = mpp[ele];\n                if(i%n != idx%n)\n                    dp[i] = i - mpp[ele];\n            }\n            mpp[ele] = i;\n        }\n\n        mpp.clear();\n\n        for(int i=arr.size()-1; i>=0; i--) {\n            int ele = arr[i];\n            if(mpp.find(ele) != mpp.end()){\n                int idx = mpp[ele];\n                if(i%n != idx%n)\n                    dp[i] = min(dp[i], mpp[ele] - i);\n            }\n            mpp[ele] = i;\n        }\n\n        vector<int> ans;\n\n        for(int idx: queries) {\n            if(dp[idx+n] == 1e9)\n                ans.push_back(-1);\n            else\n                ans.push_back(dp[idx+n]);\n        }\n\n        return ans;\n    }\n};","author":"Gagan B","submissionId":"1575114555"},[]]},{"412":[{"id":"412","fileName":"1575114725.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        from collections import defaultdict\n        import bisect\n        \n        num_idx = defaultdict(list)\n\n        for i in range(len(nums)):\n            num_idx[nums[i]].append(i)\n\n        def find_min_dist(idx, idx_list):\n            if len(idx_list) == 1:\n                return -1\n            \n            index = bisect.bisect_left(idx_list, idx)\n\n            # print(idx, idx_list, index)\n            if index == 0:\n                left = idx + len(nums) - idx_list[-1]\n                right = idx_list[1] - idx\n                # return idx_list[1] - idx\n            elif index == len(idx_list) - 1:\n                left = idx - idx_list[-2]\n                right = idx_list[0] + len(nums) - idx\n                # return idx - idx_list[-2]\n            else:\n                left = idx - idx_list[index - 1]\n                right = idx_list[index + 1] - idx\n            return min(left, right)\n            \n        ans = []\n        for query in queries:\n            num = nums[query]\n            idx_list = num_idx[num]\n            dist = find_min_dist(query, idx_list)\n            ans.append(dist)\n\n        return ans","author":"Adamranger","submissionId":"1575114725"},[]]},{"413":[{"id":"413","fileName":"1575114840.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        num_map = defaultdict(list)\n        for i, num in enumerate(nums):\n            num_map[num].append(i)\n\n        def get_min_dist(p1, p2):\n            dist1 = abs(p1-p2)\n            dist2 = len(nums) - dist1\n            return min(dist1, dist2)\n        \n        ans = [-1] * len(queries)\n        for i, query in enumerate(queries):\n            target_num = nums[query]\n            if len(num_map[target_num]) == 1: continue\n\n            # Find position in num_map\n            inner_index = bisect.bisect_left(num_map[target_num], query)\n            l_inner, r_inner = inner_index - 1, (inner_index+1) % (len(num_map[target_num]))\n            l, r = num_map[target_num][l_inner], num_map[target_num][r_inner]\n            \n            \n            ans[i] = min(get_min_dist(query, l), get_min_dist(query, r))\n\n        return ans\n            ","author":"kobb","submissionId":"1575114840"},[]]},{"414":[{"id":"414","fileName":"1575114769.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n#define dbg(...) __f(#__VA_ARGS__,__VA_ARGS__)\n// trace std::pair\ntemplate<class L,class R> std::ostream& operator<<(std::ostream& os,std::pair<L,R>& P){\n\treturn os<<\"{\"<<P.first<<\":\"<<P.second<<\"}\";\n}\n// trace std::vector\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::vector<T>& V){\n\tos<<\"[ \";for(auto v:V)os<<v<<\" \";return os<<\"]\";\n}\n// trace std::map;\ntemplate<class L,class R> std::ostream& operator<<(std::ostream& os,std::map<L,R>& MP) {\n\tos<<\"[ \";for(auto& P : MP) os<<P<<\" \";return os<<\"]\";\n}\n// trace unordred_std::map\ntemplate<class L,class R> std::ostream& operator<<(std::ostream& os,std::unordered_map<L,R>& MP) {\n\tos<<\"[ \";for(auto& P : MP) os<<P<<\" \";return os<<\"]\";\n}\n// trace std::set\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::set<T>& S){\n\tos<<\"[ \";for(auto s:S)os<<s<<\" \";return os<<\"]\";\n}\n// Debugging for std::set<int, std::greater<int>> (custom comparator)\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T, std::greater<T>>& S) {\n\tos << \"[ \";\n\tfor (auto s : S) os << s << \" \";\n\treturn os << \"]\";\n}\n// trace std::unordered_set\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::unordered_set<T>& S){\n\tos<<\"[ \";for(auto s:S)os<<s<<\" \";return os<<\"]\";\n}\n// trace std::multiset\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::multiset<T>& S){\n\tos<<\"[ \";for(auto s:S)os<<s<<\" \";return os<<\"]\";\n}\n// Debugging for std::set<int, std::greater<int>> (custom comparator)\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, std::multiset<T, std::greater<T>>& S) {\n\tos << \"[ \";\n\tfor (auto s : S) os << s << \" \";\n\treturn os << \"]\";\n}\n// std::stack FUN\ntemplate <class T>\nvoid F_Stack(std::stack<T> st, std::string& cont) {\n\tif (st.empty()) return;\n\tT mem = st.top();\n\tst.pop();\n\tF_Stack(st, cont);\n\t// Use stringstream to handle any type T\n\tstd::stringstream ss;\n\tss << mem;\n\tcont += \" \" + ss.str();\n}\n// trace std::stack                                                  \ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::stack<T> st) {\n\tos<<\"[\";std::string cont=\"\";F_Stack(st,cont);return os<<cont<<\" ]\";\n}\n// track std::queue\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::queue<T> q) {\n\tos<<\"[ \";while(!q.empty()) os<<q.front()<<\" \",q.pop();return os<<\"]\";\n}\n// Debugging for std::deque\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, std::deque<T>& D) {\n\tos << \"[ \";\n\tfor (auto& d : D) os << d << \" \";\n\treturn os << \"]\";\n}\n// dbg std::std::array\ntemplate<class T, size_t S> std::ostream& operator<<(std::ostream& os,std::array<T, S> V){\n\tos<<\"[ \";for(auto v:V)os<<v<<\" \";return os<<\"]\";\n}\n// Debugging for max-heap (default priority queue)\ntemplate <class T>\nvoid F_PriorityQueue(std::priority_queue<T> pq, std::string& cont) {\n\twhile (!pq.empty()) {\n\t\tT mem = pq.top();\n\t\tpq.pop();\n\t\t\n\t\t// Use stringstream for general types\n\t\tstd::stringstream ss;\n\t\tss << mem;\n\t\tcont += \" \" + ss.str();\n\t}\n}\n\n// Debugging for min-heap (custom comparator)\ntemplate <class T>\nvoid F_MinPriorityQueue(std::priority_queue<T, std::vector<T>, std::greater<T>> pq, std::string& cont) {\n\twhile (!pq.empty()) {\n\t\tT mem = pq.top();\n\t\tpq.pop();\n\t\t\n\t\t// Use stringstream for general types\n\t\tstd::stringstream ss;\n\t\tss << mem;\n\t\tcont += \" \" + ss.str();\n\t}\n}\n\n// Debug function for priority queue (max-heap)\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> pq) {\n\tos << \"[\";\n\tstd::string cont = \"\";\n\tF_PriorityQueue(pq, cont);\n\treturn os << cont << \" ]\";\n}\n\n// Debug function for min-heap priority queue\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> pq) {\n\tos << \"[\";\n\tstd::string cont = \"\";\n\tF_MinPriorityQueue(pq, cont);\n\treturn os << cont << \" ]\";\n}\n\n\n// for last arg.\ntemplate<typename Arg1>\nvoid __f(const char* name,Arg1&& arg1){\n\tstd::cout<<name<<\" : \"<<arg1<<std::endl;\n}\n// for variable arg\ntemplate <typename Arg1,typename... Args>\nvoid __f(const char* names,Arg1&& arg1,Args&&... args){\n\tconst char* comma=strchr(names+1,',');std::cout.write(names,comma-names)<<\" : \"<<arg1<<\" | \";__f(comma+1,args...);\n}\n\n\n// X.find_by_order(k) return iterator to kth element. 0 indexed.\n// X.order_of_key(k) returns count of elements strictly less than k.\n\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// template <class T>\n// using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\n\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define sz(x) ((ll)(x).size())\n#define nl 'n'\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define uniq(x) {x.erase(unique(all(x)), x.end()); }\n\nusing ll = long long int;\nusing i128 = __int128;\nusing pii = pair<ll,ll>;\nusing mii = map<ll,ll>;\t\nusing umii = unordered_map<ll,ll>;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vvii = vector<vpii>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\nusing vvvl = vector<vvl>;\nusing vvpii = vector<vpii>;\ntemplate<class T> using _priority_queue = priority_queue<T, vector<T>, greater<T>>;\n\ntemplate<class T, class U> bool chmin(T& a, const U& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T, class U> bool chmax(T& a, const U& b) { return a < b ? a = b, 1 : 0; }\n\n\nconst ll INF = 1e12;\nconst ll N = 1e5+5;\n\n// #define dbg(...)\n// Think about corner cases before submitting\n\n\ntemplate<class T, class U> auto min(const T& a, const U& b) -> typename std::common_type<T, U>::type { return b < a ? b : a; }\ntemplate<class T, class U> auto max(const T& a, const U& b) -> typename std::common_type<T, U>::type { return b > a ? b : a; }\n\n#define here() dbg(__LINE__)\n\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = sz(nums);\n        int q = sz(queries);\n        map<int, vi> mp;\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for (auto idx : queries) {\n            int req = nums[idx];\n            if (mp[req].size() == 1) {\n                ans.push_back(-1);\n            } else {\n                auto j = lower_bound(all(mp[req]), idx) - mp[req].begin();\n                int m = mp[req].size();\n                int cur = 1e8;\n                if (j == 0) {\n                    int j2 = mp[req][m - 1];\n                    cur = min(cur, idx + n - j2);\n                } else {\n                     cur = min(cur, idx - mp[req][j - 1]);   \n                }\n                if (j == m - 1) {\n                    int j2 = mp[req][0];\n                    cur = min(cur, n - idx + j2);\n                } else {\n                     cur = min(cur, mp[req][j + 1] - idx);   \n                }\n                ans.push_back(cur);\n            }\n        }\n        return ans;\n    }\n};","author":"Rushikesh Kulkarni","submissionId":"1575114769"},[]]},{"415":[{"id":"415","fileName":"1575114856.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> hm;\n        vector<int> posInHm;\n        int n = nums.size(), m = queries.size();\n        for (int i = 0; i < n; i++) {\n            posInHm.push_back(hm[nums[i]].size());\n            hm[nums[i]].push_back(i);\n        }\n\n        vector<int> ans;\n        for (int q : queries) {\n            int curPos = posInHm[q];\n            int val = nums[q];\n\n            vector<int>& indices = hm[val];\n\n            if (indices.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            \n            int res = -1;\n            if (curPos == 0) {\n                int dist1 = indices[curPos + 1] - indices[curPos];\n                int dist2 = indices[curPos] + n - indices.back();\n                res = min(dist1, dist2);\n            } else if (curPos == indices.size() - 1) {\n                int dist1 = indices[curPos] - indices[curPos - 1];\n                int dist2 = indices[0] + n - indices[curPos];\n                res = min(dist1, dist2);\n            } else {\n                int dist1 = indices[curPos] - indices[curPos - 1];\n                int dist2 = indices[curPos +1] - indices[curPos];\n                res = min(dist1, dist2);\n            }\n            ans.push_back(res);\n            \n        }\n        return ans;\n    }\n};\n\n// map: value and indexes\n// binary search for position of element. ","author":"xquisite0","submissionId":"1575114856"},[]]},{"416":[{"id":"416","fileName":"1575114971.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        tmp = [x for x in nums]\n        tmp.extend(nums)\n        nums.extend(tmp)\n        f = {}\n        for i in range(len(nums)):\n            if nums[i] not in f: f[nums[i]] = []\n            f[nums[i]].append(i)\n        ans = []\n        for q in queries:\n            q += n\n            idx = bisect.bisect_left(f[nums[q]], q)\n            if len(f[nums[q]]) == 3:\n                ans.append(-1)\n                continue\n            ans.append(min(f[nums[q]][idx] - f[nums[q]][idx - 1], f[nums[q]][idx + 1] - f[nums[q]][idx] ))\n        return ans\n        ","author":"goodbyeNostalgia","submissionId":"1575114971"},[]]},{"417":[{"id":"417","fileName":"1575114886.txt","sourceCode":"# @param {Integer[]} nums\n# @param {Integer[]} queries\n# @return {Integer[]}\ndef solve_queries(nums, queries)\n    rev = Hash.new\n    (0 ... nums.size).each{|i|\n        rev[nums[i]] = Array.new unless rev.key?(nums[i])\n        rev[nums[i]] << i\n    }\n    queries.map{|q|\n        index = rev[nums[q]]\n        next -1 if index.size == 1\n        i = index.bsearch_index{_1 >= q}\n        [\n            (index[i] - index[i - 1]) % nums.size,\n            (index[(i + 1) % index.size] - index[i]) % nums.size\n        ].min\n    }\nend","author":"lanegue","submissionId":"1575114886"},[]]},{"418":[{"id":"418","fileName":"1575114957.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        const int n = nums.size(), q = queries.size();\n        \n        std::unordered_map<int, std::vector<int>> m;\n        for (int i = 0; i < n; ++i) {\n            m[nums[i]].push_back(i);\n        }\n\n        std::vector<int> ans(q, -1);\n        for (int i = 0; i < q; ++i) {\n            const std::vector<int> &v = m[nums[queries[i]]];\n            auto it = std::lower_bound(v.begin(), v.end(), queries[i]);\n\n            if (it != v.begin()) {\n                ans[i] = queries[i] - *std::prev(it);\n            }\n            else if (v.size() > 1) {\n                ans[i] = queries[i] + n - v.back();\n            }\n\n            if (it != std::prev(v.end())) {\n                if (ans[i] == -1 || *std::next(it) - queries[i] < ans[i]) {\n                    ans[i] = *std::next(it) - queries[i];\n                }\n            }\n            else if (v.size() > 1 && v[0] + n - queries[i] < ans[i]) {\n                ans[i] = v[0] + n - queries[i];\n            }\n        }\n\n        return ans;\n    }\n};","author":"mcuadros","submissionId":"1575114957"},[]]},{"419":[{"id":"419","fileName":"1575114984.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n\n        d = {}\n        n = len(nums)\n\n        pre = [sys.maxsize for _ in range(n)]\n\n        for i, num in enumerate(nums):\n            if d.get(num) is None:\n                d[num] = (i,i,i)\n\n            else:\n                first,prev,last = d[num]\n\n                pre[prev] = min(pre[prev], min(i-prev, n-i+prev))\n\n                pre[i] = min(pre[i], min(i-prev, n-i+prev))\n\n                d[num] = (first,i,i)\n\n\n        for key in d.keys():\n            first,prev,last = d[key]\n\n\n            if first != last:\n                pre[first] = min(pre[first], n-last+first)\n                pre[last] = min(pre[last], n-last+first)\n\n\n\n\n        ans = []\n\n        for query in queries:\n            if pre[query] == sys.maxsize:\n                ans.append(-1)\n\n            else:\n                ans.append(pre[query])\n\n        return ans\n\n                \n            ","author":"Joker17","submissionId":"1575114984"},[]]},{"420":[{"id":"420","fileName":"1575114977.txt","sourceCode":"class Solution {\npublic:\n    int findIndex(vector<int>& indexes, int x){\n        int low=0,mid,high=indexes.size()-1;\n        while(low<=high){\n            mid=(low+high)/2;\n            if(indexes[mid]==x){\n                return mid;\n            }else if(indexes[mid]<x){\n                low=mid+1;\n            }else{\n                high=mid-1;\n            }\n        }\n        return -1;\n    }\n\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]].push_back(i);\n        }\n        // findIndex using binary search\n        vector<int> ans;\n        for(int i=0;i<queries.size();i++){\n            int ind=queries[i];\n            int k=findIndex(mp[nums[ind]], ind);\n            int sz=mp[nums[ind]].size();\n            int p=(k+1)%sz,q=(k+sz-1)%sz;\n            int r=min(abs(mp[nums[ind]][p]-ind), abs(mp[nums[ind]][q]-ind));\n            r=min(r, (int)(nums.size() - abs(mp[nums[ind]][p]-ind)) );\n            r=min(r, (int)(nums.size() - abs(mp[nums[ind]][q]-ind)) );\n            ans.push_back(r==0 ? -1 : r);\n        }\n        return ans;\n    }\n};","author":"thrivikram karur","submissionId":"1575114977"},[]]},{"422":[{"id":"422","fileName":"1575115030.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        closests = [inf] * len(nums)\n        \n        # forward\n        prev = {}\n        for i, num in enumerate(nums):\n            if num in prev:\n                closests[i] = i - prev[num]\n            prev[num] = i\n\n        for i, num in enumerate(nums):\n            if prev[num] != i:\n                closests[i] = min(closests[i], len(nums) - prev[num] + i)\n                closests[prev[num]] = min(closests[prev[num]], len(nums) - prev[num] + i)\n                \n        # back\n        prev = {}\n        for i in range(len(nums) - 1, -1, -1):\n            if nums[i] in prev:\n                closests[i] = min(closests[i], prev[nums[i]] - i)\n            prev[nums[i]] = i     \n\n        res = []\n        for i, query in enumerate(queries):\n            target = nums[query]\n            if closests[query] == inf:\n                res.append(-1)\n            else:\n                res.append(closests[query])\n\n        return res\n\n# [-1,-1,2,-1,-1,2]\n","author":"kay118","submissionId":"1575115030"},[]]},{"423":[{"id":"423","fileName":"1575115087.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        res = [0] * len(queries)\n        A = defaultdict(list)\n        for i, v in enumerate(nums):\n            A[v].append(i)\n        for i in A:\n            A[i].sort()\n        def dis(i, j):\n            return min(abs(j-i),len(nums)-abs(j-i))\n        for i in range(len(queries)):\n            j = queries[i]\n            B = A[nums[j]]\n            if len(B) <= 1:\n                res[i] = -1\n                continue\n            k = bisect_left(B, j)\n            dis1 = dis(j, B[(k-1)%len(B)])\n            dis2 = dis(j, B[(k+1)%len(B)])\n            res[i] = dis1 if dis1 < dis2 else dis2\n        return res","author":"domick","submissionId":"1575115087"},[]]},{"424":[{"id":"424","fileName":"1575115131.txt","sourceCode":"class Solution {\n    int search(vector<int> &a, int x){\n        int l = 0, r = a.size()-1;\n        while(l <= r){\n            int m = (l+r)/2;\n            if(a[m] == x) return m;\n            if(a[m] < x) l = m+1;\n            else r = m-1;\n        }\n        return -1;\n    }\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> mpp;\n        for(int i=0; i<nums.size(); ++i){\n            mpp[nums[i]].push_back(i);\n        }\n\n        vector<int> ans(queries.size(), -1);\n        for(int i=0; i<queries.size(); ++i){\n            if(mpp[nums[queries[i]]].size() > 1){\n                int idx = search(mpp[nums[queries[i]]], queries[i]);\n                int l = 0, r = 0;\n                if(idx == 0) l = queries[i] + (nums.size() - mpp[nums[queries[i]]][mpp[nums[queries[i]]].size()-1]);\n                else l = queries[i] - mpp[nums[queries[i]]][idx-1];\n                if(idx == mpp[nums[queries[i]]].size()-1) r = nums.size() + mpp[nums[queries[i]]][0] - queries[i];\n                else r = mpp[nums[queries[i]]][idx+1] - queries[i];\n\n                ans[i] = min(l, r);\n            }\n        }\n\n        return ans;\n    }\n};","author":"Shashank Gupta","submissionId":"1575115131"},[]]},{"72":[{"id":"72","fileName":"1575097547.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>>m;\n        for(int i=0;i<nums.size();i++){\n            m[nums[i]].push_back(i);\n        }\n        vector<int>ans;\n        for(auto it:queries){\n            int val=nums[it];\n            if(m[val].size()==1){\n                ans.push_back(-1);\n                continue;\n            }\n            auto it1=lower_bound(m[val].begin(),m[val].end(),it);\n            int ind1=it1-m[val].begin();\n            int x=0,y=0;\n            if(ind1>0){\n                x=m[val][ind1]-m[val][ind1-1];\n            }\n            else{\n                x=nums.size()-m[val].back()+m[val][0];\n            }\n            if(ind1<m[val].size()-1){\n                y=m[val][ind1+1]-m[val][ind1];\n            }\n            else{\n                y=nums.size()-m[val].back()+m[val][0];\n            }\n            ans.push_back(min(x,y));\n        }\n        return ans;\n    }\n};","author":"Fookin_Blinders","submissionId":"1575097547"},[{"id":"72","similarity":0.711864406779661,"totOverlap":126,"longestOverlap":20}]],"245":[{"id":"245","fileName":"1575107287.txt","sourceCode":"#define all(x) x.begin(),x.end()\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> loc;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            loc[nums[i]].push_back(i);\n        }\n\n        vector<int> res;\n        for (int idx: queries) {\n            int val = nums[idx];\n            if (loc[val].size() == 1) {  // unique\n                res.push_back(-1);\n                continue;\n            }\n            int i = distance(loc[val].begin(), lower_bound(all(loc[val]), idx));\n            int ans = 1 << 30;\n            if (i != 0) {\n                ans = min(ans, idx - loc[val][i - 1]);\n            } else {\n                ans = min(ans, idx + n - loc[val][loc[val].size() - 1]);\n            }\n            if (i != loc[val].size() - 1) {\n                ans = min(ans, loc[val][i + 1] - idx);\n            } else {\n                ans = min(ans, loc[val][0] + n - idx);\n            }\n            res.push_back(ans);\n        }\n        return res;\n    }\n};","author":"Patchy","submissionId":"1575107287"},[{"id":"245","similarity":0.7411764705882353,"totOverlap":126,"longestOverlap":18}]],"353":[{"id":"353","fileName":"1575112401.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> mp;\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(int i=0;i<queries.size();i++){\n            int temp=nums[queries[i]];\n            if((int)mp[temp].size()==1){\n                ans.push_back(-1);\n            }\n            else{\n                int tempa=-1;\n                int a=lower_bound(mp[temp].begin(),mp[temp].end(),queries[i])-mp[temp].begin();\n                if(a==0){\n                    tempa=(int)nums.size()-mp[temp][(int)mp[temp].size()-1]+mp[temp][a];\n                }\n                else{\n                    tempa=mp[temp][a]-mp[temp][a-1];\n                }\n                if(a==(int)mp[temp].size()-1){\n                    tempa=min(tempa,(int)nums.size()-mp[temp][a]+mp[temp][0]);\n                }\n                else{\n                    tempa=min(tempa,mp[temp][a+1]-mp[temp][a]);\n                }\n                ans.push_back(tempa);\n            }\n        }\n        return ans;\n    }\n};","author":"Siddh Doshi","submissionId":"1575112401"},[{"id":"353","similarity":0.7198275862068966,"totOverlap":167,"longestOverlap":9}]],"425":[{"id":"425","fileName":"1575115098.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int maxi = *max_element(nums.begin(), nums.end());\n        vector<vector<int>> v(maxi+1);\n        for(int i = 0 ; i < nums.size() ; i++)\n                v[nums[i]].push_back(i);\n        vector<int> ret;\n        for(auto &val:queries){\n            int ele = nums[val];\n            if(v[ele].size()==1){\n                ret.push_back(-1);\n            }\n            else{\n                int ind = lower_bound(v[ele].begin(), v[ele].end(), val) - v[ele].begin();\n                // cout<<val<<\" \"<<ind<<endl;\n                int prev = -1, next = -1;\n                int ans = n;\n                if(ind == 0){\n                    ans = min(ans, v[ele][ind+1] - v[ele][ind]);\n                    ans = min(ans, v[ele][ind]+n - v[ele].back());\n                }else if(ind==(v[ele].size()-1)){\n                    ans = min(ans, v[ele][ind] - v[ele][ind-1]);\n                    ans = min(ans, v[ele][0]+n - v[ele][ind]);\n                }\n                else{\n                    ans = min(ans, v[ele][ind] - v[ele][ind-1]);\n                    ans = min(ans, v[ele][ind+1] - v[ele][ind]);\n                }\n                ret.push_back(ans);\n            }\n        }\n        return ret;\n    }\n};","author":"Dhiraj Patil","submissionId":"1575115098"},[{"id":"1115","similarity":0.744,"totOverlap":186,"longestOverlap":15},{"id":"1115","similarity":0.7948717948717948,"totOverlap":186,"longestOverlap":14},{"id":"1187","similarity":0.7217741935483871,"totOverlap":179,"longestOverlap":24},{"id":"1241","similarity":0.7004048582995951,"totOverlap":173,"longestOverlap":8},{"id":"1115","similarity":0.7198275862068966,"totOverlap":167,"longestOverlap":9},{"id":"1115","similarity":0.7568807339449541,"totOverlap":165,"longestOverlap":15},{"id":"1115","similarity":0.7018348623853211,"totOverlap":153,"longestOverlap":10},{"id":"580","similarity":0.7357512953367875,"totOverlap":142,"longestOverlap":19},{"id":"1124","similarity":0.7037037037037037,"totOverlap":133,"longestOverlap":19},{"id":"950","similarity":0.711864406779661,"totOverlap":126,"longestOverlap":20},{"id":"950","similarity":0.7411764705882353,"totOverlap":126,"longestOverlap":18}]],"580":[{"id":"580","fileName":"1575119663.txt","sourceCode":"class Solution {\npublic:\n    \n    vector<int> solveQueries(vector<int>& nums, vector<int>& qu) {\n        map<int,vector<int>>mp;\n        int n=nums.size();\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int>res;\n        for(int i=0;i<qu.size();i++){\n            int uy=nums[qu[i]];\n            int ind=qu[i];\n            if(mp[uy].size()==1){\n                res.push_back(-1);\n            }\n            else{\n                int opl=upper_bound(mp[uy].begin(),mp[uy].end(),ind)-mp[uy].begin();\n                int si=mp[uy].size();\n                int opk=1e9;\n                if(opl==si){\n                    opk=min(opk,n-ind+mp[uy][0]);\n                }\n                else{\n                    opk=min(opk,mp[uy][opl]-ind);\n                }\n                if(opl==1){\n                   opk=min(opk,ind+n-mp[uy].back());\n                    \n                }  \n                else{\n                    opk=min(opk,ind-mp[uy][opl-2]);\n                }\n                res.push_back(opk);\n\n                \n                \n\n                \n            }\n            \n        }\n        return res;\n    }\n};","author":"nitin","submissionId":"1575119663"},[{"id":"1169","similarity":0.784688995215311,"totOverlap":164,"longestOverlap":20},{"id":"1169","similarity":0.7030567685589519,"totOverlap":161,"longestOverlap":16},{"id":"353","similarity":0.7357512953367875,"totOverlap":142,"longestOverlap":19}]],"705":[{"id":"705","fileName":"1575122883.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>>mp;\n        int n = nums.size();\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int>ans;\n        for(auto&i:queries){\n            int num = nums[i];\n            int m = mp[num].size();\n            if(m==1){\n                ans.push_back(-1);\n                continue;\n            }\n            int idx = lower_bound(mp[num].begin(),mp[num].end(),i)-mp[num].begin();\n            int mn;\n            if(idx>0){\n                mn = mp[num][idx]-mp[num][idx-1];\n            }\n            else{\n                mn = mp[num][idx] + (n-mp[num][m-1]);\n            }\n            if(idx<m-1){\n                mn = min(mn,mp[num][idx+1]-mp[num][idx]);\n            }\n            else{\n                mn = min(mn,mp[num][0] + (n-mp[num][idx]));\n            }\n            ans.push_back(mn);\n        }\n        return ans;\n    }\n};","author":"Sangram","submissionId":"1575122883"},[{"id":"705","similarity":0.7018348623853211,"totOverlap":153,"longestOverlap":10}]],"950":[{"id":"950","fileName":"1575129229.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> m;\n        int n = nums.size();\n        for(int i=0;i<nums.size();i++) {\n            m[nums[i]].push_back(i);\n        }\n        // for(auto x: m) {\n        //     cout<<x.first<<\": \";\n        //     for(auto y:x.second) {\n        //         cout<<y<<\" \";\n        //     }\n        //     cout<<endl;\n        // }\n        vector<int> ret;\n        for(auto x: queries) {\n            int t = nums[x];\n            if(m[t].size()==1) {\n                ret.push_back(-1);\n                continue;\n            }\n            int pos = lower_bound(m[t].begin(), m[t].end(), x) - m[t].begin();\n            int ans = INT_MAX;\n            if(pos > 0) {\n                ans = min(ans, m[t][pos]-m[t][pos-1]);\n            } else {\n                ans = min(ans, n-m[t][m[t].size()-1]+m[t][pos]);\n            }\n            if(pos<m[t].size()-1) {\n                ans = min(ans, m[t][pos+1]-m[t][pos]);\n            } else {\n                ans = min(ans, n-m[t][pos]+m[t][0]);\n            }\n            ret.push_back(ans);\n        }\n        return ret;\n    }\n};","author":"guptasuchit","submissionId":"1575129229"},[{"id":"950","similarity":0.7568807339449541,"totOverlap":165,"longestOverlap":15}]],"1088":[{"id":"1088","fileName":"1575132796.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& que) {\n        int n = nums.size();\n        map<int, vector<int>> m;\n        for(int i = 0; i < n; i++){\n            m[nums[i]].push_back(i);\n        }\n        int q = que.size();\n        vector<int> res(q);\n        for(int i = 0; i < q; i++){\n            int ele = nums[que[i]];\n            if(m[ele].size() == 1){\n                res[i] = -1;\n            }\n            else{\n                int idx1 = lower_bound(m[ele].begin(), m[ele].end(), que[i]) - m[ele].begin();\n                int minn = 10000000;\n                if(idx1 > 0){\n                    int dist = m[ele][idx1] - m[ele][idx1 - 1];\n                    minn = min(minn, dist);\n                    if(idx1 == m[ele].size() - 1){\n                        minn = min(minn, n - m[ele][idx1] + m[ele][0]);\n                    }\n                    else{\n                        minn = min(minn, m[ele][idx1 + 1] - m[ele][idx1]);\n                    }\n                }\n                else{\n                    minn = min(minn, m[ele][idx1 + 1] - m[ele][idx1]);\n                    minn = min(minn, n - m[ele][m[ele].size() - 1] + m[ele][0]);\n                }\n                res[i] = minn;\n            }\n        }\n        return res;\n    }\n};","author":"Ishit_7788","submissionId":"1575132796"},[{"id":"1088","similarity":0.7948717948717948,"totOverlap":186,"longestOverlap":14}]],"1115":[{"id":"1115","fileName":"1575133532.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n = nums.size(), m = q.size();\n        unordered_map<int, vector<int> > mp;\n        for(int i=0; i<n; i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(int i=0; i<m; i++){\n            int idx = q[i], num = nums[q[i]];\n            if(mp[num].size() == 1) ans.push_back(-1);\n            else{\n                int k = mp[num].size();\n                int j = lower_bound(mp[num].begin(), mp[num].end(), idx) - mp[num].begin();\n                int res = INT_MAX;\n                if(j == 0){\n                    res = min(res, mp[num][k-1] - mp[num][0]);\n                    res = min(res, n - mp[num][k-1] + mp[num][j]);\n                }\n                else{\n                    res = min(res, mp[num][j] - mp[num][j-1]);\n                    res = min(res, n - mp[num][j] + mp[num][j-1]);\n                }\n                if(j < k-1){\n                    res = min(res, mp[num][j+1] - mp[num][j]);\n                    res = min(res, n - mp[num][j+1] + mp[num][j]);\n                }\n                else{\n                    res = min(res, mp[num][j] - mp[num][0]);\n                    res = min(res, n - mp[num][j] + mp[num][0]);\n                }\n                ans.push_back(res);\n            }\n        }\n        return ans;\n    }\n};","author":"Prakhar Gupta","submissionId":"1575133532"},[{"id":"425","similarity":0.744,"totOverlap":186,"longestOverlap":15}]],"1124":[{"id":"1124","fileName":"1575133753.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        int n = nums.size();\n        for(int i=0; i<n; i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(auto &query: queries){\n            int element = nums[query];\n            int idx = lower_bound(mp[element].begin(), mp[element].end(), query) - mp[element].begin();\n            int low = idx - 1;\n            int up = idx + 1;\n            int a = INT_MAX;\n            if(low >= 0){\n                a = min(a, mp[element][idx] - mp[element][low]);\n            }\n            if(up < mp[element].size()){\n                a = min(a, mp[element][up] - mp[element][idx]);\n            }\n            if((idx == 0 || idx == mp[element].size()-1) && mp[element].size() > 1){\n                a = min(a, (n - mp[element][mp[element].size()-1]) + mp[element][0]);\n            }\n            if(a == INT_MAX){\n                a = -1;\n            }\n            ans.push_back(a);\n        }\n        return ans;\n    }\n};","author":"Bhavin191","submissionId":"1575133753"},[{"id":"950","similarity":0.7037037037037037,"totOverlap":133,"longestOverlap":19}]],"1152":[{"id":"1152","fileName":"1575134380.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n =nums.size();\n        vector<int> ans;\n        map<int,vector<int>> mp;\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n\n        for(int i=0;i<queries.size();i++){\n            int el = nums[queries[i]];\n            if(mp[el].size()==1){\n                ans.push_back(-1);\n            }\n            else{\n                int len = mp[el].size();\n                int man = lower_bound(mp[el].begin(),mp[el].end(),queries[i]) -mp[el].begin();\n                if(man == 0){\n                    int diff1 = mp[el][1]-mp[el][0];\n                    int diff2 = mp[el][0]+n - *mp[el].rbegin();\n                    ans.push_back(min(diff1,diff2));\n                }\n                else if(man == len-1){\n                    int diff1 = mp[el][man]-mp[el][man-1];\n                    int diff2 = mp[el][0]+n - *mp[el].rbegin();\n                    ans.push_back(min(diff1,diff2));\n                }\n                else{\n                    int diff1 = mp[el][man]-mp[el][man-1];\n                    int diff2 = mp[el][man+1]- mp[el][man];\n                    ans.push_back(min(diff1,diff2));\n                }\n            }\n            \n        }\n        return ans;\n    }\n};","author":"Manish Sharma","submissionId":"1575134380"},[{"id":"1152","similarity":0.7030567685589519,"totOverlap":161,"longestOverlap":16}]],"1169":[{"id":"1169","fileName":"1575134802.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> mp;\n        vector<int> v;\n\n        int n = nums.size();\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n\n        for(int i=0;i<queries.size();i++){\n            int num = nums[queries[i]];\n            int idx = queries[i];\n            if(mp[num].size()<2){\n                v.push_back(-1);\n            }\n            else{\n                int mini = INT_MAX;\n                int si = mp[num].size();\n                int low = lower_bound(mp[num].begin(),mp[num].end(),idx) - mp[num].begin();\n                // cout<<idx<<endl;\n                if(low==0){\n                    mini = min((mp[num][1] - mp[num][0]),(n-mp[num][si-1] + mp[num][0]));\n                }\n                else if(low==si-1){\n                    mini = min((mp[num][si-1] - mp[num][si-2]),(n-mp[num][si-1] + mp[num][0]));\n                }\n                else{\n                    mini = min((mp[num][low+1] - mp[num][low]),(mp[num][low] - mp[num][low-1]));\n                }\n\n                v.push_back(mini);\n            }\n        }\n        return v;\n    }\n};","author":"Kaustubh Jaitapkar","submissionId":"1575134802"},[{"id":"580","similarity":0.784688995215311,"totOverlap":164,"longestOverlap":20}]],"1187":[{"id":"1187","fileName":"1575135413.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int  q= queries.size();\n\n        unordered_map<int,vector<int>>mpp;\n        for(int i = 0;i < n; i++){\n            mpp[nums[i]].push_back(i);\n        }\n        vector<int>ans;\n        for(int i = 0 ;i < q; i++){\n            int idx = queries[i];\n            int num = nums[idx];\n            if(mpp[num].size() <= 1){\n                ans.push_back(-1);\n                continue;\n            }\n\n            int idx2 = lower_bound(mpp[num].begin(),mpp[num].end(),idx)- mpp[num].begin();\n            int temp ;\n            if(idx2 == 0){\n                temp = mpp[num][idx2+1]-mpp[num][idx2];\n\n                temp = min(temp,mpp[num][idx2] + n - mpp[num][mpp[num].size()-1]);\n\n                ans.push_back(temp);\n            }\n            else if(idx2 ==( mpp[num].size() -1)){\n                temp = mpp[num][idx2]-mpp[num][idx2-1];\n\n                temp = min(temp,-mpp[num][idx2] + n + mpp[num][0]);\n\n                ans.push_back(temp);\n            }\n            else{\n                temp = min(mpp[num][idx2] - mpp[num][idx2-1],mpp[num][idx2+1]-mpp[num][idx2]);\n                ans.push_back(temp);\n            }\n        }\n        return ans;\n    }\n};","author":"Yug Desai","submissionId":"1575135413"},[{"id":"1115","similarity":0.7217741935483871,"totOverlap":179,"longestOverlap":24}]],"1241":[{"id":"1241","fileName":"1575136779.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& v, vector<int>& q) {\n        map<int,vector<int>> mp;\n        for(int i=0;i<v.size();i++){\n            mp[v[i]].push_back(i);\n        }\n        int n=v.size();\n        vector<int> res;\n        for(int i=0;i<q.size();i++){\n            if(mp[v[q[i]]].size()==1) res.push_back(-1);\n            else{\n                int ans =INT_MAX;\n                int val = v[q[i]];\n                int ind = lower_bound(mp[val].begin(),mp[val].end(), q[i]) - mp[val].begin();\n                if(ind==0){\n                    ans=min(ans,mp[val][ind+1]-q[i]);\n                    ans=min(ans,n-1-mp[val].back()+q[i]+1);\n                }else if(ind==mp[val].size()-1){\n                    // cout<<\"yes \"<<val<<endl;\n                    ans=min(ans,abs(n-q[i]+mp[val][0]));\n                    ans=min(ans,abs(q[i]-mp[val][ind-1]));\n                }else{\n                    ans=min(ans,q[i]-mp[val][ind-1]);\n                    ans=min(ans,mp[val][ind+1]-q[i]);\n                }\n                res.push_back(ans);\n            }\n        }\n        return res;\n    }\n};","author":"whiz_guy","submissionId":"1575136779"},[{"id":"1115","similarity":0.7004048582995951,"totOverlap":173,"longestOverlap":8}]]},{"427":[{"id":"427","fileName":"1575115082.txt","sourceCode":"#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nclass Solution {\npublic:\n    inline int cd(int a, int b, int n) {\n        int d = abs(a - b);\n        d = min(d, n - d);\n        return d;\n    }\n    \n    inline void bop(int &x) {\n        x = x | 0;\n        x = x & 1;\n        x = x ^ 0;\n    }\n    \n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        int i = 0;\n        while(i < n) {\n            mp[nums[i]].push_back(i);\n            int tmp = i;\n            bop(tmp);\n            i++;\n        }\n        auto it = mp.begin();\n        while(it != mp.end()){\n            sort(it->second.begin(), it->second.end());\n            int dum = 0;\n            bop(dum);\n            ++it;\n        }\n        \n        vector<int> res;\n        res.reserve(queries.size());\n        int j = 0;\n        while(j < queries.size()){\n            int q = queries[j];\n            int v = nums[q];\n            auto &vec = mp[v];\n            if(vec.size() < 2) {\n                res.push_back(-1);\n                j++;\n                continue;\n            }\n            auto posIt = lower_bound(vec.begin(), vec.end(), q);\n            int pos = posIt - vec.begin();\n            int li = (pos - 1 + vec.size()) % vec.size();\n            int ri = (pos + 1) % vec.size();\n            int lc = vec[li], rc = vec[ri];\n            int dl = cd(q, lc, n);\n            int dr = cd(q, rc, n);\n            res.push_back(min(dl, dr));\n            int dum2 = j;\n            bop(dum2);\n            j++;\n        }\n        return res;\n    }\n};\n","author":"G123df","submissionId":"1575115082"},[]]},{"428":[{"id":"428","fileName":"1575115191.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        pos = defaultdict(list)\n        for i, v in enumerate(nums):\n            pos[v].append(i)\n            \n        res = [-1] * len(queries)\n        for i, q in enumerate(queries):\n            v = nums[q]\n            if len(pos[v]) != 1:\n                i1 = bisect_left(pos[v], q)\n                L = len(pos[v])\n                prev, after = (i1 - 1)%L, (i1 + 1)%L\n                a1, a2 = pos[v][prev], pos[v][after]\n                res[i] = min(min(abs(q-a2), len(nums)-abs(q-a2)), min(abs(q-a1), len(nums)-abs(q-a1)))\n        return res\n            \n        ","author":"SMH","submissionId":"1575115191"},[]]},{"429":[{"id":"429","fileName":"1575115229.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        map<int,set<int>> m;\n        int n = a.size();\n        // for(int i=0;i<n;i++){\n        //     a.push_back(a[i]);\n        // }\n        \n        for(int i=0;i<n;i++){\n            m[a[i]].insert(i);\n        }\n        vector<int> ans;\n        for(auto k:q){\n            int val = a[k];\n            auto it = m[val].find(k);\n            if(m[val].size()==1){\n                ans.push_back(-1);\n                continue;\n            }\n            cout<<*it<<\" : \";\n            auto prev = m[val].find(k);\n            auto next = m[val].find(k);\n            int as = INT_MAX;\n            if(prev!=m[val].begin()){\n                prev--;\n                as = min(as, abs(*it-*prev));\n            cout<<*prev<<\" p \";\n            }\n            next++;\n            if(next!=m[val].end()){\n                as = min(as, abs(*it-*next));\n            }\n\n            if(it!=m[val].begin()){\n                as = min(as, abs(*it-*m[val].begin()));\n                as = min(as, abs(*it-(n+*m[val].begin())));\n            }\n            if(it!=--m[val].end()){\n                auto it2 = --m[val].end();\n                as = min(as, abs(*it-*it2));\n                as = min(as, abs((*it+n)-*it2));\n                // as \n            }\n\n            \n            cout<<endl;\n            ans.push_back(as);\n        }\n        return ans;\n    }\n};","author":"Ashray Tiwari","submissionId":"1575115229"},[]]},{"430":[{"id":"430","fileName":"1575115205.txt","sourceCode":"class Solution {\npublic:\n    int calc(int i1, int i2, int n) {\n        int output = abs(i1 - i2);\n        \n        return min(output, n - output);\n    }\n    \n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> m;\n        int n = nums.size();\n        vector<int> ans(n, INT_MAX);\n        \n        for (int i=0;i<n;i++) m[nums[i]].push_back(i);\n        \n        for (auto &pr: m) {\n            int x = pr.second.size();\n            if (x == 1) continue;\n            for (int i=0;i<pr.second.size();i++) {\n                ans[pr.second[i]] = min(ans[pr.second[i]], calc(pr.second[i], pr.second[(i + 1) % x], n));\n                ans[pr.second[i]] = min(ans[pr.second[i]], calc(pr.second[i], pr.second[(i - 1 + x) % x], n));\n            }\n        }\n        \n        vector<int> output;\n        for (int i: queries) {\n            if (ans[i] == INT_MAX) output.push_back(-1);\n            else output.push_back(ans[i]);\n        }\n        return output;\n    }\n};","author":"Aitijhya Modak","submissionId":"1575115205"},[]]},{"431":[{"id":"431","fileName":"1575115232.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,set<int>> mp;\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]].insert(i);\n        }\n        vector<int> ans;\n        for(auto x : queries){\n            int num = nums[x];\n            if(mp[num].size()==1) ans.push_back(-1);\n            else{\n                auto it = mp[num].lower_bound(x);\n                if(it == mp[num].begin()){\n                    it++;int y = *it;\n                    int z = *mp[num].rbegin();\n                    int res = min(y-x,(int)(nums.size()+x-z));\n                    ans.push_back(res);\n                }\n                else{\n                    it++;\n                    if(it == mp[num].end()){\n                        int y = *mp[num].begin();\n                        --it;--it;\n                        int z = *it;\n                        int res = min((int)(y+nums.size()-x),x-z);\n                        ans.push_back(res);\n                    }\n                    else{\n                        int z = *it;\n                        --it;--it;\n                        int y = *it;\n                        int res = min(x-y,z-x);\n                        ans.push_back(res);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};","author":"Naveen Khuntey","submissionId":"1575115232"},[]]},{"432":[{"id":"432","fileName":"1575115275.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d=defaultdict(lambda:[])\n        m=len(nums)\n        for i in range(len(nums)):\n            d[nums[i]].append(i)\n        ar=[0 for i in range(m)]\n        for i in d:\n            temp=d[i]\n            n=len(d[i])\n            if n==1:\n                ar[temp[0]]=-1\n            else:\n                for j in range(n):\n                    ar[temp[j]]=min((temp[(j+1)%n]-temp[j]+m)%m,(temp[j]-temp[(n+j-1)%n]+m)%m)\n        ans=[]\n        for q in queries:\n            ans.append(ar[q])\n        return ans","author":"Nikhil Nyalakanti","submissionId":"1575115275"},[]]},{"433":[{"id":"433","fileName":"1575115246.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        pos = collections.defaultdict(list)\n        for i, n in enumerate(nums):\n            pos[n].append(i)\n        for key in pos:\n            arr = [v + len(nums) for v in pos[key]]\n            pos[key].extend(arr)\n        \n        res = []\n        for q in queries:\n            val = nums[q]\n            if len(pos[val]) <= 2:\n                res.append(-1)\n                continue\n            \n            #print(q, val, pos[val])\n            \n            p1 = bisect.bisect_left(pos[val], q)\n            p2 = bisect.bisect_left(pos[val], q + len(nums))\n            \n            #print(p1, p2)\n            \n            arr = []\n            arr.append([pos[val][p1+1] - q, pos[val][p1+1]])            \n            arr.append([q+len(nums) - pos[val][p2-1], pos[val][p2-1]])\n            arr.sort()\n            \n            #print(arr)\n            \n            res.append(arr[0][0])\n        \n        return res","author":"tinyfish1","submissionId":"1575115246"},[]]},{"434":[{"id":"434","fileName":"1575115270.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] qs) {\n        int n = nums.length;\n        List<Integer> ans = new ArrayList<>();\n        Map<Integer, Integer> map = new HashMap<>();\n        Map<Integer, TreeSet<Integer>> tmap = new HashMap<>();\n        for(int i=0; i<n; i++) {\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\n            if(tmap.get(nums[i]) == null) {\n                tmap.put(nums[i], new TreeSet<>());\n            }\n            \n            tmap.get(nums[i]).add(i);\n            tmap.get(nums[i]).add(i + n);\n            tmap.get(nums[i]).add(i - n);\n        }\n        \n        for(int q: qs) {\n            if(map.get(nums[q]) == 1) {\n                ans.add(-1);\n                continue;\n            }\n            \n            int nidx = tmap.get(nums[q]).higher(q);\n            int pidx = tmap.get(nums[q]).lower(q);\n            ans.add(Math.min(Math.abs(pidx - q), Math.abs(nidx - q)));\n        }\n        \n        return ans;\n    }\n}","author":"Saurabh_082","submissionId":"1575115270"},[]]},{"435":[{"id":"435","fileName":"1575115438.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>>mp;\n        const int n = nums.size();\n        for(int i=0;i<nums.size();++i) mp[nums[i]].push_back(i);\n        vector<int> ans;\n\n        auto get_dist = [&](int i,int j)->int{\n            return min( (i-j+n)%n, (j-i+n)%n);\n        };\n\n        for(int idx: queries){\n            int ai = nums[idx];\n            vector<int> &vec = mp[ai];\n\n            if(vec.size() == 1) ans.push_back(-1);\n            else if(vec.size() == 2){\n                int o = vec[0] + vec[1] - idx;\n                ans.push_back(get_dist(o,idx));\n            } else {\n                const int sz = vec.size();\n                int j = lower_bound(begin(vec), end(vec), idx) - begin(vec);\n                int j1 = vec[(j-1+sz)%sz], j2 = vec[(j+1+sz)%sz];\n\n                int dist = min( get_dist(j1,idx) , get_dist(j2,idx));\n                ans.push_back(dist);\n            }\n        }\n        return ans;\n    }\n};","author":"Ayush Saluja","submissionId":"1575115438"},[]]},{"436":[{"id":"436","fileName":"1575115358.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        h_map = defaultdict(list)\n        n = len(nums)\n\n        for i, num in enumerate(nums):\n            h_map[num].append(i)\n\n        # print(h_map)\n\n        \n        # res = {}\n\n        # for num in h_map.keys():\n        #     arr = h_map[num]\n        #     m = len(arr)\n        #     if m == 1:\n        #         res[num] = -1\n        #         continue\n            \n        #     cur_min = n - arr[-1] + arr[0]\n            \n\n        #     for i in range(1, m):\n        #         cur_min = min(cur_min, arr[i] - arr[i-1])\n\n        #     res[num] = cur_min\n\n        ans = []\n\n        def bin_search(num, arr):\n            l = 0\n            r = len(arr) - 1\n\n            while l <= r:\n                mid = (l + r) // 2\n\n                if arr[mid] == num:\n                    return mid\n                elif arr[mid] > num:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            \n        \n        for q in queries:\n            # print(nums[q], h_map[nums[q]])\n            arr = h_map[nums[q]]\n            m = len(arr)\n            if len(h_map[nums[q]]) == 1:\n                ans.append(-1)\n                continue\n\n            idx = bin_search(q, arr)\n            # print(idx, arr)\n            if idx == 0:\n                ans.append(min(arr[idx+1] - arr[idx], n - arr[-1] + arr[0]))\n            elif idx == m-1:\n                ans.append(min(arr[idx] - arr[idx-1], n - arr[idx] + arr[0]))\n            else:\n                ans.append(min(arr[idx] - arr[idx-1], arr[idx+1] - arr[idx]))\n            \n\n            \n            # print(bin_search(q, h_map[nums[q]]))\n            \n            \n\n        return ans\n            \n            \n            ","author":"minson1","submissionId":"1575115358"},[]]},{"437":[{"id":"437","fileName":"1575115273.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define FOR(i, a, b) for(ll i = a; i <= b; i++)\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        ll n = nums.size();\n        \n        map<ll, set<ll>> mp;\n        for(ll i = 0; i < nums.size(); i++){\n            if(mp.find(nums[i]) == mp.end()){\n                set<ll> st;\n                mp.insert({nums[i], st});\n            }\n\n            mp[nums[i]].insert(i);\n        }\n\n        vector<int> r;\n        for(ll idx : queries){\n            ll dist = 100005;\n            if(*mp[nums[idx]].begin() != idx){\n                dist = min({dist, abs(*mp[nums[idx]].begin() - idx), n - abs(*mp[nums[idx]].begin() - idx)});\n            }\n            if(*mp[nums[idx]].rbegin() != idx){\n                dist = min({dist, abs(*mp[nums[idx]].rbegin() - idx), n - abs(*mp[nums[idx]].rbegin() - idx)});\n            }\n            \n            if(mp[nums[idx]].size() >= 2){\n                auto it = mp[nums[idx]].lower_bound(idx);\n\n                if(it != mp[nums[idx]].begin()){\n                    dist = min({dist, abs(*prev(it) - idx), n - abs(*prev(it) - idx)});\n                }\n                if(next(it) != mp[nums[idx]].end()){\n                    dist = min({dist, abs(*next(it) - idx), n - abs(*next(it) - idx)});\n                }\n            }\n\n            if(dist == 100005) r.push_back(-1);\n            else r.push_back(dist);\n        }\n\n        return r;\n    }\n};","author":"Pearl Yu","submissionId":"1575115273"},[]]},{"439":[{"id":"439","fileName":"1575115188.txt","sourceCode":"impl Solution {\n    pub fn solve_queries(nums: Vec<i32>, queries: Vec<i32>) -> Vec<i32> {\n        let maxv = *nums.iter().max().unwrap();\n        let mut num_positions = vec![vec![]; maxv as usize + 1];\n        for (i, num) in nums.iter().enumerate() {\n            num_positions[*num as usize].push(i);\n        }\n        queries.iter().map(|&q| {\n            let idx = q as usize;\n            let positions = &num_positions[nums[idx] as usize];\n            let n = positions.len();\n            if n == 1 {\n                -1\n            } else {\n                let p = positions.binary_search(&idx).unwrap();\n                let left = if p == 0 { positions[n - 1] } else { positions[p - 1] };\n                let right = if p == n-1 { positions[0] } else { positions[p + 1] };\n                let n = nums.len();\n                idx.abs_diff(left)\n                .min(idx.abs_diff(right))\n                .min(idx.abs_diff(left + n))\n                .min(idx.abs_diff(right + n))\n                .min(left.abs_diff(idx + n))\n                .min(right.abs_diff(idx + n)) as i32\n            }\n        }).collect()\n    }\n}","author":"Mikko","submissionId":"1575115188"},[]]},{"440":[{"id":"440","fileName":"1575115482.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> pos;\n        for (int i = 0; i < n; i++) {\n            pos[nums[i]].push_back(i);\n        }\n        \n        unordered_map<int, unordered_map<int, int>> ansMap;\n        for (auto [val, indices] : pos) {\n            sort(indices.begin(), indices.end());\n            int k = indices.size();\n            if (k == 1) {\n                ansMap[val][indices[0]] = -1;\n            } else {\n                for (int i = 0; i < k; i++) {\n                    int curr = indices[i];\n                    int diffPrev = (i == 0) ? (indices[0] + n - indices[k - 1]) : (indices[i] - indices[i - 1]);\n                    int diffNext = (i == k - 1) ? (indices[0] + n - indices[k - 1]) : (indices[i + 1] - indices[i]);\n                    ansMap[val][curr] = min(diffPrev, diffNext);\n                }\n            }\n        }\n    \n        vector<int> res;\n        for (int q : queries) {\n            int val = nums[q];\n            res.push_back(ansMap[val][q]);\n        }\n        return res;\n    }\n};","author":"wayjiang","submissionId":"1575115482"},[]]},{"441":[{"id":"441","fileName":"1575115481.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, set<int>> m;\n        int n = nums.size();\n\n        for (int i = 0; i < n; i++) m[nums[i]].insert(i);\n\n        vector<int> res;\n        for (auto q : queries) {\n            int x = nums[q];\n            if (m[x].size() == 1) {\n                res.push_back(-1);\n                continue;\n            }\n\n            auto it = m[x].find(q);\n            int ans = INT_MAX;\n\n            if (it != m[x].begin()) {\n                auto l = prev(it);\n                ans = min(ans, *it - *l);\n            }\n\n            if (next(it) != m[x].end()) {\n                auto r = next(it);\n                ans = min(ans, *r - *it);\n            }\n\n            int first = *m[x].begin();\n            int last = *m[x].rbegin();\n            ans = min({ans, n - abs(q - first), n - abs(q - last)});\n\n            res.push_back(ans);\n        }\n        return res;\n    }\n};\n","author":"7saken","submissionId":"1575115481"},[]]},{"442":[{"id":"442","fileName":"1575115510.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> m1;\n        int n = nums.size();\n        for(int i=0;i<n;i++){\n            m1[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(auto&it:queries){\n            if(m1.find(nums[it])==m1.end() || m1[nums[it]].size()==1){\n                ans.push_back(-1);\n                continue;\n            }\n            auto& v = m1[nums[it]];\n            int sz = v.size();\n            auto prev = lower_bound(v.begin(),v.end(),it) - v.begin() - 1;\n            auto nxt = upper_bound(v.begin(),v.end(),it) - v.begin();\n            int res = n+2;\n            if(prev>=0 && prev<sz){\n                res = min({res,it-v[prev], n - it + v[prev]});\n            }\n            if(nxt>=0 && nxt<sz){\n                res = min({res,v[nxt]-it, n - v[nxt] + it});\n            }\n            if(v[0]!=it){\n                res = min({res,it-v[0], n - it + v[0]});\n            }\n            if(v[sz-1]!=it){\n                res = min({res,v[sz-1]-it, n - v[sz-1] + it});\n            }\n            ans.push_back(res);\n        }\n        return ans;\n    }\n};","author":"Dipjoy Basak","submissionId":"1575115510"},[]]},{"443":[{"id":"443","fileName":"1575115507.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int> > mp;\n        for(int i = 0; i < nums.size(); i++){\n            mp[nums[i]].push_back(i);\n        }\n        \n        vector<int> ans(queries.size());\n        for(int i = 0; i < queries.size(); i++){\n            int val = nums[queries[i]];\n            vector<int> &ivec = mp[val];\n            int idx = lower_bound(ivec.begin(), ivec.end(), queries[i]) - ivec.begin();\n            // for(auto &num : ivec){\n            //     cout << num << \" \";\n            // }\n            // cout << \"n\";\n            // cout<<idx << \"*n\";\n            ans[i] = INT_MAX;\n            if(mp[val].size() == 1)\n                ans[i] = -1;\n            if(idx >= 1)\n                ans[i] = min(ans[i], ivec[idx] - ivec[idx-1]);\n            else ans[i] = min(ans[i], int(nums.size()) - *ivec.rbegin() + ivec[idx]);\n            if(idx < ivec.size()-1)\n                ans[i] = min(ans[i], ivec[idx+1] - ivec[idx]);\n            else ans[i] = min(ans[i], int(nums.size()) - ivec[idx] + *ivec.begin());\n        }\n        return ans;\n    }\n};","author":"sellie50759","submissionId":"1575115507"},[]]},{"445":[{"id":"445","fileName":"1575115543.txt","sourceCode":"class Solution {\n\n    public int bin(ArrayList<Integer> al, int x, int n){\n        if(al.size()==1) return -1;\n        int st= 0;\n        int en= al.size()-1;\n        int ans= -1;\n        while(st<= en){\n            int mid=(st+en)/2;\n            if(al.get(mid) == x){\n                ans= mid;\n                break;\n            }\n            else if(al.get(mid)> x){\n                en= mid-1;\n            }\n            else st= mid+1;\n        }\n        int i= ans;\n        if(ans== 0){\n            return Math.min(al.get(i+1) - al.get(i), al.get(i) + n- al.get(al.size()-1));\n        }\n        else if(ans== al.size()-1){\n            return Math.min(al.get(i) - al.get(i-1), al.get(0) + n- al.get(i));\n        }\n        else{\n            return Math.min(al.get(i)- al.get(i-1), al.get(i+1)- al.get(i));\n        }\n        // return -1;\n    }\n    \n    public List<Integer> solveQueries(int[] nums, int[] q) {\n        HashMap<Integer, ArrayList<Integer>> hm = new HashMap();\n        ArrayList<Integer> res= new ArrayList();\n\n        for(int i=0;i<nums.length;i++){\n            ArrayList<Integer> al= hm.getOrDefault(nums[i], new ArrayList());\n            al.add(i);\n            hm.put(nums[i], al);\n        }\n        for(int i=0;i<q.length;i++){\n            int x= bin(hm.get(nums[q[i]]), q[i], nums.length);\n            res.add(x);\n        }\n        return res;\n    }\n}","author":"Kook12","submissionId":"1575115543"},[]]},{"446":[{"id":"446","fileName":"1575115611.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        def calcCircularDistance(idx1, idx2, total):\n            diff = abs(idx1 - idx2)\n            return diff if diff <= total - diff else total - diff\n\n        n = len(nums)\n        posMap = {}\n        for index, number in enumerate(nums):\n            if number not in posMap:\n                posMap[number] = []\n            posMap[number].append(index)\n\n        resultArr = [-1] * n\n        for number, indexList in posMap.items():\n            if len(indexList) < 2:\n                continue\n            indexList.sort()\n            totalOccurrences = len(indexList)\n            for j in range(totalOccurrences):\n                current = indexList[j]\n                nextPos = indexList[(j + 1) % totalOccurrences]\n                prevPos = indexList[j - 1]\n                distNext = calcCircularDistance(current, nextPos, n)\n                distPrev = calcCircularDistance(current, prevPos, n)\n                resultArr[current] = distNext if distNext < distPrev else distPrev\n\n        return [resultArr[q] for q in queries]\n\n        ","author":"Subicson M","submissionId":"1575115611"},[]]},{"449":[{"id":"449","fileName":"1575115513.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        locs = defaultdict(list)\n        res = []\n        for i, n in enumerate(nums):\n            locs[n].append(i)\n        for num, indexes in locs.items():\n            locs[num] = [indexes[-1] - len(nums)] + indexes\n            locs[num].append((locs[num][1] + len(nums)))\n        for q in queries:\n            if len(locs[nums[q]]) == 3:\n                res.append(-1)\n                continue\n            i = bisect_left(locs[nums[q]], q)\n            lt = abs(locs[nums[q]][i] - locs[nums[q]][i-1])\n            gt = abs(locs[nums[q]][i] - locs[nums[q]][i+1])\n            res.append(min(lt,gt))\n        return res\n            ","author":"thedude7181","submissionId":"1575115513"},[]]},{"450":[{"id":"450","fileName":"1575115773.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        N = len(nums)\n        pos = defaultdict(list)\n        for (idx, n) in enumerate(nums):\n            pos[n].append(idx)\n\n        print(pos)\n        out = []\n        \n        for idx in queries:\n            q = nums[idx]\n            if len(pos[q]) == 1:\n                out.append(-1)\n            else:\n                p = bisect_left(pos[q], idx)\n\n                if 0 < p < len(pos[q]) - 1:\n                    l, r = abs(idx - pos[q][p - 1]), abs(pos[q][p + 1] - idx)\n                elif p == 0:\n                    l, r = idx + abs(N - pos[q][-1]), abs(pos[q][p + 1] - idx)\n                elif p == len(pos[q]) - 1:\n                    l, r = abs(idx - pos[q][p-1]), N - idx + abs(pos[q][0])\n                out.append(min(l, r))\n\n        return out\n        ","author":"mcmcmc","submissionId":"1575115773"},[]]},{"451":[{"id":"451","fileName":"1575115545.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map <int,vector <int>> m;\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            m[nums[i]].emplace_back(i);\n        }\n        vector <int> ans(n);\n        for(auto it:m){\n            vector <int> tmp=it.second;\n            for(int i=0;i<tmp.size();i++){\n                int in=tmp[i];\n                if(tmp.size()==1){\n                    ans[in]=-1;\n                }\n                else{\n                    int tmpans=1e9;\n                    if(i+1<tmp.size()){\n                        tmpans=min(tmpans,tmp[i+1]-in);\n                    }\n                    else{\n                        int x=tmp[0];\n                        tmpans=min(tmpans,in-x);\n                        x+=n;\n                        tmpans=min(tmpans,x-in);\n                    }\n                    if(i-1>=0){\n                        tmpans=min(tmpans,in-tmp[i-1]);\n                    }\n                    else{\n                        int x=tmp[tmp.size()-1];\n                        tmpans=min(tmpans,x-in);\n                        tmpans=min(tmpans,in+n-x);\n                        \n                    }\n                    ans[in]=tmpans;\n                    \n                    \n                }\n            }\n        }\n        vector <int> fans;\n        for(int i=0;i<queries.size();i++){\n            fans.emplace_back(ans[queries[i]]);\n        }\n        return fans;\n    }\n};","author":"Manya_24","submissionId":"1575115545"},[]]},{"452":[{"id":"452","fileName":"1575115861.txt","sourceCode":"from collections import defaultdict\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n=len(nums)\n        ans=[n]*n\n        last=defaultdict(lambda :-1)\n        for i,a in enumerate(nums*2):\n            j=last[a]\n            if j!=-1:\n                ans[j%n]=min(ans[j%n],i-j)\n                ans[i%n] = min(ans[i%n], i-j)\n            last[a]=i\n        return [-1 if ans[i]==n else ans[i] for i in queries]\n\n","author":"M Kawa","submissionId":"1575115861"},[]]},{"453":[{"id":"453","fileName":"1575115816.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] A, int[]q) {\n        \n        int n = A.length;\n        \n        int[] B = new int[3*n];\n        for(int i = 0; i < n; i++){\n            \n            B[i] = B[i + n] = B[i + 2*n] = A[i];\n            \n        }\n        \n        //System.out.println(Arrays.toString(B));\n        \n        HashMap<Integer, TreeSet<Integer>> m = new HashMap<>();\n        for(int i = 0; i < 3*n; i++){\n            int x = B[i];\n            m.computeIfAbsent(x, k-> new TreeSet<Integer>()).add(i);\n            \n        }\n        \n        List<Integer> l = new ArrayList<>();\n        for(int i = 0; i < q.length; i++){\n            int x = q[i];\n            int y = A[x];\n            \n            TreeSet<Integer> set = m.get(y);\n            Integer low = set.lower(x + n);\n            Integer hig = set.higher(x + n);\n            \n            int min = Math.min(x + n- low, hig - (x + n));\n            if(min >= n){\n                l.add(-1);\n            }\n            else l.add(min);\n        }\n        return l;\n    }\n}","author":"gauss789","submissionId":"1575115816"},[]]},{"454":[{"id":"454","fileName":"1575115796.txt","sourceCode":"class Solution \n{\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) \n    {\n        ios::sync_with_stdio(false);\n        cin.tie(nullptr);\n        cout.tie(nullptr);\n        \n        int n = nums.size();\n        for(int i = 0; i < n; i++)\n            nums.push_back(nums[i]);\n        unordered_map<int, vector<int>> mp;\n        for(int i = 0; i < 2 * n; i++)\n            mp[nums[i]].push_back(i);\n        int m = queries.size();\n        vector<int> ans(m, -1);\n        for(int i = 0; i < m; i++)\n        {\n            int index = queries[i], value = nums[index];\n            if(mp.find(value) == mp.end() or mp[value].size() < 3)\n                continue;\n            vector<int> &array = mp[value];\n            auto lb = lower_bound(array.begin(), array.end(), index) - array.begin();\n            if(lb)\n                ans[i] = min(array[lb + 1] - array[lb], array[lb] - array[lb - 1]);\n            else\n                ans[i] = min(array[lb + 1] - array[lb], array[lb] + n - (array[array.size() - 1] - n));\n        }\n        return ans;\n    }\n};","author":"Suvendu Dalbehera","submissionId":"1575115796"},[]]},{"455":[{"id":"455","fileName":"1575115907.txt","sourceCode":"class Solution {\n    private int findMinDist(int idx,List<Integer> lst,int arrLen) {\n        if(lst.get(0)==idx) {\n            return Math.min(\n                lst.get(1)-lst.get(0),\n                lst.get(0)+arrLen-lst.get(lst.size()-1)\n            );\n        } else if(lst.get(lst.size()-1)==idx) {\n            return Math.min(\n                lst.get(lst.size()-1)-lst.get(lst.size()-2),\n                lst.get(0)+arrLen-lst.get(lst.size()-1)\n            );\n        } else {\n            int low = 0, high = lst.size()-1, mid;\n            while(low<=high) {\n                mid = (low+high)/2;\n                if(lst.get(mid)==idx) {\n                    return Math.min(\n                        lst.get(mid)-lst.get(mid-1),\n                        lst.get(mid+1)-lst.get(mid)\n                    );\n                } else if(lst.get(mid)>idx) {\n                    high=mid-1;\n                } else {\n                    low=mid+1;\n                }\n            }\n        }\n        return -2;\n    }\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer,List<Integer>> mp = new HashMap<>();\n        for(int i=0;i<nums.length;i++) {\n            if(!mp.containsKey(nums[i])) {\n                mp.put(nums[i],new ArrayList<>());\n            }\n            mp.get(nums[i]).add(i);\n        }\n        int len = queries.length;\n        List<Integer> ans = new ArrayList<>();\n        for(int i=0;i<len;i++) {\n            int idx = queries[i];\n            int val = nums[idx];\n            if(mp.get(val).size()==1) {\n                ans.add(-1);\n            } else {\n                ans.add(findMinDist(idx,mp.get(val),nums.length));\n            }\n        }\n        return ans;\n    }\n}","author":"Jaydutt","submissionId":"1575115907"},[]]},{"458":[{"id":"458","fileName":"1575115986.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        map<int,vector<int>> fr;\n        int n=a.size(),m=q.size();\n        for(int i=0;i<n;i++){\n            fr[a[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(int i=0;i<m;i++){\n            int j=a[q[i]];\n            if(fr[j].size()==1){\n                ans.push_back(-1);\n                continue;\n            }\n            auto it=lower_bound(fr[j].begin(),fr[j].end(),q[i]);\n            int left,right;\n            if(it==fr[j].begin()){\n                int x=*it;\n                int y=*fr[j].rbegin();\n                left=x+n-y;\n            }else{\n                int x=*it;\n                int y=*prev(it);\n                left=x-y;\n            }\n            if(next(it)==fr[j].end()){\n                int x=*it;\n                int y=*fr[j].begin();\n                right=n-1-x+y+1;\n            }else{\n                int x=*it;\n                int y=*next(it);\n                right=y-x;\n            }\n            ans.push_back(min(left,right));\n        }\n        return ans;\n    }\n};","author":"vedantgore_2004","submissionId":"1575115986"},[]]},{"459":[{"id":"459","fileName":"1575115879.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& queries) {\n        map<int, set<int>> M, M2;\n\n        int n = a.size();\n        for(int i=0; i<n; i++)\n            {\n                M[a[i]].insert(i);\n                M[a[i]].insert(n + i);\n                M2[a[i]].insert(n - i);\n                M2[a[i]].insert(- i);\n            }\n\n        vector<int> ret;\n\n        for(int q: queries)\n            {\n                auto itr = M[a[q]].lower_bound(q + 1);\n                auto itl = M2[a[q]].lower_bound(- q + 1);\n\n                cout << *itl << \" \" << *itr << \"n\";\n\n                int ans = min(*itr - q, *itl + q);\n\n                if(ans >= n) ret.push_back(-1);\n                else ret.push_back(ans);\n            }\n\n        return ret;\n    }\n};","author":"champ36","submissionId":"1575115879"},[]]},{"460":[{"id":"460","fileName":"1575116005.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        \n        int length = nums.length;\n        \n        for (int i = 0; i < length; i++) {\n            int num = nums[i];\n            \n            List<Integer> indices = map.get(num);\n            \n            if (indices == null) {\n                indices = new ArrayList<>();\n                map.put(num, indices);\n            }\n            \n            indices.add(i);\n        }\n        \n        int resultLength = queries.length;\n        \n        List<Integer> result = new ArrayList<>(resultLength);\n        \n        for (int i = 0; i < resultLength; i++) {\n            int q = queries[i];\n            \n            List<Integer> indices = map.get(nums[q]);\n            \n            if (indices == null) {\n                result.add(-1);\n            } else {\n                int size = indices.size();\n                \n                if (size == 1) {\n                    result.add(-1);\n                } else {\n                    int index = Collections.binarySearch(indices, q);\n                    \n                    int prevIndex = (index - 1 + size + size)%size;\n                    int nextIndex = (index + 1 + size + size)%size;\n                    \n                    int prev = indices.get(prevIndex);\n                    int next = indices.get(nextIndex);\n                    \n                    int dist1 = q > prev ? q - prev : q + length - prev;\n                    int dist2 = q < next ? next - q : next + length - q;\n                    \n                    result.add(Math.min(dist1, dist2));\n                }\n            }\n        }\n        \n        return result;\n    }\n}","author":"Taranovski","submissionId":"1575116005"},[]]},{"461":[{"id":"461","fileName":"1575116258.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        max_num = max(nums)\n        # positions of elements with value i\n        positions = [None] * (max_num + 1)\n\n        for i in range (0, max_num + 1):\n            positions[i] = []\n\n        for i in range (0, len(nums)):\n            positions[nums[i]].append(i)\n\n        for i in range (0, max_num + 1):\n            positions[i].sort()\n\n        # Do queries\n        result = []\n        for q in queries:\n            num = nums[q]\n            if len(positions[num]) == 1:\n                result.append(-1)\n                continue\n\n            if q == positions[num][0]:\n                min_distance = min(positions[num][1] - q, len(nums) + q - positions[num][-1])\n                result.append(min_distance)\n                continue\n            if q == positions[num][-1]:\n                min_distance = min(q - positions[num][-2], len(nums) + positions[num][0] - q)\n                result.append(min_distance)\n                continue\n\n            left = 0\n            right = len(positions[num])\n\n            while (left < right):\n                mid = (left + right) // 2\n                if q == positions[num][mid]:\n                    left = right = mid\n                elif q < positions[num][mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n\n            min_distance = min(positions[num][left+1] - q, q - positions[num][left-1])\n            result.append(min_distance)\n\n        return result\n                ","author":"tlh65","submissionId":"1575116258"},[]]},{"104":[{"id":"104","fileName":"1575100511.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        Map<Integer, Integer> l = new HashMap<>();\n        Map<Integer, Integer> r = new HashMap<>();\n        int[] a = new int[n];\n        for (int i=0; i<n; i++)\n            a[i] = Integer.MAX_VALUE;\n        for (int i=0; i<n; i++) {\n            if (!l.containsKey(nums[i])) {\n                l.put(nums[i], i);\n                r.put(nums[i], i);\n            } else {\n                int ll = l.get(nums[i]);\n                int rr = r.get(nums[i]);\n                a[i] = Math.min(i - rr, ll + n - i);\n                a[rr] = Math.min(a[rr], i - rr);\n                a[ll] = Math.min(a[ll], ll + n - i);\n                r.put(nums[i], i);\n            }\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int i=0; i<m; i++)\n            ans.add(a[queries[i]] == Integer.MAX_VALUE ? -1 : a[queries[i]]);\n        return ans;\n    }\n}","author":"yge2","submissionId":"1575100511"},[{"id":"104","similarity":0.7457627118644068,"totOverlap":132,"longestOverlap":8}]],"157":[{"id":"157","fileName":"1575103799.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        int[] dist = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        Map<Integer, Integer> m = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            if (m.containsKey(nums[i]))\n                dist[i] = Math.min(dist[i], i - m.get(nums[i]));\n            m.put(nums[i], i);\n        }\n        \n        for (int i = n; i < 2 * n; i++) {\n            int j = i - n;\n            if (m.containsKey(nums[j]))\n                dist[j] = Math.min(dist[j], i - m.get(nums[j]));\n            m.put(nums[j], i);\n        }\n        \n        m = new HashMap<>();\n        for (int i = 2 * n - 1; i >= n; i--)    {\n            int j = i - n;\n            if (m.containsKey(nums[j]))\n                dist[j] = Math.min(dist[j], m.get(nums[j]) - i);\n            m.put(nums[j], i);\n        }\n        \n        for (int i = n - 1; i >= 0; i--)    {\n            if (m.containsKey(nums[i]))\n                dist[i] = Math.min(dist[i], m.get(nums[i]) - i);\n            m.put(nums[i], i);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int q : queries) {\n            ans.add(dist[q] == nums.length ? -1 : dist[q]);\n        }\n        \n        return ans;\n    }\n}","author":"zeningc","submissionId":"1575103799"},[{"id":"157","similarity":0.7262773722627737,"totOverlap":199,"longestOverlap":18}]],"462":[{"id":"462","fileName":"1575115983.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int pre[] = new int[n];\n        Arrays.fill(pre, Integer.MAX_VALUE);\n        for(int i=n-1; i>=0; i--) {\n            if(map.containsKey(nums[i])) {\n                pre[i] = Math.min(pre[i], Math.abs(i-map.get(nums[i])));\n            }\n            map.put(nums[i], i);\n        }\n        map.clear();\n        for(int i=n-1; i>=0; i--) {\n            if(map.containsKey(nums[i])) {\n                pre[i] = Math.min(pre[i], Math.abs(i+(n-map.get(nums[i]))));\n            }else{\n                map.put(nums[i], i);\n            }\n        }\n        map.clear();\n        for(int i=0; i<n; i++) {\n            if(map.containsKey(nums[i])) {\n                pre[i] = Math.min(pre[i], Math.abs(i-map.get(nums[i])));\n            }\n            map.put(nums[i], i);\n        }\n        map.clear();\n        for(int i=0; i<n; i++) {\n            if(map.containsKey(nums[i])) {\n                pre[i] = Math.min(pre[i], Math.abs(n-i +map.get(nums[i])));\n            }else{\n                map.put(nums[i], i);\n            }\n        }\n        for(int i=0; i<pre.length; i++) {\n            if(pre[i]==Integer.MAX_VALUE) pre[i] = -1;\n        }\n        // System.out.println(Arrays.toString(pre));\n        List<Integer> ans = new ArrayList<>();\n        for(int i=0; i<queries.length; i++) {\n            ans.add(pre[queries[i]]);\n        }\n        return ans;\n    }\n}","author":"Rudra Pratap Singh","submissionId":"1575115983"},[{"id":"1043","similarity":0.75,"totOverlap":228,"longestOverlap":10},{"id":"1488","similarity":0.7322033898305085,"totOverlap":216,"longestOverlap":12},{"id":"1488","similarity":0.7962264150943397,"totOverlap":211,"longestOverlap":26},{"id":"1043","similarity":0.7262773722627737,"totOverlap":199,"longestOverlap":18},{"id":"934","similarity":0.725,"totOverlap":145,"longestOverlap":10},{"id":"934","similarity":0.7219251336898396,"totOverlap":135,"longestOverlap":8},{"id":"934","similarity":0.7457627118644068,"totOverlap":132,"longestOverlap":8}]],"587":[{"id":"587","fileName":"1575119886.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        int a[] = new int[n];\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i=0;i<n;i++){\n            map.put(nums[i], i);\n        }\n        for(int i=0;i<n;i++){\n            int ind = map.get(nums[i]);\n            if(ind < i){\n                a[i] = i - ind;\n            }\n            else{\n                a[i] = n - ind + i;\n            }\n            map.put(nums[i], i);\n        }\n        for(int i = n-1;i>=0;i--)map.put(nums[i], i);\n        for(int i=n-1;i>=0;i--){\n            int ind = map.get(nums[i]);\n            if(ind > i){\n                a[i] = Math.min(a[i], ind - i);\n            }\n            else{\n                a[i] = Math.min(a[i], ind + n - i);\n            }\n            if(a[i] >= n) a[i] = -1;\n            map.put(nums[i], i);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for(int i : queries){\n            ans.add(a[i]);\n        }\n        return ans;\n    }\n}","author":"Sudeap Thapa","submissionId":"1575119886"},[{"id":"587","similarity":0.7219251336898396,"totOverlap":135,"longestOverlap":8}]],"873":[{"id":"873","fileName":"1575127485.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        HashMap<Integer, Integer> farthestDistance = new HashMap<>();\n        HashMap<Integer, Integer> closestDistance = new HashMap<>();\n\n        int[] minDistance = new int[n];\n        Arrays.fill(minDistance, n+1);\n        for(int i=n-1; i>=0; i--){\n            if(closestDistance.containsKey(nums[i])){\n                minDistance[i] = Math.min(minDistance[i], closestDistance.get(nums[i])-i);\n            }\n\n            if(farthestDistance.containsKey(nums[i])){\n                minDistance[i] = Math.min(minDistance[i], i+n-farthestDistance.get(nums[i]));\n            }\n            \n            if(!farthestDistance.containsKey(nums[i])){\n                farthestDistance.put(nums[i], i);\n            }\n            \n            closestDistance.put(nums[i], i);\n        }\n\n        // System.out.println(Arrays.toString(minDistance));\n        farthestDistance.clear();\n        closestDistance.clear();\n        \n        for(int i=0; i<n; i++){\n            if(closestDistance.containsKey(nums[i])){\n                minDistance[i] = Math.min(minDistance[i], i-closestDistance.get(nums[i]));\n            }\n\n            if(farthestDistance.containsKey(nums[i])){\n                minDistance[i] = Math.min(minDistance[i], farthestDistance.get(nums[i])+n-i);\n            }\n            \n            if(!farthestDistance.containsKey(nums[i])){\n                farthestDistance.put(nums[i], i);\n            }\n            closestDistance.put(nums[i], i);\n        }\n\n        // System.out.println(Arrays.toString(minDistance));\n\n        List<Integer> res = new ArrayList<>();\n        for(int q : queries){\n            res.add(minDistance[q] == n+1? -1 : minDistance[q]);\n        }\n\n        return res;\n    }\n}","author":"Anuj","submissionId":"1575127485"},[{"id":"873","similarity":0.7962264150943397,"totOverlap":211,"longestOverlap":26}]],"934":[{"id":"934","fileName":"1575128853.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> ans = new ArrayList<>();\n        int n = nums.length;\n        int[] arr = new int[n];\n        HashMap<Integer,Integer> lasts = new HashMap<>();\n        for(int i=0;i<n;i++){\n            if(lasts.containsKey(nums[i])){\n                int last = lasts.get(nums[i]);\n                arr[last] = Math.min(arr[last],i-last);\n                arr[i]= i-last;\n            }else{\n                arr[i] = Integer.MAX_VALUE;\n                \n            }\n            lasts.put(nums[i],i);\n        }\n        //System.out.println(lasts);\n        for(int i=0;i<n;i++){\n            if(lasts.get(nums[i])!=i){\n                int last = lasts.get(nums[i]);\n                arr[i] = Math.min(arr[i],n-last+i);\n                arr[last] = Math.min(arr[last],n-last+i);\n            }\n        }\n        for(int i : queries){\n            ans.add(arr[i]==Integer.MAX_VALUE?-1:arr[i]);\n        }\n        return ans;\n    }\n}","author":"Vinayak Soni","submissionId":"1575128853"},[{"id":"157","similarity":0.725,"totOverlap":145,"longestOverlap":10}]],"1043":[{"id":"1043","fileName":"1575131614.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int[] pref=new int[nums.length];\n        Arrays.fill(pref,Integer.MAX_VALUE);\n        Map<Integer,Integer> map1=new HashMap<>();\n        Map<Integer,Integer> map2=new HashMap<>();\n        Map<Integer,Integer> map3=new HashMap<>();\n         Map<Integer,Integer> map4=new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            if(map1.containsKey(nums[i])){\n                pref[i]=Math.min(pref[i],i-map1.get(nums[i]));\n            }\n            map1.put(nums[i],i);\n        }\n        // System.out.println(Arrays.toString(pref));\n        int n=nums.length-1;\n        for(int i=n;i>=0;i--){\n            if(map2.containsKey(nums[i])){\n                pref[i]=Math.min(pref[i],map2.get(nums[i])-i);\n            }\n            map2.put(nums[i],i);\n        }\n         // System.out.println(Arrays.toString(pref));\n        for(int i=0;i<nums.length;i++){\n            if(map3.containsKey(nums[i])){\n                pref[i]=Math.min(pref[i],n-i+map3.get(nums[i])+1);\n            }\n             if(!map3.containsKey(nums[i])) map3.put(nums[i],i);\n        }\n\n        for(int i=n;i>=0;i--){\n            if(map4.containsKey(nums[i])){\n                pref[i]=Math.min(pref[i],i+n-map4.get(nums[i])+1);\n            }\n             if(!map4.containsKey(nums[i])) map4.put(nums[i],i);\n        }\n        // System.out.println(Arrays.toString(pref));\n        List<Integer> l=new ArrayList<>();\n        for(int i=0;i<queries.length;i++){\n            if(pref[queries[i]]==Integer.MAX_VALUE){\n                l.add(-1);\n            }\n            else l.add(pref[queries[i]]);\n        }\n        return l;\n    }\n}","author":"Nithish kannan","submissionId":"1575131614"},[{"id":"462","similarity":0.75,"totOverlap":228,"longestOverlap":10}]],"1488":[{"id":"1488","fileName":"611234697.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, Integer> first = new HashMap<>();\n        Map<Integer, Integer> second = new HashMap<>();\n        int[] idx = new int[n];\n        Arrays.fill(idx, Integer.MAX_VALUE);\n        for (int i = 0; i < n; i++) {\n            if (first.containsKey(nums[i])) {\n                idx[i] = Math.min(i - first.get(nums[i]), n - (i - first.get(nums[i])));\n            }\n            if (second.containsKey(nums[i])) {\n                idx[i] = Math.min(idx[i], i - second.get(nums[i]));\n            }\n            if (!first.containsKey(nums[i])) first.put(nums[i], i);\n            else second.put(nums[i], i);\n        }\n        first.clear();\n        second.clear();\n        for (int i = n - 1; i >= 0; i--) {\n            if (first.containsKey(nums[i])) {\n                idx[i] = Math.min(Math.min(first.get(nums[i]) - i, n - (first.get(nums[i]) - i)), idx[i]);\n            }\n            if (second.containsKey(nums[i])) {\n                idx[i] = Math.min(idx[i], second.get(nums[i]) - i);\n            }\n            if (!first.containsKey(nums[i])) first.put(nums[i], i);\n            else second.put(nums[i], i);\n        }\n        int m = queries.length;\n        List<Integer> ans = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            ans.add(idx[queries[i]] >= Integer.MAX_VALUE ? -1 : idx[queries[i]]);\n        }\n        return ans;\n    }\n}","author":"Mojo","submissionId":"611234697"},[{"id":"1043","similarity":0.7322033898305085,"totOverlap":216,"longestOverlap":12}]]},{"463":[{"id":"463","fileName":"1575116268.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, set<int>> lookup;\n        int n = nums.size();\n        for (int i=0;i<n;i++) {\n            lookup[nums[i]].insert(i);\n        }\n        for (int &q: queries) {\n            auto &inds = lookup[nums[q]];\n            if (inds.size()==1) {\n                q = -1;\n                continue;\n            }\n            auto it = inds.find(q);\n            int before, after;\n            it++;\n            before = it==inds.end()? n+(*inds.begin()): *it;\n            it--;\n            if (it==inds.begin()) {\n                after = (*inds.rbegin())-n;\n            } else {\n                it--;\n                after = *it;\n            }\n            q = min(before-q, q-after);\n        }\n        return queries;\n    }\n};","author":"Haggai Liu","submissionId":"1575116268"},[]]},{"464":[{"id":"464","fileName":"1575116135.txt","sourceCode":"class Solution {\nprivate:\n    int f(vector<int>& s, int i, int n) {\n        if (s.size() == 1) return -1;\n        if (s.size() == 2) return g(s[0], s.back(), n);\n        int l = lower_bound(s.begin(), s.end(), i) - s.begin();\n        int h = upper_bound(s.begin(), s.end(), i) - s.begin();\n        int pre_ret = l == 0 ? g(i, s.back(), n) : g(s[l - 1], i, n);\n        int next_ret = h == s.size() ? g(s[0], i, n) : g(i, s[h], n);\n        return min(pre_ret, next_ret);\n        \n    }\n    int g(int a, int b, int n) {\n        return min(b - a, a + n - b);\n    }\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> db;\n        for (int i = 0; i < n; ++i) {\n            db[nums[i]].push_back(i);\n        }\n        vector<int> ret;\n        for (int q: queries) {\n            ret.push_back(f(db[nums[q]], q, n));\n        }\n        return ret;        \n    }\n};","author":"Annie W","submissionId":"1575116135"},[]]},{"466":[{"id":"466","fileName":"1575116273.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        for(int i = 0 ; i < n; i++) {\n            nums.push_back(nums[i]);\n        }\n        vector<int> dis(n, INT_MAX);\n        vector<int> lpos(1e6 + 1, -1);\n        vector<int> rpos(1e6 + 1, -1);\n        for(int i = 0; i < n * 2; i++) {\n            int num = nums[i];\n            if(lpos[num] != -1 && ((lpos[num]% n) != (i % n)) ) {\n                dis[i % n] = min( abs(lpos[num] - i), dis[i%n] );\n            }\n            lpos[num] = i;\n        }\n        for(int i = n * 2 - 1; i >= 0; i--) {\n            int num = nums[i];\n            if(rpos[num] != -1 && ((rpos[num] % n) != (i % n))) {\n                dis[i % n] = min(abs(rpos[num]  - (i % n)), dis[i%n]);\n            }\n            rpos[num] = i;\n        }\n        vector<int> ret;\n        for(int i = 0; i < n; i++ ) {\n            if(dis[i] == INT_MAX) {\n                dis[i] = -1;\n            }\n        }\n        for(int idx : queries) {\n            ret.push_back(dis[idx]);\n        }\n        return ret;\n    }\n};","author":"Aster233","submissionId":"1575116273"},[]]},{"467":[{"id":"467","fileName":"1575116406.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dct=defaultdict(list)\n        l0=len(nums)\n        for i, n in enumerate(nums):\n            dct[n].append(i)\n        ans=[]\n        for q in queries:\n            val=nums[q]\n            tmp=dct[val]\n            l=len(tmp)\n            if l==1:\n                ans.append(-1)\n            elif l==2:\n                print(tmp)\n                ans.append(min(tmp[1]-tmp[0], tmp[0]+l0-tmp[1]))\n            else:\n                ind=bisect.bisect_left(tmp, q)\n                # print(l, ind, tmp)\n                q0=tmp[(ind-1)%l]\n                q1=tmp[(ind+1)%l]\n                # print(q, q0, q1)\n                t0=min(abs(q-q0), abs(q+l0-q0), abs(q0+l0-q))\n                t1=min(abs(q-q1), abs(q+l0-q1), abs(q1+l0-q))\n                ans.append(min(t0, t1))\n        return ans\n                \n        ","author":"Marius Beceanu","submissionId":"1575116406"},[]]},{"469":[{"id":"469","fileName":"1575116264.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int> > index_by_num;\n        int n=nums.size();\n        \n        for(int i=0;i<n;i++){\n            index_by_num[nums[i]].push_back(i);\n        }\n        \n        vector<int> sol;\n        \n        for(int i=0;i<queries.size();i++){\n            int q=nums[queries[i]];\n            \n            int d=1e9;\n            int sz=index_by_num[q].size();\n            if(sz>1){\n                \n                int ind=lower_bound(index_by_num[q].begin(),index_by_num[q].end(),queries[i])-index_by_num[q].begin();\n                int prev=(ind-1+sz)%sz;\n                int nx=(ind+1)%sz;\n                //cout<<ind<<\" \"<<prev<<\" \"<<nx<<\" \"<<sz<<endl;\n                int prev_d=min(abs(index_by_num[q][ind]-index_by_num[q][prev]),n-abs(index_by_num[q][ind]-index_by_num[q][prev]));\n                int nx_d=min(abs(index_by_num[q][ind]-index_by_num[q][nx]),n-abs(index_by_num[q][ind]-index_by_num[q][nx]));\n                \n\n                if(prev_d < d){\n                    d=prev_d;\n                }\n                \n                if(nx_d < d){\n                    d=nx_d;\n                }\n            }\n            \n            if(d==1e9){\n                d=-1;\n            }\n            sol.push_back(d);\n            \n        }\n        \n        return sol;\n    }\n};","author":"Harikrishna Shenoy","submissionId":"1575116264"},[{"id":"1655","similarity":0.7119565217391305,"totOverlap":131,"longestOverlap":27},{"id":"1670","similarity":0.7125748502994012,"totOverlap":119,"longestOverlap":8}]],"1655":[{"id":"1655","fileName":"611238926.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>>Map;\n        int l = nums.size();\n        for(int i=0;i<l;i++){\n            Map[nums[i]].push_back(i);\n        }\n        vector<int>res;\n        for(int query : queries){\n            int num = nums[query];\n            auto it = lower_bound(Map[num].begin(),Map[num].end(),query);\n            int len = Map[num].size();\n            if(len == 1){\n                res.push_back(-1);\n                continue;\n            }\n            int site = it - Map[num].begin();\n            int site1 = (site + len + 1)%len;\n            int site2 = (site-1 + len)%len;\n\n            int tmp1 = abs(Map[num][site]- Map[num][site1]);\n            int tmp2 = abs(Map[num][site]- Map[num][site2]);\n            \n            int r = min(min(l-tmp1,tmp1),min(l-tmp2,tmp2));\n            res.push_back(r);\n        }\n        return res;\n    }\n};","author":"如果","submissionId":"611238926"},[{"id":"469","similarity":0.7119565217391305,"totOverlap":131,"longestOverlap":27}]],"1670":[{"id":"1670","fileName":"611239537.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>>mp;\n        for(int i = 0; i < nums.size(); i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int>ans;\n        for(auto& q: queries){\n            int v = nums[q];\n            auto local_index = lower_bound(mp[v].begin(), mp[v].end(), q) - mp[v].begin();\n            if(mp[v].size() == 1){\n                ans.push_back(-1);\n                continue;\n            }\n            int  tmp = 1e7;\n            \n            int prev_index = (local_index - 1 + mp[v].size()) % mp[v].size();\n            int l = abs(mp[v][local_index] - mp[v][prev_index]);\n            tmp = min(tmp, min(l, n - l));\n            \n            int next_index = (local_index + 1) % mp[v].size();\n            l = abs(mp[v][next_index] - mp[v][local_index]);\n            tmp = min(tmp, min(l, n - l));\n            ans.push_back(tmp);\n        }\n        return ans;\n    }\n};","author":"BUG_MAKER","submissionId":"611239537"},[{"id":"1655","similarity":0.7125748502994012,"totOverlap":119,"longestOverlap":8}]]},{"470":[{"id":"470","fileName":"1575116572.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        m = defaultdict(list)\n        n = len(nums)\n        for i,num in enumerate(nums):\n            m[num].append(i)\n        ret = []\n        for q in queries:\n            #q is queries[i]-- the current idx\n            to_find = nums[q]\n            if len(m[to_find]) == 1:\n                ret.append(-1)\n                continue\n            idx_in_list = bisect_left(m[to_find], q)\n            #print(q,idx_in_list)\n            min_dist = inf\n            if idx_in_list > 0:\n                prev_element = m[to_find][idx_in_list - 1]\n                min_dist = min(min_dist,q - prev_element)\n            else:\n                prev_element = m[to_find][-1]\n                min_dist = min(min_dist,q+n - prev_element)\n            if idx_in_list < len(m[to_find]) - 1:\n                next_element = m[to_find][idx_in_list + 1]\n                min_dist = min(min_dist, next_element - q)\n            else:\n                next_element = m[to_find][0]\n                min_dist = min(min_dist, next_element + n - q)\n            \n            ret.append(min_dist)\n        return ret","author":"MalianBestCiv","submissionId":"1575116572"},[]]},{"471":[{"id":"471","fileName":"1575116500.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        mp = defaultdict(list)\n        for i, num in enumerate(nums):\n            mp[num].append(i)\n\n        ans = [-1]*len(queries)\n        for k, i in enumerate(queries):\n            num = nums[i]\n            if len(mp[num]) <= 1: continue\n            idx = bisect_left(mp[num], i)\n\n            min_dist = inf\n            \n            for j in range(idx-1, idx+2, 2):\n                j = j % len(mp[num])\n                dist =  abs(mp[num][j] - i)\n                dist = min(dist, len(nums) - dist)\n                \n                if mp[num][j] != i and dist < min_dist:\n                    ans[k] = dist\n                    min_dist = dist\n            \n        return ans\n            \n            ","author":"Piyush Kumar","submissionId":"1575116500"},[]]},{"472":[{"id":"472","fileName":"1575116557.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> res = new ArrayList<> ();\n        List<Integer>[] ls = new List[1000000];\n        int len = nums.length;\n        for(int i = 0; i < len; i++) {\n            int cur = nums[i];\n            if(ls[cur] == null)\n                ls[cur] = new ArrayList<> ();\n            ls[cur].add(i);\n        }\n        for(int q: queries) {\n            int tar = nums[q];\n            if(ls[tar].size() == 1)\n                res.add(-1);\n            else if(ls[tar].size() == 2) {\n                int a = ls[tar].get(0);\n                int b = ls[tar].get(1);\n                res.add(Math.min(Math.abs(a-b), len-Math.abs(a-b)));\n            }\n            else {\n                int l = 0, r = ls[tar].size() - 1, ind = -1, n =ls[tar].size();\n                while (l <= r) { \n                    int mid = l + (r - l) / 2;\n                    if (ls[tar].get(mid) == q) {\n                        ind = mid;\n                        break;\n                    } else if (ls[tar].get(mid) < q) {\n                        l = mid + 1;  \n                    } else {\n                        r = mid - 1; \n                    }\n                }\n                int a = ls[tar].get((ind+n-1) % n);\n                int b = ls[tar].get(ind);\n                int c = ls[tar].get((ind+1) % n);\n                int d1 = Math.min(Math.abs(a-b), len-Math.abs(a-b));\n                int d2 = Math.min(Math.abs(b-c), len-Math.abs(b-c));\n                res.add(Math.min(d1, d2));\n            }\n        }\n        return res;\n    }\n}","author":"jam","submissionId":"1575116557"},[]]},{"474":[{"id":"474","fileName":"1575116646.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        var s = new HashMap<Integer, TreeSet<Integer>>();\n        for (int i = 0; i < nums.length; i++) {\n            s.computeIfAbsent(nums[i], k -> new TreeSet<>()).add(i);\n            s.get(nums[i]).add(i + nums.length);\n            s.get(nums[i]).add(i - nums.length);\n        }\n        var res = new ArrayList<Integer>();\n        for (int i : queries) {\n            var f = s.get(nums[i]).floor(i - 1);\n            var c = s.get(nums[i]).ceiling(i + 1);\n            if (c != null && c - nums.length == i) {\n                c = null;\n            }\n            if (f != null && f + nums.length == i) {\n                f = null;\n            }\n            if (f == null && c == null) {\n                res.add(-1);\n            } else if (f != null && c != null) {\n                res.add(Math.min(c - i, i - f));\n            } else if (f != null) {\n                res.add(i - f);\n            } else if (c != null) {\n                res.add(c - i);\n            }\n        }\n        return res;\n    }\n}","author":"Ali","submissionId":"1575116646"},[]]},{"475":[{"id":"475","fileName":"1575116594.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int q = queries.length, n = nums.length;\n        List<Integer> ans = new ArrayList<>();\n        HashMap<Integer,Integer> hm = new HashMap<>();\n        int[] right = new int[n];\n        int[] left = new int[n];\n        Arrays.fill(right,-1);\n        Arrays.fill(left,-1);\n        for(int i=0;i<n;i++) {\n            if(hm.containsKey(nums[i]))\n                right[hm.get(nums[i])] = i;\n            hm.put(nums[i],i);\n        }\n        int j = 0;\n        while(hm.size()>0) {\n            if(!hm.containsKey(nums[j])) {\n                j++;\n                continue;\n            }\n            int ind = hm.get(nums[j]);\n            right[ind] = n+j;\n            hm.remove(nums[j]);\n            j++;\n        }\n        hm.clear();\n        for(int i=n-1;i>=0;i--) {\n            if(hm.containsKey(nums[i]))\n                left[hm.get(nums[i])] = i;\n            hm.put(nums[i],i);\n        }\n        j = n-1;\n        while(hm.size()>0) {\n            if(!hm.containsKey(nums[j])) {\n                j--;\n                continue;\n            }\n            int ind = hm.get(nums[j]);\n            left[ind] = j-n;\n            hm.remove(nums[j]);\n            j--;\n        }\n        for(int ind : queries) {\n            if(left[ind] == ind)\n                ans.add(-1);\n            else {\n                int temp = Math.min(Math.abs(ind-left[ind]), Math.abs(ind-right[ind]));\n                if(temp == n)\n                    ans.add(-1);\n                else\n                    ans.add(temp);\n            }\n        }\n        return ans;\n    }\n}","author":"yashwanth73","submissionId":"1575116594"},[]]},{"476":[{"id":"476","fileName":"1575116678.txt","sourceCode":"\n\n\n/*Don Paul*/\n \n#define ll long long \n#define ld long double\n#define el __int128\n\n#define vl vector<ll>\n#define ust unordered_set\n#define ump unordered_map\n#define prq priority_queue\n \n#define pb push_back\n#define pp pop_back\n#define sz(x) ((int)x.size())\n#define be(x) x.begin(), x.end()\n#define farr(i, arr) for(int i=0; i<arr.size(); ++i)\n#define fpr(it, m) for(auto it=m.begin(); it!=m.end(); ++it)\n\n\n//Debugging tools\n\n#define lines cout<<\"n----------------------n\"\n#define bline cout<<\"n======================n\"\n#define parr(arr) for(int i=0; i<arr.size(); ++i) cout<<arr[i]<<\" \"; cout<<\"n\";\n#define pset(s) for(auto i=s.begin(); i!=s.end(); ++i) cout<<*i<<\" \"; cout<<\"n\";\n#define pmap(m) for(auto i=m.begin(); i!=m.end(); ++i) cout<<i->first<<\" - \"<<i->second<<\"n\";\n \nll mod = 1e9 + 7;\nll inf = 7e18;\n \n/*======================================================================================================================*/\n\n\n\nll find(vector<ll>& arr, ll val) \n{\n    ll low = 0;\n    ll high = arr.size() - 1; \n    ll ans = -1;\n \n    while (low <= high) \n    {\n        ll mid = (low + high)/2;\n \n        if (arr[mid] <= val) \n        {\n            ans = mid;\n            low = mid + 1;\n        } \n \n        else \n        {\n            high = mid - 1;\n        }\n    }\n \n    return ans;\n}\n \n\n\nll findv(vl &arr, ll val, ll n)\n{\n    if(sz(arr) == 1)\n        return -1;\n    \n    ll ind = find(arr, val);    \n    \n    if(ind == 0)\n    {\n        ll a = arr[1] - arr[0];\n        ll b = n - arr.back() + arr[0];\n        \n        return min(a, b);\n    }\n    \n    if(ind == sz(arr) - 1)\n    {\n        ll a = arr[ind] - arr[ind-1];\n        ll b = n - arr.back() + arr[0];\n        \n        return min(a, b);   \n    }\n    \n    ll a = arr[ind+1] - arr[ind];\n    ll b = arr[ind] - arr[ind-1];\n    \n    return min(a, b);\n}\n\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        \n        int n = sz(nums);\n        map<ll, vl> m;\n        \n        for(ll i=0; i<n; ++i)\n        {   \n            m[nums[i]].pb(i);\n        }\n        \n        vector<int> res;\n        \n        for(ll i=0; i<sz(q); ++i)\n        {\n            ll ind = q[i];\n            ll curr = nums[ind];\n            \n            ll now = findv(m[curr], ind, n);\n            res.pb(now);\n        }\n        \n        return res;\n    }\n};","author":"Don Paul","submissionId":"1575116678"},[]]},{"477":[{"id":"477","fileName":"1575116758.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n\n        num_map = defaultdict(list)\n        n = len(nums)\n        for i in range(n):\n            num_map[nums[i]].append(i)\n\n        ans = []\n        for ind in queries:\n            num = nums[ind]\n            if len(num_map[num]) == 1:\n                ans.append(-1)\n            else:\n                pos = bisect_left(num_map[num], ind)\n                n_q = len(num_map[num])\n                r1 = num_map[num][(pos + 1) % n_q]\n                r2 = num_map[num][pos - 1]\n                d1, d2 = abs(ind - r1), abs(ind - r2)\n                dist = min(d1, d2, n - d1, n - d2)\n                ans.append(dist)\n        return ans","author":"djhunjhu","submissionId":"1575116758"},[]]},{"478":[{"id":"478","fileName":"1575116756.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map <int,vector<int>> mpp;\n        for (int i=0;i<nums.size();i++){\n            mpp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for (int i=0;i<queries.size();i++){\n            int ind=queries[i];\n            if (mpp[nums[ind]].size()==1){\n                ans.push_back(-1);\n                continue;\n            }\n            int minn = INT_MAX;\n            if (ind==mpp[nums[ind]][0]){\n                minn = min(mpp[nums[ind]][1]-mpp[nums[ind]][0],((int)nums.size()- (int)mpp[nums[ind]].back()+mpp[nums[ind]][0]));\n            }\n            else if (ind == mpp[nums[ind]].back()) {\n            minn = min(\n        mpp[nums[ind]].back() - mpp[nums[ind]][mpp[nums[ind]].size() - 2], \n        (int)nums.size() - mpp[nums[ind]].back() + mpp[nums[ind]][0]\n    );\n}\n            else {\n                int ind1 = lower_bound(mpp[nums[ind]].begin(),mpp[nums[ind]].end(),ind) - mpp[nums[ind]].begin();\n                minn = min(mpp[nums[ind]][ind1+1]-ind,ind- mpp[nums[ind]][ind1-1]);\n            }\n            ans.push_back(minn);\n        }\n        return ans;\n    }\n};","author":"Prithvi Sen","submissionId":"1575116756"},[]]},{"479":[{"id":"479","fileName":"1575116764.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        const int n = nums.size(), m = queries.size();\n        vector<int> ans(m, -1);\n\n        unordered_map<int, vector<int>> mp;\n\n        for(int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n\n        for(int i = 0; i < m; i++) {\n            int num = nums[queries[i]];\n            if(mp[num].size() == 1) continue;\n\n            int len = mp[num].size();\n\n            int index = lower_bound(mp[num].begin(), mp[num].end(), queries[i]) - mp[num].begin();\n            \n            int nex = (len + index + 1)%len;\n            int prev = (len + index - 1)%len;\n        \n            int len1 = abs(mp[num][index] - mp[num][nex]);    \n            int len2 = n - len1;    \n            int len3 = abs(mp[num][index] - mp[num][prev]);    \n            int len4 = n - len3;    \n            ans[i] = min({len1, len2, len3, len4});\n        }\n\n        return ans;\n    }\n};","author":"Yash151","submissionId":"1575116764"},[]]},{"480":[{"id":"480","fileName":"1575116782.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        d = defaultdict(list)\n        for i,v in enumerate(nums):\n            d[v].append(i)\n        ans = []\n        for i in queries:\n            v = nums[i]\n            if len(d[v]) < 2:\n                ans.append(-1)\n                continue\n            p = bisect.bisect_left(d[v], i)\n            m = len(d[v])\n            x = d[v][p+1] if p+1 < m else d[v][0]+n\n            y = d[v][p-1] if p > 0 else d[v][-1]-n\n            ans.append(min(x-i, i-y))\n        return ans","author":"xlx2","submissionId":"1575116782"},[]]},{"481":[{"id":"481","fileName":"1575116836.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        positions = {}\n        for i, num in enumerate(nums):\n            if num not in positions:\n                positions[num] = []\n            positions[num].append(i)\n        n = len(nums)\n        for key, value in positions.items():\n            positions[key] = value + [i + n for i in value]\n        # print(positions)\n        res = [-1] * len(queries)\n        for i, q in enumerate(queries):\n            num = nums[q]\n            array = positions[num]\n            index = bisect_left(array, q)\n            a = array[index + 1] - array[index]\n            index = bisect_left(array, q + n)\n            b = array[index] - array[index - 1]\n            # print(index)\n            tmp = min(a, b)\n            if tmp != n:\n                res[i] = tmp\n        return res","author":"Oh a clown","submissionId":"1575116836"},[]]},{"482":[{"id":"482","fileName":"1575116612.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> list = new ArrayList<>();\n        int n = nums.length, q = queries.length;\n        HashMap<Integer,TreeSet<Integer>> map = new HashMap<>();\n        for(int i=0; i<n; i++){\n            map.putIfAbsent(nums[i],new TreeSet<>());\n            map.get(nums[i]).add(i);\n        }\n        for(int i=0; i<q; i++){\n            int val = nums[queries[i]];\n            if(map.get(val).size()==1){\n                list.add(-1);\n            }else{\n                int res = Integer.MAX_VALUE;\n                int idx = queries[i];\n                Integer low = map.get(val).lower(idx);\n                if(low!=null){\n                    res = Math.min(res,idx-low);\n                }\n                Integer high = map.get(val).higher(idx);\n                if(high!=null){\n                    res = Math.min(res,high-idx);\n                }\n                int first = map.get(val).first();\n                if(first!=idx){\n                    res = Math.min(res,n-idx+first);\n                }\n                int last = map.get(val).last();\n                if(last!=idx){\n                    res = Math.min(res,n-last+idx);\n                }\n                list.add(res);\n            }\n        }\n        return list;\n    }\n}","author":"Rishabh Kumrawat","submissionId":"1575116612"},[]]},{"483":[{"id":"483","fileName":"1575116854.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> result(queries.size(), -1);\n        unordered_map<int, vector<int>> m;\n        for (int i = 0; i < n; ++i) {\n            m[nums[i]].push_back(i);\n        }\n        for (int i = 0; i < queries.size(); ++i) {\n            auto& index = queries[i];\n            int num = nums[index];\n            if (m[num].size() == 1) continue;\n            int upperIndex = getUpperIndex(index, m[num], n);\n            int lowerIndex = getLowerIndex(index, m[num], n);\n            result[i] = min(index - lowerIndex, upperIndex - index);\n        }\n        return result;\n    }\n    int getUpperIndex(int index, vector<int>& indexVec, int& n) {\n        auto it = upper_bound(indexVec.begin(), indexVec.end(), index);\n        if (it == indexVec.end()) return indexVec[0] + n;\n        return *it;\n    }\n    int getLowerIndex(int index,  vector<int>& indexVec, int& n) {\n        auto it = lower_bound(indexVec.begin(), indexVec.end(), index);\n        if (it == indexVec.begin()) return indexVec[indexVec.size() - 1] - n;\n        return *(--it);\n    }\n};","author":"mingyi621","submissionId":"1575116854"},[]]},{"484":[{"id":"484","fileName":"1575116680.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& s) {\n         int n=nums.size(),m=s.size();\n        map<int,vector<int>>mp;\n        map<int,int>bck;\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        for(int i=n-1;i>=0;i--){\n            if(bck.find(nums[i])==bck.end()){\n                bck[nums[i]]=n-i;\n            }\n        }\n        vector<int>ans(m,-1);\n        for(int i=0;i<m;i++){\n            int indx=s[i];\n            if(mp[nums[indx]].size()==1){\n                continue;\n            }\n            vector<int>&p=mp[nums[indx]];\n            int j=lower_bound(p.begin(),p.end(),indx)-p.begin();\n            int right=-1,left=-1;\n            if(j==0){\n                right=p[j+1]-p[j];\n                left=bck[nums[indx]]+p[j];\n                ans[i]=min(right,left);\n            }\n            else if(j==p.size()-1){\n                left=p[j]-p[j-1];\n                right=n-p[j]+p[0];\n                 ans[i]=min(right,left);\n            }\n            else{\n                left=p[j]-p[j-1];\n                right=p[j+1]-p[j];\n                 ans[i]=min(right,left);\n            }\n            \n        }\n        return ans;\n        \n    }\n};","author":"sprajjawalsingh","submissionId":"1575116680"},[]]},{"485":[{"id":"485","fileName":"1575116885.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n    int n = nums.size();\n    unordered_map<int, int> left, right, left2, right2;\n    vector<int> answer(n, -1);\n\n    // Compute leftmost (`left2`) and most recent left (`left`)\n    for (int i = 0; i < n; i++) {\n        if (left.count(nums[i])) {\n            int l = abs(i - left[nums[i]]);\n            answer[i] = min(l, n - l);\n        }\n        if (!left2.count(nums[i])) left2[nums[i]] = i; // Store leftmost occurrence\n        left[nums[i]] = i;\n    }\n\n    // Compute rightmost (`right2`) and most recent right (`right`)\n    for (int i = n - 1; i >= 0; i--) {\n        if (right.count(nums[i])) {\n            int r = abs(i - right[nums[i]]);\n            answer[i] = (answer[i] == -1) ? min(r, n - r) : min(answer[i], min(r, n - r));\n        }\n        if (!right2.count(nums[i])) right2[nums[i]] = i; // Store rightmost occurrence\n        right[nums[i]] = i;\n    }\n\n    // Use leftmost (`left2`) and rightmost (`right2`) occurrences to improve answer\n    for (int i = 0; i < n; i++) {\n        if (left2.count(nums[i]) && left2[nums[i]] != i) {\n            int l = abs(i - left2[nums[i]]);\n            answer[i] = (answer[i] == -1) ? min(l, n - l) : min(answer[i], min(l, n - l));\n        }\n        if (right2.count(nums[i]) && right2[nums[i]] != i) {\n            int r = abs(i - right2[nums[i]]);\n            answer[i] = (answer[i] == -1) ? min(r, n - r) : min(answer[i], min(r, n - r));\n        }\n    }\n\n    // Construct final answer based on queries\n    vector<int> final_answer;\n    for (int q : queries) {\n        final_answer.push_back(answer[q]);\n    }\n    \n    return final_answer;\n}\n};","author":"kumark6769704","submissionId":"1575116885"},[]]},{"486":[{"id":"486","fileName":"1575116943.txt","sourceCode":"from bisect import bisect_left as bl \nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = defaultdict(list)\n        n = len(nums)\n        for i in range(n):\n            d[nums[i]].append(i)\n        ans = []\n        for i in queries:\n            k = nums[i]\n            n1 = len(d[k])\n            if n1 == 1:\n                ans.append(-1)\n            else:\n                idx = bl(d[k],i)\n                if idx == n1 - 1:\n                    ans.append(min(abs(n-d[k][idx]+d[k][0]),abs(d[k][idx]-d[k][idx-1])))\n                elif idx == 0:\n                    ans.append(min(abs(n-d[k][-1]+d[k][0]),abs(d[k][idx]-d[k][idx+1])))\n                else:\n                    ans.append(min(abs(d[k][idx]-d[k][idx+1]),abs(d[k][idx]-d[k][idx-1])))\n        return ans\n        ","author":"sri_teja","submissionId":"1575116943"},[]]},{"487":[{"id":"487","fileName":"1575116932.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] quer) {\n        HashMap<Integer,List<Integer>> map = new HashMap<>();\n        int n = nums.length;\n        for(int i=0; i<n;i++){\n            List<Integer> l=new ArrayList<>();\n            if(map.containsKey(nums[i])){\n                l=map.get(nums[i]);\n            }\n            l.add(i);\n            map.put(nums[i],l);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for(int q : quer){\n            int x = nums[q];\n            List<Integer> l = map.get(x);\n            if(l.size()<=1) ans.add(-1);\n            else{\n                int low=0,high=l.size()-1;\n                int v=0;\n                while(low<=high){\n                    int mid=low+(high-low)/2;\n                    if(l.get(mid)==q) {\n                        v=mid;\n                        break;\n                    }\n                    else if(l.get(mid)<q) low=mid+1;\n                    else high=mid-1;\n                }\n\n                int before = v==0?\n                    Math.min(l.get(l.size()-1)-q,\n                            n-l.get(l.size()-1)+q):\n                    Math.min(q-l.get(v-1),\n                            n-q+l.get(v-1));\n                int after = v==l.size()-1?\n                    Math.min(q-l.get(0),\n                            n+l.get(0)-q):\n                    Math.min(l.get(v+1)-q,\n                            n+q-l.get(v+1));\n                ans.add(Math.min(before,after));\n            }\n        }\n        return ans;\n    }\n}","author":"Om Mehrotra","submissionId":"1575116932"},[]]},{"488":[{"id":"488","fileName":"1575117004.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        for(int i=0; i<n; i++) nums.push_back(nums[i]);\n        vector<int> ans(queries.size());\n        vector<pair<int,int>> ord;\n        for(int i=0; i<nums.size(); i++) ord.push_back(make_pair(nums[i],i));\n        sort(ord.begin(),ord.end());\n        for(int i=0; i<queries.size(); i++){\n            int id = queries[i];\n            auto it = lower_bound(ord.begin(),ord.end(),make_pair(nums[id],id));\n            if(next(it)->second - id == n) ans[i] = -1;\n            else {\n                ans[i] = next(it)->second - id;\n                if(it == ord.begin() || prev(it)->first != nums[id]){\n                    auto it2 = lower_bound(ord.begin(),ord.end(),make_pair(nums[id]+1,-1));\n                    it2--;\n                    ans[i] = min(ans[i], it->second + (n-(it2->second-n)));\n                }else ans[i] = min(ans[i],id - prev(it)->second);\n                // if(it != ord.begin()) cout << \"ue \" << ans[i] << ' '<< id << ' ' << prev(it)->second << 'n';\n            }\n        }\n        return ans;\n    }\n};","author":"Felipe Sabino","submissionId":"1575117004"},[]]},{"489":[{"id":"489","fileName":"1575117022.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        var indices = new HashMap<Integer, TreeSet<Integer>>();\n        int n = nums.length, m = queries.length;\n        for (int i = 0; i < n; i++) {\n            indices.computeIfAbsent(nums[i], z -> new TreeSet<>()).add(i);\n        }\n        var ans = new ArrayList<Integer>();\n        for (int i = 0; i < m; i++) {\n            int x = queries[i];\n            var set = indices.get(nums[x]);\n            Integer hi = set.higher(x), lo = set.lower(x), first = set.first(), last = set.last();\n            int r = hi == null ? (int) 1e9 : Math.abs(hi - x);\n            int l = lo == null ? (int) 1e9 : Math.abs(lo - x);\n            int s = first == null || x == first ? (int) 1e9 : first + (n - x);\n            int e = last == null || x == last ? (int) 1e9 : x + (n - last);\n            int v = Math.min(Math.min(l, r), Math.min(s, e));\n            if (v == (int) 1e9) {\n                ans.add(-1);\n            } else {\n                ans.add(v);\n            }\n        }\n        return ans;\n    }\n}\n/*\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        var indices = new HashMap<Integer, TreeSet<Integer>>();\n        int n = nums.length, m = queries.length;\n        for (int i = 0; i < n; i++) {\n            indices.computeIfAbsent(nums[i], z -> new TreeSet<>()).add(i);\n        }\n        var ans = new ArrayList<Integer>();\n        for (int i = 0; i < m; i++) {\n            int x = queries[i];\n            var set = indices.get(nums[x]);\n            // var set = indices.get(nums[queries[i]]);\n            Integer hi = set.higher(x), lo = set.lower(x), first = set.first(), last = set.last();\n            // Integer hi = set.higher(i), lo = set.lower(i), first = set.first(), last = set.last();\n            int r = hi == null ? (int) 1e9 : Math.abs(hi - i);\n            int l = lo == null ? (int) 1e9 : Math.abs(lo - i);\n            int s = first == null || x == first ? (int) 1e9 : first + (n - i);\n            // int s = first == null ? (int) 1e9 : first + (n - i);\n            int e = last == null || x == last ? (int) 1e9 : i + (n - last);\n            // int e = last == null ? (int) 1e9 : i + (n - last);\n            int v = Math.min(Math.min(l, r), Math.min(s, e));\n            if (v == (int) 1e9) {\n                ans.add(-1);\n            } else {\n                ans.add(v);\n            }\n        }\n        return ans;\n    }\n    \n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        var indices = new HashMap<Integer, TreeSet<Integer>>();\n        int n = nums.length, m = queries.length;\n        for (int i = 0; i < n; i++) {\n            indices.computeIfAbsent(nums[i], z -> new TreeSet<>()).add(i);\n        }\n        // var ans = new int[m];\n        var ans = new ArrayList<Integer>();\n        // Arrays.fill(ans, -1);\n        for (int i = 0; i < m; i++) {\n            var set = indices.get(nums[queries[i]]);\n            Integer hi = set.higher(i), lo = set.lower(i);\n            int r = hi == null ? (int) 1e9 : Math.min(Math.abs(hi - i), i + (n - hi));\n            int l = lo == null ? (int) 1e9 : Math.min(Math.abs(lo - i), lo + (n - i));\n            if (Math.min(l, r) == (int) 1e9) {\n                // continue;\n                ans.add(-1);\n            } else {\n                ans.add(Math.min(l, r));\n            }\n            // ans[i] = Math.min(l, r);\n        }\n        return ans;\n    }\n\n*/","author":"resotto","submissionId":"1575117022"},[]]},{"490":[{"id":"490","fileName":"1575117055.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dic=defaultdict(list)\n        n=len(nums)\n        for index,num in enumerate(nums):\n            dic[num].append(index)\n        res=[]\n        for query in queries:\n            target=nums[query]\n            pos=bisect_left(dic[target],query)\n            l=len(dic[target])\n            if l==1:\n                res.append(-1)\n            else:\n                bef,aft=dic[target][pos-1],dic[target][(pos+1)%l]\n                min_dis=min(abs(bef-query),abs(aft-query),abs(aft+n-query),abs(bef+n-query),abs(query+n-aft),abs(query+n-bef))\n                res.append(min_dis)\n        return res","author":"maky","submissionId":"1575117055"},[]]},{"491":[{"id":"491","fileName":"1575116920.txt","sourceCode":"\"\"\" === Method 1. use a hash table and note 2 sides\n(1) For 2 sides, we need to check the distance in another side.\n\"\"\"\nimport collections\nimport bisect\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        numIdxs = collections.defaultdict(list)\n        for idx, num in enumerate(nums):\n            numIdxs[num].append(idx)\n\n        q = len(queries)\n        results = [-1] * q\n        for queryIdx, i in enumerate(queries):\n            idxs = numIdxs[nums[i]]\n            if len(idxs) == 1:\n                continue\n            position = bisect.bisect_left(idxs, i)\n            leftIdx = idxs[position - 1]\n            rightIdx = idxs[position + 1] if position < len(idxs) - 1 else idxs[0]\n            # print(idxs, leftIdx, rightIdx, i)\n            results[queryIdx] = min(self.getDistance(leftIdx, i, n), self.getDistance(i, rightIdx, n))\n        return results\n\n    def getDistance(self, i, j, n):\n        if i > j:\n            i, j = j, i\n        return min(j - i, n - j + i)\n        ","author":"Albert_Zhang","submissionId":"1575116920"},[]]},{"492":[{"id":"492","fileName":"1575116823.txt","sourceCode":"import java.util.*;\n\nclass Util {\n    public static int m(int a, int b) {\n        if(a < b) return a;\n        return b;\n    }\n    \n    public static int abs(int a) {\n        if(a < 0) return -a;\n        return a;\n    }\n}\n\nclass Q {\n    public List<Integer> s(int[] a, int[] b) {\n        int n = a.length;\n        HashMap<Integer, ArrayList<Integer>> m = new HashMap<>();\n        int i = 0;\n        while(i < n) {\n            int c = a[i];\n            if(!m.containsKey(c)) {\n                m.put(c, new ArrayList<Integer>());\n            }\n            m.get(c).add(i);\n            i++;\n        }\n        Collection<ArrayList<Integer>> col = m.values();\n        Iterator<ArrayList<Integer>> it = col.iterator();\n        while(it.hasNext()) {\n            ArrayList<Integer> l = it.next();\n            Collections.sort(l);\n        }\n        List<Integer> r = new ArrayList<>();\n        int j = 0;\n        while(j < b.length) {\n            int p = b[j];\n            int c = a[p];\n            ArrayList<Integer> l = m.get(c);\n            if(l.size() < 2) {\n                r.add(-1);\n            } else {\n                int p2 = Collections.binarySearch(l, p);\n                int s = l.size();\n                int l1 = l.get((p2 - 1 + s) % s);\n                int r1 = l.get((p2 + 1) % s);\n                int d1 = Util.abs(p - l1);\n                d1 = Util.m(d1, n - d1);\n                int d2 = Util.abs(r1 - p);\n                d2 = Util.m(d2, n - d2);\n                r.add(Util.m(d1, d2));\n            }\n            j++;\n        }\n        return r;\n    }\n}\n\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Q q = new Q();\n        return q.s(nums, queries);\n    }\n}\n","author":"nobita_10","submissionId":"1575116823"},[]]},{"493":[{"id":"493","fileName":"1575117069.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        Map<Integer, TreeSet<Integer>> map = new HashMap<>();\n        \n        for (int i = 0; i < n; i++) {\n            map.computeIfAbsent(nums[i], k -> new TreeSet<>()).add(i);\n        }\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            int v = nums[queries[i]];\n            if (map.get(v).size() == 1) {\n                result.add(-1);\n            } else {\n                TreeSet<Integer> ts = map.get(v);\n                Integer pre = ts.lower(queries[i]);\n                if (pre == null) {\n                    pre = ts.last() - n;\n                }\n                Integer next = ts.higher(queries[i]);\n                if (next == null) {\n                    next = n + ts.first();\n                }\n                result.add(Math.min(queries[i] - pre, next - queries[i]));\n            }\n            \n        }\n        return result;\n    }\n}","author":"Zhu","submissionId":"1575117069"},[]]},{"494":[{"id":"494","fileName":"1575117160.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int,int> mp;\n        int pre[n],suf[n];\n        for(int i = 0;i<n;i++){\n            pre[i] = n;\n            suf[i] = n;\n        }\n        for(int i = 0 ;i<2*n;i++){\n            int ind = i<n?i: i-n;\n            if(mp.find(nums[ind])!=mp.end()){\n                pre[ind] = min(pre[ind],i-mp[nums[ind]]);\n            }\n            mp[nums[ind]] = i;\n        }\n        mp.clear();\n        for(int i = 2*n-1;i>=0;i--){\n            int ind = i<n?i: i-n;\n            if(mp.find(nums[ind])!=mp.end()){\n                pre[ind] = min(pre[ind],mp[nums[ind]] -i);\n            }\n            mp[nums[ind]] = i;\n        }\n        vector<int> res;\n        for(int i: queries){\n            int cur =pre[i];\n            res.push_back(cur>=n?-1:cur);\n        }\n        return res;\n    }\n};","author":"CHANDRAPRABHU","submissionId":"1575117160"},[]]},{"495":[{"id":"495","fileName":"1575117109.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int>leftv(n,INT_MAX),rightv(n,INT_MAX);\n        map<int,int>leftmp;\n        map<int,int>rightmp;\n        for(int i = 0;i<n;i++){\n            if(leftmp.find(nums[i])!=leftmp.end()){\n                leftv[i] = (i - leftmp[nums[i]]);\n            }\n            leftmp[nums[i]] = i;\n        }\n        // mp.clear();\n        for(int i = n-1;i>-1;i--){\n            if(rightmp.find(nums[i])!=rightmp.end()){\n                rightv[i] = (rightmp[nums[i]] - i);\n            }\n            rightmp[nums[i]] = i;\n        }\n        for(int i = 0;i<n-1;i++){\n            if(leftmp.find(nums[i])!=leftmp.end()){\n                int cd = i+1;\n                cd += (n - 1 - leftmp[nums[i]]);\n                leftv[i] = min(leftv[i],cd);\n            }\n        }\n        for(int i = n-1;i>0;i--){\n            if(rightmp.find(nums[i])!=rightmp.end()){\n                int cd = (n - i);\n                cd += (rightmp[nums[i]]);\n                rightv[i] = min(rightv[i],cd);\n            }\n        }\n        vector<int>ansv;\n        for(int &no : queries){\n            int ca = min(leftv[no],rightv[no]);\n            if(ca >= n)ansv.push_back(-1);\n            else ansv.push_back(ca);\n        }\n        return ansv;\n    }\n};","author":"Mayank Nichlani","submissionId":"1575117109"},[]]},{"497":[{"id":"497","fileName":"1575117198.txt","sourceCode":"class Solution {\n    int tp6=1e6;\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> pos;\n        vector<int> ans;\n        for(int i=0;i<nums.size();i++){\n            pos[nums[i]].push_back(i);\n        }\n        for(int q:queries){\n            int l=0,r=pos[nums[q]].size()-1,ind;\n            if(l>=r){\n                ans.push_back(-1);\n                continue;\n            }\n            while(l<=r){\n                int mid=l+(r-l)/2;\n                if(pos[nums[q]][mid]==q){\n                    ind=mid;\n                    break;\n                }\n                if(pos[nums[q]][mid]<q){\n                    l=mid+1;\n                }\n                else{\n                    r=mid-1;\n                }\n            }\n            int ps=pos[nums[q]].size();\n            int ldi,rdi;\n            if(ind) ldi=pos[nums[q]][ind]-pos[nums[q]][ind-1];\n            else ldi=pos[nums[q]][ind]+nums.size()-pos[nums[q]].back();\n            if(ind+1<ps){\n                rdi=pos[nums[q]][ind+1]-q;\n            }    \n            else{\n                rdi=pos[nums[q]][0]+nums.size()-pos[nums[q]][ind];\n            }\n            ans.push_back(min(ldi,rdi));\n        }\n        return ans;\n    }\n};","author":"Adithya G","submissionId":"1575117198"},[]]},{"498":[{"id":"498","fileName":"1575117202.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> ans = new ArrayList<>();\n        int n = nums.length;\n        int q = queries.length;\n        int[] prefix = new int[2*n];\n        Arrays.fill(prefix, Integer.MAX_VALUE);\n        int[] suffix = new int[2*n];\n        Arrays.fill(suffix, Integer.MAX_VALUE);\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for(int i = 0; i<2*n; i++){\n            int val = nums[i%n];\n            int idx = i%n;\n            if(hm.get(val)!=null && (hm.get(val) % n) != (i%n)){\n                prefix[idx] = Math.min(prefix[idx], i-hm.get(val));\n            }\n            hm.put(val, i);\n        }\n        hm = new HashMap<>();\n        for(int i = 2*n-1; i>=0; i--){\n            int val = nums[i%n];\n            if(hm.get(val)!=null && (hm.get(val) % n) != (i%n)){\n                suffix[i] = hm.get(val)-i;\n            }\n            hm.put(val, i);\n        }\n        \n        for(int i = 0; i<q; i++){\n            int idx = queries[i];\n            int min = Math.min(prefix[idx], suffix[idx]);\n            if(min == Integer.MAX_VALUE){\n                ans.add(-1);\n            }else{\n                ans.add(min);\n            }\n        }\n        \n        return ans;\n    }\n}","author":"Dinesh Chandran","submissionId":"1575117202"},[]]},{"499":[{"id":"499","fileName":"1575117221.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        positions = defaultdict(list)\n        for i, num in enumerate(nums):\n            positions[num].append(i)\n        ans = []\n        for i in queries:\n            indices = positions[nums[i]]\n            if len(indices) == 1:\n                ans.append(-1)\n            else:\n                idx = bisect_left(indices, i)\n                left = i - indices[idx - 1] + (len(nums) if idx == 0 else 0)\n                right = indices[idx + 1] - i if idx < len(indices) - 1 else indices[0] + len(nums) - i\n                ans.append(min(left, right))\n        return ans","author":"Theo","submissionId":"1575117221"},[]]},{"501":[{"id":"501","fileName":"1575117235.txt","sourceCode":"from bisect import bisect_left\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        indices = defaultdict(list)\n        n = len(nums)\n        \n        for index, val in enumerate(nums):\n            indices[val].append(index)\n\n        def find_closest_distance(a, b):\n            if a > b:\n                a, b = b, a\n\n            return min(b - a, n - b + a)\n        \n        answer = []\n        for query in queries:\n            val = nums[query]\n            target_list = indices[val]\n\n            if len(target_list) == 1:\n                answer.append(-1)\n            else:\n                left, right = inf, inf\n                current = bisect_left(target_list, query)\n                left_index = target_list[current - 1] if current > 0 else target_list[-1]\n                right_index = target_list[(current + 1) % len(target_list)]\n\n                dist1 = find_closest_distance(query, left_index)\n                dist2 = find_closest_distance(query, right_index)\n                answer.append(min(dist1, dist2))\n\n        return answer\n        ","author":"Suraj Suryawanshi","submissionId":"1575117235"},[]]},{"502":[{"id":"502","fileName":"1575117137.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        arr = nums+nums\n        d = defaultdict(list)\n        for i in range(n*2):\n            d[arr[i]].append(i)\n        for v in d:\n            d[v].sort()\n        r = []\n        for q in queries:\n            v = nums[q]\n            a = d[v]\n            if len(a) < 2:\n                r.append(-1)\n                continue\n            p = bisect.bisect_left(a,q)\n            if p==len(a):\n                p=0\n            ans = -1\n            for u in range(-1, 2):\n                i=(p+u)%len(a)\n                if a[i]%n != q:\n                    dis=abs(q-a[i]%n)\n                    dis=min(dis,n-dis) \n                    if ans<0 or dis<ans:\n                        ans=dis\n            r.append(ans)\n        return r\n","author":"aespa fan","submissionId":"1575117137"},[]]},{"503":[{"id":"503","fileName":"1575117272.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = size(nums);\n        vector<int> ans(size(queries), -1);\n\n        for (int i = 0; i < n; ++i)\n            nums.push_back(nums[i]);\n\n        for (int i = 0; i < n; ++i)\n            nums.push_back(nums[i]);\n\n        //for (auto x : nums)\n        //    cout << x << \" \";\n        //cout << \"n\";\n\n        int m = n * 3;\n        vector<int> prev_dst(m, INT_MAX);\n        vector<int> next_dst(m, INT_MAX);\n        map<int, int> prev_idx, next_idx;\n\n        for (int i = 0; i < m; ++i)\n        {\n            if (prev_idx.count(nums[i]))\n            {\n                prev_dst[i] = min(prev_dst[i], i - prev_idx[nums[i]]);\n            }\n            \n            prev_idx[nums[i]] = i;\n        }\n\n        for (int i = m - 1; i >= 0; --i)\n        {\n            if (next_idx.count(nums[i]))\n            {\n                next_dst[i] = min(next_dst[i], next_idx[nums[i]] - i);\n            }\n\n            next_idx[nums[i]] = i;\n        }\n\n        //for (int i = 0; i < m; ++i)\n        {\n            //cout << prev_dst[i] << \" \" << next_dst[i] << \"n\";\n        }\n\n        for (int i = 0; i < size(queries); ++i)\n        {\n            int q = queries[i] + n;\n            int dst = min(prev_dst[q], next_dst[q]);\n\n            if (dst != INT_MAX && dst != n)\n                ans[i] = dst;\n        }\n\n        return ans;\n    }\n};","author":"ttn","submissionId":"1575117272"},[]]},{"504":[{"id":"504","fileName":"1575117384.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>> numberToIndex;\n        int n = nums.size();\n        for(int i=0; i<nums.size(); ++i) {\n            numberToIndex[nums[i]].push_back(i);\n        }\n        vector<int> ans(queries.size());\n        for(int i=0; i<queries.size(); ++i) {\n            int ind = queries[i];\n            int sz = numberToIndex[nums[ind]].size();\n            if(sz==1) {\n                ans[i] = -1;\n            } else if(sz==2) {\n                int a = numberToIndex[nums[ind]][0];\n                int b = numberToIndex[nums[ind]][1];\n                ans[i] = min((n+a-b)%n,(n+b-a)%n);\n            } else {\n                int a = lower_bound(numberToIndex[nums[ind]].begin(),numberToIndex[nums[ind]].end(),ind) - numberToIndex[nums[ind]].begin();\n                int b = (sz+a-1)%sz;\n                int c = (sz+a+1)%sz;\n                ans[i] = min((n+numberToIndex[nums[ind]][a]-numberToIndex[nums[ind]][b])%n,(n+numberToIndex[nums[ind]][b]-numberToIndex[nums[ind]][a])%n);\n                ans[i] = min(ans[i],(n+numberToIndex[nums[ind]][c]-numberToIndex[nums[ind]][a])%n);\n                ans[i] = min(ans[i],(n+numberToIndex[nums[ind]][a]-numberToIndex[nums[ind]][c])%n);\n            }\n        }\n        return ans;\n    }\n};","author":"Vansh Chawla","submissionId":"1575117384"},[]]},{"505":[{"id":"505","fileName":"1575117278.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> mp;\n        int n=nums.size();\n        for(int i=0;i<n;i++)\n            {\n                mp[nums[i]].push_back(i);\n            }\n        vector<int> v;\n        for(int i=0;i<queries.size();i++)\n            {\n                if(mp[nums[queries[i]]].size()==1)\n                    v.push_back(-1);\n                else\n                {\n                    int mn=INT_MAX;\n                    if(mp[nums[queries[i]]].back()==queries[i])\n                    {\n                        int sz=mp[nums[queries[i]]].size();\n                        mn=min(mn,mp[nums[queries[i]]][sz-1]-mp[nums[queries[i]]][sz-2]);\n                        mn=min(mn,n+(mp[nums[queries[i]]][0]-mp[nums[queries[i]]][sz-1]));\n                    }\n                    else if(mp[nums[queries[i]]][0]==queries[i])\n                    {\n                        int sz=mp[nums[queries[i]]].size();\n                        mn=min(mn,mp[nums[queries[i]]][1]-mp[nums[queries[i]]][0]);\n                        mn=min(mn,n+(mp[nums[queries[i]]][0]-mp[nums[queries[i]]][sz-1]));\n                    }\n                    else\n                    {\n                        \n                            int idx=lower_bound(mp[nums[queries[i]]].begin(),mp[nums[queries[i]]].end(),queries[i])-mp[nums[queries[i]]].begin();\n                            mn=min(mn,mp[nums[queries[i]]][idx]-mp[nums[queries[i]]][idx-1]);\n                            mn=min(mn,(mp[nums[queries[i]]][idx+1]-mp[nums[queries[i]]][idx]));   \n                        \n                        \n                        // cout<<mp[nums[queries[i]]][idx-1]<<\" \"<<mp[nums[queries[i]]][idx]<<\" \"<<mp[nums[queries[i]]][idx+1]<<endl;\n                    }\n                    v.push_back(mn);\n                }\n            }\n        return v;\n    }\n};","author":"RITESH SHARMA","submissionId":"1575117278"},[]]},{"506":[{"id":"506","fileName":"1575117072.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n \nunordered_map<int, vector<int>> f(vector<int>& a){\n int n=a.size();\n unordered_map<int, vector<int>> m;\n for(int i=0;i<n;i++){\n  m[a[i]].push_back(i);\n }\n for(auto &p:m){\n  sort(p.second.begin(),p.second.end());\n }\n return m;\n}\n \nint d(int x,const vector<int>& v,int n){\n if(v.size()<2)return -1;\n auto p=lower_bound(v.begin(),v.end(),x);\n int j=v[(p-v.begin()+1)%v.size()];\n int k=v[(p-v.begin()-1+v.size())%v.size()];\n return min(min(abs(x-j),n-abs(x-j)),min(abs(x-k),n-abs(x-k)));\n}\n \nclass Solution{\npublic:\n vector<int> solveQueries(vector<int>& v,vector<int>& q){\n  int n=v.size();\n  unordered_map<int, vector<int>> m=f(v);\n  vector<int> r;\n    int q1=q.size();\n  for(int i=0;i<q1;i++)\n   r.push_back(d(q[i],m[v[q[i]]],n));\n  return r;\n }\n};\n","author":"PJ_ID","submissionId":"1575117072"},[]]},{"507":[{"id":"507","fileName":"1575117398.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n = nums.size();\n        int m = q.size();\n        const int inf = 1e9 + 7;\n        vector<int> nearest(n * 2, inf);\n        \n        map<int, int> lastSeenIdx;\n        for (int i = 0; i < 2 * n; ++i) {\n            if (lastSeenIdx.count(nums[i % n]) > 0) {\n                int gap = (i - lastSeenIdx[nums[i % n]]) % n;\n                if (gap == n || gap == 0) {\n                    nearest[i] = inf;\n                } else {\n                    nearest[i % n] = min(nearest[i % n], \n                            min(gap, n - gap));\n                }\n            }\n            lastSeenIdx[nums[i % n]] = i;\n        }\n\n        lastSeenIdx.clear();\n        for (int i = 2 * n - 1; i >= 0; --i) {\n            if (lastSeenIdx.count(nums[i % n]) > 0) {\n                int gap = abs(i - lastSeenIdx[nums[i % n]]) % n;\n                if (gap == n || gap == 0) {\n                    nearest[i] = inf;\n                } else {\n                    nearest[i % n] = min(nearest[i % n], \n                        min(abs(gap), abs(n - gap)));\n                }\n            }\n            lastSeenIdx[nums[i % n]] = i;\n        }\n\n        vector<int> ans(m, -1);\n        for (int i = 0; i < m; ++i) {\n            ans[i] = (nearest[q[i]] == inf) ? -1 : nearest[q[i]];\n        }\n        return ans;   \n    }\n};","author":"dumpfile","submissionId":"1575117398"},[]]},{"508":[{"id":"508","fileName":"1575117561.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> m;\n\n        int n = nums.size();\n        for(int i = 0; i < 2 * n; i++) {\n            int idx = i % n;\n\n            m[nums[idx]].push_back(i);\n        }\n\n        vector<int> answer;\n        for(auto x:queries) {\n            int search = nums[x];\n            int idx1 = x, idx2 = x + n;\n\n            auto &arr = m[search];\n\n            if(arr.size() == 2) {\n                answer.push_back(-1);\n                continue;\n            }\n            \n            auto it1 = lower_bound(arr.begin(), arr.end(), idx1);\n            auto it2 = lower_bound(arr.begin(), arr.end(), idx2);\n\n            int ans = INT_MAX;\n            if(it1 != arr.begin()) {\n                auto prevIt = prev(it1);\n                ans = min(ans, idx1 - *prevIt);\n            }\n\n            if(next(it2) != arr.end()) {\n                auto nextIt = next(it2);\n                ans = min(ans, *nextIt - idx2);\n            }\n\n            ans = min(ans, *next(it1) - idx1);\n            ans = min(ans, idx2 - *prev(it2));\n\n            answer.push_back(ans);\n        }\n\n        return answer;\n    }\n};","author":"Arjun Grover","submissionId":"1575117561"},[]]},{"509":[{"id":"509","fileName":"1575117484.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,int>m;\n        int n=nums.size();\n        vector<int>prev(n,-1);\n        vector<int>next(n,-1);\n        for(int i=0;i<n;i++)\n            {\n                if(m.count(nums[i]))\n                prev[i]=m[nums[i]];\n                \n                m[nums[i]]=i;\n            }\n        for(int i=0;i<n;i++)\n            {\n                if(prev[i]==-1&&m[nums[i]]!=i)\n                {\n                    prev[i]=m[nums[i]];\n                }\n            }\n        for(int i=0;i<n;i++)\n            {\n                if(prev[i]!=-1)\n                next[prev[i]]=i;\n            }\n        vector<int>ans;\n        for(int j=0;j<queries.size();j++)\n            {\n                int i=queries[j];\n                if(prev[i]==-1)\n                {\n                    ans.push_back(-1);\n                }\n                else \n                {\n                    ans.push_back(min((i+n-prev[i])%n,(next[i]+n-i)%n));\n                }\n            }\n        return ans;\n        \n        \n    }\n};","author":"omkar","submissionId":"1575117484"},[]]},{"510":[{"id":"510","fileName":"1575117413.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> dict;\n        for (auto i = 0; i < nums.size(); ++i) {\n            dict[nums[i]].emplace_back(i);\n        }\n\n        vector<int> result;\n        for (auto query : queries) {\n            auto num = nums[query];\n\n            if (dict[num].size() == 1) {\n                result.emplace_back(-1);\n                continue;\n            }\n            \n            auto lb = lower_bound(dict[num].begin(), dict[num].end(), query);\n            auto pos = *lb;\n            auto prev = lb == dict[num].begin()\n                            ? dict[num].back()\n                            : dict[num][lb - dict[num].begin() - 1];\n            lb++;\n            auto next = lb == dict[num].end() ? dict[num][0] : *lb;\n\n            result.emplace_back(\n                min(pos > prev ? pos - prev : pos + nums.size() - prev,\n                    next > pos ? next - pos : next + nums.size() - pos));\n        }\n\n        return result;\n    }\n};","author":"Piggy Wang","submissionId":"1575117413"},[]]},{"511":[{"id":"511","fileName":"1575117409.txt","sourceCode":"class Node:\n    def __init__(self, idx):\n        self.idx = idx\n        self.next = None\n        self.prev = None\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        num2lists = {}\n        idx2node = {}\n        for i, num in enumerate(nums):\n            node = Node(idx=i)\n            if num in num2lists:\n                tail = num2lists[num].prev\n                tail.next = node\n                node.prev = tail\n                node.next = num2lists[num]\n                num2lists[num].prev = node\n            else:\n                node.next = node\n                node.prev = node\n                num2lists[num] = node\n            idx2node[i] = node\n        \n        ans = []\n        for q in queries:\n            node = idx2node[q]\n            if node.next == node:\n                ans.append(-1)\n            else:\n                prev = node.prev\n                next = node.next\n                prevDist = (node.idx - prev.idx) % n\n                nextDist = (next.idx - node.idx) % n\n                minDist = min(prevDist, n - prevDist, nextDist, n - nextDist)\n                ans.append(minDist)\n        return ans","author":"ffjiang","submissionId":"1575117409"},[]]},{"512":[{"id":"512","fileName":"1575117608.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        index = defaultdict(list)\n        for i in range(len(nums)):\n            index[nums[i]].append(i)\n\n        def get_min_dist(all_idx, idx, n):\n            m = len(all_idx)\n            if m == 2:\n                a = abs(all_idx[idx] - all_idx[(idx+1) % m]) % n\n                b = n - a\n                return min(a, b)\n\n            a = all_idx[(idx+1) % m] - all_idx[idx] if all_idx[(idx+1) % m] > all_idx[idx] else n - (all_idx[idx] - all_idx[(idx+1) % m])\n            \n            b = all_idx[idx] - all_idx[idx-1] if all_idx[idx] > all_idx[idx-1] else n - (all_idx[idx-1] - all_idx[idx]) \n            \n            return min(a, b)\n            \n\n        result = []\n        for idx in queries:\n            x = nums[idx]\n            if len(index[x]) == 1:\n                result.append(-1)\n                continue\n\n            m = len(index[x])\n            t = bisect_left(index[x], idx)\n            # print(index[x])\n            # print(\"t==\",t)\n            dist = get_min_dist(index[x], t, len(nums))\n            result.append(dist)\n\n        return result\n            ","author":"DietCoke","submissionId":"1575117608"},[]]},{"513":[{"id":"513","fileName":"1575117627.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        std::ios_base::sync_with_stdio(false);\n        std::cin.tie(NULL);\n\n        int n=nums.size();\n        unordered_map<int,vector<int>> idx;\n        for(int i=0;i<n;i++){\n            idx[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n\n        for(auto &i : queries){\n            int index=i;\n            int num=nums[index];\n\n            if(idx[num].size()==1){\n                ans.push_back(-1);\n                continue;\n            }\n\n            int minDist=INT_MAX;\n\n            int l=0,r=idx[num].size()-1;\n            int curr=-1;\n            while(l<=r){\n                int mid=l+(r-l)/2;\n                if(idx[num][mid]==index){\n                    curr=mid;\n                    break;\n                }\n                if(idx[num][mid]>index){\n                    r=mid-1;\n                }\n                else{\n                    l=mid+1;\n                }\n            }\n\n            if(curr>0){\n                minDist=min(minDist,index-idx[num][curr-1]);\n            }\n            if(curr<idx[num].size()-1){\n                minDist=min(minDist,idx[num][curr+1]-index);\n            }\n\n            minDist=min({minDist,index + n - (int)idx[num].back(),idx[num][0] + n - index});\n            ans.push_back(minDist);    \n        }\n        return ans;\n        \n    }\n};","author":"lakshitjainn","submissionId":"1575117627"},[]]},{"514":[{"id":"514","fileName":"1575117590.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        nums = nums[:] + nums[:]\n        left = [float('inf') for _ in range(n*2)]\n        right = [float('inf') for _ in range(n*2)]\n        \n        tmp = {}\n        for i in range(2*n):\n            if nums[i] in tmp:\n                left[i] = i - tmp[nums[i]]\n            tmp[nums[i]] = i\n        tmp = {}\n        for i in range(2*n-1,-1,-1):\n            if nums[i] in tmp:\n                right[i] = tmp[nums[i]] - i\n            tmp[nums[i]] = i\n        #print (left, right)\n        res = [float('inf')] * n\n        a = left[:n]\n        b = left[n:]\n        c = right[:n]\n        d = right[n:]\n        for i in range(n):\n            res[i] = min(a[i], b[i],c[i],d[i])\n            \n        ans = []\n        for q in queries:\n            if res[q] < n:\n                ans.append(res[q])\n            else:\n                ans.append(-1)\n        \n        \n        return ans\n        ","author":"YanlinGong","submissionId":"1575117590"},[]]},{"515":[{"id":"515","fileName":"1575117628.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, TreeSet<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.computeIfAbsent(nums[i], x -> new TreeSet<>()).add(i);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for(int q : queries) {\n            if(map.get(nums[q]).size() == 1) {\n                ans.add(-1);\n                continue;\n            }\n            \n            int dist = Integer.MAX_VALUE;\n            Integer left = map.get(nums[q]).lower(q);\n            if(left != null){\n                int curDist = Math.min(q-left, nums.length-q+left);\n                dist = Math.min(dist, curDist);\n            }\n            Integer first = map.get(nums[q]).first();\n            if(first != null && first < q){\n                dist = Math.min(dist, nums.length-q+first);\n            }\n\n            Integer right = map.get(nums[q]).higher(q);\n            if(right != null){\n                int curDist = Math.min(right-q, nums.length-right+q);\n                dist = Math.min(dist, curDist);\n            }\n            Integer last = map.get(nums[q]).last();\n            if(last != null && last > q){\n                dist = Math.min(dist, nums.length-last+q);\n            }\n            ans.add(dist);\n        }\n        return ans;\n    }\n}","author":"STGD","submissionId":"1575117628"},[]]},{"516":[{"id":"516","fileName":"1575117619.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<int> ans(m,-1);\n        unordered_map<int,vector<int>> index;\n        for(int i = 0;i < n;i ++) index[nums[i]].push_back(i);\n\n\n        for(int i = 0;i < m;i ++){\n            int j = queries[i];\n            if(index[nums[j]].size() == 1) continue;\n            auto& vec = index[nums[j]];\n            int indx = lower_bound(vec.begin(),vec.end(),j) - vec.begin();\n            int sz = vec.size();\n            int left = (vec[indx] - vec[(indx - 1 + sz) % sz] + n) % n;\n            int right = (vec[(indx + 1) % sz] - vec[indx] + n) % n;\n            ans[i] = min(left,right);\n        }\n\n        return ans;\n    }\n};","author":"LeThanhCong","submissionId":"1575117619"},[]]},{"517":[{"id":"517","fileName":"1575117634.txt","sourceCode":"import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> solveQueries(int[] arr, int[] queries) {\n\n\n        HashMap<Integer, Integer> last = new HashMap<>();\n        HashMap<Integer, Integer> first = new HashMap<>();\n\n        for (int i = 0; i < arr.length; i++) {\n            if (!first.containsKey(arr[i])) {\n                first.put(arr[i], i);\n            }\n            last.put(arr[i], i);\n        }\n\n        HashMap<Integer, Integer> recent = new HashMap<>();\n//        for (var entry : last.entrySet()) {\n//            recent.put(entry.getKey(), entry.getValue() - arr.length);\n//        }\n        int[] lastSame = new int[arr.length];\n        Arrays.fill(lastSame, - 1);\n        for (int i = 0; i < arr.length; i++) {\n            int v = arr[i];\n            if (recent.containsKey(v)) {\n                lastSame[i] = recent.get(v);\n            }\n            recent.put(v, i);\n        }\n        \n        int[] nextSame = new int[arr.length];\n        Arrays.fill(nextSame, arr.length);\n        recent.clear();\n        for (int i = arr.length - 1; i >= 0; i--) {\n            int v = arr[i];\n            if (recent.containsKey(v)) {\n                nextSame[i] = recent.get(v);\n            }\n            recent.put(v, i);\n        }\n        // System.out.println(last);\n        // System.out.println(first);\n        // System.out.println(Arrays.toString(lastSame));\n        // System.out.println(Arrays.toString(nextSame));\n\n        List<Integer> ans = new ArrayList<>();\n        for (int i = 0; i < queries.length; i++) {\n            int minDist = arr.length;\n            int idx = queries[i];\n            int l = lastSame[idx];\n            if (l >= 0) {\n                minDist = idx - l;\n            }\n            if (last.get(arr[idx]) > idx) {\n                l = last.get(arr[idx]) - arr.length;\n                minDist = Math.min(minDist, idx - l);\n            }\n            int r = nextSame[idx];\n            if (r < arr.length) {\n                minDist = Math.min(minDist, r - idx);\n            }\n            if (first.get(arr[idx]) < idx) {\n                r = first.get(arr[idx]) + arr.length;\n                minDist = Math.min(minDist, r - idx);\n            }\n            ans.add(minDist == arr.length ? -1 : minDist);\n        }\n        return ans;\n\n\n    }\n}","author":"zokumyoin","submissionId":"1575117634"},[]]},{"519":[{"id":"519","fileName":"1575117690.txt","sourceCode":"class Solution:\n\n    \n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n            def circular_distance(a, b, n):\n                diff = abs(a - b)\n                return min(diff, n - diff)\n            n = len(nums)\n            ans = [-1] * n\n            from collections import defaultdict\n            pos_map = defaultdict(list)\n\n            for i, num in enumerate(nums):\n                pos_map[num].append(i)\n\n            for indices in pos_map.values():\n                if len(indices) > 1:\n                    indices.sort()\n                    k = len(indices)\n                    for i in range(k):\n                        cur = indices[i]\n                        nxt = indices[(i + 1) % k]\n                        prv = indices[i - 1]\n                        ans[cur] = min(circular_distance(cur, nxt, n), circular_distance(cur, prv, n))\n\n            return [ans[q] for q in queries]\n        ","author":"ATCHAYAAT","submissionId":"1575117690"},[]]},{"520":[{"id":"520","fileName":"1575117632.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, set<int>> indexes;\n        for (int i = 0; i < nums.size(); ++i) {\n            indexes[nums[i]].insert(i);\n        }\n        vector<int> res;\n        for (auto q : queries) {\n            const auto& index = indexes[nums[q]];\n            if (index.empty())\n                res.push_back(-1);\n            else {\n                int dist = INT_MAX;\n                auto right_it = index.upper_bound(q);\n                if (right_it != end(index)) {\n                    dist = min<int>(*right_it - q, q + nums.size() - *right_it);\n                }\n                else if (index.size() != 1) {\n                    dist = min(dist, *index.begin() + (int)nums.size() - q);\n                }\n                auto left_it = index.lower_bound(q);\n                if (left_it != begin(index)) {\n                    --left_it;\n                    dist = min({dist, q - *left_it, (int)nums.size() - q + *left_it});\n                }\n                else if (index.size() != 1) {\n                    dist = min(dist, (int)nums.size() - *rbegin(index) + q);\n                }\n                if (dist == INT_MAX)\n                    dist = -1;\n               res.push_back(dist);\n            }\n        }\n        return res;\n    }\n};","author":"ahong107","submissionId":"1575117632"},[]]},{"521":[{"id":"521","fileName":"1575117956.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,set<int>> h;\n        int n = (int)nums.size();\n        for(int i=0;i<n;++i){\n            h[nums[i]].insert(i);\n        }\n        int q = (int)queries.size();\n        vector<int> ans(q, -1);\n        for(int i=0;i<q;++i){\n            int lans = 1e9;\n            int pos = queries[i];\n            int num = nums[queries[i]];\n            if((int)h[num].size()==1){\n                continue;\n            }\n            auto lo = h[num].lower_bound(pos);\n            if(lo!=h[num].begin()){\n                --lo;\n                lans = min(lans, pos - (*lo));\n            }\n            auto up = h[num].upper_bound(pos);\n            if(up!=h[num].end()){\n                lans = min(lans, (*up) - pos);\n            }\n            lans = min(lans, n-pos+*h[num].begin());\n            //cout << queries[i] << \" \" << (n-1-*(--h[num].end())) << endl;\n            lans = min(lans, pos+1+(n-1-*(--h[num].end())));\n            ans[i] = lans;\n        }\n        return ans;\n    }\n};\n\n","author":"Ritik","submissionId":"1575117956"},[]]},{"522":[{"id":"522","fileName":"1575117695.txt","sourceCode":"class Solution {\n  public List<Integer> solveQueries(int[] nums, int[] qs) {\n    int n = nums.length;\n    \n    HashMap<Integer, List<Integer>> map = new HashMap<>();\n    for (int i = 0; i < n; i++) {\n      map.putIfAbsent(nums[i], new ArrayList<>());\n      map.get(nums[i]).add(i);\n    }\n\n    List<Integer> res = new ArrayList<>();\n    for (int i = 0; i < qs.length; i++) {\n      int val = nums[qs[i]];\n      List<Integer> idxs = map.get(val);\n      \n      if (idxs.size() == 1) {\n        res.add(-1);\n        continue;\n      }\n      // System.out.println(qs[i] + \" \" + idxs);\n\n      int idx = Collections.binarySearch(idxs, qs[i]);\n      int l = idx - 1, r = idx + 1;\n      if (l < 0) l = idxs.size() - 1;\n      if (r >= idxs.size()) r = 0;\n\n      int lidx = idxs.get(l), ridx = idxs.get(r);\n      // System.out.println(\"lidx ridx \" + lidx + \" \" + ridx);\n      \n      int ldist = Integer.MAX_VALUE, rdist = Integer.MAX_VALUE;\n      if (l != idx) ldist = computeDist(lidx, qs[i], n);\n      if (r != idx) rdist = computeDist(qs[i], ridx, n);\n      // System.out.println(\"ldsit \" + ldist + \" \" + rdist);\n\n      res.add(Math.min(ldist, rdist));\n    }\n    return res;\n  }\n\n  private int computeDist(int l, int r, int n) {\n    if (l > r) return computeDist(r, l, n);\n\n    return Math.min(r - l, l + n - r);\n  }\n}","author":"DCDC","submissionId":"1575117695"},[]]},{"523":[{"id":"523","fileName":"1575118041.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int len = nums.size();\n        unordered_map<int, vector<int>> idx;\n        for (int i = 0; i < len; i++)\n            idx[nums[i]].push_back(i);\n        int curr, currLen, pos;\n        int minDis1, minDis2;\n        vector<int> result;\n        for (int query: queries) {\n            curr = nums[query], currLen = idx[curr].size();\n            if (currLen < 2)\n                result.push_back(-1);\n            else {\n                pos = lower_bound(idx[curr].begin(), idx[curr].end(), query) - idx[curr].begin();\n                minDis1 = abs(idx[curr][pos] - idx[curr][(pos + currLen - 1) % currLen]);\n                minDis1 = min(minDis1, len - minDis1);\n                minDis2 = abs(idx[curr][pos] - idx[curr][(pos + currLen + 1) % currLen]);\n                minDis2 = min(minDis2, len - minDis2);\n                result.push_back(min(minDis1, minDis2));\n            }\n        }\n        return result;\n    }\n};","author":"Neil Shen","submissionId":"1575118041"},[]]},{"524":[{"id":"524","fileName":"1575118096.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        maxi = max(nums)\n        def dist(a, b, n):\n            left = min(a, b)\n            right = max(a,b)\n            return min(right-left, left+n - right)\n        queryVals = set()\n        freq = {}\n        for i in queries:\n            queryVals.add(nums[i])\n            freq[nums[i]] = []\n        for idx, i in enumerate(nums):\n            if i in queryVals:\n                freq[i].append(idx)\n        res = {}\n        n = len(nums)\n        for i in queryVals:\n            for idx, j in enumerate(freq[i]):\n                l = len(freq[i])\n                before = freq[i][idx-1]\n                after = freq[i][(idx+1)%l]\n                res[j] = float('inf')\n                if (before != j):\n                    res[j] = dist(before, j, n)\n                if (after != j):\n                    res[j] = min(res[j], dist(after, j, n))\n                if (res[j] == float('inf')):\n                    res[j] = -1\n                    \n        ans = []\n        for i in queries:\n            ans.append(res[i])\n        return ans","author":"Evan","submissionId":"1575118096"},[]]},{"525":[{"id":"525","fileName":"1575117897.txt","sourceCode":"import bisect\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        \n        my_map = {}\n        \n        for i,n in enumerate(nums):\n            if n not in my_map:\n                my_map[n] = []\n            my_map[n].append(i)\n        \n        ans = []\n        for q in queries:\n            key = nums[q]\n            \n            if len(my_map[key])==1:\n                ans.append(-1)\n                continue\n            \n            idx = bisect.bisect_left(my_map[key], q)\n            prev = my_map[key][idx-1]\n            nexts = my_map[key][(idx+1)%len(my_map[key])]\n            if prev>q:\n                prev -= len(nums)\n            if nexts<q:\n                nexts+= len(nums)\n            ans.append(min(q-prev,nexts-q))\n        return ans\n        ","author":"Rachit Yagnik","submissionId":"1575117897"},[]]},{"526":[{"id":"526","fileName":"1575117828.txt","sourceCode":"class Solution {\nint min(int a,int b){\n    if(a<b){return a;}\n    return b;\n}\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>> m;\n        for(int i=0;i<nums.size();i++){\n            m[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(int i=0;i<queries.size();i++){\n            int x=nums[queries[i]];\n            if(m[x].size()==1){ans.push_back(-1);}\n            else{\n                int index=-1;\n                int s=0,e=m[x].size()-1;\n                while(s<=e){\n                    int mid=s+(e-s)/2;\n                    if(m[x][mid]==queries[i]){index=mid;break;}\n                    else if(m[x][mid]>queries[i]){e=mid-1;}\n                    else{s=mid+1;}\n                }\n                int curr=INT_MAX;\n                if(index-1>=0){\n                    cout<<queries[i]-m[x][index-1]<<endl;\n                    curr=min(curr,queries[i]-m[x][index-1]);\n                }\n                else{\n                    cout<<queries[i]+nums.size()-m[x].back()<<endl;\n                    curr=min(curr,queries[i]+nums.size()-m[x].back());\n                }\n                if(index+1<m[x].size()){\n                    cout<<m[x][index+1]+1-queries[i]<<endl;\n                    curr=min(curr,m[x][index+1]-queries[i]);\n                }\n                else{\n                    cout<<nums.size()-queries[i]+m[x][0]<<endl;\n                    curr=min(curr,nums.size()-queries[i]+m[x][0]);\n                }\n                ans.push_back(curr);\n            }\n        }\n        return ans;\n    }\n};","author":"yashsinghbhadauria05","submissionId":"1575117828"},[]]},{"527":[{"id":"527","fileName":"1575118075.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        ans = [-1 for _ in range(len(queries))]\n        numIdx = defaultdict(list)\n        for i, num in enumerate(nums):\n            numIdx[num].append(i)\n        for i, idx in enumerate(queries):\n            val = nums[idx]\n            # find the same val in nums\n            if len(numIdx[val])>1:\n                _m = len(numIdx[val])\n                _idx = bisect.bisect_left(numIdx[val], idx)\n                _l1, _l2 =abs(numIdx[val][(_idx+1) % _m] -numIdx[val][_idx]) , abs(numIdx[val][(_idx-1) % _m]-numIdx[val][_idx])\n                  \n                ans[i]= min(_l1, _l2, n-_l1, n-_l2)\n        return ans","author":"codemonkey66","submissionId":"1575118075"},[]]},{"528":[{"id":"528","fileName":"1575118144.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int, vector<int>> m;\n        for(int i=0; i<n; i++){\n            m[nums[i]].push_back(i-n);\n        }\n        for(int i=0; i<n; i++){\n            m[nums[i]].push_back(i);\n        }\n        for(int i=0; i<n; i++){\n            m[nums[i]].push_back(n+i);\n        }\n        vector<int> res;\n        for(auto &i:queries){\n            if(m[nums[i]].size()==3){\n                res.push_back(-1);\n            }\n            else{\n                auto it = lower_bound(m[nums[i]].begin(), m[nums[i]].end(), i);\n                it--;\n                int j = *it;\n                it++;\n                it++;\n                int k = *it;\n                res.push_back(min(i-j, k-i));\n            }\n        }\n        return res;\n    }\n};","author":"Ranjith_J_23","submissionId":"1575118144"},[]]},{"529":[{"id":"529","fileName":"1575118158.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> m;\n        for(int i=0;i<nums.size();i++){\n            m[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(auto &x:queries){\n             int curr=nums[x];\n             if(m[curr].size()==1) ans.push_back(-1);\n             else{\n                 int d=INT_MAX;\n                 int ind=lower_bound(m[curr].begin(),m[curr].end(),x)-m[curr].begin();\n                 if(ind-1<0){\n                     d=min(d,x+int(nums.size()-*(--m[curr].end())));\n                 }\n                 else d=min(d,x-m[curr][ind-1]);\n                 \n                 if(ind+1>=m[curr].size()){\n                     d=min(d,int(nums.size())-x+m[curr][0]);\n                 }\n                 else d=min(d,m[curr][ind+1]-x);\n                 ans.push_back(d);\n             }   \n                \n        }\n        return ans;\n        \n    }\n};","author":"sohailkasmani007","submissionId":"1575118158"},[]]},{"531":[{"id":"531","fileName":"1575117962.txt","sourceCode":"\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(x) x.begin() , x.end() \n#define rall(x) x.rbegin() , x.rend()\n#define INF 1e18\n#define PI 3.1415926535897932384626433832795\n#define rep(i,s,e) for(long long i = s ; i < e ; i++)\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\ntypedef pair<int , int> pii;\ntypedef pair<long long , long long> pll; \ntypedef vector<long long> vll;\ntypedef vector<int> vi;\ntypedef vector<pair<int ,int>> vpii;\ntypedef vector<pair<long long , long long>> vpll;\ntypedef vector<vector<char>> vcc;\ntypedef vector<char> vc;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size() , m = queries.size();\n        map<int , vector<int>> mp;\n        for(int i =  0 ; i < n ; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        \n        for(auto & it : mp) sort(it.se.begin() , it.se.end());\n        vector<int> ret;\n        \n        for(int i = 0 ; i < m ; i++) {\n            int query = queries[i];\n            vector<int>& a = mp[nums[query]];\n            if(a.size() == 1) {\n                ret.push_back(-1);\n            }\n            else {\n                int ind = lower_bound(a.begin() , a.end() , query) - a.begin();\n                int l , r;\n                if(ind == 0) l = a.back();\n                else l = a[ind - 1];\n                if(ind == a.size() - 1) r = a.front();\n                else r = a[ind + 1];\n                \n                int d1 = min(( abs(query - l)) , n - abs(query - l));\n                int d2 = min(( abs(query - r)) , n - abs(query - r));\n                \n                ret.push_back(min(d1 , d2));\n                \n            }\n        }\n        \n        return ret;\n    }\n};","author":"Mohammed Nayeem","submissionId":"1575117962"},[]]},{"532":[{"id":"532","fileName":"1575117661.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        dict = {}\n        \n        for i, num in enumerate(nums):\n            if num not in dict:\n                dict[num] = []\n            dict[num].append(i)\n        \n        res = []\n        for q in queries:\n            v = nums[q]\n            i = dict[v]\n            \n            if len(i) == 1:\n                res.append(-1)\n                continue\n                \n            pos = bisect_left(i, q)\n            dist = float('inf')\n            \n            if pos > 0:\n                dist = min(dist, q - i[pos - 1])\n            if pos < len(i) - 1:\n                dist = min(dist, i[pos + 1] - q)\n            dist = min(dist, q + n - i[-1])\n            dist = min(dist, i[0] + n - q)\n            res.append(dist)\n        return res","author":"Cryptic-Technomage","submissionId":"1575117661"},[]]},{"533":[{"id":"533","fileName":"1575118243.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& asks) {\n\n        int n = nums.size(), q = asks.size();\n        map<int, int> last;\n        map<int, int> next, fir;\n\n        for (int g = 0; g < n; g++)\n            if (!fir.count(nums[g]))\n                fir[nums[g]] = g;\n        for (int g = n - 1; g >= 0; g--) {\n            if (last.count(nums[g]))\n                next[g] = last[nums[g]];\n            else\n                next[g] = -1;\n            last[nums[g]] = g;\n        }\n\n        map<int, int> prv, sec;\n        last.clear();\n\n        for (int g = n - 1; g >= 0; g--)\n            if (!sec.count(nums[g]))\n                sec[nums[g]] = g;\n\n        for (int g = 0; g < n; g++) {\n            if (last.count(nums[g]))\n                prv[g] = last[nums[g]];\n            else\n                prv[g] = -1;\n            last[nums[g]] = g;\n        }\n\n        vector<int> ans;\n        for (auto& it : asks) {\n\n            int res = INT_MAX;\n            if (next[it] != -1)\n                res = (next[it] - it);\n            if (prv[it] != -1)\n                res = min(res, it - prv[it]);\n\n            if (fir[nums[it]] != it) {\n                int temp = n - it + fir[nums[it]];\n                res = min(res, temp);\n            }\n            if (sec[nums[it]] != it) {\n                int temp = it + n - sec[nums[it]];\n                res = min(res, temp);\n            }\n\n            if (res == INT_MAX)\n                res = -1;\n            ans.push_back(res);\n        }\n        return ans;\n    }\n};","author":"George Magde","submissionId":"1575118243"},[]]},{"534":[{"id":"534","fileName":"1575118309.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> m;\n        vector<int> pos(nums.size(), 0);\n        for (int i = 0; i < nums.size(); i++) {\n            int n = nums[i];\n            pos[i] = m[n].size();\n            m[n].push_back(i);\n        }\n        vector<int> ret(queries.size(), -1);\n        for (int i = 0; i < queries.size(); i++) {\n            int n = queries[i];\n            int p = pos[n];\n            const vector<int>& vec = m[nums[n]];\n            if (vec.size() == 1) continue;\n            int next = (p + 1) % vec.size();\n            int prev = (p + vec.size() - 1) % vec.size();\n            //cout << i << \" \" << n << \" \" << p << \" \" << next << \" \" << prev << \" \" << vec.size() << endl;\n\n            next = vec[next] - vec[p];\n            if (next < 0) {\n                next += nums.size();\n            }\n            prev = vec[p] - vec[prev];\n            if (prev < 0) {\n                prev += nums.size();\n            }\n            ret[i] = min(next, prev);\n        }\n        return ret;\n    }\n};\n\n/*\nTake all the elements of nums with value k, put them into an array, sorted, Then each number will be closest to the number immediately after, or immediately before\n\nConstruct a map<int, vector<int>> val -> positions with the val.\nConstruct the vector<int> in order.\nAfterwards we can iterate through each of the vectors, find the solution, and store it in a separate vector\nThen the queries can just read our precomputed solutions\n\nWe don't really want to store this map though, if each one stores a pointer to the previous one, at the end we can reconstruct it\n*/","author":"nsmartinx","submissionId":"1575118309"},[]]},{"535":[{"id":"535","fileName":"1575118197.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int>ans;\n        unordered_map<int, vector<int>>ma;\n        int n = nums.size();\n        for (int i=0;i<n;i++){\n            ma[nums[i]].push_back(i);\n        }\n        for(int i=0;i<queries.size();i++){\n            int x = queries[i];\n            vector<int>&v = ma[nums[x]];\n            if(v.size()==1){\n                ans.push_back(-1);\n                continue;\n            }\n            auto it = lower_bound(v.begin(), v.end(), x);\n            int a=1e9;\n            if(it+1!=v.end()){\n                int diff = abs(*(it+1) - x);\n                a= min(a, min(diff, n-diff));\n            }\n            else{\n                int diff = abs(*v.begin() - x);\n                a= min(a, min(diff, n-diff));\n            }\n            if(it!=v.begin()){\n                int diff = abs(*(it-1) - x);\n                a = min(a, min(diff, n-diff));\n            }\n            else{\n                int diff = abs(*v.rbegin() - x);\n                a= min(a, min(diff, n-diff));\n            }\n            ans.push_back(a);\n        }\n        return ans;\n    }\n};","author":"Siddharth Bisht","submissionId":"1575118197"},[]]},{"536":[{"id":"536","fileName":"1575118255.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& v, vector<int>& q) {\n        // int nn=v.size();\n        // for(int i=0;i<nn;i++){\n        //     v.push_back(v[i]);\n        // }\n        int n=v.size();\n        map<int,vector<int>> m;\n        for(int i=0;i<n;i++){\n            m[v[i]].push_back(i);\n        }\n        int mm=q.size();\n        vector<int> ans(mm);\n        for(int i=0;i<mm;i++){\n            int num=v[q[i]];\n            int idx=lower_bound(m[num].begin(),m[num].end(),q[i])-m[num].begin();\n            int ii=m[num][idx];\n            int mn=1e9;\n            if(idx-1>=0){\n                mn=min(mn,abs(m[num][idx-1]-q[i]));\n                mn=min(mn,n-(abs(m[num][idx-1]-q[i])));\n            }\n            if(idx+1<m[num].size()){\n                mn=min(mn,abs(m[num][idx+1]-q[i]));\n                mn=min(mn,n-(abs(m[num][idx+1]-q[i])));\n            }\n            mn=min(mn,n-abs(m[num][0]-q[i]));\n            mn=min(mn,n-abs(m[num][m[num].size()-1]-q[i]));\n            if(mn==1e9){\n                mn=-1;\n            }\n            if(mn==n){\n                mn=-1;\n            }\n            ans[i]=mn;\n        }\n        return ans;\n    }\n};","author":"abhi2004iiti","submissionId":"1575118255"},[{"id":"846","similarity":0.7342342342342343,"totOverlap":163,"longestOverlap":12},{"id":"1209","similarity":0.7142857142857143,"totOverlap":140,"longestOverlap":15}]],"846":[{"id":"846","fileName":"1575126572.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>>mp;\n        int n=nums.size(),m=queries.size();\n        vector<int>ans(m,-1);\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        for(int i=0;i<m;i++){\n            int curr=nums[queries[i]];\n            if(mp[curr].size()==1)continue;\n            int ind=lower_bound(mp[curr].begin(),mp[curr].end(),queries[i])-mp[curr].begin();\n            int mini=n;\n            if(ind-1>=0){\n                mini=min(mini,abs(mp[curr][ind-1]-queries[i]));\n            }\n            if(ind+1<mp[curr].size()){\n                mini=min(mini,abs(mp[curr][ind+1]-queries[i]));\n            }\n            mini = min(mini, n - abs(mp[curr].front() - queries[i]));\n            mini = min(mini, n - abs(mp[curr].back() - queries[i]));\n            ans[i]=mini;\n        }\n        return ans;\n    }\n};","author":"Divyansh Saharan","submissionId":"1575126572"},[{"id":"536","similarity":0.7342342342342343,"totOverlap":163,"longestOverlap":12}]],"1028":[{"id":"1028","fileName":"1575131152.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int pp = nums.size();\n        map<int, vector<int>> m;\n        for(int i = 0;i<nums.size();i++){\n            m[nums[i]].push_back(i);\n        }\n        vector<int> ans(queries.size());\n        for(int i = 0;i<queries.size();i++){\n            int k = nums[queries[i]];\n            if(m[k].size() == 1){\n                ans[i] = -1;\n                continue;\n            }\n            int a = lower_bound(m[k].begin(), m[k].end(), queries[i]) - m[k].begin();\n            int res = INT_MAX;\n            int n = m[k].size();\n            res = min(res, abs(m[k][(a+n-1) % n] - queries[i]));\n            res = min(res, abs(m[k][(a+1) % n] - queries[i]));\n            res = min(res, pp - abs(m[k][(a+n-1) % n] - queries[i]));\n            res = min(res, pp - abs(m[k][(a+1) % n] - queries[i]));\n            // cout<<abs(m[k][(a+n-1) % n] - queries[i])<<\" \";\n            // cout<<abs(m[k][(a+1) % n] - queries[i])<<endl;\n            ans[i] = res;\n        }\n        return ans;\n    }\n};","author":"Ankur karn","submissionId":"1575131152"},[{"id":"1209","similarity":0.8092783505154639,"totOverlap":157,"longestOverlap":15},{"id":"846","similarity":0.7142857142857143,"totOverlap":140,"longestOverlap":15}]],"1209":[{"id":"1209","fileName":"1575136003.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        unordered_map <int,vector<int>> m;\n        int n = nums.size();\n        for(int i=0;i<n;i++) {\n            m[nums[i]].push_back(i);\n        }\n        int x = q.size();\n        vector <int> ans(x,-1); \n        for(int i=0;i<x;i++) {\n            int tmp = nums[q[i]];\n            if(!m.count(tmp) || m[tmp].size() == 1) continue;\n            int it = lower_bound(m[tmp].begin(),m[tmp].end(),q[i]) - \n            m[tmp].begin();\n            int l = INT_MAX,s = m[tmp].size();\n            // cout<<it<<\" \";\n            // if(it > 0) {\n                l = min(abs(q[i]-m[tmp][(s+it-1)%s]),\n                    n - abs(q[i]-m[tmp][(s+it-1)%s]));\n                // cout<<m[tmp][it-1]<<\" \";\n            // }\n            // cout<<l<<\" \";\n            // if(it < m[tmp].size()-1) {\n                l = min(l,abs(m[tmp][(it+1)%s] - q[i]));\n                // cout<<l<<\" \";\n                l = min(l,n - abs(m[tmp][(it+1)%s] - q[i]));\n                // cout<<l<<\" \";\n            // }\n            // cout<<endl;\n            ans[i] = l;\n        }\n        return ans;\n    }\n};","author":"RGM","submissionId":"1575136003"},[{"id":"1028","similarity":0.8092783505154639,"totOverlap":157,"longestOverlap":15}]]},{"537":[{"id":"537","fileName":"1575118402.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        hm = defaultdict(list)\n\n        for i, num in enumerate(nums):\n            hm[num].append(i)\n        #print(hm)\n        res = [-1] * len(queries)\n        for i, query in enumerate(queries):\n            if len(hm[nums[query]]) == 1:\n                continue\n            #print(\"query:\", query)\n            idx = bisect.bisect(hm[nums[query]], query)\n            idx -= 1\n            #print(\"idx:\", idx)\n            first = hm[nums[query]][(idx + 1) % len(hm[nums[query]])]\n            second = hm[nums[query]][(idx - 1 + len(hm[nums[query]])) % len(hm[nums[query]])]\n            if first < query:\n                first += len(nums)\n            if second > query:\n                second -= len(nums)\n            #print(first)\n            #print(second)\n            res[i] = min(abs(first - query), abs(second - query) )\n        return res\n            \n            ","author":"nchu05","submissionId":"1575118402"},[]]},{"538":[{"id":"538","fileName":"1575118457.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        for(int i = 0 ; i < n ; i++) nums.push_back(nums[i]);\n        for(int i = 0 ; i < n ; i++) nums.push_back(nums[i]);\n        map<int , int> mp;\n        vector<int> pre(3 * n , -1) , suff(3 * n , -1);\n        for(int i = 0 ; i < 3 * n ; i++){\n            if(mp.find(nums[i]) != mp.end()) pre[i] = mp[nums[i]];\n            mp[nums[i]] = i;\n        }\n        mp.clear();\n        for(int i = 3 * n - 1 ; i >= 0 ; i--){\n            if(mp.find(nums[i]) != mp.end()) suff[i] = mp[nums[i]];\n            mp[nums[i]] = i;\n        }\n        vector<int> arr(3 * n , 0);\n        for(int i = 0 ; i < 3 * n ; i++){\n            int left = INT_MAX , right = INT_MAX;\n            if(pre[i] != -1) left = i - pre[i];\n            if(suff[i] != -1) right = suff[i] - i;\n            int mn = min(left , right);\n            if(mn >= n) arr[i] = -1;\n            else arr[i] = mn;\n        }\n        vector<int> ans;\n        for(auto p : queries) ans.push_back(arr[p + n]);\n        return ans;\n    }\n};","author":"Raj Singh","submissionId":"1575118457"},[]]},{"540":[{"id":"540","fileName":"1575118511.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& qs) {\n        int n=nums.size();\n        vector<int> pre(n, -1);\n        vector<int> post(n, -1);\n        \n        // left\n        map<int, int> last;\n        for(int i=1; i<n; i++)\n        {\n            last[nums[i]]=i;\n        }\n        for(int i=0; i<n; i++)\n        {\n            // cout<<i<<\" : \"<<nums[i]<<\" \";\n            if(last.count(nums[i]))\n            {\n                // cout<<last[nums[i]]<<endl;\n                if(last[nums[i]]>i)\n                {\n                    pre[i]=n-(last[nums[i]]-i);\n                }\n                else if(last[nums[i]]<i)\n                {\n                    pre[i]=i-last[nums[i]];\n                }\n            }\n            // else cout<<endl;\n            last[nums[i]]=i;\n        }\n\n        last.clear();\n\n        // right\n        for(int i=n-2; i>=0; i--)\n        {\n            last[nums[i]]=i;\n        }\n        for(int i=n-1; i>=0; i--)\n        {\n            if(last.count(nums[i]))\n            {\n                if(last[nums[i]]<i)\n                {\n                    post[i]=n-(i-last[nums[i]]);\n                }\n                else if(last[nums[i]]>i)\n                {\n                    post[i]=last[nums[i]]-i;\n                }\n            }\n\n            last[nums[i]]=i;\n        }\n\n        for(auto &q:qs) \n        {\n            if(pre[q]==-1 || post[q]==-1) q=max(pre[q], post[q]);\n            else q=min(pre[q], post[q]);\n        }\n\n        return qs;\n    }\n};","author":"Mintu Jupally","submissionId":"1575118511"},[]]},{"541":[{"id":"541","fileName":"1575118525.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> ans;\n        unordered_map<int, vector<int>> poses;\n        int n = nums.size();\n        for (auto [i, num] : ranges::views::enumerate(nums)) {\n            poses[num].push_back(i);\n        }\n\n        for (auto pos : queries) {\n            int num = nums[pos];\n            if (poses[num].size() == 1)\n                ans.push_back(-1);\n            else {\n                int map_pos = lower_bound(poses[num].begin(), poses[num].end(), pos) - poses[num].begin();\n                int l = map_pos == 0 ? poses[num].back() - n : poses[num][map_pos - 1];\n                int r = map_pos + 1 == poses[num].size() ? poses[num].front() + n : poses[num][map_pos + 1];\n                // cout << pos << \" \" << l << \" \" << r << endl;\n                int dist = min((pos - l) % n, (r - pos) % n);\n                ans.push_back(dist);\n            }\n        }\n        return ans;\n    }\n};","author":"Hieu","submissionId":"1575118525"},[]]},{"542":[{"id":"542","fileName":"1575118531.txt","sourceCode":"var solveQueries = function(nums, queries) {\n    const n = nums.length;\n    const valueToIndices = new Map();\n    for (let i = 0; i < n; i++) {\n        if (!valueToIndices.has(nums[i])) {\n            valueToIndices.set(nums[i], []);\n        }\n        valueToIndices.get(nums[i]).push(i);\n    }\n    \n    const circularDistance = (i, j, n) => {\n        return Math.min(Math.abs(i - j), n - Math.abs(i - j));\n    };\n    \n    const binarySearch = (arr, target) => {\n        let left = 0;\n        let right = arr.length - 1;\n        while (left <= right) {\n            let mid = Math.floor((left + right) / 2);\n            if (arr[mid] === target) {\n                return mid;\n            } else if (arr[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return -1;\n    };\n    \n    const result = [];\n    for (const q of queries) {\n        const v = nums[q];\n        const idx = valueToIndices.get(v);\n        if (idx.length === 1) {\n            result.push(-1);\n        } else {\n            const p = binarySearch(idx, q);\n            const k = idx.length;\n            const prevIdx = idx[(p - 1 + k) % k];\n            const nextIdx = idx[(p + 1) % k];\n            const dist1 = circularDistance(q, prevIdx, n);\n            const dist2 = circularDistance(q, nextIdx, n);\n            result.push(Math.min(dist1, dist2));\n        }\n    }\n    return result;\n};\n\n//thanks for the given oppurtunity for the leetcode to upleveling  my carrer.","author":"tony stark","submissionId":"1575118531"},[]]},{"545":[{"id":"545","fileName":"1575118566.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i=0; i<n; i++) {\n            if (!map.containsKey(nums[i])) map.put(nums[i], new ArrayList<>());\n            map.get(nums[i]).add(i);\n        }\n        List<Integer> list = new ArrayList<>();\n        for (int i=0; i<queries.length; i++) {\n            list.add(find(map.get(nums[queries[i]]), queries[i], n));\n        }\n        return list;\n    }\n    private int find(List<Integer> list, int targ, int n) {\n        int L = list.size();\n        if (L <= 1) return -1;\n        int left = 0, right = L-1;\n        while (left <= right) {\n            int mid = (right - left) / 2 + left;\n            if (list.get(mid) == targ) {\n                if (mid == L-1) return Math.min(list.get(0) + n - list.get(L-1), list.get(L-1) - list.get(L-2));\n                if (mid == 0) return Math.min(list.get(1) - list.get(0), list.get(0) + n - list.get(L-1));\n                return Math.min(list.get(mid+1) - list.get(mid), list.get(mid) - list.get(mid-1));\n            }\n            else if (list.get(mid) < targ) left = mid+1;\n            else right = mid-1;\n        }\n        return -1;\n    }\n}","author":"iris","submissionId":"1575118566"},[]]},{"547":[{"id":"547","fileName":"1575118644.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, TreeSet<Integer>> map = new HashMap<>();\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            map.computeIfAbsent(nums[i], k -> new TreeSet<>()).add(i);\n        }\n        int len = queries.length;\n        List<Integer> res = new ArrayList<>();\n        for (int  i = 0; i < len; i++) {\n            int index = queries[i];\n            TreeSet<Integer> set = map.get(nums[index]);\n            if (set.size() == 1) {\n                res.add(-1);\n                continue;\n            }\n            Integer left = set.lower(index);\n            if (left == null) {\n                left = set.last() - n;\n            }\n            Integer right = set.higher(index);\n            if (right  == null) {\n                right = set.first() + n;\n            }\n\n            if (index - left <= right - index) {\n                res.add(index - left );\n            } else {\n                res.add(right - index);\n            }\n        }\n        return res;\n    }\n}","author":"zhenghao","submissionId":"1575118644"},[]]},{"548":[{"id":"548","fileName":"1575118572.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        hashMap = defaultdict(list)\n        ans = [-1]*len(queries)\n        n = len(nums)\n        for idx,num in enumerate(nums) :\n            hashMap[num].append(idx)\n        for idx,query in enumerate(queries) :\n            indices = hashMap[nums[query]]\n            if len(indices) <= 1 :\n                continue\n            r = bisect.bisect_right(indices,query)\n            l = bisect.bisect_left(indices,query)\n            # print(l,r,indices)\n            l -= 1\n            if l < 0 :\n                l = len(indices) - 1\n            elif r >= len(indices) :\n                r = 0\n            left = (query - indices[l]) % n\n            right = (indices[r] - query) % n\n            cur = min(left,right)\n            ans[idx] = cur\n        return ans","author":"Yukesh R","submissionId":"1575118572"},[]]},{"550":[{"id":"550","fileName":"1575118658.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        k = 0\n        if k == 0:\n            k = 6\n        elif k == 8:\n            for i in range(4):\n                k += i\n        else:\n            k = k\n        from collections import defaultdict\n        import bisect\n        mp = defaultdict(list)\n        n = len(nums)\n        for i, num in enumerate(nums):\n            mp[num].append(i)\n        ans = []\n        k = 0\n        if k == 0:\n            k = 6\n        elif k == 8:\n            for i in range(4):\n                k += i\n        else:\n            k = k\n        for q in queries:\n            val = nums[q]\n            ind = mp[val]\n            if not (len(ind) != 1):\n                ans.append(-1)\n                continue\n            pos = bisect.bisect_left(ind, q)\n            ld = float('inf')\n            rd = float('inf')\n            if pos > 0:\n                ld = q - ind[pos - 1]\n            if pos < len(ind) - 1:\n                rd = ind[pos + 1] - q\n            cl = n - abs(q - ind[-1]) if ind[-1] != q else float('inf')\n            cr = n - abs(q - ind[0]) if ind[0] != q else float('inf')\n            ans.append(min(ld, rd, cl, cr))\n        return ans if ans == ans else ans","author":"Saravanan B S","submissionId":"1575118658"},[]]},{"551":[{"id":"551","fileName":"1575118746.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        N = len(nums)\n        Q = len(queries)\n        res = [-1] * Q\n        # print(N)\n\n        indice = defaultdict(list)\n        for i in range(N):\n            indice[nums[i]].append(i)\n\n        for i, q in enumerate(queries):\n            n = nums[q]\n            # print('------', i, q, indice[n])\n            if len(indice[n]) == 1:\n                continue\n            m = bisect.bisect_left(indice[n], q)\n            l, r = indice[n][m - 1], indice[n][(m + 1) % len(indice[n])]\n\n            # print(m, q, l, r)\n            # print(abs(q - l), N - abs(q - l), abs(q - r), N - abs(q - r)) \n            res[i] = min(abs(q - l), N - abs(q - l), abs(q - r), N - abs(q - r))\n\n        return res\n            \n            \n            ","author":"Tim Lu","submissionId":"1575118746"},[]]},{"552":[{"id":"552","fileName":"1575118749.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int,vector<int>> mp;\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n            mp[nums[i]].push_back(i+n);\n            mp[nums[i]].push_back(i-n);\n        }\n        for(auto &ele:mp){\n            sort(ele.second.begin(),ele.second.end());\n        }\n        vector<int> ans;\n        for(auto &q:queries){\n            int indi = lower_bound(mp[nums[q]].begin(),mp[nums[q]].end(),q) - mp[nums[q]].begin();\n            int i1 = indi-1;\n            int i2 = indi+1;\n            int val1 = -1,val2=-1;\n            if(i1>=0) val1 = q-mp[nums[q]][i1];\n            if(i2<mp[nums[q]].size()) val2 = mp[nums[q]][i2]-q;\n            if(val1 == -1 and val2 == -1) {ans.push_back(-1); continue;}\n            if(val1 == -1 and val2<n){ans.push_back(val2); continue;}\n            if(val2 == -1 and val1<n){ans.push_back(val1); continue;}\n            int kk = min(val1,val2);\n            if(kk == n) {ans.push_back(-1); continue;}\n            ans.push_back(kk);\n        }\n        return ans;\n    }\n};","author":"Hritik Anand","submissionId":"1575118749"},[]]},{"554":[{"id":"554","fileName":"1575118731.txt","sourceCode":"func solveQueries(nums []int, qs []int) []int {\n\thm := make(map[int][]int)\n\tfor i, num := range nums {\n\t\thm[num] = append(hm[num], i)\n\t}\n\tn := len(nums)\n\tres := make([]int, len(qs))\n\tfor i, q := range qs {\n\t\tnum := nums[q]\n\t\tleng := len(hm[num])\n\t\tif leng == 1 {\n\t\t\tres[i] = -1\n\t\t\tcontinue\n\t\t}\n\t\tidx := find(hm[num], q)\n\t\tif idx == 0 {\n\t\t\tres[i] = min(hm[num][1]-q, n-hm[num][leng-1]+q)\n\t\t} else if idx == leng-1 {\n\t\t\tres[i] = min(q-hm[num][leng-2], n-hm[num][leng-1]+hm[num][0])\n\t\t} else {\n\t\t\tres[i] = min(q-hm[num][idx-1], hm[num][idx+1]-q)\n\t\t}\n\t}\n\treturn res\n}\n\nfunc find(nums []int, val int) int {\n\tl, r := 0, len(nums)-1\n\tfor l <= r {\n\t\tmid := (l + r) / 2\n\t\tif nums[mid] == val {\n\t\t\treturn mid\n\t\t}\n\t\tif nums[mid] > val {\n\t\t\tr = mid - 1\n\t\t} else {\n\t\t\tl = mid + 1\n\t\t}\n\t}\n\treturn -1\n}","author":"Wei-Li Lai","submissionId":"1575118731"},[]]},{"555":[{"id":"555","fileName":"1575118792.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int>ans(queries.size(),-1);\n        unordered_map<int,pair<int,int>>mpp;\n        vector<int>temp(n,1e9);\n        for(int i=0;i<n;i++){\n            int num = nums[i];\n            if(mpp.count(nums[i])){\n                temp[mpp[num].second] = min(temp[mpp[num].second],i - mpp[num].second);\n                temp[mpp[num].first] = min(temp[mpp[num].first],mpp[num].first + n - i);\n                temp[i] = min(temp[i],abs(i - mpp[num].second));\n                temp[i] = min(temp[i],(n + mpp[num].first - i));\n                mpp[num].second = i;\n            }\n            else{\n                mpp[num] = {i,i};\n            }\n        }\n        for(int i=0;i<queries.size();i++){\n            ans[i] = temp[queries[i]];\n            if(temp[queries[i]]==1e9)ans[i] = -1;\n        }\n        return ans;\n    }\n};","author":"Siddhant kale","submissionId":"1575118792"},[]]},{"556":[{"id":"556","fileName":"1575118845.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length, m = queries.length;\n        Map<Integer, List<Integer>> numToIdx = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            if (numToIdx.containsKey(nums[i])) {\n                numToIdx.get(nums[i]).add(i);\n            }\n            else {\n                List<Integer> indices = new ArrayList<>();\n                indices.add(i);\n                numToIdx.put(nums[i], indices);\n            }\n        }\n        \n        int[] dist = new int[n];\n        for (List<Integer> indices : numToIdx.values()) {\n            int k = indices.size();\n            if (k == 1) {\n                dist[indices.get(0)] = -1;\n                continue;\n            }\n            \n            for (int i = 0; i < k; i++) {\n                int d = Integer.MAX_VALUE;\n                int cur = indices.get(i);\n                int prev = indices.get((i - 1 + k) % k);\n                int next = indices.get((i + 1) % k);\n                if (cur < next) {\n                    d = Math.min(d, next - cur);\n                }\n                else {\n                    d = Math.min(d, next + n - cur);\n                }\n                if (prev < cur) {\n                    d = Math.min(d, cur - prev);\n                }\n                else {\n                    d = Math.min(d, cur + n - prev);\n                }\n                dist[indices.get(i)] = d;\n            }\n        }\n        \n        List<Integer> distL = new ArrayList<>();\n        for (int i : queries) {\n            distL.add(dist[i]);\n        }\n        return distL;\n    }\n}","author":"Fasdr","submissionId":"1575118845"},[]]},{"557":[{"id":"557","fileName":"1575118869.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        \n        map<int,set<int>>mp;\n        int n=nums.size();\n        for(int i=0;i<n;i++)\n        {\n            mp[nums[i]].insert(i);\n        }\n    \n        vector<int>ans;\n        \n        for(auto it:queries)\n        {\n            //set<int>s=mp[nums[it]];\n            int cur=it;\n            int res=INT_MAX;\n            auto nxt=mp[nums[it]].upper_bound(cur);\n            \n            if(nxt!=mp[nums[it]].end())\n            {\n                res=min(res,abs(cur-*nxt));\n            }\n            \n            nxt=mp[nums[it]].lower_bound(cur);\n               \n            if(nxt!=mp[nums[it]].begin())\n            {\n                nxt--;\n                res=min(res,abs(cur-*nxt));\n            }\n            \n            int nx=*mp[nums[it]].begin();\n            if(nx!=cur)\n               res=min(res,abs((n-cur)+nx));\n            \n            nx=*mp[nums[it]].rbegin();\n            if(nx!=cur)\n               res=min(res,abs((n-nx)+cur));\n            \n            if(res!=INT_MAX)\n                ans.push_back(res);\n            else\n                ans.push_back(-1);\n        }\n        return ans;\n        \n    }\n};","author":"Prateek Bahukhandi","submissionId":"1575118869"},[]]},{"559":[{"id":"559","fileName":"1575118902.txt","sourceCode":"class Solution:\n    def solveQueries(self, a: List[int], qs: List[int]) -> List[int]:\n        n=len(a)\n        l=[-1 for _ in range(n)] # from left.\n        last={}\n        for i in range(n): last[a[i]]=i\n        # print(f\"last={last}\")\n        for i in range(n):\n            j=last[a[i]]\n            if j==i:continue\n            l[i]=i-j if j<i else i+n-j\n            last[a[i]]=i\n        # print(f\"l={l}\")\n        r=[-1 for _ in range(n)]\n        last={}\n        for i in range(n-1,-1,-1): last[a[i]]=i\n        for i in range(n-1,-1,-1):\n            j=last[a[i]]\n            if j==i:continue\n            r[i]=j-i if j>i else j+n-i\n            last[a[i]]=i\n        # print(f\"r={r}\")\n        ans=[]\n        for i in qs:\n            ans.append(min(l[i],r[i]))\n        return ans\n        ","author":"OuterRidgeSavage","submissionId":"1575118902"},[]]},{"560":[{"id":"560","fileName":"1575118754.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& v, vector<int>& queries) {\n        int i,n=v.size();\n        \n        for(i=0;i<n;i++) {\n            v.push_back(v[i]);\n        }\n        \n        vector<int> l(n,1e9),r(n,1e9);\n        unordered_map<int,int> mp;\n        vector<int> res;\n        \n        for(i=0;i<2*n;i++) {\n            \n            int j = i>=n ? i-n : i;\n            \n            if(mp.find(v[i]) != mp.end()) {\n                l[j] = min(l[j], i - mp[v[i]]);\n            }\n            \n            mp[v[i]] = i;\n        }\n        mp.clear();\n        \n        for(i=2*n-1;i>=0;i--) {\n            \n            if(i<n) {\n                if(mp.find(v[i]) != mp.end()) {\n                    r[i] = mp[v[i]] - i;\n                }\n                else {\n                    r[i] = -1;\n                }\n            }\n            mp[v[i]] = i;\n        }\n        \n        for(auto i:queries) {\n            \n            int ans = min(l[i], r[i]);\n            \n            if(ans == n) {\n                ans = -1;\n            }\n            res.push_back(ans);\n        }\n        return res;\n    }\n};","author":"Yuu","submissionId":"1575118754"},[]]},{"561":[{"id":"561","fileName":"1575118926.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        N = len(nums)\n        counter = Counter(nums)\n        left = defaultdict(int)\n        right = defaultdict(int)\n        for i in range(N):\n            left[nums[i]] = i\n        for i in range(N - 1, -1, -1):\n            right[nums[i]] = 2 * N + i\n        \n        res = [math.inf] * N\n        for i, num in enumerate(nums):\n            if num in left:\n                res[i] = min(res[i], N + i - left[num])\n            left[num] = N + i\n            \n        for i in range(N - 1, -1, -1):\n            num = nums[i]\n            if num in right:\n                res[i] = min(res[i], right[num] - N - i)\n            right[num] = N + i\n        \n        print(res)\n        output = []\n        for i in queries:\n            if counter[nums[i]] == 1:\n                output.append(-1)\n            else:\n                output.append(res[i])\n            \n        return output","author":"Dang Huy Nguyen","submissionId":"1575118926"},[]]},{"563":[{"id":"563","fileName":"1575118964.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& A, vector<int>& Q) {\n        int n = A.size();\n        for(int i=0; i<n; i++) A.push_back(A[i]);\n        for(int i=0; i<n; i++) A.push_back(A[i]);\n\n        unordered_map<int, int> mp, pos;\n        for(int i=0; i<3*n; i++) {\n            if(i >= n && i < 2 * n) {\n                int curr = i - pos[A[i]];\n                if(curr < n) {\n                    if(mp.count(i - n)) mp[i - n] = min(mp[i - n], curr);\n                    else mp[i - n] = curr;\n                }\n            }\n            pos[A[i]] = i;\n        }\n        pos.clear();\n        for(int i=3*n-1; i>=0; --i) {\n            if(i >= n && i < 2 * n) {\n                int curr = pos[A[i]] - i;\n                if(curr < n) {\n                    if(mp.count(i - n)) mp[i - n] = min(mp[i - n], curr);\n                    else mp[i - n] = curr;\n                }\n            }\n            pos[A[i]] = i;\n        }\n\n        vector<int> res;\n        for(auto& q : Q) {\n            if(mp.find(q) != mp.end()) res.push_back(mp[q]);\n            else res.push_back(-1);\n        }\n\n        return res;\n    }\n};","author":"Gowtham Gorrepati","submissionId":"1575118964"},[]]},{"564":[{"id":"564","fileName":"1575119041.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n    m := map[int][]int{}\n    for i, v := range nums {\n        m[v] = append(m[v], i)\n    }\n    n := len(nums)\n    res := []int{}\n    for _, q := range queries {\n        v := nums[q]\n        if len(m[v]) == 1 {\n            res = append(res, -1)\n        } else {\n            id := sort.Search(len(m[v]), func(i int) bool {\n                return m[v][i] >= q\n            })\n            if id == 0 {\n                t := min(m[v][1]-q, n+q-m[v][len(m[v])-1])\n                res = append(res, t)\n            } else if id == len(m[v])-1 {\n                t := min(q-m[v][len(m[v])-2], n+m[v][0]-q)\n                res = append(res, t)\n            } else {\n                t := min(q-m[v][id-1], m[v][id+1]-q)\n                res = append(res, t)\n            }\n        }\n    }\n    return res\n}","author":"LOLwuliao","submissionId":"1575119041"},[]]},{"566":[{"id":"566","fileName":"1575119122.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        HashMap<Integer, TreeSet<Integer>> hm = new  HashMap<>();\n        for (int i = 0; i < n; ++i) {\n            int num = nums[i];\n            hm.putIfAbsent(num, new TreeSet<>());\n            hm.get(num).add(i);\n            hm.get(num).add(i + n);\n            hm.get(num).add(i - n);\n        }\n\n        List<Integer> ans = new ArrayList<>();\n        for (int idx : queries) {\n            int target = nums[idx];\n            if (hm.get(target).size() == 3) {\n                ans.add(-1);\n            } else {\n                int lower = hm.get(target).lower(idx);\n                int higher = hm.get(target).higher(idx);\n                ans.add(Math.min((higher - idx), (idx - lower)));\n            }\n        }\n        return ans;    \n    }\n}","author":"randy","submissionId":"1575119122"},[]]},{"567":[{"id":"567","fileName":"1575119040.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, TreeSet<Integer>> map = new HashMap<>();\n        int n = nums.length;\n        for(int i = 0; i < n; i++) {\n            map.computeIfAbsent(nums[i], f -> new TreeSet<>()).add(i);\n        }\n        \n        List<Integer> res = new ArrayList<>();\n        for(int query : queries) {\n            res.add(helper(query, map.get(nums[query]), n));\n        } \n        return res;\n    }\n    \n    int helper(int num, TreeSet<Integer> tree, int n) {\n        // System.out.println(\"-------\");\n        if(tree == null) return -1;\n        Integer prev = tree.lower(num);\n        Integer next = tree.higher(num);\n        // System.out.println(\"prev: \" + (prev == null ? \"null\" : prev) + \", next: \" + (next == null ? \"null\" : next));\n        if(prev == null) prev = tree.last();\n        if(next == null) next = tree.first();\n        \n        if(prev == num) prev = null;\n        if(next == num) next = null;\n        \n        int res = Integer.MAX_VALUE;\n        \n        if(prev != null) {\n            res = Math.min(res, Math.min((prev - num + n) % n, (num - prev + n) % n));\n        }\n        if(next != null) {\n            res = Math.min(res, Math.min((next - num + n) % n, (num - next + n) % n));\n        }\n        // System.out.println(\"num: \" + num + \", tree: \" + (tree == null ? \"null\" : tree) + \", n: \" + n + \", prev: \" + (prev == null ? \"null\" : prev) + \", next: \" + (next == null ? \"null\" : next));\n        return res == Integer.MAX_VALUE ? -1 : res;\n    }\n}","author":"ws1255","submissionId":"1575119040"},[]]},{"569":[{"id":"569","fileName":"1575119090.txt","sourceCode":"//* sometimes pragmas don't work, if so, just comment it!\n//? #pragma GCC optimize (\"Ofast\")\n//? #pragma GCC target (\"avx,avx2\")\n//! #pragma GCC optimize (\"trapv\")\n\n//! #undef _GLIBCXX_DEBUG //? for Stress Testing\n\n#include <bits/stdc++.h> //? if you don't want IntelliSense\n\nusing namespace std;\n\n// building blocks\nusing ll  = long long;\nusing db  = long double; // or double, if TL is tight\nusing str = string;      // yay python!\n\n//? priority_queue for minimum\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\nusing ull  = unsigned long long;\n//? using i64  = long long;\n//? using u64  = uint64_t;\n//? using i128 = __int128;\n//? using u128 = __uint128_t;\n//? using f128 = __float128;\n\n\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n\n#define mp make_pair\n#define f  first\n#define s  second\n\n\n\n#define tcT template <class T\n#define tcTU tcT, class U\n//! ^ lol this makes everything look weird but I'll try it\n\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n#define ts to_string\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\n\n\nconst int MOD = 1e9 + 7;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18;  //? not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  //? for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\n\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits set\nconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\n\t                         // USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n}  // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n}  // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n}  // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n}  // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n}  // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi);  // assuming f is increasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi);  // assuming f is decreasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) {  // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void safeErase(T &t, const U &u) {\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n}\n\n\n\n#define tcTUU tcT, class ...U\n\ninline namespace IO {\n#define SFINAE(x, ...)                                                         \n\ttemplate <class, class = void> struct x : std::false_type {};              \n\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}\n\nSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));\nSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));\nSFINAE(IsTuple, typename std::tuple_size<T>::type);\nSFINAE(Iterable, decltype(std::begin(std::declval<T>())));\n\ntemplate <auto &is> struct Reader {\n\ttemplate <class T> void Impl(T &t) {\n\t\tif constexpr (DefaultI<T>::value) is >> t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tfor (auto &x : t) Impl(x);\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\n\t\t} else static_assert(IsTuple<T>::value, \"No matching type for read\");\n\t}\n\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }\n};\n\ntemplate <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }\n#define def(t, args...)                                                        \n\tt args;                                                                    \n\tre(args);\n\ntemplate <auto &os, bool debug, bool print_nd> struct Writer {\n\tstring comma() const { return debug ? \",\" : \"\"; }\n\ttemplate <class T> constexpr char Space(const T &) const {\n\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? 'n'\n\t\t                                                             : ' ';\n\t}\n\ttemplate <class T> void Impl(T const &t) const {\n\t\tif constexpr (DefaultO<T>::value) os << t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tif (debug) os << '{';\n\t\t\tint i = 0;\n\t\t\tfor (auto &&x : t)\n\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\n\t\t\tif (debug) os << '}';\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tif (debug) os << '(';\n\t\t\tstd::apply(\n\t\t\t    [this](auto const &...args) {\n\t\t\t\t    int i = 0;\n\t\t\t\t    (((i++) ? (os << comma() << \" \", Impl(args)) : Impl(args)),\n\t\t\t\t     ...);\n\t\t\t    },\n\t\t\t    t);\n\t\t\tif (debug) os << ')';\n\t\t} else static_assert(IsTuple<T>::value, \"No matching type for print\");\n\t}\n\ttemplate <class T> void ImplWrapper(T const &t) const {\n\t\tif (debug) os << \"033[0;31m\";\n\t\tImpl(t);\n\t\tif (debug) os << \"033[0m\";\n\t}\n\ttemplate <class... Ts> void print(Ts const &...ts) const {\n\t\t((Impl(ts)), ...);\n\t}\n\ttemplate <class F, class... Ts>\n\tvoid print_with_sep(const std::string &sep, F const &f,\n\t                    Ts const &...ts) const {\n\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << 'n';\n\t}\n\tvoid print_with_sep(const std::string &) const { os << 'n'; }\n};\n\ntemplate <class... Ts> void pr(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print(ts...);\n}\ntemplate <class... Ts> void ps(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print_with_sep(\" \", ts...);\n}\n}  // namespace IO\n\ninline namespace Debug {\n\n#ifdef LOCAL\n#include \"helpers/debug.h\"\n\n#define chk(...) if (!(__VA_ARGS__)) cerr << \"033[41m\" << \"Line(\" << __LINE__ << \") -> function(\" \n\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"033[0m\" << \"n\", exit(0);\n\n#define MACRO(code) do {code} while (false)\n#define RAYA MACRO(cerr << \"033[101m\" << \"================================\" << \"033[0m\" << endl;)\n#else\n//? #define dbg(...)\n\n#define chk(...)\n//? #define RAYA\n#endif\n\nconst auto beg_time = std::chrono::high_resolution_clock::now();\n// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\ndouble time_elapsed() {\n\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\n\t                                beg_time)\n\t    .count();\n}\n}  // namespace Debug\n\n\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), \"r\", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), \"w\", stdout); }\nvoid setIO(str s = \"\") {\n\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\n\t//? cout << fixed << setprecision(12);\n    //? cerr << fixed << setprecision(12);\n\tcin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + \".in\"), setOut(s + \".out\");  // for old USACO\n}\n}  // namespace FileIO\n\n\n\n//? Custom Helpers\ntemplate <typename T>\ninline T gcd(T a, T b) { while (b != 0) swap(b, a %= b); return a; }\n\nlong long binpow(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = res * a;\n        a = a * a;\n        b >>= 1;\n    }\n    return res;\n}\n\nconst int dddx[8]{1, 0, -1,  0, 1,  1, -1, -1};\nconst int dddy[8]{0, 1,  0, -1, 1, -1,  1, -1};\n\nusing vvi = V<vi>;\nusing vvl = V<vl>;\nusing vvb = V<vb>;\n//? /Custom Helpers\n\n#define RAYA ps(\"================================\")\n\nconst string PAIR_LEFT = \"(\";\nconst string PAIR_RIGHT = \")\";\nconst string IT_LEFT = \"[\";\nconst string IT_RIGHT = \"]\";\nconst string PAIR_SEP = \", \";\nconst string IT_SEP = \", \";\n \n// const string PAIR_LEFT = \"(\";\n// const string PAIR_RIGHT = \")\";\n// const string IT_LEFT = \"[\";\n// const string IT_RIGHT = \"]\";\n// const string PAIR_SEP = \" \";\n// const string IT_SEP = \" \";\n \n// const string PAIR_LEFT = \"{\";\n// const string PAIR_RIGHT = \"}\";\n// const string IT_LEFT = \"{\";\n// const string IT_RIGHT = \"}\";\n// const string PAIR_SEP = \", \";\n// const string IT_SEP = \", \";\n \n// benq - print any container + pair\ntemplate<typename T, typename = void> struct is_iterable : false_type {};\ntemplate<typename T> struct is_iterable<T, void_t<decltype(begin(declval<T>())),decltype(end(declval<T>()))>> : true_type {};\ntemplate<typename T> typename enable_if<is_iterable<T>::value&&!is_same<T, string>::value,ostream&>::type operator<<(ostream &cout, T const &v);\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << PAIR_LEFT << p.f << PAIR_SEP << p.s << PAIR_RIGHT; }\ntemplate<typename T> typename enable_if<is_iterable<T>::value&&!is_same<T, string>::value,ostream&>::type operator<<(ostream &cout, T const &v) {\n    cout << IT_LEFT; \n    for (auto it = v.begin(); it != v.end();) {\n        cout << *it;\n        if (++it != v.end()) cout << IT_SEP;\n    }\n    return cout << IT_RIGHT;\n}\ntemplate<typename A, typename B> istream& operator>>(istream& cin, pair<A, B> &p) {\n    cin >> p.first;\n    return cin >> p.second;\n}\n \nvoid dbg_out() { cout << endl; }\ntemplate<typename Head, typename... Tail> \nvoid dbg_out(Head H, Tail... T) { cout << ' ' << H; dbg_out(T...); }\n#define dbg(...) cout << \"(\" << #__VA_ARGS__ << \"): \", dbg_out(__VA_ARGS__)\n\n//* Template\n//* /Template\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<ll,vl> pos;\n        ll n=nums.size();\n        FOR(i,0,n){\n            pos[nums[i]].pb(i);\n        }\n        vi res;\n        each(e,queries){\n            ll tam=pos[nums[e]].size();\n            if(tam==1){\n                res.pb(-1);\n            }\n            else{\n                ll idx=lower_bound(all(pos[nums[e]]),e)-pos[nums[e]].begin();\n                ll ant=pos[nums[e]][(idx-1+tam)%tam] , sgte=pos[nums[e]][(idx+1)%tam]; \n                ll dist=min((pos[nums[e]][idx]-ant +n )%n,(sgte-pos[nums[e]][idx]+n)%n);\n                //dbg(idx,ant,sgte,pos[nums[e]][idx]);\n                res.pb(dist);\n            }\n        }\n\n        return res;\n    }\n};","author":"Diego Alonso Huamani Luque","submissionId":"1575119090"},[]]},{"570":[{"id":"570","fileName":"1575119282.txt","sourceCode":"#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <climits>\n#include <algorithm>\n\nclass Solution {\npublic:\n    std::vector<int> solveQueries(std::vector<int>& array, std::vector<int>& queries) {\n        std::map<int, std::set<int>> elementIndices;\n        int arraySize = array.size();\n\n        for (int index = 0; index < arraySize; index++) {\n            elementIndices[array[index]].insert(index);\n        }\n\n        std::vector<int> results;\n        for (int queryIndex : queries) {\n            auto& positions = elementIndices[array[queryIndex]];\n            if (positions.size() == 1) {\n                results.push_back(-1);\n                continue;\n            }\n\n            auto nextPosition = positions.upper_bound(queryIndex);\n            auto previousPosition = positions.lower_bound(queryIndex);\n\n            int minimumDistance = INT_MAX;\n            if (nextPosition != positions.end()) {\n                minimumDistance = std::min(minimumDistance, *nextPosition - queryIndex);\n            }\n            if (previousPosition != positions.begin()) {\n                previousPosition--;\n                minimumDistance = std::min(minimumDistance, queryIndex - *previousPosition);\n            }\n\n            minimumDistance = std::min(minimumDistance, arraySize - std::abs(*positions.begin() - queryIndex));\n            minimumDistance = std::min(minimumDistance, arraySize - std::abs(*positions.rbegin() - queryIndex));\n\n            results.push_back(minimumDistance);\n        }\n\n        return results;\n    }\n};\n","author":"JEFFREY SAMUEL J","submissionId":"1575119282"},[]]},{"571":[{"id":"571","fileName":"1575119127.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        HashMap<Integer, List<Integer>> hm = new HashMap<>();\n        List<Integer> ans = new ArrayList<Integer>();\n\n        int[] arr = new int[n];\n        Arrays.fill(arr, 1000000000);\n        for (int i = 0; i < n; i++){\n            List<Integer> aux = hm.getOrDefault(nums[i], new ArrayList<Integer>());\n            aux.add(i);\n            if (aux.size() == 1){\n                hm.put(nums[i], aux);\n            } else {\n                int s = aux.size();\n                arr[aux.get(s - 2)] = Math.min(arr[aux.get(s - 2)], i - aux.get(s - 2));\n                arr[aux.get(0)] = Math.min(arr[aux.get(0)], aux.get(0) + n - i);\n                arr[i] = n - i + (aux.get(0));\n                arr[i] = Math.min(arr[i], i - aux.get(s - 2));\n            }\n        }\n\n        for (int i = 0; i < m; i++){\n            ans.add(arr[queries[i]] == 1000000000 ? -1 : arr[queries[i]]);\n        }\n\n        return ans;\n    }\n}","author":"Alfonso Valenciana","submissionId":"1575119127"},[]]},{"572":[{"id":"572","fileName":"1575119321.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = queries.size();\n        vector<int> res(n);\n        unordered_map<int, set<int>> mp;\n        for (int i = 0; i < nums.size(); i++) {\n            mp[nums[i]].insert(i);\n        }\n\n        for (int i = 0; i < n; i++) {\n            int q = queries[i], cur = nums[q];\n            if (mp[cur].size() == 1) res[i] = -1;\n            else {\n                int r = INT_MAX;\n                auto it = mp[cur].find(q);\n                if (it == mp[cur].begin()) {\n                    it++;\n\n                    r = min(*it - q, q + (int)nums.size() - *it);\n\n                    if (it != mp[cur].end()) {\n                        it = mp[cur].end();\n                        it--;\n                        r = min(r, min(*it - q, q + (int)nums.size() - *it));\n                    }\n\n                    res[i] = r;\n                } else {\n                    auto it2 = it;\n                    it2--;\n                    r = min(q - *it2, *it2 + (int)nums.size() - q);\n\n                    if(++it == mp[cur].end()) it = mp[cur].begin();\n                    r = min(r, min(abs(*it - q), *it + (int)nums.size() - q));\n                    res[i] = r;\n                }\n            }\n        }\n\n        return res;\n    }\n};","author":"PP Hunter","submissionId":"1575119321"},[]]},{"573":[{"id":"573","fileName":"1575119329.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n\n            unordered_map<int, vector<int>> mp;\n\n          for(int i = 0; i < nums.size(); i++)\n              {\n                  mp[nums[i]].push_back(i);\n              }\n        vector<int> ans;\n        for(int i = 0; i < queries.size(); i++)\n            {\n                int x = nums[queries[i]];\n\n                if (mp[x].size() == 1)\n                {\n                    ans.push_back(-1);\n                }\n                else\n                {\n                    int mi = INT_MAX;\n                    auto it = upper_bound(mp[x].begin(), mp[x].end(), queries[i]);\n                    if (it != mp[x].end())\n                    {\n                        mi = min(mi, (*it) - queries[i]);\n                    }\n                    it = lower_bound(mp[x].begin(), mp[x].end(), queries[i]);\n                    if (it != mp[x].begin())\n                    {\n                        --it;\n                        mi = min(mi, queries[i]-(*it));\n                    }\n                    if (mp[x][0] != queries[i])\n                    {\n                        mi = min(mi, mp[x][0] + (int)nums.size() - queries[i]);\n                    }\n                    if (mp[x][mp[x].size()-1] != queries[i])\n                    {\n                        mi = min(mi, (int)nums.size() - mp[x][mp[x].size()-1] + queries[i]);\n                    }\n                    if (mi == INT_MAX)\n                        ans.push_back(-1);\n                    else\n                        ans.push_back(mi);\n                }\n            }\n\n        return ans;\n    }\n};","author":"sitanshushukla29","submissionId":"1575119329"},[]]},{"574":[{"id":"574","fileName":"1575119187.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        mp = defaultdict(list)\n        for i, num in enumerate(nums):\n            mp[num].append(i)\n\n        def bs(arr, t):\n            s, e = 0, len(arr) - 1\n\n            while s <= e:\n                m = (s+e) // 2\n                if arr[m] == t:\n                    return m\n                elif arr[m] < t:\n                    s = m+1\n                else:\n                    e = m-1\n\n            return -1\n                \n        \n        res = []\n        for q in queries:\n            lst = mp[nums[q]]\n            # print(lst)\n            if len(lst) == 1:\n                res.append(-1)\n            else:\n                lst_i = bs(lst, q)\n                curr = lst[lst_i]\n                a = lst[(lst_i - 1) % len(lst)]\n                b = lst[(lst_i + 1) % len(lst)]\n\n                min_dist = float(\"inf\")\n                if lst_i == 0:\n                    min_dist = min(len(nums) - abs(curr - a), abs(curr - b))\n                elif lst_i == len(lst) - 1:\n                    min_dist = min(abs(curr - a), len(nums) - abs(curr - b))\n                else:\n                    min_dist = min(abs(curr - a), abs(curr - b))\n\n                res.append(min_dist)\n        \n        return res\n                ","author":"Kanak Tanwar","submissionId":"1575119187"},[]]},{"575":[{"id":"575","fileName":"1575119153.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& v, vector<int>& q) {\n        int i,j,sum=0,ans=0;\n        int n=v.size();\n        for(i=0;i<n;i++){\n            v.push_back(v[i]);\n        }\n        for(i=0;i<n;i++){\n            v.push_back(v[i]);\n        }\n        map<int,vector<int>> mp;\n        for(i=0;i<3*n;i++){\n            mp[v[i]].push_back(i);\n        }\n        vector<int> fin;\n        for(i=0;i<q.size();i++){\n            int ind=q[i]+n;\n            int ele=v[ind];\n            int low=0;\n            int high=mp[ele].size()-1;\n            int mid;\n            int cur=-1;\n            while(low<=high){\n                mid=(low+high)/2;\n                if(mp[ele][mid]>ind){\n                    high=mid-1;\n                }\n                else{\n                    cur=mid;\n                    low=mid+1;\n                }\n            }\n            ans=min(mp[ele][cur]-mp[ele][cur-1],mp[ele][cur+1]-mp[ele][cur]);\n            if(ans==n) ans=-1;\n            fin.push_back(ans);\n        }\n        return fin;\n    }\n};","author":"PDXTITAN","submissionId":"1575119153"},[]]},{"576":[{"id":"576","fileName":"1575119351.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n\n        vector<int> ans(q, -1);\n        unordered_map<int, vector<int>> hash;\n        for(int i = 0; i < n; i++)\n        {\n            hash[nums[i]].push_back(i);\n        }\n\n        for(int i = 0; i < q; i++)\n        {\n            int num = nums[queries[i]];\n            int sz = hash[num].size();\n            if(sz == 1)\n                continue;\n\n\n            int ind = lower_bound(hash[num].begin(), hash[num].end(), queries[i]) - hash[num].begin();\n\n            int left, right;\n            if(ind == 0)\n                left = hash[num][sz - 1];\n            else\n                left = hash[num][ind - 1];\n\n            if(ind == sz - 1)\n                right = hash[num][0];\n            else\n                right = hash[num][ind + 1];\n\n            int leftd = (queries[i] - left + n) % n;\n            int rightd = (right - queries[i] + n ) % n;\n\n            ans[i] = min(leftd, rightd);\n        }\n\n        return ans;\n    }\n};","author":"Rushil Reddy","submissionId":"1575119351"},[]]},{"577":[{"id":"577","fileName":"1575119638.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), q = queries.size();\n\n        vector<int> closet_distance(n, INT_MAX);\n        unordered_map<int, int> last_idx;\n        unordered_map<int, int> first_idx;\n        \n        for(int i = 0; i < n; i++) {\n            int num = nums[i];\n\n            if(first_idx.count(num) > 0)\n                closet_distance[i] = min({closet_distance[i], i-last_idx[num], first_idx[num]+n-i});\n            \n            // update the index\n            last_idx[num] = i;\n\n            if(first_idx.count(num) == 0)\n                first_idx[num] = i;\n        }\n\n        last_idx.clear();\n        first_idx.clear();\n\n        for(int i = n-1; i >= 0; i--) {\n            int num = nums[i];\n\n            if(first_idx.count(num) > 0)\n                closet_distance[i] = min({closet_distance[i], last_idx[num]-i, i+n-first_idx[num]});\n            \n            // update the index\n            last_idx[num] = i;\n\n            if(first_idx.count(num) == 0)\n                first_idx[num] = i;\n        }\n\n        vector<int> ans(q);\n        for(int i = 0; i < q; i++) {\n            int q_idx = queries[i];\n\n            ans[i] = (closet_distance[q_idx] == INT_MAX) ? -1 : closet_distance[q_idx];\n        }\n\n        return ans;\n    }\n};","author":"maomao0414","submissionId":"1575119638"},[]]},{"578":[{"id":"578","fileName":"1575119481.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        m = {}\n        s = []\n        for i,num in enumerate(nums):\n            if num in m:\n                s.append(len(m[num]))\n                m[num].append(i)\n            else:\n                s.append(0)\n                m[num] = [i]\n        res = []\n        print(m)\n        print(s)\n        for q in queries:\n            ind = s[q]\n            num = nums[q]\n            if len(m[num]) == 1:\n                res.append(-1)\n                continue\n            # forwards\n            curr = m[num][ind]\n            next = m[num][(ind+1)%len(m[num])]\n            prev = m[num][(ind-1)%len(m[num])]\n\n            if next < curr:\n                dist1 = len(nums)-curr + next\n            else:\n                dist1 = next - curr\n\n            if prev > curr:\n                dist2 = len(nums)-prev + curr\n            else:\n                dist2 = curr - prev\n            res.append(min(dist1,dist2))\n            \n        return res","author":"westonsLeetcodingJourney","submissionId":"1575119481"},[]]},{"579":[{"id":"579","fileName":"1575119292.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        N = len(nums)\n        lookup = dict()\n        for i,x in enumerate(nums):\n            if x not in lookup:\n                lookup[x] = [i]\n            else:\n                lookup[x].append(i)\n                \n        answer = []\n        for pos in queries:\n            table = lookup[nums[pos]]\n            if len(table) > 1:\n                idx = bisect_left(table, pos)\n                assert(table[idx] == pos)\n                cand1,cand2 = table[0],table[-1]\n                dist1,dist2 = None,None\n                if idx>0:\n                    cand1 = table[idx-1]\n                    dist1 = pos-cand1\n                else:\n                    cand1 = table[-1]\n                    dist1 = pos+N-cand2\n                if (idx+1) < len(table):\n                    cand2 = table[idx+1]\n                    dist2 = cand2-pos\n                else:\n                    cand2 = table[0]\n                    dist2 = cand2+N-pos\n                answer.append(min(dist1,dist2))\n            else:\n                answer.append(-1)\n        return answer","author":"Kamanashis Roy Shuva","submissionId":"1575119292"},[]]},{"581":[{"id":"581","fileName":"1575119849.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        \n        int n = nums.length;\n        int[] arr = new int[2*n];\n        \n        for(int i=0; i<n; i++) {\n            arr[i] = nums[i];\n            arr[i+n] = nums[i];\n        }\n        \n        int dist[] = new int[n];\n        Arrays.fill(dist, n);\n        \n        Map<Integer, Integer> p = new HashMap<>();\n        \n        for(int i=0; i< 2*n; i++) {\n            \n            if(p.containsKey(arr[i])) {\n                dist[i%n] = Math.min(dist[i%n], i - p.get(arr[i])); \n            }\n            p.put(arr[i], i);\n        }\n        \n        Map<Integer, Integer> q = new HashMap<>();\n        \n        for(int j=2*n-1; j>=0; j--) {\n            if(q.containsKey(arr[j])) {\n                dist[j%n] = Math.min(dist[j%n], q.get(arr[j])-j); \n            }\n            q.put(arr[j], j);\n        }\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        for(int i=0; i<queries.length; i++) {\n            if(dist[queries[i]] != n) {\n                ans.add(dist[queries[i]]);\n            } else {\n                ans.add(-1);\n            }\n        }\n        \n        return ans;\n    }\n}","author":"manjpatel00","submissionId":"1575119849"},[{"id":"1833","similarity":0.817351598173516,"totOverlap":179,"longestOverlap":20},{"id":"1833","similarity":0.7058823529411765,"totOverlap":144,"longestOverlap":11}]],"956":[{"id":"956","fileName":"1575129433.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] q) {\n        int n=nums.length;\n        HashMap<Integer,Integer> map=new HashMap<>();\n        int dist[]=new int[n];\n        int a[]=new int[2*n];\n        for(int i=0;i<2*n;i++){\n            a[i]=nums[i%n];\n        }\n        Arrays.fill(dist,Integer.MAX_VALUE);\n        for(int i=0;i<2*n;i++){\n            if(map.containsKey(a[i])){\n                dist[i%n]=Math.min(i-map.get(a[i]),dist[i%n]);\n                dist[map.get(a[i])%n]=Math.min(i-map.get(a[i]),dist[map.get(a[i])%n]);\n            }\n            map.put(a[i],i);\n        }\n        List<Integer> ans=new ArrayList<>();\n        for(int i=0;i<q.length;i++){\n            int ind=q[i];\n            if(dist[ind]==n){\n                ans.add(-1);\n            }\n            else{\n                ans.add(dist[ind]);\n            }\n        }\n        return ans;\n    }\n}","author":"Ishan","submissionId":"1575129433"},[{"id":"956","similarity":0.7058823529411765,"totOverlap":144,"longestOverlap":11}]],"1833":[{"id":"1833","fileName":"611245283.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        int[] arr = new int[2 * n];\n        for (int i = 0; i < 2 * n; i++) {\n            arr[i] = nums[i % n];\n        }\n        int[] dis = new int[n];\n        Arrays.fill(dis, -1);\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < 2*n; i++) {\n            if (map.containsKey(arr[i])) {\n                dis[i%n] = Math.min(dis[i%n], i - map.get(arr[i]));\n                if (-1 == dis[i%n]) {\n                    dis[i%n] = i - map.get(arr[i]);\n                }\n            }\n            map.put(arr[i], i);\n        }\n        map.clear();\n        for (int i = 2*n - 1; i >= 0; i--) {\n            if (map.containsKey(arr[i])) {\n                dis[i%n] = Math.min(dis[i%n], map.get(arr[i])-i);\n                if (-1 == dis[i%n]) {\n                    dis[i%n] = map.get(arr[i])-i;\n                }\n            }\n            map.put(arr[i], i);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int query : queries) {\n            if(dis[query]>=n){\n                ans.add(-1);\n            }else {\n                ans.add(dis[query]);\n            }\n        }\n        return ans;        \n    }\n}","author":"皇家码德里","submissionId":"611245283"},[{"id":"581","similarity":0.817351598173516,"totOverlap":179,"longestOverlap":20}]]},{"583":[{"id":"583","fileName":"1575119744.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        D = defaultdict(list)\n        n = len(nums)\n        for i in range(n):\n            D[nums[i]].append(i)\n\n        #for key in D:\n        #    D[key].append(D[key][0] + n)\n\n        res = []\n        for q in queries:\n            if len(D[nums[q]]) == 1:\n                res.append(-1)\n                continue\n                \n            ind = bisect.bisect_left(D[nums[q]], q)\n            if ind == 0:\n                cand1 = n - (D[nums[q]][-1] - q)\n            else:\n                cand1 = q - D[nums[q]][ind-1]\n\n            if ind == len(D[nums[q]]) - 1:\n                cand2 = n + D[nums[q]][0] - q\n            else:\n                cand2 = D[nums[q]][ind+1] - q\n            res.append(min(cand1, cand2))\n\n        return res\n        ","author":"Denis Rozhkov","submissionId":"1575119744"},[]]},{"584":[{"id":"584","fileName":"1575119770.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        def get_dist(pos1, pos2):\n            return min(abs(pos1-pos2), len(nums) - abs(pos1-pos2))\n        nums_dict = defaultdict(list)\n        for idx, num in enumerate(nums):\n            nums_dict[num].append(idx)\n        ans = []\n        for query in queries:\n            \n            # print(\"=====\")\n            # print(query)\n            num = nums[query]\n            if len(nums_dict[num]) == 1:\n                ans.append(-1)\n                continue\n            l = 0\n            r = len(nums_dict[num])\n            pos = -1\n            while l <= r:\n                m = (l+r)>>1\n                if nums_dict[num][m] < query:\n                    l = m + 1\n                if nums_dict[num][m] == query:\n                    pos = m\n                    break\n                if nums_dict[num][m] > query:\n                    r = m - 1\n            t = len(nums_dict[num])\n            # print(nums_dict[num])\n            # print(pos)\n            ans.append(min(get_dist(nums_dict[num][pos-1], nums_dict[num][pos]), get_dist(nums_dict[num][(pos+1)%t],nums_dict[num][pos])))\n        return ans","author":"tuanbi97","submissionId":"1575119770"},[]]},{"585":[{"id":"585","fileName":"1575119876.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n\tn := len(nums)\n\tnext := make([]int, n)\n\tlastIdx := make(map[int]int)\n\n\tfor i := range n {\n\t\tnext[i] = 100_000\n\t}\n\n\tfor i := range n * 2 {\n\t\tii := i % n\n\t\tif j, ok := lastIdx[nums[ii]]; ok && ii != j {\n\t\t\tnext[ii] = min(next[ii], i-j)\n\t\t\tjj := j % n\n\t\t\tnext[jj] = min(next[jj], i-j)\n\t\t}\n\t\tlastIdx[nums[ii]] = i\n\t}\n\n\tans := make([]int, len(queries))\n\tfor i, q := range queries {\n\t\tif next[q] == 100_000 {\n\t\t\tans[i] = -1\n\t\t} else {\n\t\t\tans[i] = next[q]\n\t\t}\n\t}\n\treturn ans\n}\n","author":"yap","submissionId":"1575119876"},[]]},{"586":[{"id":"586","fileName":"1575119418.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        # val to idx\n        vti = collections.defaultdict(list)\n        # idxs\n        idxs = [[] for _ in range( n)]\n        for j in range (2):\n            for i in range(n):\n                vti[nums[i]].append(i + j * n)\n                idxs[i].append(len(vti[nums[i]]) - 1)\n        res = []\n        for q in queries:\n            idx = vti[nums[q]]\n            if len(idx) == 2:\n                res.append(-1)\n            else:\n                i1, i2 = idxs[q][0], idxs[q][1]\n                minDis = min(idx[i1 + 1] - idx[i1], idx[i2] - idx[i2 - 1])\n                res.append(minDis)\n        return res\n                \n        \n        \n        ","author":"Minghao Li","submissionId":"1575119418"},[]]},{"588":[{"id":"588","fileName":"1575120081.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] q) {\n        Map<Integer, TreeSet<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.computeIfAbsent(nums[i], k -> new TreeSet<>()).add(i);\n        }\n        List<Integer> res = new ArrayList<>();\n        for (int i = 0, j; i < q.length; i++) {\n            j = q[i];\n            int v = -1;\n            TreeSet<Integer> set = map.get(nums[q[i]]);\n            Integer j1 = set.ceiling(j + 1),\n                    j2 = set.floor(j - 1),\n                    j3 = set.first(),\n                    j4 = set.last();\n            // System.out.println(j + \", \" + set + \",\" + j1 + \",\" + j2 + \",\" + j3 + \",\" + j4);\n            if (j1 != null) {\n                v = j1 - j;\n            }\n            if (j2 != null) {\n                v = v == -1 ? j - j2 : Math.min(v, j - j2);\n            }\n            if (j3 != null && j3 != j) {\n                v = v == -1 ? nums.length - j + j3: Math.min(v, nums.length - j + j3);\n            }\n            if (j4 != null && j4 != j) {\n                v = v == -1 ? nums.length - j4 + j: Math.min(v, nums.length - j4 + j);\n            }\n            res.add(v);\n        }\n        return res;\n    }\n}","author":"Arucade","submissionId":"1575120081"},[]]},{"589":[{"id":"589","fileName":"1575120015.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        h=defaultdict(list)\n        for i,x in enumerate(nums):\n            h[x].append(i)\n        ret=[-1] * len(queries)\n        for i,x in enumerate(queries):\n            t = h[nums[x]]\n            if len(t) == 1:\n                continue\n            pos = bisect_left(t,x)\n            if pos == 0:\n                right = t[pos - 1] - len(nums)\n            else:\n                right = t[pos - 1]\n            if pos + 1 == len(t):\n                left = t[0] + len(nums)\n            else:\n                left = t[pos + 1]\n            ret[i] = min(x - right, left - x)\n        return ret","author":"Andy Jiang","submissionId":"1575120015"},[]]},{"590":[{"id":"590","fileName":"1575119988.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        map<int,vector<int>> mp;\n        int n=nums.size();\n        for(int i=0; i<n; i++)\n            {\n                mp[nums[i]].push_back(i);\n            }\n        vector<int> ans(n, -1);\n        \n        for(auto it : mp)\n            {\n                if(it.second.size()>1)\n                {\n                    // fo\n                    // for(int i=0; i<it.second.size(); i++)\n                    //     {\n                    //         cout<<it.second[i]<<\" \";\n                    //     }\n                    for(int i=0; i<it.second.size(); i++)\n                        {   int dis=INT_MAX; \n                            if(i==0)\n                            {\n                                dis=min(it.second[i+1]-it.second[i], n-(it.second[it.second.size()-1]-it.second[i]));\n                             // ans[i]=dis;\n                            }\n                            else if(i==it.second.size()-1)\n                            {\n                                dis=min(it.second[i]-it.second[i-1], n-(it.second[i]-it.second[0]));\n                             // ans[i]=dis;\n                            }\n                             else\n                            {\n                                dis=min(it.second[i]-it.second[i-1], it.second[i+1]-it.second[i]);\n                             // ans[i]=dis;\n                            }\n                         ans[it.second[i]]=dis;\n                         \n                        }\n                }\n                // else\n            }\n        \n        // for(int i=0; i<n; i++)\n        //     {\n        //         // res.push_back(ans[q[i]]);\n        //         // cout<<ans[i]<<endl;\n        //     }\n        vector<int> res;\n        for(int i=0; i<q.size(); i++)\n            {\n                res.push_back(ans[q[i]]);\n            }\n        return res;\n        \n    }\n};","author":"Pratham Chaurasiya","submissionId":"1575119988"},[{"id":"1116","similarity":0.7181818181818181,"totOverlap":158,"longestOverlap":26}]],"1116":[{"id":"1116","fileName":"1575133587.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> maa;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            maa[nums[i]].push_back(i);\n        }\n        vector<int> dis(n, INT_MAX);\n        for (int i = 0; i < n; i++) {\n            if (maa[nums[i]].size() == 1) {\n                dis[i] = -1;\n            }\n        }\n        for (auto& it : maa) {\n            if (it.second.size() > 1) {\n                for (int i = 0; i < it.second.size(); i++) {\n                    if (i == 0) {\n                        dis[it.second[i]] = min({n - it.second.back() + it.second[0], it.second[i + 1] - it.second[i]});\n                    } else if (i < it.second.size() - 1) {\n                        dis[it.second[i]] = min({it.second[i + 1] - it.second[i], it.second[i] - it.second[i - 1]});\n                    } else {\n                        dis[it.second[i]] = min({it.second[i] - it.second[i - 1], n - it.second[i] + it.second[0]});\n                    }\n                }\n            }\n        }\n        vector<int> ans;\n        for (int i = 0; i < queries.size(); i++) {\n            ans.push_back(dis[queries[i]]);\n        }\n        \n        return ans;\n    }\n};\n","author":"sakutsadragonpowerranger","submissionId":"1575133587"},[{"id":"590","similarity":0.7181818181818181,"totOverlap":158,"longestOverlap":26}]]},{"592":[{"id":"592","fileName":"1575120272.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int, vector<int>> pos;\n        for (int i = 0; i < n; i++) {\n            pos[nums[i]].push_back(i);\n        }\n        \n        vector<int> ans;\n        for (int q : queries) {\n            int val = nums[q];\n            auto &indices = pos[val];\n            if (indices.size() < 2) {\n                ans.push_back(-1);\n                continue;\n            }\n            int posIndex = lower_bound(indices.begin(), indices.end(), q) - indices.begin();\n            int left, right;\n            if (posIndex == 0) {\n                left = (q - indices.back() + n) % n;\n            } else {\n                left = q - indices[posIndex - 1];\n            }\n            if (posIndex == indices.size() - 1) {\n                right = (indices.front() + n - q) % n;\n            } else {\n                right = indices[posIndex + 1] - q;\n            }\n            ans.push_back(min(left, right));\n        }\n        return ans;\n    }\n};\n","author":"Melon Musk","submissionId":"1575120272"},[]]},{"593":[{"id":"593","fileName":"1575120224.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        num_to_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            num_to_indices[num].append(i)\n\n        ans = []\n        for q in queries:\n            indices = num_to_indices[nums[q]]\n            m = len(indices)\n            if m == 1:\n                ans.append(-1)\n                continue\n\n            def get_distance(i, j):\n                diff = abs(j - i)\n                return min(diff, n - diff)\n                \n            idx = bisect.bisect_left(indices, q)\n            candidates = [(idx - 1) % m, (idx + 1) % m]\n            distances = [get_distance(indices[c], q) for c in candidates]\n            ans.append(min(distances))\n\n            #print(f\"For {q=}, {indices=}, {candidates=}, {distances=}\")\n            \n\n        return ans\n                \n            ","author":"Robert Perez","submissionId":"1575120224"},[]]},{"594":[{"id":"594","fileName":"1575120338.txt","sourceCode":"\n// iostream::sync_with_stdio(false); cin.tie(NULL);\n#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define Sree ios_base::sync_with_stdio(false);\n#define Vardhan cin.tie(NULL);\n\n#define pi pair<int,int>\n#define ppi pair<pair<int,int>,int>\n#define pip pair<int,pair<int,int>>\n#define umii unordered_map<int,int>\n#define mii map<int,int>\n#define umsi unordered_map<string,int>\n#define msi map<string,int>\n#define umss unordered_map<string,string>\n#define mss map<string,string>\n#define vi vector<int>\n#define vb vector<bool>\n#define vll vector<ll>\n#define vvi vector<vector<int>>\n#define vvb vector<vector<bool>>\n#define vpi vector<pair<int,int>>\n#define vpic vector<pair<int,char>>\n#define vvpi vector<vector<pair<int,int>>>\n#define pqimax priority_queue<int>\n#define pqimin priority_queue<int,vector<int>,greater<int>>\n#define ll long long\n#define pb push_back\n#define br cout<<endl;\n#define Name \"Sreevardhan\"\n\n\n#define fl(i,n) for(int i=0;i<n;i++)\n#define fli(i,n) for(int i=n-1;i>=0;i--)\n#define srt(v) sort(v.begin(),v.end());\n#define srtg(v) sort(v.begin(),v.end(),greater<int>());\n\n#define print(_) cout<<_<<\" \";\n#define println(_) cout<<_<<endl;\n#define inp(_) for(auto &__:_) cin>>__;\n#define prv(_) for(auto &__:_) cout<<__<<\" \";\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vi> m;\n        int n = nums.size();\n        fl(i,n){\n            m[nums[i]].pb(i);\n        }\n        int m1 = queries.size();\n        vi ans(m1);\n        fl(i,m1){\n            int idx = queries[i];\n            int val = nums[idx];\n            const vi& temp = m[val];\n            if(temp.size()==1){\n                ans[i]=-1;\n                continue;\n            }\n            int x = lower_bound(temp.begin(),temp.end(),idx) - temp.begin();\n            int res=INT_MAX;\n            if(x==0){\n                res = min((n-1)-temp.back()+idx+1,temp[x+1] -idx);\n            }\n            else if(x==temp.size()-1){\n                res = min((n-1)-temp.back()+temp[0]+1,temp.back()- temp[x-1]);\n            }\n            else{\n                res = min(temp[x]- temp[x-1],temp[x+1]- temp[x] );\n            }\n            ans[i]=res;\n        }\n        return ans;\n    }\n};\n","author":"Sreevardhan Reddy","submissionId":"1575120338"},[]]},{"595":[{"id":"595","fileName":"1575120112.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        mp = {}\n        n = len(nums)\n        for i, num in enumerate(nums):\n            mp.setdefault(num, []).append(i)\n        cache = [-1] * n\n        for num, indices in mp.items():\n            m = len(indices)\n            if m == 1: \n                continue\n            indices.sort()\n            for index, position in enumerate(indices):\n                l = indices[(index-1)%m]\n                r = indices[(index+1)%m]\n                d_l = abs(l - position)\n                d_r = abs(r - position)\n                cache[position] = min(d_l, d_r, n-d_l, n-d_r)\n        ans = []\n        for query in queries:\n            ans.append(cache[query])\n        return ans","author":"Luong Quang Dung","submissionId":"1575120112"},[]]},{"596":[{"id":"596","fileName":"1575120339.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> ans;\n        map<int,vector<int>> mpp;\n        for(int i=0;i<nums.size();i++)\n            {\n                mpp[nums[i]].push_back(i);\n            }\n\n        for(int i=0;i<queries.size();i++)\n            {\n                int ind=queries[i];\n                int val=nums[ind];\n                if(mpp[val].size()==1)\n                {\n                    ans.push_back(-1);\n                }\n                else\n                {\n                    int ind1=-1;\n                    int ind2=-1;\n                    int ind3=-1;\n                    int ind4=-1;\n                    auto it=upper_bound(mpp[val].begin(),mpp[val].end(),ind);\n                    if(it!=mpp[val].end())\n                    {\n                        ind1=mpp[val][it-mpp[val].begin()];\n                    }\n                    it=lower_bound(mpp[val].begin(),mpp[val].end(),ind);\n                    if(it!=mpp[val].begin())\n                    {\n                        it--;\n                        ind2=mpp[val][it-mpp[val].begin()];\n                    }\n                    it=mpp[val].end();\n                    it--;\n                    if(mpp[val][(it-mpp[val].begin())]!=ind)\n                    {\n                        ind3=mpp[val][it-mpp[val].begin()];\n                    }\n                    it=mpp[val].begin();\n                    if(mpp[val][(it-mpp[val].begin())]!=ind)\n                        {\n                        ind4=mpp[val][it-mpp[val].begin()];\n                        }\n\n                    int mini=INT_MAX;\n                    if(ind1!=-1)\n                    {\n                       int clock=(ind-ind1+nums.size())%nums.size();\n                        int anti=(ind1-ind+nums.size())%nums.size();\n                        mini=min(mini,clock);\n                        mini=min(mini,anti);\n                    }\n                    if(ind2!=-1)\n                    {\n                        int clock=(ind-ind2+nums.size())%nums.size();\n                        int anti=(ind2-ind+nums.size())%nums.size();\n                        mini=min(mini,clock);\n                        mini=min(mini,anti);\n                    }\n                    if(ind3!=-1)\n                    {\n                        int clock=(ind-ind3+nums.size())%nums.size();\n                        int anti=(ind3-ind+nums.size())%nums.size();\n                        mini=min(mini,clock);\n                        mini=min(mini,anti);\n                    }\n                    if(ind4!=-1)\n                    {\n                        int clock=(ind-ind4+nums.size())%nums.size();\n                        int anti=(ind4-ind+nums.size())%nums.size();\n                        mini=min(mini,clock);\n                        mini=min(mini,anti);\n                    }\n                    ans.push_back(mini);\n                }\n            }\n        return ans;\n    }\n};","author":"Yash Singh","submissionId":"1575120339"},[]]},{"597":[{"id":"597","fileName":"1575120403.txt","sourceCode":"class Solution {\n    int cal(vector<int> &v, int idx, int x) {\n        int n = v.size();\n        int r = x;\n        // cout << n << \", \" << idx << endl;\n        if(0 == idx) {\n            return min({v[idx+1]-v[idx], x-(v[idx+1]-v[idx]), v[n-1]-v[idx], x-(v[n-1]-v[idx])});\n        }\n        else if(idx == n - 1) {\n            return min({v[idx]-v[idx-1], x-(v[idx]-v[idx-1]), v[idx]-v[0], x-(v[idx]-v[0])});\n        }\n        else {\n            return min({v[idx+1]-v[idx], x-(v[idx+1]-v[idx]), v[idx]-v[idx-1], x-(v[idx]-v[idx-1])});\n        }\n    }\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& qs) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for(int i = 0; i < n; ++i) {\n            mp[nums[i]].push_back(i);\n        }\n\n        int m = qs.size();\n        vector<int> ans(m);\n        for(int i = 0; i < m; ++i) {\n            int j = qs[i];\n            int val = nums[j];\n            if(mp[val].size() < 2) { ans[i] = -1; }\n            else {\n                int idx = lower_bound(mp[val].begin(), mp[val].end(), j) - mp[val].begin();\n                ans[i] = cal(mp[val], idx, n);\n            }\n        }\n        return ans;\n    }\n};","author":"ArthurCx","submissionId":"1575120403"},[]]},{"598":[{"id":"598","fileName":"1575120118.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        indices = collections.defaultdict(list)\n        for i, x in enumerate(nums):\n            indices[x].append(i)\n        def distance(a, b):\n            dist1 = abs(a-b)\n            return min(dist1, len(nums)-dist1)\n        res = []\n        for q in queries:\n            x = nums[q]\n            xs = indices[x]\n            dist = float('inf')\n            left = bisect.bisect_left(xs, q)\n            right = bisect.bisect_right(xs, q)\n            for j in [left, right]:\n                if j == len(xs):\n                    continue\n                for target in [j-1, j, j+1]:\n                    if 0 <= target < len(xs) and xs[target]!=q:\n                        dist = min(dist, distance(q, xs[target]))\n            if len(xs) > 1 and xs[0]!=q:\n                dist = min(dist, abs(xs[0]+len(nums)-q))\n            if len(xs) > 1 and xs[-1]!=q:\n                dist = min(dist, abs(q+len(nums)-xs[-1]))\n            res.append(-1 if dist == float('inf') else dist)\n        return res","author":"StackOverflowAutomaton","submissionId":"1575120118"},[]]},{"599":[{"id":"599","fileName":"1575120282.txt","sourceCode":"from collections import defaultdict\nimport bisect \nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        to_idx = defaultdict(list)\n        for i,n in enumerate(nums):\n            bisect.insort(to_idx[n], i)\n\n        # print(to_idx)\n        ret = []\n        for i in queries:\n            val = nums[i]\n            if len(to_idx[val]) == 1:\n                ret.append(-1)\n            else:\n                l = to_idx[val]\n                j = bisect.bisect_left(l, i)\n                # print(f\"idx: {i}, val: {val}, idxs: {l}, closest: {j}\")\n                left = abs(l[j-1] - i)\n                dist = min(left, len(nums) - left)\n                right = abs(l[(j+1)%len(l)] - i)\n                dist = min(dist, right, len(nums) - right)\n                ret.append(dist)\n\n        return ret\n            \n            \n            \n        ","author":"Ali Nikseresht","submissionId":"1575120282"},[]]},{"600":[{"id":"600","fileName":"1575120433.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n\t\tmap<int, vector<int>> m;\n\t\tfor (int i = 0; i < (int)nums.size(); i++)\n\t\t{\n\t\t\tm[nums[i]].push_back(i);\n\t\t}\n\t\tvector<int> ans(queries.size(), 0);\n\t\tfor (int i = 0; i < (int)queries.size(); i++)\n\t\t{\n\t\t\tint pos = queries[i];\n\t\t\tint e = nums[pos];\n\t\t\tif(m[e].size() == 1) ans[i] = -1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint find_pos =\n\t\t\t\t\tlower_bound(m[e].begin(), m[e].end(), pos) - m[e].begin();\n\t\t\t\tint dist1, dist2;\n\t\t\t\tif (find_pos == 0)\n\t\t\t\t{\n\t\t\t\t\tdist1 = m[e][1] - m[e][0];\n\t\t\t\t\tdist2 = (-m[e].back() + m[e][0] + nums.size());\n\t\t\t\t}\n\t\t\t\telse if (find_pos == (int)m[e].size() - 1)\n\t\t\t\t{\n\t\t\t\t\tdist1 = m[e].back() - m[e][find_pos - 1];\n\t\t\t\t\tdist2 = (nums.size()-m[e].back() + m[e][0]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdist1 = m[e][find_pos + 1] - m[e][find_pos];\n\t\t\t\t\tdist2 = m[e][find_pos] - m[e][find_pos - 1];\n\t\t\t\t}\n\t\t\t\tans[i] = min(dist1, dist2);\n\t\t\t}\n\n\t\t}\n\t\treturn ans;\n\n                \n    }\n};","author":"Adithya K Anil","submissionId":"1575120433"},[]]},{"601":[{"id":"601","fileName":"1575120594.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        const int n = nums.size();\n        \n        unordered_map<int, vector<int>> val_to_idx;\n        for (int i = 0; i < nums.size(); ++i)\n            val_to_idx[nums[i]].push_back(i);\n\n        vector<int> ans(queries.size(), -1);\n        for (int i = 0; i < queries.size(); ++i) {\n            const int idx = queries[i];\n            const vector<int>& idxs = val_to_idx[nums[idx]];\n            const int m = idxs.size();\n            if (idxs.size() == 1)\n                continue;\n\n            const auto [s, e] = equal_range(idxs.begin(), idxs.end(), idx);\n            int j = distance(idxs.begin(), s);\n            ans[i] = min(tmp(idx, idxs[(j+m-1)%m], n), tmp(idx, idxs[(j+1)%m], n));\n        }\n\n        return ans;\n    }\n\nprivate:\n    int tmp(int x, int y, int n) {\n        if (x > y)\n            swap(x, y);\n        return min(y-x, x + n - y);\n    }\n};","author":"Andrey","submissionId":"1575120594"},[]]},{"602":[{"id":"602","fileName":"1575120554.txt","sourceCode":"class Solution {\n    static void dbg(Object... args) {\n        List<String> lst = new ArrayList<>();\n        for (Object arg : args) {\n        if (arg.getClass().isArray()) {\n        if ((\"\" + arg.getClass().getComponentType()).equals(\"int\")) {\n        lst.add(Arrays.toString((int[]) arg));\n        } else if ((\"\" + arg.getClass().getComponentType()).equals(\"long\")) {\n        lst.add(Arrays.toString((long[]) arg));\n        } else if ((\"\" + arg.getClass().getComponentType()).equals(\"boolean\")) {\n        lst.add(Arrays.toString((boolean[]) arg));\n        }\n        } else {\n        lst.add(arg.toString());\n        }\n        }\n        System.out.println(\"[\" + String.join(\", \", lst) + \"]\");\n        }\n\nstatic void dbg(Object obj) {\n        System.out.println(obj);\n        }\n\nstatic void dbg(int[] arr) {\n        System.out.println(Arrays.toString(arr));\n        }\n\nstatic void dbg(boolean[] arr) {\n        System.out.println(Arrays.toString(arr));\n        }\n\nstatic void dbg(long[] arr) {\n        System.out.println(Arrays.toString(arr));\n        }\n\nstatic void dbg(char[] arr) {\n        System.out.println(Arrays.toString(arr));\n        }\n\nstatic void dbg(int[][] arr) {\n        List<String> lst = new ArrayList<>();\n        for (int i = 0; i < arr.length; i++) {\n        lst.add(Arrays.toString(arr[i]));\n        }\n        System.out.println(\"[\" + String.join(\",\", lst) + \"]\");\n        }\n\nstatic void dbg(long[][] arr) {\n        List<String> lst = new ArrayList<>();\n        for (int i = 0; i < arr.length; i++) {\n        lst.add(Arrays.toString(arr[i]));\n        }\n        System.out.println(\"[\" + String.join(\",\", lst) + \"]\");\n        }\n\nstatic void dbg(List<int[]> lst) {\n        List<String> res = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n        res.add(Arrays.toString(lst.get(i)));\n        }\n        System.out.println(\"[\" + String.join(\",\", res) + \"]\");\n        }\n\nstatic void dbg(Queue<int[]> q) {\n        List<int[]> lst = new ArrayList<>(q);\n        List<String> res = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n        res.add(Arrays.toString(lst.get(i)));\n        }\n        System.out.println(\"[\" + String.join(\",\", res) + \"]\");\n        }\n\nstatic void dbgSegmentTree(long[] tree) {\n        int n = tree.length;\n        List<List<String>> res = new ArrayList<>();\n        for (int level = 2; level <= n; level = (level << 1)) {\n        List<String> curr = new ArrayList<>();\n        int c = n / level;\n        for (int j = c; j < c + c; j++) {\n        curr.add(tree[j] + \"\");\n        }\n        res.add(curr);\n        }\n        Collections.reverse(res);\n        for (List<String> re : res) {\n        dbg(re);\n        }\n        }\n    \n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        int[] arr = new int[2 * n];\n        Map<Integer, Integer> f = new HashMap<>();\n        for(int i = 0; i < n; i++) {\n            f.put(nums[i], f.getOrDefault(nums[i], 0) + 1);\n        }\n        for(int i = 0; i < 2 * n; i++) {\n            arr[i] = nums[i % n];\n        }\n        int[] left = new int[2 * n];\n        Map<Integer, Integer> pos = new HashMap<>();\n        int INF = (int) 1e7;\n        Arrays.fill(left, INF);\n        for(int i = 0; i < 2 * n; i++) {\n            if(pos.containsKey(arr[i])) {\n                left[i] = pos.get(arr[i]);\n            }\n            pos.put(arr[i], i);\n        }\n        pos.clear();\n        int[] right = new int[2 * n];\n        Arrays.fill(right, INF);\n        for(int i = 2 * n - 1; i >= 0; i--) {\n            if(pos.containsKey(arr[i])) {\n                right[i] = pos.get(arr[i]);\n            }\n            pos.put(arr[i], i);\n        }\n        List<Integer> ans = new ArrayList<>();\n        // dbg(left);\n        // dbg(right);\n        for(int q : queries) {\n            int curr = INF;\n            if(f.get(nums[q]) == 1) {\n                ans.add(-1);\n                continue;\n            }\n            if(left[q + n] != INF) {\n                curr = Math.min(curr, q + n - left[q + n]);\n            }\n            if(right[q] != INF) {\n                curr = Math.min(curr, right[q] - q);\n            }\n            if(curr != INF) {\n                ans.add(curr);\n            } else {\n                ans.add(-1);\n            }\n        }\n        return ans;\n    }\n}","author":"Algernon_5","submissionId":"1575120554"},[]]},{"603":[{"id":"603","fileName":"1575120444.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& qr) {\n        unordered_map<int, vector<int>> indexMap;\n        int n = a.size();\n        \n        for (int i = 0; i < n; ++i) {\n            indexMap[a[i]].push_back(i);\n        }\n        \n        vector<int> ans;\n        \n        for (int q : qr) {\n            int value = a[q];\n            \n            if (indexMap[value].size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            \n            int mini = n;\n            vector<int>& indices = indexMap[value];\n            auto it = upper_bound(indices.begin(), indices.end(), q);\n            if(q != *indices.begin()){\n                auto itb = indices.begin();\n                int d = abs(*itb - q);\n                mini = min(mini, min(d, n - d));\n            }\n            if(q != *indices.rbegin()){\n                auto itb = indices.rbegin();\n                int d = abs(*itb - q);\n                mini = min(mini, min(d, n - d));\n            }\n            if (it != indices.end()) {\n                int d = abs(*it - q);\n                mini = min(mini, min(d, n - d));\n            }\n            if (it != indices.begin()) {\n                --it;\n            }\n            if (it != indices.begin()) {\n                --it;\n                int d = abs(*it - q);\n                mini = min(mini, min(d, n - d));\n            }\n            \n            int circularDist = n - mini;\n            mini = min(mini, circularDist);\n            \n            ans.push_back(mini);\n        }\n        \n        return ans;\n    }\n};","author":"Manorath Reddy","submissionId":"1575120444"},[]]},{"605":[{"id":"605","fileName":"1575120428.txt","sourceCode":"class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nfrom bisect import bisect_left\nfrom collections import defaultdict\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        pos = defaultdict(list)\n        \n        for i, num in enumerate(nums):\n            pos[num].append(i)\n        \n        ans = []\n        \n        for q in queries:\n            val = nums[q]\n            idl = pos[val]\n            \n            if len(idl) < 2:\n                ans.append(-1)\n                continue\n            \n            idx = bisect_left(idl, q) \n\n            lidx = (idx - 1) % len(idl)\n            ridx = (idx + 1) % len(idl)\n            \n            posl = idl[lidx]\n            posr = idl[ridx]\n            \n            ldis = min(abs(q - posl), n - abs(q - posl))\n            rdis = min(abs(q - posr), n - abs(q - posr))\n            \n            ans.append(min(ldis, rdis))\n        \n        return ans\n\n","author":"invisible","submissionId":"1575120428"},[]]},{"606":[{"id":"606","fileName":"1575120692.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n, m = len(nums), len(queries)\n\n        np = {}\n        for i, x in enumerate(nums):\n            if x not in np:\n                np[x] = []\n            np[x].append(i)\n\n        res = []\n        for q in queries:\n            a = np[nums[q]]\n            if len(a) > 1:\n                pos = bisect.bisect_left(a, q)            \n                pre = q - a[pos - 1] if pos != 0 else a[-1] - q\n                suf = a[pos + 1] - q if pos + 1 < len(a) else q - a[0]\n                res.append(min(pre, suf, n - pre, n - suf))\n            else:\n                res.append(-1)\n        return res","author":"Jiahao","submissionId":"1575120692"},[]]},{"608":[{"id":"608","fileName":"1575120792.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        \n        N=len(nums)\n        def help(nums):\n            arr=nums+nums\n            lastseen=defaultdict(int)\n            mindistArr=[0]*N\n            for i in reversed(range(N, 2*N)):\n                lastseen[arr[i]]=i\n            # print(lastseen)\n            for i in reversed(range(N)):\n                # print(arr[i], lastseen[arr[i]], lastseen[arr[i]] - i, N)\n                if lastseen[arr[i]] - i == N:\n                    mindistArr[i]=-1\n                else:\n                    mindistArr[i]=lastseen[arr[i]]-i\n                lastseen[arr[i]]=i\n            return mindistArr\n        \n        mindistright=help(nums)\n        mindistleft=help(nums[::-1])[::-1]\n        ans=[]\n        for q in queries:\n            dist=min(mindistright[q], mindistleft[q])\n            if dist!=inf:\n                ans.append(dist)\n            else:\n                ans.append(-1)\n        return ans","author":"Akshay","submissionId":"1575120792"},[]]},{"609":[{"id":"609","fileName":"1575120835.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> m;\n        for(int i=0; i<nums.size(); i++) m[nums[i]].push_back(i);\n\n        vector<int> ans(queries.size());\n        for(int i=0; i<queries.size(); i++){\n            int ind = queries[i];\n            int num = nums[ind];\n            if(m[num].size()==1){\n                ans[i]= -1;\n                continue;\n            }\n            auto current = lower_bound(begin(m[num]), end(m[num]), ind);\n            auto position = current - m[num].begin();\n            if(position==0){\n                auto prev_ = *m[num].rbegin();\n                auto next_ = *next(current);\n\n                int left = next_ - ind;\n                int right= nums.size()-prev_+ind;\n                ans[i] = min(left, right);\n            }\n            else if(position==m[num].size()-1){\n                auto prev_ = *prev(current);\n                auto next_ = *m[num].begin();\n\n                int left = ind - prev_;\n                int right= nums.size()-ind+next_;\n                ans[i] = min(left, right);\n            }\n            else{\n                auto prev_ = *prev(current);\n                auto next_ = *next(current);\n\n                ans[i] = min(ind-prev_, next_-ind);\n            }\n        }\n        return ans;\n    }\n};","author":"rodesmodes1","submissionId":"1575120835"},[]]},{"610":[{"id":"610","fileName":"1575120610.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        unordered_map<int, vector<int>> m;\n        for(int i=0; i<n; ++i){\n            m[ nums[i] ].push_back(i);\n        }\n        for(auto &k : m){\n            sort(k.second.begin(), k.second.end());\n        }\n        vector<int> res;\n        res.reserve(q);\n        for(auto query : queries){\n            int val = nums[query];\n            vector<int>& pos = m[val];\n            if(pos.size() == 1) res.push_back(-1);\n            else{\n                int ind = lower_bound(pos.begin(), pos.end(), query) - pos.begin();\n                int dis;\n                if(ind > 0) dis =  pos[ind] - pos[ind-1];\n                else dis = pos[0] + n - pos.back();\n                if(ind < pos.size()-1) dis = min(dis, pos[ind+1] - pos[ind]);\n                else dis = min(dis, pos[0] + n - pos.back());\n                res.push_back(dis);\n            }\n        }\n        return res;\n    }\n};","author":"william6715","submissionId":"1575120610"},[]]},{"612":[{"id":"612","fileName":"1575120347.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> cache;\n        int n = nums.size();\n        for (int i = 0; i < nums.size(); ++i) {\n            cache[nums[i]].push_back(i);\n        }\n        vector<int> res;\n        for (int q : queries) {\n            int v = nums[q];\n            //cout << \"v : \" << v << \" \"; \n            if (cache[v].size() == 1) {\n                res.push_back(-1);\n            } else {\n                auto it = lower_bound(cache[v].begin(), cache[v].end(), q);\n                int idx = it - cache[v].begin();\n                int m = cache[v].size();\n                int pre = idx == 0 ? cache[v][m-1] : cache[v][idx-1];\n                int nxt = idx == m-1 ? cache[v][0] : cache[v][idx + 1];\n                //cout << pre << \" \" << nxt << endl;\n                int pre_dist = min(min(abs(q - pre), abs(pre + n - q)), abs(q + n - pre));\n                int nxt_dist = min(min(abs(q - nxt), abs(nxt + n - q)), abs(q + n - nxt));\n                res.push_back(min(pre_dist, nxt_dist));\n            }\n        }\n        return res;\n    }\n};","author":"Tyrande","submissionId":"1575120347"},[]]},{"613":[{"id":"613","fileName":"1575120918.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& qr) {\n        int n = nums.size();\n        vector<int> lnear(n,-1),rnear(n,-1),lfar(n,-1),rfar(n,-1),res;\n        unordered_map<int,int> mp;\n        for(int i = 0;i<n;i++){\n            if(mp.count(nums[i])){\n                lnear[i] = mp[nums[i]];\n            }\n            mp[nums[i]] = i;\n        }\n\n        mp.clear();\n        for(int i = 0;i<n;i++){\n            if(mp.count(nums[i])){\n                lfar[i] = mp[nums[i]];\n            }\n            else\n                mp[nums[i]] = i;\n        }\n\n        mp.clear();\n        for(int i = n-1;i>=0;i--){\n            if(mp.count(nums[i])){\n                rnear[i] = mp[nums[i]];\n            }\n            mp[nums[i]] = i;\n        }\n\n        mp.clear();\n        for(int i = n-1;i>=0;i--){\n            if(mp.count(nums[i])){\n                rfar[i] = mp[nums[i]];\n            }\n            else\n                mp[nums[i]] = i;\n        }\n\n        for(auto& q : qr){\n            int rs = INT_MAX;\n            // cout<<lnear[q]<<\" \"<<lfar[q]<<\" \"<<rnear[q]<<\" \"<<rfar[q]<<endl;\n            \n            if(lnear[q] != -1) rs = min(rs,q-lnear[q]);\n            else if(rfar[q] != -1) rs = min(rs,n-rfar[q]+q);\n            \n            if(rnear[q] != -1) rs = min(rs,rnear[q]-q);\n            else if(lfar[q] != -1) rs = min(rs,n-q+lfar[q]);\n            \n            if(rs == INT_MAX)\n                res.push_back(-1);\n            else\n                res.push_back(rs);\n            \n        }\n        return res;\n    }\n};","author":"Sithaarth M","submissionId":"1575120918"},[]]},{"614":[{"id":"614","fileName":"1575120992.txt","sourceCode":"class Solution {\n    int diff(int l, int r, int sz){\n            if(r>l) return min(r-l, l+sz-r);\n            else return min(l-r, r+sz-l);\n    }\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> left(nums.size(),-1);\n        vector<int> right(nums.size(),-1);\n        unordered_map<int,int> last_pos_left;\n        unordered_map<int,int> last_pos_right;\n\n        for(int it=0;it<nums.size();it++){\n            auto ind = last_pos_left.find(nums[it]);\n            if(ind != last_pos_left.end()){\n                ind->second = it;\n            }\n            else{\n                last_pos_left[nums[it]] = it;\n            }\n        }\n        for(int it=0;it<nums.size();it++){\n            auto ind = last_pos_left.find(nums[it]);\n            left[it] = ind->second;\n            ind->second = it;\n        }\n\n        \n        for(int it=nums.size()-1;it>=0;it--){\n            auto ind = last_pos_right.find(nums[it]);\n            if(ind != last_pos_right.end()){\n                ind->second = it;\n            }\n            else{\n                last_pos_right[nums[it]] = it;\n            }\n        }\n        for(int it=nums.size()-1;it>=0;it--){\n            auto ind = last_pos_right.find(nums[it]);\n            right[it] = ind->second;\n            ind->second = it;\n        }\n\n        vector<int> ans;\n        ans.reserve(queries.size());\n        for(const auto &ind:queries){\n            if(left[ind] != ind){\n                ans.push_back(min(diff(ind, left[ind], nums.size()), diff(ind, right[ind], nums.size())));\n            }\n            else ans.push_back(-1);\n        }\n        return ans;\n    }\n};","author":"peak_slayer","submissionId":"1575120992"},[]]},{"615":[{"id":"615","fileName":"1575120983.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, int[]> map = new HashMap();\n        for (int i = 0; i < nums.length; i++)\n            {\n                if (!map.containsKey(nums[i])) map.put(nums[i], new int[]{i, i});\n                int[] arr = map.get(nums[i]);\n                int x = nums[i];\n                if (i == arr[0]) nums[i] = -1;\n                else\n                {\n                    int d1 = i - arr[1];\n                    if (d1 < nums[arr[1]] || nums[arr[1]] == -1) nums[arr[1]] = d1;\n                    int d2 = arr[0] + nums.length - i;\n                    if (d2 < nums[arr[0]] || nums[arr[0]] == -1) nums[arr[0]] = d2;\n                    nums[i] = Math.min(d1, d2);\n                }\n                map.put(x, new int[]{arr[0], i});\n            }\n\n        List<Integer> ans = new ArrayList();\n        for (int a : queries) ans.add(nums[a]);\n        return ans;\n    }\n}","author":"sodacorsair","submissionId":"1575120983"},[]]},{"617":[{"id":"617","fileName":"1575121014.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        mp=defaultdict(list)\n        l=len(nums)\n        for i,x in enumerate(nums):\n            mp[x].append(i)\n        ans=[]\n        for i,q in enumerate(queries):\n            x=nums[q]\n            if len(mp[x])==1:\n                ans.append(-1)\n            else:\n                idx=bisect_left(mp[x],q)\n                #print(mp[x],q,x,idx)\n                if idx==0:\n                    ans.append(min(mp[x][idx+1]-q,l-1-mp[x][-1]+q+1))\n                elif idx==len(mp[x])-1:\n                    ans.append(min(q-mp[x][idx-1],l-1-q+mp[x][0]+1))\n                else:\n                    ans.append(min(q-mp[x][idx-1],mp[x][idx+1]-q))\n       # print(ans)\n        return ans\n        ","author":"Anshuman","submissionId":"1575121014"},[]]},{"618":[{"id":"618","fileName":"1575120959.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        index = defaultdict(list)\n        for i, num in enumerate(nums):\n            index[num].append(i)\n        m = len(nums)\n        # print(m)\n        result = []\n        for q in queries:\n            # print(q)\n            l = index[nums[q]]\n            # print(l)\n            if len(l) == 1:\n                result.append(-1)\n            else:\n                pos = bisect.bisect_left(l, q)\n                n = (pos + 1) % len(l)\n                p = (pos - 1 + len(l)) % len(l)\n                # print(f\"pos: {pos}, {n}, {p}\")\n                result.append(min((l[n] - l[pos] + m) % m, (l[pos] - l[p] + m) % m))\n\n        return result\n            ","author":"seanzhoujobs","submissionId":"1575120959"},[]]},{"621":[{"id":"621","fileName":"1575121090.txt","sourceCode":"class Solution {\npublic:\n    int dist(int a, int b, int n) {\n        if (a < b) return dist(b, a, n);\n        return min(a - b, n - a + b);\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int qz = queries.size();\n        int n = nums.size();\n        vector<int> res(qz);\n        unordered_map<int, vector<int>> indices;\n        for (int i = 0; i < nums.size(); i++) indices[nums[i]].push_back(i);\n        for (auto& [k, v] : indices) sort(v.begin(), v.end());\n\n        for (int i = 0; i < qz; i++) {\n            int target = nums[queries[i]];\n            auto& v = indices[target];\n            if (v.size() == 1) {\n                res[i] = -1;\n                continue;\n            }\n            auto it = lower_bound(v.begin(), v.end(), queries[i]);\n            int idx = distance(v.begin(), it);\n            // cout<<queries[i]<<\" \"<<idx<<\" \"<<target<<endl;\n            if (idx == 0) {\n                res[i] = min(dist(v[idx], v[idx + 1], n), dist(v[idx], v.back(), n));\n            } else if (idx == v.size() - 1) {\n                res[i] = min(dist(v.back(), v[v.size() - 2], n), dist(v.back(), v[0], n));\n            } else {\n                res[i] = min(dist(v[idx], v[idx + 1], n), dist(v[idx], v[idx - 1], n));\n            }\n        }\n        return res;\n    }\n};","author":"hiJason","submissionId":"1575121090"},[]]},{"549":[{"id":"549","fileName":"1575118664.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector <int> rt;\n        int n = nums.size();\n        vector <vector <int>> mp;\n        mp.assign(((int)1e5 + 1),{});\n        for(int i = 0; i<n; i++) mp[nums[i]].push_back(i);\n        for(auto q : queries){\n            int t = nums[q];\n            int ans = 1e9;\n            int i = lower_bound(mp[t].begin() , mp[t].end(), q) - mp[t].begin();\n            if(i!=0){\n                ans = min(ans,mp[t][i]-mp[t][i-1]);\n                ans = min(ans,n-(mp[t][i]-mp[t][0]));\n            }\n            if(i!=mp[t].size()-1){\n                ans = min(ans,mp[t][i+1]-mp[t][i]);\n                ans = min(ans,n-(mp[t][mp[t].size()-1]-mp[t][i]));\n            }\n            if(ans==1e9) ans = -1;\n            rt.push_back(ans);\n        }\n        return rt;\n    }\n};","author":"Manimum","submissionId":"1575118664"},[{"id":"549","similarity":0.7010309278350515,"totOverlap":136,"longestOverlap":13}]],"622":[{"id":"622","fileName":"1575121133.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>>mp;\n        int n = nums.size();\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        int q = queries.size();\n        vector<int>ans(q,-1);\n        for(int i=0;i<q;i++){\n            int val = queries[i];\n            int value = nums[val];\n            if(mp[value].size()<2){\n                ans[i] = -1;\n            }\n            else{\n                int idx = lower_bound(mp[value].begin(),mp[value].end(), val ) - mp[value].begin();\n                int m = mp[value].size();\n                if(idx==0){\n                    int d1 = mp[value][idx+1] - mp[value][idx];\n                    int d2 = n - mp[value].back() + mp[value][idx];\n                    if(d1>=d2) ans[i] = d2;\n                    else{\n                       ans[i]= d1;\n                    }\n                    \n                }\n                else if(idx == m-1){\n                    int d1 = mp[value][idx] - mp[value][idx-1];\n                    int d2 = n - mp[value][idx] + mp[value][0];\n                    if(d1>=d2) ans[i] = d2;\n                    else{\n                        ans[i]= d1;\n                    }\n                    \n                }\n                else{\n                    int d1 = mp[value][idx] - mp[value][idx-1];\n                    int d2 = mp[value][idx +1]- mp[value][idx];\n                    if(d1>=d2) ans[i] = d2;\n                    else{\n                        ans[i]= d1;\n                    }\n                    \n                }\n                \n            }\n        }\n        return ans;\n        \n    }\n};","author":"Hardik Aswal","submissionId":"1575121133"},[{"id":"928","similarity":0.7037037037037037,"totOverlap":190,"longestOverlap":38},{"id":"933","similarity":0.7136563876651982,"totOverlap":162,"longestOverlap":20},{"id":"933","similarity":0.7010309278350515,"totOverlap":136,"longestOverlap":13}]],"928":[{"id":"928","fileName":"1575128610.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n       unordered_map<int,vector<int>>mp;\n       int n = nums.size();\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        int q = queries.size();\n        vector<int>ans(q,-1);\n\n        for(int i=0;i<q;i++){\n            int num = nums[queries[i]];\n            if(mp.find(num)==mp.end() || mp[num].size()<2){continue;}\n\n            if(mp[num][0]==queries[i]){\n                int dis1 = mp[num][1]-mp[num][0];\n                int dis2 = (mp[num][0]+1)+(n-1)-mp[num].back();\n                if(dis1<=dis2){ans[i]=dis1;}\n                else{ans[i]=dis2;}\n            }\n            else if(mp[num].back()==queries[i]){\n                int dis1 = mp[num].back()-mp[num][mp[num].size()-2];\n                int dis2 = (n-mp[num].back())+(mp[num][0]);\n                if(dis1<=dis2){ans[i]=dis1;}\n                else{ans[i]=dis2;}\n            }\n            else{\n                auto it = lower_bound(mp[num].begin(),mp[num].end(),queries[i])-mp[num].begin();\n                int dis1 = mp[num][it]-mp[num][it-1];\n                int dis2 = mp[num][it+1]-mp[num][it];\n                if(dis1<=dis2){ans[i]=dis1;}\n                else{ans[i]=dis2;}\n            }\n        }\n\n        return ans;\n    }\n};","author":"Tanishq Singh Rathore","submissionId":"1575128610"},[{"id":"622","similarity":0.7037037037037037,"totOverlap":190,"longestOverlap":38}]],"933":[{"id":"933","fileName":"1575128796.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> numToIdxs;\n        int n = nums.size();\n        for(int i=0; i<n; ++i)\n            numToIdxs[nums[i]].push_back(i);\n\n        int qn = queries.size();\n        vector<int> ans(qn, -1);\n        for(int i=0; i<qn; ++i){\n            int currIdx = queries[i];\n            int num = nums[currIdx], sz = numToIdxs[num].size();\n            if(sz == 1) continue;\n            \n            int res = 1e9;\n            int idx = lower_bound(numToIdxs[num].begin(), numToIdxs[num].end(), currIdx) - numToIdxs[num].begin();\n            if(idx > 0) res = min(res, numToIdxs[num][idx] - numToIdxs[num][idx-1]);\n            else res = min(res, n - (numToIdxs[num][sz-1] - numToIdxs[num][idx]));\n            \n            if(idx !=  sz-1) res = min(res, numToIdxs[num][idx+1] - numToIdxs[num][idx]);\n            else res = min(res, n - (numToIdxs[num][idx] - numToIdxs[num][0]));\n            \n            ans[i] = res;\n        }\n        \n        return ans;\n    }\n};","author":"Santosh Swansi","submissionId":"1575128796"},[{"id":"622","similarity":0.7136563876651982,"totOverlap":162,"longestOverlap":20}]]},{"623":[{"id":"623","fileName":"1575121166.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> m;\n        int n = nums.size();\n        for(int i=0;i<n;i++){\n            m[nums[i]].push_back(i);\n        }\n        vector<int> res;\n        for(auto q:queries){\n            int k = nums[q];\n            if(m.find(k)==m.end()){\n                res.push_back(-1);\n            }\n            else{\n                vector<int> &v = m[k];\n                int idx = lower_bound(v.begin(),v.end(),q)-v.begin();\n                if(v.size()==1){\n                    res.push_back(-1);\n                }\n                else{\n                    int p;\n                    cout<<idx<<v.size()<<endl;\n                    if(idx==0){\n                         p = min(v[1]-v[0],n-v[v.size()-1]+v[0]);\n                    }\n                    else if(idx == v.size()-1){\n                        p = min(v[v.size()-1]-v[v.size()-2],n-v[v.size()-1]+v[0]);\n                    }\n                    else{\n                        p = min(v[idx]-v[idx-1],v[idx+1]-v[idx]);\n                    }\n                    res.push_back(p);\n                }\n            }\n        }\n        return res;\n    }\n};","author":"Pranav Bansal","submissionId":"1575121166"},[]]},{"624":[{"id":"624","fileName":"1575121154.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, TreeSet<Integer>> map = new HashMap<>();\n        \n        for (int i = 0; i < nums.length; i++) {\n            if (!map.containsKey(nums[i])) {\n                map.put(nums[i], new TreeSet<Integer>());\n            }\n            map.get(nums[i]).add(i);\n        }\n        \n        \n        List<Integer> li = new ArrayList<>();\n        for (int i = 0; i < queries.length; i++) {\n            int val = queries[i];\n            int target = nums[val];\n            TreeSet<Integer> s = map.get(target);\n            if (s.size() == 1) {\n                li.add(-1);\n                continue;\n            } else {\n                Integer next = s.higher(val);\n                int first = s.first();\n                int diffN = Integer.MAX_VALUE;\n                if (next != null) {\n                    diffN = next - val;\n                }\n                int diffF = Integer.MAX_VALUE;\n                if (first != val) {\n                    diffF = first + nums.length - val;\n                }\n                Integer pre = s.lower(val);\n                int diffL = Integer.MAX_VALUE;\n                if (pre != null) {\n                    diffL = val - pre;\n                }\n                int minDiff = Math.min(diffN, diffF);\n                \n                \n                \n                int sss = Math.min(minDiff, diffL);\n                \n                int diffLast = Integer.MAX_VALUE;\n                int last = s.last();\n                if (last != val) {\n                    diffLast = val - (last - nums.length);\n                }       \n                int result = Math.min(sss, diffLast);\n                \n                li.add(result);\n            }\n        }\n        return li;\n    }\n}\n// 0 1 2 3\n// 3 - 0","author":"jason_wong1","submissionId":"1575121154"},[]]},{"625":[{"id":"625","fileName":"1575121177.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = (int)nums.size();\n        map<int,int> prev, next;\n        vector<int> left(n), right(n);\n        for(int i = 0; i < n; i++)\n            prev[nums[i]] = i;\n\n        for(int i = 0; i < n; i++) {\n            left[i] = prev[nums[i]];\n            prev[nums[i]] = i;\n        }\n\n        for(int i = n-1; i >= 0; i--)\n            next[nums[i]] = i;\n\n        for(int i = n-1; i >= 0; i--) {\n            right[i] = next[nums[i]];\n            next[nums[i]] = i;\n        }\n        vector<int> ans;\n        for(auto &q: queries) {\n            int l = left[q];\n            int r = right[q];\n\n            if(l == q or r == q) {\n                ans.push_back(-1);\n                continue;\n            }\n\n            auto getDist = [&](int l, int q)->int {\n                int d = abs(l-q);\n                return min(d, n-d);\n            };\n\n            ans.push_back(min(getDist(l,q), getDist(r,q)));\n        }\n        return ans;\n    }\n};","author":"_Dragneel","submissionId":"1575121177"},[]]},{"626":[{"id":"626","fileName":"1575121029.txt","sourceCode":"class Solution {\npublic:\n    int findIdx(vector<int> &nums, int ele) {\n        int low = 0, high = nums.size() - 1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (nums[mid] == ele)\n                return mid;\n            else if (nums[mid] < ele)\n                low = mid + 1;\n            else\n                high = mid - 1;\n        }\n        return -1;  // Element not found\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& qu) {\n        int q = qu.size(), n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for(int i=0; i<n; i++){\n            int ele = nums[i];\n            mp[ele].push_back(i);\n        }\n        //algorithm\n        vector<int> ans(q);\n        for(int i=0; i<q; i++){\n            int idx = qu[i];\n            int ele = nums[idx];\n            int sz = mp[ele].size();\n            int myIdx = findIdx(mp[ele], idx);\n            if(sz == 1) ans[i] = -1;\n            else if(sz == 2){\n                int val1 = abs(mp[ele][0] - mp[ele][1]);\n                int val2 = (n-mp[ele][sz-1]) + mp[ele][0];\n                ans[i] = min(val1, val2);\n            }\n            else if(myIdx != 0 && myIdx != sz-1){\n                int val1 = abs(mp[ele][myIdx]-mp[ele][myIdx-1]);\n                int val2 = abs(mp[ele][myIdx]-mp[ele][myIdx+1]);\n                int dist = min(val1, val2);\n                ans[i] = dist;\n            }\n            else if(myIdx == 0){\n                int val1 = abs(mp[ele][0] - mp[ele][1]);\n                int val2 = (n-mp[ele][sz-1]) + mp[ele][0];\n                ans[i] = min(val1, val2);\n            }\n            else{\n                int val1 = abs(mp[ele][sz-1] - mp[ele][sz-2]);\n                int val2 = (n-mp[ele][sz-1]) + mp[ele][0];\n                ans[i] = min(val1, val2);\n            }\n        }\n        return ans;\n    }\n};","author":"Koushik Debnath","submissionId":"1575121029"},[]]},{"628":[{"id":"628","fileName":"1575121224.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> d;\n        for(int i = 0;i<n;i++){\n            int c = nums[i];\n            d[c].push_back(i);\n        }\n        vector<int> out;\n        for(int q:queries){\n            int c = nums[q];\n            int l = 0, h = d[c].size();\n            while(l<h){\n                int m = (h-l)/2+l;\n                if(d[c][m] == q){\n                    l = m;\n                    break;\n                }\n                else if(d[c][m]<q){\n                    l = m;\n                }\n                else{\n                    h = m;\n                }\n                if(l+1 == h){\n                    if(d[c][h] == q){\n                        l = h;\n                    }\n                    else{\n                        h = l;\n                    }\n                }\n            }\n                \n            int sz = d[c].size();\n            if(sz == 1){\n                out.push_back(-1);\n                continue;\n            }\n            int prev_ind = d[c][(l-1+sz)%sz], next_ind = d[c][(l+1)%sz];\n            int prev_dist = INT_MAX, next_dist = INT_MAX;\n            if(prev_ind < q){\n                prev_dist = min(q-prev_ind, prev_ind+n-q);\n            }\n            else{\n                prev_dist = min(prev_ind-q, q+n-prev_ind);\n            }\n            if(next_ind < q){\n                next_dist = min(q-next_ind, next_ind+n-q);\n            }\n            else{\n                next_dist = min(next_ind-q, q+n-next_ind);\n            }\n            out.push_back(min(next_dist, prev_dist));\n        }\n        return out;\n    }\n};","author":"Yunchuan","submissionId":"1575121224"},[]]},{"629":[{"id":"629","fileName":"1575121328.txt","sourceCode":"class Solution {\npublic:\n    \n    int findMinimumDistance(int pos1, int pos2, int n){\n        \n        if(pos1>pos2)swap(pos1,pos2);\n        \n        int ans=pos2-pos1;\n        ans=min(ans, pos1+n-pos2);\n        \n        return ans;\n        \n        \n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        \n        int q=queries.size();\n        int n=nums.size();\n        vector<int> queryIndex(n,-1);\n        vector<int> ans(q,-1);\n        for(int i=0;i<q;i++){\n            queryIndex[queries[i]]=i;\n        }\n        \n        unordered_map<int,vector<int>> hash;\n        \n        for(int i=0;i<n;i++){\n            hash[nums[i]].push_back(i);\n        }\n        \n        for(auto arr:hash){\n            vector<int> pos=arr.second;\n            int sz=pos.size();\n            if(sz>1){\n                \n                for(int i=0;i<sz;i++){\n                    \n                    int prevpos=(i-1+sz)%sz;\n                    int nextpos=(i+1+sz)%sz;\n                    \n                    int mina=findMinimumDistance(pos[i],pos[prevpos],n);\n                    mina=min(mina,findMinimumDistance(pos[i],pos[nextpos],n));\n                    if(queryIndex[pos[i]]!=-1){\n                        ans[queryIndex[pos[i]]]=mina;\n                    }\n                }\n            }\n        }\n        \n        return ans;\n        \n    }\n};","author":"Sahil Kumar","submissionId":"1575121328"},[]]},{"631":[{"id":"631","fileName":"1575121234.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> indices;\n        for (int i = 0; i < n; i++) {\n            indices[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for (int i : queries) {\n            int val = nums[i];\n            if (indices[val].size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            vector<int>& pos = indices[val];\n            int idx = lower_bound(pos.begin(), pos.end(), i) - pos.begin();\n            int minDist = n;\n            if (idx < pos.size() - 1) minDist = min(minDist, abs(pos[idx + 1] - i));\n            if (idx > 0) minDist = min(minDist, abs(pos[idx - 1] - i));\n            minDist = min({minDist, n - abs(pos[0] - i), n - abs(pos.back() - i)});\n            ans.push_back(minDist);\n        }\n        return ans;\n    }\n};\n","author":"edward7780","submissionId":"1575121234"},[]]},{"632":[{"id":"632","fileName":"1575121354.txt","sourceCode":"class Solution \n{\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) \n    {\n        int n = nums.size(), m = queries.size();\n        unordered_map<int, vector<int>> um;\n        for(int i = 0; i < n; i++)\n        {\n            um[nums[i]].push_back(i);\n        }\n        vector<int> dis(n, -1);\n        for(auto it : um)\n        {\n            int ni = it.second.size();\n            if(ni == 1)\n            {\n                continue;\n            }\n            for(int i = 0; i < ni; i++)\n            {\n                int last = it.second[(i - 1 + ni) % ni];\n                int ptr = it.second[i];\n                int next = it.second[(i + 1) % ni];\n                dis[ptr] = min(min(abs(last - ptr), n - abs(last - ptr)), min(abs(ptr - next), n - abs(ptr - next)));\n            }\n        }\n        for(int i = 0; i < m; i++)\n        {\n            queries[i] = dis[queries[i]];   \n        }\n        return queries;\n    }\n};","author":"Chou","submissionId":"1575121354"},[]]},{"633":[{"id":"633","fileName":"1575121472.txt","sourceCode":"class Solution:\n    def bs(self,arr,x):\n        beg = 0\n        end = len(arr)-1\n        while beg<=end:\n            mid = (end-beg)//2 + beg\n            if arr[mid]==x:\n                return mid\n            if arr[mid]>x:\n                end = mid-1\n            else:\n                beg = mid+1\n        return -1\n    \n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = collections.defaultdict(list)\n        for i in range(len(nums)):\n            d[nums[i]].append(i)\n        result = []\n        for query in queries:\n            val = nums[query]\n            idx = self.bs(d[val],query)\n            if len(d[val])==1:\n                result.append(-1)\n            else:\n                p = len(nums)+1\n                if idx==0:\n                    p = min(p,d[val][idx]+(len(nums)-d[val][-1]),(d[val][idx+1]-d[val][idx]))\n                elif idx==len(d[val])-1:\n                    p = min(p,d[val][0]+(len(nums)-d[val][idx]),(d[val][idx]-d[val][idx-1]))\n                else:\n                    p = min(p,(d[val][idx+1]-d[val][idx]),(d[val][idx]-d[val][idx-1]))\n                result.append(p)\n        return result","author":"Who cares","submissionId":"1575121472"},[]]},{"635":[{"id":"635","fileName":"1575121498.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d=defaultdict(lambda:[])\n        for i in range(len(nums)):\n            d[nums[i]].append(i)\n\n\n        ans=[]\n        for i in queries:\n            l = d[nums[i]]\n            if i==9:\n                print(l)\n            if len(l)==1:\n                ans.append(-1)\n            else:\n                ind = bisect.bisect_left(l,i)\n                \n                len1 = 0\n                if ind!=0:\n                    len1 = abs(l[ind-1]-i)\n                else:\n                    len1 = l[ind]+len(nums)-l[-1]\n               \n                len2 = 0\n                if ind!=len(l)-1:\n                    len2 = abs(l[ind+1]-i)\n                else:\n                    len2 = len(nums)-l[ind]+l[0]\n\n                # if i==9:\n                #     print(ind+len(nums)-l[-1],len2)\n\n                ans.append(min(len1,len2))\n                    \n        return ans\n                \n                \n            \n                \n            ","author":"wanderlust312","submissionId":"1575121498"},[]]},{"636":[{"id":"636","fileName":"1575121475.txt","sourceCode":"class Solution {\n    public int fun1(int idx1, int idx2, int n){\n        if(idx1 > idx2){\n            int temp = idx1;\n            idx1 = idx2;\n            idx2 = temp;\n        }\n        int ans1 = idx2 - idx1;\n        int ans2 = n - idx2 + idx1;\n        return Math.min(ans1, ans2);\n    }\n    public List<Integer> solveQueries(int[] arr, int[] queries) {\n        List<Integer> ansList = new ArrayList<>();\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\n        int n = arr.length;\n        for(int i = 0; i < n; i++){\n            int val = arr[i];\n            if(!map.containsKey(val)) map.put(val, new ArrayList<>());\n            map.get(val).add(i);\n        }\n        int q = queries.length;\n        for(int i = 0; i < q; i++){\n            List<Integer> list = map.get(arr[queries[i]]);\n            int ls = list.size();\n            int low = 0, high = ls - 1, myAns = -1;\n            while(low <= high){\n                int mid = low + (high - low) / 2;\n                if(list.get(mid) == queries[i]){\n                    myAns = mid;\n                    break;\n                } else if(list.get(mid) < queries[i]){\n                    low = mid + 1;\n                } else{\n                    high = mid - 1;\n                }\n            }\n\n            // if(i == 2) {\n            //     System.out.println(\"myAns: \" + myAns);\n            //     System.out.println(\"list: \" + list);\n            // }\n            \n            if(ls == 1) ansList.add(-1);\n            else {\n                int nextIdx = list.get((myAns + 1) % ls);\n                int prevIdx = list.get((myAns - 1 + ls) % ls);\n                int ans1 = fun1(list.get(myAns), nextIdx, n);\n                int ans2 = fun1(list.get(myAns), prevIdx, n);\n\n            //     if(i == 2) {\n            //     System.out.println(\"nextIdx: \" + nextIdx);\n            //     System.out.println(\"prevIdx: \" + prevIdx);\n            // }\n                \n                ansList.add(Math.min(ans1, ans2));\n            }\n        }\n        return ansList;\n    }\n}","author":"Prakhar Garg","submissionId":"1575121475"},[]]},{"637":[{"id":"637","fileName":"1575121468.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        N = len(nums)\n        \n        group = defaultdict(list)\n        for i, x in enumerate(nums):\n            group[x].append(i)\n\n        ans = []\n        for q in queries:\n            x = nums[q]\n            a = group[x]\n            if len(a) == 1:\n                ans.append(-1)\n            else:\n                idx = bisect_left(a, q)\n                sz = len(a)\n                # print(q, a[idx-1], a[(idx+1) % sz])\n                \n                dis1 = abs(q - a[idx-1])\n                dis1 = min(dis1, abs(N - dis1))\n\n                dis2 = abs(q - a[(idx+1) % sz])\n                dis2 = min(dis2, abs(N - dis2))\n                # print(dis1, dis2)\n                \n                ans.append(min(dis1, dis2))\n\n        return ans","author":"momocowcow","submissionId":"1575121468"},[]]},{"641":[{"id":"641","fileName":"1575121577.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        l = len(nums)\n        def distance(a, b, c):\n            return min((a - b) % l, (b - a) % l, (a - c) % l, (c - a) % l)\n        indices = dict()\n        for i in range(len(nums)):\n            if nums[i] not in indices:\n                indices[nums[i]] = []\n            indices[nums[i]].append(i)\n        # tracker = dict()\n        # print(indices)\n        for i in range(len(queries)):\n            q = queries[i]\n            if len(indices[nums[q]]) == 1:\n                queries[i] = -1\n                continue\n            ind = bisect_left(indices[nums[q]], q)\n            if ind == 0:\n                queries[i] = distance(q, indices[nums[q]][-1], indices[nums[q]][1])\n            elif ind == len(indices[nums[q]]) - 1:\n                queries[i] = distance(q, indices[nums[q]][ind - 1], indices[nums[q]][0])\n            else:\n                queries[i] = distance(q, indices[nums[q]][ind - 1], indices[nums[q]][ind + 1])\n        return queries\n        ","author":"jyhuang2005","submissionId":"1575121577"},[]]},{"644":[{"id":"644","fileName":"1575121659.txt","sourceCode":"class Solution {\n    \n    /*\n    [14,14,4,2,19,19,14,19,14]\n[2,4,8,6,3]\nexpected = [-1,1,1,2,-1]\n    \n    \n    */\n    \n    \n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, TreeSet<Integer>> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int key = nums[i];\n            map.putIfAbsent(key, new TreeSet<>());\n            map.get(key).add(i);\n        }\n        // System.out.println(map);\n        List<Integer> ans = new ArrayList<>();\n        for (int query : queries) {\n            if (map.get(nums[query]).size() < 2) {\n                ans.add(-1);\n            } else {\n                int min = Integer.MAX_VALUE;\n                TreeSet<Integer> set = map.get(nums[query]);\n                Integer lower = set.lower(query);\n                if (lower != null) {\n                    int dist = Math.min(query - lower, lower + n - query);\n                    min = Math.min(min, dist);\n                } else {\n                    Integer last = set.last();\n                    int dist = Math.min(last - query, query + n - last);\n                    min = Math.min(min, dist);\n                }\n                Integer higher = set.higher(query);\n                if (higher != null) {\n                    int dist = Math.min(higher - query, query + n - higher);\n                    min = Math.min(min, dist);\n                } else {\n                    Integer first = set.first();\n                    int dist = Math.min(query - first, first + n - query);\n                    min = Math.min(min, dist);\n                }\n                ans.add(min);\n            }\n        }\n        return ans;\n        \n    }\n}","author":"Y","submissionId":"1575121659"},[]]},{"645":[{"id":"645","fileName":"1575121640.txt","sourceCode":"class Solution {\npublic:\n    int minCircularDist(int a, int b, int n) {\n        int d = abs(a - b);\n        return min(d, n - d);\n    }\n\n    unordered_map<int, vector<int>> groupPositions(const vector<int>& arr) {\n        unordered_map<int, vector<int>> pos;\n        pos.reserve(arr.size());\n        pos.max_load_factor(0.7f);\n        for (int i = 0; i < arr.size(); i++) {\n            pos[arr[i]].push_back(i);\n        }\n        return pos;\n    }\n\n    vector<int> computeNearestDistances(const vector<int>& arr) {\n        int n = arr.size();\n        vector<int> dst(n, -1);\n        auto pos = groupPositions(arr);\n        \n        for (auto& [_, idx] : pos) {\n            int cnt = idx.size();\n            if (cnt == 1) continue;\n            \n            for (int i = 0; i < cnt; i++) {\n                int x = idx[i];\n                int p = idx[(i - 1 + cnt) % cnt];\n                int nxt = idx[(i + 1) % cnt];\n                \n                dst[x] = min(minCircularDist(x, p, n), minCircularDist(x, nxt, n));\n            }\n        }\n        return dst;\n    }\n\n    vector<int> solveQueries(vector<int>& nums, vector<int>& qry) {\n        vector<int> dst = computeNearestDistances(nums);\n        vector<int> res;\n        for (int i : qry) {\n            res.push_back(dst[i]);\n        }\n        return res;\n    }\n};\n","author":"uday0506","submissionId":"1575121640"},[]]},{"646":[{"id":"646","fileName":"1575121678.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size(), m=queries.size();\n        vector<int>l(n, -1), r(n,-1), l1(n, -1), r1(n, -1);\n        unordered_map<int, int>left, right, ll1, rr1;\n        vector<int>ans(m, (int) 1e9);\n        for(int i=0;i<n;i++){\n            if(left.find(nums[i])!=left.end()) l[i]=left[nums[i]];\n            if(ll1.find(nums[i])!=ll1.end()) l1[i]=ll1[nums[i]];\n            left[nums[i]]=i;\n            if(ll1.find(nums[i])==ll1.end()) ll1[nums[i]]=i;\n        }\n        for(int i=n-1;i>=0;i--){\n            if(right.find(nums[i])!=right.end()) r[i]=right[nums[i]];\n            if(rr1.find(nums[i])!=rr1.end())r1[i]=rr1[nums[i]];\n            right[nums[i]]=i;\n              if(rr1.find(nums[i])==rr1.end()) rr1[nums[i]]=i;\n        }\n        for(int i=0;i<m;i++){\n            int q = queries[i];\n            if(l[q]!=-1)ans[i]=min(n-(q-l1[q]), q-l[q]);\n            if(r[q]!=-1) ans[i]=min(ans[i], min(r[q]-q, n-(r1[q]-q)));\n            if(ans[i]==1e9) ans[i]=-1;\n        }\n        \n        return ans;\n    }\n};","author":"yoasobi","submissionId":"1575121678"},[]]},{"647":[{"id":"647","fileName":"1575121487.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        left, right = [-1]*n, [-1]*n\n        seen = {}\n        last = {}\n        first = {}\n        for i, num in enumerate(nums):\n            if num not in first:\n                first[num] = i\n            last[num] = i\n            if num in seen:\n                left[i] = seen[num]\n            seen[num] = i\n        seen = {}\n        for i in range(n-1, -1, -1):\n            num = nums[i]\n            if num in seen:\n                right[i] = seen[num]\n            seen[num] = i\n        for i in range(n):\n            if left[i] == -1 and last[nums[i]] != i:\n                left[i] = last[nums[i]]\n            if right[i] == -1 and first[nums[i]] != i:\n                right[i] = first[nums[i]]\n        ans = []\n        for query in queries:\n            if left[query] == -1 and right[query] == -1:\n                ans.append(-1)\n            else:\n                dist = float('inf')\n                if left[query] != -1:\n                    l, r = min(left[query], query), max(left[query], query)\n                    dist = min(dist, r-l, n-r+l, n-l+r)\n                if right[query] != -1:\n                    l, r = min(right[query], query), max(right[query], query)\n                    dist = min(dist, r-l, n-r+l, n-l+r)\n                ans.append(dist)\n        return ans","author":"Kyle Chiu","submissionId":"1575121487"},[]]},{"648":[{"id":"648","fileName":"1575121687.txt","sourceCode":"class Solution {\npublic:\n    int getIdx(int target, vector<int>& vec) {\n        int start = 0, end = vec.size() - 1, mid, ans;\n        while (start <= end) {\n            mid = start + (end - start) / 2;\n            if (vec[mid] == target)\n                return mid;\n            else if (vec[mid] < target)\n                start = mid + 1;\n            else\n                end = mid - 1;\n        }\n        return -1;\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n\n        int n = nums.size();\n        for (int i = 0; i < n; ++i)\n            mp[nums[i]].push_back(i);\n\n        vector<int> ans;\n        for (int& it : queries) {\n            int ele = nums[it];\n\n            if (mp[ele].size() == 1)\n                ans.push_back(-1);\n            else {\n                int idx = getIdx(it, mp[ele]);\n                \n                int len = mp[ele].size();\n                int min_dis = 1e9;\n                \n                if (idx - 1 >= 0)\n                    min_dis = min(min_dis, it - mp[ele][idx - 1]);\n                else \n                    min_dis = min(min_dis, (n - 1 - mp[ele][len - 1] + it + 1));\n\n                if (idx + 1 < len)\n                    min_dis = min(min_dis, mp[ele][idx + 1] - it);\n                else\n                    min_dis = min(min_dis, n - 1 - it + mp[ele][0] + 1);\n\n                ans.push_back(min_dis);\n            }\n        }\n\n        return ans;\n    }\n};","author":"Mudit Anand","submissionId":"1575121687"},[]]},{"649":[{"id":"649","fileName":"1575121684.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        c = Counter(nums)\n        d = defaultdict(list)\n        n = len(nums)\n        res = []\n        for i in range(n):\n            d[nums[i]].append(i)\n        for q in queries:\n            num = nums[q]\n            if c[num] == 1:\n                res.append(-1)\n            else:\n                idx = bisect_left(d[num], q)\n                idxs = d[num]\n                l = len(idxs)\n                prev = idxs[(idx-1 + l) % l]\n                last = idxs[(idx+1) % l]\n                \n                res.append(min((q-prev+n)%n, (last-q + n) % n ))\n\n        return res\n                \n                \n                \n                \n            \n        ","author":"Eizy","submissionId":"1575121684"},[]]},{"650":[{"id":"650","fileName":"1575121688.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        left = [None] * len(nums)\n        prev = {}\n\n        for i in range(len(nums) * 2):\n            index = i % len(nums)\n            num = nums[index]\n            if num in prev and left[index] is None:\n                left[index] = i  - prev[num]\n            prev[num] = i\n        \n        right = [None] * len(nums)\n        prev.clear()\n        for i in range(len(nums) * 2 - 1, -1, -1):\n            index = i % len(nums)\n            num = nums[i % len(nums)]\n            if num in prev and right[index] is None:\n                right[index] = prev[num] - i \n            prev[num] = i\n\n        result = []\n        for query in queries:\n            if left[query] is None and right[query] is None:\n                result.append(-1)\n            elif left[query] is None:\n                result.append(right[query])\n            elif right[query] is None:\n                result.append(left[query])\n            else:\n                result.append(min(\n                    left[query],\n                    right[query]\n                ))\n\n            if result[-1] == len(nums):\n                result[-1] = -1\n            \n        return result\n","author":"dinhlockt02","submissionId":"1575121688"},[]]},{"651":[{"id":"651","fileName":"1575121710.txt","sourceCode":"class Solution {\n    public int findSmaller(List<Integer> arr, int target) {\n        int l = 0;\n        int r = arr.size()-1;\n        int res = (int)1e9;\n        while(l<=r) {\n            int mid = l + (r-l)/2;\n            int val = arr.get(mid);\n            if(val<target) {\n                res = target-val;\n                l = mid + 1;\n            }\n            else {\n                r = mid - 1;\n            }\n        }\n        return res;\n    }\n    public int findLarger(List<Integer> arr, int target) {\n        int l = 0;\n        int r = arr.size()-1;\n        int res = (int)1e9;\n        while(l<=r) {\n            int mid = l + (r-l)/2;\n            int val = arr.get(mid);\n            if(val > target) {\n                res = val-target;\n                r = mid - 1;\n            }\n            else {\n                l = mid + 1;\n            }\n        }\n        return res;\n    }\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer,List<Integer>> index = new HashMap<>();\n        for(int i=0;i<nums.length;i++) {\n            int num = nums[i];\n            if(!index.containsKey(num)) {\n                index.put(num, new ArrayList<>());\n            }\n            index.get(num).add(i);\n        }\n        List<Integer> res = new ArrayList<>();\n        for(int i=0;i<queries.length;i++) {\n            int num = nums[queries[i]];\n            int queryIndex = queries[i];\n            List<Integer> in = index.get(num);\n            // System.out.println(\"num=\"+num+\" \"+\"queryIndex=\"+queryIndex+\" \"+\"in=\"+in);\n            if(in.size() == 1) {\n                res.add(-1);\n            }\n            else {\n                int smaller = findSmaller(in, queryIndex);\n                int larger = findLarger(in, queryIndex);\n                int first = (queryIndex + 1) + (nums.length-in.get(in.size()-1) - 1);\n                int second = (nums.length - queryIndex) + (in.get(0));\n                int min = Math.min(smaller, Math.min(larger, Math.min(first, second)));\n                res.add(min);\n            }\n        }\n        return res;\n    }\n}","author":"vegitogogeta1234","submissionId":"1575121710"},[]]},{"652":[{"id":"652","fileName":"1575121743.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> pos;\n        int n = nums.size();\n        for (int i = 0; i < n; i++)\n            pos[nums[i]].push_back(i);\n\n        vector<int> ans;\n        for (int q : queries){\n            if (pos[nums[q]].size() == 1)\n                ans.push_back(-1);\n            else {\n                auto it = lower_bound(pos[nums[q]].begin(), pos[nums[q]].end(), q);\n                int pre = (it == pos[nums[q]].begin())? (pos[nums[q]].back()) : *prev(it);\n                int nex = (next(it) == pos[nums[q]].end())? (*pos[nums[q]].begin()) : *next(it);\n                // cout << q << \" \" << pre << \" \" << nex << 'n';\n                int dis_prev = q - pre;\n                if (dis_prev < 0)\n                    dis_prev += n;\n                int dis_next = nex - q;\n                if (dis_next < 0)\n                    dis_next += n;\n                ans.push_back(min(dis_next, dis_prev));\n            }\n        }\n        return ans;\n    }\n};","author":"jerry5841314","submissionId":"1575121743"},[]]},{"653":[{"id":"653","fileName":"1575121780.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.putIfAbsent(nums[i], new ArrayList<>());\n            map.get(nums[i]).add(i);\n        }\n        List<Integer> ans = new ArrayList<>(queries.length);\n        for (int query : queries) {\n            List<Integer> indexes = map.get(nums[query]);\n            if (indexes.size() == 1) {\n                ans.add(-1);\n                continue;\n            }\n            int k = Collections.binarySearch(indexes, query), distance;\n            if (k == 0)\n                distance = Math.min(indexes.get(1) - query, nums.length - indexes.get(indexes.size() - 1) + query);\n            else if (k == indexes.size() - 1)\n                distance = Math.min(query - indexes.get(k - 1), nums.length + indexes.get(0) - query);\n            else\n                distance = Math.min(indexes.get(k + 1) - query, query - indexes.get(k - 1));\n            ans.add(distance);\n        }\n        return ans;\n    }\n}","author":"samzhu333","submissionId":"1575121780"},[]]},{"654":[{"id":"654","fileName":"1575121773.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<int> ret(m, -1);\n        unordered_map<int, vector<int>> nums_mapping;\n        unordered_map<int, int> queries_mapping;\n    \n        for (int i = 0; i < n; ++i) {\n            nums_mapping[nums[i]].push_back(i);\n        }\n\n        for (int i = 0; i < m; ++i) {\n            queries_mapping[queries[i]] = i;\n        }\n\n        for (const auto &[k, v]: nums_mapping) {\n            int c = v.size();\n            for (int i = 0; i < c; ++i) {\n                int left = v[(i - 1 + c) % c];\n                int right = v[(i + 1) % c];\n                int left_distance = min(abs(v[i] - left), n - abs(v[i] - left));\n                int right_distance = min(abs(v[i] - right), n - abs(v[i] - right));\n                int ans = min(left_distance, right_distance);\n                if (queries_mapping.find(v[i]) != queries_mapping.end() && ans != 0) {\n                    ret[queries_mapping.at(v[i])] = ans;\n                }\n            }\n        }\n\n\n        return ret;\n    \n    }\n};","author":"nick698715","submissionId":"1575121773"},[]]},{"655":[{"id":"655","fileName":"1575121860.txt","sourceCode":"class Solution:\n def solveQueries(self,nums:list[int],queries:list[int])->list[int]:\n  my_m=len(nums);my_theo={}\n  for my_garffield,margot in enumerate(nums):\n   my_theo.setdefault(margot,[]).append(my_garffield)\n  my_tulus=[-1]*my_m;my_ham=lambda d:d if d<=my_m-d else my_m-d\n  for anne,lst in my_theo.items():\n   if len(lst)<2:continue\n   k=len(lst)\n   for i in range(k):\n    diff=(lst[(i+1)%k]-lst[i]+my_m)%my_m;cand=my_ham(diff)\n    if my_tulus[lst[i]]==-1 or cand<my_tulus[lst[i]]:\n     my_tulus[lst[i]]=cand\n    nxt=lst[(i+1)%k]\n    if my_tulus[nxt]==-1 or cand<my_tulus[nxt]:\n     my_tulus[nxt]=cand\n  return[my_tulus[q]for q in queries]\n","author":"AKASH SINGH CHOUDHARY","submissionId":"1575121860"},[]]},{"656":[{"id":"656","fileName":"1575121830.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n\n        int n=nums.size();\n        int q=queries.size();\n\n        vector<int>ans(q,0);\n\n        unordered_map<int,vector<int>>mp;\n\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        \n        for(int qu=0;qu<q;qu++){\n\n            int val=nums[queries[qu]];\n\n            if(mp[val].size()==1){\n                ans[qu]=-1;\n            }\n            else{\n                int id=queries[qu];\n                int cur=lower_bound(mp[val].begin(),mp[val].end(),id)-mp[val].begin();\n                int after = cur+1;\n                int before = cur-1;\n                \n                if(after==mp[val].size()){\n                    after=0;\n                }\n                if(before==-1){\n                    before=mp[val].size()-1;\n                }\n\n                ans[qu]=min({\n                    abs(id-mp[val][before]),\n                    abs(mp[val][after]-id),\n                    abs(id+n-mp[val][before]),\n                    abs(n-id+mp[val][after])\n                    });\n                \n            }\n            \n        }\n\n        return ans;\n        \n    }\n};","author":"farmcreepissohard","submissionId":"1575121830"},[]]},{"657":[{"id":"657","fileName":"1575121933.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        auto A = nums;\n        for (auto it : nums) {\n            A.push_back(it);\n        }\n        map<int, int> mp;\n        int n = nums.size();\n        vector<int> idx(n, 1e9);\n        for (int i = 0; i < 2 * n; i++) {\n            int ii = (i < n) ? i : i - n;\n            auto it = mp.find(A[i]);\n            if (it != mp.end()) {\n                int dist = i - it->second;\n                idx[ii] = min(idx[ii], dist);\n                int j = it->second;\n                int jj = (j < n) ? j : j - n;\n                idx[jj] = min(idx[jj], dist);\n            }\n            mp[A[i]] = i;\n        }\n        // for (auto it : idx) {\n        //     cout << it << ' ';\n        // }\n        vector<int> ans;\n        for (int q : queries) {\n            int val = (idx[q] < n) ? idx[q] : -1;\n            ans.push_back(val);\n        }\n        return ans;\n    }\n};","author":"Anonymous","submissionId":"1575121933"},[]]},{"658":[{"id":"658","fileName":"1575122040.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        num_orders = defaultdict(list)\n        num_indices = [-1]*len(nums)\n        for i, num in enumerate(nums):\n            num_indices[i] = len(num_orders[num])\n            num_orders[num].append(i)\n        res = [-1]*len(queries)\n        for i, q in enumerate(queries):\n            order = num_orders[nums[q]]\n            idx = num_indices[q]\n            if len(order)==1:\n                res[i] = -1\n            else:\n                post = order[idx+1]-order[idx] if idx+1!=len(order) else len(nums)-order[idx]+order[0]\n                prev = order[idx]-order[idx-1] if idx!=0  else len(nums)-order[-1]+order[0]\n                # print(prev, post)\n                res[i]=min(post, prev)\n        return res","author":"yahoo010206","submissionId":"1575122040"},[]]},{"279":[{"id":"279","fileName":"1575109724.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(); \n        vector<int> res1(n, -1); \n        vector<int> res2(n, -1);\n        map<int, int> mp1; \n        map<int, int> mp2; \n        for(int i = 0; i < n; i++) {\n            mp1[nums[i]] = i-n; \n        }\n        for(int i = n-1; i >= 0; i--) {\n            mp2[nums[i]] = i+n; \n        }\n        for(int i = 0; i < n; i++) {\n            if(mp1.find(nums[i]) != mp1.end() && i-mp1[nums[i]] != n) res1[i] = i - mp1[nums[i]]; \n            mp1[nums[i]] = i; \n        }\n        for(int i = n-1; i >= 0; i--) {\n            if(mp2.find(nums[i]) != mp2.end() && mp2[nums[i]] - i != n) res2[i] = mp2[nums[i]] - i; \n            mp2[nums[i]] = i; \n        }\n        vector<int>res;\n        for(auto query : queries) {\n            res.push_back(min(res1[query], res2[query])); \n        }\n        return res;\n    }\n};","author":"Konstantinos Fotopoulos","submissionId":"1575109724"},[{"id":"279","similarity":0.705,"totOverlap":141,"longestOverlap":15}]],"659":[{"id":"659","fileName":"1575121948.txt","sourceCode":"class Solution {\n    void cal(vector<int>& nums, map<int,int>& qu, vector<int>& res){\n        map<int,int> lst;\n        int n = nums.size();\n        for(int i=n-1; i>=0; i--){\n            lst[nums[i]] = n+i;\n        }\n\n        for(int i=n-1; i>=0; i--){\n            if(qu.find(i) == qu.end()) {\n                lst[nums[i]] = i;\n                continue;\n            }\n            int len = lst[nums[i]] - i;\n            if(len < n) {\n                if(res[qu[i]] == -1) res[qu[i]] = len;\n                else res[qu[i]] = min(len, res[qu[i]]);\n            }\n            lst[nums[i]] = i;\n        }\n    }\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        \n        map<int,int> qu;\n        int qn = queries.size();\n        for(int i=0; i<qn; i++){\n            qu[queries[i]] = i;\n        }\n\n        vector<int> res(qn, -1);\n\n        cal(nums, qu, res);\n\n        reverse(nums.begin(), nums.end());\n        map<int,int> qu2;\n        for(int i=0; i<qn; i++){\n            qu2[n - 1 - queries[i]] = i;\n        }\n        cal(nums, qu2, res);\n\n        return res;\n    }\n};","author":"Anand Amar","submissionId":"1575121948"},[{"id":"1777","similarity":0.7149321266968326,"totOverlap":158,"longestOverlap":23},{"id":"1777","similarity":0.705,"totOverlap":141,"longestOverlap":15}]],"1777":[{"id":"1777","fileName":"611242652.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, int> umap1;\n        int n1 = nums.size();\n        for (int i = n1 - 1; i >= 0; i--) {\n            umap1[nums[i]] = i + n1;\n        }\n        vector<int> steps(n1, -1);\n        for (int i = n1 - 1; i >= 0; i--) {\n            steps[i] = umap1[nums[i]] - i;\n            steps[i] = steps[i] == n1 ? -1 : steps[i];\n            umap1[nums[i]] = i;\n        }\n        unordered_map<int, int> umap2;\n        for (int i = 0; i < n1; i++) {\n            umap2[nums[i]] = i - n1;\n        }\n        for (int i = 0; i < n1; i++) {\n            steps[i] = min(i - umap2[nums[i]], steps[i]);\n            umap2[nums[i]] = i;\n        }\n        int n2 = queries.size();\n        vector<int> res(n2);\n        for (int i = 0; i < n2; i++) {\n            res[i] = steps[queries[i]];\n        }\n        return res;\n    }\n};","author":"晨","submissionId":"611242652"},[{"id":"659","similarity":0.7149321266968326,"totOverlap":158,"longestOverlap":23}]]},{"661":[{"id":"661","fileName":"1575122086.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        //min distance to closest number with equal value\n        std::unordered_map<int, std::set<int>> common;\n        for(int i = 0; i < nums.size(); i++){\n            auto num = nums[i];\n            common[num].insert(i);\n        }\n\n        std::vector<int> ans;\n\n        auto disto = [len = nums.size()](int a, int b){\n            unsigned long dist = std::abs(a-b);\n            return std::min(dist, len-dist);\n        };\n        for(int i = 0; i < queries.size(); i++){\n            auto q_ind = queries[i];\n            auto q_val = nums[q_ind];\n            \n            if(common[q_val].size() <= 1){\n                ans.push_back(-1);\n                continue;\n            }\n\n            auto iter = common[q_val].find(q_ind);\n            auto itercpy = common[q_val].find(q_ind);\n            int dist = INT_MAX;\n\n            if(iter != common[q_val].begin()){\n                dist = std::min(dist, (int)disto(q_ind, *(common[q_val].begin())));\n            }\n            if(iter != --(common[q_val].end())){\n                dist = std::min(dist, (int)disto(q_ind, *(--common[q_val].end())));\n            }\n\n            // std::cout << i << \" \" << q_ind << std::endl;\n            if(iter != common[q_val].begin()){\n                auto prev = --iter;\n                int early_dist = disto(*prev, q_ind);\n                // std::cout << *prev << \" prev \" << early_dist << std::endl;\n                dist = std::min(dist, early_dist);\n            }\n            \n            auto next = ++itercpy;\n            if(next != common[q_val].end()){\n                int late_dist = disto(*next, q_ind);\n                // std::cout << *next << \" post \" << late_dist << std::endl;\n                dist = std::min(dist, late_dist);\n            }\n\n            \n            \n            ans.push_back(dist);\n        }\n        return ans;\n    }\n};","author":"d11235813","submissionId":"1575122086"},[]]},{"662":[{"id":"662","fileName":"1575122050.txt","sourceCode":"class Solution {\npublic:\n    int findIndInVec(int val, vector<int> &vec) {\n        int low = 0;\n        int high = vec.size() - 1;\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (vec[mid] == val) return mid;\n            else if (vec[mid] < val) low = mid + 1;\n            else high = mid - 1;\n        }\n        return -1;\n    }\n\n    int solve(vector<int> &vec, int currIndInNums, int numSize) {\n        int currIndInVec = findIndInVec(currIndInNums, vec);\n        int ans;\n        if (vec.size() == 1) {\n            ans = -1;\n        }else if (currIndInVec > 0 && currIndInVec < vec.size() - 1) {\n            int leftIndInNums = vec[currIndInVec - 1];\n            int rightIndInNums = vec[currIndInVec + 1];\n            ans = min(currIndInNums - leftIndInNums, rightIndInNums - currIndInNums);\n        } else if (currIndInVec == 0) {\n            int rightIndInNums = vec[currIndInVec + 1];\n            ans = min(currIndInNums + numSize - vec[vec.size() - 1] , rightIndInNums - currIndInNums);\n        } else {\n            int leftIndInNums = vec[currIndInVec - 1];\n            ans = min(currIndInNums - leftIndInNums, numSize - currIndInNums + vec[0]);\n        }\n\n        return ans;\n    }\n\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> ans;\n        unordered_map<int,vector<int>> umap;\n        for (int i = 0; i < nums.size(); i++) {\n            int currNum = nums[i];\n            umap[currNum].push_back(i);\n        }\n        \n        for (int i = 0; i < queries.size(); i++) {\n            int currQuery = queries[i];\n            int currIndInNums = currQuery;\n            int currValInNums = nums[currQuery];\n            int closestDifference = solve(umap[currValInNums], currIndInNums, nums.size());\n            ans.push_back(closestDifference);\n        }\n        return ans;\n    }\n};","author":"feli33","submissionId":"1575122050"},[]]},{"663":[{"id":"663","fileName":"1575122087.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> um;\n        unordered_map<int, int> um1;\n        for (int i = 0; i < nums.size(); i++) {\n            if (um.find(nums[i]) == um.end()) um[nums[i]] = {};\n            um[nums[i]].push_back(i);\n            um1[i] = um[nums[i]].size() - 1;\n        }\n        vector<int> ans;\n        for (int i : queries) {\n            if (um[nums[i]].size() == 1) ans.push_back(-1);\n            else {\n                int temp = nums.size();\n                int pos = um1[i];\n                temp = min(temp, (pos > 0) ? um[nums[i]][pos] - um[nums[i]][pos - 1] : um[nums[i]][pos] + (int)(nums.size()) - um[nums[i]][um[nums[i]].size() - 1]);\n                temp = min(temp, (pos < um[nums[i]].size() - 1) ? um[nums[i]][pos + 1] - um[nums[i]][pos] : um[nums[i]][0] + (int)(nums.size()) - um[nums[i]][pos]);\n                ans.push_back(temp);\n            }\n        }\n        return ans;\n    }\n};","author":"嘉智 陈","submissionId":"1575122087"},[]]},{"664":[{"id":"664","fileName":"1575122096.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& v, vector<int>& q) {\n        int n = v.size();\n        map<int,vector<int>>mp;\n        for(int i=0;i<n;i++){\n            mp[v[i]].push_back(i);\n        }\n        vector<int>ans(q.size());\n        for(int i=0;i<q.size();i++){\n            int num = v[q[i]];\n            if(mp[num].size()==1){\n                ans[i] = -1;\n            }\n            else{\n                int low = 0,high = mp[num].size()-1;\n                while(low<=high){\n                    int mid = (low+high)>>1;\n                    if(mp[num][mid]>=q[i]){\n                        high = mid-1;\n                    }\n                    else{\n                        low = mid+1;\n                    }\n                }\n                if(low == 0){\n                    int mn = abs(mp[num][0]-mp[num][1]);\n                    int mn2 = mp[num][low]+(n-1-mp[num][mp[num].size()-1]);\n                    ans[i] = min(mn,mn2+1);\n                }\n                else if(low == mp[num].size()-1){\n                    int mn = abs(mp[num][mp[num].size()-1]-mp[num][mp[num].size()-2]);\n                    int mn2 = (n-1-mp[num][low])+mp[num][0];\n                    ans[i] = min(mn,mn2+1);\n                }\n                else{\n                    int mn = abs(mp[num][low]-mp[num][low+1]);\n                    int mn2 = abs(mp[num][low]-mp[num][low-1]);\n                    ans[i] = min(mn,mn2);\n                }\n            }\n        }\n        return ans;\n    }\n};","author":"Ankush Gaurav","submissionId":"1575122096"},[]]},{"665":[{"id":"665","fileName":"1575122095.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        for(int i=0;i<n;i++){\n            nums.push_back(nums[i]);\n        }\n        map<int, vector<int>>m;\n        for(int i=0;i<nums.size();i++){\n            m[nums[i]].push_back(i);\n        }\n        vector<int>res(queries.size(), -1);\n        for(int i=0;i<queries.size();i++){\n            int num = nums[queries[i]];\n            auto first = lower_bound(m[num].begin(), m[num].end(), queries[i]);\n            auto second = lower_bound(m[num].begin(), m[num].end(), queries[i]+n);\n            int curmin = INT_MAX;\n            auto& indices = m[num];\n            if (first != indices.begin()) {\n                curmin = min(curmin, abs(*first - *prev(first)));\n            }\n            if (next(first) != indices.end()) {\n                curmin = min(curmin, abs(*first - *next(first)));\n            }\n            if (second != indices.begin()) {\n                curmin = min(curmin, abs(*second - *prev(second)));\n            }\n            if (next(second) != indices.end()) {\n                curmin = min(curmin, abs(*second - *next(second)));\n            }\n\n            if(curmin!=INT_MAX && curmin<n) res[i] = curmin;\n        }\n        return res;\n    }\n};","author":"Jai Khanna","submissionId":"1575122095"},[]]},{"468":[{"id":"468","fileName":"1575116376.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for(int i=0; i<n; i++) mp[nums[i]].push_back(i);\n        \n        for(auto &p : mp) sort(p.second.begin(), p.second.end());\n        \n        vector<int> ans(q.size(), -1);\n        \n        for(int i=0; i<q.size(); i++) {\n            int id = q[i];\n            int val = nums[id];\n            if(mp[val].size() < 2) continue;\n            \n            auto it = lower_bound(mp[val].begin(), mp[val].end(), id);\n            int pos = it - mp[val].begin();\n            int c1 = mp[val][(pos+1) % mp[val].size()];\n            int c2 = mp[val][(pos-1+mp[val].size()) % mp[val].size()];\n            \n            int d1 = min(abs(id-c1), n-abs(id-c1));\n            int d2 = min(abs(id-c2), n-abs(id-c2));\n            \n            ans[i] = min(d1, d2);\n        }\n        return ans;\n    }\n};\n","author":"Ashutosh Kumar","submissionId":"1575116376"},[{"id":"468","similarity":0.7287234042553191,"totOverlap":137,"longestOverlap":10}]],"666":[{"id":"666","fileName":"1575122169.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> map;\n        int n=nums.size();\n        int q=queries.size();\n        \n        for(int i=0;i<n;i++) \n        {\n            map[nums[i]].push_back(i);\n        }\n    \n    \n    vector<int> ans(q, -1);\n    \n    for(int i = 0; i < q; i++) \n    {\n        int idx = queries[i];\n        int value = nums[idx];\n        \n        if (map[value].size() == 1) {\n            // ans[i] = -1;\n            continue;\n        }\n        \n        int pos = lower_bound(map[value].begin(), map[value].end(), idx) -map[value].begin();\n        \n        int leftNeighbor = map[value][(pos - 1 + map[value].size()) % map[value].size()];\n        int rightNeighbor = map[value][(pos + 1) % map[value].size()];\n        \n       \n        int d1 = abs(idx - leftNeighbor);\n        d1 = min(d1, n - d1);\n        int d2 = abs(idx - rightNeighbor);\n        d2 = min(d2, n - d2);\n        \n        ans[i] = min(d1, d2);   \n    }\n\n    return ans;\n    }\n};","author":"BhuvanDaulatDesale","submissionId":"1575122169"},[{"id":"744","similarity":0.7580645161290323,"totOverlap":141,"longestOverlap":16},{"id":"666","similarity":0.7287234042553191,"totOverlap":137,"longestOverlap":10},{"id":"1452","similarity":0.7061855670103093,"totOverlap":137,"longestOverlap":11}]],"744":[{"id":"744","fileName":"1575123809.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>> arr;\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            arr[nums[i]].push_back(i);\n        }\n        int m=queries.size();\n        vector<int> ans;\n        for(int i=0;i<m;i++){\n            int j=queries[i];\n            int ele=nums[j];\n            int l=arr[ele].size();\n            if(l==1){\n                ans.push_back(-1);\n                continue;\n            }\n            int f=lower_bound(arr[ele].begin(),arr[ele].end(),j)-arr[ele].begin();\n            int cur=arr[ele][f];\n            int prev=arr[ele][(f-1+l)%l];\n            int next=arr[ele][(f+1)%l];\n            int mn=min(abs(prev-cur),n-abs(prev-cur));\n            mn=min(mn,abs(next-cur));\n            mn=min(mn,n-abs(next-cur));\n            ans.push_back(mn);\n        }\n        return ans;\n    }\n};","author":"dilpreet singh","submissionId":"1575123809"},[{"id":"666","similarity":0.7580645161290323,"totOverlap":141,"longestOverlap":16}]],"1452":[{"id":"1452","fileName":"611233368.txt","sourceCode":"class Solution {\npublic:\n  vector<int> solveQueries(vector<int> &nums, vector<int> &queries) {\n    unordered_map<int, vector<int>> vc;\n    for (int i = 0; i < nums.size(); ++i)\n      vc[nums[i]].push_back(i);\n    int n = nums.size();\n    vector<int> ans;\n    for (int i : queries) {\n      int res = n + 1;\n      auto v = nums[i];\n      if (vc[v].size() > 1) {\n        int p = lower_bound(vc[v].begin(), vc[v].end(), i) - vc[v].begin();\n        int pp = vc[v][(p + 1) % vc[v].size()];\n        pp = abs(i - pp);\n        pp = min(pp, n - pp);\n        res = min(res, pp);\n\n        pp = vc[v][(p + vc[v].size() - 1) % vc[v].size()];\n        pp = abs(i - pp);\n        pp = min(pp, n - pp);\n        res = min(res, pp);\n      }\n      if (res > n)\n        res = -1;\n      ans.push_back(res);\n    }\n    return ans;\n  }\n};","author":"TangJing","submissionId":"611233368"},[{"id":"666","similarity":0.7061855670103093,"totOverlap":137,"longestOverlap":11}]]},{"667":[{"id":"667","fileName":"1575122118.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>> idx;\n        int n = nums.size();\n        \n        for(int i = 0; i < n; i++){\n            idx[nums[i]].push_back(i);\n        }\n        \n        vector<int> ans;\n        for(int &q:queries){\n            int num = nums[q];\n            if(idx[num].size() == 1){\n                ans.push_back(-1);\n            }\n            else{\n                int t = lower_bound(idx[num].begin(), idx[num].end(), q)-idx[num].begin();\n                int s = idx[num].size();\n                int y1 = idx[num][(t-1+s)%s];\n                int y2 = idx[num][(t+1)%s];\n                \n\n                int d1, d2;\n                if(y1 < q){\n                    d1 = min(q-y1, n-q+y1);\n                }\n                else{\n                    d1 = min(y1-q, n-y1+q);\n                }\n                if(y2 < q){\n                    d2 = min(q-y2, n-q+y2);\n                }\n                else{\n                    d2 = min(y2-q, n-y2+q);\n                }\n                ans.push_back(min(d1,d2));\n            }\n        }\n\n        return ans;\n    }\n};","author":"Ganesh Yadav","submissionId":"1575122118"},[{"id":"906","similarity":0.7569060773480663,"totOverlap":137,"longestOverlap":23}]],"906":[{"id":"906","fileName":"1575128374.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map <int, vector <int>> mp;\n\n        for (int i = 0; i < nums.size(); i++) {\n            mp[nums[i]].push_back(i);\n        }\n\n        // for (auto & it: mp) {\n        //     cout << it.first << endl;\n        //     for (auto& num: it.second)\n        //             cout << num << \" \";\n        //     cout << endl << endl;\n        // }\n\n        vector <int> ans;\n        for (auto& query: queries) {\n            if (mp[nums[query]].size() == 1) {\n                ans.push_back(-1);\n                continue;\n            } \n\n            int num = nums[query];\n\n            int index = distance(mp[num].begin(), lower_bound(mp[num].begin(), mp[num].end(), query));\n            int size = mp[num].size();\n\n            int curr = query;\n            int before = mp[num][(index - 1 + size) % size];\n            int after = mp[num][(index + 1 + size) % size];\n\n            size = nums.size();\n\n            int before_dist = INT_MAX;\n            int after_dist = INT_MAX;\n\n            if (before < curr) {\n                before_dist = min(curr - before, size - curr + before);\n            }\n            else {\n                before_dist = min(before - curr, size - before + curr);\n            }\n\n            if (after < curr) {\n                after_dist = min(curr - after, size - curr + after);\n            }\n            else {\n                after_dist = min(after - curr, size - after + curr);\n            }\n            ans.push_back(min(before_dist, after_dist));\n        }\n\n        return ans;\n    }\n};","author":"Govardhan N","submissionId":"1575128374"},[{"id":"667","similarity":0.7569060773480663,"totOverlap":137,"longestOverlap":23}]]},{"668":[{"id":"668","fileName":"1575122180.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> arr;\n        for(int i = 0; i < 3; i++){\n            for(auto &j : nums) arr.push_back(j);\n        }\n        unordered_map<int, vector<int>> temp;\n        for(int i = 0; i < 3 * n; i++){\n            temp[arr[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(auto &q : queries){\n            auto k = lower_bound(temp[nums[q]].begin(), temp[nums[q]].end(), q + n) - temp[nums[q]].begin();\n            if(k == temp[nums[q]].size()){\n                ans.push_back(-1);\n                continue;\n            }\n            if(temp[nums[q]][k] == q + n){\n                if(temp[nums[q]].size() == 3) ans.push_back(-1);\n                else {\n                    int t = min(q + n - temp[nums[q]][k - 1], temp[nums[q]][k + 1] - q - n);\n                    ans.push_back(t);   \n                }\n            } else {\n                int t = min(temp[nums[q]][k] - q - n, q + n - temp[nums[q]][k - 1]);\n                ans.push_back(t);\n            }\n        }\n        return ans;\n    }\n};","author":"Win_Handsome","submissionId":"1575122180"},[]]},{"669":[{"id":"669","fileName":"1575122117.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] A, int[] Q) {\n        int n = A.length;\n        int [] res = new int [n];\n        Arrays.fill(res, -1);\n        \n        Map<Integer , List<Integer>> map = new HashMap<>();\n        \n        for(int i = 0 ; i < n ; i++){\n            map.computeIfAbsent(A[i],  k -> new ArrayList<>()).add(i);\n        }\n        \n        \n        for(List<Integer> val : map.values()){\n            \n            if(val.size() == 1) continue;\n            \n            int m = val.size();\n            \n            for(int i = 0 ; i < m ; i++){\n                int curr = val.get(i);\n                \n                int prev = (i > 0) ? val.get(i-1) : val.get(m-1);\n                int d1 = (i > 0) ? (curr - prev ) :(curr - prev + n);\n                \n                int next = (i < m-1) ? val.get(i+1) : val.get(0);\n                int d2 = (i < m-1) ? (next -curr  ) :(next + n - curr);\n                \n                res[curr] = Math.min(d1,d2);\n            }\n        }\n        \n        \n        \n       List<Integer> R = new ArrayList<>();\n        \n        for(int i = 0 ; i < Q.length ; i++){\n            R.add(res[Q[i]]);\n        }\n        \n        return R;\n    }\n}","author":"adwicorp","submissionId":"1575122117"},[]]},{"670":[{"id":"670","fileName":"1575122170.txt","sourceCode":"class Solution {\npublic:\n    int binarySearch(vector<int>& arr, int low, int high, int x) {\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (arr[mid] == x)\n                return mid;\n            if (arr[mid] < x)\n                low = mid + 1;\n            else\n                high = mid - 1;\n        }\n        return -1;\n    }\n\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> a;\n        vector<int> ans(queries.size(), -1);\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            a[nums[i]].push_back(i);\n        }\n        for (int i = 0; i < queries.size(); i++) {\n            int queryIndex = queries[i];\n            if (queryIndex < 0 || queryIndex >= n) continue;\n\n            int num = nums[queryIndex];\n            if (a[num].size() < 2) continue;\n            int index = binarySearch(a[num], 0, a[num].size() - 1, queryIndex);\n            if (index == -1) continue;\n            int prevIndex = (index == 0) ? a[num].back() : a[num][index - 1];\n            int nextIndex = (index == a[num].size() - 1) ? a[num].front() : a[num][index + 1];\n            int dist1 = min(abs(queryIndex - prevIndex), n - abs(queryIndex - prevIndex));\n            int dist2 = min(abs(queryIndex - nextIndex), n - abs(queryIndex - nextIndex));\n\n            ans[i] = min(dist1, dist2);\n        }\n\n        return ans;\n    }\n};\n\n","author":"Vaibhav Sen","submissionId":"1575122170"},[]]},{"671":[{"id":"671","fileName":"1575122207.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n\n        def bny(lst, tgt):\n            l=0\n            r=len(lst)\n            while r-l>2:\n                mid = (r+l)//2\n                if lst[mid]>=tgt:\n                    r=mid\n                else:\n                    l=mid+1\n            idx = -1\n            for i in range(max(0,l-1),min(r+1, len(lst))):\n                if lst[i]==tgt:\n                    idx = i\n                    break\n            return idx\n        \n        ctr = Counter(nums)\n        dct = defaultdict(list)\n        nnums = []\n        nnums.extend(nums)\n        nnums.extend(nums)\n        nnums.extend(nums)\n        for ind, num in enumerate(nnums):\n            dct[num].append(ind)\n            \n        res = [-1]*len(queries)\n        for ind,i in enumerate(queries):\n            ret = float('inf')\n            if ctr[nums[i]]!=1:\n                idxs = dct[nums[i]]\n                idx = bny(idxs, i+len(nums))\n                if idx>0:\n                    ret = min(ret, i+len(nums)-idxs[idx-1])\n                ret = min(ret, idxs[idx+1]-i-len(nums))\n                res[ind] = ret\n        return res","author":"Anirudha Soni","submissionId":"1575122207"},[]]},{"673":[{"id":"673","fileName":"1575122262.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> m;\n        for(int i = 0; i < nums.size(); i++)\n        {\n            m[nums[i]].push_back(i);\n        }\n\n        vector<int> ans;\n        for(int cur: queries)\n        {\n            int n = m[nums[cur]].size();\n            if(n==1)\n            {\n                ans.push_back(-1);\n                continue;\n            }\n\n            int idx = lower_bound(m[nums[cur]].begin(), m[nums[cur]].end(), cur) - m[nums[cur]].begin();\n            int s = nums.size();\n            int dis = s;\n            if(idx==n-1)\n                dis = min(dis, m[nums[cur]][0]+s-m[nums[cur]][n-1]);\n            else\n                dis = min(dis, m[nums[cur]][idx+1]-m[nums[cur]][idx]);\n\n            if(idx==0)\n                dis = min(dis, m[nums[cur]][0]+s-m[nums[cur]][n-1]);\n            else\n                dis = min(dis, m[nums[cur]][idx]-m[nums[cur]][idx-1]);\n\n            ans.push_back(dis);\n        }\n        return ans;\n    }\n};","author":"ycyubill","submissionId":"1575122262"},[{"id":"961","similarity":0.7248677248677249,"totOverlap":137,"longestOverlap":11}]],"961":[{"id":"961","fileName":"1575129593.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> mp;\n        int n = nums.size();\n        for(int i = 0; i < n; i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(auto ind: queries){\n            int cnt = mp[nums[ind]].size();\n            if(cnt == 1){\n                ans.push_back(-1);\n            } else {\n                int x = lower_bound(mp[nums[ind]].begin(), mp[nums[ind]].end(),ind) - mp[nums[ind]].begin();\n                int temp = INT_MAX;\n                if(x+1 < cnt){\n                    temp = min(temp, mp[nums[ind]][x+1]-mp[nums[ind]][x]);\n                } else {\n                    temp = min(temp, n - mp[nums[ind]][x] + mp[nums[ind]][0]);\n                }\n                if(x - 1 >= 0){\n                    temp = min(temp, mp[nums[ind]][x] - mp[nums[ind]][x-1]);\n                } else {\n                    temp = min(temp, mp[nums[ind]][x] + n - mp[nums[ind]][cnt-1]);\n                }\n                ans.push_back(temp);\n            }\n        }\n        return ans;\n    }\n};","author":"tarunsingh","submissionId":"1575129593"},[{"id":"673","similarity":0.7248677248677249,"totOverlap":137,"longestOverlap":11}]]},{"674":[{"id":"674","fileName":"1575122263.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& queries) {\n        map< int, set<int> > s;\n        int i, n = a.size();\n        map<int, int> cnt;\n        set<int> ::iterator I,J;\n        for(i=0; i<n; i++)\n        {\n           int  x = a[i];\n            s[x].insert(i);\n            s[x].insert(i+n);\n            s[x].insert(i-n);\n            cnt[x]++;\n        }\n        vector<int> ans;\n        for(int xx : queries)\n        {\n            int x = a[xx];\n            if(cnt[x] == 1)ans.push_back(-1);\n            else {\n                I = s[x].find(xx);\n                J = I;\n                J++;\n                int nx = (*J - *I);\n                J = I;\n                J--;\n                int pr = (*I - *J);\n                ans.push_back(min(nx,pr));\n            }\n        }\n        return ans;\n        \n    }\n};","author":"Satyendra","submissionId":"1575122263"},[]]},{"675":[{"id":"675","fileName":"1575122293.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        m = len(queries)\n        temp = [math.inf] * n\n        dp = collections.defaultdict(list)\n        for i in range(n):\n            val = nums[i]\n            if len(dp[val]) > 0:\n                prev = dp[val][-1]\n                temp[prev] = min(temp[prev], i - prev)\n                temp[i] = i - prev\n            dp[val].append(i)\n        for val, ls in dp.items():\n            if len(ls) > 1:\n                temp[ls[0]] = min(temp[ls[0]], ls[0] + n - ls[-1])\n                temp[ls[-1]] = min(temp[ls[-1]], ls[0] + n - ls[-1])\n        for j in range(m):\n            q = queries[j]\n            queries[j] = temp[q] if temp[q] != math.inf else -1\n        return queries\n        ","author":"Yuxuan Liu","submissionId":"1575122293"},[]]},{"676":[{"id":"676","fileName":"1575122305.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        arr = nums + nums + nums\n        dic = defaultdict(list)\n        for i, v in enumerate(arr):\n            dic[v].append(i)\n        \n        res = []\n        for q in queries:\n            v = nums[q]\n            q += len(nums)\n            # find closest index with value = v\n            lst = dic[v]\n            # print(q, lst)\n            if len(lst) == 3:\n                res.append(-1)\n            else:\n                idx = bisect.bisect_left(lst, q)\n                pre_dist = post_dist = float('inf')\n                if idx > 0:\n                    pre_dist = lst[idx] - lst[idx-1]\n                if idx + 1 < len(lst):\n                    post_dist = lst[idx+1] - lst[idx]\n                res.append(min(pre_dist, post_dist))\n        return res\n    \n    \n    \n    \n    ","author":"Terran21","submissionId":"1575122305"},[]]},{"677":[{"id":"677","fileName":"1575122265.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        const int n = nums.size();\n        const int m = queries.size();\n        vector<int> dis(m);\n        unordered_map<int, vector<int>> val_idx;\n        for (int i = 0; i < n; ++i)\n            val_idx[nums[i]].push_back(i);\n        for (int j = 0; j < m; ++j) {\n            const int idx = queries[j];\n            auto& tmp = val_idx[nums[idx]];\n            if (tmp.size() == 1) {\n                dis[j] = -1;\n                continue;\n            }\n            auto itr = lower_bound(tmp.begin(), tmp.end(), idx);\n            if (itr == tmp.begin())\n                dis[j] = min(tmp[1] - tmp[0], tmp[0] + n - tmp.back());\n            else if (itr == prev(tmp.end()))\n                dis[j] = min(tmp.back() - tmp[tmp.size() - 2], tmp[0] + n - tmp.back());\n            else\n                dis[j] = min(*itr-*prev(itr), *next(itr) - *itr);\n        }\n        return dis;\n    }\n};","author":"HarleyLiu","submissionId":"1575122265"},[]]},{"678":[{"id":"678","fileName":"1575122316.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        arr = nums + nums\n        l_idx, r_idx = {}, {}\n        tmp = [-1] * len(arr)\n\n        for i, num in enumerate(arr):\n            if num in l_idx and i - l_idx[num] < len(nums):\n                tmp[i] = i - l_idx[num]\n            l_idx[num] = i\n        for i in range(len(arr) - 1, -1, -1):\n            if arr[i] in r_idx and r_idx[arr[i]] - i < len(nums):\n                tmp[i] = r_idx[arr[i]] - i if tmp[i] == -1 else min(tmp[i], r_idx[arr[i]] - i)\n            r_idx[arr[i]] = i\n\n        ans = [-1] * len(queries)\n        for idx in range(len(ans)):\n            i = queries[idx]\n            if tmp[i] == -1 and tmp[i + len(nums)] == -1:\n                continue\n            if tmp[i] == -1:\n                ans[idx] = tmp[i + len(nums)]\n                continue\n            if tmp[i + len(nums)] == -1:\n                ans[idx] = tmp[i]\n                continue\n            ans[idx] = min(tmp[i], tmp[i + len(nums)])\n        return ans","author":"TODD YANG","submissionId":"1575122316"},[]]},{"679":[{"id":"679","fileName":"1575122310.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int, set<int>> m;\n        for(int i = 0; i < n; ++i) m[nums[i]].insert(i);\n        for(auto &p: m){\n            //cout << p.first << ' ' << *p.second.begin() << ' ' << *p.second.rbegin() << endl;\n            int l = *p.second.begin(), r = *p.second.rbegin();\n            p.second.insert(l+n); p.second.insert(r-n);\n        }\n        function<int(int, int)> close = [&](int val, int idx){\n            if(m[val].size()==3) return -1;\n            int l = *(--m[val].lower_bound(idx));\n            int r = *m[val].upper_bound(idx);\n            return min(idx-l, r-idx);\n        };\n        vector<int> ans;\n        for(int q : queries){\n            ans.push_back(close(nums[q], q));\n        }\n        return ans;\n    }\n};","author":"Sarthak Jain","submissionId":"1575122310"},[]]},{"680":[{"id":"680","fileName":"1575122434.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        indeces=defaultdict(list)\n        for i, num in enumerate(nums):\n            indeces[num].append(i)\n\n        dist=[-1]*len(nums)\n\n        for val in indeces.values():\n            if len(val)>1:\n                l=len(val)\n                for i in range(len(val)):\n                    dist[val[i]]= min(\n                        abs(val[(i+1)%l]-val[i]),\n                        abs(val[i]-val[(i-1)%l]),\n                        abs(-val[i]+len(nums)+val[(i+1)%l]),\n                        abs(len(nums)+val[i]-val[(i-1)%l])\n                    )\n        # print(indeces)\n        # print(dist)\n        res=[]         \n        for q in queries:\n            res.append(dist[q])\n        return res","author":"peaky-blinder","submissionId":"1575122434"},[]]},{"681":[{"id":"681","fileName":"1575122347.txt","sourceCode":"from bisect import bisect_left\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        N = len(nums)\n        result = []\n        pos_map = {}\n        for idx, num in enumerate(nums):\n            pos_map.setdefault(num, []).append(idx)\n        \n        circ_distance = lambda a, b: min(abs(a - b), N - abs(a - b))\n        for q in queries:\n            value = nums[q]\n            positions = pos_map[value]\n            if len(positions) < 2:\n                result.append(-1)\n                continue\n            pos = bisect.bisect_left(positions, q)\n            next_index = positions[(pos + 1) % len(positions)]\n            prev_index = positions[(pos - 1) % len(positions)]\n            result.append(min(circ_distance(q, prev_index), circ_distance(q, next_index)))\n        return result","author":"Sheik Naveedh N","submissionId":"1575122347"},[]]},{"682":[{"id":"682","fileName":"1575122451.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        \n        unordered_map<int, vector<int>> M;\n        \n        for (int i = 0; i < nums.size(); ++i) {\n            M[nums[i]].push_back(i);\n        }\n        \n        vector<int> res(queries.size(), -1);\n        int k = 0;\n        for (int x : queries) {\n            auto& m = M[nums[x]];\n            \n            int l = 0, r = m.size() - 1;\n            while (l <= r) {\n                int mid = (l + r) / 2;\n                if (m[mid] < x) l = mid + 1;\n                else r = mid - 1;\n            }\n            \n            int a = m[(l - 1 + m.size()) % m.size()];\n            int b = m[(l + 1) % m.size()];\n            \n            int c = min(abs(x - a), min(x, a) + (int)nums.size() - max(x, a));\n            int d = min(abs(x - b), min(x, b) + (int)nums.size() - max(x, b));\n            int e = min(c, d);\n            // cout<< e;\n            res[k] = e;\n            if (res[k] == 0) res[k] = -1;\n            ++k;\n        }\n        \n        return res;\n    }\n};","author":"Jing-You","submissionId":"1575122451"},[]]},{"683":[{"id":"683","fileName":"1575122343.txt","sourceCode":"#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nlong double PI = acos(-1.0);\n#define fastio()ios_base::sync_with_stdio(false);cin.tie(NULL)\n#define pb push_back\n#define ppb pop_back\n#define pf push_front\n#define ppf pop_front\n#define all(x) (x).begin(), (x).end()\n#define ff(i, l, r) for(int i=l;i<r;i++)\n#define ffr(i, l, r) for(int i=l;i>=r;i--)\n#define F first\n#define S second\n#define vii vector<vector<int>>\n#define vi vector<int>\n#define pii pair<int, int>\n#define mem1(a) memset(a, -1, sizeof(a))\n#define mem0(a) memset(a, 0, sizeof(a))\n#define ppc __builtin_popcount\n#define ppcll __builtin_popcountll\n\nclass Solution {\npublic:\n\tint circularDistance(int i, int j, int n) {\n\t\tint diff = abs(i - j);\n\t\treturn min(diff, n - diff);\n\t}\n\n\tvector<int> solveQueries(vector<int>& nums, vector<int>& que) {\n\t\tint n = nums.size();\n\t\tmap<int, vi> pos;\n\n\t\tfor (int i = 0; i < n; i++)pos[nums[i]].pb(i);\n\t\tfor (auto &v : pos)sort(all(v.S));\n\n\n\t\tvi ans;\n\t\tans.reserve(que.size());\n\n\t\tfor (int q : que) {\n\t\t\tauto &vec = pos[nums[q]];\n\n\n\t\t\tif (vec.size() >= 2) {\n\t\t\t\tint idx = lower_bound(all(vec), q) - vec.begin();\n\t\t\t\tint DL = circularDistance(q, vec[(idx - 1 + vec.size()) % vec.size()], n);\n\t\t\t\tint DR = circularDistance(q, vec[(idx + 1) % vec.size()], n);\n\t\t\t\tans.push_back(min(DL, DR));\n\t\t\t} else {\n\t\t\t\tans.push_back(-1);\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\t}\n};","author":"CallMeHaldey","submissionId":"1575122343"},[]]},{"684":[{"id":"684","fileName":"1575122352.txt","sourceCode":"\tclass Solution {\n\t\tpublic List<Integer> solveQueries(int[] nums, int[] queries) {\n\t\t\tint n = nums.length;\n\t\t\tMap<Integer, List<Integer>> b = new HashMap<>();\n\t\t\tList<Integer> ret = new ArrayList<>();\n\n\t\t\tfor(int i = 0;i < nums.length;i++){\n\t\t\t\tint v = nums[i];\n\t\t\t\tif(!b.containsKey(v)){\n\t\t\t\t\tb.put(v, new ArrayList<>());\n\t\t\t\t}\n\t\t\t\tb.get(v).add(i);\n\t\t\t}\n\n\t\t\tfor(int id : queries){\n\t\t\t\tint v = nums[id];\n\t\t\t\tif(b.get(v).size() == 1){\n\t\t\t\t\tret.add(-1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint ind = Collections.binarySearch(b.get(v), id);\n\t\t\t\tint re = Integer.MAX_VALUE;\n\t\t\t\tre = Math.min(re, (b.get(v).get((ind+1) % b.get(v).size()) - id + n) % n);\n\t\t\t\tre = Math.min(re, (id - b.get(v).get((ind+b.get(v).size()-1) % b.get(v).size()) + n) % n);\n\t\t\t\tret.add(re);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n    }\n","author":"uwi","submissionId":"1575122352"},[]]},{"685":[{"id":"685","fileName":"1575122448.txt","sourceCode":"#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, x) for(int i = 0; i < int(x); i++)\n#define all(x) (x).begin(), (x).end()\n\ntemplate<class T> inline bool chmax(T &a, T b){if (a < b) {a = b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T &a, T b){if (a > b) {a = b;return 1;}return 0;}\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        int n = a.size();\n        unordered_map<int, vector<int>> mp;\n        \n        rep(i, n){\n            mp[a[i]].emplace_back(i);    \n        }\n        // nlg n\n        for (auto &x : mp){\n            sort(all(x.second));\n        }\n        \n        vector<int> ret(n, -1);\n        // n\n        for (auto &x : mp) {\n            auto &pos = x.second;\n            if (pos.size() < 2) continue;  \n            int m = pos.size();\n            // m\n            for (int i = 0; i < m; i++) {\n                int next = (i+1)%m;\n                int diff;\n                if (i == m-1) diff = pos[0] + n - pos[i];\n                else diff = pos[i+1] - pos[i];\n                int circDist = min(diff, n - diff);\n                if (ret[pos[i]] == -1)\n                    ret[pos[i]] = circDist;\n                else\n                    ret[pos[i]] = min(ret[pos[i]], circDist);\n                \n                if (ret[pos[next]] == -1)\n                    ret[pos[next]] = circDist;\n                else\n                    ret[pos[next]] = min(ret[pos[next]], circDist);\n            }\n        }\n        // 1\n        vector<int> ans;\n        for (int qi : q) {\n            ans.push_back(ret[qi]);\n        }\n        return ans;\n    }\n};","author":"t38178","submissionId":"1575122448"},[]]},{"686":[{"id":"686","fileName":"1575122519.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int> > num_ind;\n        for (int i = 0; i < nums.size(); i++)\n            num_ind[nums[i]].push_back(i);\n        int n = nums.size();\n\n        unordered_map<int, int> short_distances;\n\n        for (auto &&[k, v]: num_ind) {\n            int n2 = v.size();\n            for (int i = 1; i < n2 - 1; i++)\n                short_distances[v[i]] = min(v[i] - v[i-1], v[i + 1] - v[i]);\n            \n            if (v.size() == 1)\n                short_distances[v[0]] = -1;\n            else {\n                short_distances[v[0]] = min(v[1] - v[0], n + v[0] - v[n2-1]);\n                short_distances[v[n2-1]] = min(v[n2-1] - v[n2-2], n + v[0] - v[n2-1]);\n                // short_distances[v.back()] = min(v.back() - v[v.size() - 2], (int)v.size() + v[0] - v.back());\n            }\n        }\n        \n        vector<int> ans;\n        for (auto &&q: queries)\n            ans.push_back(short_distances[q]);\n            \n        return ans;\n    }\n};","author":"sunilsatyarampatel","submissionId":"1575122519"},[]]},{"687":[{"id":"687","fileName":"1575122485.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n\n        map<int, int> leftIndex;\n        map<int, int> rightIndex;\n\n        vector<int> leftDis(n, -1);\n        vector<int> rightDis(n, -1);\n\n        // Process left distance\n        for (int i = 0; i < n*2 ; i++) {\n            int nowIndex = i % n;\n            int num = nums[nowIndex];\n\n            if (leftIndex.find(num) != leftIndex.end()) {\n                if(i - leftIndex[num] < n){\n                    leftDis[nowIndex] = max(leftDis[nowIndex], i - leftIndex[num]);\n                }\n            }\n            leftIndex[num] = i;\n        }\n        // Process right distance\n        for (int i = 2*n - 1; i >= 0 ; i--) {\n            int nowIndex = i % n;\n            int num = nums[nowIndex];\n\n            if (rightIndex.find(num) != rightIndex.end()) {\n                if(rightIndex[num] - i < n){\n                    rightDis[nowIndex] = max(rightDis[nowIndex], rightIndex[num] - i);\n                }\n            }\n            rightIndex[num] = i;\n        }\n\n        vector<int> ans;\n        for(auto q: queries) {\n            // cout << \"q: \" << q << \"left, right: \" << leftDis[q] << \" \" << rightDis[q] << endl;\n            ans.push_back(min(leftDis[q], rightDis[q]));\n        }\n\n        return ans;\n    }\n};","author":"tsehsuan1102","submissionId":"1575122485"},[]]},{"688":[{"id":"688","fileName":"1575122523.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        mp = collections.defaultdict(list)\n        mp_2 = collections.defaultdict(int)\n        for i, x in enumerate(nums):\n            mp[x].append(i)\n            mp_2[i] = len(mp[x]) - 1\n        \n        n = len(nums)\n        def dis_cir(idx1, idx2):\n            a = min(idx1, idx2)\n            b = max(idx1, idx2)\n            # print(\"orig:\", idx1, idx2)\n            # print(a, b, n - 1 - b + 1, a-0+1)\n            return (n - 1 - b) + (a - 0) + 1\n        \n        def min_dis(idx1, idx2):\n            return min(abs(idx2-idx1), dis_cir(idx1, idx2))\n        # print(mp)\n        # print(mp_2)\n        #  1---a, b ---n\n        \n\n        res = [-1] * len(queries)\n        for i, q in enumerate(queries):\n            x = nums[q]\n            idx = mp_2[q]\n            cur = -1\n            if len(mp[x]) == 1:\n                cur = -1\n            elif len(mp[x]) == 2:\n                # idx = 0 or idx = 1\n                other_idx = mp[x][1 - idx]\n                # print(mp[x]) # [1, 5]\n                # print(q, idx, other_idx)\n                # a = min(q, other_idx)\n                # b = max(q, other_idx)\n                # cir = (n - 1 - b + 1) + (a - 0 + 1)\n                cur = min_dis(q, other_idx)\n            else: #mp>3\n                if idx > 0 and idx < len(mp[x]) - 1:\n                    n1 = mp[x][idx-1]\n                    n2 = mp[x][idx + 1]\n                    cur = min(min_dis(q, n1), min_dis(q,n2))\n                elif idx == 0:\n                    n1 = mp[x][-1]\n                    n2 = mp[x][idx + 1]\n                    cur = min(min_dis(q, n1), min_dis(q, n2))\n                elif idx == len(mp[x]) - 1:\n                    n1 = mp[x][idx-1]\n                    n2 = mp[x][0]\n                    cur = min(min_dis(q, n1), min_dis(q, n2))\n            \n            res[i] = cur\n        return res\n                    ","author":"silencea","submissionId":"1575122523"},[]]},{"689":[{"id":"689","fileName":"1575122525.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        int q=queries.size();\n        map<int,vector<int>> mp;\n        map<int,int> prev,post;\n        for(int i=0;i<n;i++)\n        {\n            prev[nums[i]]=INT_MIN;\n            post[nums[i]]=INT_MAX;\n        }\n        for(int i=0;i<n;i++)\n        {\n            mp[nums[i]].push_back(i);\n            prev[nums[i]]=max(prev[nums[i]],i);\n            post[nums[i]]=min(post[nums[i]],i);\n        }\n        vector<int> ans(q);\n        for(int i=0;i<q;i++)\n        {\n            int ind=queries[i];\n            int st=0,en=mp[nums[ind]].size()-1;\n            int left=-1,right=-1;\n            while(st<=en){\n                int mid=st+(en-st)/2;\n                if(mp[nums[ind]][mid]<ind){\n                    left=mid;\n                    st=mid+1;\n                }\n                else{\n                    en=mid-1;\n                }\n            }\n            st=0;\n            en=mp[nums[ind]].size()-1;\n            while(st<=en){\n                int mid=st+(en-st)/2;\n                if(mp[nums[ind]][mid]>ind){\n                    right=mid;\n                    en=mid-1;\n                }\n                else{\n                    st=mid+1;\n                }\n            }\n            // cout<<left<<\" \"<<right<<\" \";\n            int li=(left==-1)?prev[nums[ind]]-n:mp[nums[ind]][left];\n            int ri=(right==-1)?post[nums[ind]]+n:mp[nums[ind]][right];\n            // cout<<li<<\" \"<<ind<<\" \"<<ri<<\"n\";\n            int d=min(ind-li,ri-ind);\n            if(d>=n)\n                ans[i]=-1;\n            else\n                ans[i]=d;\n        }\n        return ans;\n    }\n};","author":"Harshit Chauhan","submissionId":"1575122525"},[]]},{"690":[{"id":"690","fileName":"1575122574.txt","sourceCode":"class Solution:\n    def solveQueries(self, A: List[int], Q: List[int]) -> List[int]:\n\n        n = len(A)\n        pre = [-1] * n\n        aft = [-1] * n\n\n        B = A + A\n        last = {}\n        for i in range(2 * n):\n            if i >= n and B[i] in last and i - last[B[i]] < n:\n                pre[i - n] = i - last[B[i]]\n            last[B[i]] = i\n        last = {}\n        for i in range(2 * n - 1, -1, -1):\n            if i < n and B[i] in last and last[B[i]] - i < n:\n                aft[i] = last[B[i]] - i\n            last[B[i]] = i\n        #print(pre, aft)\n        return [min(pre[i], aft[i]) for i in Q]","author":"ddveloper","submissionId":"1575122574"},[]]},{"691":[{"id":"691","fileName":"1575122358.txt","sourceCode":"const int N = 1e6+6;\nvector<int> mp[N]; \nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), q = queries.size();\n        for(int i=0; i<n; i++) mp[nums[i]].push_back(i);\n        vector<int> ans;\n        #define all(v) v.begin(), v.end()\n        auto get = [&](int x, int y){\n            int res = abs(x-y);\n            return min(n - res, res);\n        };\n        for(int i : queries){\n            auto &v = mp[nums[i]];\n            if(v.size() == 1){\n                ans.push_back(-1);\n                continue;\n            }\n            \n            auto it = lower_bound(all(v), i);\n            int cur = INT_MAX;\n            \n            auto nxt = next(it);\n            if(nxt == v.end()) nxt = v.begin();\n            cur = min(cur, get(*nxt, i));\n            \n            if(it == v.begin()) it = v.end();\n            \n            auto prv = prev(it);\n            cur = min(get(i, *prv), cur);\n            \n            ans.push_back(cur);\n        }\n        for(int x : nums) mp[x].clear();\n        return ans;\n    }\n};","author":"godoflogix","submissionId":"1575122358"},[]]},{"692":[{"id":"692","fileName":"1575122610.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>> indexes;\n        int n = nums.size();\n        for(int i =0; i < nums.size(); i++){\n            indexes[nums[i]].push_back(i);\n        }\n        unordered_map<int,int> queryToAns;\n        vector<int> ans;\n        for(const auto& pair : indexes){\n            vector<int> cur = pair.second;\n            if(cur.size() == 1){\n                queryToAns[cur[0]] = -1;\n            } else {\n                for(int i = 0; i < cur.size(); i++){\n                    int prevIndex = i-1;\n                    if(i == 0){\n                        prevIndex = cur.size()-1;\n                    }\n                    int nextIndex = i+1;\n                    if(i == cur.size()-1){\n                        nextIndex = 0;\n                    }\n                    int prevDist = min(abs(cur[i]-cur[prevIndex]),n-abs(cur[i]-cur[prevIndex]));\n                    int nextDist = min(abs(cur[i]-cur[nextIndex]),n-abs(cur[i]-cur[nextIndex]));\n                    queryToAns[cur[i]] = min(prevDist,nextDist);\n                }\n            }\n            \n        }\n\n        for(int i : queries){\n            ans.push_back(queryToAns[i]);\n        }\n\n        return ans;\n    }\n};","author":"ALWHleetcode","submissionId":"1575122610"},[]]},{"693":[{"id":"693","fileName":"1575122625.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> ans;\n        vector<int> dist(n, INT_MAX);\n        map<int ,int> mp;\n        map<int,int> cnt;\n        for(int i=0; i<n; i++){\n            if(mp.find(nums[i]) != mp.end()){\n                dist[i] = i-mp[nums[i]];\n                dist[mp[nums[i]]] = min(dist[mp[nums[i]]], dist[i]);\n            }\n            mp[nums[i]] = i;\n            cnt[nums[i]]++;\n        }\n        for(int i=0; i<n; i++){\n            int last = mp[nums[i]];\n            if(last == i){\n                continue;\n            }\n            int d = n-last + i;\n            dist[i] = min(dist[i], d);\n            dist[last] = min(dist[last], d);\n        }\n        for(int i: queries){\n            if(cnt[nums[i]] == 1){\n                ans.push_back(-1);\n                continue;\n            }\n            ans.push_back(dist[i]);\n        }\n        return ans;\n    }\n};","author":"Tikam_Gupta","submissionId":"1575122625"},[]]},{"694":[{"id":"694","fileName":"1575122646.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        // Map each value to all of its indices in the array\n        unordered_map<int, set<int>> valueToIndices;\n        int n = nums.size();\n        \n        // Fill the map with all indices for each value\n        for(int i = 0; i < n; i++) {\n            valueToIndices[nums[i]].insert(i);\n        }\n        \n        vector<int> ans;\n        for(int idx : queries) {\n            int val = nums[idx];\n            \n            // If the value appears only once, no other occurrence exists\n            if(valueToIndices[val].size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            \n            // Find the previous and next occurrences in the circular array\n            int prevDist = INT_MAX;\n            int nextDist = INT_MAX;\n            \n            // Look for previous and next elements in the set\n            auto it = valueToIndices[val].find(idx);\n            \n            // Find previous element\n            if(it != valueToIndices[val].begin()) {\n                auto prevIt = prev(it);\n                prevDist = idx - *prevIt;\n            } else {\n                // If current is the first occurrence, the previous is the last occurrence\n                auto prevIt = prev(valueToIndices[val].end());\n                prevDist = idx + (n - *prevIt); // Distance in circular array\n            }\n            \n            // Find next element\n            auto nextIt = next(it);\n            if(nextIt != valueToIndices[val].end()) {\n                nextDist = *nextIt - idx;\n            } else {\n                // If current is the last occurrence, the next is the first occurrence\n                auto nextIt = valueToIndices[val].begin();\n                nextDist = (n - idx) + *nextIt; // Distance in circular array\n            }\n            \n            // Return the minimum distance between prev and next\n            ans.push_back(min(prevDist, nextDist));\n        }\n        \n        return ans;\n    }\n};","author":"Arya Mukhopadhyay","submissionId":"1575122646"},[]]},{"695":[{"id":"695","fileName":"1575122696.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n\n        mp = defaultdict(list)\n        res = []\n        \n        for i in range(len(nums)):\n            mp[nums[i]].append(i)\n\n        for q in queries:\n            x = nums[q]\n            if len(mp[x])==1:\n                res.append(-1)\n            else:\n                l = 0\n                r = len(mp[x])-1\n                index = 0\n                while(l<=r):\n                    mid = (l+r)//2\n                    if mp[x][mid]==q:\n                        index = mid\n                        break\n                    elif mp[x][mid]>q:\n                        r = mid-1\n                    else:\n                        l = mid+1\n                mind = len(nums)\n                \n                \n                l = mp[x][(index-1)%len(mp[x])]\n                r = mp[x][(index+1)%len(mp[x])]\n                index = mp[x][index]\n                if index>l:\n                    mind = min(mind,index-l)\n                else:\n                    mind = min(mind,index+len(nums)-l)\n                \n                if r>index:\n                    mind = min(mind,r-index)\n                else:\n                    mind = min(mind,len(nums)+r-index)\n                res.append(mind)\n        return res","author":"user3996te","submissionId":"1575122696"},[]]},{"696":[{"id":"696","fileName":"1575122647.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        map<int,vector<int>>mp;\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]].push_back(i);\n        };\n        vector<int>aa;\n        for(int i=0;i<q.size();i++){\n            int num=nums[q[i]];\n            int a1=-1;\n            if(mp[num][0]!=q[i]){\n                a1=nums.size()-q[i]+mp[num][0];\n            }\n            int a4=-1;\n            if(mp[num][mp[num].size()-1]!=q[i]){\n                a1=nums.size()-mp[num][mp[num].size()-1]+q[i];\n            }\n            int a2=-1;\n            int a3=-1;\n            int ni=lower_bound(mp[num].begin(),mp[num].end(),q[i])-mp[num].begin();\n            if(ni+1<mp[num].size())\n                a2=mp[num][ni+1]-q[i];\n            if(ni-1>=0)\n                a3=q[i]-mp[num][ni-1];\n            int ans=INT_MAX;\n            if(a1!=-1)\n                ans=min(ans,a1);\n            if(a2!=-1)\n                ans=min(ans,a2);\n            if(a3!=-1)\n                ans=min(ans,a3);\n            if(a4!=-1)\n                ans=min(ans,a4);\n            aa.push_back(ans==INT_MAX?-1:ans);\n        }\n        return aa;\n    }\n};","author":"Prashant Singh","submissionId":"1575122647"},[]]},{"697":[{"id":"697","fileName":"1575122669.txt","sourceCode":"use std::collections::HashMap;\nuse std::usize;\n\nimpl Solution {\n    pub fn solve_queries(nums: Vec<i32>, queries: Vec<i32>) -> Vec<i32> {\n        let mut map: HashMap<i32, Vec<usize>> = HashMap::new();\n        let n = nums.len();\n        for i in 0..n {\n            if map.contains_key(&nums[i]) {\n                map.get_mut(&nums[i]).unwrap().push(i);\n            } else {\n                map.insert(nums[i], vec![i]);\n            }\n        }\n        let mut ans = vec![];\n\n        for query in queries {\n            let query = query as usize;\n            let num = nums[query];\n            let positions = map.get(&num).unwrap();\n            if positions.len() == 1 {\n                ans.push(-1);\n            } else {\n                let len_position = positions.len();\n                let mut i = 0;\n                let mut left = 0;\n                let mut right = len_position - 1;\n\n                while left <= right {\n                    let mid = (left + right) / 2;\n                    if positions[mid] == query {\n                        i = mid;\n                        break;\n                    } else if positions[mid] > query {\n                        right = mid - 1;\n                    } else {\n                        left = mid + 1;\n                    }\n                }\n                if positions[i] == query {\n                    let mut dis = usize::MAX;\n                    if i > 0 {\n                        dis = dis.min(positions[i] - positions[i - 1]);\n                    } else {\n                        dis = dis.min(n - (positions[len_position - 1] - positions[i]));\n                    }\n\n                    if i < (len_position - 1) {\n                        dis = dis.min(positions[i + 1] - positions[i]);\n                    } else {\n                        dis = dis.min(n - (positions[i] - positions[0]));\n                    }\n                    ans.push(dis as i32);\n                }\n            }\n        }\n\n\n        ans\n    }\n}\n","author":"OneMore14","submissionId":"1575122669"},[]]},{"698":[{"id":"698","fileName":"1575122697.txt","sourceCode":"from bisect import bisect_left\nfrom collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        value_indices = defaultdict(list)\n        for idx, num in enumerate(nums):\n            value_indices[num].append(idx)\n        \n        result = []\n        for q in queries:\n            val = nums[q]\n            indices = value_indices[val]\n            if len(indices) == 1:\n                result.append(-1)\n                continue\n            i = bisect_left(indices, q)\n            m = len(indices)\n            prev_i = (i - 1) % m\n            next_i = (i + 1) % m\n            prev_dist = min(abs(q - indices[prev_i]), n - abs(q - indices[prev_i]))\n            next_dist = min(abs(q - indices[next_i]), n - abs(q - indices[next_i]))\n            result.append(min(prev_dist, next_dist))\n        return result","author":"RaasithS","submissionId":"1575122697"},[]]},{"699":[{"id":"699","fileName":"1575122703.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        m = defaultdict(list)\n\n        for i, n in enumerate(nums):\n            m[n].append(i)\n\n        #print(m)\n        \n        ans = []\n        for i in queries:\n            arr = m[nums[i]]\n            if nums[i] not in m or len(arr) == 1:\n                ans.append(-1)\n            else:\n                idx_right = bisect_right(arr, i)\n                if idx_right == len(arr):\n                    idx_right = 0\n\n                idx_left = bisect_left(arr, i) - 1\n                if idx_left == -1:\n                    idx_left = len(arr) - 1\n                    \n                ans.append(min((arr[idx_right]-i+len(nums))%len(nums), (i-arr[idx_left]+len(nums))%len(nums)))\n\n        return ans","author":"serein","submissionId":"1575122703"},[]]},{"700":[{"id":"700","fileName":"1575122743.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        index_last_same_left = dict()\n        num_last_index = dict()\n        for i, num in enumerate(nums):\n            if num in num_last_index:\n                index_last_same_left[i] = num_last_index[num]\n            num_last_index[num] = i\n\n        # again, cause circular array\n        for i, num in enumerate(nums):\n            if i not in index_last_same_left and num in num_last_index and num_last_index[num] != i:\n                index_last_same_left[i] = num_last_index[num]\n\n        index_last_same_right = dict()\n        num_last_index = dict()\n        for i in range(len(nums))[::-1]:\n            num = nums[i]\n            if num in num_last_index:\n                index_last_same_right[i] = num_last_index[num]\n            num_last_index[num] = i\n\n        # again, cause circular array\n        for i in range(len(nums))[::-1]:\n            num = nums[i]\n            if i not in index_last_same_right and num in num_last_index and num_last_index[num] != i:\n                index_last_same_right[i] = num_last_index[num]\n\n        ans = []\n        n = len(nums)\n        for query in queries:\n            if query not in index_last_same_left:\n                ans.append(-1)\n            else:\n                a, b = index_last_same_left[query], index_last_same_right[query]\n                if a > query:\n                    dis_a = min(a - query, n - (a - query))\n                else:\n                    dis_a = min(query - a, n - (query - a))\n\n                if b > query:\n                    dis_b = min(b - query, n - (b - query))\n                else:\n                    dis_b = min(query - b, n - (query - b))\n\n                ans.append(min(dis_a, dis_b))\n\n        return ans","author":"quizliu","submissionId":"1575122743"},[]]},{"701":[{"id":"701","fileName":"1575122704.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> prev(n, -1), nxt(n, -1);\n        \n        unordered_map<int, int> lastOccurrence;\n        for (int i = 0; i < n; i++) {\n            int val = nums[i];\n            if (lastOccurrence.find(val) != lastOccurrence.end())\n                prev[i] = lastOccurrence[val];\n            lastOccurrence[val] = i;\n        }\n        \n        unordered_map<int, int> firstOccurrence;\n        for (int i = n - 1; i >= 0; i--) {\n            int val = nums[i];\n            if (firstOccurrence.find(val) != firstOccurrence.end())\n                nxt[i] = firstOccurrence[val];\n            firstOccurrence[val] = i;\n        }\n        \n        unordered_map<int, int> firstOcc, lastOcc;\n        for (int i = 0; i < n; i++) {\n            int val = nums[i];\n            if (firstOcc.find(val) == firstOcc.end())\n                firstOcc[val] = i;\n            lastOcc[val] = i;\n        }\n        \n        vector<int> ans;\n        for (int q : queries) {\n            int val = nums[q];\n            int best = INT_MAX;\n            if (prev[q] != -1) {\n                int d = abs(q - prev[q]);\n                d = min(d, n - d);  \n                best = min(best, d);\n            }\n            if (nxt[q] != -1) {\n                int d = abs(nxt[q] - q);\n                d = min(d, n - d);  \n                best = min(best, d);\n            }\n            if (firstOcc[val] != q) {\n                int d = abs(q - firstOcc[val]);\n                d = min(d, n - d);\n                best = min(best, d);\n            }\n            if (lastOcc[val] != q) {\n                int d = abs(q - lastOcc[val]);\n                d = min(d, n - d);\n                best = min(best, d);\n            }\n            ans.push_back(best == INT_MAX ? -1 : best);\n        }\n        return ans;\n    }\n};\n","author":"Tanmay Paul","submissionId":"1575122704"},[]]},{"702":[{"id":"702","fileName":"1575122761.txt","sourceCode":"# https://github.com/tatyam-prime/SortedSet/blob/main/SortedSet.py\nimport math\nfrom bisect import bisect_left, bisect_right\nfrom typing import Generic, Iterable, Iterator, TypeVar, Union, List\nT = TypeVar('T')\n\nclass SortedSet(Generic[T]):\n    BUCKET_RATIO = 16\n    REBUILD_RATIO = 24\n\n    def _build(self, a=None) -> None:\n        \"Evenly divide `a` into buckets.\"\n        if a is None: a = list(self)\n        size = self.size = len(a)\n        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))\n        self.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]\n    \n    def __init__(self, a: Iterable[T] = []) -> None:\n        \"Make a new SortedSet from iterable. / O(N) if sorted and unique / O(N log N)\"\n        a = list(a)\n        if not all(a[i] < a[i + 1] for i in range(len(a) - 1)):\n            a = sorted(set(a))\n        self._build(a)\n\n    def __iter__(self) -> Iterator[T]:\n        for i in self.a:\n            for j in i: yield j\n\n    def __reversed__(self) -> Iterator[T]:\n        for i in reversed(self.a):\n            for j in reversed(i): yield j\n    \n    def __len__(self) -> int:\n        return self.size\n    \n    def __repr__(self) -> str:\n        return \"SortedSet\" + str(self.a)\n    \n    def __str__(self) -> str:\n        s = str(list(self))\n        return \"{\" + s[1 : len(s) - 1] + \"}\"\n\n    def _find_bucket(self, x: T) -> List[T]:\n        \"Find the bucket which should contain x. self must not be empty.\"\n        for a in self.a:\n            if x <= a[-1]: return a\n        return a\n\n    def __contains__(self, x: T) -> bool:\n        if self.size == 0: return False\n        a = self._find_bucket(x)\n        i = bisect_left(a, x)\n        return i != len(a) and a[i] == x\n\n    def add(self, x: T) -> bool:\n        \"Add an element and return True if added. / O(√N)\"\n        if self.size == 0:\n            self.a = [[x]]\n            self.size = 1\n            return True\n        a = self._find_bucket(x)\n        i = bisect_left(a, x)\n        if i != len(a) and a[i] == x: return False\n        a.insert(i, x)\n        self.size += 1\n        if len(a) > len(self.a) * self.REBUILD_RATIO:\n            self._build()\n        return True\n\n    def discard(self, x: T) -> bool:\n        \"Remove an element and return True if removed. / O(√N)\"\n        if self.size == 0: return False\n        a = self._find_bucket(x)\n        i = bisect_left(a, x)\n        if i == len(a) or a[i] != x: return False\n        a.pop(i)\n        self.size -= 1\n        if len(a) == 0: self._build()\n        return True\n    \n    def lt(self, x: T) -> Union[T, None]:\n        \"Find the largest element < x, or None if it doesn't exist.\"\n        for a in reversed(self.a):\n            if a[0] < x:\n                return a[bisect_left(a, x) - 1]\n\n    def le(self, x: T) -> Union[T, None]:\n        \"Find the largest element <= x, or None if it doesn't exist.\"\n        for a in reversed(self.a):\n            if a[0] <= x:\n                return a[bisect_right(a, x) - 1]\n\n    def gt(self, x: T) -> Union[T, None]:\n        \"Find the smallest element > x, or None if it doesn't exist.\"\n        for a in self.a:\n            if a[-1] > x:\n                return a[bisect_right(a, x)]\n\n    def ge(self, x: T) -> Union[T, None]:\n        \"Find the smallest element >= x, or None if it doesn't exist.\"\n        for a in self.a:\n            if a[-1] >= x:\n                return a[bisect_left(a, x)]\n    \n    def __getitem__(self, x: int) -> T:\n        \"Return the x-th element, or IndexError if it doesn't exist.\"\n        if x < 0: x += self.size\n        if x < 0: raise IndexError\n        for a in self.a:\n            if x < len(a): return a[x]\n            x -= len(a)\n        raise IndexError\n    \n    def index(self, x: T) -> int:\n        \"Count the number of elements < x.\"\n        ans = 0\n        for a in self.a:\n            if a[-1] >= x:\n                return ans + bisect_left(a, x)\n            ans += len(a)\n        return ans\n\n    def index_right(self, x: T) -> int:\n        \"Count the number of elements <= x.\"\n        ans = 0\n        for a in self.a:\n            if a[-1] > x:\n                return ans + bisect_right(a, x)\n            ans += len(a)\n        return ans\nfrom typing import List\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        #d = [SortedSet() for _ in range(10**6)]\n        d = dict()\n        for i in range(n):\n            v = nums[i]\n            v-=1\n            nums[i] = v\n            if v not in d:\n                d[v] = SortedSet()\n            d[v].add(i)\n        ans = []\n        for q in queries:\n            v = nums[q]\n            l = d[v].lt(q)\n            r = d[v].gt(q)\n            if l is None and r is None:\n                ans.append(-1)\n            elif l is None:\n                tmp = r-q\n                l = d[v][-1]\n                if l!=q:\n                    tmp2 = l-q\n                    ans.append(min(tmp, tmp2, n-tmp, n-tmp2))\n                else:\n                    ans.append(min(tmp, n-tmp))\n            elif r is None:\n                tmp = q-l\n                r = d[v][0]\n                if r!=q:\n                    tmp2 = q-r\n                    ans.append(min(tmp, tmp2, n-tmp, n-tmp2))\n                else:\n                    ans.append(min(tmp, n-tmp))\n            else:\n                tmp = r-q\n                tmp2 = q-l\n                ans.append(min(tmp, tmp2, n-tmp, n-tmp2))\n        return ans\n","author":"miya145592","submissionId":"1575122761"},[]]},{"704":[{"id":"704","fileName":"1575122850.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n\n        Map<Integer, List<Integer>> hmap = new HashMap<>();\n        int len = nums.length;\n        for (int i = 0; i < len; i++) {\n            if (hmap.containsKey(nums[i])) {\n                List<Integer> l = hmap.get(nums[i]);\n                l.add(i);\n                hmap.put(nums[i], l);\n            } else {\n                List<Integer> l = new ArrayList<>();\n                l.add(i);\n                hmap.put(nums[i], l);\n            }\n        }\n\n        List<Integer> res = new ArrayList<>();\n        for (int i = 0; i < queries.length; i++) {\n            int tar = nums[queries[i]];\n            res.add(helper(hmap, nums, queries[i]));\n        }\n        return res;\n    }\n\n    public int helper(Map<Integer, List<Integer>> hmap, int[] nums, int pos) {\n        int tar = nums[pos];\n        int len = nums.length;\n        List<Integer> cur = hmap.get(tar);\n        if (cur.size() <= 1) {\n            return -1;\n        } else if (cur.size() == 2) {\n            return Math.min(cur.get(1) - cur.get(0), len - (cur.get(1) - cur.get(0)));\n        } else {\n            int size = cur.size();\n            if (pos == cur.get(0)){\n                return Math.min(cur.get(1) - cur.get(0), len - (cur.get(size - 1) - cur.get(0)));\n            } else if (pos == cur.get(cur.size() - 1)) {\n                return Math.min(cur.get(size - 1) - cur.get(size - 2), len - (cur.get(size - 1) - cur.get(0)));\n            } else {\n                int left = 0, right = size - 1;\n                while (left <= right) {\n                    int mid = left + (right - left) / 2;\n                    if (cur.get(mid) == pos) {\n                        left = mid;\n                        break;\n                    } else if (cur.get(mid) > pos) {\n                        right = mid - 1;\n                    } else {\n                        left = mid + 1;\n                    }\n                }\n\n                return Math.min(cur.get(left + 1) - cur.get(left), cur.get(left) - cur.get(left - 1));\n            }\n        }\n    }\n}","author":"litang","submissionId":"1575122850"},[]]},{"706":[{"id":"706","fileName":"1575122714.txt","sourceCode":"class Solution {\nprivate:\n    int binSearch(vector<int> &v, int num) {\n        int low = 1, high = v.size() - 2;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (v[mid] == num) return mid;\n            else if (v[mid] < num) low = mid + 1;\n            else high = mid - 1;\n        }\n        return -1;\n    }\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int, vector<int>> mpp;\n        for (int i = 0; i < n; i++) {\n            mpp[nums[i]].push_back(i);\n        }\n        for (auto &p : mpp) {\n            vector<int> &v = p.second;\n            v.insert(v.begin(), v.back() - n);\n            v.push_back(v[1] + n);\n        }\n        vector<int> res;\n        for (auto q : queries) {\n            int num = nums[q];\n            vector<int> &v = mpp[num];\n            int idx = binSearch(v, q);\n            int ans = min(v[idx] - v[idx - 1], v[idx + 1] - v[idx]);\n            ans == n ? res.push_back(-1) : res.push_back(ans);\n        }\n        return res;\n    }\n};","author":"Devansh Vyas","submissionId":"1575122714"},[]]},{"707":[{"id":"707","fileName":"1575122986.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        size = len(nums)\n        output = [-1] * size  \n        index_map = defaultdict(list) \n\n        for idx, val in enumerate(nums):\n            index_map[val].append(idx)\n\n        for val, indices in index_map.items():\n            if len(indices) < 2:\n                continue  \n\n            total = len(indices)\n            for i, current in enumerate(indices):\n                previous = indices[i - 1]  \n                next_idx = indices[(i + 1) % total]\n\n                dist1 = min(abs(current - previous), size - abs(current - previous))\n                dist2 = min(abs(next_idx - current), size - abs(next_idx - current))\n\n                output[current] = min(dist1, dist2)\n\n        return [output[q] for q in queries]","author":"Mathivanan_S","submissionId":"1575122986"},[]]},{"708":[{"id":"708","fileName":"1575122945.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> indices;\n        int n = nums.size();\n        for(int i = 0; i < nums.size(); i++){\n            indices[nums[i]].push_back(i);\n        }\n        vector<int> res;\n        for(int q: queries){\n            if(indices[nums[q]].size() == 1){\n                res.push_back(-1);\n                continue;\n            }\n            int ind = lower_bound(indices[nums[q]].begin(), indices[nums[q]].end(), q) - indices[nums[q]].begin();\n            if(ind == 0){\n                res.push_back(min(n-indices[nums[q]].back()+q, indices[nums[q]][ind+1]-q));\n            }\n            else if(ind == indices[nums[q]].size()-1){\n                res.push_back(min(n-q+indices[nums[q]][0], -indices[nums[q]][ind-1]+q));\n            }\n            else{\n                res.push_back(min(-indices[nums[q]][ind-1]+q, indices[nums[q]][ind+1]-q));\n            }\n        }\n        return res;\n    }\n};","author":"Shikha Verma","submissionId":"1575122945"},[]]},{"710":[{"id":"710","fileName":"1575123077.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        hmap = defaultdict(list)\n        n = len(nums)\n        for i, num in enumerate(nums):\n            hmap[num].append(i)\n        arr = [-1] * n\n        for key, li in hmap.items():\n            if len(li) <= 1:\n                continue\n            arr[li[0]] = min(li[1] - li[0], n - li[-1] + li[0])\n            arr[li[-1]] = min(li[-1] - li[-2], n - li[-1] + li[0])\n            for i in range(1, len(li) - 1):\n                arr[li[i]] = min(li[i] - li[i - 1], li[i + 1] - li[i])\n        return [arr[q] for q in queries]","author":"bogdansharpy","submissionId":"1575123077"},[{"id":"1733","similarity":0.8,"totOverlap":120,"longestOverlap":56},{"id":"1478","similarity":0.8013698630136986,"totOverlap":117,"longestOverlap":23}]],"1478":[{"id":"1478","fileName":"611234418.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        vi = defaultdict(list)\n        for i,n in enumerate(nums):\n            vi[n].append(i)\n        d = len(nums)\n        tmp = [-1]*d\n        for v,ii in vi.items():\n            if len(ii) > 1:\n                tmp[ii[0]] = min(ii[1] - ii[0], ii[0]+d-ii[-1])\n                tmp[ii[-1]] = min(ii[-1] - ii[-2], ii[0]+d-ii[-1])\n                for j in range(1, len(ii)-1):\n                    tmp[ii[j]] = min(ii[j] - ii[j-1], ii[j+1] - ii[j])\n        return [tmp[i] for i in queries]","author":"孔雀千人","submissionId":"611234418"},[{"id":"710","similarity":0.8013698630136986,"totOverlap":117,"longestOverlap":23}]],"1733":[{"id":"1733","fileName":"611241515.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        cnt = defaultdict(list)\n        for i, x in enumerate(nums):\n            cnt[x].append(i)\n        rec = [-1]*n\n        for k, v in cnt.items():\n            if len(v)>1:\n                rec[v[0]] = min(v[1]-v[0], n-v[-1]+v[0])\n                rec[v[-1]] = min(v[-1]-v[-2], n-v[-1]+v[0])\n                for i in range(1, len(v)-1):\n                    x, y1, y2 = v[i], v[i-1], v[i+1]\n                    rec[x] = min(x-y1, y2-x)\n        m = len(queries)\n        ans = [-1]*m\n        for i, q in enumerate(queries):\n            ans[i] = rec[q]\n        return ans","author":"ANG_GAO","submissionId":"611241515"},[{"id":"710","similarity":0.8,"totOverlap":120,"longestOverlap":56}]]},{"711":[{"id":"711","fileName":"1575123105.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = defaultdict(list)\n        c = Counter(nums)\n        l = len(nums)\n        visited = set()\n        for i, v in enumerate(nums):\n            d[v].append(i)\n        for i, v in enumerate(nums[::-1]):\n            if c[v]==1: continue\n            if v in visited : continue\n            d[v] = [ -i-1 ] + d[v]\n            visited.add(v)\n        visited= set()\n        for i, v in enumerate(nums):\n            if c[v]==1: continue\n            if v in visited : continue\n            d[v] = d[v] + [i + l] \n            visited.add(v)\n        #print(d)\n        ans = []\n        for i in  queries:\n            if c[nums[i]]==1:\n                ans.append(-1)\n                continue\n            idx = bisect_left( d[nums[i]], i )\n            tmp = inf\n            if idx>0:\n                tmp = min(tmp, abs(d[nums[i]][idx]-d[nums[i]][idx-1]))\n            if idx<len(d[nums[i]])-1:\n                tmp = min(tmp, abs(d[nums[i]][idx]-d[nums[i]][idx+1]))\n            ans.append(tmp)\n        return ans\n        ","author":"kenchen","submissionId":"1575123105"},[]]},{"712":[{"id":"712","fileName":"1575123167.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& arr, vector<int>& queries) {\n        vector<int> nums = arr;\n        for(int a:arr) nums.push_back(a);\n        \n        map<int,int> mp;\n        int n = nums.size();\n\n        vector<int> ans(n,0);\n\n        for(int i = 0; i<n; i++){\n            if(mp.find(nums[i])==mp.end()){\n                mp[nums[i]] = i+1;\n                ans[i%(n/2)] = n+1;\n            }\n            else{\n                ans[i%(n/2)] = i + 1 - mp[nums[i]];\n                mp[nums[i]] = i+1;\n            }\n        }\n\n        map<int,int> m;\n        for(int i = n-1; i>=0; i--){\n             if(m.find(nums[i])==m.end()){\n                m[nums[i]] = i+1;\n            }\n            else{\n                ans[i%n] = min(ans[i], m[nums[i]] - i - 1 );\n                m[nums[i]] = i+1;\n            }\n        }\n\n        int q = queries.size();\n        vector<int> main(q,0);\n\n        for(int i = 0; i<q; i++){\n            if(ans[queries[i]]>=n/2){\n                main[i] = -1;\n            }\n            else main[i] = ans[queries[i]];\n        }\n\n        return main;\n\n        \n    }\n};","author":"Siddhesh Pandey","submissionId":"1575123167"},[]]},{"713":[{"id":"713","fileName":"1575122960.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        \n        idx = defaultdict(list)\n        \n        for i, x in enumerate(nums):\n            idx[x].append(i)\n        \n        ret = []\n        \n        n = len(nums)\n        \n        for iq in queries:\n            xq = nums[iq]\n            if len(idx[xq]) < 2:\n                ret.append(-1)\n            else:\n                a = idx[xq]\n                j = bisect_left(a, iq) \n                r = a[(j + 1) % len(a)]\n                l = a[(j - 1 + len(a)) % len(a)]                \n                dr = min(abs(iq - r), n - abs(iq - r))\n                dl = min(abs(iq - l), n - abs(iq - l))\n                # print(iq, l, r, dl, dr)\n                ret.append(min(dl, dr))\n        \n        return ret\n","author":"Only My Railgun","submissionId":"1575122960"},[]]},{"714":[{"id":"714","fileName":"1575123115.txt","sourceCode":"def check(l,t):\n    i=0\n    j=len(l)-1\n    while(i<=j):\n        mid=(i+j)//2\n        if(l[mid]==t):\n            return mid\n        if(l[mid]>t):\n            j=mid-1\n        else:\n            i=mid+1\n    return -1\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d=defaultdict(list)\n        for i in range(len(nums)):\n            d[nums[i]].append(i)\n        ans=[]\n        for i in queries:\n            if(len(d[nums[i]])==1):\n                ans.append(-1)\n            else:\n                ind=check(d[nums[i]],i)\n                dist=len(nums)\n                if(ind>0):\n                    dist=d[nums[i]][ind]-d[nums[i]][ind-1]\n                else:\n                    dist=len(nums)-d[nums[i]][-1]+d[nums[i]][0]\n                if(ind+1<len(d[nums[i]])):\n                    dist=min(dist,d[nums[i]][ind+1]-d[nums[i]][ind])\n                else:\n                    dist=min(dist,len(nums)-d[nums[i]][-1]+d[nums[i]][0])\n                ans.append(dist)\n        return ans","author":"Yash Jaiswal","submissionId":"1575123115"},[]]},{"214":[{"id":"214","fileName":"1575106092.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, ArrayList<Integer>> map = new HashMap<>();\n        for(int i = 0; i < nums.length; i++) {\n            if(!map.containsKey(nums[i])) {\n                map.put(nums[i], new ArrayList<>());\n            }\n            map.get(nums[i]).add(i);\n        }\n        int n = nums.length;\n        int[] qwe = new int[n];\n        for(ArrayList<Integer> a : map.values()) {\n            int m = a.size();\n            if(m == 1) {\n                qwe[a.get(0)] = -1;\n                continue;\n            }\n            for(int i = 0; i < m-1; i++) {\n                qwe[a.get(i)] = a.get(i+1) - a.get(i);\n            }\n            qwe[a.get(m-1)] = a.get(0) + n - a.get(m-1);\n            for(int i = 1; i < m; i++) {\n                qwe[a.get(i)] = Math.min(a.get(i) - a.get(i-1), qwe[a.get(i)]);\n            }\n            qwe[a.get(0)] = Math.min(qwe[a.get(0)], a.get(0) -  a.get(m-1) + n);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for(int x : queries) {\n            ans.add(qwe[x]);\n        }\n        return ans;\n    }\n}","author":"chubbyseal","submissionId":"1575106092"},[{"id":"214","similarity":0.7068965517241379,"totOverlap":164,"longestOverlap":12}]],"715":[{"id":"715","fileName":"1575123171.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, ArrayList<Integer>> map = new HashMap<>();\n        int n = nums.length;\n        int[] ansArray = new int[n];\n        for(int i =0; i < n; i++){\n            int x =  nums[i];\n            map.putIfAbsent(x, new ArrayList<>());\n            map.get(x).add(i);\n        }\n        for(int x: map.keySet()){\n            ArrayList<Integer> list = map.get(x);\n            int m = list.size();\n            for(int i =1; i < m-1; i++){\n                int index = list.get(i);\n                ansArray[index] = Math.min(list.get(i+1)-list.get(i), \n                                           list.get(i)-list.get(i-1));\n            }\n            if(m == 1){\n                ansArray[list.get(0)] = -1;\n            }else{\n                ansArray[list.get(0)] = Math.min(list.get(1)-list.get(0), \n                                       n-(list.get(m-1) - list.get(0)));\n                ansArray[list.get(m-1)] = Math.min(list.get(m-1)-list.get(m-2), \n                                         n-(list.get(m-1) - list.get(0)));\n            }\n            \n        }\n        List<Integer> ans = new LinkedList<>();\n        for(int i =0; i < queries.length; i++){\n            ans.add(ansArray[queries[i]]);\n        }\n        return ans;\n    }\n}","author":"Sina S","submissionId":"1575123171"},[{"id":"1654","similarity":0.7078189300411523,"totOverlap":172,"longestOverlap":14},{"id":"1654","similarity":0.7222222222222222,"totOverlap":169,"longestOverlap":18},{"id":"1654","similarity":0.7068965517241379,"totOverlap":164,"longestOverlap":12}]],"1099":[{"id":"1099","fileName":"1575133052.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        int n = nums.length;\n        for (int i=0; i<n; i++) {\n            map.computeIfAbsent(nums[i], c-> new ArrayList<>());\n            map.get(nums[i]).add(i);\n        }\n\n        int[] arr = new int[n];\n        for (int key: map.keySet()) {\n            List<Integer> list = map.get(key);\n            int m = list.size();\n            if (m == 1) {\n                arr[list.get(0)] = -1;\n            }\n            else {\n                for (int i=1; i<m-1; i++) {\n                    arr[list.get(i)] = Math.min(list.get(i)-list.get(i-1), list.get(i+1)-list.get(i));\n                }\n                arr[list.get(0)] = Math.min(list.get(1)-list.get(0), n-list.get(m-1)+list.get(0));\n                arr[list.get(m-1)] = Math.min(list.get(m-1)-list.get(m-2), n-list.get(m-1)+list.get(0));\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int query: queries) {\n            result.add(arr[query]);\n        }\n        return result;\n    }\n}","author":"JudyZWY2021","submissionId":"1575133052"},[{"id":"1099","similarity":0.7222222222222222,"totOverlap":169,"longestOverlap":18}]],"1654":[{"id":"1654","fileName":"611238971.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        int[] all = new int[n];\n        Map<Integer,List<Integer>> map = new HashMap<>();\n        for(int i = 0;i < n;i++){\n            if(!map.containsKey(nums[i])){\n                map.put(nums[i],new ArrayList<>());\n            }\n            map.get(nums[i]).add(i);\n        }\n        for(int key:map.keySet()){\n            List<Integer> list = map.get(key);\n            if(list.size() == 1){\n                all[list.get(0)] = -1;\n                continue;\n            }\n            all[list.get(0)] = Math.min(list.get(1) - list.get(0),n-list.get(list.size()-1)+list.get(0));\n            all[list.get(list.size()-1)] = Math.min(list.get(list.size()-1) - list.get(list.size()-2),n-list.get(list.size()-1)+list.get(0));\n            for(int i = 1;i < list.size()-1;i++){\n                all[list.get(i)] = Math.min(list.get(i) - list.get(i-1),list.get(i+1) - list.get(i));\n            }\n        }\n        List<Integer> res = new ArrayList<>();\n        for(int i = 0;i < queries.length;i++){\n            res.add(all[queries[i]]);\n        }\n        return res;\n    }\n}","author":"水","submissionId":"611238971"},[{"id":"715","similarity":0.7078189300411523,"totOverlap":172,"longestOverlap":14}]]},{"716":[{"id":"716","fileName":"1575123173.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>>idx ; \n        int n = nums.size() ; \n        for (int i = 0 ; i < nums.size() ; i++ )idx[nums[i]].push_back(i);\n\n        vector<int>dist(n , 1e7);\n\n        for (auto [el , vec] : idx){\n            sort(vec.begin() , vec.end());\n            for (int i = 1 ; i < vec.size() - 1; i++){\n                dist[vec[i]] = min(vec[i + 1] - vec[i] , vec[i] - vec[i - 1]);\n            }\n            if (vec.size() > 1){\n                \n                dist[vec[0]] = min(vec[1] - vec[0] , (int)nums.size() - vec.back() + vec[0]);\n\n                dist[vec[(int)vec.size() - 1]] = min(vec[(int)vec.size() - 1] - vec[(int)vec.size() - 2],\n                    (int)nums.size() - vec.back() + vec[0]) ; \n            }\n            \n        }\n        vector<int>ans ; \n        for (int q : queries){\n            if(dist[q] == 1e7){\n                ans.push_back(-1);\n            }else{\n                ans.push_back(dist[q]);\n            }\n        }\n        return ans;\n    }\n};","author":"Rishabh Mishra","submissionId":"1575123173"},[]]},{"717":[{"id":"717","fileName":"1575123202.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        ios_base::sync_with_stdio(false);\n        cin.tie(NULL); \n        int n = nums.size();\n        vector<int> ans(queries.size(), -1);\n        unordered_map<int, vector<int>> temp;\n        for (int i = 0; i < n; i++) {\n            temp[nums[i]].push_back(i);\n        }\n        for (int q = 0; q < queries.size(); q++) {\n            int idx = queries[q];\n            int val = nums[idx];\n            vector<int> &pos = temp[val];   \n            if (pos.size() <= 1) {\n                continue;\n            }\n            auto it = lower_bound(pos.begin(), pos.end(), idx);\n            int dis = INT_MAX;\n            if (it != pos.end() && *it == idx) {\n                if (it != pos.begin()) {\n                    int p = *(it - 1);\n                    int dist = min(idx - p, p + n - idx);\n                    dis = min(dis, dist);\n                }\n                if (it + 1 != pos.end()) {\n                    int f = *(it + 1);\n                    int dist = min(f - idx, idx + n - f);\n                    dis = min(dis, dist);\n                }\n                if (pos.size() > 2) {\n                    if (it == pos.begin()) {\n                        int l = pos.back();\n                        int dist = min(l - idx, idx + n - l);\n                        dis = min(dis, dist);\n                    }\n                    else if (it + 1 == pos.end()) {\n                        int fu = pos.front();\n                        int dist = min(idx - fu, fu + n - idx);\n                        dis = min(dis, dist);\n                    }\n                }\n            } else {\n                int pr = -1, ne = -1;\n                if (it == pos.end()) {\n                    pr = pos.back();\n                    ne = pos.front();\n                } else if (it == pos.begin()) {\n                    pr = pos.back();\n                    ne = pos.front();\n                } else {\n                    pr = *(it - 1);\n                    ne = *it;\n                }\n                if (pr != -1) {\n                    int dist = min(idx - pr, pr + n - idx);\n                    dis = min(dis, dist);\n                }\n                if (ne != -1) {\n                    int dist = min(ne - idx, idx + n - ne);\n                    dis = min(dis, dist);\n                }\n            }\n            ans[q] = dis;\n        }\n        return ans;\n    }\n};","author":"frameboy_27","submissionId":"1575123202"},[]]},{"718":[{"id":"718","fileName":"1575123191.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& arr, vector<int>& qq) {\n        int n = arr.size();\n        unordered_map<int,vector<int>>mp;\n        \n        for(int i=0;i<n;i++){\n            mp[arr[i]].push_back(i);\n        }\n\n        vector<int>ans;\n\n        for(auto &q:qq){\n            if(mp[arr[q]].size()<=1) ans.push_back(-1);\n            else{\n                auto &v = mp[arr[q]];\n                auto it = lower_bound(begin(v),end(v),q);\n                int dis = 1e9;\n                if(it!=begin(v)){\n                    it--;\n                    int i = *it;\n                    int j = q;\n                    dis = (min(j-i, n+i-j));\n                }\n                else{\n                    int i = q;\n                    int j = v.back();\n                    dis = min(dis, min(j-i, n+i-j));\n                }\n\n                it = upper_bound(begin(v),end(v),q);\n                if(it!=end(v)){\n                    int j = *it;\n                    int i = q;\n                    dis = min(dis, min(j-i, n+i-j));\n                }\n                else{\n                    int j = q;\n                    int i = v[0];\n                    dis = min(dis, min(j-i, n+i-j));\n                }\n                ans.push_back(dis);\n            }\n        }\n        return ans;\n    }\n};","author":"soundboard","submissionId":"1575123191"},[]]},{"719":[{"id":"719","fileName":"1575123210.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int,vector<int>>mp;\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int>ans(queries.size(),-1);\n        for(int i=0;i<queries.size();i++){\n            int j = queries[i];\n            int val = nums[j];\n            if(mp[val].size() <= 1){\n                continue;\n            }\n            auto &vec = mp[val];\n            auto it = lower_bound(vec.begin(),vec.end(),j) - vec.begin();\n            int l = 0,r = 0;\n            if(it == 0){\n                l = vec.back() - n;\n            }\n            else{\n                l = vec[it - 1];\n            }\n            if(it == vec.size() - 1){\n                r = vec[0] + n;\n            }\n            else{\n                r = vec[it + 1];\n            }\n            int d1 = j - l,d2 = r - j;\n            ans[i] = min(d1,d2);\n        }\n        return ans;\n    }\n};\n\n","author":"adi_097","submissionId":"1575123210"},[]]},{"720":[{"id":"720","fileName":"1575123281.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> dis(n, -1);\n        map<int, pair<int,int>>mp;\n        for(int i = 0; i < n; i++){\n            if(mp.find(nums[i]) == mp.end()){\n                mp[nums[i]] = {i , i};\n            //    cout << i << \"n\";\n            }else{\n                pair<int, int> cur = mp[nums[i]];\n                int first = cur.first;\n                int last = cur.second;\n                int dist1 = i - last;\n                int dist2 = first + n - i;\n                dis[i] =  min(dist1, dist2);\n                dis[first] = (dis[first]!=-1)?(min(dis[first] , dist2)):dist2;\n                dis[last] = (dis[last]!=-1)?(min(dis[last] , dist1)):dist1;\n                mp[nums[i]] = {first, i};\n            }\n        }\n        vector<int> ans (queries.size());\n        for(int i  = 0; i < queries.size(); i++){\n            ans[i] = dis[queries[i]];\n        }\n        return ans;\n    }\n};","author":"xilefy","submissionId":"1575123281"},[]]},{"722":[{"id":"722","fileName":"1575123296.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        length = len(nums)\n        prevIndex = defaultdict(lambda : -1)\n        minPrevDis = defaultdict(lambda : float(\"inf\"))\n        minPostDis = defaultdict(lambda : float(\"inf\"))\n        nums = nums+nums\n        for i in range(length*2):\n            #print(nums[i],prevIndex[nums[i]],i%length)\n            if prevIndex[nums[i]]==-1:\n                prevIndex[nums[i]]=i\n            elif prevIndex[nums[i]]==i%length:\n                continue\n            else:\n                if i%length==3:\n                    print(minPrevDis[i%length],i-prevIndex[nums[i]])\n                minPrevDis[i%length] = min(minPrevDis[i%length],i-prevIndex[nums[i]])\n                prevIndex[nums[i]]=i\n        #print(minPrevDis)\n        prevIndex = defaultdict(lambda : -1)\n        for i in range((length*2)-1,-1,-1):\n            if prevIndex[nums[i]]==-1:\n                prevIndex[nums[i]]=i\n            elif prevIndex[nums[i]]==i+length:\n                continue\n            else:\n                minPostDis[i%length] = min(minPostDis[i%length],prevIndex[nums[i]]-i)\n                prevIndex[nums[i]]=i\n        res = [-1 for _ in range(len(queries))]\n        #print(minPrevDis)\n        for i in range(len(queries)):\n            if min(minPostDis[queries[i]],minPrevDis[queries[i]])==float(\"inf\"):\n                continue\n            else:\n                res[i]=min(minPostDis[queries[i]],minPrevDis[queries[i]])\n        return res","author":"Deban Kumar Sahu","submissionId":"1575123296"},[]]},{"723":[{"id":"723","fileName":"1575123248.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            indices[num].append(i)\n        for num in indices:\n            indices[num].sort()\n        \n        ans = []\n        n = len(nums)\n        \n        for i in queries:\n            v = nums[i]\n            list_v = indices.get(v, [])\n            if len(list_v) <= 1:\n                ans.append(-1)\n                continue\n            pos = bisect.bisect_left(list_v, i)\n            prev_pos = pos - 1\n            \n            if prev_pos < 0:\n                prev_pos = len(list_v) - 1\n                \n            next_pos = (pos + 1) % len(list_v)\n            c1 = list_v[prev_pos]\n            c2 = list_v[next_pos]\n            dist1 = min(abs(i - c1), n - abs(i - c1))\n            dist2 = min(abs(i - c2), n - abs(i - c2))\n            ans.append(min(dist1, dist2))\n            \n        return ans","author":"Sahil Raut","submissionId":"1575123248"},[]]},{"724":[{"id":"724","fileName":"1575123389.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        int m = 3*n;\n        int a[] = new int[m];\n        for(int i=0;i<n;i++){\n            a[i] = nums[i];\n        }\n        for(int i=0;i<n;i++){\n            a[i+n] = nums[i];\n        }\n        for(int i=0;i<n;i++){\n            a[i+2*n] = nums[i];\n        }\n        HashMap<Integer,Integer>mp = new HashMap<>();\n        int ansl[] = new int[m];\n        for(int i=0;i<m;i++){\n            int ind = mp.getOrDefault(a[i],-1);\n            ansl[i] = ind==-1?-1:Math.abs(i-ind);\n            mp.put(a[i],i);\n        }\n        int ansr[] = new int[m];\n        mp=new HashMap<>();\n        for(int i=m-1;i>=0;i--){\n            int ind = mp.getOrDefault(a[i],-1);\n            ansr[i] = ind==-1?-1:Math.abs(i-ind);\n            mp.put(a[i],i);\n        }\n        int ans[] = new int[n];\n        for(int i=0;i<n;i++){\n            int x=ansl[i+n],y=ansr[i+n];\n            if(ansl[i+n]==-1)x=Integer.MAX_VALUE;\n            if(ansr[i+n]==-1)y=Integer.MAX_VALUE;\n            ans[i] = Math.min(x,y);\n            if(ans[i] == Integer.MAX_VALUE)ans[i]=-1;\n        }\n        List<Integer>anss = new ArrayList<>();\n        for(int x:queries){\n            anss.add(ans[x]>=n ? -1 : ans[x]);\n        }\n        // return Arrays.asList(ans);\n        return anss;\n    }\n}","author":"ppwani","submissionId":"1575123389"},[]]},{"725":[{"id":"725","fileName":"1575123430.txt","sourceCode":"class Solution {\npublic:\n    int helper(vector<int>& nums, int idx, int m)\n    {\n        int n = nums.size();\n        if(n == 1) return -1;\n        int current = lower_bound(nums.begin(), nums.end(), idx) - nums.begin();\n        int dis = INT_MAX;\n        int next = (current + 1) % n;\n        int prev = (current + n - 1) % n;\n        dis = min(dis, abs(nums[next] - idx));\n        dis = min(dis, abs(nums[prev] - idx));\n        dis = min(dis, m - abs(nums[next] - idx));\n        dis = min(dis, m - abs(nums[prev] - idx));\n        return dis;\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n\n        unordered_map<int, vector<int>> map;\n\n        for(int i = 0; i < n; ++i)\n        {\n            map[nums[i]].push_back(i);\n        }\n\n        vector<int> result;\n\n        for(int i = 0; i < queries.size(); ++i)\n        {\n            result.push_back(helper(map[nums[queries[i]]], queries[i], n));\n        }\n\n        return result;\n    }\n};","author":"pratyushaggarwal1281","submissionId":"1575123430"},[]]},{"726":[{"id":"726","fileName":"1575123398.txt","sourceCode":"from collections import defaultdict\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        def binary_search(lst, target):\n            lo, hi = 0, len(lst) - 1\n            while lo < hi:\n                mid = (lo + hi) // 2\n                if lst[mid] < target:\n                    lo = mid + 1\n                else:\n                    hi = mid\n            return lo\n\n        d = defaultdict(list)\n        n = len(nums)\n        ans = []\n        for i in range(n):\n            d[nums[i]].append(i)\n        for query in queries:\n            num = nums[query]\n            lst = d[num]\n            ll = len(lst)\n            if ll==1:\n                ans.append(-1)\n                continue\n            idx = binary_search(lst, query)\n            \n            prev = lst[(idx-1) % ll]\n            post = lst[(idx+1) % ll]\n            prevdist = min(abs(query-prev), n - abs(query-prev))\n            postdist = min(abs(query-post), n - abs(query-post))\n            ans.append(min(prevdist, postdist))\n\n        return ans","author":"bluehue","submissionId":"1575123398"},[]]},{"727":[{"id":"727","fileName":"1575123453.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        hm = defaultdict(list)\n        for i,a in enumerate(nums):\n            hm[a].append(i)\n        ans = []\n        for each in queries:\n            val = nums[each]\n            if len(hm[val])==1:\n                ans.append(-1)\n            else:\n                idx = bisect_left(hm[val], each)\n                l,r = idx-1, (idx+1)%len(hm[val])\n                ans.append(min([abs(hm[val][l]-each), abs(hm[val][r]-each), abs(hm[val][l]-len(nums)-each), abs(hm[val][r]-len(nums)-each), abs(hm[val][l]+len(nums)-each), abs(hm[val][r]+len(nums)-each)]))\n        return ans","author":"HappyBoy168","submissionId":"1575123453"},[]]},{"728":[{"id":"728","fileName":"1575123464.txt","sourceCode":"class Solution:\n    def solveQueries(self, arr: List[int], qs: List[int]) -> List[int]:\n        n = len(arr)\n        mp = defaultdict(list)\n\n        for i in range(n):\n            mp[arr[i]].append(i)\n        res = []\n        for i in qs:\n            k = len(mp[arr[i]])\n            if k == 1:\n                res.append(-1)\n                continue\n            idx = bisect_left(mp[arr[i]], i)\n\n            a = mp[arr[i]][idx]\n            b = mp[arr[i]][(idx-1+k)%k]\n            c = mp[arr[i]][(idx+1)%k]\n\n            res.append(min(abs(a-b), n - abs(a-b), abs(a-c), n-abs(a-c)))\n\n        return res\n            ","author":"asdfweasd","submissionId":"1575123464"},[]]},{"729":[{"id":"729","fileName":"1575123583.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> ans(queries.size(), -1);\n        int mx = *max_element(nums.begin(), nums.end());\n        vector<set<int>> pos(mx + 1);\n\n        for (int i = 0; i < n; ++i)\n            pos[nums[i]].insert(i);\n\n        for (int i = 0; i < queries.size(); ++i) {\n            int x = queries[i];\n            if (x < 0 || x >= n)\n                continue;\n\n            int y = nums[x];\n            if (pos[y].size() == 1)\n                continue;\n\n            pair<int, int> p = {INT_MAX, INT_MAX};\n\n\n            auto it = pos[y].lower_bound(x);\n            if (it != pos[y].begin()) {\n                it--;\n                int dis = min(n - abs(x - *it), abs(x - *it));\n                if (dis < p.first)\n                    p = {dis, *it};\n            }\n            it = pos[y].upper_bound(x);\n            if (it != pos[y].begin() && it != pos[y].end()) {\n\n                int dis = min(n - abs(x - *it), abs(x - *it));\n                // cout << i << \" \" << dis << \"n\";\n                if (dis < p.first)\n                    p = {dis, *it};\n            }\n            if (*pos[y].begin() == x) {\n                it = pos[y].end();\n                it--;\n                if (*it != x) {\n                    int dis = min(n - abs(x - *it), abs(x - *it));\n                    if (dis < p.first)\n                        p = {dis, *it};\n                }\n            }\n            if (*pos[y].rbegin() == x) {\n                it = pos[y].begin();\n\n                if (*it != x) {\n                    int dis = min(n - abs(x - *it), abs(x - *it));\n                    if (dis < p.first)\n                        p = {dis, *it};\n                }\n            }\n            ans[i] = p.first;\n        }\n        return ans;\n    }\n};","author":"Ankit sisodya","submissionId":"1575123583"},[]]},{"730":[{"id":"730","fileName":"1575123584.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int, set<int>> mp;\n\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].insert(i);\n        }\n\n        vector<int> v;\n        for (auto idx : queries) {\n            int x = nums[idx];\n            auto &st = mp[x];\n\n            if (st.size() == 1) {\n                v.push_back(-1);\n                continue;\n            }\n\n            int ans = 1e9;\n            auto it = st.find(idx);\n\n            if (it != st.begin()) {\n                auto prevIt = it;\n                prevIt--;\n                ans = min(ans, idx - *prevIt);\n            } else {\n                auto lastIt = st.end();\n                lastIt--;\n                ans = min(ans, idx + n - *lastIt);\n            }\n\n            auto nextIt = it;\n            nextIt++;\n            if (nextIt != st.end()) {\n                ans = min(ans, *nextIt - idx);\n            } else {\n                ans = min(ans, *st.begin() + n - idx);\n            }\n\n            v.push_back(ans);\n        }\n\n        return v;\n    }\n};\n","author":"Shashivardhan Reddy","submissionId":"1575123584"},[]]},{"731":[{"id":"731","fileName":"1575123615.txt","sourceCode":"from collections import defaultdict \nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        index = defaultdict(int)\n        close = defaultdict(int)\n        n = len(nums)\n        nums = nums + nums + nums\n        for i in range(len(nums)):\n            close[i] = float('inf')\n        for i in range(len(nums)):\n            el = nums[i]\n            if el in index:\n                close[i] = i - index[el]\n            index[el] = i\n\n        \n        # print(close)\n        index = defaultdict(int)\n        for i in range(len(nums)-1, -1, -1):\n            el = nums[i]\n            if el in index:\n                close[i] = min(close[i], abs(index[el] - i))\n               \n                    \n            index[el] = i\n        ans = []\n        for i in queries:\n            q = i + n\n            if close[q] != float('inf') and close[q] < n:\n                ans.append(close[q])\n            else:\n                ans.append(-1)\n        return ans","author":"Vic","submissionId":"1575123615"},[]]},{"732":[{"id":"732","fileName":"1575123685.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        index_map = defaultdict(list)\n        for i, num in enumerate(nums):\n            index_map[num].append(i)\n        # print(index_map)\n        n = len(nums)\n        ans = []\n        for q in queries:\n            if len(index_map[nums[q]]) == 1:\n                ans.append(-1)\n                continue\n            pos = bisect_left(index_map[nums[q]], q)\n            d_prev = n - (q - index_map[nums[q]][0]) if pos+1 == len(index_map[nums[q]]) else index_map[nums[q]][(pos+1)] - q\n            d_next = n - (index_map[nums[q]][-1] - q) if pos == 0 else q - index_map[nums[q]][(pos-1)] \n            # print(nums[q], pos)\n            ans.append(min(d_prev, d_next))\n        return ans","author":"1014jack","submissionId":"1575123685"},[]]},{"733":[{"id":"733","fileName":"1575123481.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    unordered_map<int, vector<int>> groups;\n    vector<int> output;\n\n    void func(vector<int>& nums, vector<int>& queries,int size) {\n        for (int q : queries) {\n            int val = nums[q];\n            vector<int>& arr = groups[val];\n\n            if (arr.size() < 2) {\n                output.push_back(-1);\n                continue;\n            }\n\n            auto it = lower_bound(arr.begin(), arr.end(), q);\n            int pos = distance(arr.begin(), it);\n            \n            int leftNe = (pos > 0) ? arr[pos - 1] : arr.back();\n            int rightNe = (pos < arr.size() - 1) ? arr[pos + 1] : arr.front();\n\n            int left, right;\n            if (q >= leftNe) {\n                left = q - leftNe;\n            } else {\n                left = q + size - leftNe;\n            }\n\n            if (rightNe >= q) {\n                right = rightNe - q;\n            } else {\n                right = rightNe + size - q;\n            }\n\n            output.push_back(min(left, right));\n        }\n\n    }\n\n    void funcc(){\n        for (auto x: groups) {\n            auto i=x.first;\n            auto vec=x.second;\n            sort(vec.begin(), vec.end());\n        }\n    }\n\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int size = nums.size();\n        \n        for (int pos = 0; pos < size; pos++) {\n            groups[nums[pos]].push_back(pos);\n        }\n\n        funcc();\n        func(nums, queries, size);        \n        return output;\n    }\n};\n","author":"devanshDev_001","submissionId":"1575123481"},[]]},{"734":[{"id":"734","fileName":"1575123697.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        vector<int> res;\n        map<int,vector<int>> mp;\n        int n=size(a);\n        for(int i=0;i<size(a);i++)\n            mp[a[i]].push_back(i);\n        map<int,int> l,r;\n        for(auto &i:mp)\n        {\n            int m=size(i.second);\n            for(int j=0;j<m;j++)\n                l[i.second[j]]=i.second[(j+m-1)%m],r[i.second[j]]=i.second[(j+1)%m];\n        }\n        for(int i:q)\n        {\n            if(size(mp[a[i]])==1)\n                res.push_back(-1);\n            else\n                res.push_back(min(cal(l[i],i,n),cal(i,r[i],n)));\n        }\n        return res;\n    }\n\n    int cal(int i,int j,int n)\n    {\n        if(i<j) return j-i;\n        return n-i+j;\n    }\n};","author":"LeeMinHoon","submissionId":"1575123697"},[]]},{"735":[{"id":"735","fileName":"1575123736.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int>ans(queries.size());\n        map<int,set<int>>m;\n        int n = nums.size();\n        map<int,int>counter;\n        for(int i =0; i<n; ++i){\n            int v= nums[i];\n            counter[v]++;\n            m[v].insert(i);\n            m[v].insert(i+n);\n            m[v].insert(i-n);\n        }\n        for(int i =0; i<queries.size(); ++i){\n            int v= nums[queries[i]];\n            int pos = queries[i];\n            if(counter[v]==1){\n                ans[i]=-1;\n            }else{\n                auto it = m[v].upper_bound(pos);\n                auto it2 = prev(m[v].lower_bound(pos));\n                int a = min(pos-*it2,n-(pos-*it2));\n                int b = min(n-(*it-pos),*it-pos);\n                int dist = min(a,b);\n                ans[i]=dist;\n                //cout<<dist<<endl;\n            }\n        }\n        return ans;\n        \n    }\n};","author":"BrainZhao","submissionId":"1575123736"},[]]},{"736":[{"id":"736","fileName":"1575123771.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<int> res(m, -1);\n        unordered_map<int, vector<int>> pos;\n        for(int i = 0; i < n; i ++) {\n            pos[nums[i]].push_back(i);\n        }\n        for(int i = 0; i < m; i ++) {\n            int num = nums[queries[i]], size = pos[num].size();\n            if(size == 1) {\n                continue;\n            }\n            int k = bisect(pos[num], queries[i]);\n            int d1 = dist(queries[i],  pos[num][(k + 1) % size], n), d2 = dist(queries[i],  pos[num][(k - 1 + size) % size], n);\n            res[i] = d1 < d2 ? d1 : d2;\n        }\n        return res;\n    }\n\n    int bisect(vector<int>& nums, int target) {\n        int left = 0, right = nums.size() - 1;\n        while(left <= right) {\n            int mid = (left + right) / 2;\n            if(nums[mid] < target) {\n                left = mid + 1;\n            }\n            else if(nums[mid] > target) {\n                right = mid - 1;\n            }\n            else {\n                return mid;\n            }\n        }\n        return -1;\n    }\n\n    int dist(int a, int b, int n) {\n        int d = abs(a - b);\n        return min(d, n - d);\n    }\n};","author":"zubacii","submissionId":"1575123771"},[]]},{"737":[{"id":"737","fileName":"1575123573.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) \n    {\n        int n = nums.size();\n        map<int, vector<int>> mpp;\n        for(int i = 0; i < n; ++i)\n        {\n            mpp[nums[i]].push_back(i);\n        }\n        int m = queries.size();\n        vector<int> ans(m, -1);\n        for(int i = 0; i < m; ++i)\n        {\n            int idx = queries[i];\n            int el = nums[idx];\n            int sz = mpp[el].size();\n            if(mpp[el].size() > 1)\n            {\n                int iu = upper_bound(mpp[el].begin(), mpp[el].end(), idx) - mpp[el].begin();\n                iu--;\n                int l = (iu-1+sz)%sz;\n                int r = (iu+1)%sz;\n                if(iu == 0)\n                {\n                    ans[i] = (idx + n - mpp[el][l]);\n                }\n                else \n                {\n                    ans[i] = (idx - mpp[el][l]);\n                }\n                if(iu == (sz-1))\n                {\n                    cout << \"Yes\" << endl;\n                    ans[i] = min(ans[i], n + mpp[el][r] - idx);\n                    // cout << (n + mpp[el][r] + idx);\n                }\n                else \n                {\n                    ans[i] = min(ans[i], abs(mpp[el][r] - idx));\n                }\n            }\n        }\n        return ans;\n    }\n};","author":"Prajjawal_Agrahari","submissionId":"1575123573"},[]]},{"738":[{"id":"738","fileName":"1575123753.txt","sourceCode":"constexpr int INF = 1e9 + 7;\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<int> ans;\n        ans.reserve(m);\n        unordered_map<int, int> pos;\n        vector<int> dist(n, INF);\n        for (int i = 0; i < 2 * n; ++i) {\n            int j = i % n;\n            int x = nums[j];\n            if (pos.count(x) == 0) {\n                pos[x] = j;\n            } else {\n                int p = pos[x];\n                if (p == j) {\n                    if (dist[j] == INF) {\n                        dist[j] = -1;\n                        continue;\n                    }\n                }\n                int d;\n                if (p < j) {\n                    d = min(j - p, p + n - j);\n                } else {\n                    d = min(p - j, j + n - p);\n                }\n                dist[j] = min(dist[j], d);\n                dist[p] = min(dist[p], d);\n                \n                pos[x] = j;\n            }\n        }\n        for (int q : queries) {\n            ans.push_back(dist[q]);\n        }\n        return ans;\n    }\n};","author":"Catchet","submissionId":"1575123753"},[]]},{"740":[{"id":"740","fileName":"1575123903.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (!map.containsKey(nums[i])) {\n                map.put(nums[i], new ArrayList<Integer>());\n            }\n            map.get(nums[i]).add(i);\n            map.get(nums[i]).add(i-nums.length);\n            map.get(nums[i]).add(i+nums.length);\n        }\n        for (Integer key : map.keySet()) {\n            Collections.sort(map.get(key));\n        }\n        List<Integer> ans = new ArrayList<>(queries.length);\n        for (int i = 0; i < queries.length; i++) {\n            int j = queries[i];\n            if (!map.containsKey(nums[j])) {\n                ans.add(-1);\n                continue;\n            }\n            List<Integer> indices = map.get(nums[j]);\n            if (indices.size() == 3) {\n                ans.add(-1);\n                continue;\n            }\n            int index = Collections.binarySearch(indices, j);\n            ans.add(Math.min(indices.get(index+1) - indices.get(index), indices.get(index) - indices.get(index-1)));\n        }\n        return ans;\n    }\n}","author":"Abhay Kshatriya","submissionId":"1575123903"},[]]},{"742":[{"id":"742","fileName":"1575123757.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> mp = {};\n        vector<int> ans = {};\n        int n = nums.size();\n        vector<int> idxToAns = vector(n, 1000000000);\n\n        for(int i = 0; i < nums.size(); i++) {\n            if(mp.contains(nums[i])) {\n                idxToAns[i] = min(mp[nums[i]][0] + n - i, i - mp[nums[i]][mp[nums[i]].size() - 1]);\n                idxToAns[mp[nums[i]][0]] = min(idxToAns[mp[nums[i]][0]], mp[nums[i]][0] + n - i);\n                idxToAns[mp[nums[i]][mp[nums[i]].size() - 1]] = min(\n                    idxToAns[mp[nums[i]][mp[nums[i]].size() - 1]],\n                    i - mp[nums[i]][mp[nums[i]].size() - 1]\n                );\n\n                // cout << idxToAns[i] << endl;\n                // cout << idxToAns[mp[nums[i]][0]] << endl;\n                mp[nums[i]].push_back(i);\n            }\n            else {\n                mp[nums[i]] = {i};\n            }\n        }\n\n        for(int q : queries) {\n            ans.push_back(idxToAns[q] == 1000000000 ? -1 : idxToAns[q]);\n        }\n\n        return ans;\n    }\n};","author":"Joey Mucci","submissionId":"1575123757"},[]]},{"745":[{"id":"745","fileName":"1575124130.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n\n        int n = nums.size();\n\n        for(int i = 0; i<n; ++i){\n            nums.push_back(nums[i]);\n        }\n\n        vector<int> min_neighbour_idx(n, n);\n\n        map<int, int> mp;                // ele -> idx\n\n        for(int i = 0; i<2*n; ++i){\n            if(mp.find(nums[i]) != mp.end()){\n                min_neighbour_idx[i%n] = i - mp[nums[i]];\n            }\n\n            mp[nums[i]] = i;\n        }\n\n        mp.clear();\n\n        for(int i = 2*n-1; i>=0; --i){\n            if(mp.find(nums[i]) != mp.end()){\n                min_neighbour_idx[i%n] = min(mp[nums[i]] - i, min_neighbour_idx[i%n]);\n            }\n\n            mp[nums[i]] = i;\n        }\n\n        int q = queries.size();\n\n        vector<int> ans(q);\n\n        for(int i = 0; i<q; ++i){\n            ans[i] = min_neighbour_idx[queries[i]];\n            if(ans[i] == n) ans[i] = -1;\n        }\n        return ans;\n    }\n};","author":"automatefreely","submissionId":"1575124130"},[{"id":"1297","similarity":0.7424242424242424,"totOverlap":147,"longestOverlap":13}]],"1297":[{"id":"1297","fileName":"1575138124.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        int q=queries.size();\n        vector<int>arr(2*n);\n        for(int i=0;i<2*n;i++){\n            arr[i]=nums[i%n];\n        }\n        vector<int>ans(q);\n        vector<int>left(2*n);\n        map<int,int>lastIndex;\n        for(int i=0;i<2*n;i++){\n            if(lastIndex.find(arr[i])==lastIndex.end()){\n                left[i]=1e9;\n            }\n            else{\n                left[i]=i-lastIndex[arr[i]];\n            }\n            lastIndex[arr[i]]=i;\n        }\n        vector<int>right(2*n);\n        map<int,int>nxtIndex;\n        for(int i=2*n-1;i>=0;i--){\n            if(nxtIndex.find(arr[i])==nxtIndex.end()){\n                right[i]=1e9;\n            }\n            else{\n                right[i]=nxtIndex[arr[i]]-i;\n            }\n            nxtIndex[arr[i]]=i;\n        }\n        //debug(arr);\n        //debug(left);\n        //debug(right);\n        for(int i=0;i<q;i++){\n            ans[i]=min({left[queries[i]],right[queries[i]],left[n+queries[i]],right[n+queries[i]]});\n            if(ans[i]>=n)ans[i]=-1;\n        }\n        return ans;\n    }\n};","author":"BodaciousLord007","submissionId":"1575138124"},[{"id":"745","similarity":0.7424242424242424,"totOverlap":147,"longestOverlap":13}]]},{"746":[{"id":"746","fileName":"1575124064.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], q: List[int]) -> List[int]:\n        def cir(a,b,n):\n            d=abs(a-b)\n            return min(d,n-d)\n        d=defaultdict(list)\n        for i,v in enumerate(nums):\n            d[v].append(i)\n        for i in d:\n            d[i].sort()\n        n=len(nums)\n        ans=[]\n        for i in q:\n            a=nums[i]\n            arr=d[a]\n            if len(arr)<2:\n                ans.append(-1)\n                continue\n            w=bisect.bisect_left(arr, i)\n            if w==len(arr) or arr[w]!=i:\n                w-=1\n            j=(w+1)%len(arr)\n            k=(w-1)%len(arr)\n            ans.append(min(cir(arr[w],arr[j],n),cir(arr[w],arr[k],n)))\n        return ans","author":"Arnav Goyal","submissionId":"1575124064"},[]]},{"747":[{"id":"747","fileName":"1575124111.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n         int n= nums.size();\n        for(int i=0;i<n;i++){\n            nums.push_back(nums[i]);\n        }\n        vector<int> left(2*n,-1),right(2*n,-1);\n        unordered_map<int,int> mp1,mp2;\n        for(int i=0;i<2*n;i++){\n            if(mp1.find(nums[i])!=mp1.end() && mp1[nums[i]]!=(i%n)){\n                left[i]=mp1[nums[i]];\n            }\n            mp1[nums[i]]=i;\n        }\n        for(int i=2*n-1;i>=0;i--){\n            if(mp2.find(nums[i])!=mp2.end() && mp2[nums[i]]!=(i+n)){\n                right[i]=mp2[nums[i]];\n            }\n            mp2[nums[i]]=i;\n        }\n\n        vector<int> ans;\n        for(auto it: queries){\n            int minval=INT_MAX;\n            if(left[it]!=-1){\n                minval= min(minval,abs(it-left[it]));\n            }\n            if(left[it+n]!=-1){\n                minval= min(minval,abs(it+n-left[it+n]));\n            }\n            if(right[it]!=-1){\n                minval= min(minval,abs(it-right[it]));\n            }\n            if(right[it+n]!=-1){\n                minval= min(minval,abs(it+n-right[it+n]));\n            }\n            if(minval==INT_MAX) ans.push_back(-1);\n            else ans.push_back(minval);\n        }\n        return ans;\n    }\n};","author":"GavnishKumar","submissionId":"1575124111"},[]]},{"748":[{"id":"748","fileName":"1575123838.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        indices = defaultdict(list)\n        n = len(nums)\n        for i in range(n):\n            indices[nums[i]].append(i)\n        ret = []\n        for q in queries:\n            num = nums[q]\n            if len(indices[num]) == 1:\n                ret.append(-1)\n            else:\n                idx = bisect_left(indices[num], q)\n                leftDist = 0\n                rightDist = 0\n                if idx == 0:\n                    leftDist = q + (n - indices[num][-1])\n                    rightDist = indices[num][idx+1] - q\n                elif idx == len(indices[num]) - 1:\n                    leftDist = q - indices[num][idx-1]\n                    rightDist = (n - q) + indices[num][0]\n                else:\n                    leftDist = q - indices[num][idx-1]\n                    rightDist = indices[num][idx+1] - q\n                ret.append(min(leftDist, rightDist))\n        return ret","author":"jayxps","submissionId":"1575123838"},[]]},{"749":[{"id":"749","fileName":"1575124276.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n\n        map<int, int> prev, next;\n        int n = nums.size();\n\n        for(int i=0; i<n; i++)\n            prev[nums[i]] = -n+i;\n        for(int i=n-1; i>=0; i--)\n            next[nums[i]] = n+i;\n\n        vector<int> prevDis(n, -1);\n\n        for(int i=0; i<n; i++){\n            prevDis[i] = prev[nums[i]];\n            prev[nums[i]] = i;\n        }\n        \n        vector<int> nextDis(n, -1);\n\n        for(int i=n-1; i>=0; i--){\n            nextDis[i] = next[nums[i]];\n            next[nums[i]] = i;\n        }\n\n        vector<int> ans(n, -1);\n        for(int i=0; i<n; i++){\n            if(true){\n                int dis = i - prevDis[i];\n                // dis = min(dis, n - dis);\n                // if(dis != 0) \n                ans[i] = dis;\n            }\n\n            if(true){\n                int dis = nextDis[i] - i;\n                // dis = min(dis, n - dis);\n                // if(dis != 0)\n                if(ans[i] == -1 or dis < ans[i])\n                    ans[i] = dis;\n            }\n        }\n            \n        vector<int> res;\n        for(int i: queries){\n            if(ans[i] == n) ans[i] = -1;\n            res.push_back(ans[i]);\n        }\n\n        return res;\n    }\n};","author":"Arjun S","submissionId":"1575124276"},[]]},{"750":[{"id":"750","fileName":"1575124191.txt","sourceCode":"\n  //the game is won at the practice not during the performance//-->someone \n #include <bits/stdc++.h>\n using namespace std;\n #define ll                     long long int\n #define all(v)                 v.begin(), v.end()\n #define maxi(v)                *max_element(v.begin(), v.end())\n #define vecsum(v)              accumulate(v.begin(), v.end(), 0LL)\n #define mini(v)                *min_element(v.begin(), v.end())\n #define sortd(v)                sort(v.begin(), v.end(), greater<int>())\n #define read(a, n)             for(int i=0;i<n;i++)    cin >> a[i]\n #define print(a, n)            for(int i=0;i<n;i++)    cout << a[i] << \" \"; cout << endl\n #define rep(a,n,b,i)           for(int i=a;i<n;i+=b)       \n #define M                       1000000007\n #define pb                      push_back\n #define sz                      size()\n #define len                     length()\n #define fir                     first\n #define sec                     second\n #define cy                      cout << \"YES\" << endl\n #define cn                      cout << \"NO\" << endl \n using pp = pair<ll,ll>;\n using ppp = pair<ll,pair<ll,ll>>;\n using vl = vector<ll>;\n using vc = vector<char>;\n using vi = vector<int>;\n using vvl=vector<vector<ll>>;\n using vvc=vector<vector<char>>;\n \n class Solution {\n    public:\n        vector<int> solveQueries(vector<int>& v, vector<int>& q) {\n            map<ll,vector<ll>>mp;\n            ll n=v.sz;\n            vi res;\n            ll ind=0;\n            for(auto it:v){\n            mp[it].pb(ind);\n             ind++;\n            }\n            for(auto it:q){\n               ll id=it;\n               ll cur=v[id];\n               if(mp[cur].sz==1){\n                   res.pb(-1);\n                   continue;\n               }\n               ll m=mp[cur].sz;\n               ll ind1=lower_bound(mp[cur].begin(),mp[cur].end(),id)-mp[cur].begin();\n               ll tem=1e9;\n                 ll n1=(ind1+1)%m;\n                 ll n2=(ind1-1+m)%m;\n                 ll x=(mp[cur][n1]),y=mp[cur][n2];\n                 ll p=abs(it-x),q=abs(it-y);\n                 p=min(p,n-p);q=min(q,n-q);\n                 res.pb(min(p,q));\n            }\n            return res;\n        }\n    };","author":"nishanth14","submissionId":"1575124191"},[]]},{"752":[{"id":"752","fileName":"1575124304.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, int> mp, mp1;\n        int n = nums.size();\n        vector<int> temp(n+1, -1);\n        \n        for(int i = 0; i < n; i++){\n            nums.push_back(nums[i]);\n        }\n        for(int i = 0; i < n; i++){\n            if(mp[nums[i]] != 0){\n                int prv = mp[nums[i]]-1;\n                int nxt = mp1[nums[i]] - 1;\n                int cur = i;\n                int a = cur - prv;\n                int b = nxt + n - cur;\n                // cout<<i<<\" \"<<nums[i]<<\" \"<<a<<\" \"<<b<<endl;\n                int c = min(a, b);\n                // a = min(a, b);\n                \n                if(temp[prv] == -1 || temp[prv] > a){\n                    temp[prv] = a;\n                }\n                if(temp[cur] == -1 || temp[cur] > c){\n                    temp[cur] = c;\n                }\n                if(temp[nxt] == -1 || temp[nxt] > b){\n                    temp[nxt] = b;\n                }\n            }\n            if(mp1[nums[i]] == 0){\n                mp1[nums[i]] = i+1;\n            }\n            mp[nums[i]] = i + 1;\n        }\n        vector<int> ans;\n        for(auto aa : queries){\n            ans.push_back(temp[aa]);\n        }\n        return ans;\n    }\n};","author":"arham doshi","submissionId":"1575124304"},[]]},{"753":[{"id":"753","fileName":"1575124300.txt","sourceCode":"class Solution {\npublic:\n    inline int dist(int a, int b, int s){\n        return min(abs(a-b), min(abs(b+s-a), abs(a+s-b)));\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> idx;\n        for(int i = 0; i < nums.size(); i++){\n            idx[nums[i]].push_back(i);\n        }\n        vector<int> ans(queries.size());\n        for(int i = 0; i < queries.size(); i++){\n            int v = nums[queries[i]];\n            if(idx[v].size() == 1){\n                ans[i] = -1;\n                continue;\n            }\n            auto it = upper_bound(idx[v].begin(), idx[v].end(), queries[i]);\n            int i1, i2;\n            if(it == idx[v].end()){\n                i1 = idx[v][0];\n                i2 = idx[v][idx[v].size()-2];\n            }\n            else{\n                i1 = *it;\n                i2 = idx[v][(it-idx[v].begin()-2+idx[v].size())%idx[v].size()];\n            }\n            ans[i] = min(dist(i1, queries[i], nums.size()), dist(i2, queries[i], nums.size()));\n        }\n        return ans;\n    }\n};","author":"HerbertTheBird","submissionId":"1575124300"},[]]},{"755":[{"id":"755","fileName":"1575124291.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> p(1000000, -1);\n        vector<int> pn(nums.size(), -1);\n        vector<int> nn(nums.size(), -1);\n        vector<int> res(queries.size(), -1);\n        for(int i=0; i<nums.size(); ++i) {\n            if (0<=p[nums[i]]){\n                nn[p[nums[i]]] = i;\n                pn[i] = p[nums[i]];\n            }\n            p[nums[i]] = i;\n        }\n        for(int i=0; i<nums.size(); ++i) {\n            if (pn[i]<0) {\n                nn[p[nums[i]]] = i;\n                pn[i] = p[nums[i]];\n            }\n        }\n        for(int i=0; i<queries.size(); ++i) {\n            const auto& q = queries[i];\n            res[i] = min(\n                (nn[q] - q + nums.size())%nums.size(),\n                (q - pn[q] + nums.size())%nums.size()\n            );\n            if (res[i]==0) res[i] = -1;\n        }\n        return res;\n    }\n};","author":"skentagon","submissionId":"1575124291"},[]]},{"756":[{"id":"756","fileName":"1575124314.txt","sourceCode":"from typing import List\n\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n\n        num_to_last_index = {}\n\n        for i in range(n):\n            num = nums[i]\n            num_to_last_index[num] = i\n\n        num_to_prev_index = {}\n        prev_indexes = [-1] * n\n\n        for i in range(n):\n            num = nums[i]\n            if num in num_to_prev_index:\n                prev_indexes[i] = num_to_prev_index[num]\n            else:\n                prev_indexes[i] = num_to_last_index[num]\n            num_to_prev_index[num] = i\n\n        next_indexes = [-1] * n\n\n        for i in range(n):\n            prev_index = prev_indexes[i]\n            assert 0 <= prev_index < n\n            next_indexes[prev_index] = i\n\n        def dist(a, b):\n            return min(abs(a - b), n - abs(a - b))\n\n        results = []\n        for b in queries:\n            a = prev_indexes[b]\n            c = next_indexes[b]\n            results.append(min(dist(b, a), dist(b, c)))\n        return [(x if 1 <= x < n else -1) for x in results]\n\n ","author":"ocavue","submissionId":"1575124314"},[]]},{"757":[{"id":"757","fileName":"1575124377.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        int n = nums.size();\n        for (int i = 0; i < nums.size(); i++) {\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans, t;\n        for (int q: queries) {\n            t = mp[nums[q]];\n            if (t.size() <= 1) ans.push_back(-1);\n            else {\n                int mod = t.size();\n                int i = upper_bound(t.begin(), t.end(), q) - t.begin() - 1;\n                int j = (i + 1) % mod;\n                int k = (i - 1 + mod) % mod;\n                ans.push_back(min({abs(t[i] - t[j]), abs(t[i] - t[k]), abs(t[i] + n - t[k]), abs(t[j] + n - t[i])}));\n            }\n        }\n        return ans;\n    }\n};","author":"Zhenyuan Lu","submissionId":"1575124377"},[]]},{"758":[{"id":"758","fileName":"1575124411.txt","sourceCode":"public class Solution {\n    public IList<int> SolveQueries(int[] nums, int[] qu) \n    {\n        var dict = nums.Select((x, i) => (x, i)).GroupBy(p => p.x).ToDictionary(g => g.Key, g => g.Select(p => p.i).ToList());\n\n        List<int> ans = new(qu.Length);\n        foreach (int q in qu) \n        {\n            var list = dict[nums[q]];\n\n            if (list.Count == 1) \n            {\n                ans.Add(-1);\n                continue;\n            }\n            \n            int ind = list.BinarySearch(q);\n            int prev = ind > 0 ? ind - 1 : list.Count - 1;\n            int next = ind + 1 < list.Count ? ind + 1 : 0;\n\n            //Console.WriteLine($\"{ind} {prev} {next}\");\n            //Console.WriteLine($\"{list[ind]} {list[prev]} {list[next]}\");\n\n            ans.Add(Math.Min(Dist(list[ind], list[prev]), Dist(list[ind], list[next])));\n\n            int Dist(int i, int j) => Math.Min(Math.Abs(i - j), nums.Length - Math.Abs(i - j));\n        }\n        return ans;\n    }\n}","author":"Rad0miR","submissionId":"1575124411"},[]]},{"759":[{"id":"759","fileName":"1575124470.txt","sourceCode":"#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n\n// shortcut type\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\n\n// Constants\nconst int MOD = 1e9 + 7;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& v, vector<int>& q) {\n        map<int, vector<int>> m;\n        int n = v.size();\n        for (int i = 0; i < n; i++) {\n            m[v[i]].push_back(i);\n        }\n        vi ans;\n        for (auto& j : q) {\n            int x = v[j];\n            if (m.find(x) == m.end() or m[x].size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            int i = lower_bound(all(m[x]), j) - m[x].begin();\n            int l, r;\n            if (i == 0) {\n                l = m[x].back();\n            } else\n                l = m[x][i - 1];\n            if (i == m[x].size() - 1) {\n                r = m[x][0];\n            } else\n                r = m[x][i + 1];\n            int a = 1e9;\n            i=m[x][i];\n            // cout<<i<<\" \"<<l<<\" \"<<r<<endl;\n            if (l < i) {\n                a = min(a, min(i - l,l+n-i));\n            } else\n                a = min(a, min(l-i,i+n-l));\n           if (r < i) {\n                a = min(a, min(i - r,r+n-i));\n            } else\n                a = min(a, min(r-i,i+n-r));\n            ans.push_back(a);\n        }\n        return ans;\n    }\n};","author":"Sk Najir","submissionId":"1575124470"},[]]},{"760":[{"id":"760","fileName":"1575124431.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n=len(nums)\n        d={}\n        for i,val in enumerate(nums):\n            if val not in d.keys():\n                d[val]=[]\n            d[val].append(i)\n\n        for k in d.keys():\n            d[k].sort()\n        ans=[]\n        for q in queries:\n            if len(d[nums[q]])==1:\n                ans.append(-1)\n                continue\n            #d[nums[q]].sort()\n            m=len(d[nums[q]])\n            idx=bisect_left(d[nums[q]],q)\n            ans.append(min(\n                (d[nums[q]][(idx+1)%m]-d[nums[q]][idx]+n)%n,\n                (d[nums[q]][idx]-d[nums[q]][idx-1]+n)%n\n            ))\n        return ans","author":"Cheng-Shun Liu","submissionId":"1575124431"},[]]},{"761":[{"id":"761","fileName":"1575124459.txt","sourceCode":"class Solution {\npublic:\n    int n;\n    int q;\n    vector<int> solveQueries(vector<int>& nums, vector<int>& que) {\n        n = nums.size();\n        unordered_map<int, vector<int>> mp;\n\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n    \n        vector<int> left(n, -1), right(n, -1);\n        for (auto& [val, indices] : mp) {\n            int m = indices.size();\n            for (int i = 0; i < m; i++) {\n                int j = (i + 1) % m;\n                int dist = min(abs(indices[j] - indices[i]), n - abs(indices[j] - indices[i]));\n                left[indices[i]] = dist;\n                right[indices[j]] = dist;\n            }\n        }\n    \n        vector<int> ans;\n        for (int q : que) {\n            int target = nums[q];\n            if (mp[target].size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            ans.push_back(min(left[q], right[q]));\n        }\n        return ans;\n    }\n};","author":"Sarvagya_Gupta73","submissionId":"1575124459"},[]]},{"762":[{"id":"762","fileName":"1575124520.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, set<int>>mp;\n        int n = nums.size();\n        vector<int>res;\n        \n        for(int i=0;i<n;i++){\n            mp[nums[i]].insert(i);\n        }\n\n        for(auto el : queries){\n            if(mp[nums[el]].size()==1){\n                res.push_back(-1);\n            }\n            else{\n                int x = nums[el];\n                auto it =mp[x].find(el);\n                if(it==mp[x].begin()){\n                    int r = *next(it) - *it;\n                    int l =  *it + n- (*mp[x].rbegin());\n                    res.push_back(min(l,r));\n                }\n                else if(next(it)==mp[x].end()){\n                    int l = *it - *prev(it);\n                    int r = n-(*it) + (*mp[x].begin());\n                    res.push_back(min(l,r));\n                }\n                else{\n                    int l = *it - *prev(it);\n                    int r = *next(it) - *it;\n                    res.push_back(min(l,r));\n                }\n            }\n        }\n\n        return res;\n    }\n};","author":"dhavalk439","submissionId":"1575124520"},[]]},{"763":[{"id":"763","fileName":"1575124512.txt","sourceCode":"typedef int ll;\nclass Solution {\npublic:\n    \n    \n    ll f1(vector <pair<ll,ll>> &A,ll a){\n        ll low = 0,high = A.size()-1;\n        ll ans = -1;\n        while(low<=high){\n            ll m= low + (high-low)/2;\n            if(A[m].first==a){\n                ans = m;\n                high = m-1;\n            }\n            else if(A[m].first>a){\n                high = m-1;\n            }\n            else{\n                low = m+1;\n            }\n        }\n        return ans;\n    }\n    ll f2(vector <pair<ll,ll>> &A,ll a){\n        ll low = 0,high = A.size()-1;\n        ll ans = -1;\n        while(low<=high){\n            ll m= low + (high-low)/2;\n            if(A[m].first==a){\n                ans = m;\n                low = m+1;\n            }\n            else if(A[m].first>a){\n                high = m-1;\n            }\n            else{\n                low = m+1;\n            }\n        }\n        return ans;\n    }\n    ll f3(vector <pair<ll,ll>> &A,ll a,ll b){\n        ll low = 0,high = A.size()-1;\n        ll ans = -1;\n        while(low<=high){\n            ll m= low + (high-low)/2;\n            if(A[m].first==a){\n                if(A[m].second==b){\n                    ans = m;\n                    break;\n                }\n                else if(A[m].second<b){\n                    low = m+1;\n                }\n                else{\n                    high = m-1;\n                }\n            }\n            else if(A[m].first>a){\n                high = m-1;\n            }\n            else{\n                low = m+1;\n            }\n        }\n        return ans;\n    }\n    ll que(vector <pair<ll,ll>> &A,ll a,ll b){\n        ll x = f1(A,a);\n        ll y = f2(A,a);\n        ll z = f3(A,a,b);\n        if(x==y){\n            return -1;\n        }\n        // cout<<a<<\" \"<<A[x].second<<\" \"<<A[y].second<<\" \"<<A[z].second<<endl;\n        ll k = A.size();\n        if(z==x){\n            return min((A[x+1].second-A[x].second),(k+A[x].second-A[y].second));\n        }\n        if(z==y){\n            return min(A[y].second-A[y-1].second,k+A[x].second-A[y].second);\n        }\n        return min(A[z+1].second-A[z].second,A[z].second-A[z-1].second);\n        \n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector <pair<ll,ll>> A;\n        ll i = 0;\n        for(auto x : nums){\n            A.push_back({x,i});\n            i++;\n        }\n        sort(A.begin(),A.end());\n        vector <ll> ans;\n        for(auto x : queries){\n            ans.push_back(que(A,nums[x],x));\n        }\n        return ans;\n        \n    }\n};","author":"Alok Priydarshi","submissionId":"1575124512"},[]]},{"764":[{"id":"764","fileName":"1575124605.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer,ArrayList<Integer>>hs=new HashMap<>(); int n=nums.length;\n        for(int i=0;i<n;i++){\n            int num=nums[i];\n            if(!hs.containsKey(num))hs.put(num,new ArrayList<>());\n            hs.get(num).add(i);\n        }\n        List<Integer>ans=new ArrayList<>();\n        for(int i=0;i<queries.length;i++){\n            int idx=queries[i];\n            int num=nums[idx];\n            if(hs.get(num).size()==1)ans.add(-1);\n            else{\n                ArrayList<Integer>li=hs.get(num);\n                int rightIdx=0; int leftIdx=0;\n                if(li.get(li.size()-1)==idx){\n                    rightIdx=li.get(0);\n                    leftIdx=li.get(li.size()-2);\n                }\n                else if(li.get(0)==idx){\n                    rightIdx=li.get(1);\n                    leftIdx=li.get(li.size()-1);\n                }\n                else{\n                    int indexOfIdx=solve(li,idx);\n                    rightIdx=li.get(indexOfIdx+1);\n                    leftIdx=li.get(indexOfIdx-1);\n                }\n                //dis\n                int clock=(rightIdx-idx+n)%n;\n                int anticlock=(idx-leftIdx+n)%n;\n                ans.add(Math.min(clock,anticlock));\n            }\n            \n        }\n        return ans;\n    }\n    \n    public int solve(ArrayList<Integer>li,int idx){\n        int low=0; int high=li.size()-1; \n        while(low<=high){\n            int mid=low+(high-low)/2;\n            if(li.get(mid)==idx)return mid;\n            if(li.get(mid)<idx)low=mid+1;\n            else high=mid-1;\n        }\n        return 0;\n    }\n}","author":"tinku_vishnu17","submissionId":"1575124605"},[]]},{"765":[{"id":"765","fileName":"1575124614.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int maxi = 0;\n        int i;\n        for(i=0;i<nums.size();i++){\n            maxi = max(maxi, nums[i]);\n        }\n        vector<int> ind[maxi + 1];\n        for(i=0;i<nums.size();i++){\n            ind[nums[i]].push_back(i);\n        }\n        vector<int> queryAns(queries.size());\n        int index;\n        int mini;\n        int n = nums.size();\n        int val;\n        for(i=0;i<queries.size();i++){\n            val = nums[queries[i]];\n            if(ind[nums[queries[i]]].size() == 1){\n                queryAns[i] = -1;\n            }\n            else{\n                index = lower_bound(ind[val].begin(), ind[val].end(), queries[i]) - ind[val].begin();\n                if(index == 0){\n                    mini = n - ind[val][ind[val].size() - 1] + ind[val][index];\n                }\n                else{\n                    mini = ind[val][index] - ind[val][index - 1];\n                }\n                if(index == (ind[val].size() - 1)){\n                    mini = min(mini, n - ind[val][index] + ind[val][0]);\n                }\n                else{\n                    mini = min(mini, ind[val][index + 1] - ind[val][index]);\n                }\n                queryAns[i] = mini;\n            }\n        }\n        return queryAns;\n    }\n};","author":"Daksh Govani","submissionId":"1575124614"},[]]},{"766":[{"id":"766","fileName":"1575124623.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        unordered_map<int,set<int>> mp;\n        for (int i = 0;i < n;i ++) {\n            mp[nums[i]].insert(i);\n        }\n        vector<int> ans(m, -1);\n        for (int i = 0;i < m;i ++) {\n            if (mp[nums[queries[i]]].size() > 1) {\n                auto it = mp[nums[queries[i]]].find(queries[i]);\n                auto it2 = next(it);\n                if (it2 != mp[nums[queries[i]]].end()) {\n                    ans[i] = (*it2 - *it)%n;\n                } else {\n                    ans[i] = (*mp[nums[queries[i]]].begin() - *mp[nums[queries[i]]].rbegin() + n)%n;\n                }\n                if (it == mp[nums[queries[i]]].begin()) {\n                    ans[i] = min(ans[i] , (*it + n - *mp[nums[queries[i]]].rbegin()) % n); \n                } else {\n                    auto it_prev = prev(it);\n                    //cout << i << \" \" << *it << \" \" << *it_prev << endl;\n                    ans[i] = min(ans[i], (*it - *it_prev + n) % n);\n                }\n            }\n        }\n        return ans;\n    }\n};","author":"fast_turtle","submissionId":"1575124623"},[]]},{"767":[{"id":"767","fileName":"1575124627.txt","sourceCode":"class Solution\n{\npublic:\n    vector<int> solveQueries(vector<int> &nums, vector<int> &queries)\n    {\n        int n = nums.size();\n        unordered_map<int, vector<int>> indices;\n        for (int i = 0; i < nums.size(); i++)\n            indices[nums[i]].push_back(i - n);\n        for (int i = 0; i < nums.size(); i++)\n            indices[nums[i]].push_back(i);\n        for (int i = 0; i < nums.size(); i++)\n            indices[nums[i]].push_back(i + n);\n\n        // for (int i = 0; i < nums.size(); i++)\n        // {\n        //     if (indices[nums[i]].size() == 0)\n        //         continue;\n        //     cout << nums[i] << \" : \";\n        //     for (int j = 0; j < indices[nums[i]].size(); j++)\n        //     {\n        //         cout << indices[nums[i]][j] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n\n        vector<int> res;\n        for (int q : queries)\n        {\n            if (indices[nums[q]].size() == 3)\n            {\n                res.push_back(-1);\n                continue;\n            }\n            auto ub = upper_bound(indices[nums[q]].begin(), indices[nums[q]].end(), q);\n            auto lb = lower_bound(indices[nums[q]].begin(), indices[nums[q]].end(), q);\n            lb--;\n            int ans1 = q - *lb, ans2 = *ub - q;\n            res.push_back(min(ans1, ans2));\n        }\n        return res;\n    }\n};","author":"Aditya Raj","submissionId":"1575124627"},[]]},{"3":[{"id":"3","fileName":"1575080965.txt","sourceCode":"class Solution {\npublic:\nvector<int> solveQueries(vector<int>& nums, vector<int>& qs) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++)\n            mp[nums[i]].push_back(i);\n        for (auto &p : mp)\n            sort(p.second.begin(), p.second.end());\n        vector<int> ans;\n        for (int q : qs) {\n            int v = nums[q];\n            if (mp[v].size() < 2) {\n                ans.push_back(-1);\n                continue;\n            }\n            auto &vec = mp[v];\n            auto it = lower_bound(vec.begin(), vec.end(), q);\n            int pos = it - vec.begin();\n            int nxt = vec[(pos + 1) % vec.size()];\n            int prv = vec[(pos + vec.size() - 1) % vec.size()];\n            int d1 = abs(nxt - q);\n            d1 = min(d1, n - d1);\n            int d2 = abs(prv - q);\n            d2 = min(d2, n - d2);\n            ans.push_back(min(d1, d2));\n        }\n        return ans;\n    }\n};","author":"yuv5120","submissionId":"1575080965"},[{"id":"331","similarity":0.8797814207650273,"totOverlap":161,"longestOverlap":33},{"id":"331","similarity":0.8695652173913043,"totOverlap":160,"longestOverlap":43}]],"5":[{"id":"5","fileName":"1575083922.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> occ;\n        \n        // Build the mapping from value to the indices where it appears.\n        for (int i = 0; i < n; i++) {\n            occ[nums[i]].push_back(i);\n        }\n        \n        // Precompute the minimum distance for each index.\n        vector<int> closest(n, -1);\n        for (auto &entry : occ) {\n            vector<int> &indices = entry.second;\n            if (indices.size() < 2) continue;  // Only one occurrence: answer stays -1.\n            sort(indices.begin(), indices.end());\n            int m = indices.size();\n            for (int i = 0; i < m; i++) {\n                int cur = indices[i];\n                int prev = indices[(i - 1 + m) % m];  // Circular previous.\n                int next = indices[(i + 1) % m];        // Circular next.\n                \n                // Compute circular distances.\n                int d1 = abs(cur - prev);\n                int d2 = abs(next - cur);\n                d1 = min(d1, n - d1);\n                d2 = min(d2, n - d2);\n                closest[cur] = min(d1, d2);\n            }\n        }\n        \n        // Answer each query using the precomputed distances.\n        vector<int> ans;\n        for (int q : queries) {\n            ans.push_back(closest[q]);\n        }\n        return ans;\n    }\n};\n","author":"Testing","submissionId":"1575083922"},[{"id":"473","similarity":1.0,"totOverlap":174,"longestOverlap":87},{"id":"184","similarity":0.9771428571428571,"totOverlap":171,"longestOverlap":28},{"id":"868","similarity":0.7990430622009569,"totOverlap":167,"longestOverlap":28},{"id":"448","similarity":0.8648648648648649,"totOverlap":160,"longestOverlap":40},{"id":"1788","similarity":0.7162790697674418,"totOverlap":154,"longestOverlap":34},{"id":"1311","similarity":0.7475247524752475,"totOverlap":151,"longestOverlap":35},{"id":"868","similarity":0.7211538461538461,"totOverlap":150,"longestOverlap":28},{"id":"184","similarity":0.7019230769230769,"totOverlap":146,"longestOverlap":11}]],"12":[{"id":"12","fileName":"1575086760.txt","sourceCode":"#define vi vector<int>\nclass Solution {\npublic:\n    vi solveQueries(vi &a, vi &q) {\n        int n = a.size();\n        int m = q.size();\n        unordered_map<int, vi> mp;\n\n        for (int i = 0; i < n; i++) \n            mp[a[i]].push_back(i);\n\n        for (auto &p : mp) \n            sort(p.second.begin(), p.second.end());\n\n        vi ans(m, -1);\n\n        for (int i = 0; i < m; i++) {\n            int idx = q[i], v = a[idx];\n            auto &vec = mp[v];\n\n            if (vec.size() == 1) continue; \n\n            int pos = lower_bound(vec.begin(), vec.end(), idx) - vec.begin();\n            int l = vec[(pos + vec.size() - 1) % vec.size()];\n            int r = vec[(pos + 1) % vec.size()];\n\n            int d1 = abs(idx - l), d2 = abs(idx - r);\n            d1 = min(d1, n - d1); \n            d2 = min(d2, n - d2);\n\n            ans[i] = min(d1, d2);\n        }\n\n        return ans;\n    }\n};","author":"Nimish","submissionId":"1575086760"},[{"id":"137","similarity":0.7407407407407407,"totOverlap":140,"longestOverlap":14},{"id":"137","similarity":0.7111111111111111,"totOverlap":128,"longestOverlap":20}]],"37":[{"id":"37","fileName":"1575093690.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& arr, vector<int>& que) {\n        int n = arr.size();\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++)\n            mp[arr[i]].push_back(i);\n        for (auto & pr : mp)\n            sort(pr.second.begin(), pr.second.end());\n        vector<int> ans;\n        for (int x : que) {\n            int v = arr[x];\n            vector<int>& pos = mp[v];\n            if (pos.size() == 1) {\n                ans.push_back(-1);\n            } else {\n                auto it = lower_bound(pos.begin(), pos.end(), x);\n                int idx = it - pos.begin();\n                int d = INT_MAX;\n                int c1 = (idx == pos.size() - 1) ? pos[0] : pos[idx + 1];\n                int d1 = abs(x - c1);\n                d1 = min(d1, n - d1);\n                d = min(d, d1);\n                int c2 = (idx == 0) ? pos.back() : pos[idx - 1];\n                int d2 = abs(x - c2);\n                d2 = min(d2, n - d2);\n                d = min(d, d2);\n                ans.push_back(d);\n            }\n        }\n        return ans;\n    }\n};\n","author":"Ekambareswar","submissionId":"1575093690"},[{"id":"37","similarity":0.7396694214876033,"totOverlap":179,"longestOverlap":17}]],"49":[{"id":"49","fileName":"1575095602.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> valueToIndices;\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            valueToIndices[nums[i]].push_back(i);\n        }\n        for (auto& entry : valueToIndices) {\n            sort(entry.second.begin(), entry.second.end());\n        }\n        \n        vector<int> answer;\n        answer.reserve(queries.size());\n        for (int x : queries) {\n            int val = nums[x];\n            auto& indices = valueToIndices[val];\n            if (indices.size() == 1) {\n                answer.push_back(-1);\n                continue;\n            }\n            auto pos_it = lower_bound(indices.begin(), indices.end(), x);\n            int pos = pos_it - indices.begin();\n            \n            int pre, suc;\n            // Calculate predecessor\n            if (pos > 0) {\n                pre = indices[pos - 1];\n            } else {\n                pre = indices.back();\n            }\n\n            if (pos < indices.size() - 1) {\n                suc = indices[pos + 1];\n            } else {\n                suc = indices[0];\n            }\n            \n            int dist_pre = min(abs(x - pre), n - abs(x - pre));\n            int dist_suc = min(abs(x - suc), n - abs(x - suc));\n            answer.push_back(min(dist_pre, dist_suc));\n        }\n        return answer;\n    }\n};","author":"Yash Chauhan","submissionId":"1575095602"},[{"id":"954","similarity":0.9203980099502488,"totOverlap":185,"longestOverlap":62},{"id":"954","similarity":0.794392523364486,"totOverlap":170,"longestOverlap":33}]],"56":[{"id":"56","fileName":"1575096448.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        \n        int n = a.size();\n        unordered_map<int, vector<int>> mp;\n        \n        for(int i=0;i<n;i++) mp[a[i]].push_back(i);\n        for(auto &p: mp) sort(p.second.begin(), p.second.end());\n        \n        vector<int> ans;\n        for(auto x: q){\n            \n            int v = a[x];\n            auto &idx = mp[v];\n            if(idx.size()==1){ ans.push_back(-1); continue; }\n            int pos = lower_bound(idx.begin(), idx.end(), x) - idx.begin();\n            int a1 = idx[(pos-1+idx.size())%idx.size()], a2 = idx[(pos+1)%idx.size()];\n            int d1 = abs(x - a1), d2 = abs(x - a2);\n            ans.push_back(min(min(d1, n-d1), min(d2, n-d2)));\n            \n        }\n        \n        return ans;\n    }\n};\n","author":"Ronak Gadhiya","submissionId":"1575096448"},[{"id":"56","similarity":0.8546511627906976,"totOverlap":147,"longestOverlap":30}]],"66":[{"id":"66","fileName":"1575097284.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> posMap;\n        for (int i = 0; i < n; i++) {\n            posMap[nums[i]].push_back(i);\n        }\n        for (auto& entry : posMap) {\n            sort(entry.second.begin(), entry.second.end());\n        }\n        auto circularDistance = [&](int i, int j) -> int {\n            int diff = abs(i - j);\n            return min(diff, n - diff);\n        };\n        vector<int> ans;\n        ans.reserve(queries.size());\n\n        for (int idx : queries) {\n            int value = nums[idx];\n            auto& positions = posMap[value];\n\n            if (positions.size() < 2) {\n                ans.push_back(-1);\n                continue;\n            }\n\n            int pos = lower_bound(positions.begin(), positions.end(), idx) - positions.begin();\n            int candidate = INT_MAX;\n\n            if (pos > 0) {\n                candidate = min(candidate, circularDistance(idx, positions[pos - 1]));\n            }\n            if (pos < positions.size() - 1) {\n                candidate = min(candidate, circularDistance(idx, positions[pos + 1]));\n            }\n            if (pos == 0) {\n                candidate = min(candidate, circularDistance(idx, positions.back()));\n            }\n            if (pos == positions.size() - 1) {\n                candidate = min(candidate, circularDistance(idx, positions.front()));\n            }\n\n            ans.push_back(candidate);\n        }\n        return ans;\n    }\n};\n","author":"nadoor_7","submissionId":"1575097284"},[{"id":"149","similarity":0.852017937219731,"totOverlap":190,"longestOverlap":35},{"id":"174","similarity":0.8341013824884793,"totOverlap":181,"longestOverlap":26},{"id":"457","similarity":0.8341013824884793,"totOverlap":181,"longestOverlap":35},{"id":"672","similarity":0.7045454545454546,"totOverlap":155,"longestOverlap":23},{"id":"457","similarity":0.7142857142857143,"totOverlap":145,"longestOverlap":30}]],"68":[{"id":"68","fileName":"1575096761.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> pos;\n        for (int i = 0; i < n; i++) {\n            pos[nums[i]].push_back(i);\n        }\n        for (auto& p : pos) {\n            sort(p.second.begin(), p.second.end());\n        }\n        vector<int> ans;\n        for (int q : queries) {\n            int val = nums[q];\n            auto& indices = pos[val];\n            if (indices.size() < 2) {\n                ans.push_back(-1);\n                continue;\n            }\n            int sz = indices.size();\n            auto it = lower_bound(indices.begin(), indices.end(), q);\n            int indexPos = it - indices.begin();\n            int leftIndex = indices[(indexPos - 1 + sz) % sz];\n            int rightIndex = indices[(indexPos + 1) % sz];\n            int diff1 = abs(q - leftIndex);\n            int diff2 = abs(q - rightIndex);\n            int circ1 = min(diff1, n - diff1);\n            int circ2 = min(diff2, n - diff2);\n            ans.push_back(min(circ1, circ2));\n        }\n        return ans;\n    }\n};","author":"IronSpidy","submissionId":"1575096761"},[{"id":"68","similarity":0.7131147540983607,"totOverlap":174,"longestOverlap":31}]],"71":[{"id":"71","fileName":"1575098145.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n    unordered_map<int, vector<int>> positions;\n    \n    // Store indices for each value in the array.\n    for (int i = 0; i < n; i++) {\n        positions[nums[i]].push_back(i);\n    }\n    // Sort the indices for each value.\n    for (auto &entry : positions) {\n        sort(entry.second.begin(), entry.second.end());\n    }\n    \n    vector<int> ans;\n    // Process each query.\n    for (int q : queries) {\n        int value = nums[q];\n        const auto& posList = positions[value];\n        // If only one occurrence exists, answer is -1.\n        if (posList.size() < 2) {\n            ans.push_back(-1);\n        } else {\n            // Find the position of q in the sorted list.\n            int idx = int(lower_bound(posList.begin(), posList.end(), q) - posList.begin());\n            \n            // Since the list is circular, define neighbors:\n            int leftIdx = (idx - 1 + posList.size()) % posList.size();\n            int rightIdx = (idx + 1) % posList.size();\n            \n            // Helper lambda to compute circular distance.\n            auto circularDistance = [&](int i, int j) {\n                int diff = abs(i - j);\n                return min(diff, n - diff);\n            };\n            \n            int d1 = circularDistance(q, posList[leftIdx]);\n            int d2 = circularDistance(q, posList[rightIdx]);\n            ans.push_back(min(d1, d2));\n        }\n    }\n    return ans;\n    }\n};","author":"Praneeth","submissionId":"1575098145"},[{"id":"71","similarity":0.8648648648648649,"totOverlap":160,"longestOverlap":34}]],"73":[{"id":"73","fileName":"1575098353.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> occ;\n        for (int i = 0; i < n; i++){\n            occ[nums[i]].push_back(i);\n        }\n        for (auto &p : occ) {\n            sort(p.second.begin(), p.second.end());\n        }\n        vector<int> res;\n        for (int q : queries) {\n            int v = nums[q];\n            auto &vec = occ[v];\n            if(vec.size() < 2){\n                res.push_back(-1);\n                continue;\n            }\n            int candidate = INT_MAX;\n            auto it = lower_bound(vec.begin(), vec.end(), q);\n            if(it != vec.end() && *it == q){\n                if(it + 1 != vec.end())\n                    candidate = min(candidate, (*(it+1) - q));\n                if(it != vec.begin())\n                    candidate = min(candidate, (q - *(it-1)));\n            } else {\n                if(it != vec.end())\n                    candidate = min(candidate, (*it - q));\n                if(it != vec.begin())\n                    candidate = min(candidate, (q - *(it-1)));\n            }\n            candidate = min(candidate, (q + n - vec.back()));\n            candidate = min(candidate, (vec.front() + n - q));\n            res.push_back(candidate);\n        }\n        return res;\n    }\n};","author":"I_Love_Ginger","submissionId":"1575098353"},[{"id":"73","similarity":0.7031963470319634,"totOverlap":154,"longestOverlap":30}]],"111":[{"id":"111","fileName":"1575101011.txt","sourceCode":"#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    void preprocess(vector<int>& a, unordered_map<int, vector<int>>& m) {\n        for (int i = 0; i < a.size(); i++) {\n            m[a[i]].push_back(i);\n        }\n    }\n    \n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        int n = a.size();\n        vector<int> res(q.size(), -1);\n        unordered_map<int, vector<int>> m;\n        preprocess(a, m);\n        \n        for (int i = 0; i < q.size(); i++) {\n            int idx = q[i];\n            int v = a[idx];\n            auto& indices = m[v];\n            if (indices.size() == 1) {\n                continue;\n            }\n            \n            int k = indices.size();\n            auto it = lower_bound(indices.begin(), indices.end(), idx);\n            int pos = it - indices.begin();\n            \n            int prev_pos = (pos - 1 + k) % k;\n            int next_pos = (pos + 1) % k;\n            \n            int prev_idx = indices[prev_pos];\n            int next_idx = indices[next_pos];\n            \n            int d1 = abs(idx - prev_idx);\n            d1 = min(d1, n - d1);\n            \n            int d2 = abs(next_idx - idx);\n            d2 = min(d2, n - d2);\n            \n            res[i] = min(d1, d2);\n        }\n        \n        return res;\n    }\n};","author":"Angshuman_Chh","submissionId":"1575101011"},[{"id":"111","similarity":0.7882882882882883,"totOverlap":175,"longestOverlap":28}]],"112":[{"id":"112","fileName":"1575101327.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        int n = a.size();\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[a[i]].push_back(i);\n        }\n        for (auto &p : mp) {\n            sort(p.second.begin(), p.second.end());\n        }\n        \n        vector<int> ans;\n        for (int i : q) {\n            int val = a[i];\n            vector<int>& v = mp[val];\n            if (v.size() < 2) {\n                ans.push_back(-1);\n                continue;\n            }\n            \n            auto it = lower_bound(v.begin(), v.end(), i);\n            int d = INT_MAX;\n            \n            if (it != v.begin()) {\n                int l = *(it - 1);\n                int diff = abs(l-i);\n                diff = min(diff, n - diff);\n                d = min(diff,d);\n            } else {\n                int l = v[v.size()-1];\n                int diff = abs(l-i);\n                diff = min(diff, n - diff);\n                d = min(diff,d);\n            }\n            \n            if (it != v.end() - 1) {\n                int r = *(it + 1);\n                int diff = abs(r-i);\n                diff = min(diff,n-diff);\n                d = min(diff,d);\n            } else {\n                int r = v[0];\n                int diff = abs(r-i);\n                diff = min(diff, n - diff);\n                d = min(d, diff);\n            }\n            \n            ans.push_back(d);\n        }\n        return ans;\n    }\n};","author":"Shrey Bansal","submissionId":"1575101327"},[{"id":"112","similarity":0.8351648351648352,"totOverlap":228,"longestOverlap":23}]],"117":[{"id":"117","fileName":"1575101143.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int, vector<int>> pos;\n        \n        for(int i = 0; i < n; i++) {\n            pos[nums[i]].push_back(i);\n        }\n\n        for(auto &p : pos) {\n            sort(p.second.begin(), p.second.end());\n        }\n        \n        vector<int> ans;\n        for (auto q : queries) {\n            int x = nums[q];\n            vector<int>& p = pos[x];\n            if (p.size() == 1) {\n                ans.push_back(-1);\n            } else {\n                auto it = lower_bound(p.begin(), p.end(), q);\n                int idx = it - p.begin();\n                int prev = (idx == 0) ? p.back() : p[idx - 1];\n                int now = (idx == p.size() - 1) ? p.front() : p[idx + 1];\n                \n                int d1 = abs(q - prev);\n                d1 = min(d1, n - d1);\n                int d2 = abs(now - q);\n                d2 = min(d2, n - d2);\n                \n                ans.push_back(min(d1, d2));\n            }\n        }\n        return ans;\n    }\n};","author":"NityaJangra","submissionId":"1575101143"},[{"id":"117","similarity":0.7165354330708661,"totOverlap":182,"longestOverlap":31}]],"126":[{"id":"126","fileName":"1575101900.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> positions;\n        \n        for (int i = 0; i < n; ++i) {\n            positions[nums[i]].push_back(i);\n        }\n        \n        // For each unique number, ensure the indices are sorted.\n        for (auto &entry : positions) {\n            sort(entry.second.begin(), entry.second.end());\n        }\n        \n        vector<int> ans;\n        for (int q : queries) {\n            int num = nums[q];\n            vector<int>& indices = positions[num];\n            \n            if (indices.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            \n            auto it = lower_bound(indices.begin(), indices.end(), q);\n            int pos = it - indices.begin();\n            \n            int prev_index = (pos > 0) ? indices[pos - 1] : indices.back();\n            int next_index = (pos + 1 < indices.size()) ? indices[pos + 1] : indices.front();\n            \n            int d1 = min(abs(q - prev_index), n - abs(q - prev_index));\n            int d2 = min(abs(q - next_index), n - abs(q - next_index));\n            \n            ans.push_back(min(d1, d2));\n        }\n        \n        return ans;\n    }\n};","author":"Navdeep Rathore","submissionId":"1575101900"},[{"id":"126","similarity":0.7604166666666666,"totOverlap":146,"longestOverlap":22}]],"137":[{"id":"137","fileName":"1575102746.txt","sourceCode":"class Solution{\npublic:\n    vector<int> solveQueries(vector<int>& a,vector<int>& q){\n        int n=a.size(),m=q.size();\n        unordered_map<int,vector<int>> mp;\n        for(int i=0;i<n;i++) mp[a[i]].push_back(i);\n        for(auto &p:mp) sort(p.second.begin(),p.second.end());\n        vector<int> ans(m);\n        for(int i=0;i<m;i++){\n            int idx=q[i],v=a[idx];\n            auto &vec=mp[v];\n            if(vec.size()<2){ans[i]=-1;continue;}\n            int pos=lower_bound(vec.begin(),vec.end(),idx)-vec.begin();\n            int nxt=vec[(pos+1)%vec.size()],prev=vec[(pos+vec.size()-1)%vec.size()];\n            int d1=min(abs(nxt-idx),n-abs(nxt-idx));\n            int d2=min(abs(idx-prev),n-abs(idx-prev));\n            ans[i]=min(d1,d2);\n        }\n        return ans;\n    }\n};\n","author":"Srivatsan B","submissionId":"1575102746"},[{"id":"12","similarity":0.7407407407407407,"totOverlap":140,"longestOverlap":14}]],"149":[{"id":"149","fileName":"1575103230.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> occ;\n        for (int i = 0; i < n; i++) {\n            occ[nums[i]].push_back(i);\n        }\n        for (auto &p : occ) {\n            sort(p.second.begin(), p.second.end());\n        }\n        auto circularDist = [&](int i, int j) {\n            int diff = abs(i - j);\n            return min(diff, n - diff);\n        };\n        vector<int> ans;\n        for (int q : queries) {\n            int val = nums[q];\n            auto &indices = occ[val];\n            if (indices.size() < 2) {\n                ans.push_back(-1);\n                continue;\n            }\n            int best = n;\n            auto pos = lower_bound(indices.begin(), indices.end(), q);\n            \n            if (pos != indices.begin()) {\n                best = min(best, circularDist(q, *(pos - 1)));\n            }\n            if (pos + 1 != indices.end()) {\n                best = min(best, circularDist(q, *(pos + 1)));\n            }\n            // circular ke liye\n            if (pos == indices.begin()) {\n                best = min(best, circularDist(q, indices.back()));\n            }\n            if (pos == indices.end() - 1) {\n                best = min(best, circularDist(q, indices.front()));\n            }\n            ans.push_back(best);\n        }\n        return ans;\n    }\n};\n","author":"Tanmay Singh","submissionId":"1575103230"},[{"id":"66","similarity":0.852017937219731,"totOverlap":190,"longestOverlap":35}]],"160":[{"id":"160","fileName":"1575104012.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n         int n = nums.size();\n        \n        unordered_map<int, vector<int>> occ;\n        for (int i = 0; i < n; i++) {\n            occ[nums[i]].push_back(i);\n        }\n      \n        vector<int> ansForIndex(n, -1);\n        for (auto &p : occ) {\n            vector<int>& pos = p.second;\n           \n            if (pos.size() < 2) continue;\n            \n            sort(pos.begin(), pos.end());\n            int k = pos.size();\n            \n            for (int i = 0; i < k; i++) {\n                int curr = pos[i];\n               \n                int next = pos[(i + 1) % k];\n               \n                int prev = pos[(i - 1 + k) % k];\n                \n               \n                int dNext = (i == k - 1) ? (n - curr + pos[0]) : (next - curr);\n                int dPrev = (i == 0) ? (curr + (n - pos[k - 1])) : (curr - prev);\n                ansForIndex[curr] = min(dNext, dPrev);\n            }\n        }\n        \n       \n        vector<int> answer;\n        for (int idx : queries) {\n            answer.push_back(ansForIndex[idx]);\n        }\n        return answer;\n    }\n};","author":"Uttam Rai","submissionId":"1575104012"},[{"id":"160","similarity":0.7211538461538461,"totOverlap":150,"longestOverlap":28}]],"173":[{"id":"173","fileName":"1575104405.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        \n        for(int i = 0; i < n; i++){\n            mp[nums[i]].push_back(i);\n        }\n        \n        for(auto &p : mp){\n            sort(p.second.begin(), p.second.end());\n        }\n        \n        vector<int> ans;\n        ans.reserve(queries.size());\n        for(int idx : queries){\n            int value = nums[idx];\n            const vector<int>& pos = mp[value];\n            \n            if(pos.size() == 1){\n                ans.push_back(-1);\n                continue;\n            }\n            \n            auto it = lower_bound(pos.begin(), pos.end(), idx);\n            int posIndex = it - pos.begin();\n            \n            int leftIdx = pos[(posIndex - 1 + pos.size()) % pos.size()];\n            int rightIdx = pos[(posIndex + 1) % pos.size()];\n            \n            int d1 = abs(idx - leftIdx);\n            int d2 = abs(idx - rightIdx);\n            int dist1 = min(d1, n - d1);\n            int dist2 = min(d2, n - d2);\n            \n            ans.push_back(min(dist1, dist2));\n        }\n        \n        return ans;\n    }\n};\n","author":"baliramkumar","submissionId":"1575104405"},[{"id":"173","similarity":0.9585492227979274,"totOverlap":185,"longestOverlap":47}]],"174":[{"id":"174","fileName":"1575104334.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n\n        vector<int> res;\n        auto circularDist = [&](int a, int b) -> int {\n            int diff = abs(a - b);\n            return min(diff, n - diff);\n        };\n        for (int q : queries) {\n            int val = nums[q];\n            auto &v = mp[val];\n            if (v.size() == 1) {\n                res.push_back(-1);\n            } else {\n                int pos = lower_bound(v.begin(), v.end(), q) - v.begin();\n                int m = INT_MAX;\n                if (pos > 0) {\n                    m = min(m, circularDist(q, v[pos - 1]));\n                }\n                if (pos < v.size()-1) {\n                    m = min(m, circularDist(q, v[pos + 1]));\n                }\n                if (v[0] == q)\n                    m = min(m, circularDist(q, v.back()));\n                if (v.back() == q)\n                    m = min(m, circularDist(q, v[0]));\n                res.push_back(m);\n            }\n        }\n        return res;\n    }\n};\n","author":"Giriraj bidwai","submissionId":"1575104334"},[{"id":"66","similarity":0.8341013824884793,"totOverlap":181,"longestOverlap":26}]],"184":[{"id":"184","fileName":"1575105025.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> min_dist(n, -1);\n        unordered_map<int, vector<int>> positions;\n        for (int i = 0; i < n; i++) {\n            positions[nums[i]].push_back(i);\n        }\n        for (auto &entry : positions) {\n            vector<int>& inds = entry.second;\n            if (inds.size() <= 1) continue;\n            sort(inds.begin(), inds.end());\n            int k = inds.size();\n            for (int i = 0; i < k; i++) {\n                int pos = inds[i];\n                int next_pos = inds[(i + 1) % k];\n                int prev_pos = inds[(i - 1 + k) % k];\n                int d1 = abs(pos - next_pos);\n                d1 = min(d1, n - d1);\n                int d2 = abs(pos - prev_pos);\n                d2 = min(d2, n - d2);\n                min_dist[pos] = min(d1, d2);\n            }\n        }\n        vector<int> answer;\n        for (int q : queries) {\n            answer.push_back(min_dist[q]);\n        }\n        return answer;\n    }\n};\n","author":"Abhay_230904","submissionId":"1575105025"},[{"id":"974","similarity":0.9720670391061452,"totOverlap":174,"longestOverlap":54},{"id":"5","similarity":0.9771428571428571,"totOverlap":171,"longestOverlap":28}]],"186":[{"id":"186","fileName":"1575104891.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = (int)nums.size();\n        \n        // Build a map: value -> sorted list of positions where that value appears\n        unordered_map<int, vector<int>> pos;\n        pos.reserve(n);\n        for (int i = 0; i < n; i++) {\n            pos[nums[i]].push_back(i);\n        }\n        for (auto &p : pos) {\n            sort(p.second.begin(), p.second.end());\n        }\n\n        // Helper for circular distance in a length-n array\n        auto circularDist = [&](int i, int j) {\n            int d = abs(i - j);\n            return min(d, n - d);\n        };\n\n        vector<int> ans(queries.size(), -1);\n        for (int i = 0; i < (int)queries.size(); i++) {\n            int q = queries[i];          // the index in nums\n            int val = nums[q];           // the value at that index\n            auto &positions = pos[val];  // all occurrences of val\n\n            // If there's only 1 occurrence of val, no other index matches\n            if (positions.size() < 2) {\n                ans[i] = -1;\n                continue;\n            }\n\n            // Find q's position in positions[] using binary search\n            // lower_bound gives us the first place where q could go\n            int idx = (int)(std::lower_bound(positions.begin(),\n                                             positions.end(),\n                                             q) \n                            - positions.begin());\n\n            // positions[idx] should be exactly q (since q is in that list).\n            // Next and previous occurrences, wrapping around the vector\n            int nextIdx = (idx + 1) % positions.size();\n            int prevIdx = (idx + (int)positions.size() - 1) % positions.size();\n\n            // Compute the circular distances from q to these neighbors\n            int distNext = circularDist(q, positions[nextIdx]);\n            int distPrev = circularDist(q, positions[prevIdx]);\n            ans[i] = min(distNext, distPrev);\n        }\n        return ans;\n    }\n};\n\n","author":"ItsMe","submissionId":"1575104891"},[{"id":"977","similarity":0.9070796460176991,"totOverlap":205,"longestOverlap":52},{"id":"874","similarity":0.7004608294930875,"totOverlap":152,"longestOverlap":14}]],"189":[{"id":"189","fileName":"1575105280.txt","sourceCode":"#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> idx_map;\n        int len = nums.size();\n        for (int i = 0; i < len; ++i) {\n            idx_map[nums[i]].push_back(i);\n        }\n        \n        vector<int> res;\n        for (int q : queries) {\n            int val = nums[q];\n            auto& idx_list = idx_map[val];\n            if (idx_list.size() == 1) {\n                res.push_back(-1);\n                continue;\n            }\n            auto it = lower_bound(idx_list.begin(), idx_list.end(), q);\n            int pos = it - idx_list.begin();\n            int n = idx_list.size();\n            int prev_idx = (pos - 1 + n) % n;\n            int next_idx = (pos + 1) % n;\n            int cand1 = idx_list[prev_idx];\n            int cand2 = idx_list[next_idx];\n            \n            int diff1 = abs(q - cand1);\n            int dist1 = min(diff1, len - diff1);\n            int diff2 = abs(q - cand2);\n            int dist2 = min(diff2, len - diff2);\n            \n            res.push_back(min(dist1, dist2));\n        }\n        return res;\n    }\n};\n","author":"Ayush Shahi","submissionId":"1575105280"},[{"id":"189","similarity":0.7307692307692307,"totOverlap":171,"longestOverlap":21}]],"190":[{"id":"190","fileName":"1575105136.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = (int)nums.size();\n        \n        unordered_map<int, vector<int>> indexMap;\n        indexMap.reserve(n);\n        for(int i = 0; i < n; i++){\n            indexMap[nums[i]].push_back(i);\n        }\n        for(auto &kv : indexMap){\n            sort(kv.second.begin(), kv.second.end());\n        }\n        \n        vector<int> ans;\n        ans.reserve(queries.size());\n        \n        for(int q : queries){\n            int val = nums[q];\n            if(indexMap[val].size() < 2){\n                ans.push_back(-1);\n                continue;\n            }\n            \n            auto &positions = indexMap[val];\n            int idx = (int)(std::lower_bound(positions.begin(), positions.end(), q) \n                            - positions.begin());\n            \n            int nextIdx = (idx + 1) % positions.size();\n            int prevIdx = (idx - 1 + positions.size()) % positions.size();\n            \n            auto circularDist = [&](int a, int b){\n                int direct = abs(a - b);\n                return min(direct, n - direct);\n            };\n            \n            int distNext = circularDist(positions[nextIdx], q);\n            int distPrev = circularDist(positions[prevIdx], q);\n            \n            int minDist = min(distNext, distPrev);\n            ans.push_back(minDist);\n        }\n        \n        return ans;\n    }\n};","author":"ChY","submissionId":"1575105136"},[{"id":"186","similarity":0.7061611374407583,"totOverlap":149,"longestOverlap":32}]],"196":[{"id":"196","fileName":"1575105537.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        int n = a.size();\n        unordered_map<int, vector<int>> m;\n        for(int i = 0; i < n; i++) {\n            m[a[i]].push_back(i);\n        }\n        vector<int> ans;\n        ans.reserve(q.size());\n        \n        for(int x : q) {\n            int v = a[x];\n            auto &vec = m[v];\n            if(vec.size() < 2) {\n                ans.push_back(-1);\n                continue;\n            }\n            int dmin = n;\n            auto it = lower_bound(vec.begin(), vec.end(), x);\n            if(it != vec.end() && *it == x) {\n                if(it + 1 != vec.end()) {\n                    int d = abs(x - *(it + 1));\n                    dmin = min(dmin, min(d, n - d));\n                }\n                if(it != vec.begin()) {\n                    int d = abs(x - *(it - 1));\n                    dmin = min(dmin, min(d, n - d));\n                }\n            }\n            if(vec.front() != x) {\n                int d = abs(x - vec.front());\n                dmin = min(dmin, min(d, n - d));\n            }\n            if(vec.back() != x) {\n                int d = abs(x - vec.back());\n                dmin = min(dmin, min(d, n - d));\n            }\n            ans.push_back(dmin);\n        }\n        return ans;\n    }\n};\n\n/**\n * Variables:\n * a    : Circular array of integers.\n * q    : Array of query indices.\n * n    : Size of the array 'a'.\n * m    : Hash map mapping each integer in 'a' to a vector of its indices.\n * ans  : Vector storing the answer for each query.\n * x    : Current query index from 'q'.\n * v    : Value at index 'x' in array 'a'.\n * vec  : Vector of indices where value 'v' appears in 'a'.\n * it   : Iterator to position in 'vec' corresponding to index 'x' (found using lower_bound).\n * dmin : Minimum circular distance for the current query.\n * d    : Temporary variable representing distance between indices.\n */\n","author":"SA_Shukla","submissionId":"1575105537"},[{"id":"196","similarity":0.7378277153558053,"totOverlap":197,"longestOverlap":55}]],"210":[{"id":"210","fileName":"1575105594.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> occ;\n        for (int i = 0; i < n; i++) {\n            occ[nums[i]].push_back(i);\n        }\n        for (auto &p : occ) {\n            sort(p.second.begin(), p.second.end());\n        }\n        \n        vector<int> ans;\n        for (int q : queries) {\n            int val = nums[q];\n            auto &v = occ[val];\n            if (v.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            int pos = int(lower_bound(v.begin(), v.end(), q) - v.begin());\n            int k = v.size();\n            int left = v[(pos - 1 + k) % k];\n            int right = v[(pos + 1) % k];\n            auto dist = [&](int a, int b) {\n                int d = abs(a - b);\n                return min(d, n - d);\n            };\n            ans.push_back(min(dist(q, left), dist(q, right)));\n        }\n        return ans;\n    }\n};\n","author":"Divyansh Deshmukh","submissionId":"1575105594"},[{"id":"210","similarity":0.8305084745762712,"totOverlap":147,"longestOverlap":34}]],"228":[{"id":"228","fileName":"1575106631.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<int> res(m, -1);\n        unordered_map<int, vector<int>> mp;\n        \n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        \n        for (int i = 0; i < m; i++) {\n            int idx = queries[i];\n            int val = nums[idx];\n            vector<int>& vec = mp[val];\n            if (vec.size() < 2) { \n                res[i] = -1;\n                continue;\n            }\n\n            auto it = lower_bound(vec.begin(), vec.end(), idx);\n            int pos = it - vec.begin();\n            \n\n            int nextPos = (pos + 1) % vec.size();\n            int prevPos = (pos - 1 + vec.size()) % vec.size();\n            int nextIdx = vec[nextPos];\n            int prevIdx = vec[prevPos];\n            \n            int d1 = abs(idx - nextIdx);\n            d1 = min(d1, n - d1);\n            int d2 = abs(idx - prevIdx);\n            d2 = min(d2, n - d2);\n            res[i] = min(d1, d2);\n        }\n        return res;\n    }\n};\n","author":"xymabinogi","submissionId":"1575106631"},[{"id":"1918","similarity":0.8349056603773585,"totOverlap":177,"longestOverlap":29},{"id":"228","similarity":0.7787610619469026,"totOverlap":176,"longestOverlap":19}]],"230":[{"id":"230","fileName":"1575106826.txt","sourceCode":"class Solution {\npublic:\n  vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n    map<int, vector<int>> a;\n    int n = nums.size();\n    for (int i = 0; i < n; ++i) a[nums[i]].push_back(i);\n    vector<int> ret;\n    for (int i : queries) {\n      int x = nums[i];\n      const auto& v = a[x];\n      if (v.size() > 1) {\n        int u = lower_bound(v.begin(), v.end(), i) - v.begin();\n        int u1 = (u + v.size() - 1) % v.size(), u2 = (u + 1) % v.size();\n        int d1 = abs(v[u] - v[u1]), d2 = abs(v[u] - v[u2]);\n        d1 = min(d1, n - d1);\n        d2 = min(d2, n - d2);\n        ret.push_back(min(d1, d2));\n      } else {\n        ret.push_back(-1);\n      }\n    }\n    return ret;\n  }\n};","author":"Neal@阳谷县","submissionId":"1575106826"},[{"id":"230","similarity":0.7142857142857143,"totOverlap":120,"longestOverlap":13}]],"238":[{"id":"238","fileName":"1575107042.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n         int n = nums.size();\n        unordered_map<int, vector<int>> pos;\n        for (int i = 0; i < n; i++) {\n            pos[nums[i]].push_back(i);\n        }\n        for (auto& p : pos) {\n            sort(p.second.begin(), p.second.end());\n        }\n        \n        vector<int> ans;\n        for (int q : queries) {\n            int val = nums[q];\n            const vector<int>& indices = pos[val];\n            if (indices.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            int idx = lower_bound(indices.begin(), indices.end(), q) - indices.begin();\n            int leftIdx = (idx - 1 + indices.size()) % indices.size();\n            int rightIdx = (idx + 1) % indices.size();\n            int d1 = abs(q - indices[leftIdx]);\n            int d2 = abs(q - indices[rightIdx]);\n            int dist1 = min(d1, n - d1);\n            int dist2 = min(d2, n - d2);\n            ans.push_back(min(dist1, dist2));\n        }\n        return ans;\n    }\n};","author":"UJ_026","submissionId":"1575107042"},[{"id":"238","similarity":0.7327586206896551,"totOverlap":170,"longestOverlap":37}]],"250":[{"id":"250","fileName":"1575107521.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> position;\n        vector<int> adar(n);\n        \n        for (int i = 0; i < n; i++) {\n            int v = nums[i];\n            position[v].push_back(i);\n            adar[i] = position[v].size() - 1;\n        }\n        \n        vector<int> ans;\n        for (int q : queries) {\n            int v = nums[q];\n            auto &vec = position[v];\n            if (vec.size() == 1) {\n                ans.push_back(-1);\n            } else {\n                int posIndex = adar[q];\n                int leftIndex = vec[(posIndex - 1 + vec.size()) % vec.size()];\n                int rightIndex = vec[(posIndex + 1) % vec.size()];\n                int d1 = abs(q - leftIndex);\n                int d2 = abs(rightIndex - q);\n                d1 = min(d1, n - d1);\n                d2 = min(d2, n - d2);\n                ans.push_back(min(d1, d2));\n            }\n        }\n        return ans;\n    }\n};\n","author":"adarsh","submissionId":"1575107521"},[{"id":"250","similarity":0.7016574585635359,"totOverlap":127,"longestOverlap":34}]],"258":[{"id":"258","fileName":"1575108151.txt","sourceCode":"class Solution {\npublic:\n    int cir_dis(int i, int j, int n) {\n        int d = abs(i - j);\n        return min(d, n - d);\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        for (auto &p : mp) {\n            sort(p.second.begin(), p.second.end());\n        }\n        vector<int> ans;\n        for (int q : queries) {\n            int val = nums[q];\n            auto &v = mp[val];\n            if (v.size() == 1) {\n                ans.push_back(-1);\n            } else {\n                int pos = lower_bound(v.begin(), v.end(), q) - v.begin();\n                int left = (pos - 1 + v.size()) % v.size();\n                int right = (pos + 1) % v.size();\n                int d1 = cir_dis(q, v[left], n);\n                int d2 = cir_dis(q, v[right], n);\n                ans.push_back(min(d1, d2));\n            }\n        }\n        return ans;\n    }\n};\n","author":"SRIRAM G","submissionId":"1575108151"},[{"id":"847","similarity":0.8663101604278075,"totOverlap":162,"longestOverlap":34},{"id":"258","similarity":0.8648648648648649,"totOverlap":160,"longestOverlap":34},{"id":"173","similarity":0.7989690721649485,"totOverlap":155,"longestOverlap":29}]],"271":[{"id":"271","fileName":"1575108873.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int> &nums, vector<int> &queries) {\n        int n = nums.size();\n        map<int, vector<int>> indices;\n\n        for (int i = 0; i < n; ++i) {\n            indices[nums[i]].push_back(i);\n        }\n\n        vector<int> ans;\n        auto calc=[&](int i,int j)->int{\n            int d=abs(i-j);\n            return min(d,n-d);\n        };\n        for (int query: queries) {\n            int tar = nums[query];\n            if (indices[tar].size() <= 1) {\n                ans.push_back(-1);\n                continue;\n            }\n\n            auto &id = indices[tar];\n            auto it = lower_bound(id.begin(), id.end(), query);\n            int idx=it-id.begin();\n            int m=id.size();\n            int prv=id[(idx-1+m)%m];\n            int nxt=id[(idx+1)%m];\n            int mn = min(calc(prv,query),calc(nxt,query));\n            ans.emplace_back(mn);\n        }\n\n        return ans;\n    }\n};","author":"Ahmed_Ashraf","submissionId":"1575108873"},[{"id":"271","similarity":0.7431693989071039,"totOverlap":136,"longestOverlap":32}]],"286":[{"id":"286","fileName":"1575109913.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int, vector<int>> indMap;\n\n        for (int i = 0; i < n; i++) {\n            indMap[nums[i]].push_back(i);\n        }\n\n        for (auto& it : indMap) {\n            sort(it.second.begin(), it.second.end());\n        }\n\n        vector<int> ans;\n        ans.reserve(queries.size());\n\n        for (int q : queries) {\n            int v = nums[q];\n            const auto& pos = indMap[v];\n\n            if (pos.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n\n            int mini = n;\n            auto it = lower_bound(pos.begin(), pos.end(), q);\n            int index = it - pos.begin();\n\n            if (index > 0) {\n                int d = q - pos[index - 1];\n                mini = min(mini, min(d, n - d));\n            }\n            if (index < pos.size() - 1) {\n                int d = pos[index + 1] - q;\n                mini = min(mini, min(d, n - d));\n            }\n            if (index == 0) {\n                int d = q + n - pos.back();\n                mini = min(mini, min(d, n - d));\n            }\n            if (index == pos.size() - 1) {\n                int d = pos.front() + n - q;\n                mini = min(mini, min(d, n - d));\n            }\n            ans.push_back(mini);\n        }\n        return ans;\n    }\n};\n","author":"shubhhh_02","submissionId":"1575109913"},[{"id":"196","similarity":0.7031963470319634,"totOverlap":154,"longestOverlap":23}]],"295":[{"id":"295","fileName":"1575110173.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> mp;\n        int n=nums.size();\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for( auto i : queries){\n            int val = nums[i];\n            auto &a = mp[val];\n            if (a.size() < 2) {\n                ans.push_back(-1);\n                continue;\n            }\n            auto it = lower_bound(a.begin(), a.end(), i);\n            int x = it - a.begin();\n            int leftIndex = (x == 0) ? a.back() : a[x - 1];\n            int rightIndex = (x == a.size() - 1) ? a.front() : a[x + 1];\n            int dLeft = abs(i - leftIndex);\n            int dRight = abs(i - rightIndex);\n            int circLeft = min(dLeft, n - dLeft);\n            int circRight = min(dRight, n - dRight);\n            \n            ans.push_back(min(circLeft, circRight));\n        }\n        return ans;\n        }\n};","author":"diyashah2904","submissionId":"1575110173"},[{"id":"117","similarity":0.8087431693989071,"totOverlap":148,"longestOverlap":30}]],"309":[{"id":"309","fileName":"1575110730.txt","sourceCode":"class Solution {\npublic:\n    int dis(int currIndex, int otherIndex, int n) {\n        if (currIndex>otherIndex) {\n            return dis(otherIndex, currIndex, n);\n        }\n        int d = otherIndex-currIndex;\n        return min(d, n-d);\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> mp;\n        int n = nums.size();\n        for (int i=0; i<n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for (int q: queries) {\n            vector<int> &v = mp[nums[q]];\n            if (v.size()==1) {\n                ans.push_back(-1);continue;\n            }\n            int m = v.size();\n            int currIndex = lower_bound(v.begin(), v.end(), q)-v.begin();\n            int nextIndex = v[(currIndex+1)%m];\n            int prevIndex = v[(currIndex-1+m)%m];\n            // cout<<currIndex<<\" \"<<\n            ans.push_back(min(dis(q, nextIndex, n), dis(q, prevIndex, n)));\n        }\n        return ans;\n    }\n};","author":"codeforpurpose","submissionId":"1575110730"},[{"id":"309","similarity":0.7528735632183908,"totOverlap":131,"longestOverlap":9}]],"312":[{"id":"312","fileName":"1575110779.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> posMap;\n        \n        for (int i = 0; i < n; i++) {\n            posMap[nums[i]].push_back(i);\n        }\n        for (auto& kv : posMap) {\n            sort(kv.second.begin(), kv.second.end());\n        }\n        \n        vector<int> ans;\n        auto circularDistance = [&](int a, int b) {\n            int diff = abs(a - b);\n            return min(diff, n - diff);\n        };\n        \n        for (int q : queries) {\n            int val = nums[q];\n            vector<int>& positions = posMap[val];\n            \n            if (positions.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            \n            int idx = lower_bound(positions.begin(), positions.end(), q) - positions.begin();\n            \n            int prevIndex = (idx == 0) ? positions.back() : positions[idx - 1];\n            int nextIndex = (idx == positions.size() - 1) ? positions[0] : positions[idx + 1];\n            \n            int d1 = circularDistance(q, prevIndex);\n            int d2 = circularDistance(q, nextIndex);\n            \n            ans.push_back(min(d1, d2));\n        }\n        \n        return ans;\n    }\n};\n","author":"Rugved Kulkarni","submissionId":"1575110779"},[{"id":"312","similarity":0.8350515463917526,"totOverlap":162,"longestOverlap":61}]],"328":[{"id":"328","fileName":"1575111636.txt","sourceCode":"class Solution {\npublic:\n    int circularDistance(int i, int j, int n) {\n        int diff = abs(i - j);\n        return min(diff, n - diff);\n    }\n\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> ind;\n\n        for (int i = 0; i < n; ++i) {\n            ind[nums[i]].push_back(i);\n        }\n        for (auto& entry : ind) {\n            sort(entry.second.begin(), entry.second.end());\n        }\n\n        vector<int> ans;\n        ans.reserve(queries.size());\n\n        for (int q : queries) {\n            int value = nums[q];\n            const vector<int>& pos = ind[value];\n\n            if (pos.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n\n            auto it = lower_bound(pos.begin(), pos.end(), q);\n            int idx = it - pos.begin();\n            int k = pos.size();\n\n            int prev = pos[(idx - 1 + k) % k];\n            int next = pos[(idx + 1) % k];\n\n            int d1 = circularDistance(q, prev, n);\n            int d2 = circularDistance(q, next, n);\n\n            ans.push_back(min(d1, d2));\n        }\n        return ans;\n    }\n};","author":"SAAHIL AV","submissionId":"1575111636"},[{"id":"721","similarity":0.9086021505376344,"totOverlap":169,"longestOverlap":41},{"id":"173","similarity":0.8195876288659794,"totOverlap":159,"longestOverlap":60}]],"331":[{"id":"331","fileName":"1575111803.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++)\n            mp[nums[i]].push_back(i);\n            \n        for (auto &p : mp)\n            sort(p.second.begin(), p.second.end());\n            \n        vector<int> ans;\n        for (int q : queries) {\n            int v = nums[q];\n            vector<int>& pos = mp[v];\n            if (pos.size() == 1)\n                ans.push_back(-1);\n            else {\n                auto it = lower_bound(pos.begin(), pos.end(), q);\n                int idx = it - pos.begin();\n                int a = pos[(idx + 1) % pos.size()];\n                int b = pos[(idx + pos.size() - 1) % pos.size()];\n                int d1 = abs(q - a), d2 = abs(q - b);\n                d1 = min(d1, n - d1);\n                d2 = min(d2, n - d2);\n                ans.push_back(min(d1, d2));\n            }\n        }\n        return ans;\n    }\n};","author":"Amjad Imran","submissionId":"1575111803"},[{"id":"3","similarity":0.8797814207650273,"totOverlap":161,"longestOverlap":33}]],"350":[{"id":"350","fileName":"1575112494.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> positions;\n        for (int i = 0; i < n; i++) {\n            positions[nums[i]].push_back(i);\n        }\n        \n        vector<int> best(n, -1);\n        \n        for (auto& kv : positions) {\n            auto& idxs = kv.second;\n            if (idxs.size() < 2) continue;\n            sort(idxs.begin(), idxs.end());\n            int m = idxs.size();\n            for (int j = 0; j < m; j++) {\n                int curr = idxs[j];\n                int prev = idxs[(j - 1 + m) % m];\n                int next = idxs[(j + 1) % m];\n                int d_prev = (curr - prev + n) % n;\n                int d_next = (next - curr + n) % n;\n                best[curr] = min(d_prev, d_next);\n            }\n        }\n        \n        vector<int> result;\n        for (int q : queries) {\n            result.push_back(best[q]);\n        }\n        return result;\n    }\n};\n","author":"Adithya Hegde Kota","submissionId":"1575112494"},[{"id":"350","similarity":0.7164179104477612,"totOverlap":144,"longestOverlap":31}]],"356":[{"id":"356","fileName":"1575112548.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& arr, vector<int>& q) {\n        int n = arr.size();\n        vector<int> v(n,-1);\n        map<int,vector<int>> m;\n        for(int i=0;i<n;i++){\n            m[arr[i]].push_back(i);\n        }\n        for(auto i : m){\n            vector<int> a = i.second;\n            int sz = a.size();\n            if (sz<2) continue;\n            sort(a.begin(),a.end());\n            for(int j=0;j<sz;j++){\n                int curr = a[j];\n                int prev = a[(j-1+sz)%sz];\n                int next = a[(j+1)%sz];\n                int d1 = abs(curr - prev);\n                int d2 = abs(curr - next);\n                v[curr] = min(min(d1,n-d1),min(d2,n-d2));\n            }\n        }\n        vector<int> ans;\n        for(auto i : q){\n            ans.push_back(v[i]);\n        }\n        return ans;\n    }\n};","author":"Bu1h49jsB8","submissionId":"1575112548"},[{"id":"184","similarity":0.8058823529411765,"totOverlap":137,"longestOverlap":27}]],"359":[{"id":"359","fileName":"1575112545.txt","sourceCode":"#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> val_to_indices;\n        int n = nums.size();\n        \n        for (int i = 0; i < n; ++i) {\n            val_to_indices[nums[i]].push_back(i);\n        }\n        \n        for (auto& entry : val_to_indices) {\n            sort(entry.second.begin(), entry.second.end());\n        }\n        \n        vector<int> answer;\n        for (int q : queries) {\n            int v = nums[q];\n            const vector<int>& indices = val_to_indices[v];\n            \n            if (indices.size() == 1) {\n                answer.push_back(-1);\n                continue;\n            }\n            \n            auto it = lower_bound(indices.begin(), indices.end(), q);\n            int pos = it - indices.begin();\n            int m = indices.size();\n            int prev_pos = (pos - 1 + m) % m;\n            int next_pos = (pos + 1) % m;\n            int prev_idx = indices[prev_pos];\n            int next_idx = indices[next_pos];\n            int dist_prev = min(abs(q - prev_idx), n - abs(q - prev_idx));\n            int dist_next = min(abs(q - next_idx), n - abs(q - next_idx));\n            \n            answer.push_back(min(dist_prev, dist_next));\n        }\n        \n        return answer;\n    }\n};","author":"Prince Chaudhary","submissionId":"1575112545"},[{"id":"359","similarity":0.934010152284264,"totOverlap":184,"longestOverlap":55}]],"370":[{"id":"370","fileName":"1575112976.txt","sourceCode":"\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& v, vector<int>& queries) {\n        int n = v.size();\n        unordered_map<int, vector<int>> um;\n        for (int i = 0; i < n; i++) \n            um[v[i]].push_back(i);\n        \n        for (auto &ii : um) \n            sort(ii.second.begin(), ii.second.end());\n        \n        vector<int> ans;\n        for (int q : queries) \n        {\n            vector<int>& z = um[v[q]];\n            if (z.size() == 1) \n            {\n                ans.push_back(-1);\n                continue;\n            }\n            int pos = int(lower_bound(z.begin(), z.end(), q) - z.begin());\n            int l = z[(pos - 1 + z.size()) % z.size()];\n            int r = z[(pos + 1) % z.size()];\n            int d = abs(q - l);\n            d = min(d, n - d);\n            int dr = abs(q - r);\n            dr = min(dr, n - dr);\n            ans.push_back(min(d, dr));\n        }\n        return ans;\n    }\n};\n","author":"Ansh Gupta","submissionId":"1575112976"},[{"id":"370","similarity":0.9111111111111111,"totOverlap":164,"longestOverlap":31}]],"377":[{"id":"377","fileName":"1575113152.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(); unordered_map<int, vector<int>> positions;\n        for(int i = 0; i < n; i++) positions[nums[i]].push_back(i);\n        for(auto &i : positions) sort(i.second.begin(), i.second.end());\n        vector<int> ans;\n        for(int q : queries){\n            int val = nums[q]; vector<int>& indices = positions[val];\n            if(indices.size() == 1){ans.push_back(-1); continue;}\n            int pos = lower_bound(indices.begin(), indices.end(), q)-indices.begin();\n            int left = indices[(pos-1+indices.size())%indices.size()];\n            int right = indices[(pos+1)%indices.size()];\n            int d1 = abs(q-left);\n            int d2 = abs(q-right);\n            d1 = min(d1, n-d1);\n            d2 = min(d2, n-d2);\n            ans.push_back(min(d1, d2));\n        }\n        return ans;\n    }\n};","author":"TLE","submissionId":"1575113152"},[{"id":"377","similarity":0.9095744680851063,"totOverlap":171,"longestOverlap":38}]],"391":[{"id":"391","fileName":"1575113996.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> val;\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            val[nums[i]].push_back(i);\n        }\n        \n        vector<int> ans;\n        for (int q : queries) {\n            int v = nums[q];\n            auto& indices = val[v];\n            if (indices.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            \n            auto it = lower_bound(indices.begin(), indices.end(), q);\n            int pos = it - indices.begin();\n            int m = indices.size();\n            int left_pos = (pos - 1 + m) % m;\n            int right_pos = (pos + 1) % m;\n            \n            int left_idx = indices[left_pos];\n            int right_idx = indices[right_pos];\n            \n            int dist_left = min(abs(q - left_idx), n - abs(q - left_idx));\n            int dist_right = min(abs(q - right_idx), n - abs(q - right_idx));\n            \n            ans.push_back(min(dist_left, dist_right));\n        }\n        return ans;\n    }\n};","author":"Temp05","submissionId":"1575113996"},[{"id":"391","similarity":0.9617486338797814,"totOverlap":176,"longestOverlap":63}]],"396":[{"id":"396","fileName":"1575114075.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& qs) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> m;\n        for (int i = 0; i < n; i++) {\n            m[nums[i]].push_back(i);\n        }\n        for (auto &p : m)\n            sort(p.second.begin(), p.second.end());\n        \n        vector<int> ans;\n        ans.reserve(qs.size());\n        for (int q : qs) {\n            int v = nums[q];\n            const vector<int>& pos = m[v];\n            if (pos.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            int idx = lower_bound(pos.begin(), pos.end(), q) - pos.begin();\n            int prev = pos[(idx - 1 + pos.size()) % pos.size()];\n            int nxt  = pos[(idx + 1) % pos.size()];\n            int d1 = abs(q - prev);\n            d1 = min(d1, n - d1);\n            int d2 = abs(q - nxt);\n            d2 = min(d2, n - d2);\n            ans.push_back(min(d1, d2));\n        }\n        return ans;\n    }\n};\n","author":"Devu Gupta","submissionId":"1575114075"},[{"id":"396","similarity":0.7204724409448819,"totOverlap":183,"longestOverlap":24}]],"421":[{"id":"421","fileName":"1575115039.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums,vector<int>& queries) {\n        int n=nums.size();\n        unordered_map<int,vector<int>>mp;\n        for(int i=0;i<n;++i)mp[nums[i]].push_back(i);\n        for(auto& it:mp)sort(it.second.begin(),it.second.end());\n        vector<int>ans;\n        for(auto& it:queries)\n        {\n            int v=nums[it];\n            // unordered_map<int,vector<int>>::iterator it1=mp.find(v);\n            // vector<int>ret=it1->second;\n            auto& ret=mp[v];\n            if(ret.size()<2)\n            {\n                ans.push_back(-1);\n                continue;\n            }\n            auto LB=ranges::lower_bound(ret,it);\n            int x=LB-ret.begin();\n            //ret[x-1],ret[x+1] or ret[x-1]+n,ret[x+1]+n\n            int l=ret[(x-1+ret.size())%ret.size()],r=ret[(x+1)%ret.size()];\n            int L=min(abs(it-l),n-abs(it-l)),R=min(abs(it-r),n-abs(it-r));\n            ans.push_back(min(L,R));\n        }\n        return ans;\n    }\n};","author":"Rajat","submissionId":"1575115039"},[{"id":"56","similarity":0.823170731707317,"totOverlap":135,"longestOverlap":30}]],"438":[{"id":"438","fileName":"1575115384.txt","sourceCode":"class Solution {\npublic:\n    \n    unordered_map<int, vector<int>> buildIndexMap(vector<int>& nums) {\n        unordered_map<int, vector<int>> mpp;\n        for (int i = 0; i < nums.size(); i++) {\n            mpp[nums[i]].push_back(i);\n        }\n        for (auto& p : mpp) {\n            sort(p.second.begin(), p.second.end());\n        }\n        return mpp;\n    }\n\n    \n    int getNearestDistance(vector<int>& it, int q, int n) {\n        if (it.size() == 1) return -1;  \n        \n        int idx = lower_bound(it.begin(), it.end(), q) - it.begin();\n        int left = (idx - 1 + it.size()) % it.size();\n        int right = (idx + 1) % it.size();\n\n        int d1 = abs(q - it[left]);\n        int d2 = abs(q - it[right]);\n\n        int dist1 = min(d1, n - d1);\n        int dist2 = min(d2, n - d2);\n\n        return min(dist1, dist2);\n    }\n\n    \n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> indexMap = buildIndexMap(nums);\n        \n        vector<int> res;\n        for (int q : queries) {\n            int val = nums[q];\n            res.push_back(getNearestDistance(indexMap[val], q, n));\n        }\n        return res;\n    }\n};\n","author":"Dhruv_chavda","submissionId":"1575115384"},[{"id":"591","similarity":0.8259109311740891,"totOverlap":204,"longestOverlap":63},{"id":"591","similarity":0.7327586206896551,"totOverlap":170,"longestOverlap":37},{"id":"813","similarity":0.9142857142857143,"totOverlap":160,"longestOverlap":39},{"id":"173","similarity":0.8138297872340425,"totOverlap":153,"longestOverlap":31}]],"444":[{"id":"444","fileName":"1575115515.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int, set<int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].insert(i);\n        }\n        vector<int> ans;\n        ans.reserve(queries.size());\n        for (int q : queries) {\n            int val = nums[q];\n            auto &idx = mp[val];\n            if (idx.size() < 2) {\n                ans.push_back(-1);\n                continue;\n            }\n            auto it = idx.lower_bound(q);\n            auto nx = it;\n            ++nx;\n            if (nx == idx.end()) {\n                nx = idx.begin();\n            }\n            int ncd = *nx;\n            auto px = it;\n            if (px == idx.begin()) {\n                px = idx.end();\n            }\n            --px;\n            int pcd = *px;\n            int dnx = (ncd - q + n) % n;\n            int dpx = (q - pcd + n) % n;\n            ans.push_back(min(dnx, dpx));\n        }\n        return ans;\n    }\n};\n","author":"shubcoder","submissionId":"1575115515"},[{"id":"444","similarity":0.7083333333333334,"totOverlap":119,"longestOverlap":19}]],"448":[{"id":"448","fileName":"1575115769.txt","sourceCode":"\n#include <unordered_map>\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> vec(n, -1);\n        unordered_map<int, vector<int>> aaa;\n        for (int m = 0; m < n; m++) {\n            aaa[nums[m]].push_back(m);\n        }\n        for (auto &p : aaa) {\n            vector<int>& v = p.second;\n            if (v.size() < 2)\n                continue;\n            sort(v.begin(), v.end());\n            for (int i = 0; i < v.size(); i++) {\n                int cur = v[i];\n                int l = v[(i - 1 + v.size()) % v.size()];\n                int r = v[(i + 1) % v.size()];\n                int d1 = abs(cur - l);\n                d1 = min(d1, n - d1);\n                int d2 = abs(r - cur);\n                d2 = min(d2, n - d2);\n                vec[cur] = min(d1, d2);\n            }\n        }\n        vector<int> Result;\n        for (int x : queries)\n            Result.push_back(vec[x]);\n        return Result;\n    }\n};","author":"KUMAR ANISH","submissionId":"1575115769"},[{"id":"184","similarity":0.8648648648648649,"totOverlap":160,"longestOverlap":40}]],"457":[{"id":"457","fileName":"1575115964.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> occ;\n        for (int i = 0; i < n; i++) {\n            occ[nums[i]].push_back(i);\n        }\n        for (auto &p : occ) {\n            sort(p.second.begin(), p.second.end());\n        }\n        auto circDist = [&](int a, int b) {\n            int d = abs(a - b);\n            return min(d, n - d);\n        };\n        vector<int> ans;\n        for (int q : queries) {\n            int val = nums[q];\n            const vector<int>& pos = occ[val];\n            if (pos.size() < 2) {\n                ans.push_back(-1);\n                continue;\n            }\n            int i = lower_bound(pos.begin(), pos.end(), q) - pos.begin();\n            int best = INT_MAX;\n            if (i > 0) best = min(best, circDist(q, pos[i - 1]));\n            if (i + 1 < pos.size()) best = min(best, circDist(q, pos[i + 1]));\n            if (pos.front() != q) best = min(best, circDist(q, pos.front()));\n            if (pos.back() != q) best = min(best, circDist(q, pos.back()));\n            ans.push_back(best);\n        }\n        return ans;\n    }\n};","author":"Mayank sharma","submissionId":"1575115964"},[{"id":"66","similarity":0.8341013824884793,"totOverlap":181,"longestOverlap":35}]],"473":[{"id":"473","fileName":"1575116625.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n    unordered_map<int, vector<int>> positions;\n    for (int i = 0; i < n; i++) {\n        positions[nums[i]].push_back(i);\n    }\n    \n    vector<int> minDist(n, -1);\n    for (auto& p : positions) {\n        vector<int>& indices = p.second;\n        if (indices.size() < 2) continue;\n        sort(indices.begin(), indices.end());\n        int m = indices.size();\n        for (int j = 0; j < m; j++) {\n            int current = indices[j];\n            int prev_idx = indices[(j - 1 + m) % m];\n            int next_idx = indices[(j + 1) % m];\n            int d_prev = abs(current - prev_idx);\n            int d_next = abs(next_idx - current);\n            d_prev = min(d_prev, n - d_prev);\n            d_next = min(d_next, n - d_next);\n            minDist[current] = min(d_prev, d_next);\n        }\n    }\n    \n    vector<int> result;\n    for (int q : queries) {\n        result.push_back(minDist[q]);\n    }\n    \n    return result;\n    }\n};","author":"Saurabh Kumar","submissionId":"1575116625"},[{"id":"5","similarity":1.0,"totOverlap":174,"longestOverlap":87}]],"500":[{"id":"500","fileName":"1575117227.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>>m;\n        int n = nums.size();\n        for(int i = 0; i < n; i++){\n            m[nums[i]].push_back(i);\n        }\n        //int m = queries.size();\n        vector<int>res;\n        for(int i:queries){\n            int value = nums[i];\n            if(m[value].size() != 1){\n                //cout<<i <<\" \"<<value<<endl;\n                auto & v = m[value];\n                int idx = lower_bound(v.begin(), v.end(), i) - v.begin();\n                int next = v[(idx + 1 + v.size()) % v.size()];\n                int last = v[(idx - 1 + v.size()) % v.size()];\n                //cout<<next<<\" \"<<last<<endl;\n                int ne = next > i ? next - i:next + n - i;\n                int la = last <i ? i - last : i - last + n;\n                \n                int ans = min(ne, la);\n                res.push_back(ans);\n            }else{\n                res.push_back(-1);\n            }\n        }\n        return res;\n    }\n};","author":"qianyifan010203","submissionId":"1575117227"},[{"id":"500","similarity":0.702247191011236,"totOverlap":125,"longestOverlap":23}]],"518":[{"id":"518","fileName":"1575117807.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> indices;\n        \n        // Store all indices for each value in sorted order.\n        for (int i = 0; i < n; i++) {\n            indices[nums[i]].push_back(i);\n        }\n        for (auto &p : indices) {\n            sort(p.second.begin(), p.second.end());\n        }\n        \n        vector<int> result;\n        for (int q : queries) {\n            int value = nums[q];\n            auto &vec = indices[value];\n            // If only one occurrence exists, answer is -1.\n            if (vec.size() == 1) {\n                result.push_back(-1);\n                continue;\n            }\n            \n            // Binary search to find the position of q in the sorted vector.\n            int pos = lower_bound(vec.begin(), vec.end(), q) - vec.begin();\n            int prevIdx = (pos == 0 ? vec.back() : vec[pos-1]);\n            int nextIdx = (pos == vec.size()-1 ? vec.front() : vec[pos+1]);\n            \n            // Calculate circular distances.\n            int d1 = abs(q - prevIdx);\n            d1 = min(d1, n - d1);\n            \n            int d2 = abs(q - nextIdx);\n            d2 = min(d2, n - d2);\n            \n            result.push_back(min(d1, d2));\n        }\n        \n        return result;\n    }\n};\n","author":"amit sharma","submissionId":"1575117807"},[{"id":"518","similarity":0.7028112449799196,"totOverlap":175,"longestOverlap":30}]],"543":[{"id":"543","fileName":"1575118174.txt","sourceCode":"\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int arraySize = nums.size();\n        unordered_map<int, vector<int>> indicesMap;\n        for (int i = 0; i < arraySize; i++) {\n            indicesMap[nums[i]].push_back(i);\n        }\n        for (auto& entry : indicesMap) {\n            sort(entry.second.begin(), entry.second.end());\n        }\n        vector<int> answers;\n        for (int queryIndex : queries) {\n            int targetValue = nums[queryIndex];\n            const vector<int>& positions = indicesMap[targetValue];\n            if (positions.size() < 2) {\n                answers.push_back(-1);\n                continue;\n            }\n            auto it = lower_bound(positions.begin(), positions.end(), queryIndex);\n            int posIndex = it - positions.begin();\n            int leftPos = positions[(posIndex - 1 + positions.size()) % positions.size()];\n            int rightPos = positions[(posIndex + 1) % positions.size()];\n            int distLeft = abs(queryIndex - leftPos);\n            distLeft = min(distLeft, arraySize - distLeft);\n            int distRight = abs(queryIndex - rightPos);\n            distRight = min(distRight, arraySize - distRight);\n            answers.push_back(min(distLeft, distRight));\n        }\n        return answers;\n    }\n};","author":"Keshav__2006","submissionId":"1575118174"},[{"id":"543","similarity":0.7430830039525692,"totOverlap":188,"longestOverlap":31}]],"544":[{"id":"544","fileName":"1575118539.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        int n = a.size();\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[a[i]].push_back(i);\n        }\n        for (auto &p : mp) {\n            sort(p.second.begin(), p.second.end());\n        }\n        vector<int> ans(q.size());\n        for (int i = 0; i < q.size(); i++) {\n            int idx = q[i];\n            int v = a[idx];\n            vector<int>& pos = mp[v];\n            if (pos.size() == 1) {\n                ans[i] = -1;\n            } else {\n                int pos_idx = lower_bound(pos.begin(), pos.end(), idx) - pos.begin();\n                int l = (pos_idx - 1 + pos.size()) % pos.size();\n                int r = (pos_idx + 1) % pos.size();\n                int d1 = abs(idx - pos[l]);\n                int d2 = abs(idx - pos[r]);\n                d1 = min(d1, n - d1);\n                d2 = min(d2, n - d2);\n                ans[i] = min(d1, d2);\n            }\n        }\n        return ans;\n    }\n};\n","author":"Madhavan_shree","submissionId":"1575118539"},[{"id":"228","similarity":0.8028846153846154,"totOverlap":167,"longestOverlap":17}]],"558":[{"id":"558","fileName":"1575118882.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int, vector<int>> pos;\n        \n        for (int i=0;i<n;i++) \n        {\n            pos[nums[i]].push_back(i);\n        }\n        \n        for (auto &x :pos) \n        {\n            sort(x.second.begin(), x.second.end());\n        }\n        vector<int> ans;\n        for (int q : queries) \n        {\n            int val = nums[q];\n            auto &vec = pos[val];\n            if (vec.size() ==1) \n            {\n                ans.push_back(-1);\n                continue;\n            }\n            int candi = INT_MAX;\n            int i = q;\n            auto it = lower_bound(vec.begin(), vec.end(), i);\n            int idx = it - vec.begin();\n            if (idx > 0)\n                candi = min(candi, i - vec[idx - 1]);\n            if (idx < vec.size() - 1)\n                candi = min(candi, vec[idx + 1] - i);\n            candi = min(candi, (i + n) - vec.back());\n            candi = min(candi, (vec.front() + n) - i);\n            ans.push_back(candi);\n        }\n        return ans;\n    }\n};\n","author":"vicky_kumar1347","submissionId":"1575118882"},[{"id":"286","similarity":0.7486910994764397,"totOverlap":143,"longestOverlap":31}]],"565":[{"id":"565","fileName":"1575119088.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> pos;\n        for (int i = 0; i < n; i++) {\n            pos[nums[i]].push_back(i);\n        }\n        for (auto& p : pos) {\n            sort(p.second.begin(), p.second.end());\n        }\n        vector<int> ans;\n        for (int idx : queries) {\n            int v = nums[idx];\n            auto& vec = pos[v];\n            if (vec.size() <= 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            auto it = lower_bound(vec.begin(), vec.end(), idx);\n            int posIdx = it - vec.begin();\n            int leftDist = posIdx == 0 ? idx + n - vec.back() : idx - vec[posIdx - 1];\n            int rightDist = posIdx == vec.size() - 1 ? vec.front() + n - idx : vec[posIdx + 1] - idx;\n            ans.push_back(min(leftDist, rightDist));\n        }\n        return ans;\n    }\n};\n","author":"Krrish Chanchal","submissionId":"1575119088"},[{"id":"126","similarity":0.7559523809523809,"totOverlap":127,"longestOverlap":36}]],"582":[{"id":"582","fileName":"1575119753.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& qs) {\n        int n = nums.size();\n        unordered_map<int,vector<int>>m;\n        for (int i=0;i<n;++i)m[nums[i]].push_back(i);\n        for (auto &p:m)sort(p.second.begin(),p.second.end());\n        vector<int>ans;\n        for (int q : qs){\n            int v=nums[q];\n            vector<int>&x=m[v];\n            if (x.size()==1){\n                ans.push_back(-1);\n                continue;\n            }\n            int pos = int(lower_bound(x.begin(), x.end(), q) - x.begin());\n            int l = x[(pos - 1 + x.size()) % x.size()];\n            int r = x[(pos + 1) % x.size()];\n            int d = min(min(abs(q - l), n - abs(q - l)), min(abs(q - r), n - abs(q - r)));\n            ans.push_back(d);\n        }\n        return ans;\n    }\n};","author":"Samudra","submissionId":"1575119753"},[{"id":"377","similarity":0.8707865168539326,"totOverlap":155,"longestOverlap":46}]],"591":[{"id":"591","fileName":"1575120104.txt","sourceCode":"void print(){\n    cout<<\"\"<<endl;\n}\n void mapp(const vector<int>& nums) {\n        unordered_map<int, vector<int>> mapping;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            mapping[nums[i]].push_back(i);\n        }\n        for (auto& entry : mapping) {\n            sort(entry.second.begin(), entry.second.end());\n        }\n        return ;\n    }\nclass Solution {\npublic:\n    unordered_map<int, vector<int>> mapp(const vector<int>& nums) {\n        unordered_map<int, vector<int>> mapping;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            mapping[nums[i]].push_back(i);\n        }\n        for (auto& entry : mapping) {\n            sort(entry.second.begin(), entry.second.end());\n        }\n        return mapping;\n    }\n    \n    int queryMinDistance(int q, const vector<int>& nums, const vector<int>& indices, int n) {\n        if (indices.size() == 1)\n            return -1;\n        int idx = lower_bound(indices.begin(), indices.end(), q) - indices.begin();\n        int left = (idx - 1 + indices.size()) % indices.size();\n        int right = (idx + 1) % indices.size();\n        int dis1 = abs(q - indices[left]);\n        int dis2 = abs(q - indices[right]);\n        int dist1 = min(dis1, n - dis1);\n        int dist2 = min(dis2, n - dis2);\n        return min(dist1, dist2);\n    }\n    \n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mapping = mapp(nums);\n        vector<int> res;\n        for (int q : queries) {\n            res.push_back(queryMinDistance(q, nums, mapping[nums[q]], n));\n        }\n        return res;\n    }\n};","author":"ujjwal2612","submissionId":"1575120104"},[{"id":"438","similarity":0.8259109311740891,"totOverlap":204,"longestOverlap":63}]],"611":[{"id":"611","fileName":"1575120768.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n\n        unordered_map<int,vector<int>> mpp;\n\n        for(int i = 0 ; i < n ; i++){\n            mpp[nums[i]].push_back(i);\n        }\n\n        for(auto &m : mpp){\n            sort(m.second.begin() , m.second.end());\n        }\n\n        vector<int> res;\n        res.reserve(queries.size());\n\n        // check the minimal circular distance\n        for(int q : queries){\n            int val = nums[q];\n            auto &v = mpp[val];\n\n            // if value only apperas once answer is -1\n            if(v.size() < 2){\n                res.push_back(-1);\n                continue;\n            }\n\n            int b = n;\n\n            auto i = lower_bound(v.begin() , v.end() , q);\n\n            if(i != v.end() && *i == q){\n                if(i != v.begin()){\n                    int c = *(i - 1);\n                    int d = abs(q - c);\n                    b = min(b , min(d , n-d));\n                }\n                \n                if((i+1) != v.end()){\n                    int c = *(i + 1);\n                    int d = abs(q - c);\n                    b = min(b , min(d , n-d));\n                }\n            } else {\n                    if(i != v.end()){\n                    int c = *(i);\n                    int d = abs(q - c);\n                    b = min(b , min(d , n-d));\n                } \n                    if(i != v.begin()){\n                    int c = *(i-1);\n                    int d = abs(q - c);\n                    b = min(b , min(d , n-d));\n                } \n            }\n\n            if(!v.empty()){\n                if(v.front() != q){\n                    int c = v.front();\n                    int d = abs(q - c);\n                    b = min(b , min(d , n-d));\n                }\n                if(v.back() != q){\n                    int c = v.back();\n                    int d = abs(q - c);\n                    b = min(b , min(d , n-d));\n                }           \n            }\n\n            res.push_back(b);\n        }\n        return res;\n    }\n};","author":"Karan","submissionId":"1575120768"},[{"id":"112","similarity":0.702054794520548,"totOverlap":205,"longestOverlap":31}]],"619":[{"id":"619","fileName":"1575121061.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        for (auto& [val, indices] : mp) {\n            sort(indices.begin(), indices.end());\n        }\n        vector<int> res;\n        for (int idx : queries) {\n            int x = nums[idx];\n            auto& indices = mp[x];     \n            if (indices.size() == 1) {\n                res.push_back(-1);\n                continue;\n            }\n            int pos = lower_bound(indices.begin(), indices.end(), idx) - indices.begin();\n            int left = (pos - 1 + indices.size()) % indices.size();\n            int right = (pos + 1) % indices.size();\n            int l = indices[left];\n            int r = indices[right];\n            int dl = (idx - l + n) % n;\n            int dr = (r - idx + n) % n;\n            res.push_back(min(dl, dr));\n        }\n        return res;\n    }\n};\n","author":"Shalini","submissionId":"1575121061"},[{"id":"619","similarity":0.7912087912087912,"totOverlap":144,"longestOverlap":44}]],"627":[{"id":"627","fileName":"1575121187.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n    unordered_map<int, vector<int>> indexMap;\n\n    // Store occurrences of each number\n    for (int i = 0; i < n; i++) {\n        indexMap[nums[i]].push_back(i);\n    }\n\n    // Precompute nearest distances\n    vector<int> left(n, -1), right(n, -1);\n\n    for (auto& [num, indices] : indexMap) {\n        int m = indices.size();\n        if (m == 1) continue; // No valid distances if only one occurrence\n\n        // Compute nearest left and right distances\n        for (int i = 0; i < m; i++) {\n            int curr = indices[i];\n            int prev = indices[(i - 1 + m) % m]; // Circular previous index\n            int next = indices[(i + 1) % m];     // Circular next index\n\n            left[curr] = min(abs(curr - prev), n - abs(curr - prev));\n            right[curr] = min(abs(next - curr), n - abs(next - curr));\n        }\n    }\n\n    // Process queries in O(1)\n    vector<int> result;\n    for (int q : queries) {\n        if (left[q] == -1 && right[q] == -1) {\n            result.push_back(-1);\n        } else {\n            result.push_back(min(left[q] != -1 ? left[q] : INT_MAX,\n                                 right[q] != -1 ? right[q] : INT_MAX));\n        }\n    }\n\n    return result;\n    }\n};","author":"Venkata Pavan Kumar","submissionId":"1575121187"},[{"id":"709","similarity":1.0,"totOverlap":178,"longestOverlap":89},{"id":"627","similarity":0.7352941176470589,"totOverlap":125,"longestOverlap":25}]],"630":[{"id":"630","fileName":"1575121460.txt","sourceCode":"class Solution {\npublic:\n\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> valueIndices;\n        for (int i = 0; i < n; ++i) {\n            valueIndices[nums[i]].push_back(i);\n        }\n        \n        vector<int> answer;\n        for (int q : queries) {\n            int v = nums[q];\n            auto& list = valueIndices[v];\n            if (list.size() == 1) {\n                answer.push_back(-1);\n                continue;\n            }\n            \n            auto it = lower_bound(list.begin(), list.end(), q);\n            int pos = distance(list.begin(), it);\n            int m = list.size();\n            int prev_pos = (pos - 1 + m) % m;\n            int next_pos = (pos + 1) % m;\n            \n            int prev_idx = list[prev_pos];\n            int next_idx = list[next_pos];\n            \n            int dist_prev = min(abs(q - prev_idx), n - abs(q - prev_idx));\n            int dist_next = min(abs(q - next_idx), n - abs(q - next_idx));\n            \n            answer.push_back(min(dist_prev, dist_next));\n        }\n        return answer;\n    }\n};\n\n","author":"MO_RAAFAT","submissionId":"1575121460"},[{"id":"1792","similarity":0.9719101123595506,"totOverlap":173,"longestOverlap":36},{"id":"1792","similarity":0.9144385026737968,"totOverlap":171,"longestOverlap":77}]],"634":[{"id":"634","fileName":"1575121380.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& qs) {\n        int n=nums.size();\n        unordered_map<int,vector<int>> mp;\n        for(int i=0;i<n;i++) mp[nums[i]].push_back(i);\n        vector<int> ans;\n        ans.reserve(qs.size());\n        for(int q:qs){\n            int v=nums[q];\n            auto &vec=mp[v];\n            if(vec.size()==1){\n                ans.push_back(-1);\n                continue;\n            }\n            auto it=lower_bound(vec.begin(),vec.end(),q);\n            int idx=it-vec.begin();\n            int l=vec[(idx-1+vec.size())%vec.size()];\n            int r=vec[(idx+1)%vec.size()];\n            int d1=(q-l+n)%n, d2=(r-q+n)%n;\n            ans.push_back(min(d1,d2));\n        }\n        return ans;\n    }\n};","author":"Kaju Takli","submissionId":"1575121380"},[{"id":"173","similarity":0.7584269662921348,"totOverlap":135,"longestOverlap":36}]],"638":[{"id":"638","fileName":"1575121545.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n         int n = nums.size();\n    unordered_map<int, vector<int>> pos;\n    \n    for (int i = 0; i < n; i++) {\n        pos[nums[i]].push_back(i);\n    }\n    \n    vector<int> res;\n    for (int q : queries) {\n        int val = nums[q];\n        if (pos[val].size() == 1) {\n            res.push_back(-1);\n        } else {\n            const vector<int>& idx = pos[val];\n            int i = lower_bound(idx.begin(), idx.end(), q) - idx.begin();\n            int p = (i - 1 + idx.size()) % idx.size();\n            int nxt = (i + 1) % idx.size();\n            int d1 = min(abs(q - idx[p]), n - abs(q - idx[p]));\n            int d2 = min(abs(q - idx[nxt]), n - abs(q - idx[nxt]));\n            res.push_back(min(d1, d2));\n        }\n    }\n    \n    return res;\n    }\n};","author":"gauravpandit7856","submissionId":"1575121545"},[{"id":"238","similarity":0.7247191011235955,"totOverlap":129,"longestOverlap":28}]],"640":[{"id":"640","fileName":"1575121517.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        int n = nums.size();\n        for(int i=0; i<n; i++){\n            mp[nums[i]].push_back(i);\n        }\n        for(auto& p : mp){\n         sort(p.second.begin(), p.second.end());   \n        }\n        vector<int> ans;\n        for(auto x : queries){\n            int val = nums[x];\n            if (mp[val].size() == 1)\n                ans.push_back(-1);\n            else {\n                auto& vec = mp[val];\n                int pos =\n                    lower_bound(vec.begin(), vec.end(), x) - vec.begin();\n                int k = vec.size();\n                int nxt=vec[(pos+1)%k];\n                int prv=vec[(pos-1+k)%k];\n                int d1=abs(x-nxt), d2=abs(x-prv);\n                d1 = min(d1, n-d1);\n                d2=min(d2, n-d2);\n                ans.push_back(min(d1, d2));\n            }\n        }\n        return ans;\n    }\n};","author":"parnikaamathur","submissionId":"1575121517"},[{"id":"640","similarity":0.7740112994350282,"totOverlap":137,"longestOverlap":9}]],"672":[{"id":"672","fileName":"1575122287.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> res;\n        auto dis = [&](int x, int y) {\n            int cur = abs(x - y);\n            return min(cur, n - cur);\n        };\n        for (auto id : queries) {\n            auto& st = mp[nums[id]];\n            int cur = 1e9;\n            auto it = upper_bound(st.begin(), st.end(), id);\n            auto self = lower_bound(st.begin(), st.end(), id);\n            if (it != st.end()) {\n                cur = min(cur, dis(id, *it));\n            } else {\n                if (st.size() > 1) {\n                    cur = min(cur, dis(id, st[0]));\n                }\n            }\n            \n            if (self != st.begin()) {\n                self --;\n                cur = min(cur, dis(id, *self));\n            } else {\n                if (st.size() > 1) cur = min(cur, dis(id, st.back()));\n            }\n            res.push_back(cur == 1e9 ? -1 : cur);\n        }\n        return res;\n    }\n};","author":"jeemzz147","submissionId":"1575122287"},[{"id":"149","similarity":0.7045454545454546,"totOverlap":155,"longestOverlap":23}]],"709":[{"id":"709","fileName":"1575122991.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n    unordered_map<int, vector<int>> indexMap;\n    for (int i = 0; i < n; i++) {\n        indexMap[nums[i]].push_back(i);\n    }\n    vector<int> left(n, -1), right(n, -1);\n\n    for (auto& [num, indices] : indexMap) {\n        int m = indices.size();\n        if (m == 1) continue;\n        for (int i = 0; i < m; i++) {\n            int curr = indices[i];\n            int prev = indices[(i - 1 + m) % m];\n            int next = indices[(i + 1) % m]; \n\n            left[curr] = min(abs(curr - prev), n - abs(curr - prev));\n            right[curr] = min(abs(next - curr), n - abs(next - curr));\n        }\n    }\n    vector<int> result;\n    for (int q : queries) {\n        if (left[q] == -1 && right[q] == -1) {\n            result.push_back(-1);\n        } else {\n            result.push_back(min(left[q] != -1 ? left[q] : INT_MAX,\n                                 right[q] != -1 ? right[q] : INT_MAX));\n        }\n    }\n    return result;\n    }\n};","author":"Chava Venkata Pavan Kumar","submissionId":"1575122991"},[{"id":"627","similarity":1.0,"totOverlap":178,"longestOverlap":89}]],"721":[{"id":"721","fileName":"1575123177.txt","sourceCode":"class Solution {\npublic:\n    int circularDistance(int i, int j, int n) {\n        int diff = abs(i - j);\n        return min(diff, n - diff);\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> positions;\n        for (int i = 0; i < n; i++) {\n            positions[nums[i]].push_back(i);\n        }\n        for (auto& v : positions) {\n            sort(v.second.begin(), v.second.end());\n        }\n        vector<int> result;\n        for (int q : queries) {\n            int val = nums[q];\n            const vector<int>& idxlist = positions[val];\n            if (idxlist.size() == 1) {\n                result.push_back(-1);\n                continue;\n            }\n            int pos = lower_bound(idxlist.begin(), idxlist.end(), q) -idxlist.begin();\n            int m = idxlist.size();\n            int left = idxlist[(pos - 1 + m) % m];\n            int right = idxlist[(pos + 1) % m];\n\n            int best = min(circularDistance(q, left, n),circularDistance(q, right, n));\n\n            result.push_back(best);\n        }\n        return result;\n    }\n};","author":"SUPERMAN44","submissionId":"1575123177"},[{"id":"328","similarity":0.9086021505376344,"totOverlap":169,"longestOverlap":41}]],"739":[{"id":"739","fileName":"1575124010.txt","sourceCode":"class Solution {\npublic:\n    int circularDistance(int i, int j, int n) \n    {\n        int diff = abs(i - j);\n        return min(diff, n - diff);\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& que) \n    {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++) \n        {\n            mp[nums[i]].push_back(i);\n        }\n        \n        vector<int> answer;\n        answer.reserve(que.size());\n        \n        for (int q : que) \n        {\n            int curr = nums[q];\n            const vector<int>& idx = mp[curr];\n            \n            if (idx.size() <=1 ) \n            {\n                answer.push_back(-1);\n                continue;\n            }\n            \n            auto it = lower_bound(idx.begin(), idx.end(), q);\n            int pos = it - idx.begin();\n            \n            int prev = (pos == 0) ? idx.back() : idx[pos - 1];\n            int next = (pos == idx.size() - 1) ? idx.front() : idx[pos + 1];\n            \n            int distPrev = circularDistance(q, prev,n);\n            int distNext = circularDistance(q, next,n);\n            answer.push_back(min(distPrev, distNext));\n        }\n        return answer;\n    }\n};","author":"Ayush Pratap Singh","submissionId":"1575124010"},[{"id":"328","similarity":0.8201058201058201,"totOverlap":155,"longestOverlap":65}]],"741":[{"id":"741","fileName":"1575124054.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        unordered_map<int,vector<int>> mp;\n        int n = nums.size();\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(int i=0;i<q.size();i++){\n            int idx = q[i];\n            int ele = nums[q[i]];\n\n            if(mp[ele].size()==1){\n                ans.push_back(-1);\n                continue;\n            }\n            const vector<int>& temp= mp[ele];\n\n            int curr  = lower_bound(temp.begin(),temp.end(),idx) - temp.begin();\n\n            int left = temp[(curr - 1 + temp.size())%temp.size()];\n            int right = temp[(curr + 1)%temp.size()];\n            \n            int diffL = abs(idx - left);\n            int diffR = abs(idx - right);\n\n            int minL = min(diffL,n-diffL);\n            int minR = min(diffR,n-diffR);\n\n            ans.push_back(min(minL,minR));\n        }\n        return ans;\n    }\n};","author":"Tanay Gupta","submissionId":"1575124054"},[{"id":"904","similarity":0.7842105263157895,"totOverlap":149,"longestOverlap":16},{"id":"173","similarity":0.7578947368421053,"totOverlap":144,"longestOverlap":36}]],"743":[{"id":"743","fileName":"1575124023.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& qu) {\n        map<int,multiset<int>>mp;\n        for(int i=0;i<nums.size();i++)\n            mp[nums[i]].insert(i);\n        \n    int n=nums.size();\n        vector<int>res(n,-1);\n        for(auto it:mp){\n            auto mt=it.second;\n            if(mt.size()<=1)\n                continue;\n            vector<int>idx;\n              for(int i:mt)\n                idx.push_back(i);\n            \n            for(int i=0;i<idx.size();i++){\n                int j=idx[i];\n               // cout<<j<<\"a\"<<endl;\n                int j1=idx[(i+1)%(idx.size())];\n               // cout<<j1<<\"a1\"<<endl;\n                int j2=idx[(i-1+idx.size())% (idx.size())];\n               // cout<<j2<<\"a2\"<<endl;\n                \n                int ans1=abs(j-j1);\n                ans1= min(ans1,n-ans1);\n                int ans2=abs(j-j2);\n                ans2= min(ans2, n-ans2);\n                res[j] = min(ans1,ans2);\n            }\n        }\n        \n        vector<int>ans;\n        for(int i:qu)\n            ans.push_back(res[i]);\n        \n        \n        return ans;\n    }\n};\n","author":"pandeysujal04","submissionId":"1575124023"},[{"id":"448","similarity":0.7409326424870466,"totOverlap":143,"longestOverlap":27}]],"769":[{"id":"769","fileName":"1575124687.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        int n = a.size();\n        unordered_map<int,vector<int>> mp;\n        for(int i = 0; i < n; i++){\n            mp[a[i]].push_back(i);\n        } \n        vector<int> ans;\n        ans.reserve(q.size());\n        for(auto it : q){\n            int el = a[it];\n            vector<int>& v = mp[el];\n            if (v.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            } \n            int m = v.size();\n            int pos = lower_bound(v.begin(), v.end(), it) - v.begin();\n            int l = v[(pos - 1 + m) % m];\n            int r = v[(pos + 1) % m];\n            \n            int d1 = abs(it - l);\n            d1 = min(d1, n - d1);\n            int d2 = abs(r - it);\n            d2 = min(d2, n - d2);\n            ans.push_back(min(d1, d2));\n        }\n        return ans;\n    }\n};\n","author":"Jaikrit Sanandiya","submissionId":"1575124687"},[{"id":"611","similarity":0.7061224489795919,"totOverlap":173,"longestOverlap":28}]],"770":[{"id":"770","fileName":"1575124596.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n = nums.size();\n        map<int, vector<int>> mp;\n        for (int i = 0; i < n; ++i) {\n            mp[nums[i]].push_back(i);\n        }\n        for (auto& [k, v] : mp) {\n            sort(v.begin(), v.end());\n        }\n        vector<int> ans;\n        for (int i : q) {\n            int v = nums[i];\n            auto& list = mp[v];\n            if (list.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            auto it = lower_bound(list.begin(), list.end(), i);\n            int pos = it - list.begin();\n            int min_dist = INT_MAX;\n\n            if (pos > 0) {\n                int j = list[pos - 1];\n                int d = abs(i - j);\n                d = min(d, n - d);\n                min_dist = min(min_dist, d);\n            }\n            if (pos < list.size() - 1) {\n                int j = list[pos + 1];\n                int d = abs(i - j);\n                d = min(d, n - d);\n                min_dist = min(min_dist, d);\n            }\n            if (pos == list.size() - 1) {\n                int j = list[0];\n                int d = abs(i - j);\n                d = min(d, n - d);\n                min_dist = min(min_dist, d);\n            }\n            if (pos == 0) {\n                int j = list.back();\n                int d = abs(i - j);\n                d = min(d, n - d);\n                min_dist = min(min_dist, d);\n            }\n            ans.push_back(min_dist);\n        }\n        return ans;\n    }\n};","author":"Prathamesh","submissionId":"1575124596"},[{"id":"902","similarity":0.7042682926829268,"totOverlap":231,"longestOverlap":22},{"id":"770","similarity":0.8351648351648352,"totOverlap":228,"longestOverlap":23},{"id":"611","similarity":0.702054794520548,"totOverlap":205,"longestOverlap":31},{"id":"611","similarity":0.7378277153558053,"totOverlap":197,"longestOverlap":55},{"id":"611","similarity":0.7430830039525692,"totOverlap":188,"longestOverlap":31},{"id":"543","similarity":0.9585492227979274,"totOverlap":185,"longestOverlap":47},{"id":"833","similarity":0.7131782945736435,"totOverlap":184,"longestOverlap":14},{"id":"1598","similarity":0.7603305785123967,"totOverlap":184,"longestOverlap":55},{"id":"611","similarity":0.7204724409448819,"totOverlap":183,"longestOverlap":24},{"id":"791","similarity":0.75,"totOverlap":183,"longestOverlap":14},{"id":"611","similarity":0.7165354330708661,"totOverlap":182,"longestOverlap":31},{"id":"770","similarity":0.7396694214876033,"totOverlap":179,"longestOverlap":17},{"id":"1598","similarity":0.8202764976958525,"totOverlap":178,"longestOverlap":40},{"id":"1966","similarity":0.7023809523809523,"totOverlap":177,"longestOverlap":23},{"id":"833","similarity":0.7787610619469026,"totOverlap":176,"longestOverlap":19},{"id":"228","similarity":0.7882882882882883,"totOverlap":175,"longestOverlap":28},{"id":"611","similarity":0.7028112449799196,"totOverlap":175,"longestOverlap":30},{"id":"611","similarity":0.7131147540983607,"totOverlap":174,"longestOverlap":31},{"id":"769","similarity":0.7061224489795919,"totOverlap":173,"longestOverlap":28},{"id":"1230","similarity":0.7307692307692307,"totOverlap":171,"longestOverlap":21},{"id":"396","similarity":0.9095744680851063,"totOverlap":171,"longestOverlap":38},{"id":"1966","similarity":0.9144385026737968,"totOverlap":171,"longestOverlap":77},{"id":"1792","similarity":0.9444444444444444,"totOverlap":170,"longestOverlap":63},{"id":"1050","similarity":0.794392523364486,"totOverlap":170,"longestOverlap":33},{"id":"937","similarity":0.8571428571428571,"totOverlap":168,"longestOverlap":38},{"id":"544","similarity":0.8028846153846154,"totOverlap":167,"longestOverlap":17},{"id":"1945","similarity":0.9217877094972067,"totOverlap":165,"longestOverlap":28},{"id":"377","similarity":0.9111111111111111,"totOverlap":164,"longestOverlap":31},{"id":"1966","similarity":0.8109452736318408,"totOverlap":163,"longestOverlap":28},{"id":"937","similarity":0.8350515463917526,"totOverlap":162,"longestOverlap":61},{"id":"959","similarity":0.8797814207650273,"totOverlap":161,"longestOverlap":45},{"id":"377","similarity":0.8695652173913043,"totOverlap":160,"longestOverlap":43},{"id":"328","similarity":0.8195876288659794,"totOverlap":159,"longestOverlap":60},{"id":"1519","similarity":0.7417840375586855,"totOverlap":158,"longestOverlap":35},{"id":"1857","similarity":0.7464114832535885,"totOverlap":156,"longestOverlap":31},{"id":"847","similarity":0.7989690721649485,"totOverlap":155,"longestOverlap":29},{"id":"1980","similarity":0.7828282828282829,"totOverlap":155,"longestOverlap":28},{"id":"739","similarity":0.8201058201058201,"totOverlap":155,"longestOverlap":65},{"id":"582","similarity":0.8707865168539326,"totOverlap":155,"longestOverlap":46},{"id":"196","similarity":0.7031963470319634,"totOverlap":154,"longestOverlap":30},{"id":"286","similarity":0.7031963470319634,"totOverlap":154,"longestOverlap":23},{"id":"238","similarity":0.8138297872340425,"totOverlap":153,"longestOverlap":31},{"id":"874","similarity":0.765,"totOverlap":153,"longestOverlap":22},{"id":"1078","similarity":0.8138297872340425,"totOverlap":153,"longestOverlap":34},{"id":"977","similarity":0.7004608294930875,"totOverlap":152,"longestOverlap":14},{"id":"788","similarity":0.8287292817679558,"totOverlap":150,"longestOverlap":30},{"id":"190","similarity":0.7061611374407583,"totOverlap":149,"longestOverlap":32},{"id":"295","similarity":0.8087431693989071,"totOverlap":148,"longestOverlap":30},{"id":"377","similarity":0.8546511627906976,"totOverlap":147,"longestOverlap":30},{"id":"721","similarity":0.8305084745762712,"totOverlap":147,"longestOverlap":34},{"id":"359","similarity":0.7604166666666666,"totOverlap":146,"longestOverlap":22},{"id":"833","similarity":0.7019230769230769,"totOverlap":146,"longestOverlap":11},{"id":"1361","similarity":0.7142857142857143,"totOverlap":145,"longestOverlap":30},{"id":"1361","similarity":0.7754010695187166,"totOverlap":145,"longestOverlap":18},{"id":"741","similarity":0.7578947368421053,"totOverlap":144,"longestOverlap":36},{"id":"868","similarity":0.7164179104477612,"totOverlap":144,"longestOverlap":31},{"id":"1792","similarity":0.7912087912087912,"totOverlap":144,"longestOverlap":44},{"id":"558","similarity":0.7486910994764397,"totOverlap":143,"longestOverlap":31},{"id":"743","similarity":0.7409326424870466,"totOverlap":143,"longestOverlap":27},{"id":"1081","similarity":0.700507614213198,"totOverlap":138,"longestOverlap":14},{"id":"356","similarity":0.8058823529411765,"totOverlap":137,"longestOverlap":27},{"id":"769","similarity":0.7740112994350282,"totOverlap":137,"longestOverlap":9},{"id":"937","similarity":0.7431693989071039,"totOverlap":136,"longestOverlap":32},{"id":"421","similarity":0.823170731707317,"totOverlap":135,"longestOverlap":30},{"id":"634","similarity":0.7584269662921348,"totOverlap":135,"longestOverlap":36},{"id":"1253","similarity":0.783625730994152,"totOverlap":134,"longestOverlap":22},{"id":"1087","similarity":0.7135135135135136,"totOverlap":132,"longestOverlap":37},{"id":"1036","similarity":0.7058823529411765,"totOverlap":132,"longestOverlap":11},{"id":"721","similarity":0.7528735632183908,"totOverlap":131,"longestOverlap":9},{"id":"1221","similarity":0.7247191011235955,"totOverlap":129,"longestOverlap":24},{"id":"994","similarity":0.7914110429447853,"totOverlap":129,"longestOverlap":12},{"id":"638","similarity":0.7247191011235955,"totOverlap":129,"longestOverlap":28},{"id":"421","similarity":0.7111111111111111,"totOverlap":128,"longestOverlap":20},{"id":"565","similarity":0.7559523809523809,"totOverlap":127,"longestOverlap":36},{"id":"377","similarity":0.7016574585635359,"totOverlap":127,"longestOverlap":34},{"id":"1751","similarity":0.7078651685393258,"totOverlap":126,"longestOverlap":20},{"id":"741","similarity":0.702247191011236,"totOverlap":125,"longestOverlap":23},{"id":"1311","similarity":0.7352941176470589,"totOverlap":125,"longestOverlap":25},{"id":"904","similarity":0.7142857142857143,"totOverlap":125,"longestOverlap":16},{"id":"1224","similarity":0.7321428571428571,"totOverlap":123,"longestOverlap":21},{"id":"1695","similarity":0.711764705882353,"totOverlap":121,"longestOverlap":24},{"id":"813","similarity":0.7142857142857143,"totOverlap":120,"longestOverlap":13},{"id":"1976","similarity":0.7228915662650602,"totOverlap":120,"longestOverlap":14},{"id":"1096","similarity":0.718562874251497,"totOverlap":120,"longestOverlap":17},{"id":"634","similarity":0.7083333333333334,"totOverlap":119,"longestOverlap":19},{"id":"1685","similarity":0.7018633540372671,"totOverlap":113,"longestOverlap":24}]],"788":[{"id":"788","fileName":"1575125229.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& qs) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        for (auto &p : mp) {\n            sort(p.second.begin(), p.second.end());\n        }\n        auto circ = [&](int a, int b) {\n            int d = abs(a - b);\n            return min(d, n - d);\n        };\n        vector<int> res;\n        for (int q : qs) {\n            int v = nums[q];\n            auto &vec = mp[v];\n            if (vec.size() < 2) {\n                res.push_back(-1);\n                continue;\n            }\n            int pos = lower_bound(vec.begin(), vec.end(), q) - vec.begin();\n            int l = (pos - 1 + vec.size()) % vec.size();\n            int r = (pos + 1) % vec.size();\n            res.push_back(min(circ(q, vec[l]), circ(q, vec[r])));\n        }\n        return res;\n    }\n};\n","author":"Aditya Kumar Ray","submissionId":"1575125229"},[{"id":"71","similarity":0.8287292817679558,"totOverlap":150,"longestOverlap":30}]],"791":[{"id":"791","fileName":"1575125287.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>>mp;\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]].push_back(i);\n        }\n        // for(auto i:mp){\n        //     int v=i.first;\n        //     sort(mp[v].second.begin(),mp[v].second.end());\n        //     for(int j:mp[v].second)\n        // }\n        \n        vector<int>ans;\n        \n        for(int i:queries){\n            int x=nums[i];\n            vector<int>&k=mp[x];\n            if(k.size()<2){\n                ans.emplace_back(-1);\n            }\n            else{\n                int position = lower_bound(k.begin(),k.end(),i)-k.begin();\n                int n=nums.size();\n                int prev;\n                if(position==0)prev=k.back();\n                else prev=k[position-1];\n                int dist1 = abs(i-prev);\n                dist1 = min(dist1, n-dist1);\n                int res = min(n,dist1);\n                \n                int nxt;\n                if(position==k.size()-1){\n                    nxt = k.front();\n                }\n                else{\n                    nxt=k[position+1];\n                }\n                int dist2 = abs(i-nxt);\n                dist2 = min(dist2,n-dist2);\n                res=min(res,dist2);\n                \n                ans.push_back(res);\n                \n            }\n        }\n        return ans;\n        \n    }\n};","author":"Rithish Kumar","submissionId":"1575125287"},[{"id":"770","similarity":0.75,"totOverlap":183,"longestOverlap":14}]],"804":[{"id":"804","fileName":"1575125514.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> mp;\n        int n = nums.size();\n        for(int i=0; i<n; ++i) mp[nums[i]].push_back(i);\n        vector<int> ans;\n        for(auto q:queries){\n            vector<int> &arr = mp[nums[q]];\n            if(arr.size()==1){\n                ans.push_back(-1);\n                continue;\n            }\n            int i = lower_bound(arr.begin(),arr.end(),q) - arr.begin();\n            int j1 = arr[(i-1+arr.size())%arr.size()];\n            int j2 = arr[(i+1)%arr.size()];\n            int d1 = j1<q ? q-j1 : (q) + (n-j1);\n            int d2 = q<j2 ? j2-q : (j2) + (n-q);\n            // cout << i << \" - \" << j1 << \" : \" << d1 << \"n\";\n            // cout << i << \" - \" << j2 << \" : \" << d2 << \"nn\";\n            ans.push_back(min(d1,d2));\n        }\n        return ans;\n    }\n};","author":"Ankush Balse","submissionId":"1575125514"},[{"id":"804","similarity":0.7142857142857143,"totOverlap":125,"longestOverlap":16}]],"813":[{"id":"813","fileName":"1575125841.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for (int q : queries) {\n            int v = nums[q];\n            vector<int>& pos = mp[v];\n            if (pos.size() < 2) {\n                ans.push_back(-1);\n                continue;\n            }\n            int p = lower_bound(pos.begin(), pos.end(), q) - pos.begin();\n            int l = (p - 1 + pos.size()) % pos.size();\n            int r = (p + 1) % pos.size();\n            int d1 = abs(q - pos[l]);\n            int d2 = abs(q - pos[r]);\n            d1 = min(d1, n - d1);\n            d2 = min(d2, n - d2);\n            ans.push_back(min(d1, d2));\n        }\n        return ans;\n    }\n};","author":"Sagen Hansda","submissionId":"1575125841"},[{"id":"238","similarity":0.9142857142857143,"totOverlap":160,"longestOverlap":39}]],"833":[{"id":"833","fileName":"1575126261.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& ar, vector<int>& q) {\n        int n = ar.size(), m = q.size();\n        unordered_map<int, vector<int>> mp;\n        for(int i=0;i<n;i++){\n            mp[ar[i]].push_back(i);\n        }\n        vector<int> ans(m, -1);\n        for (int i=0;i<m;i++){\n            int idx = q[i];\n            int val = ar[idx];\n            vector<int>& id = mp[val];\n            if(id.size() == 1){\n                ans[i] = -1;\n            } else {\n                int pos = lower_bound(id.begin(), id.end(), idx) - id.begin();\n                int d1 = INT_MAX, d2 = INT_MAX;\n                if(pos+1 < id.size()){\n                    int ok = id[pos+1];\n                    int diff = abs(ok - idx);\n                    d1 = min(diff, n - diff);\n                }\n                if(pos-1 >= 0){\n                    int ok = id[pos-1];\n                    int diff = abs(idx - ok);\n                    d2 = min(diff, n - diff);\n                }\n                if(pos == 0){\n                    int ok = id.back();\n                    int diff = abs(idx - ok);\n                    d2 = min(diff, n - diff);\n                }\n                if(pos == id.size()-1){\n                    int ok = id.front();\n                    int diff = abs(ok - idx);\n                    d1 = min(diff, n - diff);\n                }\n                ans[i] = min(d1, d2);\n            }\n        }\n        return ans;\n    }\n};","author":"Abdulla bin ah","submissionId":"1575126261"},[{"id":"770","similarity":0.7131782945736435,"totOverlap":184,"longestOverlap":14}]],"847":[{"id":"847","fileName":"1575126729.txt","sourceCode":"class Solution {\npublic:\n    int gunjeshcircularDistance(int g, int u , int n)\n{\n    int j = abs(g-u);\n    int e = min(j , n-j);\n    return e;\n}\n    vector<int> solveQueries(vector<int>& gunjesh, vector<int>& kumar) \n    {\n        int kum = gunjesh.size();\n        unordered_map<int, vector<int>> gun;\n        for(int g =0; g<kum; g++)\n            {\n                gun[gunjesh[g]].push_back(g);\n            }\n        for(auto &u : gun)\n            {\n                sort(u.second.begin(), u.second.end());\n            }\n        vector<int> r;\n        for(int u : kumar)\n            {\n                int n = gunjesh[u];\n                const vector<int>& e = gun[n];\n                if(e.size()<2)\n                {\n                    r.push_back(-1);\n                }\n                else\n                {\n                    auto s = lower_bound(e.begin(),e.end(), u);\n                    int j = s - e.begin();\n                    int h = (j-1+e.size())%e.size();\n                    int k = (j+1)% e.size();\n                    int s1 = gunjeshcircularDistance(u, e[h], kum);\n                    int s2 = gunjeshcircularDistance(u, e[k], kum);\n                    r.push_back(min(s1, s2));\n                }\n            }\n        return r;\n    }\n};","author":"GUNJESH KUMAR","submissionId":"1575126729"},[{"id":"258","similarity":0.8663101604278075,"totOverlap":162,"longestOverlap":34}]],"868":[{"id":"868","fileName":"1575127412.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> result(n, -1);\n        unordered_map<int, vector<int>> indexMap;\n        \n        // Populate the index map\n        buildIndexMap(nums, indexMap);\n\n        // Compute minimum cyclic distances\n        computeMinDistances(indexMap, n, result);\n\n        // Process queries\n        return processQueries(result, queries);\n    }\n\nprivate:\n    void buildIndexMap(vector<int>& nums, unordered_map<int, vector<int>>& indexMap) {\n        for (int i = 0; i < nums.size(); i++) {\n            indexMap[nums[i]].push_back(i);\n        }\n    }\n\n    void computeMinDistances(unordered_map<int, vector<int>>& indexMap, int n, vector<int>& result) {\n        for (auto& entry : indexMap) {\n            vector<int>& positions = entry.second;\n            if (positions.size() < 2) continue;\n\n            sort(positions.begin(), positions.end());\n            int k = positions.size();\n\n            for (int j = 0; j < k; j++) {\n                int currIndex = positions[j];\n                int prevIndex = positions[(j - 1 + k) % k];\n                int nextIndex = positions[(j + 1) % k];\n\n                int dist1 = min(abs(currIndex - prevIndex), n - abs(currIndex - prevIndex));\n                int dist2 = min(abs(nextIndex - currIndex), n - abs(nextIndex - currIndex));\n\n                result[currIndex] = min(dist1, dist2);\n            }\n        }\n    }\n\n    vector<int> processQueries(vector<int>& result, vector<int>& queries) {\n        vector<int> queryResults;\n        for (int q : queries) {\n            queryResults.push_back(result[q]);\n        }\n        return queryResults;\n    }\n};\n","author":"SUDHARSHAN R","submissionId":"1575127412"},[{"id":"184","similarity":0.7990430622009569,"totOverlap":167,"longestOverlap":28}]],"874":[{"id":"874","fileName":"1575127629.txt","sourceCode":"class Solution {\npublic:\n    int circularDistance(int i, int j, int n) {\n        int diff = abs(i - j);\n        return min(diff, n - diff);\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        unordered_map<int, vector<int>> positions;\n        for (int i = 0; i < n; i++) {\n            positions[nums[i]].push_back(i);\n        }\n\n        for (auto& entry : positions) {\n            sort(entry.second.begin(), entry.second.end());\n        }\n\n        vector<int> answer(m, -1);\n        for (int i = 0; i < m; i++) {\n            int q = queries[i];\n            int value = nums[q];\n            auto& posList = positions[value];\n            if (posList.size() == 1)\n                continue;\n            auto it = lower_bound(posList.begin(), posList.end(), q);\n            int idx = it - posList.begin();\n            int leftCandidate =\n                posList[(idx - 1 + posList.size()) % posList.size()];\n            int rightCandidate = posList[(idx + 1) % posList.size()];\n            int d1 = circularDistance(q, leftCandidate, n);\n            int d2 = circularDistance(q, rightCandidate, n);\n            answer[i] = min(d1, d2);\n        }\n        return answer;\n    }\n};","author":"glorious","submissionId":"1575127629"},[{"id":"328","similarity":0.765,"totOverlap":153,"longestOverlap":22}]],"902":[{"id":"902","fileName":"1575128285.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int, vector<int>> m;\n        for (int i = 0; i < n; i++) {\n            m[nums[i]].push_back(i);\n        }\n        \n        vector<int> r;\n        for (int i = 0; i < queries.size(); i++) {\n            int v = nums[queries[i]];\n            vector<int>& p = m[v];\n            \n            if (p.size() == 1) {\n                r.push_back(-1);\n                continue;\n            }\n            \n            int a1 = lower_bound(p.begin(), p.end(), queries[i]) - p.begin();\n            int d = INT_MAX;\n            \n            if (a1 < p.size() && p[a1] == queries[i]) {\n                if (a1 > 0) {\n                    int diff = abs(queries[i] - p[a1 - 1]);\n                    int cand = min(diff, n - diff);\n                    d = min(d, cand);\n                }\n                if (a1 + 1 < p.size()) {\n                    int diff = abs(queries[i] - p[a1 + 1]);\n                    int cand = min(diff, n - diff);\n                    d = min(d, cand);\n                }\n            }\n            else {\n                if (a1 < p.size()) {\n                    int diff = abs(queries[i] - p[a1]);\n                    int cand = min(diff, n - diff);\n                    d = min(d, cand);\n                }\n                if (a1 > 0) {\n                    int diff = abs(queries[i] - p[a1 - 1]);\n                    int cand = min(diff, n - diff);\n                    d = min(d, cand);\n                }\n            }\n            \n            if (p.front() != queries[i]) {\n                int diff = abs(queries[i] - p.front());\n                int cand = min(diff, n - diff);\n                d = min(d, cand);\n            }\n            if (p.back() != queries[i]) {\n                int diff = abs(queries[i] - p.back());\n                int cand = min(diff, n - diff);\n                d = min(d, cand);\n            }\n            \n            r.push_back(d);\n        }\n        return r;\n    }\n};\n","author":"1oPhytGbYO","submissionId":"1575128285"},[{"id":"770","similarity":0.7042682926829268,"totOverlap":231,"longestOverlap":22}]],"904":[{"id":"904","fileName":"1575128379.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>>mp;\n        int n=nums.size();\n        int q=queries.size();\n        for(int i=0;i<n;i++){\n             mp[nums[i]].push_back(i);\n        }\n        vector<int>ans;\n        for(int i=0;i<q;i++){\n            int val=nums[queries[i]];\n            vector<int>&v=mp[val];\n             if(v.size() < 2) {\n              ans.push_back(-1);\n              continue;\n        }\n    \n        int pos = lower_bound(v.begin(), v.end(), queries[i]) - v.begin();\n        \n        int nxtIndx= v[(pos + 1) % v.size()];\n        int prevIndx = v[(pos - 1 + v.size()) % v.size()];\n        \n        int distNext = abs(nxtIndx - queries[i]);\n        int distPrev = abs(queries[i] - prevIndx);\n        distNext = min(distNext, n - distNext);\n        distPrev = min(distPrev, n - distPrev);\n        \n        ans.push_back(min(distNext, distPrev));\n        }\n        return ans;\n    }\n};","author":"Mangalgupta","submissionId":"1575128379"},[{"id":"741","similarity":0.7842105263157895,"totOverlap":149,"longestOverlap":16}]],"937":[{"id":"937","fileName":"1575128942.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int, vector<int>> pos;\n        for (int i = 0; i < n; i++) {\n            pos[nums[i]].push_back(i);\n        }\n        for (auto &it : pos) {\n            sort(it.second.begin(), it.second.end());\n        }\n        \n        vector<int> ans;\n        auto dis = [&](int i, int j) {\n            int diff = abs(i - j);\n            return min(diff, n - diff);\n        };\n        \n        for (int q : queries) {\n            int val = nums[q];\n            vector<int>&temp = pos[val];\n            if (temp.size()==1) {\n                ans.push_back(-1);\n                continue;\n            }\n            auto it = lower_bound(temp.begin(), temp.end(), q);\n            int index = it - temp.begin();\n            int lpos = temp[(index - 1 + temp.size()) % temp.size()];\n            int rpos = temp[ (index + 1) % temp.size()];\n            \n            int d1 = dis(q, lpos);\n            int d2 = dis(q, rpos);\n            ans.push_back(min(d1, d2));\n        }\n        return ans;\n    }\n};\n","author":"LikithReddy","submissionId":"1575128942"},[{"id":"937","similarity":0.8969072164948454,"totOverlap":174,"longestOverlap":32}]],"954":[{"id":"954","fileName":"1575129347.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solve(vector<int>& nums, vector<int>& queries) {\n    unordered_map<int, vector<int>> valToIndices;\n    int n = nums.size();\n    for (int i = 0; i < n; ++i) {\n        valToIndices[nums[i]].push_back(i);\n    }\n    \n    vector<int> answer;\n    for (int q : queries) {\n        int v = nums[q];\n        auto& indices = valToIndices[v];\n        if (indices.size() <= 1) {\n            answer.push_back(-1);\n            continue;\n        }\n        \n        \n        auto it = lower_bound(indices.begin(), indices.end(), q);\n        int pos = it - indices.begin();\n        \n        int prev, next;\n        \n        if (pos > 0) {\n            prev = indices[pos - 1];\n        } else {\n            prev = indices.back();\n        }\n      \n        if (pos < indices.size() - 1) {\n            next = indices[pos + 1];\n        } else {\n            next = indices[0];\n        }\n        \n       \n        int d1 = min(abs(q - prev), n - abs(q - prev));\n        int d2 = min(abs(q - next), n - abs(q - next));\n        answer.push_back(min(d1, d2));\n    }\n    return answer;\n}\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        return solve(nums,queries);\n    }\n};","author":"Charan R","submissionId":"1575129347"},[{"id":"49","similarity":0.9203980099502488,"totOverlap":185,"longestOverlap":62}]],"959":[{"id":"959","fileName":"1575129343.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& arr, vector<int>& q) {\n        int len = arr.size();\n        unordered_map<int, vector<int>> pos;\n\n        for (int i = 0; i < len; i++) {\n            pos[arr[i]].push_back(i);\n        }\n\n        vector<int> ans;\n        for (int idx : q) {\n            int val = arr[idx];\n            const vector<int>& p = pos[val];\n            if (p.size() <= 1) {\n                ans.push_back(-1);\n                continue;\n            }\n\n            auto it = lower_bound(p.begin(), p.end(), idx);\n            int posIdx = it - p.begin();\n\n            int left = p[(posIdx - 1 + p.size()) % p.size()];\n            int right = p[(posIdx + 1) % p.size()];\n\n            int dL = min(abs(idx - left), len - abs(idx - left));\n            int dR = min(abs(idx - right), len - abs(idx - right));\n\n            ans.push_back(min(dL, dR));\n        }\n        return ans;\n    }\n};\n","author":"uJMQbJwlnP","submissionId":"1575129343"},[{"id":"173","similarity":0.8797814207650273,"totOverlap":161,"longestOverlap":45}]],"974":[{"id":"974","fileName":"1575129819.txt","sourceCode":"\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int len = nums.size();\n        vector<int> dist(len, -1);\n        unordered_map<int, vector<int>> m;\n        for (int i = 0; i < len; i++) {\n            m[nums[i]].push_back(i);\n        }\n        for (auto &e : m) {\n            vector<int>& locs = e.second;\n            if (locs.size() < 2) continue;\n            sort(locs.begin(), locs.end());\n            int cnt = locs.size();\n            for (int i = 0; i < cnt; i++) {\n                int cur = locs[i];\n                int prev = locs[(i - 1 + cnt) % cnt];\n                int next = locs[(i + 1) % cnt];\n                int d1 = abs(cur - prev);\n                d1 = min(d1, len - d1);\n                int d2 = abs(next - cur);\n                d2 = min(d2, len - d2);\n                dist[cur] = min(d1, d2);\n            }\n        }\n        vector<int> ans;\n        for (int idx : queries) {\n            ans.push_back(dist[idx]);\n        }\n        return ans;\n    }\n};\n","author":"sridarshofcl","submissionId":"1575129819"},[{"id":"184","similarity":0.9720670391061452,"totOverlap":174,"longestOverlap":54}]],"977":[{"id":"977","fileName":"1575129948.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int arraySize = nums.size();\n\n        unordered_map<int, vector<int>> valueToIndices;\n        valueToIndices.reserve(arraySize);\n        valueToIndices.max_load_factor(0.7f);\n\n        for (int i = 0; i < arraySize; i++) {\n            valueToIndices[nums[i]].push_back(i);\n        }\n\n        for (auto& entry : valueToIndices) {\n            sort(entry.second.begin(), entry.second.end());\n        }\n\n        auto getCircularDistance = [&](int i, int j) {\n            int diff = abs(i - j);\n            return min(diff, arraySize - diff);\n        };\n\n        vector<int> answers(queries.size(), -1);\n\n        for (int q = 0; q < (int)queries.size(); q++) {\n            int queryIndex = queries[q];\n            int value = nums[queryIndex];\n\n            auto& indices = valueToIndices[value];\n            if (indices.size() < 2) {\n                answers[q] = -1;\n                continue;\n            }\n\n            auto it = lower_bound(indices.begin(), indices.end(), queryIndex);\n            int pos = (int)(it - indices.begin());\n\n            int leftPos  = (pos - 1 + (int)indices.size()) % indices.size();\n            int rightPos = (pos + 1) % indices.size();\n\n            int leftDist  = getCircularDistance(queryIndex, indices[leftPos]);\n            int rightDist = getCircularDistance(queryIndex, indices[rightPos]);\n\n            answers[q] = min(leftDist, rightDist);\n        }\n\n        return answers;\n    }\n};\n","author":"Gaurav Chaudhari","submissionId":"1575129948"},[{"id":"186","similarity":0.9070796460176991,"totOverlap":205,"longestOverlap":52}]],"994":[{"id":"994","fileName":"1575130305.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        \n        vector<int> minDist(n, -1);\n        \n        \n        unordered_map<int, vector<int>> groups;\n        for (int i = 0; i < n; i++) {\n            groups[nums[i]].push_back(i);\n        }\n        \n        for (auto &entry : groups) {\n            vector<int>& idxList = entry.second;\n            int m = idxList.size();\n            if (m < 2) continue;\n            \n            for (int i = 0; i < m; i++) {\n                int curr = idxList[i];\n                int prev = idxList[(i - 1 + m) % m];  \n                int next = idxList[(i + 1) % m];        \n                int d1 = (curr >= prev) ? curr - prev : curr + n - prev;\n                int d2 = (next >= curr) ? next - curr : next + n - curr;\n                minDist[curr] = min(d1, d2);\n            }\n        }\n        \n        vector<int> res;\n        for (int q : queries) {\n            res.push_back(minDist[q]);\n        }\n        return res;\n    }\n};","author":"karton9647","submissionId":"1575130305"},[{"id":"160","similarity":0.7914110429447853,"totOverlap":129,"longestOverlap":12}]],"1006":[{"id":"1006","fileName":"1575130574.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> valueToIndices;\n        int n = nums.size();\n\n        for (int i = 0; i < n; ++i) {\n            valueToIndices[nums[i]].push_back(i);\n        }\n\n        for (auto& pair : valueToIndices) {\n            sort(pair.second.begin(), pair.second.end());\n        }\n        \n        vector<int> answer;\n        \n        for (int q : queries) {\n            int value = nums[q];\n            auto& indices = valueToIndices[value];\n            \n            if (indices.size() <= 1) {\n                answer.push_back(-1);\n                continue;\n            }\n\n            auto it = lower_bound(indices.begin(), indices.end(), q);\n            int pos = it - indices.begin();\n            int len = indices.size();\n            int prev_pos = (pos - 1 + len) % len;\n            int next_pos = (pos + 1) % len;\n            \n            int prev_index = indices[prev_pos];\n            int next_index = indices[next_pos];\n            int dist_prev = min(abs(prev_index - q), n - abs(prev_index - q));\n            int dist_next = min(abs(next_index - q), n - abs(next_index - q));\n            \n            answer.push_back(min(dist_prev, dist_next));\n        }\n        \n        return answer;\n    }\n};","author":"Rupesh ranjan","submissionId":"1575130574"},[{"id":"1269","similarity":1.0,"totOverlap":190,"longestOverlap":95},{"id":"1006","similarity":0.934010152284264,"totOverlap":184,"longestOverlap":55},{"id":"1934","similarity":0.8805970149253731,"totOverlap":177,"longestOverlap":20},{"id":"1006","similarity":0.9617486338797814,"totOverlap":176,"longestOverlap":63},{"id":"1979","similarity":0.8917525773195877,"totOverlap":173,"longestOverlap":60},{"id":"391","similarity":0.9444444444444444,"totOverlap":170,"longestOverlap":63}]],"1013":[{"id":"1013","fileName":"1575130761.txt","sourceCode":"class Solution {\npublic:\n\n\n//    int ff(int x, int y, int n)\n// {\n//     int diff = abs(y-x);\n\n//     return min(diff, n-diff);\n    \n// }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n\n        vector<int> ans;\n        map<int,vector<int>> mm;\n        for(int i=0;i<n;i++)\n            {\n                mm[nums[i]].push_back(i);\n            }\n\n\n        for(auto &ii:mm)\n            {\n                sort(ii.second.begin(), ii.second.end());\n            }\n\n\n        auto ff = [&](int i, int  j)\n        {\n            int d = abs(i-j);\n            return min(d, n-d);\n        };\n\n        for(auto ii:queries)\n            {\n                int xx = nums[ii];\n                if(mm[xx].size() < 2)\n                {\n                    ans.push_back(-1);\n                }\n                else \n                {\n                    vector<int> &vv = mm[xx];\n\n                    int ind = lower_bound(vv.begin(), vv.end(), ii) - vv.begin();\n                    int ll = vv[(ind-1 + vv.size()) % vv.size()];\n                    int rr = vv[(ind+1)%vv.size()];\n                    ans.push_back(min(ff(ii, ll), ff(ii, rr)));\n                }\n            }\n\n        return ans;\n        \n    }\n};","author":"Rsoniie","submissionId":"1575130761"},[{"id":"1013","similarity":0.7754010695187166,"totOverlap":145,"longestOverlap":18}]],"1036":[{"id":"1036","fileName":"1575131430.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        unordered_map<int,vector<int>> pos;\n        for(int i=0;i<nums.size();i++){\n            pos[nums[i]].push_back(i);\n        }\n        vector<int> ans(nums.size(),-1);\n        for(auto& it:pos){\n            auto& v=it.second;\n            sort(v.begin(),v.end());\n            if(v.size()>1){\n                for(int j=0;j<v.size();j++){\n                    int cur = v[j], prev = v[(j - 1 + v.size()) % v.size()], next = v[(j + 1) % v.size()];\n                    int d1 = min(abs(cur - prev), n - abs(cur - prev)), d2 = min(abs(cur - next), n - abs(cur - next));\n                    ans[cur] = min(d1, d2);\n                }\n            }\n        }\n        vector<int> ans2;\n        for(int& x:queries){\n            ans2.push_back(ans[x]);\n        }\n        return ans2;\n    }\n};","author":"prajpro","submissionId":"1575131430"},[{"id":"448","similarity":0.7058823529411765,"totOverlap":132,"longestOverlap":11}]],"1050":[{"id":"1050","fileName":"1575131751.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> val_to_indices;\n    int n = nums.size();\n    for (int i = 0; i < n; ++i) {\n        val_to_indices[nums[i]].push_back(i);\n    }\n    \n    for (auto& [v, indices] : val_to_indices) {\n        sort(indices.begin(), indices.end());\n    }\n    \n    vector<int> answer;\n    for (int q : queries) {\n        int v = nums[q];\n        auto& indices = val_to_indices[v];\n        if (indices.size() == 1) {\n            answer.push_back(-1);\n            continue;\n        }\n        \n        auto it = lower_bound(indices.begin(), indices.end(), q);\n        int pos = it - indices.begin();\n        \n        int modified_first, modified_last;\n        if (pos == 0) {\n            modified_first = indices[1];\n        } else {\n            modified_first = indices[0];\n        }\n        \n        if (pos == indices.size() - 1) {\n            modified_last = indices[indices.size() - 2];\n        } else {\n            modified_last = indices.back();\n        }\n        \n        vector<int> candidates;\n        if (pos > 0) {\n            candidates.push_back(indices[pos - 1]);\n        }\n        if (pos < indices.size() - 1) {\n            candidates.push_back(indices[pos + 1]);\n        }\n        candidates.push_back(modified_first);\n        candidates.push_back(modified_last);\n        \n        int min_dist = INT_MAX;\n        for (int idx : candidates) {\n            int diff = abs(q - idx);\n            int dist = min(diff, n - diff);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n        answer.push_back(min_dist);\n    }\n    \n    return answer;\n    }\n};","author":"Gautam Kumar","submissionId":"1575131751"},[{"id":"1050","similarity":0.8202764976958525,"totOverlap":178,"longestOverlap":40}]],"1078":[{"id":"1078","fileName":"1575132512.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        for (auto &p : mp) {\n            sort(p.second.begin(), p.second.end());\n        }\n        vector<int> result;\n        for (int q : queries) {\n            int ele = nums[q];\n            auto &vec = mp[ele];\n            if (vec.size() == 1) {\n                result.push_back(-1);\n            } else {\n                auto it = lower_bound(vec.begin(), vec.end(), q);\n                int idx = it - vec.begin();\n                int prevIndex = (idx + vec.size() - 1) % vec.size();\n                int nextIndex = (idx + 1) % vec.size();\n                int dist1 = abs(q - vec[prevIndex]);\n                dist1 = min(dist1, n - dist1);\n                int dist2 = abs(q - vec[nextIndex]);\n                dist2 = min(dist2, n - dist2);\n                result.push_back(min(dist1, dist2));\n            }\n        }\n        return result;\n    }\n};\n","author":"autumn_1eaf","submissionId":"1575132512"},[{"id":"847","similarity":0.8138297872340425,"totOverlap":153,"longestOverlap":34}]],"1081":[{"id":"1081","fileName":"1575132402.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int, vector<int>> X;\n        for (int i = 0; i < n; i++) {\n            X[nums[i]].push_back(i);\n        }\n        auto diff = [&](int i, int j) -> int {\n            int dist = abs(i - j);\n            return min(dist, n - dist);\n        };\n        int Q = queries.size();\n        vector<int> ans(Q,-1);\n        for (int _ = 0; _ < Q; _++) {\n            int num = nums[queries[_]];\n            int pos = queries[_];\n            auto& vals = X[num];\n            if (vals.size() == 1) continue;\n            auto i = lower_bound(vals.begin(), vals.end(), pos) - vals.begin();\n            int sz = vals.size();\n            int li = vals[(i-1 + sz) % sz];\n            int ri = vals[(i+1) % sz];\n            ans[_] = min(diff(pos, li), diff(pos, ri));\n        }\n        return ans;\n    }\n};","author":"abz-codes","submissionId":"1575132402"},[{"id":"874","similarity":0.700507614213198,"totOverlap":138,"longestOverlap":14}]],"1087":[{"id":"1087","fileName":"1575132718.txt","sourceCode":"class Solution {\npublic:\n    int calc(vector<int>& vec, int q, int n) {\n        int idx = lower_bound(vec.begin(), vec.end(), q)-vec.begin();\n        int nxtidx= idx+1;\n        int next=vec[nxtidx % vec.size()];\n        int previdx=idx-1+vec.size();\n        int prev = vec[previdx % vec.size()];\n        return min(min(abs(q - next), n - abs(q - next)),  min(abs(q-prev), n -abs(q-prev)));\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        for (auto &it : mp) {\n            sort(it.second.begin(), it.second.end());\n        }\n        vector<int> ans;\n        for (int q : queries) {\n            int val = nums[q];\n            auto &vec = mp[val];\n            if (vec.size()==1 || vec.size()==0){\n                ans.push_back(-1);continue;\n            }\n            ans.push_back(calc(vec, q, n));\n        }\n        return ans;\n    }\n};\n","author":"NISHANT TIWARI","submissionId":"1575132718"},[{"id":"258","similarity":0.7135135135135136,"totOverlap":132,"longestOverlap":37}]],"1096":[{"id":"1096","fileName":"1575133031.txt","sourceCode":"class Solution {\npublic:\n  vector<int> solveQueries(const vector<int>& nums, const vector<int>& queries) {\n    int n = nums.size();\n    unordered_map<int, vector<int>> index;\n    for (int i = 0; i < n; ++i) {\n      index[nums[i]].push_back(i);\n    }\n    auto dis = [&](int a, int b) -> int {\n      return min(abs(a - b), n - abs(a - b));\n    };\n    vector<int> res;\n    for (int q : queries) {\n      int value = nums[q];\n      if (index[value].size() == 1) {\n        res.push_back(-1);\n        continue;\n      }\n      auto& idx = index[value];\n      int pos = lower_bound(idx.begin(), idx.end(), q) - idx.begin();\n      int ia = (pos + 1) % idx.size(), ib = (pos + idx.size() - 1) % idx.size();\n      res.push_back(min(dis(idx[pos], idx[ia]), dis(idx[pos], idx[ib])));\n    }\n    return res;\n  }\n};","author":"Dexter","submissionId":"1575133031"},[{"id":"788","similarity":0.718562874251497,"totOverlap":120,"longestOverlap":17}]],"1221":[{"id":"1221","fileName":"1575136198.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> pos;\n        for (int i = 0; i < n; i++) {\n            pos[nums[i]].push_back(i);\n        }\n        for (auto &p: pos) sort(p.second.begin(), p.second.end());\n        vector<int> ans;\n        for (int idx: queries) {\n            if (pos[nums[idx]].size() < 2) { ans.push_back(-1); continue; }\n            // int dr = INT_MAX, dl = INT_MAX;\n            auto it = lower_bound(pos[nums[idx]].begin(), pos[nums[idx]].end(), idx);\n            // if (*it == idx) {\n            //     if (it != pos[nums[idx]].end()) {\n            //         if (it + 1 != pos[nums[idx]].end()) {\n            //             int cand = *(it + 1);\n            //             dr = min(abs(idx - cand), n - abs(idx - cand));\n            //         } else {\n            //             int cand = pos[nums[idx]].back();\n            //             dl = min(abs(idx - cand), n - abs(idx - cand));\n            //         }\n            //     }\n            // }\n            int rc = (it == pos[nums[idx]].end()-1) ? pos[nums[idx]][0] : *(it + 1);\n            int lc = (it == pos[nums[idx]].begin()) ? pos[nums[idx]].back() : *(it - 1);\n            int dr = min(abs(idx - rc), n - abs(idx - rc));\n            int dl  = min(abs(idx - lc), n - abs(idx - lc));\n            ans.push_back(min(dl, dr));\n        }\n        return ans;\n    }\n};","author":"Adithya","submissionId":"1575136198"},[{"id":"126","similarity":0.7247191011235955,"totOverlap":129,"longestOverlap":24}]],"1224":[{"id":"1224","fileName":"1575136275.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int>ans;\n        int n=nums.size();\n        map<int,vector<int>>mpp;\n        for(int i=0;i<n;i++) mpp[nums[i]].push_back(i);\n        for(auto& ele:queries){\n            int sz=mpp[nums[ele]].size();\n            if(sz<2){\n                ans.push_back(-1);\n                continue;\n            }\n            vector<int>&idx=mpp[nums[ele]];\n            int p=lower_bound(idx.begin(),idx.end(),ele)-idx.begin();\n            int l=idx[(p-1+sz)%sz];\n            int r=idx[(p+1)%sz];\n            int d1=abs(ele-l),d2=abs(r-ele);\n            d1=min(d1,n-d1);d2=min(d2,n-d2);\n            int mini=min(d1,d2);\n            ans.push_back(mini);\n            // if(sz>=3){\n            //     int j=0;\n            //     for(;j<sz;j++){\n            //         if(mpp[nums[ele]][j]==ele) break;\n            //     }\n            //     int idx=-1;\n            //     if(j==0) idx=mpp[nums[ele]][j+1]; \n            //     else if(j==sz-1) idx=mpp[nums[ele]][j-1]; \n            //     else{\n            //         if(mpp[nums[ele]][j+1]-mpp[nums[ele]][j]<mpp[nums[ele]][j]-mpp[nums[ele]][j-1]){\n            //             idx=j+1;\n            //         }\n            //         else idx=j-1;\n            //     }\n            //     ans.push_back(idx);\n            // }\n            // else if(sz==2){\n            //     if(mpp[nums[ele]][0]==ele){\n            //         ans.push_back(mpp[nums[ele]][1]);\n            //     }\n            //     else ans.push_back(mpp[nums[ele]][0]);\n            // }\n            // else if(sz==1){\n            //     ans.push_back(-1);\n            // }\n        }\n        return ans;\n        \n    }\n};","author":"Sahil Singh","submissionId":"1575136275"},[{"id":"769","similarity":0.7321428571428571,"totOverlap":123,"longestOverlap":21}]],"1230":[{"id":"1230","fileName":"1575136438.txt","sourceCode":"#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<pair<int, int>>> valueToIndices;\n        unordered_map<int, vector<int>> tempMap;\n        \n        \n        for (int i = 0; i < n; ++i) {\n            tempMap[nums[i]].push_back(i);\n        }\n        \n        \n        for (auto& [val, indices] : tempMap) {\n            int k = indices.size();\n            if (k == 1) {\n                valueToIndices[val].emplace_back(indices[0], -1);\n                continue;\n            }\n            for (int j = 0; j < k; ++j) {\n                int prev_j = (j - 1 + k) % k;\n                int next_j = (j + 1) % k;\n                int current = indices[j];\n                int prev = indices[prev_j];\n                int next = indices[next_j];\n                \n                int dist_prev = abs(current - prev);\n                dist_prev = min(dist_prev, n - dist_prev);\n                \n                int dist_next = abs(current - next);\n                dist_next = min(dist_next, n - dist_next);\n                \n                int min_dist = min(dist_prev, dist_next);\n                valueToIndices[val].emplace_back(current, min_dist);\n            }\n            \n            sort(valueToIndices[val].begin(), valueToIndices[val].end());\n        }\n        \n        vector<int> result;\n        for (int q : queries) {\n            int val = nums[q];\n            auto& vec = valueToIndices[val];\n            if (vec.size() == 1) {\n                result.push_back(-1);\n                continue;\n            }\n            \n            auto it = lower_bound(vec.begin(), vec.end(), q, [](const pair<int, int>& p, int v) {\n                return p.first < v;\n            });\n            if (it != vec.end() && it->first == q) {\n                result.push_back(it->second);\n            } else {\n                result.push_back(-1); \n            }\n        }\n        \n        return result;\n    }\n};","author":"Kuldeep","submissionId":"1575136438"},[{"id":"1966","similarity":0.7542372881355932,"totOverlap":178,"longestOverlap":21},{"id":"611","similarity":0.7023809523809523,"totOverlap":177,"longestOverlap":23}]],"1253":[{"id":"1253","fileName":"1575137120.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> indexMap;\n\n        // Step 1: Store indices of each value in nums\n        for (int i = 0; i < n; i++) {\n            indexMap[nums[i]].push_back(i);\n        }\n\n        vector<int> answer;\n\n        // Step 2: Process each query\n        for (int idx : queries) {\n            int val = nums[idx];\n\n            // If no duplicate exists, return -1\n            if (indexMap[val].size() == 1) {\n                answer.push_back(-1);\n                continue;\n            }\n\n            vector<int>& indices = indexMap[val];\n            int pos = lower_bound(indices.begin(), indices.end(), idx) - indices.begin();\n\n            int nextIdx = indices[(pos + 1) % indices.size()];\n            int prevIdx = indices[(pos - 1 + indices.size()) % indices.size()];\n\n            int forwardDist = (nextIdx - idx + n) % n;\n            int backwardDist = (idx - prevIdx + n) % n;\n\n            answer.push_back(min(forwardDist, backwardDist));\n        }\n\n        return answer;\n    }\n};\n\n","author":"shubham choudhary","submissionId":"1575137120"},[{"id":"619","similarity":0.783625730994152,"totOverlap":134,"longestOverlap":22}]],"1269":[{"id":"1269","fileName":"1575137577.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            mp[nums[i]].push_back(i);}\n\n        \n        for (auto& ent : mp) {\n            sort(ent.second.begin(), ent.second.end());\n        }\n        vector<int> ans;\n        for (int q : queries) {\n            int val = nums[q];\n            auto& indices = mp[val];\n            if (indices.size() <= 1) {\n                ans.push_back(-1);\n                continue;}\n            \n            auto it = lower_bound(indices.begin(), indices.end(), q);\n            int pos = it - indices.begin();\n            int m = indices.size();\n            \n            int prev_p = (pos - 1 + m) % m;\n            int next_p = (pos + 1) % m;\n            int candidate1 = indices[prev_p];\n            int candidate2 = indices[next_p];\n            \n            int d1 = min(abs(q - candidate1), n - abs(q - candidate1));\n            int d2 = min(abs(q - candidate2), n - abs(q - candidate2));\n            ans.push_back(min(d1, d2));}\n        return ans;\n    }};","author":"Gaurav Chandola","submissionId":"1575137577"},[{"id":"1006","similarity":1.0,"totOverlap":190,"longestOverlap":95}]],"1311":[{"id":"1311","fileName":"1575138731.txt","sourceCode":"#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> indexTracker;  // Map to track positions of each number\n        int numsSize = nums.size();\n\n        // Record positions for each number in nums\n        for (int pos = 0; pos < numsSize; ++pos) {\n            indexTracker[nums[pos]].emplace_back(pos);\n        }\n\n        vector<int> minDistances(numsSize, -1);  // Initialize distances with -1\n\n        // Compute minimum distances for all elements\n        for (auto& [number, positions] : indexTracker) {\n            int count = positions.size();\n            \n            // Skip numbers that occur only once\n            if (count < 2) continue;\n\n            // For each occurrence, find closest neighbors circularly\n            for (int i = 0; i < count; ++i) {\n                int currentPos = positions[i];\n                int previousPos = positions[(i - 1 + count) % count];  // Previous occurrence\n                int nextPos = positions[(i + 1) % count];              // Next occurrence\n\n                int distPrev = min(abs(currentPos - previousPos), numsSize - abs(currentPos - previousPos));\n                int distNext = min(abs(currentPos - nextPos), numsSize - abs(currentPos - nextPos));\n\n                minDistances[currentPos] = min(distPrev, distNext);\n            }\n        }\n\n        vector<int> queryResults;  // Store results for queries\n        for (int queryIdx : queries) {\n            queryResults.push_back(minDistances[queryIdx]);\n        }\n\n        return queryResults;\n    }\n};\n","author":"SASIEDHARAN R","submissionId":"1575138731"},[{"id":"868","similarity":0.7475247524752475,"totOverlap":151,"longestOverlap":35}]],"1361":[{"id":"1361","fileName":"611229646.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> posMap;\n        for (int i = 0; i < n; i++) {\n            posMap[nums[i]].push_back(i);\n        }\n        for (auto& p : posMap) {\n            sort(p.second.begin(), p.second.end());\n        }\n\n        vector<int> ans;\n        for (int q : queries) {\n            int v = nums[q];\n            vector<int>& indices = posMap[v];\n            if (indices.size() < 2) {\n                ans.push_back(-1);\n                continue;\n            }\n            int pos = int(lower_bound(indices.begin(), indices.end(), q) -\n                          indices.begin());\n            int left = indices[(pos - 1 + indices.size()) % indices.size()];\n            int right = indices[(pos + 1) % indices.size()];\n            auto calcDist = [&](int a, int b) -> int {\n                int diff = abs(a - b);\n                return min(diff, n - diff);\n            };\n            int d1 = calcDist(q, left);\n            int d2 = calcDist(q, right);\n            ans.push_back(min(d1, d2));\n        }\n        return ans;\n    }\n};\n","author":"8aus1R","submissionId":"611229646"},[{"id":"1535","similarity":1.0,"totOverlap":190,"longestOverlap":95},{"id":"1361","similarity":0.8969072164948454,"totOverlap":174,"longestOverlap":32},{"id":"173","similarity":0.8571428571428571,"totOverlap":168,"longestOverlap":38}]],"1446":[{"id":"1446","fileName":"611233534.txt","sourceCode":"int diff(int i1, int i2, int n){\n    return min(abs(i1-i2), n-abs(i1-i2));\n}\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> idx;\n        for(int i=0; i<n; ++i){\n            idx[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(auto q:queries){\n            int qv = nums[q];\n            auto &qi = idx[qv];\n            int m = qi.size();\n            if(qi.size()<=1){\n                ans.push_back(-1);\n            } else {\n                int j = lower_bound(qi.begin(), qi.end(), q)-qi.begin();\n                int j1 = qi[(m+j-1)%m];\n                int j2 = qi[(j+1)%m];\n                ans.push_back(min(diff(q, j1, n), diff(q, j2, n)));\n            }\n        }\n        return ans;\n    }\n};","author":"伽利略","submissionId":"611233534"},[{"id":"1446","similarity":0.7018633540372671,"totOverlap":113,"longestOverlap":24}]],"1519":[{"id":"1519","fileName":"611235354.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& A, vector<int>& Q) {\n        int N = A.size();\n        map<int, vector<int>> pos;\n        for (int i = 0; i < N; ++i)\n            pos[A[i]].push_back(i);\n        for (auto& p : pos)\n            sort(p.second.begin(), p.second.end());\n        vector<int> res;\n        for (int i : Q) {\n            int val = A[i];\n            const auto& idx = pos[val];\n            if (idx.size() == 1) {\n                res.push_back(-1);\n            } else {\n                int sz = idx.size();\n                auto it = lower_bound(idx.begin(), idx.end(), i);\n                int best = N;\n                if (it != idx.end() && *it == i) {\n                    int next_idx = idx[(it - idx.begin() + 1) % sz];\n                    int diff = abs(i - next_idx);\n                    best = min(best, min(diff, N - diff));\n                    int prev_idx =\n                        idx[((it - idx.begin() - 1) + sz) % sz];\n                    diff = abs(i - prev_idx);\n                    best = min(best, min(diff, N - diff));\n                } else {\n                    int pos1 = it - idx.begin();\n                    int cand1 = idx[pos1];\n                    int diff = abs(i - cand1);\n                    best = min(best, min(diff, N - diff));\n                    int pos2 = (pos1 - 1 + sz) % sz;\n                    int cand2 = idx[pos2];\n                    diff = abs(i - cand2);\n                    best = min(best, min(diff, N - diff));\n                }\n                res.push_back(best);\n            }\n        }\n        return res;\n    }\n};","author":"farmer","submissionId":"611235354"},[{"id":"331","similarity":0.7417840375586855,"totOverlap":158,"longestOverlap":35}]],"1535":[{"id":"1535","fileName":"611235859.txt","sourceCode":"class Solution {\npublic:\n        vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> posMap;\n        for (int i = 0; i < n; i++) \n        {\n            posMap[nums[i]].push_back(i);\n        }\n        for (auto& p : posMap) \n        {\n            sort(p.second.begin(), p.second.end());\n        }\n        vector<int> ans;\n        for (int q : queries) \n        {\n            int v = nums[q];\n            vector<int>& indices = posMap[v];\n            if (indices.size() < 2)\n            {\n                ans.push_back(-1);\n                continue;\n            }\n            int pos = int(lower_bound(indices.begin(), indices.end(), q) -\n                          indices.begin());\n            int left = indices[(pos - 1 + indices.size()) % indices.size()];\n            int right = indices[(pos + 1) % indices.size()];\n            auto calcDist = [&](int a, int b) -> int \n            {\n                int diff = abs(a - b);\n                return min(diff, n - diff);\n            };\n            int d1 = calcDist(q, left);\n            int d2 = calcDist(q, right);\n            ans.push_back(min(d1, d2));\n        }\n        return ans;\n    }\n};","author":"Sakura_luo","submissionId":"611235859"},[{"id":"1361","similarity":1.0,"totOverlap":190,"longestOverlap":95}]],"1598":[{"id":"1598","fileName":"611237563.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n    unordered_map<int, vector<int>> pos_map;\n    \n    // 预处理每个数值的位置，并排序\n    for (int i = 0; i < n; ++i) {\n        pos_map[nums[i]].push_back(i);\n    }\n    for (auto& [num, positions] : pos_map) {\n        sort(positions.begin(), positions.end());\n    }\n    \n    vector<int> answer;\n    for (int q : queries) {\n        int v = nums[q];\n        auto& list = pos_map[v];\n        \n        if (list.size() <= 1) {\n            answer.push_back(-1);\n            continue;\n        }\n        \n        // 二分查找找到q在列表中的位置\n        auto it = lower_bound(list.begin(), list.end(), q);\n        int k = it - list.begin();\n        \n        vector<int> candidates;\n        if (k > 0) {\n            candidates.push_back(list[k-1]);\n        }\n        if (k < list.size() - 1) {\n            candidates.push_back(list[k+1]);\n        }\n        candidates.push_back(list[0]);\n        candidates.push_back(list.back());\n        \n        // 过滤掉q本身\n        vector<int> valid;\n        for (int j : candidates) {\n            if (j != q) {\n                valid.push_back(j);\n            }\n        }\n        \n        if (valid.empty()) {\n            answer.push_back(-1);\n            continue;\n        }\n        \n        int min_d = INT_MAX;\n        for (int j : valid) {\n            int d = abs(j - q);\n            min_d = min(min_d, min(d, n - d));\n        }\n        answer.push_back(min_d);\n    }\n    \n    return answer;\n\n    }\n};","author":"Antares","submissionId":"611237563"},[{"id":"770","similarity":0.7603305785123967,"totOverlap":184,"longestOverlap":55}]],"1685":[{"id":"1685","fileName":"611240097.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n\n        unordered_map<int, vector<int>> mp;\n        for(int i = 0; i < n; i ++ ) {\n            mp[nums[i]].emplace_back(i);\n        }\n\n        vector<int> ans;\n\n        for(auto& q: queries) {\n            int val = nums[q];\n            auto& idv = mp[val];\n\n            int pos = lower_bound(idv.begin(), idv.end(), q) - idv.begin();\n            int m = idv.size();\n            int pre = idv[((pos - 1) % m + m) % m];\n            int pro = idv[(pos + 1) % m];\n\n            int d1 = min(abs(pre - q), n - abs(pre - q));\n            int d2 = min(abs(pro - q), n - abs(pro - q));\n\n            ans.emplace_back((min(d1, d2) == 0)? -1: min(d1, d2));\n        }\n        return ans;\n    }\n};","author":"空梦丶繁华褪去","submissionId":"611240097"},[{"id":"1685","similarity":0.711764705882353,"totOverlap":121,"longestOverlap":24}]],"1695":[{"id":"1695","fileName":"611240430.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        // 从左到右边\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].emplace_back(i);\n        }\n\n        vector<int> ans(queries.size());\n        for (int i = 0; i < queries.size(); i++) {\n            int q = queries[i];\n            vector<int>& arr = mp[nums[q]];\n            int m = arr.size();\n            if (m == 1) {\n                ans[i] = -1;\n            } else {\n                // 等于大于 q\n                int l = lower_bound(arr.begin(), arr.end(), q) - arr.begin();\n                int x = arr[(l + 1) % m], y = arr[(l + m - 1) % m];\n                int a =  min(abs(q - x), n - abs(q - x));\n                int b =  min(abs(q - y), n - abs(q - y));\n                ans[i] = min(a, b);\n            }\n        }\n        return ans;\n    }\n};\n\n\n","author":"一两截","submissionId":"611240430"},[{"id":"1751","similarity":0.7219251336898396,"totOverlap":135,"longestOverlap":16},{"id":"1311","similarity":0.7078651685393258,"totOverlap":126,"longestOverlap":20}]],"1751":[{"id":"1751","fileName":"611241921.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> umap;\n        for (int i = 0; i < nums.size(); ++i)\n            umap[nums[i]].push_back(i);\n        vector<int> minDist(nums.size());\n        for (auto& [n, indexs]: umap) {\n            int s = indexs.size();\n            int ns = nums.size();\n            if (s == 1)\n                minDist[indexs[0]] = -1;\n            else {\n                for (int i = 0; i < s; ++i) {\n                    int pos = indexs[i];\n                    int pre = indexs[(i + s - 1) % s];\n                    int next = indexs[(i + 1) % s];\n                    int preMin = min(abs(pos - pre), ns - abs(pos - pre));\n                    int nextMin =  min(abs(next - pos), ns - abs(next - pos));\n                    minDist[indexs[i]] = min(preMin, nextMin);\n                }\n            }\n        }\n        vector<int> ans(queries.size());\n        for (int i = 0; i < queries.size(); ++i)\n            ans[i] = minDist[queries[i]];\n        return ans;\n    }\n};","author":"KaguraChen","submissionId":"611241921"},[{"id":"1695","similarity":0.7219251336898396,"totOverlap":135,"longestOverlap":16}]],"1788":[{"id":"1788","fileName":"611243138.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n    unordered_map<int, vector<int>> num_indices;\n    for (int i = 0; i < n; ++i) {\n        num_indices[nums[i]].push_back(i);\n    }\n    for (auto& entry : num_indices) {\n        sort(entry.second.begin(), entry.second.end());\n    }\n    unordered_map<int, int> min_dist;\n    for (auto& entry : num_indices) {\n        const auto& indices = entry.second;\n        int m = indices.size();\n        if (m < 2) {  // 无其他相同元素，距离为-1\n            for (int idx : indices) {\n                min_dist[idx] = -1;\n            }\n            continue;\n        }\n        for (int k = 0; k < m; ++k) {\n            int current = indices[k];\n            int left = indices[(k - 1 + m) % m];  // 循环左邻居\n            int right = indices[(k + 1) % m];      // 循环右邻居\n            int d1 = min(abs(current - left), n - abs(current - left));\n            int d2 = min(abs(current - right), n - abs(current - right));\n            min_dist[current] = min(d1, d2);\n        }\n    }\n    vector<int> answer;\n    for (int q : queries) {\n        answer.push_back(min_dist[q]);\n    }\n    return answer;\n    }\n};","author":"Pensive CrayL8l","submissionId":"611243138"},[{"id":"868","similarity":0.7162790697674418,"totOverlap":154,"longestOverlap":34}]],"1792":[{"id":"1792","fileName":"611243181.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> value_to_indices;\n        for (int i = 0; i < n; ++i) {\n            value_to_indices[nums[i]].push_back(i);\n        }\n        for (auto& [v, indices] : value_to_indices) {\n            sort(indices.begin(), indices.end());\n        }\n        \n        vector<int> ans;\n        for (int pos : queries) {\n            int v = nums[pos];\n            auto& indices = value_to_indices[v];\n            if (indices.size() <= 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            auto it = lower_bound(indices.begin(), indices.end(), pos);\n            int idx = it - indices.begin();\n            int k = indices.size();\n            int pre_idx = (idx - 1 + k) % k;\n            int post_idx = (idx + 1) % k;\n            int j_pre = indices[pre_idx];\n            int j_post = indices[post_idx];\n            int dist_pre = min(abs(j_pre - pos), n - abs(j_pre - pos));\n            int dist_post = min(abs(j_post - pos), n - abs(j_post - pos));\n            ans.push_back(min(dist_pre, dist_post));\n        }\n        return ans;\n    }\n};","author":"小天才一休","submissionId":"611243181"},[{"id":"630","similarity":0.9719101123595506,"totOverlap":173,"longestOverlap":36}]],"1857":[{"id":"1857","fileName":"611246337.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> valueIndices;\n        for (int i = 0; i < n; ++i) {\n            valueIndices[nums[i]].push_back(i);\n        }\n        for (auto& entry : valueIndices) {\n            sort(entry.second.begin(), entry.second.end());\n        }\n\n        unordered_map<int, pair<int, int>> predSucc;\n        for (auto& entry : valueIndices) {\n            auto& indices = entry.second;\n            int m = indices.size();\n            if (m <= 1) continue;\n            for (int i = 0; i < m; ++i) {\n                int pred = (i == 0) ? indices.back() : indices[i - 1];\n                int succ = (i == m - 1) ? indices[0] : indices[i + 1];\n                predSucc[indices[i]] = {pred, succ};\n            }\n        }\n\n        vector<int> ans;\n        for (int q : queries) {\n            int v = nums[q];\n            auto& indices = valueIndices[v];\n            if (indices.size() <= 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            auto& ps = predSucc[q];\n            int pred = ps.first;\n            int succ = ps.second;\n\n            int d1 = abs(pred - q);\n            d1 = min(d1, n - d1);\n            int d2 = abs(succ - q);\n            d2 = min(d2, n - d2);\n            ans.push_back(min(d1, d2));\n        }\n        return ans;\n    }\n};","author":"code_sunflowers","submissionId":"611246337"},[{"id":"117","similarity":0.7464114832535885,"totOverlap":156,"longestOverlap":31}]],"1866":[{"id":"1866","fileName":"611247124.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> value_to_indices;\n        for (int i = 0; i < n; ++i) {\n            value_to_indices[nums[i]].push_back(i);\n        }\n\n        vector<int> answer;\n        for (int q : queries) {\n            int val = nums[q];\n            auto it = value_to_indices.find(val);\n            if (it == value_to_indices.end() || it->second.size() <= 1) {\n                answer.push_back(-1);\n                continue;\n            }\n            vector<int>& list = it->second;\n            auto pos_it = lower_bound(list.begin(), list.end(), q);\n            if (pos_it == list.end() || *pos_it != q) {\n                answer.push_back(-1);\n                continue;\n            }\n            int pos = pos_it - list.begin();\n            int m = list.size();\n            int left_pos = (pos - 1 + m) % m;\n            int right_pos = (pos + 1) % m;\n            int left = list[left_pos];\n            int right = list[right_pos];\n            int diff_left = abs(q - left);\n            int dist_left = min(diff_left, n - diff_left);\n            int diff_right = abs(q - right);\n            int dist_right = min(diff_right, n - diff_right);\n            answer.push_back(min(dist_left, dist_right));\n        }\n        return answer;\n    }\n};","author":"MaloFleur","submissionId":"611247124"},[{"id":"1866","similarity":0.8109452736318408,"totOverlap":163,"longestOverlap":28}]],"1918":[{"id":"1918","fileName":"611252068.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mymap;\n        vector<int> ans(queries.size());\n        int n = nums.size();\n        \n        for (int i = 0; i < n; ++i) {\n            mymap[nums[i]].push_back(i);\n        }\n        \n        for (int i = 0; i < queries.size(); ++i) {\n            int cur = queries[i];\n            int x = nums[cur];\n            vector<int>& vec = mymap[x];\n            if (vec.size() == 1) {\n                ans[i] = -1;\n                continue;\n            }\n            auto it = lower_bound(vec.begin(), vec.end(), cur);\n            int pos_idx = it - vec.begin();\n            int m = vec.size();\n            int left_idx = (pos_idx - 1 + m) % m;\n            int right_idx = (pos_idx + 1) % m;\n            int p1 = vec[left_idx];\n            int p2 = vec[right_idx];\n            int d1 = min(abs(p1 - cur), n - abs(p1 - cur));\n            int d2 = min(abs(p2 - cur), n - abs(p2 - cur));\n            ans[i] = min(d1, d2);\n        }\n        return ans;\n    }\n};","author":"Myluster","submissionId":"611252068"},[{"id":"228","similarity":0.8349056603773585,"totOverlap":177,"longestOverlap":29}]],"1934":[{"id":"1934","fileName":"611254037.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n =nums.size();\n        unordered_map<int,vector<int>>p;\n        // vector<pair<int,int>>h;\n        vector<int>ans;\n        for(int i=0;i<n;i++){\n            p[nums[i]].push_back(i);\n        }\n        for(auto x:p){\n            sort(x.second.begin(),x.second.end());\n        }\n        // for(auto x:h){\n        //     cout<<x.first<<endl;\n        // }\n        int m=queries.size();\n        for(int i=0;i<m;i++)\n        {\n            int idx=queries[i];\n            int x=nums[idx];\n            auto& list =p[x];\n            if(list.size()<=1){\n                ans.push_back(-1);\n                continue;\n            }\n            auto it =lower_bound(list.begin(),list.end(),idx);\n            int m=list.size();\n            int k=it-list.begin();\n            int pre=(k-1+m)%m;\n            int next=(k+1)%m;\n            int pre_num=list[pre];\n            int next_num=list[next];\n            int dist_pre=min(n-abs(pre_num-idx),abs(idx-pre_num));\n            int dist_next=min(abs(next_num-idx),n-abs(idx-next_num));\n            ans.push_back(min(dist_pre,dist_next));\n            // cout<<k<<endl;\n            \n        }\n        return ans;\n    }\n};","author":"ywk","submissionId":"611254037"},[{"id":"1006","similarity":0.8805970149253731,"totOverlap":177,"longestOverlap":20}]],"1945":[{"id":"1945","fileName":"611256485.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> numIndices;\n        \n        // 预处理：记录每个数值的索引，自然按升序排列\n        for (int i = 0; i < n; ++i) {\n            numIndices[nums[i]].push_back(i);\n        }\n        \n        vector<int> answer;\n        for (int query : queries) {\n            int target = nums[query];\n            auto& indices = numIndices[target];\n            int len = indices.size();\n            \n            if (len <= 1) {\n                answer.push_back(-1);\n                continue;\n            }\n            \n            // 二分查找当前查询位置在列表中的索引\n            auto it = lower_bound(indices.begin(), indices.end(), query);\n            int pos = it - indices.begin();\n            \n            // 计算左右邻居的索引（考虑循环）\n            int left_pos = (pos - 1 + len) % len;\n            int right_pos = (pos + 1) % len;\n            \n            int left = indices[left_pos];\n            int right = indices[right_pos];\n            \n            // 计算两个邻居的循环距离并取最小值\n            int dist_left = min(abs(left - query), n - abs(left - query));\n            int dist_right = min(abs(right - query), n - abs(right - query));\n            int min_dist = min(dist_left, dist_right);\n            \n            answer.push_back(min_dist);\n        }\n        return answer;\n    }\n};","author":"xzbcc979","submissionId":"611256485"},[{"id":"1792","similarity":0.9217877094972067,"totOverlap":165,"longestOverlap":28}]],"1966":[{"id":"1966","fileName":"611260521.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> vp;\n        for (int i = 0; i < n; ++i) {\n            vp[nums[i]].push_back(i);\n        }\n        \n        for (auto& [val, zp] : vp) {\n            sort(zp.begin(), zp.end());\n        }\n        \n        vector<int> ans;\n        for (int qi : queries) {\n            int val = nums[qi];\n            auto& zp = vp[val];\n            if (zp.size() <= 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            \n            auto it = lower_bound(zp.begin(), zp.end(), qi);\n            int index = it - zp.begin();\n            int k = zp.size();\n            \n            int l = (index - 1 + k) % k;\n            int r = (index + 1) % k;\n            \n            int tl = zp[l];\n            int tr = zp[r];\n            \n            int d = abs(tl - qi);\n            d = min(d, n - d);\n            \n            int dt = abs(tr - qi);\n            dt = min(dt, n - dt);\n            \n            ans.push_back(min(d, dt));\n        }\n        return ans;\n    }\n};","author":"lemonade","submissionId":"611260521"},[{"id":"1230","similarity":0.7542372881355932,"totOverlap":178,"longestOverlap":21}]],"1976":[{"id":"1976","fileName":"611265672.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n =nums.size();\n        unordered_map<int,vector<int>> um;\n        vector<int> ip(n);\n        \n        for(int i=0;i<n;++i){\n            um[nums[i]].emplace_back(i);\n            ip[i]=um[nums[i]].size()-1;\n        }\n\n        vector<int> res;\n\n        for(int i:queries){\n            int val=nums[i];\n            vector<int> &v=um[val];\n\n            if(v.size()==1){\n                res.emplace_back(-1);\n                continue;\n            }\n            int pos = ip[i];\n            int m=v.size();\n            int l=v[(pos-1+m)%m];\n            int r = v[(pos+1)%m];\n\n            res.push_back(min(min(abs(i-l),n-abs(i-l)),min(abs(i-r),n-abs(i-r))));\n        }\n        return res;\n    }\n};","author":"蛋弟","submissionId":"611265672"},[{"id":"769","similarity":0.7228915662650602,"totOverlap":120,"longestOverlap":14}]],"1979":[{"id":"1979","fileName":"611270479.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        // int n = q.size();\n        // vector<int> res(n, -1);\n        // unordered_map<int, vector<int>> v_idxs;\n        \n        // for (int i = 0; i < nums.size(); ++i) {\n        //     v_idxs[nums[i]].push_back(i);\n        // }\n\n        // int l = nums.size();\n        // unordered_map<int,int> v_mn;\n        // for (int i = 0; i < n; ++i) {\n        //     if(v_idxs[nums[q[i]]].size() == 1) res[i] = -1;\n        //     else {\n        //         if (v_mn.count(q[i])) {\n        //             res[i] = v_mn[q[i]];\n        //             continue;\n        //         }\n        //         int mn = INT_MAX;\n        //         for (auto idx : v_idxs[nums[q[i]]]) {\n        //             if (idx == q[i]) continue;\n        //             // 向后找\n        //             int v = q[i]-idx;\n        //             if (v < 0) mn = min(v+l, mn);\n        //             else mn = min(mn, v);\n        //             // 向前找\n        //             v= idx-q[i];\n        //             if (v < 0) mn = min(v+l, mn);\n        //             else mn = min(mn, v);\n        //         }\n        //         res[i] = mn;\n        //         v_mn[q[i]] = mn;\n        //     }\n        // }\n        // return res;\n        unordered_map<int, vector<int>> dict;\n\n    // 预处理：记录每个数值的出现位置\n    for (int i = 0; i < nums.size(); ++i) {\n        int val = nums[i];\n        dict[val].push_back(i);\n    }\n\n    // 对每个数值的出现位置列表进行排序\n    for (auto& pair : dict) {\n        sort(pair.second.begin(), pair.second.end());\n    }\n\n    vector<int> answer;\n    int n = nums.size();\n\n    for (int i : q) {\n        int val = nums[i];\n        auto& list = dict[val];\n\n        if (list.size() < 2) {\n            answer.push_back(-1);\n            continue;\n        }\n\n        // 使用二分查找找到i在列表中的位置\n        auto it = lower_bound(list.begin(), list.end(), i);\n        int pos = it - list.begin();\n        int len = list.size();\n\n        // 计算左右邻居的位置\n        int left_pos = (pos - 1 + len) % len;\n        int right_pos = (pos + 1) % len;\n\n        int left_val = list[left_pos];\n        int right_val = list[right_pos];\n\n        // 计算距离，考虑循环\n        int d1 = min(abs(i - left_val), n - abs(i - left_val));\n        int d2 = min(abs(i - right_val), n - abs(i - right_val));\n\n        answer.push_back(min(d1, d2));\n    }\n\n    return answer;\n    }\n};","author":"Sheen","submissionId":"611270479"},[{"id":"1006","similarity":0.8917525773195877,"totOverlap":173,"longestOverlap":60}]],"1980":[{"id":"1980","fileName":"611273680.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        int n = nums.size(), m = queries.size();\n        mp.reserve(n);\n\n        for(int i = 0; i < n; ++i) {\n            mp[nums[i]].push_back(i);\n        }\n\n        for(auto& it : mp) {\n            auto& idxs = it.second;\n            sort(idxs.begin(), idxs.end());\n        }\n\n        vector<int> ans;\n        ans.reserve(m);\n        for(int q : queries) {\n            int val = nums[q];\n            const vector<int>& tmp = mp[val];\n\n            if(tmp.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n\n            auto u = lower_bound(tmp.begin(), tmp.end(), q);\n            int uu = u - tmp.begin();\n\n            int a = (uu == 0 ? tmp.back() : tmp[uu - 1]);\n            int b = (uu == tmp.size() - 1 ? tmp.front() : tmp[uu + 1]);\n\n            int da = abs(q - a);\n            int db = abs(q - b);\n            int dda = min(da, n - da);\n            int ddb = min(db, n - db);\n            ans.push_back(min(dda, ddb));\n        }\n        return ans;\n    }\n};","author":"张二狗","submissionId":"611273680"},[{"id":"173","similarity":0.7828282828282829,"totOverlap":155,"longestOverlap":28}]]},{"771":[{"id":"771","fileName":"1575124726.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int> >m;\n        int n=nums.size();\n        for(int i=0;i<n;i++)\n            {\n                m[nums[i]].push_back(i);\n            }\n        vector<int>ans(queries.size(),-1);\n        for(int i=0;i<queries.size();i++)\n            {\n                int k=queries[i];\n                int ind=lower_bound(m[nums[k]].begin(),m[nums[k]].end(),k)-m[nums[k]].begin();\n                if(m[nums[k]].size()>1)\n                {\n                    int p=m[nums[k]].size();\n                    int val=min(abs(m[nums[k]][(ind-1+p)%p]-k),n-abs(m[nums[k]][(ind-1+p)%p]-k));\n                    val=min(val,abs(m[nums[k]][(ind+1)%p]-k));\n                    val=min(val,n-abs(m[nums[k]][(ind+1)%p]-k));\n                    cout<<m[nums[k]][(ind-1+p)%p]<<\" \"<<m[nums[k]][(ind+1)%p]<<endl;;\n                    ans[i]=val;\n                }\n            }\n        return ans;\n        \n    }\n};","author":"Raj Tiwari","submissionId":"1575124726"},[]]},{"772":[{"id":"772","fileName":"1575124755.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        def dis(a, b):\n            if a < b:\n                return b - a\n            return len(nums) - (a - b)\n        hashmap = defaultdict(list)\n        for i, num in enumerate(nums):\n            hashmap[num].append(i)\n\n        min_dist = [-1 for _ in range(len(nums))]\n        for num in hashmap:\n            lst = hashmap[num]\n            for j, i in enumerate(lst):\n                if len(lst) > 1:\n                    min_dist[i] = min(dis(lst[j - 1], lst[j]), dis(lst[j], lst[(j + 1) % len(lst)]))\n        \n        return [min_dist[i] for i in queries]\n","author":"user9140jy","submissionId":"1575124755"},[]]},{"774":[{"id":"774","fileName":"1575124828.txt","sourceCode":"#define pii pair<int,int>\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& v, vector<int>& q) {\n        int n = v.size();\n        vector<int> op = v; for(auto &x:v) op.push_back(x); for(auto &x:v) op.push_back(x);\n        for(auto &x:v) cout << x << \" \"; cout << \"n\";\n        vector< pii > ans(3*n,{1e9,-1});\n        \n        \n        map<int,int> mp;\n        int m = 3 * n;\n        for(int i=0;i<m;i++)\n        {\n            int x = op[i];\n            if(!mp.count(x)) {\n                mp[x] = i;\n            }else {\n                int prev = mp[x];\n                int dis = abs(i-prev);\n                if(dis < ans[i].first) {\n                    ans[i] = {dis, prev};\n                }\n                mp[x] = i;\n            }\n        }\n        \n        mp.clear();\n        for(int i=m-1;i>=0;i--)\n        {\n            int x = op[i];\n            if(!mp.count(x)) {\n                mp[x] = i;\n            }else {\n                int next = mp[x];\n                int dis = abs(next - i);\n                if(dis < ans[i].first) {\n                    ans[i] = {dis, next};\n                }\n                mp[x] = i;\n            }\n        }\n        \n        \n        vector<int> ret(q.size(),-1);\n        for(int i=0;i<q.size();i++) {\n            int x = q[i];\n            int idx = ans[x+n].second;\n            if(idx == -1) continue;\n            idx %= n;\n            if(abs(idx-x) != 0) {\n                ret[i] = min( abs(x-idx), n - abs(x-idx) );\n            }\n        }\n        \n        return ret;\n    }\n};","author":"e7F9OC79Eg","submissionId":"1575124828"},[]]},{"775":[{"id":"775","fileName":"1575124786.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\n        int n = nums.length;\n        for(int i = 0; i < n;i++){\n            List<Integer> list = map.computeIfAbsent(nums[i], k -> new ArrayList<>());\n            list.add(i);\n        }\n        int[] ansArray = new int[n];\n        for(Map.Entry<Integer, List<Integer>> entry : map.entrySet()) {\n            int val = entry.getKey();\n            List<Integer> list = entry.getValue();\n            int pre = list.get(list.size()-1) - n;\n            list.add(list.get(0)+n);\n            for(int i=0;i<list.size()-1;i++){\n                int index = list.get(i);\n                ansArray[index] = Math.min(index - pre, list.get(i+1) - index);\n                pre = index;\n                if(ansArray[index]==n) {\n                    ansArray[index] = -1;\n                }\n            }\n        }\n        List<Integer> ans = new ArrayList<>();\n        for(int i=0;i<queries.length;i++){\n            ans.add(ansArray[queries[i]]);\n        }\n        \n        return ans;\n    }\n}","author":"hsujc513","submissionId":"1575124786"},[]]},{"776":[{"id":"776","fileName":"1575124872.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(),m = queries.size(),x,y;\n        vector<int> ans(m,n);\n        map<int,vector<int>> mp;\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        for(int i=0;i<m;i++){\n            x = lower_bound(mp[nums[queries[i]]].begin(),mp[nums[queries[i]]].end(),queries[i]) - mp[nums[queries[i]]].begin();\n            if(x+1<mp[nums[queries[i]]].size()){\n                y = mp[nums[queries[i]]][x+1]-queries[i];\n                y = min(y,n-y);\n                ans[i] = min(ans[i],y);\n            }\n            if(x-1>=0){\n                y = queries[i]-mp[nums[queries[i]]][x-1];\n                y = min(y,n-y);\n                ans[i] = min(ans[i],y);\n            }\n            if(mp[nums[queries[i]]].back()!=queries[i]){\n                y = mp[nums[queries[i]]].back()-queries[i];\n                y = min(y,n-y);\n                ans[i] = min(ans[i],y);\n            }\n            if(mp[nums[queries[i]]].front()!=queries[i]){\n                y = queries[i]-mp[nums[queries[i]]].front();\n                y = min(y,n-y);\n                ans[i] = min(ans[i],y);\n            }\n        }\n        for(int i=0;i<m;i++){\n            if(ans[i]==n){\n                ans[i] = -1;\n            }\n        }\n        return ans;\n    }\n};","author":"Vivek vardhan Mudigonda","submissionId":"1575124872"},[]]},{"777":[{"id":"777","fileName":"1575124708.txt","sourceCode":"\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) mp[nums[i]].push_back(i);\n        int m = queries.size();\n        vector<int> ans(m, INT_MAX);\n\n        for (int i = 0; i < m; ++i) {\n            int tar = nums[queries[i]];\n            auto& vc = mp[tar];\n            if (vc.size() == 1) {\n                ans[i] = -1;\n                continue;\n            }\n            auto it = std::lower_bound(vc.begin(), vc.end(),queries[i] + 1);\n            auto it2 = std::lower_bound(vc.begin(), vc.end(), queries[i]);\n\n            auto calc = [&](int v) -> int {\n                return std::min(v, n - v);\n            };\n\n            if (it != vc.end()) {\n                ans[i] = min(ans[i], calc(*it - queries[i]));\n            } else if (queries[i] != vc[0]) {\n                ans[i] = min(ans[i], calc(queries[i] - vc[0]));\n            }\n\n            if (it2 != vc.begin()) {\n                --it2;\n                ans[i] = min(ans[i], calc(queries[i] - *it2));\n            } else if (queries[i] != vc.back()){\n                ans[i] = min(ans[i], calc(vc.back() - queries[i]));\n            }\n\n        }\n\n        return ans;\n    }\n};\n","author":"jackey","submissionId":"1575124708"},[]]},{"778":[{"id":"778","fileName":"1575124875.txt","sourceCode":"class Solution {\npublic:\n    int N;\n    int findl(vector<int>&v, int i){\n        int n = v.size();\n        int ind = lower_bound(v.begin(), v.end(), i)-v.begin();\n        ind--;\n        if(ind < 0) ind += n;\n        int a = min(i, v[ind]);\n        int b = max(i, v[ind]);\n        return min(b-a, N-b+a);        \n    }\n    int findr(vector<int>&v, int i){\n        int n = v.size();\n        int ind = lower_bound(v.begin(), v.end(), i)-v.begin();\n        ind++;\n        if(ind >= n) ind -= n;\n        int a = min(i, v[ind]);\n        int b = max(i, v[ind]);\n        return min(b-a, N-b+a); \n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> indices;\n        vector<int> ret;\n        int n = nums.size();\n        N = n;\n        for(int i=0; i<n ;i++){\n            indices[nums[i]].push_back(i);\n        }\n        for(auto i: queries){\n            int a = nums[i];\n            vector<int>&v = indices[a];\n            int l = v.size();\n            if(v.size() < 2){\n                ret.push_back(-1);\n            }else{\n                int la = findl(v, i);\n                int ra = findr(v, i);\n                ret.push_back(min(la, ra));\n            }\n        }\n        return ret;\n        \n    }\n};","author":"amit_n","submissionId":"1575124875"},[]]},{"779":[{"id":"779","fileName":"1575124927.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> closest(n, -1);\n        map<int,int> last;\n        for (int i = 0; i < n+n; i++) {\n            int num = nums[i%n];\n            if (last.count(num) && (last[num]-i) % n) {\n                int d = distance(last[num], i%n, n);\n                int pd = n;\n                if (closest[i%n] != -1) {\n                    pd = distance(closest[i%n], i%n, n);\n                }\n                if (d < pd) {\n                    closest[i%n] = last[num];\n                }\n            }\n            last[num] = i%n;\n        }\n        last.clear();\n        for (int i = n+n-1; i >= 0; i--) {\n            int num = nums[i%n];\n            if (last.count(num) && (last[num]-i) % n) {\n                int d = distance(last[num], i%n, n);\n                int pd = n;\n                if (closest[i%n] != -1) {\n                    pd = distance(closest[i%n], i%n, n);\n                }\n                if (d < pd) {\n                    closest[i%n] = last[num];\n                }\n            }\n            last[num] = i%n;\n        }\n        vector<int> ans(queries.size());\n        for (int i = 0; i < queries.size(); i++) {\n            int q = queries[i];\n            if (closest[q] == -1) {\n                ans[i] = -1;\n            } else {\n                ans[i] = distance(closest[q], q, n);\n            }\n        }\n        return ans;\n    }\n\n    int distance(int a, int b, int n) {\n        if (a > b) {\n            return distance(b, a, n);\n        }\n        return min(b-a, a-b+n);\n    }\n};","author":"Ahmad Zaky","submissionId":"1575124927"},[]]},{"780":[{"id":"780","fileName":"1575124990.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        table = {}\n        n = len(nums)\n        preans = [float(\"inf\")]*n\n        for i in range(n):\n            if nums[i] not in table:\n                table[nums[i]] = [i, i]\n            else:\n                prev = table[nums[i]][1]\n                preans[prev] = min(preans[prev], i - prev)\n                preans[i] = i - prev\n                table[nums[i]][1] = i\n        for key in table:\n            a, b = table[key]\n            if a != b:\n                preans[a] = min(preans[a], n-b+a)\n                preans[b] = min(preans[b], n-b+a)\n        ans = []\n        for index in queries:\n            if preans[index] < float(\"inf\"):\n                ans.append(preans[index])\n            else:\n                ans.append(-1)\n        return ans","author":"qcoh","submissionId":"1575124990"},[]]},{"781":[{"id":"781","fileName":"1575124981.txt","sourceCode":"class Solution {\n    int binarySearch(vector<int>& arr, int val) {\n        int l = 0, h = arr.size() - 1;\n        while (l <= h) {\n            int mid = l + (h - l) / 2;\n            if (arr[mid] == val) return mid;\n            else if (arr[mid] > val) h = mid - 1;\n            else l = mid + 1;\n        }\n        return l; \n    }\n\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> numIndices;\n        int n = nums.size();\n        \n        for (int i = 0; i < n; i++) {\n            numIndices[nums[i]].push_back(i);\n        }\n        \n        vector<int> answer;\n        \n        for (int q : queries) {\n            int target = nums[q];  \n\n            if (numIndices[target].size() <= 1) {\n                answer.push_back(-1); \n                continue;\n            }\n            \n            vector<int>& indices = numIndices[target];\n            int idx = binarySearch(indices, q); \n\n            int minDist = INT_MAX;\n            int m = indices.size();\n\n            if (idx < m - 1) {\n                minDist = min(minDist, indices[idx + 1] - q);\n            }\n            if (idx > 0) {\n                minDist = min(minDist, q - indices[idx - 1]);\n            }\n\n            minDist = min({minDist, q + n - indices.back(), indices.front() + n - q});\n\n            answer.push_back(minDist);\n        }\n        \n        return answer;\n    }\n};\n","author":"sandipto729","submissionId":"1575124981"},[]]},{"782":[{"id":"782","fileName":"1575124732.txt","sourceCode":"class Solution {\n\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int[] left = new int[nums.length], right = new int[nums.length];\n        HashMap<Integer, Integer> map = new HashMap<>(), map2 = new HashMap(), start = new HashMap<>(), end = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            left[i] = map.getOrDefault(nums[i], -1);\n            start.putIfAbsent(nums[i], i);\n            map.put(nums[i], i);\n        }\n        for (int i = nums.length - 1; i >= 0; i--) {\n            right[i] = map2.getOrDefault(nums[i], -1);\n            end.putIfAbsent(nums[i], i);\n            map2.put(nums[i], i);\n        }\n        ArrayList<Integer> list = new ArrayList<>();\n        for (int query : queries) {\n            int min = Math.min(left[query] != -1 ? Math.abs(query - left[query]) : Integer.MAX_VALUE, Math.min(right[query] != -1 ? Math.abs(query - right[query]) : Integer.MAX_VALUE, Math.min(start.getOrDefault(nums[query], query) != query ? nums.length - Math.abs(query - start.get(nums[query])) : Integer.MAX_VALUE, end.getOrDefault(nums[query], query) != query ? nums.length - Math.abs(query - end.get(nums[query])) : Integer.MAX_VALUE)));\n            if (min == Integer.MAX_VALUE) {\n                min = -1;\n            }\n            list.add(min);\n        }\n        return list;\n    }\n}","author":"arignote","submissionId":"1575124732"},[]]},{"784":[{"id":"784","fileName":"1575125083.txt","sourceCode":"\ndef bs(arr,x,l,r):\n    while l <=r :\n        mid = (l+r)//2\n        if arr[mid] == x:\n            return mid \n        elif arr[mid] < x :\n            l = mid+1\n        else:\n            r = mid -1\n    return -1\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        ans = []\n        hash = {}\n        singles = set()\n        n = len(nums)\n        for i in range(len(nums)) :\n            ele = nums[i]\n            if ele in hash :\n                hash[ele].append(i)\n            else:\n                hash[ele] = [i]\n        for i in hash :\n            if len(hash[i]) == 1:\n                singles.add(i)\n        # print(hash,singles)\n        for i in queries :\n            ele = nums[i]\n            if ele in singles :\n                ans.append(-1)\n            else:\n                sl = hash[ele]\n                pos = bs(sl,i,0,len(sl))\n                if pos == 0:\n                    # print(\"1\")\n                    ans.append(min(\n                        sl[1]-sl[0],\n                        n-sl[-1]+sl[0]))\n                elif pos == len(sl) - 1 :\n                    # print(\"2\")\n                    ans.append(min(\n                        sl[-1]-sl[-2],\n                        abs(n-sl[-1]+sl[0])))\n                else:\n                    # print(\"3\")\n                    ans.append(\n                        min(sl[pos] - sl[pos-1],\n                            sl[pos+1] - sl[pos]\n                           ))\n        return ans","author":"YASH BHATT","submissionId":"1575125083"},[]]},{"786":[{"id":"786","fileName":"1575124966.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        for (auto& it : mp) {\n            sort(it.second.begin(), it.second.end());\n        }\n\n        vector<int> ans;\n        for (auto& q : queries) {\n            if (mp[nums[q]].size() < 2) {\n                ans.push_back(-1);\n                continue;\n            }\n\n            auto helper = [&](int x) -> int {\n                return min(abs(q - x), n - abs(q - x));\n                };\n\n            int curr = INT_MAX, m = mp[nums[q]].size();\n            auto& res = mp[nums[q]];\n            auto it = lower_bound(res.begin(), res.end(), q) - res.begin();\n            ans.push_back(min(helper(res[(it + 1) % m]), helper(res[(it - 1 + m) % m])));\n        }\n        return ans;\n    }\n};","author":"Divyansh Saxena","submissionId":"1575124966"},[]]},{"787":[{"id":"787","fileName":"1575125120.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        int m = 1000001;\n        ArrayList<Integer>[] inv = new ArrayList[m];\n        for (int i=0; i<n; i++) {\n            int num = nums[i];\n            if (inv[num]==null) inv[num]=new ArrayList<>();\n            inv[num].add(i);\n        }\n        \n        \n        \n        int q = queries.length;\n        ArrayList<Integer> ans = new ArrayList<>();\n        for (int i=0; i<q; i++) {\n            int num = nums[queries[i]];\n            ArrayList<Integer> idxs = inv[num];\n            //System.out.println(idxs);\n            if (idxs.size()==1) {\n                ans.add(-1);\n                continue;\n            }\n            int idx2 = Collections.binarySearch(idxs,queries[i]);\n            int an = (idx2==0) ? n+idxs.get(idx2)-idxs.get(idxs.size()-1) : idxs.get(idx2)-idxs.get(idx2-1);\n            an = Math.min(an,\n                    (idx2==idxs.size()-1) ? n+idxs.get(0)-idxs.get(idx2) : idxs.get(idx2+1)-idxs.get(idx2)\n                 );\n            ans.add(an);\n        }\n        return ans;\n    }\n}","author":"JerryGu1","submissionId":"1575125120"},[]]},{"789":[{"id":"789","fileName":"1575125121.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        std::map<int, std::vector<int>> value_to_indices;\n        \n        // Populate the map with value to list of indices\n        for (int i = 0; i < n; ++i) {\n            value_to_indices[nums[i]].push_back(i);\n        }\n        \n        std::vector<int> answer;\n        answer.reserve(queries.size());\n        \n        for (int q : queries) {\n            int v = nums[q];\n            auto& list = value_to_indices[v];\n            int k = list.size();\n            \n            if (k == 1) {\n                // Only one occurrence, no other index with the same value\n                answer.push_back(-1);\n                continue;\n            }\n            \n            // Find the position of q in the list\n            auto it = std::lower_bound(list.begin(), list.end(), q);\n            int m = it - list.begin();\n            assert(*it == q); // Ensure q is found in the list\n            \n            // Get previous and next indices in the circular list\n            int prev_index = list[(m - 1 + k) % k];\n            int next_index = list[(m + 1) % k];\n            \n            // Calculate circular distances\n            int dist_to_prev = std::min(std::abs(q - prev_index), n - std::abs(q - prev_index));\n            int dist_to_next = std::min(std::abs(q - next_index), n - std::abs(q - next_index));\n            \n            // The minimum distance is the smallest of these two distances\n            int min_dist = std::min(dist_to_prev, dist_to_next);\n            answer.push_back(min_dist);\n        }\n        \n        return answer;\n    }\n};","author":"Abhinavsharma005","submissionId":"1575125121"},[]]},{"790":[{"id":"790","fileName":"1575125282.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, TreeSet<Integer>> map = new HashMap<>();\n        int n = nums.length;\n        for(int i=0; i<n; i++){\n            map.putIfAbsent(nums[i], new TreeSet<>());\n            TreeSet<Integer> set = map.get(nums[i]);\n            set.add(i);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for(int i=0; i<queries.length; i++){\n            int val = nums[queries[i]];\n            TreeSet<Integer> set = map.get(val);\n            if(set.size() == 1){\n                ans.add(-1);\n                continue;\n            }\n            Integer lower = set.lower(queries[i]);\n            Integer higher = set.higher(queries[i]);\n            if(lower == null){\n                lower = (int)1e7;\n            }\n            if(higher == null){\n                higher = (int)1e7;\n            }\n            int k = Math.min(Math.abs(lower - queries[i]), Math.abs(higher - queries[i]));\n            int first = set.first();\n            int last = set.last();\n            if(first != queries[i]){\n                k = Math.min(k, Math.abs(first - queries[i]));\n                k = Math.min(k, Math.abs(n - Math.abs(first - queries[i])));\n            }\n            if(last != queries[i]){\n                k = Math.min(k, Math.abs(last - queries[i]));\n                k = Math.min(k, Math.abs(n - Math.abs(last - queries[i])));\n            }\n            // System.out.println(lower+\" \"+higher+\" \"+first+\" \"+last);\n            ans.add(k);\n        }\n        return ans;\n    }\n}","author":"MOHANA YOGESH DIKKALA","submissionId":"1575125282"},[]]},{"792":[{"id":"792","fileName":"1575125329.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>>mp;\n        int n = nums.size();\n        int m = queries.size();\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int>ans(m,-1);\n        for(int i=0;i<m;i++){\n            if(mp[nums[queries[i]]].size()==1) continue;\n            int index = queries[i];\n            int idx = -1;\n            int low = 0, high = mp[nums[queries[i]]].size()-1;\n            while (low <= high) {\n                int mid = (low + high) / 2;\n                if (mp[nums[queries[i]]][mid] == index) {\n                    idx = mid;\n                    break;\n                } else if (mp[nums[queries[i]]][mid] > index) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n            int n1 = mp[nums[queries[i]]].size();\n            int left = mp[nums[queries[i]]][(idx-1+n1)%n1];\n            int right = mp[nums[queries[i]]][(idx+1)%n1];\n            ans[i] = min((index-left+n)%n,(right-index+n)%n);\n        }\n        return ans;\n    }\n};","author":"Praveen Kumar","submissionId":"1575125329"},[]]},{"793":[{"id":"793","fileName":"1575125311.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        #nums = nums + nums\n        #N = len(nums)\n        ans = []\n        dic = collections.defaultdict(list)\n        for i in range(n):\n            dic[nums[i]].append(i)\n        for x in queries:\n            t = nums[x]\n            if len(dic[t]) == 1:\n                ans.append(-1)\n                continue\n            i = bisect.bisect_left(dic[t],x)\n            #print(dic[t],x,dic[t][i-1],dic[t][(i+1)%len(dic[t])],x - dic[t][(i+1)%len(dic[t])] + n)\n            mi = float(\"inf\")\n            mi = min(mi,abs(x-dic[t][i-1]))\n            mi = min(mi,abs(x-(dic[t][i-1] - n)))\n            mi = min(mi,abs(x-(dic[t][i-1] + n)))\n            mi = min(mi,abs(x-dic[t][(i+1)%len(dic[t])]))\n            mi = min(mi,abs(x-(dic[t][(i+1)%len(dic[t])] + n)))\n            mi = min(mi,abs(x-(dic[t][(i+1)%len(dic[t])] - n)))\n            if mi == float(\"inf\"):\n                ans.append(-1)\n            else:\n                ans.append(mi)\n        return ans  ","author":"hidy","submissionId":"1575125311"},[]]},{"794":[{"id":"794","fileName":"1575125382.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> mp;\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        int n = nums.size();\n        for(auto&q:queries){\n            if(mp.find(nums[q]) != mp.end() && mp[nums[q]].size() > 1){\n                auto& vec = mp[nums[q]];\n                auto low = lower_bound(vec.begin(),vec.end(),q);\n                int curr = INT_MAX;\n                if(low != vec.begin()){\n                    auto p = low -1;\n                    curr = min(curr,abs(*p-q));\n                    curr = min(curr,abs(*p-q+n));\n                }else{\n                    curr = min(curr,abs(vec.back()-q));\n                    curr = min(curr,abs(q-vec.back()+n));\n                }\n                low++;\n                if(low != vec.end()){\n                    curr = min(curr,abs(*low-q));\n                    curr = min(curr,abs(q-*low+n));\n                }else{\n                    curr = min(curr,abs(vec[0]-q));\n                    curr = min(curr,abs(vec[0]-q+n));\n                }\n                ans.push_back(curr);\n            }else{\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};","author":"Sai Mahesh","submissionId":"1575125382"},[]]},{"795":[{"id":"795","fileName":"1575125375.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        \n        # Pre-compute and store the position of each index in the indices list\n        value_indices = {}\n        index_positions = {}  # Maps (value, index) to its position in the value_indices list\n        \n        for i, num in enumerate(nums):\n            if num not in value_indices:\n                value_indices[num] = []\n            index_positions[(num, i)] = len(value_indices[num])\n            value_indices[num].append(i)\n        \n        results = []\n        for query_idx in queries:\n            value = nums[query_idx]\n            indices = value_indices[value]\n            \n            # If the value appears only once\n            if len(indices) == 1:\n                results.append(-1)\n                continue\n            \n            # Get the position of query_idx in the indices list in O(1) time\n            pos = index_positions[(value, query_idx)]\n            \n            # Calculate distances to adjacent occurrences\n            prev_pos = (pos - 1) % len(indices)\n            next_pos = (pos + 1) % len(indices)\n            \n            prev_idx = indices[prev_pos]\n            next_idx = indices[next_pos]\n            \n            # Calculate regular and circular distances\n            prev_distance = min(abs(query_idx - prev_idx), n - abs(query_idx - prev_idx))\n            next_distance = min(abs(query_idx - next_idx), n - abs(query_idx - next_idx))\n            \n            min_distance = min(prev_distance, next_distance)\n            results.append(min_distance)\n        \n        return results","author":"suchithra126","submissionId":"1575125375"},[]]},{"796":[{"id":"796","fileName":"1575125369.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        const int n = nums.size();\n        map<int, set<int>> pos;\n        for (int i = 0; i < nums.size(); ++i) {\n            pos[nums[i]].insert(i);\n            pos[nums[i]].insert(i - n);\n            pos[nums[i]].insert(i + n);\n        }\n        \n        vector<int> res;\n        for (int q : queries) {\n            int x = nums[q];\n            if (pos[x].size() <= 3) res.push_back(-1);\n            else {\n                int v = 0x3f3f3f3f;\n                auto it = pos[x].find(q);\n                //cout << q << \" \" << *next(it, 1) << endl;\n                //cout << q << \" \" << *prev(it, 1) << endl;\n                v = min(v, *next(it, 1) - q);\n                //cout << v << endl;\n                v = min(v, q - *prev(it, 1));\n                //cout << v << endl;\n                //cout << \"---n\";\n                res.push_back(v);\n            }\n        }\n        return res;\n    }\n};","author":"jfantasy90","submissionId":"1575125369"},[]]},{"797":[{"id":"797","fileName":"1575125305.txt","sourceCode":"// DEBUGGING TEMPLATE\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \nenable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cout << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifndef ONLINE_JUDGE\n~debug() { cout << endl; }\neni(!=) cout << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\nris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n*this << \"[\";\nfor (auto it = d.b; it != d.e; ++it)\n*this << \", \" + 2 * (it == d.b) << *it;\nris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& queries) {\n        int n = a.size();\n        vector<int> dist(n, 1e9), res(n, -1);\n        map<int, int> mp;\n        for (int i = 0; i < 2 * n; i++) {\n            int x = i % n;\n            if (mp.count(a[x])) {\n                int j = mp[a[x]];\n                int d = abs(j - i) % n;\n                // debug() << imie(x) << imie(a[x]) << imie(j);\n                if (d != 0) {\n                    if (dist[x] > d) {\n                        res[x] = j;\n                        dist[x] = d;\n                        // debug() << imie(x) << imie(a[x]) << imie(j) << imie(dist[x]) << imie(res[x]);\n                    }\n                }\n            }\n            mp[a[x]] = i;\n        }\n        for (int i = 2 * n; i >= 0; i--) {\n            int x = i % n;\n            if (mp.count(a[x])) {\n                int j = mp[a[x]];\n                int d = abs(j - i) % n;\n                // debug() << imie(x) << imie(a[x]) << imie(j);\n                if (d != 0) {\n                    if (dist[x] > d) {\n                        res[x] = j;\n                        dist[x] = d;\n                        // debug() << imie(x) << imie(a[x]) << imie(j) << imie(dist[x]) << imie(res[x]);\n                    }\n                }\n            }\n            mp[a[x]] = i;\n        }\n        // debug() << imie(res);\n        vector<int> v;\n        for (int j: queries) {\n            v.push_back(dist[j] == 1e9 ? -1: dist[j]);\n        }\n        return v;\n    }\n};","author":"Guddu Singh","submissionId":"1575125305"},[]]},{"799":[{"id":"799","fileName":"1575125463.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        vector<int>v(n);\n        unordered_map<int,vector<int>>mp;\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        for(auto &i:mp){\n            auto x=i.second;\n            if(x.size()==1){ v[x[0]]=-1;continue;}\n            for(auto j=0;j<i.second.size();j++){\n                if(j==0){\n                    v[x[j]]=min(x[j+1]-x[j],n-abs(x[x.size()-1]-x[j]));\n                }\n                else if(j==x.size()-1){\n                    v[x[j]]=min(x[j]-x[j-1],n-abs(x[0]-x[j]));\n\n                }\n                else{\n                    v[x[j]]=abs(min(x[j]-x[j-1],x[j+1]-x[j]));\n                }\n            }\n        }\n        vector<int>ans;\n        for(auto i:queries) ans.push_back(v[i]);\n        return ans;\n    }\n};","author":"Sri Ram Kumar R","submissionId":"1575125463"},[{"id":"1808","similarity":0.7258883248730964,"totOverlap":143,"longestOverlap":12}]],"1808":[{"id":"1808","fileName":"611243786.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int,vector<int>> mp;\n        for(int i=0;i<n;++i)\n            {\n                mp[nums[i]].push_back(i);\n            }\n        vector<int> id(n,-1);\n        for(auto& it:mp)\n            {\n                auto &vec =it.second;\n                if(vec.size()>1)\n                {\n                    int m = vec.size();\n                    for(int i=0;i<m;i++)\n                        {\n                            if(i==0)\n                            {\n                                id[vec[i]] = min(vec[i]+n-vec.back(),vec[i+1]-vec[i]);\n                            }\n                            else if(i==m-1)\n                            {\n                                id[vec[i]] = min(vec[0]+n-vec[i],vec[i]-vec[i-1]);\n                            }\n                            else\n                            {\n                                id[vec[i]] = min(vec[i+1]-vec[i],vec[i]-vec[i-1]);\n                            }\n                        }\n                }\n            }\n        // for(auto i:id)\n        //     cout<<i<<'t';\n        vector<int>res;\n        for(auto i:queries)\n            res.push_back(id[i]);\n        return res;\n    }\n};","author":"倚海观澜","submissionId":"611243786"},[{"id":"799","similarity":0.7258883248730964,"totOverlap":143,"longestOverlap":12}]]},{"800":[{"id":"800","fileName":"1575125423.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> st(nums.size(),-1);\n        unordered_map<int,int> mp;\n        int n=nums.size();\n        for(int i=0;i<nums.size()*2;i++){\n            if(mp.count(nums[i%n])>0){\n                if(i%n == mp[nums[i%n]]%n){\n                    continue;\n                }\n                int l=st[mp[nums[i%n]]%n];\n                if(l==-1){\n                    st[mp[nums[i%n]]%n]=i-mp[nums[i%n]];\n                }\n                else{\n                    st[mp[nums[i%n]]%n]=min(l,i-mp[nums[i%n]]);\n                }\n                if(st[i%n]==-1){\n                    st[i%n]=i-mp[nums[i%n]];\n                }\n                else{\n                    l=st[i%n];\n                    st[i%n]=min(l,i-mp[nums[i%n]]);\n                }\n                mp[nums[i%n]]=i;\n            }\n            else{\n                mp[nums[i%n]]=i;\n            }\n        }\n        vector<int> ans;\n        for(int i=0;i<queries.size();i++){\n            ans.push_back(st[queries[i]]);\n        }\n        return ans;\n    }\n};","author":"Kunal Gupta","submissionId":"1575125423"},[]]},{"801":[{"id":"801","fileName":"1575125526.txt","sourceCode":"class Solution {\npublic:\n    int f(int a, int b, int len) {\n        if(a > b) {\n            swap(a, b);\n        }\n        int l = b - a; \n        int r = len - (b - a);\n        return min(l, r);\n    }\n    const int INF = INT_MAX / 2;\n    vector<int> solveQueries(vector<int>& nums, vector<int>& qs) {\n        unordered_map<int,vector<int>> xs;\n        for(int i = 0;i<nums.size();i++) {\n            int v = nums[i];\n            xs[v].push_back(i);\n        }\n        vector<int> ret; \n        for(int i = 0;i<qs.size();i++) {\n            int q = qs[i];\n            int v = nums[q]; \n            if(xs[v].size() == 1) {\n                ret.push_back(-1);\n                continue;\n            }\n            auto ptr = lower_bound(xs[v].begin(), xs[v].end(), q);\n            int dis = INF; \n            int j = distance(xs[v].begin(), ptr);\n            if(j > 0) {\n                dis = f(xs[v][j-1], xs[v][j], nums.size());\n            } else {\n                dis = f(xs[v][j], xs[v].back(), nums.size());\n            }\n            if(j + 1 < xs[v].size()) {                \n                dis = min(dis, f(xs[v][j], xs[v][j+1], nums.size()));\n            } else {\n                dis = min(dis, f(xs[v].front(), xs[v][j], nums.size()));\n            }\n            ret.push_back(dis);\n        }\n        return ret;\n    }\n};","author":"Hanzhou Tang","submissionId":"1575125526"},[]]},{"802":[{"id":"802","fileName":"1575125488.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        buckets = defaultdict(list)\n        for i, num in enumerate(nums):\n            buckets[num].append(i)\n        res = []\n        n = len(nums)\n        \n        def dis(b, i):\n            j = bisect.bisect_left(b, i)\n            if j == 0:\n                left = b[j] + n - b[-1]\n            else:\n                left = b[j] - b[j - 1]\n            if j == len(b) - 1:\n                right = n - b[j] + b[0]\n            else:\n                right = b[j + 1] - b[j]\n            return min(left, right)\n        \n        for i in queries:\n            v = nums[i]\n            b = buckets[v]\n            m = len(b)\n            if m == 1:\n                res.append(-1)\n                continue\n            # print(b)\n            res.append(dis(b, i))\n        return res\n        ","author":"chaotian","submissionId":"1575125488"},[]]},{"803":[{"id":"803","fileName":"1575125529.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n\n        int n=nums.size();\n\n        unordered_map<int,set<int>>mp;\n\n        for(int i=0;i<n;i++)\n        {\n            mp[nums[i]].insert(i);\n            mp[nums[i]].insert(n+i);\n        }\n\n        vector<int>ans(q.size(),0);\n        for(int i=0;i<q.size();i++)\n        {\n            int id=q[i];\n            if(mp[nums[id]].size()==2)ans[i]=-1;\n            else\n            {\n                int mx=n+1;\n                auto it=mp[nums[id]].upper_bound(id);\n                if(it!=mp[nums[id]].end())\n                {\n                    mx=min(mx,abs(id-*it));\n                }\n                it=mp[nums[id]].lower_bound(id);\n                if(it!=mp[nums[id]].begin())\n                {\n                    it--;\n                    mx=min(mx,abs(id-*it));\n                }\n\n                it=mp[nums[id]].upper_bound(id+n);\n                if(it!=mp[nums[id]].end())\n                {\n                    mx=min(mx,abs(id+n-*it));\n                }\n                it=mp[nums[id]].lower_bound(id+n);\n                if(it!=mp[nums[id]].begin())\n                {\n                    it--;\n                    mx=min(mx,abs(id+n-*it));\n                }\n                ans[i]=mx;\n            }\n        }\n        return ans;\n        \n    }\n};","author":"Neeraj9436","submissionId":"1575125529"},[]]},{"805":[{"id":"805","fileName":"1575125544.txt","sourceCode":"import bisect\nfrom collections import defaultdict\n\nclass Solution(object):\n    def solveQueries(self, nums, queries):\n        n = len(nums)\n        mp = defaultdict(list)\n        for idx, num in enumerate(nums):\n            mp[num].append(idx)\n        \n        result = []\n        for q in queries:\n            x = nums[q]\n            indices = mp[x]\n            if len(indices) == 1:\n                result.append(-1)\n                continue\n            \n            pos = bisect.bisect_left(indices, q)\n            prev = (pos - 1) % len(indices)\n            next = (pos + 1) % len(indices)\n            j_prev = indices[prev]\n            j_next = indices[next]\n            \n            d_prev = min(abs(q - j_prev), n - abs(q - j_prev))\n            d_next = min(abs(q - j_next), n - abs(q - j_next))\n            result.append(min(d_prev, d_next))\n        \n        return result","author":"Aditya Kotha","submissionId":"1575125544"},[]]},{"806":[{"id":"806","fileName":"1575125568.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, List<Integer>> hm = new HashMap<>();\n        HashMap<Integer, Integer> minDis = new HashMap<>();\n\n\n        for(int i=0;i<nums.length;i++) {\n            hm.putIfAbsent(nums[i], new ArrayList<>());\n            hm.get(nums[i]).add(i);\n        }\n        List<Integer> ans = new ArrayList<>();\n\n        for(int i=0;i<queries.length;i++) {\n            int ind = queries[i];\n            int num = nums[ind];\n\n            List<Integer> pos = hm.get(num);\n\n            if(pos.size() == 1) {\n               ans.add(-1);\n            } else {\n                int low = 0;\n                int high = pos.size() - 1;\n                int in = -1;\n                while(low<=high) {\n                    int mid = high - (high - low)/2;\n                    if(pos.get(mid) == ind) {\n                        in = mid;\n                        break;\n                    } else if(pos.get(mid)> ind) {\n                        high = mid - 1;\n                    } else {\n                        low = mid + 1;\n                    }\n                }\n\n                // in, you can check left and check right;\n\n                int op1 = Integer.MAX_VALUE;\n\n                if(in == 0) {\n                    op1 = Math.min(op1, pos.get(0) + nums.length - pos.get(pos.size()-1));\n                }\n                \n                if(in + 1 < pos.size()) {\n                    op1 = Math.min(op1, pos.get(in+1)-pos.get(in));\n                }\n\n                if(in-1>=0) {\n                    op1 = Math.min(op1, pos.get(in)-pos.get(in-1));\n                }\n\n                if(in == pos.size()-1) {\n                    op1 = Math.min(op1, nums.length - pos.get(in) + pos.get(0));\n                }\n\n                ans.add(op1);\n            }\n        }\n\n        return ans;\n    }\n}","author":"Jagrit","submissionId":"1575125568"},[]]},{"807":[{"id":"807","fileName":"1575125691.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        last = {}\n        best = [-1] * len(nums)\n        for i, n in enumerate(nums):\n            last_i = last.get(n)\n            if last_i is not None:\n                new_best = i - last_i\n                best[last_i] = new_best if best[last_i] == -1 else min(new_best, best[last_i])\n                best[i] = new_best\n            last[n] = i\n        \n        for i, n in enumerate(nums):\n            last_i = last.get(n)\n            if last_i and best[last_i] != -1:\n                new_best =  i + (len(nums) - last_i)\n                best[last_i] = min(new_best, best[last_i])\n                best[i] = min(new_best, best[i])\n\n        return [best[q] for q in queries]\n                \n            \n            ","author":"edbltn","submissionId":"1575125691"},[]]},{"808":[{"id":"808","fileName":"1575125693.txt","sourceCode":"use std::collections::*;\n\nimpl Solution {\n    pub fn solve_queries(nums: Vec<i32>, queries: Vec<i32>) -> Vec<i32> {\n        let mut idx: HashMap<i32, Vec<usize>> = HashMap::new();\n        for (i, &num) in nums.iter().enumerate() {\n            idx.entry(num)\n                .and_modify(|v| v.push(i))\n                .or_insert(vec![i]);\n        }\n\n        let mut dist = HashMap::new();\n        let num_len = nums.len();\n        for (num, v) in idx.iter() {\n            let n = v.len();\n            let mut adj = HashMap::new();\n            if n == 1 {\n                adj.insert(v[0], -1);\n            } else {\n                for (i, &vi) in v.iter().enumerate() {\n                    let next = v[(i + 1) % n];\n                    let next_dist = ((next + num_len - vi) % num_len).min((vi + num_len - next) % num_len);\n\n                    let prev = v[(i + n - 1) % n];\n                    let prev_dist = ((prev + num_len - vi) % num_len).min((vi + num_len - prev) % num_len);\n                    adj.insert(vi, next_dist.min(prev_dist) as i32);\n                }\n            }\n\n            dist.insert(num, adj);\n        }\n\n        queries.into_iter()\n            .map(|q| {\n                dist.get(&nums[q as usize]).unwrap().get(&(q as usize)).copied().unwrap()\n            })\n            .collect()\n    }\n}","author":"Fainabi","submissionId":"1575125693"},[]]},{"809":[{"id":"809","fileName":"1575125442.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        Q = len(queries)\n        N = len(nums)\n        ans = []\n        # want min distance to next value of number\n        # consider 1st occurence to left and 1st occurence to right \n        # for each numbr in nums, process where it appears \n        num_inds = defaultdict(list)\n        for i, x in enumerate(nums):\n            num_inds[x].append(i)\n\n        for q_idx in queries:\n            v = nums[q_idx]\n            arr = num_inds[v]\n            # find nearest occurence of v\n            if len(arr) == 1:\n                ans.append(-1)\n                continue\n            i = bisect_left(arr, q_idx)\n            # now consider left and right values. \n            left_i = i - 1 if i != 0 else (len(arr) - 1)\n            right_i = i + 1 if i != len(arr) - 1 else 0\n            #print(i, left_i, right_i)\n            r = arr[right_i]\n            l = arr[left_i]\n            #print(f'the left and right for {v} are {l=}, {r =}: {arr} ')\n            d_l = min((l - q_idx) % N,(q_idx - l) % N )\n            d_r = min((q_idx - r) % N, (r - q_idx) % N )\n            ans.append(min(d_l, d_r))\n            #print(f'we see the index of {q_idx} in {arr} is {i}')\n        return ans\n        \n        ","author":"Connor Colombe","submissionId":"1575125442"},[]]},{"810":[{"id":"810","fileName":"1575125730.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& v, vector<int>& q) {\n        int n = v.size(), mm = q.size();\n        map<int, multiset<int>> m;\n        for(int i = 0; i < n; i++){\n            m[v[i]].insert(i);\n        }\n        vector<int> ans(mm, -1);\n        for(int i = 0; i < mm; i++){\n            int x = v[q[i]];\n            int res = 1e9;\n            if(m[x].size() == 1){\n                continue;\n            }\n            m[x].erase(m[x].find(q[i]));\n            auto it = m[x].lower_bound(q[i]);\n            if(it != m[x].end()){\n                res = min(res, *it - q[i]);\n                res = min(res, q[i] + n - *it);\n            }\n            if(it != m[x].begin()){\n                it--;\n                res = min(res, q[i] - *it);\n                res = min(res, *it + n - q[i]);\n            }\n            res = min(res, q[i] + n - *prev(m[x].end()));\n            res = min(res, *m[x].begin() + n - q[i]);\n            m[x].insert(q[i]);\n\n            ans[i] = res;\n        }\n        return ans;\n    }\n};","author":"Ashutosh Sahu","submissionId":"1575125730"},[]]},{"811":[{"id":"811","fileName":"1575125734.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> nums2;\n        \n        for(int j = 0; j<3; j++){\n        for(int i = 0; i<n; i++){\n            nums2.push_back(nums[i]);\n        }\n        }\n        \n        vector<int> dp(n,1e9);\n        map<int,int> mp1 , mp2;\n        for(int j = 0; j<nums2.size(); j++){\n            int val = nums2[j];\n            \n            if(j>=n && j<2*n){\n                dp[j-n] = min(dp[j-n],j-mp1[val]);\n            }\n            mp1[val] = j;\n        }\n        for(int j = nums2.size()-1; j>=0; j--){\n           int val = nums2[j];\n            \n            if(j>=n && j<2*n){\n                dp[j-n] = min(dp[j-n],mp2[val]-j);\n            }\n            mp2[val] = j;\n        }\n        vector<int> ans;\n        for(auto it : queries){\n            int val = dp[it];\n            if(val == n){\n                val = -1;\n            }\n            ans.push_back(val);\n        }\n        \n        return ans;\n    }\n};","author":"Sudhanshu Pandey","submissionId":"1575125734"},[]]},{"812":[{"id":"812","fileName":"1575125769.txt","sourceCode":"#include <algorithm>\n#include <array>\n#include <bitset>\n#include <deque>\n#include <format>\n#include <iterator>\n#include <limits>\n#include <map>\n#include <memory>\n#include <ranges>\n#include <set>\n#include <sstream>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <string_view>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#include <cmath>\n\n#include <bits/ranges_algo.h>\n\nclass Solution {\npublic:\n\tauto solveQueries(std::vector<int> &nums, std::vector<int> &queries) -> std::vector<int>\n\t{\n\t\tauto occurrence_map = std::map<int, std::deque<int>>{};\n\t\tfor (auto i = 0U; i < nums.size(); i++) {\n\t\t\tauto num = nums[i];\n\t\t\tauto &m = occurrence_map[num];\n\t\t\tm.emplace_back(i);\n\t\t\tm.emplace_back(static_cast<long>(i) - static_cast<long>(nums.size()));\n\t\t\tm.emplace_back(static_cast<long>(i) + static_cast<long>(nums.size()));\n\t\t}\n\t\tauto sorted = std::map<int, bool>{};\n\t\tauto result = std::vector(queries.size(), std::numeric_limits<int>::max());\n\t\tauto oit = result.begin();\n\t\tfor (auto query : queries) {\n\t\t\tauto num = nums[query];\n\t\t\tauto &v = occurrence_map[num];\n\t\t\tif (!sorted[num]) {\n\t\t\t\tstd::ranges::sort(v);\n\t\t\t\tsorted[num] = true;\n\t\t\t}\n\t\t\tauto it = std::ranges::lower_bound(v, query);\n\t\t\tif (it == v.end())\n\t\t\t\tthrow std::runtime_error{\"I\"};\n\t\t\tif (it != v.begin())\n\t\t\t\t*oit = *it - *std::prev(it);\n\t\t\tif (std::next(it) != v.end())\n\t\t\t\t*oit = std::min(*oit, *std::next(it) - *it);\n\t\t\tif (*oit == nums.size())\n\t\t\t\t*oit = -1;\n\t\t\t++oit;\n\t\t}\n\t\treturn result;\n\t}\n};\n","author":"G9aWb","submissionId":"1575125769"},[]]},{"814":[{"id":"814","fileName":"1575125873.txt","sourceCode":"from bisect import bisect_left\n\nclass Solution:\n    def solveQueries(self, nums: List[int], qr: List[int]) -> List[int]:\n\n        map_ = defaultdict(list)\n\n        for i, v in enumerate(nums):\n            map_[v].append(i)\n\n        n = len(qr)\n        ans = [-1] * n\n        inf = 10 ** 9\n        N = len(nums)\n        \n        for i, v in enumerate(qr):\n            ar = map_[nums[v]]\n            m = len(ar)\n            if m < 2:\n                continue\n            min_ = inf\n            idx = bisect_left(ar, v)\n\n            left = (idx - 1) % m\n            mx, mn = max(v, ar[left]), min(v, ar[left])\n            min_ = min(min_, mx - mn, N - mx + mn)\n            right = (idx + 1) % m\n            mx, mn = max(v, ar[right]), min(v, ar[right])\n            min_ = min(min_, mx - mn, N - mx + mn)\n            ans[i] = min_\n            \n        return ans\n","author":"Twin Braids","submissionId":"1575125873"},[]]},{"815":[{"id":"815","fileName":"1575125795.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int, int> mp;\n        vector<int> dist(n, 1e9);\n\n        for (int i = 2*n - 1; i >= 0; i--) {\n            if (mp.find(nums[i%n]) != mp.end() && mp[nums[i%n]] != i+n) {\n                dist[i%n] = mp[nums[i%n]] - i; \n            }\n            mp[nums[i%n]] = i; \n        }\n\n        map<int, int> mp2;\n        vector<int> dist2(n, 1e9);\n\n        for (int i = 0; i <=2*n-1; i++) {\n            if (mp2.find(nums[i%n]) != mp2.end() && mp2[nums[i%n]] != i-n) {\n                dist2[i%n] = i - mp2[nums[i%n]]; \n            }\n            mp2[nums[i%n]] = i; \n        }\n\n        vector<int> ans;\n        for (int i : queries) {\n            if (i < 0 || i >= n) ans.push_back(-1); \n            else if(dist[i] != 1e9 || dist2[i] != 1e9) ans.push_back(min(dist[i], dist2[i]));\n            else ans.push_back(-1);\n        }\n\n        return ans;\n    }\n};","author":"Yash","submissionId":"1575125795"},[]]},{"816":[{"id":"816","fileName":"1575125922.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n\n        int len = nums.length;\n        List<Integer> res = new ArrayList<>();\n\n        HashMap<Integer, TreeSet<Integer>> map = new HashMap<>();\n        for (int i = 0; i < len; i++) {\n            int key = nums[i];\n            map.putIfAbsent(key, new TreeSet<>());\n            map.get(key).add(i);\n        }\n\n        for (int q: queries) {\n\n            int minDis = Integer.MAX_VALUE;\n            int key = nums[q];\n            TreeSet<Integer> ts = map.get(key);\n            if (ts.size() == 1) {\n                res.add(-1);\n                continue;\n            }\n            Integer first = ts.first();\n            Integer last = ts.last();\n            Integer pre = ts.lower(q);\n            Integer next = ts.higher(q);\n            if (pre == null) {\n                pre = last;\n            }\n            if (next == null) {\n                next = first;\n            }\n            System.out.println(\"query: \" + q + \", key: \" + key + \" pre: \" + pre + \", next: \" + next);\n\n            minDis = Math.min(minDis, ((q - pre) + len) % len);\n            minDis = Math.min(minDis, ((pre - q) + len) % len);\n            minDis = Math.min(minDis, ((q - next) + len) % len);\n            minDis = Math.min(minDis, ((next - q) + len) % len);\n            res.add(minDis);\n        }\n        return res;\n    }\n}","author":"YanJF","submissionId":"1575125922"},[]]},{"818":[{"id":"818","fileName":"1575126049.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,pair<int,int>> mpp;\n        for(int i=0;i<nums.size();i++){\n            if(mpp.find(nums[i])==mpp.end()){\n                mpp[nums[i]].first=i;\n                mpp[nums[i]].second=i;\n            }\n            else{\n                mpp[nums[i]].second=i;\n            }\n        }\n        unordered_map<int,int> fmpp;\n        unordered_map<int,int> smpp;\n        vector<int> prefix(nums.size());\n        vector<int> postfix(nums.size());\n        for(int i=0;i<nums.size();i++){\n            if(fmpp.find(nums[i])!=fmpp.end()){\n                prefix[i]=i-fmpp[nums[i]];\n            }\n            else{\n                prefix[i]=(nums.size()-mpp[nums[i]].second+i)%nums.size();\n            }\n            fmpp[nums[i]]=i;\n        }\n        for(int i=nums.size()-1;i>=0;i--){\n            if(smpp.find(nums[i])!=smpp.end()){\n                postfix[i]=smpp[nums[i]]-i;\n            }\n            else{\n                postfix[i]=(nums.size()-i+mpp[nums[i]].first)%nums.size();\n            }\n            smpp[nums[i]]=i;\n        }\n        vector<int> ans(queries.size());\n        for(int i=0;i<queries.size();i++){\n            ans[i]=min(prefix[queries[i]],postfix[queries[i]]);\n            if(ans[i]==0){\n                ans[i]=-1;\n            }\n        }\n        return ans;\n    }\n};","author":"Saketh Karumudi","submissionId":"1575126049"},[]]},{"819":[{"id":"819","fileName":"1575125979.txt","sourceCode":"class Solution {\npublic List<Integer> solveQueries(int[] nums, int[] queries) {\n        var n = nums.length;\n        var before = new int[n];\n        var after = new int[n];\n        var lastIndexArr = new int[1_000_001];\n        Arrays.fill(before, -1);\n        Arrays.fill(after, -1);\n        Arrays.fill(lastIndexArr, -1);\n        for (int i = 0; i < n; i++) {\n            var num = nums[i];\n            if (lastIndexArr[num] != -1) {\n                before[i] = lastIndexArr[num];\n                after[lastIndexArr[num]] = i;\n            }\n\n            lastIndexArr[num] = i;\n        }\n        for (int i = 0; i < n; i++) {\n            var num = nums[i];\n            if (lastIndexArr[num] != -1) {\n                before[i] = lastIndexArr[num];\n                after[lastIndexArr[num]] = i;\n            }\n            lastIndexArr[num] = i;\n        }\n        var result = new ArrayList<Integer>();\n        for (var item : queries) {\n            var temp = Integer.MAX_VALUE;\n            if (before[item] != -1) {\n                if (item > before[item])\n                    temp = Math.min(temp, item - before[item]);\n                else\n                    temp = Math.min(temp, item - before[item] + n);\n            }\n            if (after[item] != -1) {\n                if (after[item] > item)\n                    temp = Math.min(temp, after[item] - item);\n                else\n                    temp = Math.min(temp, after[item] - item + n);\n            }\n            if (temp >= n)\n                temp = -1;\n            result.add(temp);\n        }\n        return result;\n    }\n}","author":"tmimotw","submissionId":"1575125979"},[]]},{"820":[{"id":"820","fileName":"1575126066.txt","sourceCode":"#include <bits/stdc++.h>\n#define rep(I, N) for (int I = 0; I < (N); ++I)\n#define ll long long\n#define pb push_back\n#define pii pair<int, int>\n#define vall(X) (X).begin(), (X).end()\n#define vi vector<int>\n#define vll vector<long long>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nconst int SIZE = 1e6 + 10;\nclass Solution {\npublic:\n    void helper(vi& nums, vi& queries, int n, vi& ans) {\n        int maxi=*max_element(vall(nums));\n        vector<vi> mpp(maxi+1);\n        rep(i,n)\n        {\n            mpp[nums[i]].push_back(i);\n        }\n        vi indi(n);\n        rep(i,maxi+1)\n        {\n            rep(j,mpp[i].size())\n            {\n                indi[mpp[i][j]]=j;\n            }\n        }\n        for (auto q : queries) {\n            int temp = nums[q];\n            if (mpp[temp].size() <= 1) \n            {\n                ans.pb(-1);\n                continue;\n            }\n            int ind =indi[q];\n            int k=mpp[temp].size();\n            int l=mpp[temp][(ind+k-1)%k];\n            int r=mpp[temp][(ind + 1) % k];\n            ans.pb(min(min(abs(q - l), n - abs(q - l)),min(abs(q - r), n - abs(q - r))));\n        }\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vi ans;\n        int n = nums.size();\n        helper(nums, queries, n, ans);\n        return ans;\n    }\n};","author":"uzer30","submissionId":"1575126066"},[]]},{"821":[{"id":"821","fileName":"1575126219.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        M=defaultdict(list)\n        for i,num in enumerate(nums):\n            M[num].append(i)\n        res=[]\n        for query in queries:\n            if nums[query] not in M or len(M[nums[query]])==1:\n                res.append(-1)\n            else:\n                idxary=M[nums[query]]\n                idx=bisect_left(idxary,query)\n                # print('left',idxary,idx)\n                if idx-1>-1:\n                    left=query-idxary[idx-1]\n                else:\n                    left=len(nums)-idxary[-1]+idxary[idx]\n                # print('left dist',left)\n                idx=bisect_right(idxary,query)\n                # print('right',idxary,idx)\n                \n                if idx<len(idxary):\n                    right=idxary[idx]-query\n                else:\n                    right=idxary[0]+(len(nums)-query)\n                # print('right dist',right)\n                res.append(min(left,right))\n        return res","author":"jjzzzmd","submissionId":"1575126219"},[]]},{"822":[{"id":"822","fileName":"1575126140.txt","sourceCode":"#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<string> vs;\ntypedef vector<char> vc;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef pair<int, int> pii;\ntypedef tuple<int, int, int> ti;\ntypedef pair<double, double> pdd;\ntypedef pair<ll, ll> pll;\ntypedef vector<pii> vpii;\ntypedef vector<vpii> vvpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef tree<int, null_type, less<>, rb_tree_tag, tree_order_statistics_node_update>\n        ordered_set;\nconst int inf = 1e9;\nconst ll llinf = 4e18;\nconst int mod = 1e9 + 7;\nconst double EPS = 1e-9;\n#define all(a) a.begin(),a.end()\n#define read(n) vi arr(n);for(int&_:arr)cin>>_\n#define readarr(arr) for(auto&_:arr)cin>>_\n#define readpair(arr) for(auto&[_,__]:arr)cin>>_>>__\n#define rep(i, a, n) for(int i=a;i<n;i++)\n#define repr(i, a, n) for(int i=a;i>=n;i--)\n#define nl \"n\"\n#define sz(v) ((int)v.size())\n#define PQ priority_queue\n#define hmap unordered_map\n#define hset unordered_set\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n#define clz(i) __builtin_clz(i)\n#define ctz(i) __builtin_ctz(i)\n#define popcount(i) __builtin_popcount(i)\n#define lsb(i) (i&-i)\nmt19937_64 rnd(time(0));\n\n\ntemplate<typename T>\ninline void pr(const T &t) { cout << t << ' '; }\n\ntemplate<typename T, typename U>\ninline void pr(const pair<T, U> &pa) {\n    cout << '(';\n    pr(pa.first);\n    cout << ',';\n    pr(pa.second);\n    cout << \") \";\n}\n\ntemplate<typename... Args>\ninline void pr(const tuple<Args...> &tup) {\n    apply([](const auto &... args) {\n        pr('[');\n        (pr(args), ...);\n        pr(']');\n    }, tup);\n}\n\ntemplate<typename T>\ninline void pr(const vector<T> &v) {\n    for (auto i: v) pr(i);\n    cout << nl;\n}\n\ntemplate<typename T>\ninline void pr(const set<T> &s) {\n    for (auto t: s)pr(t);\n    cout << nl;\n}\n\ntemplate<typename T>\ninline void pr(const unordered_set<T> &s) {\n    for (auto t: s)pr(t);\n    cout << nl;\n}\n\ntemplate<typename T, typename U>\ninline void pr(const map<T, U> &m) {\n    for (auto [t, u]: m) {\n        cout << '(';\n        pr(t);\n        pr('-');\n        pr(u);\n        pr(')');\n    }\n    cout << nl;\n}\n\ntemplate<typename T, typename U>\ninline void pr(const unordered_map<T, U> &m) {\n    for (auto [t, u]: m) {\n        cout << '(';\n        pr(t);\n        pr('-');\n        pr(u);\n        pr(')');\n    }\n    cout << nl;\n}\n\ntemplate<typename T>\ninline void pr(const queue<T> &q) {\n    queue<T> copy(q);\n    while (!copy.empty()) {\n        pr(copy.front());\n        copy.pop();\n    }\n    cout << nl;\n}\n\ntemplate<typename T>\ninline void pr(const stack<T> &s) {\n    stack<T> copy(s);\n    while (!copy.empty()) {\n        pr(copy.top());\n        copy.pop();\n    }\n    cout << nl;\n}\n\ntemplate<typename T>\ninline void pr(const deque<T> &q) {\n    deque<T> copy(q);\n    while (!copy.empty()) {\n        pr(copy.top());\n        copy.pop();\n    }\n    cout << nl;\n}\n\ntemplate<typename T>\ninline void pr(const PQ<T> &pq) {\n    PQ<T> copy(pq);\n    vector<T> arr;\n    while (!copy.empty()) {\n        arr.pb(copy.top());\n        copy.pop();\n    }\n    pr(arr);\n    cout << nl;\n}\n\ntemplate<typename T>\ninline void pr(const PQ<T, vector<T>, greater<T>> &pq) {\n    auto copy(pq);\n    vector<T> arr;\n    while (!copy.empty()) {\n        arr.pb(copy.top());\n        copy.pop();\n    }\n    pr(arr);\n    cout << nl;\n}\n\ntemplate<typename T>\ninline void pnl(const T &t) {\n    pr(t);\n    cout << nl;\n}\n\ntemplate<typename... Args>\nvoid pr(const Args &... args) {\n    (pr(args), ...);\n    cout << nl;\n}\n\nbool dfs(int a, int L, vector<vi> &g, vi &btoa, vi &A, vi &B) {\n    if (A[a] != L) return 0;\n    A[a] = -1;\n    for (int b: g[a])\n        if (B[b] == L + 1) {\n            B[b] = 0;\n            if (btoa[b] == -1 || dfs(btoa[b], L + 1, g, btoa, A, B))\n                return btoa[b] = a, 1;\n        }\n    return 0;\n}\n\nint hopcroftKarp(vector<vi> &g, vi &btoa) {\n    int res = 0;\n    vi A(g.size()), B(btoa.size()), cur, next;\n    for (;;) {\n        fill(all(A), 0);\n        fill(all(B), 0);\n        /// Find the starting nodes for BFS (i.e. layer 0).\n        cur.clear();\n        for (int a: btoa) if (a != -1) A[a] = -1;\n        rep(a, 0, sz(g)) if (A[a] == 0) cur.push_back(a);\n        /// Find all layers using bfs.\n        for (int lay = 1;; lay++) {\n            bool islast = 0;\n            next.clear();\n            for (int a: cur)\n                for (int b: g[a]) {\n                    if (btoa[b] == -1) {\n                        B[b] = lay;\n                        islast = 1;\n                    } else if (btoa[b] != a && !B[b]) {\n                        B[b] = lay;\n                        next.push_back(btoa[b]);\n                    }\n                }\n            if (islast) break;\n            if (next.empty()) return res;\n            for (int a: next) A[a] = lay;\n            cur.swap(next);\n        }\n        /// Use DFS to scan for augmenting paths.\n        rep(a, 0, sz(g))res += dfs(a, 0, g, btoa, A, B);\n    }\n}\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int q=sz(queries);\n        vi res(q);\n        hmap<int,vi>pos(1e6+1);\n        int n=sz(nums);\n        rep(i,0,n)pos[nums[i]].pb(i);\n        rep(i,0,q){\n            int idx=queries[i];\n            int cur=nums[idx];\n            if(sz(pos[cur])==1)res[i]=-1;\n            else{\n                auto it=ub(all(pos[cur]),idx);\n                int ans=inf;\n                if(it!=pos[cur].end()){\n                    ans=min(*it-idx,idx+n-*it);\n                }else{\n                    it=pos[cur].begin();\n                    ans=min(ans,min(idx-*it,*it+n-idx));\n                }\n                it=lb(all(pos[cur]),idx);\n                if(it!=pos[cur].begin()){\n                    --it;\n                    ans=min(ans,min(idx-*it,*it+n-idx));\n                }else{\n                    it=pos[cur].end()-1;\n                    ans=min(ans,min(*it-idx,idx+n-*it));\n                }\n                res[i]=ans;\n            }\n        }\n        return res;\n    }\n};\n//inline void solve() {\n//\n//}\n//\n//int32_t main() {\n//    ios_base::sync_with_stdio(false);\n//    cin.tie(nullptr);\n//    cout.tie(nullptr);\n//    cout << fixed << setprecision(10);\n//    int cases = 1;\n////    cin >> cases;\n//    while (cases--) solve();\n//    return 0;\n//}","author":"Choon Hean Lew","submissionId":"1575126140"},[]]},{"823":[{"id":"823","fileName":"1575126217.txt","sourceCode":"from typing import List\nfrom collections import defaultdict\nfrom bisect import bisect_left\nclass Solution:\n    def solveQueries(self,nums:List[int],queries:List[int])->List[int]:\n        h=defaultdict(list)\n        for i,ele in enumerate(nums):\n            h[ele].append(i)\n        ans=[-1]*len(queries)\n        n=len(nums)\n        for j,q in enumerate(queries):\n            ele=nums[q]\n            neigh=h[ele]\n            if len(neigh)==1:\n                continue\n            i=bisect_left(neigh,q)\n            if i>0:\n                l=neigh[i-1]\n            else:\n                l=neigh[-1]\n            if i+1<len(neigh):\n                r=neigh[i+1]\n            else:\n                r=neigh[0]\n            d1=min(abs(q-l),n-abs(q-l))\n            d2=min(abs(q-r),n-abs(q-r))\n            ans[j]=min(d1,d2)\n        return ans\n","author":"Bay Harbour Butcher","submissionId":"1575126217"},[]]},{"824":[{"id":"824","fileName":"1575126118.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>>mp;\n        int n = nums.size();\n        for(int i = 0; i < n; i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int>ans;\n        for(int i = 0; i < queries.size(); i++){\n            int curr = INT_MAX;\n            int ind = queries[i];\n            // vector<int>v = mp[nums[ind]];\n            if(mp[nums[ind]].size() == 1){\n                ans.push_back(-1);\n                continue;\n            }\n            int pos = lower_bound(mp[nums[ind]].begin(), mp[nums[ind]].end(), ind) - mp[nums[ind]].begin();\n            if(pos > 0){\n                int index = mp[nums[ind]][pos - 1];\n                int y= min(abs(ind - index), n - abs(ind - index));\n                curr = min(curr, y);\n            }\n            else{\n                curr = min(curr, n - abs(mp[nums[ind]][mp[nums[ind]].size() - 1] - mp[nums[ind]][pos]));\n            }\n            if(pos < mp[nums[ind]].size() - 1){\n                int index = mp[nums[ind]][pos + 1];\n                int x = min(abs(ind - index), n - abs(ind - index));\n                curr = min(curr, x);\n            }\n            else{\n                curr = min(curr, n - abs(mp[nums[ind]][0] - mp[nums[ind]][pos]));\n            }\n            ans.push_back(curr);\n        }\n        return ans;\n    }\n};","author":"Siddharth Singh","submissionId":"1575126118"},[]]},{"825":[{"id":"825","fileName":"1575126234.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        places = {}\n        n, m = len(nums), len(queries)\n        for i in range(n):\n            places.setdefault(nums[i], []).append(i)\n        \n        ans = [-1] * n\n        for k, idxs in places.items():\n            if len(idxs) >= 2:\n                head, tail = idxs[0], idxs[-1]\n                ans[head] = min(idxs[1] - head, head - tail + n)\n                ans[tail] = min(tail - idxs[-2], head - tail + n)\n                for j in range(1, len(idxs) - 1):\n                    idx = idxs[j]\n                    ans[idx] = min(idx - idxs[j - 1], idxs[j + 1] - idx)\n        \n        \n        return [ans[query] for query in queries]","author":"liuyc18","submissionId":"1575126234"},[]]},{"827":[{"id":"827","fileName":"1575126247.txt","sourceCode":"class Solution:\n    from collections import defaultdict\n    import bisect\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        idx_map = defaultdict(list)      \n        for i, num in enumerate(nums):\n            idx_map[num].append(i)\n        n = len(nums)\n        min_dist = [-1] * n        \n        for p in idx_map.values():\n            if len(p) < 2:\n                continue           \n            for i in range(len(p)):\n                c = p[i]\n                n_p = p[(i + 1) % len(p)]                \n                norm_dist = abs(n_p - c)\n                circ_dist = n - norm_dist\n                \n                min_dist[c] = min(min_dist[c] if min_dist[c] != -1 else float('inf'), norm_dist, circ_dist)\n                min_dist[n_p] = min(min_dist[n_p] if min_dist[n_p] != -1 else float('inf'), norm_dist, circ_dist)\n        ans = []\n        for q in queries:\n            ans.append(min_dist[q] if min_dist[q] != -1 else -1)\n\n        return ans","author":"Akankasha","submissionId":"1575126247"},[]]},{"828":[{"id":"828","fileName":"1575126222.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,set<int>> m;\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            m[nums[i]].insert(i);\n            m[nums[i]].insert(n+i);\n        }\n        vector<int> ans;\n        for(int i:queries){\n            if(m[nums[i]].size()==2) ans.push_back(-1);\n            else{\n                int uind=*m[nums[i]].upper_bound(i);\n                auto lp=m[nums[i]].lower_bound(i);\n                int lind=1e9;\n                if(lp!=m[nums[i]].begin()){ lp--,lind=*lp;}\n                int ind1=min(abs(uind-i),abs(lind-i));\n\n                i+=n;\n                uind=1e9;\n                auto up=m[nums[i-n]].upper_bound(i);\n                if(up!=m[nums[i-n]].end()) uind=*up;\n                lp=m[nums[i-n]].lower_bound(i);\n                lind=1e9;\n                if(lp!=m[nums[i-n]].begin()){ lp--,lind=*lp;}\n                int ind2=min(abs(uind-i),abs(lind-i));\n                \n                ans.push_back(min(ind1,ind2));\n            }\n        }\n        return ans;\n    }\n};","author":"David_264","submissionId":"1575126222"},[]]},{"829":[{"id":"829","fileName":"1575126299.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int[] ans = new int[nums.length];\n        Map<Integer, TreeSet<Integer>> hm = new HashMap<>();\n        int c = 0;\n        for (int i : nums) {\n            if (!hm.containsKey(i)) {\n                hm.put(i, new TreeSet<>());\n            }\n            hm.get(i).add(c);\n            c++;\n        }\n\n        for (int i = 0; i < nums.length; i++) {\n            if (hm.get(nums[i]).size() == 1) {\n                ans[i] = -1;\n                continue;\n            }\n            Integer left = hm.get(nums[i]).lower(i);\n            if (left == null) {\n                left = hm.get(nums[i]).last() - nums.length;\n            }\n            Integer right = hm.get(nums[i]).higher(i);\n            if (right == null) {\n                right = hm.get(nums[i]).first() + nums.length;\n            }\n            // System.out.println(i +\" : left \" + left + \" : right \" + right);\n            ans[i] = Math.min(i - left, right - i);\n        }\n\n        List<Integer> res = new ArrayList<>();\n        for (int q : queries) {\n            res.add(ans[q]);\n        }\n        return res;\n        \n    }\n}","author":"Shubham","submissionId":"1575126299"},[]]},{"830":[{"id":"830","fileName":"1575126095.txt","sourceCode":"class Solution {\npublic:\nusing ll= long long;\nusing sg=string;\ntypedef pair<int, int> pll;\ntypedef vector<int> vll;\ntypedef vector<pll> vpll; \ntypedef map<int,int> mll;\n#define ff first\n#define ss second\n#define pb push_back\n#define fl(i,n) for(int i=0;i<n;i++)\n#define vr(v) v.begin(),v.end()\n#define flp(i,a,b) for(int i = a; i <= b; i++)\n\n    vector<int> solveQueries(vector<int>& v, vector<int>& q) {\n        int n=v.size();\n        map<int,vll>mpp;\n        fl(i,n){\n            mpp[v[i]].pb(i);\n        }\n        int m=q.size();\n        vll ans(m,0);\n        fl(i,m){\n            int val=v[q[i]];\n            int id=lower_bound(mpp[val].begin(),mpp[val].end(),q[i])-mpp[val].begin();\n            if(mpp[val].size()==1){\n                ans[i]=-1;\n                continue;\n            }\n            int mini=1e9;\n            int sz=mpp[val].size();\n            if(id==0){\n                mini=min({mini,n-abs(mpp[val][0]-mpp[val].back()),abs(mpp[val][0]-mpp[val][1])});\n            } \n            else if(id==sz-1){\n                mini=min({mini,n-abs(mpp[val][0]-mpp[val].back()),abs(mpp[val][sz-2]-mpp[val].back())});\n            }else{\n                mini=min({mini,abs(mpp[val][id-1]-mpp[val][id]),abs(mpp[val][id+1]-mpp[val][id])});\n            } \n            ans[i]=mini;\n        }\n        return ans;\n    }\n};","author":"utkarsh prakash","submissionId":"1575126095"},[]]},{"831":[{"id":"831","fileName":"1575126311.txt","sourceCode":"\nfunc solveQueries(nums []int, queries []int) []int {\n\tn := len(nums)\n\tv2i := make(map[int][]int)\n\tfor i, num := range nums {\n\t\tv2i[num] = append(v2i[num], i)\n\t}\n\tgetMinD := func(q int) int {\n\t\tval := nums[q]\n\t\tpos := v2i[val]\n\t\tif len(pos) == 1 {\n\t\t\treturn -1\n\t\t}\n\t\tidx := sort.SearchInts(pos, q)\n\t\tminDist := math.MaxInt32\n\n\t\tif idx > 0 {\n\t\t\tleft := pos[idx-1]\n\t\t\tdist := (q - left + n) % n\n\t\t\tif dist < minDist {\n\t\t\t\tminDist = dist\n\t\t\t}\n\t\t}\n\n\t\tif idx < len(pos) {\n\t\t\tright := pos[idx]\n\t\t\tif right == q {\n\t\t\t\tif idx+1 < len(pos) {\n\t\t\t\t\tright = pos[idx+1]\n\t\t\t\t} else {\n\t\t\t\t\tright = -1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif right != -1 {\n\t\t\t\tdist := (right - q + n) % n\n\t\t\t\tif dist < minDist {\n\t\t\t\t\tminDist = dist\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif len(pos) > 1 {\n\t\t\tfirst := pos[0]\n\t\t\tlast := pos[len(pos)-1]\n\t\t\tif first != q {\n\t\t\t\twrapDist := min(\n\t\t\t\t\t(first - q + n) % n,\n\t\t\t\t)\n\t\t\t\tif wrapDist < minDist {\n\t\t\t\t\tminDist = wrapDist\n\t\t\t\t}\n\t\t\t}\n\t\t\tif last != q {\n\t\t\t\twrapDist := min(\n\t\t\t\t\t(q - last + n) % n,\n\t\t\t\t)\n\t\t\t\tif wrapDist < minDist {\n\t\t\t\t\tminDist = wrapDist\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn minDist\n\t}\n\n\tans := make([]int, len(queries))\n\tfor i, q := range queries {\n\t\tans[i] = getMinD(q)\n\t}\n\treturn ans\n}","author":"YUFENGWANG","submissionId":"1575126311"},[]]},{"832":[{"id":"832","fileName":"1575126363.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> m;\n\n        for(int i=0; i<n; ++i)\n            m[nums[i]].push_back(i);\n        \n        vector<int> ret(queries.size(), INT_MAX);\n        int idx = 0;\n        for(auto q : queries){\n            if(m[nums[q]].size() == 1)\n                ret[idx++] = -1;\n            else{\n                auto it = lower_bound(m[nums[q]].begin(), m[nums[q]].end(), q);\n                if(next(it) != m[nums[q]].end())\n                    ret[idx] = *next(it) - *it;\n                else\n                    ret[idx] = (n-*it) + *m[nums[q]].begin();\n                if(it != m[nums[q]].begin())\n                    ret[idx] = min(*it - *prev(it), ret[idx]);\n                else\n                    ret[idx] = min((n-*prev(m[nums[q]].end())) + *it, ret[idx]);\n                idx++;\n            }\n        }\n        return ret;\n    }\n};","author":"hc167","submissionId":"1575126363"},[]]},{"834":[{"id":"834","fileName":"1575126398.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        idx_map = defaultdict(list)\n        n = len(nums)\n        for i, num in enumerate(nums):\n            idx_map[num].append(i)\n        res = []\n        for q in queries:\n            v = nums[q]\n            idxs = idx_map[v]\n            if len(idxs) == 1:\n                res.append(-1)\n                continue\n            p = bisect.bisect_left(idxs, q)\n            p_prev = (p - 1) % len(idxs)\n            p_next = (p + 1) % len(idxs)\n            d1 = min(abs(q - idxs[p_prev]), n - abs(q - idxs[p_prev]))\n            d2 = min(abs(q - idxs[p_next]), n - abs(q - idxs[p_next]))\n            res.append(min(d1, d2))\n        return res\n","author":"S Yathissh","submissionId":"1575126398"},[{"id":"1343","similarity":0.7363636363636363,"totOverlap":81,"longestOverlap":26}]],"1343":[{"id":"1343","fileName":"1575139507.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        pos_map = defaultdict(list)\n        n = len(nums)\n\n        for i, v in enumerate(nums):\n            pos_map[v].append(i)\n\n        res = []\n        for q in queries:\n            v = nums[q]\n            pos = pos_map[v]\n\n            if len(pos) == 1:\n                res.append(-1)\n                continue\n\n            idx = bisect.bisect_left(pos, q)\n            prev_idx = (idx - 1) % len(pos)\n            next_idx = (idx + 1) % len(pos)\n            res.append(min(\n                min(abs(q - pos[prev_idx]), n - abs(q - pos[prev_idx])),\n                min(abs(q - pos[next_idx]), n - abs(q - pos[next_idx]))\n            ))\n\n        return res","author":"Meenakshi","submissionId":"1575139507"},[{"id":"834","similarity":0.7363636363636363,"totOverlap":81,"longestOverlap":26}]]},{"835":[{"id":"835","fileName":"1575126427.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> ans;\n        unordered_map<int, vector<int>> mp;\n        int n = nums.size();\n        for (int i = 0; i < nums.size(); i++)\n            mp[nums[i]].push_back(i);\n        for (int i = 0; i < queries.size(); i++) {\n            int ind = queries[i];\n            vector<int>& temp = mp[nums[ind]];\n            int size = temp.size();\n            int pos = lower_bound(temp.begin(),temp.end(),ind) - temp.begin();\n            if (size > 1) {\n                int mini = 1e9;\n                if (pos - 1 >= 0)\n                    mini = min(mini, ind - temp[pos - 1]);\n                else \n                    mini = min(mini, ind + (n - temp[size-1]));\n                if (pos + 1 < size){\n                    mini=min(mini,temp[pos+1]-ind);\n                }\n                else mini=min(mini,n-ind+temp[0]);\n\n                if(mini==1e9)mini=-1;\n                ans.push_back(mini);\n            } else\n                ans.push_back(-1);\n        }\n        return ans;\n    }\n};","author":"viking","submissionId":"1575126427"},[]]},{"836":[{"id":"836","fileName":"1575126437.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n = nums.size();\n        vector<int> minDis(n, INT_MAX) ;\n        map<int, int> prev;\n\n        vector<int> temp(nums.begin(), nums.end());\n        for(auto&val : nums ) temp.push_back(val);\n\n        for (int i = 0; i < temp.size(); i++) {\n            if (prev.find(nums[i%n]) != prev.end() && prev[nums[i%n]] != i % n) {\n                minDis[i % n] = min(minDis[i % n], i - prev[nums[i%n]]);\n                int ind =  prev[nums[i%n]];\n                minDis[ind % n] = min(minDis[ind % n], i - prev[nums[i%n]]);\n            }\n            prev[nums[i%n]] = i;\n        }\n\n        // for(int i=0;i<n;i++) cout<<minDis[i]<<\" \";\n\n\n        vector<int> ans(q.size(), -1);\n\n        for (int i=0;i<q.size();i++) {\n\n            if(minDis[q[i]]!=INT_MAX) ans[i] = minDis[q[i]];\n        \n        }\n\n        return ans;\n    }\n};","author":"Dev Aghera","submissionId":"1575126437"},[]]},{"837":[{"id":"837","fileName":"1575126533.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n=nums.size();\n        int sz=q.size();\n        vector<int>ans(sz);\n        vector<int>hash(n,1e8);\n        map<int,pair<int,int>>mpp1;\n        map<int,pair<int,int>>mpp2;\n        for(int i=0;i<n;i++){\n            int val=nums[i];\n            if(mpp1.find(val)!=mpp1.end()){\n                int a=i-mpp1[val].second;\n                int b=(mpp1[val].first+(n-i));\n                hash[i]=min(hash[i],min(a,b));\n            }\n            if(mpp1.find(val)==mpp1.end()){\n                mpp1[val].first=i;\n            }\n            mpp1[val].second=i;\n            \n        }\n        for(int i=n-1;i>=0;i--){\n            int val=nums[i];\n            if(mpp2.find(val)!=mpp2.end()){\n                int a=mpp2[val].second-i;\n                int b=(n-mpp2[val].first+i);\n                hash[i]=min(hash[i],min(a,b));\n            }\n            if(mpp2.find(val)==mpp2.end()){\n                mpp2[val].first=i;\n            }\n            mpp2[val].second=i;\n        }\n        for(int i=0;i<n;i++){\n            cout<<hash[i]<<\" \";\n            \n        }\n        cout<<endl;\n        for(int i=0;i<sz;i++){\n            int ind=q[i];\n            if(hash[q[i]]==1e8){\n                ans[i]=-1;\n            }\n            else{\n                ans[i]=hash[q[i]];\n            }\n        }\n        return ans;\n    }\n};","author":"Devansh Shankhdhar","submissionId":"1575126533"},[]]},{"838":[{"id":"838","fileName":"1575126546.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n\n        indexes = defaultdict(list)\n        n = len(nums)\n\n        for i in range(n):\n            indexes[nums[i]].append(i)\n\n        res = []\n        \n        for q in queries:\n            num = nums[q]\n            ixs = indexes[num]\n            if len(ixs) == 1:\n                res.append(-1)\n                continue\n            indx = bisect.bisect_left(ixs, q)\n            left_val = float('inf')\n            right_val = float('inf')\n            if indx < len(ixs)-1:\n                right_val = (ixs[indx+1]-q)\n            else:\n                right_val = n - q + ixs[0]\n            \n            if indx > 0:\n                left_val = (q - ixs[indx-1])\n            else:\n                left_val = n - ixs[indx-1] + q\n                \n            res.append(min(left_val, right_val))\n\n\n        return res\n                \n                \n        ","author":"Manu S Pillai","submissionId":"1575126546"},[]]},{"839":[{"id":"839","fileName":"1575126250.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, TreeSet<Integer>> map = new HashMap<>();\n        \n        int n = nums.length;\n        for (int i = 0; i < n; ++i) {\n            if (!map.containsKey(nums[i])) map.put(nums[i], new TreeSet<>());\n            map.get(nums[i]).add(i);\n            map.get(nums[i]).add(i + n);\n        }\n        \n        List<Integer> res = new ArrayList<>();\n        for (int i = 0; i < queries.length; ++i) {\n            int idx = queries[i];\n            \n            Integer lo = map.get(nums[queries[i]]).lower(idx);\n            Integer hi = map.get(nums[queries[i]]).higher(idx);\n                        \n            int min = Integer.MAX_VALUE;\n            if (lo != null) {\n                min = Math.min(min, idx - lo);\n            }\n            if (hi != null) {\n                min = Math.min(min, hi - idx);\n            }\n            \n            idx = queries[i] + n;\n            \n            lo = map.get(nums[queries[i]]).lower(idx);\n            hi = map.get(nums[queries[i]]).higher(idx);\n            \n            if (lo != null) {\n                min = Math.min(min, idx - lo);\n            }\n            if (hi != null) {\n                min = Math.min(min, hi - idx);\n            }\n            \n            res.add(min >= n ? -1 : min);\n        }\n        return res;\n    }\n}","author":"Terry","submissionId":"1575126250"},[]]},{"841":[{"id":"841","fileName":"1575126469.txt","sourceCode":"class Solution\n{\n    public:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries)\n    {\n        int n = nums.size(), q = queries.size();\n        for (int i = 0; i <= n - 1; i++) nums.push_back(nums[i]);\n            \n        vector<int> ans(q, 2 * n);\n        unordered_map<int, vector<int>> idx;\n        for (int i = 0; i <= 2 * n - 1; i++) idx[nums[i]].push_back(i);\n        \n        for (int qi = 0; qi <= q - 1; qi++)\n        {\n            int i = queries[qi];\n            int num = nums[i];\n            \n            int ub = upper_bound(idx[num].begin(), idx[num].end(), i) - idx[num].begin();\n            int lb = lower_bound(idx[num].begin(), idx[num].end(), i) - idx[num].begin();\n        \n            if (lb > 0)\n            {\n                lb--;\n                ans[qi] = i - idx[num][lb];\n            }\n            if (idx[num][ub] - i <= n - 1) ans[qi] = min(ans[qi], idx[num][ub] - i);\n            \n            i = i + n;\n            ub = upper_bound(idx[num].begin(), idx[num].end(), i) - idx[num].begin();\n            lb = lower_bound(idx[num].begin(), idx[num].end(), i) - idx[num].begin();\n        \n            lb--;\n            if (i - idx[num][lb] <= n - 1) ans[qi] = min(ans[qi], i - idx[num][lb]);\n            \n            \n            int const nidx = idx[num].size();\n            if (ub <= nidx - 1) ans[qi] = min(ans[qi], idx[num][ub] - i);\n\n            \n            \n            if (ans[qi] >= n) ans[qi] = -1;\n        }\n        \n        \n        return ans;\n    }\n};","author":"lakkshyag","submissionId":"1575126469"},[]]},{"842":[{"id":"842","fileName":"1575126596.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,set<int>>mp;\n        int n=nums.size();\n        for(int i=0;i<n;i++)\n        {\n            mp[nums[i]].insert(i);\n        }\n        int m=queries.size();\n        vector<int>ans(m,-1);\n        for(int i=0;i<m;i++)\n        {\n            int ind=queries[i];\n            int ind1=-1;\n            int ind2=-1;\n            int ind3=-1;\n            int ind4=-1;\n            int res=1e9;\n            auto itr1=mp[nums[ind]].lower_bound(ind);\n            auto itr2=mp[nums[ind]].upper_bound(ind);\n            auto itr3=mp[nums[ind]].begin();\n            auto itr4=mp[nums[ind]].rbegin();\n            if(itr1!=mp[nums[ind]].end() && itr1!=mp[nums[ind]].begin())\n            {\n                 itr1--;\n                 ind1=*itr1;\n                 res=min(res,ind-ind1);\n            }\n            if(itr2!=mp[nums[ind]].end())\n            {\n                 ind2=*itr2;\n                 res=min(res,ind2-ind);\n            }\n            if(*itr3 != ind)\n            {\n                 ind3=*itr3;\n                 res=min(res,abs(n-ind)+ind3);\n            }\n            if(*itr4 !=ind)\n            {\n                 ind4=*itr4;\n                 res=min(res,abs(n-ind4)+ind);\n            }\n            if(res!=1e9)\n            {\n                ans[i]=res;\n            }\n        }\n        return ans;\n    }\n};","author":"Monolith","submissionId":"1575126596"},[]]},{"843":[{"id":"843","fileName":"1575126627.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            map.computeIfAbsent(nums[i], o -> new ArrayList<>()).add(i);\n        }\n        List<Integer> res = new ArrayList<>();\n        for (int i = 0; i < queries.length; i++) {\n            int val = nums[queries[i]];\n            List<Integer> list = map.get(val);\n            if (list.size() == 1) res.add(-1);\n            else if (list.size() == 2)\n                res.add(Math.min((list.get(0) - list.get(1) + n) % n, list.get(1) - list.get(0)));\n            else {\n                int idx = binarySearch(queries[i], list);\n                int size = list.size();\n                int left = (idx - 1 + size) % size;\n                int right = (idx + 1) % size;\n                res.add(Math.min(Math.min((list.get(idx) - list.get(left) + n) % n, (list.get(left) - list.get(idx) + n) % n), Math.min((list.get(right) - list.get(idx) + n) % n, (list.get(idx) - list.get(right) + n) % n)));\n            }\n        }\n        return res;\n    }\n\n    private int binarySearch(int target, List<Integer> list) {\n        int left = 0, right = list.size() - 1;\n        while (left <= right) {\n            int mid = right + left >>> 1;\n            if (list.get(mid) == target) return mid;\n            else if (list.get(mid) > target) right = mid - 1;\n            else left = mid + 1;\n        }\n        return -1;\n    }\n}","author":"Di Ha","submissionId":"1575126627"},[]]},{"844":[{"id":"844","fileName":"1575126718.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n\n        int n=nums.size();\n        \n        vector<int> v=nums;\n        for(int x:nums) v.push_back(x);\n\n        vector<int> dis(2*n,INT_MAX);\n\n        unordered_map<int,int> pre,suff;\n\n        for(int i=0;i<2*n -1;i++){\n\n            int num=v[i];\n            if(pre.find(num)!=pre.end()) dis[i]=min(dis[i],i-pre[num]);\n\n            pre[num]=i;\n        }\n        for(int i=2*n -1;i>=0;i--){\n\n            int num=v[i];\n            if(suff.find(num)!=suff.end()) dis[i]=min(dis[i],suff[num]-i);\n\n            suff[num]=i;\n        }\n        vector<int> ans;\n\n        for(int ind:queries){\n\n            int d=min(dis[ind],dis[ind+n]);\n            if(d>=n) ans.push_back(-1);\n            else ans.push_back(d);\n        }\n        return ans;\n    }\n};","author":"GMT","submissionId":"1575126718"},[]]},{"845":[{"id":"845","fileName":"1575126713.txt","sourceCode":"/**\n *    author:  Chet8n\n *    created: 16.03.2025 08:09:30\n **/\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define fastio ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define all(x) (x).begin(), (x).end()\n#define ceill(x, y) ((x + y - 1) / y)\n#define setbits(x) __builtin_popcountll(x)\n\nconst int mod = 1e9 + 7;\nconst int inf = 2e9 + 5;\nconst long long infl = 2e18 + 5;\ndouble PI = 3.14159265358979323846;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define db(...) 20\n#define sout(...) 20\n#endif\n\nclass Solution {\n  public:\n    vector<int> solveQueries(vector<int> &nums, vector<int> &queries) {\n\n        int n = nums.size();\n        int m = queries.size();\n        map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n\n        vector<int> ans(m);\n\n        for (int i = 0; i < m; i++) {\n            int num = nums[queries[i]];\n            if (mp[num].size() == 1) {\n                ans[i] = -1;\n            } else {\n                int ind = lower_bound(all(mp[num]), queries[i]) - mp[num].begin();\n                int N = mp[num].size();\n                int dist = inf;\n                if (ind + 1 < N) {\n                    dist = min(dist, mp[num][ind + 1] - mp[num][ind]);\n                }\n                if(i == 2)db(dist);\n                if (ind - 1 >= 0) {\n                    dist = min(dist, mp[num][ind] - mp[num][ind - 1]);\n                }\n                if(i == 2)db(dist);\n                if (ind == 0) {\n                    dist = min(dist, n - 1 - mp[num][N - 1] + mp[num][ind] + 1);\n                }\n                if(i == 2)db(dist);\n                if (ind == N - 1) {\n                    db(i);\n                    dist = min(dist, mp[num][0] + n - 1 - mp[num][ind] + 1);\n                }\n                if(i == 2)db(dist);\n                ans[i] = dist;\n            }\n        }\n\n        return ans;\n    }\n};\n\n#ifdef LOCAL\nint32_t main() {\n    fastio;\n    int testCases = 1;\n    // cin >> testCases;\n    for (int i = 1; i <= testCases; i++) {\n        Solution s;\n        vector<int> nums = {1,3,1,4,1,3,2};\n        vector<int> queries = {0, 3, 5};\n        auto ans = s.solveQueries(nums, queries);\n        sout(ans);\n    }\n}\n#endif","author":"Chethan J","submissionId":"1575126713"},[]]},{"848":[{"id":"848","fileName":"1575126891.txt","sourceCode":"public class Solution {\n    public IList<int> SolveQueries(int[] nums, int[] queries) {\n        int n = nums.Length;\n        var valueToIndices = new Dictionary<int, List<int>>();\n        \n        // Bước 1: Xây dựng bảng ánh xạ giá trị -> danh sách chỉ số\n        for (int i = 0; i < n; i++) {\n            if (!valueToIndices.ContainsKey(nums[i])) {\n                valueToIndices[nums[i]] = new List<int>();\n            }\n            valueToIndices[nums[i]].Add(i);\n        }\n        \n        // Bước 2: Duyệt qua các truy vấn và tính toán khoảng cách\n        int[] result = new int[queries.Length];\n        \n        for (int i = 0; i < queries.Length; i++) {\n            int query = queries[i];\n            int queryValue = nums[query];\n            var indices = valueToIndices[queryValue];\n            \n            // Nếu không có phần tử nào giống với nums[queries[i]], trả về -1\n            if (indices.Count == 1) {\n                result[i] = -1;\n                continue;\n            }\n            \n            // Bước 3: Tính khoảng cách ngắn nhất\n            int minDistance = int.MaxValue;\n            \n            // foreach (int idx in indices) {\n            //     if (idx != query) {\n            //         int distance = Math.Min(Math.Abs(query - idx), n - Math.Abs(query - idx));\n            //         minDistance = Math.Min(minDistance, distance);\n            //     }\n            // }\n\n            // for (int j = 0; j < indices.Count; j++) {\n            //     int prevIndex = indices[(j - 1 + indices.Count) % indices.Count];\n            //     int nextIndex = indices[(j + 1) % indices.Count];\n                \n            //     // Tính khoảng cách vòng tròn với chỉ số truy vấn\n            //     int distPrev = Math.Min(Math.Abs(query - prevIndex), n - Math.Abs(query - prevIndex));\n            //     int distNext = Math.Min(Math.Abs(query - nextIndex), n - Math.Abs(query - nextIndex));\n                \n            //     minDistance = Math.Min(minDistance, Math.Min(distPrev, distNext));\n            // }\n\n            int index = indices.IndexOf(query);\n\n            int prevIndex = indices[(index - 1 + indices.Count) % indices.Count];\n            int nextIndex = indices[(index + 1) % indices.Count];\n            \n            // Tính khoảng cách vòng tròn với chỉ số truy vấn\n            int distPrev = Math.Min(Math.Abs(query - prevIndex), n - Math.Abs(query - prevIndex));\n            int distNext = Math.Min(Math.Abs(query - nextIndex), n - Math.Abs(query - nextIndex));\n            \n            minDistance = Math.Min(minDistance, Math.Min(distPrev, distNext));\n            \n            result[i] = minDistance;\n        }\n        \n        return result;\n    }\n}","author":"vuongnguyen","submissionId":"1575126891"},[]]},{"850":[{"id":"850","fileName":"1575126767.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size(),m=queries.size();\n        vector<int> ans(m);\n        vector<int> lr(n),rl(n);\n        map<int,int> mp,np;\n        map<int,int> lmost,rmost;\n        for(int i=0;i<n;i++){\n            if(mp.find(nums[i])==mp.end()){\n                lr[i]=-1;\n                lmost[nums[i]]=i;\n                //cout<<nums[i]<<\" \"<<i<<endl;\n            }else{\n                lr[i]=mp[nums[i]];\n            }\n            mp[nums[i]]=i;\n        }\n        for(int i=n-1;i>=0;i--){\n            if(np.find(nums[i])==np.end()){\n                rl[i]=-1;\n                rmost[nums[i]]=i;\n            }else{\n                rl[i]=np[nums[i]];\n            }\n            np[nums[i]]=i;\n        }\n        for(int i=0;i<m;i++){\n            if(lr[queries[i]]==-1&&rl[queries[i]]==-1){\n                ans[i]=-1;\n            }\n            else if(lr[queries[i]]!=-1&&rl[queries[i]]!=-1){\n                ans[i]=min(queries[i]-lr[queries[i]],rl[queries[i]]-queries[i]);\n            }else{\n                if(lr[queries[i]]==-1){\n                    ans[i]=rl[queries[i]]-queries[i];\n                    ans[i]=min(ans[i],queries[i]+(n-rmost[nums[queries[i]]]));\n                }else{\n                    ans[i]=queries[i]-lr[queries[i]];\n                    \n                    ans[i]=min(ans[i],n-queries[i]-1+lmost[nums[queries[i]]]+1);\n                    //cout<<ans[i]<<endl;\n                }\n            }\n        }\n        return ans;\n    }\n};","author":"Naramala Siva Vekata Pavan","submissionId":"1575126767"},[]]},{"851":[{"id":"851","fileName":"1575126804.txt","sourceCode":"class Solution {\n       public static List<Integer> solveQueries(int[] nums, int[] queries) {\n        // HashMap<Integer,Integer> dist = new HashMap<>();\n        // for(int i=0;i<nums.length;i++){\n        //     dist.put(nums[i],Integer.MAX_VALUE);\n        // }\n        HashMap<Integer,Integer> hm = new HashMap<>();\n        int ans[]=new int[nums.length];\n        for(int i=0;i<2*nums.length;i++){\n            int ele = nums[i%nums.length];\n            if(hm.containsKey(ele)){\n                int val1 = hm.get(ele);\n                ans[i%nums.length]=i-val1;\n            }\n            hm.put(ele,i);\n        }\n        hm=new HashMap<>();\n        for(int j=2*nums.length-1;j>=0;j--){\n            int ele = nums[j%nums.length];\n            if(hm.containsKey(ele)){\n                int val1 = hm.get(ele);\n                ans[j%nums.length]=Math.min(ans[j%nums.length],val1-j);\n            }\n            hm.put(ele,j);\n        }\n        List<Integer> fi = new ArrayList<>();\n        for(int i=0;i<queries.length;i++){\n            if(ans[queries[i]]<nums.length) fi.add(ans[queries[i]]);\n            else fi.add(-1);\n        }\n        return fi;\n    }\n}","author":"pkojhnppmknsdf53453453534","submissionId":"1575126804"},[]]},{"852":[{"id":"852","fileName":"1575126917.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        next = list(range(n))\n        prev = list(range(n))\n        last = {}\n        for i,v in list(enumerate(nums))*2:\n            if v in last:\n                next[last[v]] = i\n                prev[i] = last[v]\n            last[v] = i\n        def d(q):\n            if next[q] == q:\n                return -1\n            return min((next[q] - q) % n, (q - prev[q]) % n)\n        return [d(q) for q in queries]","author":"nshepperd","submissionId":"1575126917"},[]]},{"853":[{"id":"853","fileName":"1575126845.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        pos = {}\n        for i in range(len(nums)):\n            n = nums[i]\n            if n not in pos:\n                pos[n] = []\n            pos[n].append(i)\n\n        res = []\n        for i in queries:\n            n = nums[i]\n            if len(pos[n]) == 1:\n                res.append(-1)\n            else:\n                res.append(self.minDist(pos[n], i, len(nums)))\n        return res\n\n    def minDist(self, nums, n, total):\n        start = 0\n        end = len(nums)-1\n        while start + 1 < end:\n            mid = (start+end)//2\n            if nums[mid] == n:\n                return self.helper(nums, mid, total)\n            elif nums[mid] < n:\n                start = mid\n            else:\n                end = mid\n        if nums[start] == n:\n            return self.helper(nums, start, total)\n        else:\n            return self.helper(nums, end, total)\n\n    def helper(self, nums, i, total):\n        if i > 0:\n            prev = nums[i] - nums[i-1]\n        else:\n            prev = total-(nums[-1] - nums[i])\n\n        if i < len(nums)-1:\n            post = nums[i+1] - nums[i]\n        else:\n            post = total-(nums[i]-nums[0])\n        return min(prev, post)\n                \n                                ","author":"reobb","submissionId":"1575126845"},[]]},{"854":[{"id":"854","fileName":"1575126914.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < a.size(); i++) {\n            mp[a[i]].push_back(i);\n        }\n\n        vector<int> res(a.size(), -1);\n        for (auto& it : mp) {\n            int n = it.second.size();\n            if (n == 1) continue;\n\n            for (int i = 1; i < n - 1; i++) {\n                res[it.second[i]] = min(it.second[i + 1] - it.second[i], it.second[i] - it.second[i - 1]);\n            }\n\n            res[it.second[0]] = min(it.second[1] - it.second[0], (int)std::abs(it.second[0] - it.second[n - 1] + (int)a.size()));\n            res[it.second[n - 1]] = min(it.second[n - 1] - it.second[n - 2], (int)std::abs(it.second[0] - it.second[n - 1] + (int)a.size()));\n        }\n\n        vector<int> ans;\n        for (auto& it : queries) {\n            ans.push_back(res[it]);\n        }\n        return ans;\n    }\n};\n","author":"Meda Jaswanth","submissionId":"1575126914"},[]]},{"855":[{"id":"855","fileName":"1575127012.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> indexMap;\n        // Step 1: Store indices for each number\n        for (int i = 0; i < n; i++) {\n            indexMap[nums[i]].push_back(i);\n        }\n\n        vector<int> result;\n        for (int q : queries) {\n            int targetIndex = q;\n            int targetValue = nums[q];\n\n            if (indexMap[targetValue].size() == 1) {\n                result.push_back(-1);\n                continue;\n            }\n\n            // Step 2: Find the closest index using binary search\n            vector<int>& indices = indexMap[targetValue];\n            auto it1 = upper_bound(indices.begin(), indices.end(), targetIndex);\n            auto it2 = lower_bound(indices.begin(), indices.end(), targetIndex);\n            int minDist = INT_MAX;\n            auto it3 = indices.begin();\n            auto it4 = indices.end();\n            --it4;\n            if(it2!=it4){\n                minDist=min(minDist,n-abs(targetIndex-*it4));\n            }\n            minDist=min(minDist,n-abs(targetIndex-*it3));\n            if(it2!=indices.begin()){\n                --it2;\n                minDist=min(minDist,abs(targetIndex-*it2));\n                minDist=min(minDist,n-abs(targetIndex-*it2));\n            }\n            if (it1 != indices.end()) {\n                minDist = min(minDist, *it1 - targetIndex);\n                minDist=min(minDist,n-abs(targetIndex-*it1));\n            }\n            result.push_back(minDist);\n        }\n\n        return result;\n    }\n};","author":"Manik Aggarwal","submissionId":"1575127012"},[]]},{"857":[{"id":"857","fileName":"1575127222.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> numToIndexes = new HashMap<>();\n        int[] indexToMin = new int[nums.length];\n        Arrays.fill(indexToMin, Integer.MAX_VALUE);\n        for(int i = 0; i < nums.length; i++){\n            if(!numToIndexes.containsKey(nums[i]))\n                numToIndexes.put(nums[i], new ArrayList<>());\n            List<Integer> indexes = numToIndexes.get(nums[i]);\n            int size = indexes.size();\n            if(size >= 1){\n                int prevIndex = indexes.get(size - 1);\n                indexToMin[prevIndex] = Math.min(indexToMin[prevIndex], i - prevIndex);\n                indexToMin[i] = i - prevIndex;\n                \n                int firstIndex = indexes.get(0);\n                int distance = nums.length - i + firstIndex;\n                indexToMin[firstIndex] = Math.min(indexToMin[firstIndex], distance);\n                indexToMin[i] = Math.min(indexToMin[i], distance);\n            }\n            indexes.add(i);\n        }\n        List<Integer> answer = new ArrayList<>();\n        for(int i = 0; i < queries.length; i++){\n            int query = queries[i];\n            answer.add(indexToMin[query] == Integer.MAX_VALUE? -1: indexToMin[query]);\n        }\n        return answer;\n    }\n}","author":"venkatkri5h","submissionId":"1575127222"},[]]},{"858":[{"id":"858","fileName":"1575126774.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n = nums.size();\n        map<int,vector<int>> mp;\n        for (int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans(q.size(),-1);\n        int cur = -1;\n        for (auto x : q){\n            cur++;\n            int idx = x;\n            int val = nums[x];\n            if (mp[val].size()==1) continue;\n            auto it = lower_bound(mp[val].begin(), mp[val].end(), idx) - mp[val].begin();\n            int sz = mp[val].size();\n            auto & temp = mp[val];\n            if (it == 0){\n                int dl = n-temp[sz-1]+temp[0];\n                int dr = temp[1]-temp[0];\n                // if (dl > dr){\n                //     ans[cur] = temp[1];\n                // }\n                // else{\n                //     ans[cur] = temp[sz-1];\n                // }\n                ans[cur] = min(dl,dr);\n            }\n            else if (it== sz-1){\n                int dl = temp[sz-1]-temp[sz-2];\n                int dr = n-temp[sz-1]+temp[0];\n                // cout << dl << \" \" << dr << endl;\n                // if (dl > dr){\n                //     ans[cur] = temp[0];\n                // }\n                // else{\n                //     ans[cur] = temp[sz-2];\n                // }\n                ans[cur] = min(dl,dr);\n            }\n            else{\n                int dl = temp[it]-temp[it-1];\n                int dr = temp[it+1]-temp[it];\n                // if (dl > dr){\n                //     ans[cur] = temp[it+1];\n                // }\n                // else{\n                //     ans[cur] = temp[it-1];\n                // }\n                ans[cur] = min(dl,dr);\n            }\n        }\n        return ans;\n    }\n};","author":"Kushhhhh42","submissionId":"1575126774"},[]]},{"859":[{"id":"859","fileName":"1575127190.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        linker = { }\n        indices = { }\n        for idx, num in enumerate(nums):\n            if num not in indices: indices[num] = list( )\n            indices[num].append(idx)\n            linker[idx] = len(indices[num]) - 1\n\n        result = list( )\n        for query in queries:\n            num = nums[query]\n            if len(indices[num]) == 1:\n                result.append(-1); continue\n\n            idx = linker[query]\n\n            if idx > 0:\n                distance = indices[num][idx] - indices[num][idx - 1]\n            else:\n                distance = indices[num][idx] - (indices[num][-1] - n)\n            if idx < len(indices[num]) - 1:\n                distance = min(distance, indices[num][idx + 1] - indices[num][idx])\n            else:\n                distance = min(distance, (n + indices[num][0]) - indices[num][idx])\n            result.append(distance)\n        return result","author":"Benjamin Banaga","submissionId":"1575127190"},[]]},{"860":[{"id":"860","fileName":"1575127277.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> ans;\n        map<int,vector<int>> bag;\n        for(int i=0;i<nums.size();i++){\n            bag[nums[i]].push_back(i);\n        }\n        int ind,val,m,n=nums.size();\n        for(int i=0;i<queries.size();i++){\n            if(bag[nums[queries[i]]].size()==1){\n                ans.push_back(-1);\n            }\n            else{\n                val = 1e9;\n                auto k = lower_bound(bag[nums[queries[i]]].begin(),bag[nums[queries[i]]].end(),queries[i]);\n                ind = k-bag[nums[queries[i]]].begin();\n                m = bag[nums[queries[i]]].size();\n                if(ind!=0)val = min(val,abs(bag[nums[queries[i]]][ind]-bag[nums[queries[i]]][ind-1]));\n                else val = min(val,bag[nums[queries[i]]][ind]+n-bag[nums[queries[i]]][m-1]);\n                if(ind<m-1)val = min(val,abs(bag[nums[queries[i]]][ind]-bag[nums[queries[i]]][ind+1]));\n                else val = min(val,n-bag[nums[queries[i]]][ind]+bag[nums[queries[i]]][0]);\n                ans.push_back(val);\n            }\n        }\n        return ans;\n    }\n};","author":"VVS Raghavendra","submissionId":"1575127277"},[]]},{"861":[{"id":"861","fileName":"1575127257.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        positions = defaultdict(list)\n\n        # Map each value to all indices where it occurs\n        for idx, num in enumerate(nums):\n            positions[num].append(idx)\n\n        result = []\n        for q in queries:\n            num = nums[q]\n            indices = positions[num]\n            if len(indices) == 1:\n                result.append(-1)\n                continue\n\n            pos = bisect.bisect_left(indices, q)\n\n            left_neighbor = indices[pos - 1] if pos > 0 else indices[-1]\n            right_neighbor = indices[pos] if pos < len(indices) and indices[pos] != q else indices[(pos + 1) % len(indices)]\n\n            left_dist = min(abs(q - left_neighbor), n - abs(q - left_neighbor))\n            right_dist = min(abs(q - right_neighbor), n - abs(q - right_neighbor))\n\n            result.append(min(left_dist, right_dist))\n        return result\n        \n        \n            ","author":"StasShkolnyi","submissionId":"1575127257"},[]]},{"862":[{"id":"862","fileName":"1575127230.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& n, vector<int>& q) {\n        map<int, vector<int>> pos;\n        int l = n.size();\n        for (int i = 0; i < n.size(); i++) {\n            pos[n[i]].push_back(i);\n        }\n        for (auto i : pos) {\n            sort(i.second.begin(), i.second.end());\n        }\n        vector<int> vans(q.size());\n        for (int i = 0; i < q.size(); i++) {\n            int ele = n[q[i]];\n            int hi = pos[ele].size() - 1;\n            int lo = 0;\n            int ans = -1;\n            while (hi >= lo) {\n                int mid = lo + (hi - lo) / 2;\n                if (pos[ele][mid] <= q[i]) {\n                    lo = mid + 1;\n                    ans = mid;\n                } else {\n                    hi = mid - 1;\n                }\n            }\n            // cout << pos[ele][ans] << \" \";\n            if (pos[ele].size() == 1) {\n                vans[i] = -1;\n                continue;\n            }\n            if (ans != 0 && ans != pos[ele].size() - 1) {\n                vans[i] = min(abs(pos[ele][ans - 1] - pos[ele][ans]),\n                              abs(pos[ele][ans + 1] - pos[ele][ans]));\n            } else {\n                if (ans == 0) {\n                    vans[i] = min(\n                        abs(pos[ele][ans + 1] - pos[ele][ans]),\n                        abs(pos[ele][ans] + l - pos[ele][pos[ele].size() - 1]));\n                } else {\n                    vans[i] = min(abs(pos[ele][ans - 1] - pos[ele][ans]),\n                                  abs(pos[ele][0] + l - pos[ele][ans]));\n                }\n            }\n        }\n        return vans;\n    }\n};","author":"marmick Mathur","submissionId":"1575127230"},[]]},{"863":[{"id":"863","fileName":"1575127403.txt","sourceCode":"#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> valueToIndices;\n\n        for (int i = 0; i < n; ++i) {\n            valueToIndices[nums[i]].push_back(i);\n        }\n\n        vector<int> answer;\n\n        for (int query : queries) {\n            int value = nums[query];\n            const vector<int>& indices = valueToIndices[value];\n\n            if (indices.size() == 1) {\n                answer.push_back(-1);\n                continue;\n            }\n\n            int minDistance = n;\n            auto it = lower_bound(indices.begin(), indices.end(), query);\n            int pos = it - indices.begin();\n\n            if (pos > 0) {\n                minDistance = min(minDistance, query - indices[pos - 1]);\n            } else if (indices.size() > 1) {\n                minDistance = min(minDistance, query + n - indices.back());\n            }\n\n            if (pos < indices.size() && indices[pos] != query) {\n                minDistance = min(minDistance, indices[pos] - query);\n            } else if (pos == indices.size()) {\n                minDistance = min(minDistance, indices[0] + n - query);\n            }\n\n            if (pos < indices.size() && indices[pos] == query) {\n                if (pos + 1 < indices.size()) {\n                    minDistance = min(minDistance, indices[pos + 1] - query);\n                } else {\n                    minDistance = min(minDistance, indices[0] + n - query);\n                }\n\n                if (pos > 0) {\n                    minDistance = min(minDistance, query - indices[pos - 1]);\n                } else {\n                    minDistance = min(minDistance, query + n - indices.back());\n                }\n            }\n\n            answer.push_back(minDistance);\n        }\n\n        return answer;\n    }\n};\n","author":"JITENDRA SINGH BAHTI","submissionId":"1575127403"},[{"id":"894","similarity":1.0,"totOverlap":260,"longestOverlap":130}]],"894":[{"id":"894","fileName":"1575128200.txt","sourceCode":"#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> valueToIndices;\n\n        for (int i = 0; i < n; ++i) {\n            valueToIndices[nums[i]].push_back(i);\n        }\n\n        vector<int> answer;\n\n        for (int query : queries) {\n            int value = nums[query];\n            const vector<int>& indices = valueToIndices[value];\n\n            if (indices.size() == 1) {\n                answer.push_back(-1);\n                continue;\n            }\n\n            int minDistance = n;\n            auto it = lower_bound(indices.begin(), indices.end(), query);\n            int pos = it - indices.begin();\n\n            if (pos > 0) {\n                minDistance = min(minDistance, query - indices[pos - 1]);\n            } else if (indices.size() > 1) {\n                minDistance = min(minDistance, query + n - indices.back());\n            }\n\n            if (pos < indices.size() && indices[pos] != query) {\n                minDistance = min(minDistance, indices[pos] - query);\n            } else if (pos == indices.size()) {\n                minDistance = min(minDistance, indices[0] + n - query);\n            }\n\n            if (pos < indices.size() && indices[pos] == query) {\n                if (pos + 1 < indices.size()) {\n                    minDistance = min(minDistance, indices[pos + 1] - query);\n                } else {\n                    minDistance = min(minDistance, indices[0] + n - query);\n                }\n\n                if (pos > 0) {\n                    minDistance = min(minDistance, query - indices[pos - 1]);\n                } else {\n                    minDistance = min(minDistance, query + n - indices.back());\n                }\n            }\n\n            answer.push_back(minDistance);\n        }\n\n        return answer;\n    }\n};\n","author":"rajput_js_bhati","submissionId":"1575128200"},[{"id":"863","similarity":1.0,"totOverlap":260,"longestOverlap":130}]]},{"864":[{"id":"864","fileName":"1575127251.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> mp;\n        for(int i = 0;i< nums.size();i++)\n        {\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans(nums.size(),-1);\n        for(auto it: mp)\n            {\n                vector<int> temp = it.second;\n                if(it.second.size()==1) continue;\n                for(int i = 0;i<temp.size();i++)\n                    {\n                        \n                        if(i==0)\n                        {\n                            ans[temp[i]]=temp[1]-temp[0];\n                            int t= nums.size()-temp[temp.size()-1] + temp[0];\n                            ans[temp[i]]=min(ans[temp[i]],t);\n                        }\n                        else if(i==temp.size()-1)\n                        {\n                            ans[temp[i]]=temp[temp.size()-1]-temp[temp.size()-2];\n                            int t = nums.size()-temp[temp.size()-1] + temp[0];\n                            ans[temp[i]]=min(ans[temp[i]],t);\n                        }\n                        else{\n                            ans[temp[i]]=temp[i]-temp[i-1];\n                            ans[temp[i]]=min(ans[temp[i]],temp[i+1]-temp[i]);\n                        }\n                         \n                    }\n               \n                \n            }\n        vector<int> result;\n        for(int i = 0;i<queries.size();i++)\n            {\n                result.push_back(ans[queries[i]]);\n            }\n       \n        return result;\n    }\n};","author":"Aaditya Vikram Saravana Bhavan","submissionId":"1575127251"},[]]},{"865":[{"id":"865","fileName":"1575127362.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& v, vector<int>& queries) {\n        int n=v.size();\n        for(int i=0;i<n;i++)\n            v.push_back(v[i]);\n        vector<int>ans;\n        vector<int>dis(n,-1);\n        unordered_map<int,int>m;\n        for(int i=v.size()-1;i>=n;i--){\n            m[v[i]]=i;\n        }\n        // for(auto it:m)\n        //     cout<<it.first<<\" \"<<it.second<<\"n\";\n        for(int i=n-1;i>=0;i--){\n            if(m.find(v[i])!=m.end())\n                dis[i]=abs(m[v[i]]-i);\n            m[v[i]]=i;\n        }\n        m.clear();\n        for(int i=0;i<n;i++){\n            if(m.find(v[i])!=m.end()){\n                if(dis[i]==-1||dis[i]>abs(m[v[i]]-i))\n                    dis[i]=abs(m[v[i]]-i);\n            }\n            m[v[i]]=i;\n        }\n        for(int i=n;i<v.size();i++){\n            if(m.find(v[i])!=m.end()){\n                if(dis[i-n]==-1||dis[i-n]>abs(m[v[i]]-i))\n                    dis[i-n]=abs(m[v[i]]-i);\n            }\n            m[v[i]]=i;\n        }\n        for(auto it:queries){\n            if(dis[it]!=n)\n            ans.push_back(dis[it]);\n            else\n            ans.push_back(-1);\n        }\n        return ans;\n    }\n};","author":"kraphe001","submissionId":"1575127362"},[]]},{"866":[{"id":"866","fileName":"1575127333.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> v[100'001];\n        int n = size(nums), q = size(queries);\n        map<int, int> used;\n        vector<int> index(n, -1);\n        for (int i = 0; i < n; i++) {\n            if (used.find(nums[i]) == end(used))\n                used[nums[i]] = i;\n            index[i] = size(v[used[nums[i]]]);\n            v[used[nums[i]]].push_back(i); \n        }\n\n        vector<int> ans(q);\n        for (int i = 0; i < q; i++) {\n            if (size(v[used[nums[queries[i]]]]) == 1) {\n                ans[i] = -1;\n                continue;\n            }\n\n            int val = used[nums[queries[i]]];\n            int idx = queries[i];\n            int l = size(v[val]);\n\n            int v1 = v[val][(index[idx]+1) % l];\n            int v2 = v[val][(index[idx] + l - 1) % l];\n\n            ans[i] = abs(queries[i] - v1);\n            ans[i] = min(ans[i], abs(n+queries[i] - v1));\n            ans[i] = min(ans[i], abs(n-queries[i] + v1));\n            ans[i] = min(ans[i], abs(queries[i] - v2));\n            ans[i] = min(ans[i], abs(n+queries[i] - v2));\n            ans[i] = min(ans[i], abs(n-queries[i] + v2));\n        }\n        return ans;\n    }\n};","author":"Michael Bao","submissionId":"1575127333"},[]]},{"867":[{"id":"867","fileName":"1575127296.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> m;\n        for(int i=0; i<nums.size(); ++i){\n            m[nums[i]].push_back(i);\n        }\n        \n        vector<int> res(queries.size(), INT_MAX);\n        for(int i=0; i<queries.size(); ++i){\n            int idx = queries[i];\n            int num = nums[idx];\n            // cout<<idx<<\" \"<<num<<\": \";\n            // for(auto j: m[num]){\n            //     cout<<j<<\" \";\n            // }cout<<endl;\n            \n            int found_idx = lower_bound(m[num].begin(), m[num].end(), idx) - m[num].begin();\n            cout<<found_idx<<endl;\n            if(found_idx+1<m[num].size()){\n                res[i] = min(res[i], abs(idx - m[num][found_idx + 1]));\n            }else{\n                int temp = nums.size() -1 -idx +1 +m[num][0];\n                res[i] = idx != m[num][0] ? min(res[i], temp) : res[i];\n            }\n            if(found_idx-1>=0){\n                res[i] = min(res[i], abs(idx - m[num][found_idx - 1]));\n            }else{\n                int temp = idx + 1 + (nums.size()-1) -m[num][m[num].size() - 1];\n                res[i] = idx != m[num][m[num].size() - 1] ? min(res[i], temp) : res[i];\n            }\n            if(res[i] == 0 || res[i] == INT_MAX){\n                res[i] = -1;\n            }\n        }\n        return res;\n    }\n};","author":"Madhav Jha","submissionId":"1575127296"},[]]},{"869":[{"id":"869","fileName":"1575127471.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        arr = nums+nums\n        n = len(arr)\n        val2index = {}\n        leftD = [float('inf')]*n\n        for i in range(n):\n            val = arr[i]\n            if val in val2index:\n                leftD[i] = i-val2index[val]\n            val2index[val] = i\n        \n        val2index = {}\n        rightD = [float('inf')]*n\n        for i in range(n-1,-1,-1):\n            val = arr[i]\n            if val in val2index:\n                rightD[i] = val2index[val]-i\n            val2index[val] = i\n\n        ans = []\n        for q in queries:\n            tmp = min(leftD[q],rightD[q],leftD[q+n//2],rightD[q+n//2])\n            if tmp == n//2:\n                ans.append(-1)\n            else:\n                ans.append(tmp)\n        return ans\n                ","author":"Wenhanfu Yang","submissionId":"1575127471"},[]]},{"870":[{"id":"870","fileName":"1575127475.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> temp = nums;\n        for (auto i : nums) {\n            temp.push_back(i);\n        }\n\n        map<int, vector<int>> mp;\n        for (int i = 0; i < temp.size(); i++) {\n            mp[temp[i]].push_back(i);\n        }\n\n        vector<int> mans;\n        for (auto i : queries) {\n            int ans1 = n, ans2 = n;\n            int no = temp[i];\n            auto it1 = upper_bound(mp[no].begin(), mp[no].end(), i);\n\n            if (*it1 - i < n) {\n                ans1 = min(ans1, *it1 - i);\n            }\n\n            auto it2 = lower_bound(mp[no].begin(), mp[no].end(), i + n);\n\n            if (it2 == mp[no].begin()) {\n\n            } else {\n                it2--;\n                if (i + n - *it2 < n) {\n                    ans2 = min(ans2, i + n - *it2);\n                }\n            }\n            if (min(ans1, ans2) == n) {\n                mans.push_back(-1);\n            } else\n                mans.push_back(min(ans1, ans2));\n        }\n        return mans;\n    }\n};","author":"ROHITAASX","submissionId":"1575127475"},[]]},{"871":[{"id":"871","fileName":"1575127444.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        num_map = defaultdict(list)\n        idx_map = {}\n\n        n = len(nums)\n        for i in range(n):\n            num_map[nums[i]].append(i)\n            idx_map[i] = len(num_map[nums[i]]) - 1\n            \n        ans = []\n        for q in queries:\n            query_num = nums[q]\n            query_list = num_map[query_num]\n            length = len(query_list)\n            if length == 1:\n                ans.append(-1)\n            else:\n                q_idx = idx_map[q]\n                before = 0\n                after = 0\n                if q_idx == 0:\n                    before = length - 1\n                    after = 1\n                elif q_idx == length - 1:\n                    before = length - 2\n                    after = 0\n                else:\n                    before = q_idx - 1\n                    after = q_idx + 1\n                #print(query_list[q_idx], query_list[before], query_list[after])\n\n                before_diff = query_list[q_idx] - query_list[before] if before < q_idx else query_list[q_idx] + n - query_list[before]\n                after_diff = query_list[after] - query_list[q_idx] if after > q_idx else query_list[after] + n - query_list[q_idx]\n                #print(before_diff, after_diff)\n                ans.append(min(before_diff, after_diff))\n        return ans\n                \n        ","author":"Jason Wang","submissionId":"1575127444"},[]]},{"872":[{"id":"872","fileName":"1575127511.txt","sourceCode":"import bisect as b\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        idx = defaultdict(list)\n        \n        for i, n in enumerate(nums):\n            idx[n].append(i)\n\n        ans = []\n        for j, q in enumerate(queries):\n            n = nums[q]\n            if len(idx[n]) == 1:\n                ans.append(-1)\n            else:\n                pos = b.bisect_left(idx[n], q)\n                #print(j, q, pos, idx[n])\n                if pos == 0:\n                    ans.append(min(idx[n][pos+1] - idx[n][pos], len(nums) - idx[n][-1]+idx[n][0]))\n                elif pos == (len(idx[n]) - 1):\n                    ans.append(min(idx[n][pos] - idx[n][pos-1], len(nums) - idx[n][pos] + idx[n][0]))\n                else:\n                    ans.append(min(idx[n][pos+1] - idx[n][pos], idx[n][pos] - idx[n][pos-1]))\n                    \n                \n        return ans\n            \n            \n            ","author":"AKA","submissionId":"1575127511"},[]]},{"875":[{"id":"875","fileName":"1575127592.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        presentAt = defaultdict(list)\n        for index,num in enumerate(nums):\n            presentAt[num].append(index)\n        res = []\n        #print(presentAt.items())\n        sizeOfNums = len(nums)\n        for query in queries:\n            \n            num = nums[query]\n            \n            sizeOfIndices = len(presentAt[num])\n            #print('query:',query,\"|\",num,presentAt[num])\n            if sizeOfIndices == 1:\n                #print(\"returning -1\")\n                res.append(-1)\n                continue\n            start,end = 0,sizeOfIndices-1\n            indexOfElement = 0\n            while start <= end:\n                mid = start + (end-start)//2\n                if presentAt[num][mid] > query:\n                    end = mid - 1\n                elif presentAt[num][mid] < query:\n                    start = mid + 1\n                else:\n                    indexOfElement = mid\n                    break\n            #print('found:',indexOfElement)\n            if indexOfElement == 0:\n                dis = min(\n                    presentAt[num][(indexOfElement+1) % sizeOfIndices] - presentAt[num][indexOfElement],\n                    presentAt[num][indexOfElement % sizeOfIndices] + sizeOfNums - presentAt[num][indexOfElement-1],\n                )\n            elif indexOfElement == sizeOfIndices-1:\n                dis = min(\n                    presentAt[num][(indexOfElement+1) % sizeOfIndices] + sizeOfNums - presentAt[num][indexOfElement],\n                    presentAt[num][indexOfElement % sizeOfIndices] - presentAt[num][indexOfElement-1],\n                )\n            else:\n                dis = min(\n                    presentAt[num][(indexOfElement+1) % sizeOfIndices] - presentAt[num][indexOfElement],\n                    presentAt[num][indexOfElement % sizeOfIndices] - presentAt[num][indexOfElement-1],\n                )\n            res.append(dis)\n        return res\n                ","author":"Spiderman","submissionId":"1575127592"},[]]},{"876":[{"id":"876","fileName":"1575127573.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, TreeSet<Integer>> map = new HashMap<>();\n\n        for(int i=0;i<nums.length;i++) {\n            map.putIfAbsent(nums[i], new TreeSet<>());\n            map.get(nums[i]).add(i);\n        }\n\n        List<Integer> fin = new ArrayList<>(queries.length);\n        \n        for(int query: queries) {\n            int item = nums[query];\n\n            TreeSet<Integer> set = map.get(item);\n            Integer next = set.ceiling(query+1);\n            Integer prev = set.floor(query-1);\n\n            if(next == null) {\n                next = set.ceiling(0);\n            }\n            if(prev == null) {\n                prev = set.floor(nums.length-1);\n            }\n\n            int result = -1;\n            if(next != null && next != query) {\n                if(next < query) {\n                    next += nums.length;\n                }\n                result = next - query;\n            }\n            if(prev != null && prev != query) {\n                if(prev > query) {\n                    prev -= nums.length;\n                }\n                result = Math.min(result, query - prev);\n            }\n\n            fin.add(result);\n        }\n\n        return fin;\n    }\n}","author":"Rakshit Gundi Lakshminarayan","submissionId":"1575127573"},[]]},{"877":[{"id":"877","fileName":"1575127453.txt","sourceCode":"class Solution {\npublic:\n    int dist(int i, int j, int n) {\n        if (i > j) return dist(j, i, n);\n        int a = j - i;\n        int b = i + n - j;\n        // cout << \"for i=\" << i << \", j=\" << j << \", \" << n << \" -> \" << a << \" & \" << b << endl;\n        return min(a, b);\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> data;\n        for (int i=0; i<nums.size(); ++i) {\n            if (data.find(nums[i]) == data.end())\n                data[nums[i]] = {};\n            data[nums[i]].push_back(i);\n        }\n        // for (auto& [k, v]: data) {\n        //     cout << k << \": \";\n        //     for (int num: v)\n        //         cout << num << \", \";\n        //     cout << endl;\n        // }\n        vector<int> ans;\n        for (int q: queries) {\n            int val = nums[q];\n            auto& vec = data[val];\n            if (vec.size() == 1) {\n                ans.push_back(-1);\n            } else {\n                int idx = lower_bound(vec.begin(), vec.end(), q) - vec.begin();\n                int pIdx = (idx == 0) ? vec.size()-1 : idx - 1;\n                int nIdx = (idx == vec.size()-1) ? 0 : idx + 1;\n                ans.push_back(min(dist(vec[pIdx], vec[idx], nums.size()), dist(vec[nIdx], vec[idx], nums.size())));\n            }\n        }\n        return ans;\n    }\n};","author":"thatdns","submissionId":"1575127453"},[]]},{"878":[{"id":"878","fileName":"1575127714.txt","sourceCode":"import java.util.*;\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        int ans[] = new int[n];\n        for(int i=0;i<n;i++){\n            ans[i] = -1;\n        }\n\n        Hashtable<Integer,Integer> ht = new Hashtable<Integer,Integer>();\n        Hashtable<Integer,Integer> fst = new Hashtable<Integer,Integer>();\n        for(int i=0;i<n;i++){\n            if(ht.containsKey(nums[i])){\n                int last = ht.get(nums[i]);\n                int diff = i-last;\n                diff = Math.min(diff, n-diff);\n                ans[i] = diff;\n                if(ans[last] == -1){\n                    ans[last] = diff; \n                }\n                else{\n                    ans[last] = Math.min(ans[last], diff);    \n                }\n                \n                if(last!=fst.get(nums[i])){\n                     last = fst.get(nums[i]);\n                     diff = i-last;\n                    diff = Math.min(diff, n-diff); \n                    \n                    if(ans[i] == -1){\n                        ans[i] = diff; \n                    }\n                    else{\n                        ans[i] = Math.min(ans[i], diff);    \n                    }\n                    \n                    if(ans[last] == -1){\n                        ans[last] = diff; \n                    }\n                    else{\n                        ans[last] = Math.min(ans[last], diff);    \n                    }\n                }\n                ht.put(nums[i],i);\n            }\n            else{\n                ht.put(nums[i],i);\n                fst.put(nums[i],i);\n            }\n        }\n        List<Integer> ans2 = new ArrayList<Integer>();\n        for(int i=0;i<queries.length;i++){\n            ans2.add(ans[queries[i]]);\n        }\n        return ans2;\n    }\n}","author":"anmol dogra","submissionId":"1575127714"},[]]},{"879":[{"id":"879","fileName":"1575127651.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        m = defaultdict(lambda: -1)\n        mp = defaultdict(lambda: inf)\n        m_f = defaultdict(lambda: -1)\n        n = len(nums)\n        for i, num in enumerate(nums):\n            if m[num] > -1:\n                mp[m[num]] = min(mp[m[num]], i - m[num])\n                mp[i] = min(i - m[num], (m_f[num] - i + n) % n)\n            m[num] = i\n            if m_f[num] == -1:\n                m_f[num] = i\n        \n        for num in m_f:\n            if m_f[num] != m[num]:\n                mp[m_f[num]] = min(mp[m_f[num]], (m_f[num] - m[num] + n) % n)\n        \n        res = []\n        for q in queries:\n            if mp[q] == inf:\n                res.append(-1)\n            else:\n                res.append(mp[q])\n        return res","author":"kwrefs","submissionId":"1575127651"},[]]},{"880":[{"id":"880","fileName":"1575127697.txt","sourceCode":"import bisect\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        index_dict = dict()\n        for i in range(len(nums)):\n            num = nums[i]\n            if num not in index_dict:\n                index_dict[num] = [i]\n            else:\n                index_dict[num].append(i)\n\n\n        # print(index_dict)\n        answer = []\n        for query in queries:\n            num = nums[query]\n            if len(index_dict[num]) == 1:\n                answer.append(-1)\n            else:\n                location = bisect.bisect_left(index_dict[num], query)\n                if location == 0:\n                    answer.append(min(index_dict[num][1] - index_dict[num][0], len(nums) - index_dict[num][-1] + index_dict[num][0]))\n                elif location == len(index_dict[num]) - 1:\n                    answer.append(min(len(nums) - index_dict[num][location] + index_dict[num][0], index_dict[num][location] - index_dict[num][location - 1]))\n                else:\n                    answer.append(min(index_dict[num][location + 1] - index_dict[num][location], index_dict[num][location] - index_dict[num][location - 1]))\n            \n        return answer \n                ","author":"KidusTegene","submissionId":"1575127697"},[]]},{"881":[{"id":"881","fileName":"1575127647.txt","sourceCode":"from collections import defaultdict\nimport bisect\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        def circCalc(a, b):\n            smallNum = min(a,b)\n            bigNum = max(a,b)\n            return min((bigNum - smallNum), smallNum + len(nums) - bigNum)\n        \n        numsMap = defaultdict(list)\n        for i,num in enumerate(nums):\n            numsMap[num].append(i)\n            \n        ans = []\n        for query in queries:\n            queryNum = nums[query]\n            if len(numsMap[queryNum]) == 1:\n                ans.append(-1)\n            elif len(numsMap[queryNum]) == 2:\n                ans.append(circCalc(numsMap[queryNum][0],numsMap[queryNum][1]))\n            else:\n                index = bisect.bisect_left(numsMap[queryNum], query)\n                ans.append(min(circCalc(numsMap[queryNum][index], numsMap[queryNum][index-1]), circCalc(numsMap[queryNum][index], numsMap[queryNum][(index+1) % len(numsMap[queryNum])])))\n        return ans","author":"lijustin111","submissionId":"1575127647"},[]]},{"882":[{"id":"882","fileName":"1575127806.txt","sourceCode":"from collections import defaultdict\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        places = defaultdict(list)\n        for i, x in enumerate(nums):\n            places[x].append(i)\n\n        ans = []\n\n        def bsearch(v, positions):\n            l = 0\n            h = len(positions) - 1\n            while l < h:\n                m = (l + h) // 2\n                if positions[m] == v:\n                    return m\n                elif positions[m] < v:\n                    l = m + 1\n                else:\n                    h = m\n            return l\n\n        # print(places)\n        for q in queries:\n            v = nums[q]\n            positions = places[v]\n            # print(positions)\n            if len(positions) <= 1:\n                ans.append(-1)\n                continue\n            # binary search for position\n            p = bsearch(q, positions)\n            # print(v, p)\n            \n            if p == 0:\n                down = positions[p] + len(nums) - positions[-1]\n            else:\n                down = positions[p] - positions[p-1]\n\n            if p == len(positions) - 1:\n                up = positions[0] + len(nums) - positions[-1]\n            else:\n                up = positions[p+1] - positions[p]\n            # print(v, up, down)\n            ans.append(min(up, down))\n\n        return ans","author":"user7719id","submissionId":"1575127806"},[]]},{"883":[{"id":"883","fileName":"1575127763.txt","sourceCode":"from sortedcontainers import SortedList\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        def ahh(i,f):\n            return min((f - i)%len(nums),abs(i - f),(i - f)%len(nums))\n        n = len(nums)\n        # nums  = nums + nums\n        d = defaultdict(lambda : SortedList())\n        for i,x in enumerate(nums):\n            d[x].add(i)\n        ret = []\n        for q in queries:\n            j = d[nums[q]].bisect_left(q)\n            ans = inf\n            if j-1>=0:\n                ans = min(ans,abs(q - d[nums[q]][j - 1]))\n            if j+ 1 < len(d[nums[q]]):\n                ans = min(ans,abs(q - d[nums[q]][j + 1]))\n            if len(d[nums[q]])!=1:\n                if q!=d[nums[q]][0]:\n                    ans = min(ans,ahh(q,d[nums[q]][0]))\n                if q!=d[nums[q]][-1]:\n                    ans = min(ans,ahh(q,d[nums[q]][-1]))\n            if ans==inf:\n                ret.append(-1)\n            else:\n                ret.append(ans)\n        return ret","author":"Sasank Nasika","submissionId":"1575127763"},[]]},{"884":[{"id":"884","fileName":"1575127816.txt","sourceCode":"class Solution {\npublic:\n    #define ll long long int\n    \n    ll min(ll a, ll b)\n    {\n        if(a > b) return b;\n        else return a;\n    }\n    \n    int find(vector<int> &A, int ind, int n)\n    {\n        int d = lower_bound(A.begin(), A.end(), ind) - A.begin();\n        \n        if(A.size() == 1) return -1;\n        \n        ll ans = 1e7;\n        if(d+1 < A.size()) {\n            ans = min(ans, A[d+1] - A[d]);\n            ans = min(ans, n - (A[d+1]) + A[d]);\n        }\n        \n        if(d-1 >= 0) {\n            ans = min(ans, A[d] - A[d-1]);\n            ans = min(ans, n - (A[d]) + A[d-1]);\n        }\n        \n        ans = min(ans, n - (A[d]) + A[0]);\n        ans = min(ans, n - A.back() + A[d]);\n        \n        return ans;\n    }\n    \n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int> > m;\n        \n        for(int i=0; i<nums.size(); i++) {\n            m[nums[i]].push_back(i);\n        }\n        \n        vector<int> ans;\n        \n        for(auto &it : queries) {\n            ans.push_back(find(m[nums[it]], it, nums.size()));\n        }\n        \n        return ans;\n    }\n};","author":"Harshit Bansal","submissionId":"1575127816"},[]]},{"885":[{"id":"885","fileName":"1575127779.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int a = nums.size();\n        unordered_map<int, vector<int>> b;\n        \n        for (int c = 0; c < a; c++) {\n            b[nums[c]].push_back(c);\n        }\n        \n        vector<int> d(queries.size());\n        \n        for (int e = 0; e < queries.size(); e++) {\n            int f = queries[e];\n            int g = nums[f];\n            \n            if (b[g].size() == 1) {\n                d[e] = -1;\n                continue;\n            }\n            \n            int h = a;\n            vector<int>& store = b[g];\n            \n            auto it = lower_bound(store.begin(), store.end(), f);\n            int pos = it - store.begin();\n            \n            if (pos < store.size() && store[pos] != f) {\n                int j = (store[pos] - f + a) % a;\n                int k = (f - store[pos] + a) % a;\n                h = min(h, min(j, k));\n            } else if (pos < store.size() && store[pos] == f) {\n                if (pos + 1 < store.size()) {\n                    int j = (store[pos + 1] - f + a) % a;\n                    int k = (f - store[pos + 1] + a) % a;\n                    h = min(h, min(j, k));\n                }\n                if (pos > 0) {\n                    int j = (store[pos - 1] - f + a) % a;\n                    int k = (f - store[pos - 1] + a) % a;\n                    h = min(h, min(j, k));\n                }\n                if (store.size() > 1) {\n                    if (pos == 0) {\n                        int j = (store.back() - f + a) % a;\n                        int k = (f - store.back() + a) % a;\n                        h = min(h, min(j, k));\n                    } else if (pos == store.size() - 1) {\n                        int j = (store[0] - f + a) % a;\n                        int k = (f - store[0] + a) % a;\n                        h = min(h, min(j, k));\n                    }\n                }\n            } else if (pos > 0) {\n                int j = (store[pos - 1] - f + a) % a;\n                int k = (f - store[pos - 1] + a) % a;\n                h = min(h, min(j, k));\n            }\n            \n            d[e] = h;\n        }\n        \n        return d;\n    }\n};","author":"Chausa Mausa","submissionId":"1575127779"},[]]},{"886":[{"id":"886","fileName":"1575128017.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        if (nums == null || nums.length == 0 || queries == null || queries.length == 0) {\n            return new ArrayList<Integer>();\n        }\n\n        // {value -> [indexes in the position lists]}\n        Map<Integer, List<Integer>> valuePositionMap = new HashMap<Integer, List<Integer>>();\n\n        // {indexes in nums -> indexes in position lists}\n        Map<Integer, Integer> indexMap = new HashMap<Integer, Integer>();\n        for (int i = 0; i < nums.length; i++) {\n            if (!valuePositionMap.containsKey(nums[i])) {\n                valuePositionMap.put(nums[i], new ArrayList<Integer>());\n            }\n            valuePositionMap.get(nums[i]).add(i);\n            indexMap.put(i, valuePositionMap.get(nums[i]).size() - 1);\n        }\n\n        List<Integer> result = new ArrayList<Integer>();\n        for (int query : queries) {\n            int n = nums[query];\n            List<Integer> positions = valuePositionMap.get(n);\n            int index = indexMap.get(query);\n            if (positions.size() == 1) {\n                result.add(-1);\n            } else {\n                int leftDistance = (index == 0 ? (query + nums.length - positions.get(positions.size() - 1)) : (positions.get(index) - positions.get(index - 1)));\n                int rightDistance = (index == (positions.size() - 1) ? (nums.length - query + positions.get(0)) : (positions.get(index + 1) - positions.get(index)));\n                result.add(Math.min(leftDistance, rightDistance));\n            }\n        }\n        return result;\n    }\n}","author":"leetcode_2019","submissionId":"1575128017"},[]]},{"888":[{"id":"888","fileName":"1575127939.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& que) {\n        map<int, vector<int>> mp;\n        int n = nums.size();\n        for (int i = 0; i < n; i++)\n            mp[nums[i]].push_back(i);\n        vector<int> ans;\n        function<int(int)> fxn = [&](int ind) {\n            int cur = nums[ind];\n            if (mp[cur].size() == 1)\n                return -1;\n\n            vector<int>& positions = mp[cur];\n            int pos = lower_bound(positions.begin(), positions.end(), ind) -\n                      positions.begin();\n            int diff = INT_MAX;\n\n            if (pos < positions.size() - 1)\n                diff = min(diff, positions[pos + 1] - ind);\n            if (pos > 0)\n                diff = min(diff, ind - positions[pos - 1]);\n\n            int first = positions[0], last = positions.back();\n            diff = min(diff, n - abs(last - ind));\n            diff = min(diff, n - abs(first - ind));\n\n            return diff;\n        };\n        for (auto it : que) {\n            ans.push_back(fxn(it));\n        }\n        return ans;\n    }\n};","author":"Romit Sovakar","submissionId":"1575127939"},[]]},{"889":[{"id":"889","fileName":"1575128115.txt","sourceCode":"from collections import defaultdict\nfrom bisect import bisect_left\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        index = defaultdict(list)\n        for i, num in enumerate(nums):\n            index[num].append(i)\n\n        res = []\n        for q in queries:\n            num = nums[q]\n            if len(index[num]) == 1:\n                res.append(-1)\n            else:\n                arr = index[num]\n                idx = bisect_left(arr, q)\n                if idx == 0:\n                    res.append(min(arr[1] - arr[0], n + arr[0] - arr[-1]))\n                elif idx == len(arr)-1:\n                    res.append(min(arr[-1] - arr[-2], n + arr[0] - arr[-1]))\n                else:\n                    res.append(min(arr[idx] - arr[idx-1], arr[idx+1] - arr[idx]))\n\n        return res\n                ","author":"Mafish","submissionId":"1575128115"},[]]},{"890":[{"id":"890","fileName":"1575128024.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        vector<int>temp(n+n,-1);\n        unordered_map<int,int>mp,mpp,mppp,first,last;\n        for(int i=0;i<n;i++){\n            if(first.count(nums[i])==0) first[nums[i]]=i;\n            last[nums[i]]=i;\n            mppp[nums[i]]++;\n            nums.push_back(nums[i]);\n        }\n        for(int i=0;i<nums.size();i++){\n            if(mp.count(nums[i])){\n                temp[mp[nums[i]]]=i-mp[nums[i]];\n                if(mpp.count(nums[i])){\n                    temp[mp[nums[i]]]=min(mpp[nums[i]],i-mp[nums[i]]);\n                }\n                mpp[nums[i]]=i-mp[nums[i]];\n            }\n            mp[nums[i]]=i;\n        }\n        for(int i=0;i<n;i++){\n            if(i==first[nums[i]])\n            temp[i]=min(temp[i],n-last[nums[i]]+first[nums[i]]);\n        }\n        vector<int>ans;\n        for(auto x:queries){\n            if(mppp[nums[x]]<2){\n                ans.push_back(-1);\n                continue;\n            }\n            ans.push_back(temp[x]);\n        }\n        return ans;\n    }\n};","author":"josbuttlerr","submissionId":"1575128024"},[]]},{"891":[{"id":"891","fileName":"1575128112.txt","sourceCode":"class Solution {\npublic:\n\n\n    int Bi1 (int x, vector<int> &vt){\n        int l = 0, r = vt.size() - 1;\n        while(r > l + 1){\n            int mid = (l + r)/2;\n            if(vt[mid] > x) r = mid;\n            else l = mid;\n        }\n        if(vt[l] > x) return vt[l];\n        else if(vt[r] > x) return vt[r];\n        return -1;\n    }\n\n    int Bi2 (int x, vector<int> &vt){\n        int l = 0, r = vt.size() - 1;\n        while(r > l + 1){\n            int mid = (l + r)/2;\n            if(vt[mid] < x) l = mid;\n            else r = mid;\n        }\n        if(vt[r] < x) return vt[r];\n        else if(vt[l] < x) return vt[l];\n        return -1;\n    }\n\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> mp;\n        for(int i = 0; i < nums.size(); i++){\n            mp[nums[i]].push_back(i);\n        }\n        int n = nums.size();\n        vector<int> ans(queries.size(), 1e9);\n        for(int i = 0; i < queries.size(); i++){\n            int x = nums[queries[i]];\n            if(mp[x].size() == 1) ans[i] = -1;\n            else{\n                int a = queries[i], b = Bi1(queries[i], mp[x]), c = Bi2(queries[i], mp[x]);\n                if(b != -1) ans[i] = min({abs(b - a), ans[i], n - abs(b - a)});\n                if(c != -1) ans[i] = min({abs(c - a), ans[i], n - abs(c - a)});\n                if(mp[x].back() != a) ans[i] = min(ans[i], n - abs(mp[x].back() - a));\n                if(mp[x][0] != a) ans[i] = min(ans[i], n - abs(mp[x][0] - a));\n            }\n        }\n        return ans;\n    }\n};","author":"Do Van Tuan","submissionId":"1575128112"},[]]},{"893":[{"id":"893","fileName":"1575128201.txt","sourceCode":"class Solution {\npublic:\n\n    int getInd(int ele, int ind, map<int,vector<int>> &mp){\n        int low = 0, high = mp[ele].size()-1;\n        int mid;\n        while(low <= high){\n            mid = (low + high) / 2;\n            if(mp[ele][mid] > ind) high = mid-1;\n            else if(mp[ele][mid] < ind) low = mid+1;\n            else return mid;\n        }\n        return -1;\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n\n        int n = nums.size();\n        \n        map<int,vector<int>> mp;\n        for(int i = 0; i < nums.size(); i++) mp[nums[i]].push_back(i);\n\n        vector<int> ans;\n        for(int i = 0; i < queries.size(); i++){\n            int ind = queries[i];\n            int ele = nums[ind];\n            if(mp[ele].size() == 1){\n                ans.push_back(-1);\n                continue;\n            }\n            int dist = INT_MAX;\n            int eleInd = getInd(ele,ind,mp);\n            if(eleInd+1 < mp[ele].size()){\n                int nextInd = mp[ele][eleInd+1];\n                dist = min(dist,abs(ind-nextInd));\n                dist = min(dist,n-abs(ind-nextInd));\n            }\n            else{\n                int nextInd = mp[ele][0];\n                dist = min(dist,abs(ind-nextInd));\n                dist = min(dist,n-abs(ind-nextInd));\n            }\n            if(eleInd-1 >= 0){\n                int prevInd = mp[ele][eleInd-1];\n                dist = min(dist,abs(ind-prevInd));\n                dist = min(dist,n-abs(ind-prevInd));\n            }\n            else{\n                int prevInd = mp[ele][mp[ele].size()-1];\n                dist = min(dist,abs(ind-prevInd));\n                dist = min(dist,n-abs(ind-prevInd));\n            }\n            ans.push_back(dist);\n        }\n        return ans;\n    }\n};","author":"Ishan","submissionId":"1575128201"},[]]},{"895":[{"id":"895","fileName":"1575128198.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length, m = queries.length;\n        List<Integer> ret = new ArrayList<>();\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        for (int i = 0; i < m; i++) {\n            int v = nums[queries[i]];\n            List<Integer> indices = map.get(v);\n            int lo = 0, hi = indices.size() - 1, t = -1;\n            while (lo <= hi) {\n                int mid = lo + (hi - lo) / 2;\n                if (indices.get(mid) == queries[i]) {\n                    t = mid;\n                    break;\n                } else if (indices.get(mid) > queries[i]) {\n                    hi = mid - 1;\n                } else {\n                    lo = mid + 1;\n                }\n            }\n            // System.out.println(t);\n            if (indices.size() > 1) {\n                if (t == 0) {\n                    ret.add(Math.min(indices.get(t + 1) - queries[i], queries[i] - (indices.get(indices.size() - 1) - n)));\n                } else if (t == indices.size() - 1) {\n                    ret.add(Math.min(queries[i] - indices.get(t - 1), indices.get(0) + n - queries[i]));\n                } else {\n                    ret.add(Math.min(queries[i] - indices.get(t - 1), indices.get(t + 1) - queries[i]));\n                }\n            } else {\n                ret.add(-1);\n            }\n        }\n        return ret;\n    }\n}","author":"YMF","submissionId":"1575128198"},[]]},{"896":[{"id":"896","fileName":"1575128142.txt","sourceCode":"class Solution {\npublic:\n\n    static int min_distance(int n, const set<int>& values, int index) {\n        const auto it = values.find(index);\n        auto next_it = next(it);\n        int distance = INT_MAX;\n        if (next_it == cend(values)) {\n            distance = min(distance, *cbegin(values) + n - index);\n        }\n        else {\n            distance = min(distance, *next_it - index);\n        }\n        if (it == cbegin(values)) {\n            auto prev_it = prev(cend(values));\n            distance = min(distance, index + n - *prev_it);\n        }\n        else {\n            auto prev_it = prev(it);\n            distance = min(distance, index - *prev_it);\n        }\n        return distance;\n    }\n\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        const auto n = size(nums);\n        map<int, set<int>> index_map;\n        for (int i = 0; i < n; i++) {\n            index_map[nums[i]].insert(i);\n        }\n        vector<int> ans(size(queries),-1);\n        for (int i = 0; i < size(queries); i++) {\n            const auto query = queries[i];\n            const auto num = nums[query % n];\n            if (size(index_map[num]) > 1) {\n                ans[i] = min_distance(n, index_map[num], query);\n            }\n        }\n        return ans;\n    }\n};","author":"sakaoka","submissionId":"1575128142"},[]]},{"897":[{"id":"897","fileName":"1575128202.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n=nums.length;\n        int max=0;\n        for(int e:nums){\n            max=Math.max(e,max);\n        }\n        \n        int freq[]=new int[max+1];\n        // store last occur\n        for(int i=0;i<n;i++){\n            freq[nums[i]]=i;\n        }\n        int mat[][]=new int[n][2];\n        for(int m[]:mat){\n            Arrays.fill(m,Integer.MAX_VALUE);\n        }\n        \n        for(int i=0;i<n;i++){\n            if(i!=freq[nums[i]]&&freq[nums[i]]!=Integer.MAX_VALUE){\n                mat[i][0]=i+(n-freq[nums[i]]);//left dist\n                freq[nums[i]]=Integer.MAX_VALUE;\n            }\n        }\n\n        // FIRST OCCUR\n        for(int i=n-1;i>=0;i--){\n            freq[nums[i]]=i;\n        }\n\n        for(int i=n-1;i>=0;i--){\n            if(i!=freq[nums[i]]&&freq[nums[i]]!=Integer.MAX_VALUE){\n                mat[i][1]=freq[nums[i]]+(n-i);\n                freq[nums[i]]=Integer.MAX_VALUE;\n            }\n        }\n\n        Arrays.fill(freq,Integer.MAX_VALUE);\n        for(int i=0;i<n;i++){\n            if(mat[i][0]!=Integer.MAX_VALUE)\n            {\n                freq[nums[i]]=i;\n                continue;\n            }\n\n            if(freq[nums[i]]!=Integer.MAX_VALUE){\n                mat[i][0]=i-freq[nums[i]];\n            }\n            freq[nums[i]]=i;\n        }\n        Arrays.fill(freq,Integer.MAX_VALUE);\n        for(int i=n-1;i>=0;i--){\n            if(mat[i][1]!=Integer.MAX_VALUE)\n            {\n                freq[nums[i]]=i;\n                continue;\n            }\n\n            if(freq[nums[i]]!=Integer.MAX_VALUE){\n                mat[i][1]=freq[nums[i]]-i;\n            }\n            freq[nums[i]]=i;\n        }\n        // for(int i=0;i<n;i++){\n        //     System.out.println(\"e=\"+nums[i]+\" left=\"+mat[i][0]+\" right=\"+mat[i][1]);\n        // }\n        List<Integer> list=new ArrayList<>();\n        for(int e:queries){\n            if(mat[e][0]==Integer.MAX_VALUE&&mat[e][1]==Integer.MAX_VALUE){\n                list.add(-1);\n            }\n            else{\n                list.add(Math.min(mat[e][0],mat[e][1]));\n            }\n        }\n        return list;\n        \n    }\n}","author":"hacker","submissionId":"1575128202"},[]]},{"900":[{"id":"900","fileName":"1575128222.txt","sourceCode":"public class Solution {\n    public IList<int> SolveQueries(int[] nums, int[] queries) {\n        int n = nums.Length;\n        \n        Dictionary<int, int[]> dic = nums\n            .Select((n, i) => (n, i))\n            .GroupBy(ni => ni.n)\n            .ToDictionary(g => g.Key, g => g.Select(ni => ni.i).ToArray());\n\n        List<int> results = new List<int>(queries.Length);\n\n        foreach (int query in queries) {\n            int num = nums[query];\n            int[] indexes = dic[num];\n            if (indexes.Length == 1) {\n                results.Add(-1);\n            } else {\n                int i = Array.BinarySearch(indexes, query);\n\n                int min = int.MaxValue;\n                \n                if (i == 0) {\n                    min = indexes[0] + n - indexes[indexes.Length - 1];\n                } else {\n                    min = indexes[i] - indexes[i - 1];\n                }\n\n                if (i == indexes.Length - 1) {\n                    min = Math.Min(min, indexes[0] + n - indexes[indexes.Length - 1]);\n                } else {\n                    min = Math.Min(min, indexes[i + 1] - indexes[i]);\n                }\n\n                results.Add(min);\n            }\n        }\n\n        return results;\n    }\n}","author":"lauel24","submissionId":"1575128222"},[]]},{"901":[{"id":"901","fileName":"1575128232.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        unordered_map<int, vector<int>> mp;\n        int n = nums.size();\n        for(int i=0; i<n; i++){\n            mp[nums[i]].push_back(i);\n        }\n        \n        vector<int> res;\n        for(int i=0; i<q.size(); i++){\n            int indx = q[i];\n            int num = nums[indx];\n            if(mp[num].size() == 1){\n                res.push_back(-1);\n                continue;\n            }\n            vector<int> &curr = mp[num];\n            int idx = lower_bound(curr.begin(), curr.end(), indx) - curr.begin();\n            \n            int prev = (idx == 0) ? curr.back() : curr[idx - 1];\n            int next = (idx == curr.size() - 1) ? curr[0] : curr[idx + 1];\n            \n            cout << prev << \"  \" << next << endl;\n\n            int distPrev = (indx - prev + n) % n;\n            int distNext = (next - indx + n) % n;\n            \n            // cout << distPrev << \"  \" << distNext << endl;\n\n            res.push_back(distPrev <= distNext ? distPrev : distNext);\n            \n        }\n        return res;\n    }\n};","author":"Mohit_is_back","submissionId":"1575128232"},[]]},{"903":[{"id":"903","fileName":"1575128277.txt","sourceCode":"\nclass Solution {\n    public:\n        int binary_search(auto& arr, int l, int r, int t) {\n          while (l <= r) {\n            int m = l + (r - l) / 2;\n            if (arr[m] == t) {\n              return m;\n            } else if (arr[m] > t) {\n              r = m - 1;\n            } else {\n              l = m + 1;\n            }\n          }\n          return -1;\n        }\n        vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n            int n = nums.size();\n            map<int,vector<int>> buckets;\n            for (int i = 0; i < nums.size(); i++) {\n                buckets[nums[i]].push_back(i);\n            }\n            int m = queries.size();\n            vector<int> ans(m, -1);\n            for (int i = 0; i < m; i++) {\n              int q = queries[i];\n              int val = nums[queries[i]];\n              if (buckets.find(val) == buckets.end()) continue;\n              auto& arr = buckets[val];\n              int k = arr.size();\n              if (arr.size() <= 1) continue;\n              int idx = binary_search(arr, 0, arr.size() - 1, queries[i]);\n              int right_idx = arr[(idx + 1) % k];\n              int left_idx = arr[(idx + k - 1) % k];\n              if (right_idx < queries[i]) { right_idx += n; }\n              if (left_idx > queries[i]) {left_idx -= n; }\n              ans[i] = min(queries[i] - left_idx, right_idx - queries[i]);\n            }\n            return ans;\n        }\n};","author":"Ishan Srivastava","submissionId":"1575128277"},[]]},{"905":[{"id":"905","fileName":"1575128288.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> ans;\n        \n        int n = nums.size();\n        \n        map<int, vector<int>> mp;\n        \n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        \n        for(int q:queries){\n            int val = nums[q];\n            if(mp[val].size() ==1){\n                ans.push_back(-1);\n                continue;\n            }\n            int m = mp[val].size();\n            int ind = lower_bound(mp[val].begin(), mp[val].end(), q) - mp[val].begin();\n            int prev = (ind - 1 + m) %m;\n            int next = (ind + 1 + m) %m;\n            int temp = n+1;\n            if(mp[val][prev] != q){\n                temp = abs(mp[val][prev] - q);\n                temp = min(temp, n-temp);\n            }\n            int temp1 = n+1;\n            if(mp[val][next] != q) {\n                temp1 = abs(mp[val][next] - q);\n                temp1 = min(temp1, n-temp1);\n            }\n            ans.push_back(min(temp1, temp));\n        }\n        return ans;\n    }\n};","author":"QT3DbyBL5R","submissionId":"1575128288"},[]]},{"907":[{"id":"907","fileName":"1575128366.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>>mp;\n        for(int i = 0; i < nums.size(); ++i)\n        {\n            mp[nums[i]].push_back(i);\n        }\n        vector<int>res;\n        for(int i = 0; i < queries.size(); ++i)\n        {\n            int q_idx = queries[i];\n            vector<int>* m_ptr = &mp[nums[q_idx]];\n            if((*m_ptr).size() == 1)  //no closet equal element\n            {\n                res.push_back(-1);\n                continue;\n            }\n            int l = 0, r = (*m_ptr).size()-1, m = -1;\n            while(l < r)\n            {\n                m = l + ((r-l) >> 1);\n                if((*m_ptr)[m] >= q_idx)\n                    r = m;\n                else\n                    l = m+1;\n            }            \n            int leftIdx = l > 0 ? (*m_ptr)[l-1] : (*m_ptr).back();\n            int rightIdx = l < (*m_ptr).size()-1 ? (*m_ptr)[l+1] : (*m_ptr).front();\n            int leftDist = min((q_idx - leftIdx + nums.size()) % nums.size(), (leftIdx - q_idx + nums.size()) % nums.size());\n            int rightDist = min((q_idx - rightIdx + nums.size()) % nums.size(), (rightIdx - q_idx + nums.size()) % nums.size());\n            res.push_back(min(leftDist, rightDist));\n        }\n        return res;\n    }\n};","author":"lai_cheng","submissionId":"1575128366"},[]]},{"908":[{"id":"908","fileName":"1575128472.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        idx = defaultdict(list)\n        k = len(nums)\n        for i, x in enumerate(nums):\n            idx[x].append(i)\n            \n        n = len(queries)\n        ans = [-1] * n\n        # print(ans)\n        for q, i in enumerate(queries):\n            x = nums[i]\n            if len(idx[x]) == 1:\n                continue\n            j = bisect_left(idx[x], i)\n            # print(idx, i, x, j)\n            if j - 1 >= 0 and j + 1 < len(idx[x]):\n                ans[q] = min(idx[x][j] - idx[x][j - 1], idx[x][j + 1] - idx[x][j])\n            elif j - 1 < 0:\n                ans[q] = min(idx[x][j + 1] - idx[x][j], idx[x][-1] - idx[x][j], idx[x][j] + k - idx[x][-1])\n            elif j + 1 >= len(idx[x]):\n                # print(idx[x][j], idx[x][0], idx[x][j - 1], i)\n                ans[q] = min(idx[x][j] - idx[x][j - 1], idx[x][j] - idx[x][0], idx[x][0] + k - idx[x][j])\n        \n        return ans\n                ","author":"txycodelc","submissionId":"1575128472"},[]]},{"909":[{"id":"909","fileName":"1575128372.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer>list=new ArrayList<>();\n        HashMap<Integer,List<Integer>>map=new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            if(!map.containsKey(nums[i]))map.put(nums[i],new ArrayList<>());\n            map.get(nums[i]).add(i);\n        }\n        for(int i:queries){\n            list.add(find(map.get(nums[i]),i,nums.length));\n        }\n        return list;\n    }\n    public int find(List<Integer>list,int i,int n){\n        if(list.size()==1)return -1;\n        int pos=-1;\n        int st=0;\n        int end=list.size()-1;\n        while(st<=end){\n            int mid=st+(end-st)/2;\n            if(list.get(mid)==i){\n                pos=mid;\n                break;\n            }\n            else if(list.get(mid)>i){\n                end=mid-1;\n            }\n            else st=mid+1;\n        }\n        \n        int m=list.size();\n        int min=Integer.MAX_VALUE;\n        if(pos-1>=0){\n            min=Math.min(min,Math.abs(list.get(pos)-list.get(pos-1)));\n        }\n        else {\n            \n            min=Math.min(min,Math.abs(list.get(0)+n-list.get(m-1)));\n            // System.out.println(min+\" \"+pos);\n        }\n        if(pos+1<m){\n            min=Math.min(min,Math.abs(list.get(pos)-list.get(pos+1)));\n            \n        }\n        else{\n            min=Math.min(min,Math.abs(n-list.get(pos)+list.get(0)));\n        }\n        return min;\n    }\n}","author":"VISHNU VARDHAN","submissionId":"1575128372"},[]]},{"910":[{"id":"910","fileName":"1575128445.txt","sourceCode":"public class Solution {\n    public IList<int> SolveQueries(int[] nums, int[] queries) {\n        int n = nums.Length;\n        int[] answer = new int[queries.Length];\n        \n        Dictionary<int, List<int>> valueToIndices = new Dictionary<int, List<int>>();\n        \n        for (int i = 0; i < n; i++) {\n            if (!valueToIndices.ContainsKey(nums[i])) {\n                valueToIndices[nums[i]] = new List<int>();\n            }\n            valueToIndices[nums[i]].Add(i);\n        }\n        \n        foreach (var key in valueToIndices.Keys) {\n            valueToIndices[key].Sort();\n        }\n        \n        for (int i = 0; i < queries.Length; i++) {\n            int queryIndex = queries[i];\n            int value = nums[queryIndex];\n            \n            if (valueToIndices[value].Count == 1) {\n                answer[i] = -1;\n                continue;\n            }\n            \n            List<int> indices = valueToIndices[value];\n            int minDistance = n;\n            \n            int pos = BinarySearch(indices, queryIndex);\n            \n            if (indices[pos] != queryIndex) {\n                int dist = MinCircularDistance(indices[pos], queryIndex, n);\n                minDistance = Math.Min(minDistance, dist);\n            }\n            \n            if (pos > 0 && indices[pos - 1] != queryIndex) {\n                int dist = MinCircularDistance(indices[pos - 1], queryIndex, n);\n                minDistance = Math.Min(minDistance, dist);\n            }\n            \n            if (pos < indices.Count - 1 && indices[pos + 1] != queryIndex) {\n                int dist = MinCircularDistance(indices[pos + 1], queryIndex, n);\n                minDistance = Math.Min(minDistance, dist);\n            }\n            \n            if (indices[pos] == queryIndex) {\n                int prev = (pos - 1 + indices.Count) % indices.Count;\n                int next = (pos + 1) % indices.Count;\n                \n                int distPrev = MinCircularDistance(indices[prev], queryIndex, n);\n                int distNext = MinCircularDistance(indices[next], queryIndex, n);\n                \n                minDistance = Math.Min(distPrev, distNext);\n            }\n            \n            answer[i] = minDistance;\n        }\n        \n        return answer;\n    }\n    \n    private int BinarySearch(List<int> indices, int target) {\n        int left = 0;\n        int right = indices.Count - 1;\n        \n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (indices[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        \n        if (indices[left] == target) return left;\n        \n        if (left > 0 && target - indices[left - 1] < indices[left] - target) {\n            return left - 1;\n        }\n        return left;\n    }\n    \n    private int MinCircularDistance(int idx1, int idx2, int n) {\n        int directDist = Math.Abs(idx1 - idx2);\n        int circularDist = n - directDist;\n        return Math.Min(directDist, circularDist);\n    }\n}","author":"happyparida","submissionId":"1575128445"},[]]},{"911":[{"id":"911","fileName":"1575128405.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> out(queries.size());\n        unordered_map<int, vector<int>> valToInds;\n        for(int i = 0; i < nums.size(); i++) valToInds[nums[i]].push_back(i);\n        \n        int ind = 0;\n        for(int& q : queries){\n            int it = lower_bound(valToInds[nums[q]].begin(), valToInds[nums[q]].end(), q) - valToInds[nums[q]].begin();\n            if(valToInds[nums[q]].size() == 1) out[ind] = -1;\n            else {\n                int val = INT_MAX;\n                if(it == valToInds[nums[q]].size() - 1){\n                    val = min(val, valToInds[nums[q]][it] - valToInds[nums[q]][it - 1]);\n                    val = min(val, valToInds[nums[q]][0] + (int)nums.size() - valToInds[nums[q]].back());\n                } else if(it == 0) {\n                    val = min(val, valToInds[nums[q]][1] - valToInds[nums[q]][it]);\n                    val = min(val, (int)nums.size() - valToInds[nums[q]].back() + valToInds[nums[q]][it]);\n                } else {\n                    val = min(val, valToInds[nums[q]][it] - valToInds[nums[q]][it - 1]);\n                    val = min(val, valToInds[nums[q]][it + 1] - valToInds[nums[q]][it]);\n                }\n                out[ind] = val;\n            }\n            ind++;\n        }\n        return out;\n    }\n};","author":"Zach Breger","submissionId":"1575128405"},[]]},{"913":[{"id":"913","fileName":"1575128499.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        arr = [float('inf')]*n\n        seen = dict()\n        left_first = dict()\n        for i in range(n):\n            if nums[i] in seen:\n                arr[i%n] = min(i-seen[nums[i]],n-i+seen[nums[i]])\n            seen[nums[i]] = i\n            if nums[i] not in left_first:\n                left_first[nums[i]]=i\n        right_first = dict()\n        seen = dict()\n        for i in range(n-1,-1,-1):\n            if nums[i] in seen:\n                arr[i%n] = min(arr[i],seen[nums[i]]-i,n-seen[nums[i]]+i)\n            seen[nums[i]] = i\n            if nums[i] not in right_first:\n                right_first[nums[i]] = i\n        for k,v in left_first.items():\n            if k in right_first and v!=right_first[k]:\n                arr[v] = min(arr[v],n-right_first[k]+v)\n                arr[right_first[k]] = min(arr[right_first[k]],n-right_first[k]+v)\n        for i in range(n):\n            if arr[i] == float('inf'):\n                arr[i] = -1\n        return [arr[k] for k in queries]","author":"Jianqiao Li","submissionId":"1575128499"},[]]},{"914":[{"id":"914","fileName":"1575128459.txt","sourceCode":"class Solution:\n    def solveQueries(self, A: List[int], queries: List[int]) -> List[int]:\n        n = len(A)\n        d = defaultdict(list)\n        for i, x in enumerate(A):\n            d[x].append(i)\n        ans = []\n        \n        def fuck(l, r):\n            v = abs(l - r)\n            return min(v, n - v)\n        \n        for q in queries:\n            v = A[q]\n            poss = d[v]\n            #print(poss)\n            if len(poss) < 2:\n                ans.append(-1)\n            else:\n                pos = bisect_left(poss, q)\n                l = poss[pos - 1] if pos > 0 else poss[-1]\n                r = poss[pos + 1] if pos < len(poss) - 1 else poss[0]\n                dl = fuck(q, l)\n                dr = fuck(q, r)\n                ans.append(min(dl, dr))\n        return ans","author":"MC_Stone","submissionId":"1575128459"},[]]},{"915":[{"id":"915","fileName":"1575128569.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        \"\"\" think\n        NOTICE:\n        1. 要回傳的是 distance !!!\n        2. 只有一個 element 的情況不能回傳自己的 distance !!\n        3. 要回傳的 distance 也跟他的位置有關！！！\n        think\n        1. create mapping value->indices\n            1. indices 也許用 queue ?\n        2. 或者對於每個 element 都暴力往左找往右找？不行，時間複雜度太高\n        3. 先做出 doubled_nums 然後 traverse 一次，看每個 index 上一個＆下一個\n        \"\"\"\n        n = len(nums)\n        doubled_nums = nums + nums\n        num_last_id = {}  # new(doubled) idx\n        idx_min_dist = defaultdict(lambda: float(\"inf\")) # origin idx\n        for new_idx, num in enumerate(doubled_nums):\n            # maintain num_last_id and num_min_dist\n            if num in num_last_id:\n                last_idx = num_last_id[num]\n                new_dist = new_idx - last_idx\n                if new_dist == n:\n                    new_dist = float(\"inf\")\n                last_ori_idx = last_idx % n\n                ori_idx = new_idx % n\n                idx_min_dist[last_ori_idx] = min(new_dist, idx_min_dist[last_ori_idx])\n                idx_min_dist[ori_idx] = min(new_dist, idx_min_dist[ori_idx])\n            num_last_id[num] = new_idx\n        # for i in range(n):\n        #     print(f\"nums[{i}]]={nums[i]}, idx_min_dist[{i}]={idx_min_dist[i]}\")\n        ans = []\n        for query in queries:\n            dist = idx_min_dist[query]\n            res = dist if dist != float(\"inf\") else -1\n            ans.append(res)\n        return ans\n        ","author":"Johnny","submissionId":"1575128569"},[]]},{"916":[{"id":"916","fileName":"1575128537.txt","sourceCode":"class Solution:\n    def solveQueries(self, original: List[int], queries: List[int]) -> List[int]:\n        indexToClosest = {}\n        nums = original + original\n        # maps num -> last seen index\n        lastSeen = {}\n        # print(nums)\n        # print(len(nums))\n        for i in range(len(nums)):\n            num = nums[i]\n            if num not in lastSeen:\n                lastSeen[num] = i\n                continue\n            lastIndex = lastSeen[num]\n            diff = abs(i - lastIndex)\n            # print(num, diff)\n            # print(indexToClosest, i)\n            # print(lastSeen)\n            # print()\n            if i in indexToClosest:\n                indexToClosest[i] = min(indexToClosest[i], diff)\n            else:\n                indexToClosest[i] = diff\n            if lastIndex in indexToClosest:\n                indexToClosest[lastIndex] = min(indexToClosest[lastIndex], diff)\n            else:\n                indexToClosest[lastIndex] = diff\n            lastSeen[num] = i\n        # print(indexToClosest)\n        returner = []\n        best = [0] * (len(original)*3)\n        for i in indexToClosest:\n            if i+len(original) in indexToClosest:\n                best[i] = min(indexToClosest[i], indexToClosest[i+len(original)])\n            else:\n                best[i] = indexToClosest[i]\n        # print(best)\n        # for q in queries:\n        #     if indexToClosest[q] < len(original):\n        #         returner.append(indexToClosest[q])\n        #     else:\n        #         returner.append(-1)\n        for q in queries:\n            if best[q] < len(original):\n                returner.append(best[q])\n            else:\n                returner.append(-1)\n        return returner","author":"pogert","submissionId":"1575128537"},[]]},{"918":[{"id":"918","fileName":"1575128577.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        # n = len(queries)\n        # ans = []\n        # table = defaultdict(list)\n        # for i,num in enumerate(nums):\n        #     table[num].append(i)\n\n        # for idx in queries:\n        #     number = nums[idx]\n        #     positions = table[number]\n\n        #     if len(positions)==1:\n        #         ans.append(-1)\n        #         continue\n\n        #     pos = positions.index(idx)\n        \n        #     left = indices[pos - 1] \n        #     right = indices[(pos + 1) % len(indices)]\n            \n        #     # Calculate the circular distances\n        #     d_left = min(abs(idx - left), n - abs(idx - left))\n        #     d_right = min(abs(idx - right), n - abs(idx - right))\n            \n        #     result.append(min(d_left, d_right))\n        import bisect\n\n        n = len(nums)\n        # Build a dictionary mapping each number to its list of indices.\n        positions = defaultdict(list)\n        for i, num in enumerate(nums):\n            positions[num].append(i)\n        \n        # Sort the lists for binary search.\n        for num in positions:\n            positions[num].sort()\n        \n        results = []\n        \n        # Process each query.\n        for query in queries:\n            value = nums[query]\n            idx_list = positions[value]\n            \n            # If only one occurrence exists, answer is -1.\n            if len(idx_list) == 1:\n                results.append(-1)\n                continue\n            \n            # Find the insertion position of query in the sorted list.\n            pos = bisect.bisect_left(idx_list, query)\n            \n            # Determine the left and right neighbors in the circular list.\n            left_index = idx_list[pos - 1] if pos > 0 else idx_list[-1]\n            right_index = idx_list[pos + 1] if pos + 1 < len(idx_list) else idx_list[0]\n            \n            # Compute distances taking circularity into account.\n            dist_left = min(abs(query - left_index), n - abs(query - left_index))\n            dist_right = min(abs(query - right_index), n - abs(query - right_index))\n            \n            # The answer is the smaller of the two distances.\n            results.append(min(dist_left, dist_right))\n        \n        return results\n    \n                \n            ","author":"underhood","submissionId":"1575128577"},[]]},{"751":[{"id":"751","fileName":"1575124274.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,int> mp;\n        nums.insert(nums.end(),nums.begin(),nums.end());\n        vector<int> nearestNeighbour(nums.size(),1e9);\n        for(int i=0;i<nums.size();i++){\n            if(mp.find(nums[i])==mp.end()) nearestNeighbour[i]=1e9;\n            else nearestNeighbour[i]=i-mp[nums[i]];\n            nearestNeighbour[mp[nums[i]]]=min(nearestNeighbour[mp[nums[i]]],nearestNeighbour[i]);\n            mp[nums[i]]=i;\n        }\n        for(int i=0;i<queries.size();i++){\n            queries[i]=min(nearestNeighbour[queries[i]],nearestNeighbour[queries[i]+nums.size()/2]);\n            if(queries[i]==nums.size()/2) queries[i]=-1;\n        }\n        return queries;\n    }\n};","author":"Dara_2001","submissionId":"1575124274"},[{"id":"751","similarity":0.7541899441340782,"totOverlap":135,"longestOverlap":11}]],"919":[{"id":"919","fileName":"1575128591.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, int> m;\n        map<int, int> prev;\n        int n = nums.size();\n        vector<int> nums2(nums.size()*2);\n        for(int i = 0; i < nums.size()*2; ++i){\n            if(i < nums.size()) nums2[i] = nums[i];\n            else nums2[i] = nums[i-nums.size()];\n        }\n        nums = nums2;\n        for(int i = 0; i < nums.size(); ++i){\n            if(prev.find(nums[i]) == prev.end()){\n                m[i] = 1e9;\n            }else{\n                m[i] = i-prev[nums[i]];\n                m[prev[nums[i]]] = min(m[prev[nums[i]]], m[i]);\n            }\n            prev[nums[i]] = i;\n        }\n        vector<int> ans(queries.size(), 0);\n        for(int i = 0; i < queries.size(); ++i){\n            m[queries[i]] = min(m[queries[i]], m[queries[i]+n]);\n            if(m[queries[i]] == 1e9 || m[queries[i]] >= n) ans[i] = -1;\n            else{\n                ans[i] = m[queries[i]];\n            }\n        }\n        return ans;\n    }\n};","author":"Top G","submissionId":"1575128591"},[{"id":"978","similarity":0.7252252252252253,"totOverlap":161,"longestOverlap":14},{"id":"978","similarity":0.7541899441340782,"totOverlap":135,"longestOverlap":11}]],"978":[{"id":"978","fileName":"1575129790.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map <int, int> last_pos;\n        \n        vector <int> near(2 * nums.size(), nums.size());\n        \n        for (int i = 0; i < nums.size(); i++) {\n            if (last_pos.find(nums[i]) != last_pos.end()) {\n                near[i] = i - last_pos[nums[i]];\n                near[last_pos[nums[i]]] = min(near[last_pos[nums[i]]], near[i]);\n            }\n            last_pos[nums[i]] = i;\n        }\n        \n        for (int i = 0; i < nums.size(); i++) {\n            int j = nums.size() + i;\n            if (last_pos.find(nums[i]) != last_pos.end()) {\n                near[j] = j - last_pos[nums[i]];\n                near[last_pos[nums[i]]] = min(near[last_pos[nums[i]]], near[j]);\n            }\n            last_pos[nums[i]] = j;\n        }\n        \n        vector <int> res(queries.size());\n        for (int i = 0; i < queries.size(); i++) {\n            res[i] = min(near[queries[i]], near[queries[i] + nums.size()]);\n            if (res[i] >= nums.size()) res[i] = -1;\n        }\n        return res;\n    }\n};","author":"Egor Tiliguzov","submissionId":"1575129790"},[{"id":"919","similarity":0.7252252252252253,"totOverlap":161,"longestOverlap":14}]]},{"920":[{"id":"920","fileName":"1575128578.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> ans;\n        int n = nums.size();\n\n        unordered_map<int, vector<int>> idx;\n\n        for (int i = 0; i < nums.size(); i++) {\n            idx[nums[i]].push_back(i);\n        }\n\n        for (auto query: queries) {\n            int q = nums[query];\n            if (idx.count(q) < 1) {\n                ans.push_back(-1);\n            } else {\n                if (idx[q].size() < 2) {\n                    ans.push_back(-1);\n                } else {\n                    auto it = lower_bound(idx[q].begin(), idx[q].end(), query);\n                    if (it == idx[q].begin()) {\n                        ans.push_back(min((*(it+1))-(*(it)), n + (*it) - (*(idx[q].end()-1))));\n                    } else if (it == idx[q].end() - 1) {\n                        ans.push_back(min((*(it))-(*(it-1)), n + (*(idx[q].begin())) - (*it)));\n                    } else {\n                        ans.push_back(min((*(it))-(*(it-1)), (*(it + 1))-(*it)));\n                    }\n                }\n            }\n        }\n        \n        return ans;\n    }\n};","author":"dongli-_-","submissionId":"1575128578"},[]]},{"921":[{"id":"921","fileName":"1575128601.txt","sourceCode":"\nclass Solution {\n    \npublic:\n    \n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n    unordered_map<int, vector<int>> mp;\n    int n = nums.size();\n    \n   \n    for (int i = 0; i < n; i++) {\n        mp[nums[i]].push_back(i);\n    }\n\n    vector<int> ans;\n    for (int q : queries) {\n        int ele = nums[q];\n        vector<int>& tmp = mp[ele]; \n        int idx = lower_bound(tmp.begin(), tmp.end(), q) - tmp.begin();\n        int lsz = tmp.size();\n        int mini = INT_MAX;\n\n        if (lsz == 1) {\n            ans.push_back(-1);\n            continue;\n        }\n\n        \n        if (idx > 0) {\n            mini = min(mini, q - tmp[idx - 1]);\n        } else {\n            mini = min(mini, (n + q - tmp[lsz - 1]) % n);\n        }\n\n        if (idx < lsz - 1) {\n            mini = min(mini, tmp[idx + 1] - q);\n        } else {\n            mini = min(mini, (n + tmp[0] - q) % n);\n        }\n\n        ans.push_back(mini);\n    }\n\n    return ans;\n}\n    \n};\n\n","author":"nimish yadav","submissionId":"1575128601"},[]]},{"922":[{"id":"922","fileName":"1575128633.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        int n = nums.size();\n        for(int i=0;i<n;i++)\n        {\n            mp[nums[i]].push_back(i);\n        }\n\n        int q = queries.size();\n        vector<int> ans(q, -1);\n        for(int i=0;i<q;i++)\n        {\n            int idx = queries[i];\n\n            int val = nums[idx];\n            auto &v = mp[val];\n\n            if(v.size()==1)\n                continue;\n            auto x = lower_bound(v.begin(), v.end(), idx) - v.begin();\n            ans[i] = n;\n            int pre = x-1;\n            if(pre<0)\n                pre = v.size()-1;\n\n            ans[i] = min({ans[i], (n-1)-idx+1+v[pre], idx+n-v[pre], abs(idx-v[pre])});\n\n            int post = x+1;\n            if(post>=v.size())\n                post = 0;\n\n            ans[i] = min({ans[i], (n-1)-idx+1+v[post], idx+n-v[post], abs(idx-v[post])});\n\n                    \n        }\n\n        return ans;\n    }\n};","author":"Suryansh Gupta","submissionId":"1575128633"},[]]},{"923":[{"id":"923","fileName":"1575128605.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for(int i = 0; i < n; ++i) {\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> f(n);\n        for(auto const& [val, idx]: mp) {\n            int m = idx.size();\n            if(m == 1) {\n                f[idx[0]] = -1;\n                continue;\n            }\n            for(int i = 0; i < m; ++i) {\n                int next = i + 1 == m ? 0 : i + 1;\n                int prev = i - 1 < 0 ? m - 1 : i - 1;\n                int dist1 = next < i ? idx[next] + n - idx[i] : idx[next] - idx[i];\n                int dist2 = prev > i ? idx[i] + n - idx[prev] : idx[i] - idx[prev];\n                f[idx[i]] = min(dist1, dist2);\n            }\n        }\n        vector<int> res;\n        for(int q: queries) res.push_back(f[q]);\n        return res;\n    }\n};","author":"Marvin Liu","submissionId":"1575128605"},[]]},{"924":[{"id":"924","fileName":"1575128630.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& v, vector<int>& q) {\n        map<int,vector<int>> m;\n        vector<int> w;\n        for(int i=0;i<v.size();i++) m[v[i]].push_back(i);\n        for(int i=0;i<q.size();i++){\n            int x=v[q[i]];\n            if(m[x].size()<=1) {\n                w.push_back(-1);\n                continue;\n            }\n            auto it=lower_bound(m[x].begin(),m[x].end(),q[i]);\n            int idx=it-m[x].begin();\n            int a=m[x][(idx+1)%(m[x].size())];\n            int b=m[x][(idx+m[x].size()-1)%(m[x].size())];\n            a=abs(q[i]-a);\n            b=abs(q[i]-b);\n            a=min(a,(int)v.size()-a);\n            b=min(b,(int)v.size()-b);\n            w.push_back(min(a,b));\n        }\n        return w;\n    }\n};","author":"nathanium","submissionId":"1575128630"},[]]},{"926":[{"id":"926","fileName":"1575128732.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int>ltor(nums.size());\n        map<int,int>mp;\n        map<int,int>counter;\n        for(int i = 0; i < nums.size(); i++){\n            if(mp.find(nums[i])==mp.end()){\n                ltor[i] = INT_MAX;\n            }\n            else{\n                ltor[i] = i - mp[nums[i]];\n            }\n            mp[nums[i]] = i;\n            counter[nums[i]]++;\n        }\n        for(int i = 0; i < nums.size(); i++){\n            if(ltor[i]==INT_MAX){\n                ltor[i] = nums.size() - mp[nums[i]] + i;\n            }\n        }\n        vector<int>rtol(nums.size());\n        map<int,int>mp2;\n        for(int i = nums.size()-1; i >= 0; i--){\n            if(mp2.find(nums[i])==mp2.end()){\n                rtol[i] = INT_MAX;\n            }\n            else{\n                rtol[i] =  mp2[nums[i]] - i;\n            }\n            mp2[nums[i]] = i;\n        }\n        for(int i =  nums.size()-1; i >= 0; i--){\n            if(rtol[i]==INT_MAX){\n                 rtol[i] = mp2[nums[i]] + (nums.size() - i);\n            }\n        }\n        vector<int>ans;\n        for(int i = 0; i < queries.size(); i++){\n            int ind = queries[i];\n            if(counter[nums[ind]]==1) ans.push_back(-1);\n            else ans.push_back(min(ltor[ind],rtol[ind]));\n        }\n        return ans;\n    }\n};","author":"sai_uma_sankar","submissionId":"1575128732"},[]]},{"927":[{"id":"927","fileName":"1575128763.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        int a[] = new int[2*n-1];\n        for(int i=0;i<n;i++) a[i] = nums[i];\n        for(int i=n;i<2*n-1;i++) a[i] = nums[i-n];\n        int res[] = new int[2*n-1];\n        HashMap<Integer,Integer> map  = new HashMap<>();\n        for(int i=2*n-2;i>=0;i--)\n        {\n            if(map.containsKey(a[i])) \n            {\n                res[i] = map.get(a[i])-i;\n            }\n            else {\n                res[i] = -1;\n            }\n            map.put(a[i],i);\n        }\n        int b[] = new int[2*n-1];\n        for(int i=0;i<n-1;i++) {\n            b[i] = nums[i+1];\n        }\n        for(int i=n-1;i<2*n-1;i++)\n        {\n            b[i] = nums[i-n+1];\n        }\n        map = new HashMap<>();\n        int res2[] = new int[2*n-1];\n        for(int i=0;i<2*n-1;i++)\n        {\n            if(map.containsKey(b[i]))\n            {\n                res2[i] = i-map.get(b[i]);\n            }\n            else res2[i] = -1;\n            map.put(b[i],i);\n        }\n        int q = queries.length;\n        List<Integer> ans = new ArrayList<>();\n        for(int i=0;i<q;i++)\n        {\n            int ind = queries[i];\n            int val1 = res[ind];\n            int val2 = res2[ind+n-1];\n            int val = 0;\n            if(val1==-1&&val2==-1) {\n                val = -1;\n            }\n            else if(val1==-1)\n            {\n                val = val2;\n            }\n            else if(val2==-1)\n            {\n                val = val1;\n            }\n            else {\n                val = Math.min(val1,val2);\n            }\n            if(val<n&&val!=-1)\n            {\n                ans.add(val);\n            }\n            else ans.add(-1);\n        }\n        return ans;\n    }\n}","author":"TulasiRaj","submissionId":"1575128763"},[]]},{"929":[{"id":"929","fileName":"1575128748.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> m;\n        vector<int> pos;\n        for (int i = 0; i < nums.size(); ++i){\n            m[nums[i]].push_back(i);\n            pos.push_back(m[nums[i]].size() - 1);\n        }\n        vector<int> ans;\n        for (auto& n : queries){\n            int p = pos[n];\n            int num = nums[n];\n            if (m[num].size() == 1){\n                ans.push_back(-1);\n                continue;\n            } \n            // forward\n            // backward\n            int f = m[num][(p + 1) % m[num].size()];\n            int b = m[num][(p - 1 + m[num].size()) % m[num].size()];\n            p = n;\n            int minDist = max(f, p) - min(f, p);\n            \n \n            minDist = min(minDist, max(b, p) - min(b, p));\n            \n            minDist = min(minDist, min(f, p) + (int)nums.size() - max(f,p));\n            \n            minDist = min(minDist, min(b, p) + (int)nums.size() - max(p,b));\n            ans.push_back(minDist);\n        }\n        return ans;\n    }\n\n};","author":"epicfailure2015","submissionId":"1575128748"},[]]},{"930":[{"id":"930","fileName":"1575128704.txt","sourceCode":"class Solution {\npublic:\n\n    int solver(vector<int> & v, int index, int total_size){\n        int vin=lower_bound(v.begin(), v.end(), index)-v.begin();\n        int n=v.size();\n        if(n==1){return -1;}\n        if(vin==0){\n            // check with next and end of v\n            \n            int ans=INT_MAX;\n            ans=min(ans, v[vin+1]-v[vin]);\n            ans=min(ans, (total_size-v[n-1])+v[vin]);\n            \n            return ans;\n                \n            \n        }if(vin==v.size()-1){\n            // check with last and first of v\n            int ans=INT_MAX;\n            ans=min(ans, v[vin]-v[vin-1]);\n            ans=min(ans, (total_size-v[vin])+v[0]);\n            \n            return ans;\n        }\n        if(vin!=0 && vin!=v.size()-1){\n            int ans=INT_MAX;\n            ans=min(ans, v[vin]-v[vin-1]);\n            ans=min(ans, v[vin+1]-v[vin]);\n            return ans;\n        }\n        return -1;\n    }\n\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> d;\n        for(int i=0;i<nums.size();i++){\n            d[nums[i]].push_back(i);\n        }\n        // cout<<\"SIze: \"<<nums.size()<<endl;\n        // for(auto i:d){\n        //     cout<<i.first<<\": \";\n        //     for(auto j:i.second){\n        //         cout<<j<<\" \";\n        //     }cout<<endl;\n        // }\n        vector<int> final(queries.size(), 0);\n        for(int i=0;i<queries.size();i++){\n            int ele=nums[queries[i]];\n            int index=queries[i];\n            int temp_ans=solver(d[ele], index, nums.size());\n            final[i]=temp_ans;            \n        }\n        return final;\n    }\n};","author":"Shashvat Singhal","submissionId":"1575128704"},[]]},{"931":[{"id":"931","fileName":"1575128826.txt","sourceCode":"class Solution(object):\n    def solveQueries(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        # 20250315 22:36PM\n        hmap = defaultdict(list)\n        for idx,val in enumerate(nums):\n            hmap[val].append(idx)\n        n = len(nums)\n        ans = []\n        for q in queries:\n\n            if len(hmap[nums[q]]) == 1:\n                ans.append(-1)\n            else:\n                t_list = hmap[nums[q]]\n                idx = bisect.bisect_left(t_list,q)# first >=\n                if idx == 0:\n                    res = min(t_list[1]-t_list[0], n - (t_list[-1]-t_list[0])%n)\n                elif idx == len(t_list)-1:\n                    res = min(t_list[idx]-t_list[idx-1], n - (t_list[idx]-t_list[0])%n)\n                else:\n                    res = min(t_list[idx] - t_list[idx-1], t_list[idx+1] - t_list[idx])\n                ans.append(res)\n        return ans\n                    \n            ","author":"lynnnaive16","submissionId":"1575128826"},[]]},{"932":[{"id":"932","fileName":"1575128825.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        ans = []\n        N = len(nums)\n        dists = defaultdict(list)\n        for i, num in enumerate(nums):\n            dists[num].append(i)\n\n        \n        for q in queries:\n            val = nums[q]\n            valIndices = dists[val]\n            if len(valIndices) <= 1:\n                ans.append(-1)\n                continue\n                \n            valIDX = bisect_left(valIndices, q)\n            left = None\n            right = None\n            if valIDX == 0:\n                left = valIndices[-1]\n                right = valIndices[1]\n            elif valIDX == len(valIndices) - 1:\n                left = valIndices[valIDX -1]\n                right = valIndices[0]\n            else:\n                left = valIndices[valIDX - 1]\n                right = valIndices[valIDX + 1]\n\n            \n            mnLeftDist = min(abs(left-q), min(left, q) + (N - max(left, q)))\n            mnRightDist = min(abs(right-q), min(right, q) + (N - max(right, q)))\n            res = min(mnLeftDist, mnRightDist)\n            ans.append(res)\n            \n        return ans\n        ","author":"Jonathan de Koning","submissionId":"1575128825"},[]]},{"935":[{"id":"935","fileName":"1575128871.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        # 0 2 4\n        m = defaultdict(list)\n        ntom = {}\n        for i,n in enumerate(nums):\n            m[n].append(i)\n            if n not in ntom:\n                ntom[n] = {}\n            ntom[n][i] = len(m[n]) - 1\n        ans = []\n        for q in queries:\n            curr = nums[q]\n            minDist = len(nums)\n            indices = m[curr]\n            if len(indices) == 1:\n                ans.append(-1)\n                continue\n            ntomi = ntom[curr][q]\n            if ntomi >= len(indices)-1:\n                minDist = min(minDist, len(nums) - indices[ntomi] + indices[0])\n            else:\n                minDist = min(minDist, indices[ntomi+1] - indices[ntomi])\n            if ntomi == 0:\n                minDist = min(minDist, indices[ntomi] + len(nums) - indices[len(indices)-1])\n            else:\n                minDist = min(minDist, indices[ntomi] - indices[ntomi-1])\n            ans.append(minDist)\n        return ans\n            ","author":"Jake Barris","submissionId":"1575128871"},[]]},{"936":[{"id":"936","fileName":"1575128830.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mpp;\n        int n = nums.size();\n        \n        // Step 1: Store indices of each number in a hashmap\n        for (int i = 0; i < n; i++) {\n            mpp[nums[i]].push_back(i);\n        }\n\n        vector<int> ans;\n        for (int idx : queries) {\n            vector<int>& v = mpp[nums[idx]];  // Use reference to avoid copying\n\n            if (v.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n\n            // Step 2: Use lower_bound to find position\n            int ele_idx = lower_bound(v.begin(), v.end(), idx) - v.begin();\n\n            // Step 3: Get neighbors without unnecessary modulo\n            int prev = (ele_idx > 0) ? v[ele_idx - 1] : v.back();\n            int next = (ele_idx < v.size() - 1) ? v[ele_idx + 1] : v.front();\n\n            // Step 4: Compute min distance\n            int mindist = min((idx - prev + n) % n, (next - idx + n) % n);\n            ans.push_back(mindist);\n        }\n\n        return ans;\n    }\n};\n","author":"chennakeshava_ck","submissionId":"1575128830"},[]]},{"938":[{"id":"938","fileName":"1575128803.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& v, vector<int>& q) {\n        int n=v.size();\n        vector<int>a;\n        unordered_map<int,int>u,ci,u1,ci1;\n        vector<int>t(2*n);\n        for(int i=0;i<n;i++) {\n            t[i] = v[i];\n            t[i+n] = v[i];\n        }\n        for(int i=0;i<2*n;i++) {\n            if(ci.count(t[i]) && ci[t[i]] > i-n) u[i] = ci[t[i]];\n            ci[t[i]] = i;\n        }\n        for(int i=2*n-1;i>=0;i--) {\n            if(ci1.count(t[i]) && ci1[t[i]] < i+n) u1[i] = ci1[t[i]];\n            ci1[t[i]] = i;\n        }\n        for(auto &i: q) {\n            if(u.count(i) == 0 && u.count(i+n) == 0) a.push_back(-1);\n            else {\n                int z=INT_MAX;\n                if(u.count(i)) z = i-u[i];\n                if(u1.count(i)) z = min(z,u1[i]-i);\n                if(u.count(i+n)) z = min(z,i+n-u[i+n]);\n            //    if(u1.count(i+n)) z = min(z,u1[i+1]-i);\n                a.push_back(z);\n            }\n        }\n        return a;\n    }\n};","author":"Archit Jain","submissionId":"1575128803"},[]]},{"939":[{"id":"939","fileName":"1575128982.txt","sourceCode":"#define all(a) a.begin(), a.end()\n#define rep(i, k, n) for(int i = k; i < n; i++)\n#define pb(v) push_back(v) \n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> t2;\n        rep(i, 0, nums.size()){t2[nums[i]].pb(i);}\n\n        vector<int> res;\n        for (int &it : queries) {    \n            int val = nums[it];\n            auto &t1 = t2[val];\n            \n            if (!(t1.size() - 1)) {res.pb(-1); continue;}\n            int pos = int(lower_bound(all(t1), it) - t1.begin());\n            \n            int t3 = abs(it - t1[(pos - 1 + t1.size()) % t1.size()]);\n            int t4 = abs(it - t1[(pos + 1) % t1.size()]);\n            t3 = min(t3, static_cast<int>(nums.size()) - t3);\n            t4 = min(t4, static_cast<int>(nums.size()) - t4);\n            int temp = min(t3, t4);\n            res.pb(temp);\n        }\n        \n        return res;\n    }\n};\n","author":"Alphx2435","submissionId":"1575128982"},[]]},{"940":[{"id":"940","fileName":"1575128912.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,int> mp;\n        int i, j, n = nums.size();\n        vector<pair<int,int>> vp(n,{INT_MAX,INT_MAX});\n        for(i=0;i<2*n;i++){\n            int z = i%n;\n            int x = nums[z];\n            if(mp.find(x)!=mp.end()){\n                int y = mp[x];\n                if(y%n!=z){\n                    vp[z].first = min(vp[z].first,i-y);\n                }\n            }\n            mp[x]=i;\n        }\n        mp.clear();\n        for(i=2*n-1;i>=0;i--){\n            int z = i%n;\n            int x = nums[z];\n            if(mp.find(x)!=mp.end()){\n                int y = mp[x];\n                if(y%n!=z){\n                    vp[z].second = min(vp[z].second,y-i);\n                }\n            }\n            mp[x]=i;\n        }\n        // for(i=0;i<n;i++){\n        //     cout<<vp[i].first<<\" \";\n        // }\n        // cout<<\"n\";\n        // for(i=0;i<n;i++){\n        //     cout<<vp[i].second<<\" \";\n        // }\n        // cout<<\"n\";\n        vector<int> ans;\n        for(auto &el: queries){\n            int an = min(vp[el].first,vp[el].second);\n            if(an==INT_MAX){\n                ans.push_back(-1);\n            }\n            else{\n                ans.push_back(an);\n            }\n        }\n        return ans;\n        \n    }\n};","author":"Bharat Adhikari","submissionId":"1575128912"},[]]},{"941":[{"id":"941","fileName":"1575129009.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        map<int,vector<int>> mp;\n        map<int,pair<int,int>> m2;\n        int n=a.size();\n        for(int i=0;i<n;i++){\n            if(mp[a[i]].size()==0){mp[a[i]].push_back(i);\n            m2[i]=make_pair(INT_MAX,INT_MAX);\n                                  }\n            else{\n                int t=mp[a[i]].back();\n                int d=i-t;\n                if(m2[t].second>d){\n                    m2[t].first=i;\n                    m2[t].second=d;\n                }\n                m2[i]=make_pair(t,d);\n                mp[a[i]].push_back(i);\n            }\n        }\n        for(auto it:mp){\n            vector<int> t=it.second;\n            if(t.size()!=1){\n                int f=t.front();\n                int l=t.back();\n                int d=n-l+f;\n                if(m2[l].second>d){\n                    m2[l].first=f;\n                    m2[l].second=d;\n                }\n                if(m2[f].second>d){\n                    m2[f].first=f;\n                    m2[f].second=d;\n                }\n            }\n        }\n        vector<int> ans;\n        \n        for(int i=0;i<q.size();i++){\n            int ele=a[q[i]];\n            if(mp[ele].size()==1)ans.push_back(-1);\n            else ans.push_back(m2[q[i]].second);\n        }\n        return ans;\n    }\n};","author":"Rip_Logic","submissionId":"1575129009"},[]]},{"942":[{"id":"942","fileName":"1575128865.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, set<int>> m;\n        for (int i = 0; i < n; ++i) {\n            m[nums[i]].insert(i);\n        }\n\n        vector<int> ans;\n        for (auto idx : queries) {\n            int value = nums[idx];\n            set<int>& idxes = m[value];\n            if (idxes.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            int distance = INT_MAX;\n            \n            auto after = idxes.upper_bound(idx);\n            auto before = idxes.lower_bound(idx);\n\n            // if there is nothing after\n            if (after != end(idxes)) {\n                int afterIdx = *after;\n                distance = min(afterIdx - idx, distance);\n                distance = min(idx + (n-afterIdx), distance);\n                //printf(\"after %d %d %d %d %dn\", idx, value, afterIdx, afterIdx - idx, idx + (n-afterIdx));\n            } else {\n                // look for first before\n                int beforeIdx = *begin(idxes);\n                distance = min(distance, beforeIdx + (n-idx));\n            }\n\n            // if there is nothing before\n            if (before != begin(idxes)) {\n                int beforeIdx = *prev(before);\n                distance = min(idx - beforeIdx, distance);\n                distance = min(beforeIdx + (n-idx), distance);\n                //printf(\"before %d %d %d %d %dn\", idx, value, beforeIdx, idx - beforeIdx, beforeIdx + (n-idx));\n            } else {\n                int afterIdx = *prev(end(idxes));\n                distance = min(idx + (n- afterIdx), distance);\n                // look for last\n            }\n\n            ans.push_back(distance == INT_MAX ? -1 : distance);\n        }\n        return ans;\n    }\n};","author":"law","submissionId":"1575128865"},[]]},{"943":[{"id":"943","fileName":"1575129112.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n      int n = nums.size(), m = queries.size();\n\n      vector<int>cir = nums;\n      cir.insert(cir.begin(),nums.begin(),nums.end());\n      cir.insert(cir.begin(),nums.begin(),nums.end());\n      unordered_map<int, vector<int>>app;\n      \n       vector<int>ans(m);\n\n      for(int i = 0 ; i<3*n;++i){\n        app[cir[i]].push_back(i);\n      }\n\n      for(int i=0;i<m;++i){\n        int targetI = n+queries[i];\n        int val = nums[ queries[i]];\n        vector<int> &ocr = app[val];\n        if(ocr.size()==3){\n          ans[i] = -1;\n          continue;\n        }\n\n        auto it = lower_bound(ocr.begin(),ocr.end(),targetI);\n        int idx = distance(ocr.begin(),it);\n\n        ans[i] = min( targetI - ocr[idx-1], ocr[idx+1]-targetI );\n        \n      }\n\n\n\n\n      return ans;\n        \n    }\n};","author":"ngmi","submissionId":"1575129112"},[]]},{"944":[{"id":"944","fileName":"1575129011.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        if len(queries) == 0:\n            return []\n        dic = {}\n        n = len(nums)\n        loc = [-1] * n\n        for i,num in enumerate(nums):\n            if num in dic:\n                dic[num].append(i)\n            else:\n                dic[num] = [i]\n            loc[i] = len(dic[num])-1\n        m = len(queries)\n        out = [-1] * m\n        for i in range(m):\n            ind1 = queries[i]\n            cand = dic[nums[ind1]]\n            if len(cand) == 1:\n                continue\n            j1 = loc[ind1]\n            if j1 > 0 and j1 < len(cand) - 1:\n                out[i] = min(cand[j1+1]-ind1,ind1-cand[j1-1])\n            elif j1 == 0:\n                out[i] = min(cand[1]-ind1,ind1+n-cand[-1])\n            else:\n                out[i] = min(cand[0]+n-ind1,ind1-cand[j1-1])\n        return out\n            ","author":"Ar2FZ3mtmI","submissionId":"1575129011"},[]]},{"945":[{"id":"945","fileName":"1575129072.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        map<int,vector<int>>m;\n        int n=a.size();\n        for(int i=0;i<n;i++) {\n            m[a[i]].push_back(i);\n        }\n\n        int ans[n];\n        memset(ans,-1,sizeof(ans));\n\n        for(auto i:m) {\n            int sz=i.second.size();\n            if(sz>1) {\n                int j=sz-1;\n                for(int k=0;k<sz;k++) {\n                    int curr = i.second[k];\n                    int next = i.second[(k+1)%sz];\n                    int prev = i.second[j];\n\n                    int val1=n+1;\n                    if(next>curr) {\n                        val1 = (next-curr);\n                    }else {\n                        val1 = next + (n-curr);\n                    }\n\n                    int val2=n+1;\n                    if(curr>prev) {\n                        val2 = curr-prev;\n                    }else {\n                        val2 = curr + (n-prev);\n                    }\n\n                    ans[curr] = min(val1, val2);\n\n                    j=(j+1)%sz;\n                }\n            }\n        }\n        vector<int>ret;\n        for(auto i:q) {\n            ret.push_back(ans[i]);\n        }\n        return ret;\n    }\n};\n","author":"keysersoze29","submissionId":"1575129072"},[]]},{"946":[{"id":"946","fileName":"1575129086.txt","sourceCode":"typedef pair<int, int> pii;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<pii> v1, v2;\n        v1.reserve(n*2+2);\n        v2.reserve(n*2+2);\n        for(int i = 0; i < n; i++) {\n            v1.push_back({nums[i], i});\n            v2.push_back({nums[i], -i});\n            v1.push_back({nums[i], i+n});\n            v2.push_back({nums[i], n-i});\n        }\n        v1.push_back({INT_MIN, INT_MIN});\n        v1.push_back({INT_MAX, INT_MAX});\n        v2.push_back({INT_MIN, INT_MIN});\n        v2.push_back({INT_MAX, INT_MAX});\n        sort(v1.begin(), v1.end());\n        sort(v2.begin(), v2.end());\n        vector<int> res;\n        int m = queries.size();\n        res.reserve(m);\n        for(int q: queries) {\n            // cout << q << endl;\n            int dist = INT_MAX;\n            auto it = upper_bound(v1.begin(), v1.end(), pii{nums[q], q});\n            // cout << it->first << \",\" << it->second << ' ';\n            if(it->first == nums[q]) dist = it->second - q;\n            it = upper_bound(v2.begin(), v2.end(), pii{nums[q], -q});\n            // cout << it->first << \",\" << it->second << endl;\n            if(it->first == nums[q]) dist = min(dist, it->second + q);\n            if(dist >= n) dist = -1;\n            res.push_back(dist);\n        }\n        return res;\n    }\n};","author":"h_bugw7","submissionId":"1575129086"},[]]},{"948":[{"id":"948","fileName":"1575129188.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        vector<int>ans(q.size(),-1);\n        unordered_map<int,vector<int>>mp;\n        for(int i=0;i<nums.size();i++)\n            {\n                mp[nums[i]].push_back(i);\n            }\n        int n=nums.size();\n        for(int i=0;i<q.size();i++)\n            {\n                int vv=nums[q[i]];\n                if(mp[vv].size()>1){\n                    auto &v=mp[vv];\n                    int idx=lower_bound(v.begin(),v.end(),q[i])-v.begin();\n                    int value=INT_MAX;\n                    \n                    value=(v[(idx+1)%v.size()]-v[idx]+nums.size())%nums.size();\n                    \n                    \n                        int ii=(v.size()+idx-1)%v.size();\n                        value=min(value,(v[idx]-v[ii]+n)%n);\n                    \n                    \n                    ans[i]=value;\n                }\n            }\n        return ans;\n    }\n};","author":"Shivesh Dixit","submissionId":"1575129188"},[]]},{"949":[{"id":"949","fileName":"1575129125.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        # [1,3,1,4,1,3,2] \n        print = lambda *x:x\n        n = len(nums)\n        \n\n        left = [None] * n\n        right = [None] * n\n        \n        m = collections.defaultdict(list)\n        for i, num in enumerate(nums):\n            if len(m[num]) > 0:\n                left[i] = m[num][-1]\n            m[num].append(i)\n        \n        for i in range(n):\n            if left[i] is None:\n                continue\n            nIndex = left[i]\n            right[nIndex] = i\n                        \n        print(m)\n        print(left)\n        print(right)\n\n            \n        # fill first\n        for i in range(n):\n            val = nums[i]\n            if left[i] is None and len(m[val]) > 1:\n                left[i] = m[val][-1]\n\n\n        for i in range(n):\n            val = nums[i]\n            if right[i] is None and len(m[val]) > 1:\n                right[i] = m[val][0]\n\n            \n                \n        print(left)\n        print(right)\n                            \n            \n            \n        result = []\n        for index in queries:\n            num = nums[index]\n            locations = m[num]\n            \n            if len(locations) == 1:\n                result.append(-1)\n                continue\n            \n            dist = []\n\n            l = (index-left[index])%n if left[index] is not None else float(\"inf\")\n            r = (right[index]-index)%n if right[index] is not None else float(\"inf\")\n            \n            print(index, l, r)\n            \n            x = min(l, r)\n            if x == float(\"inf\"):\n                result.append(-1)\n            else:\n                result.append(x)\n            \n            \n        return result","author":"wansong123","submissionId":"1575129125"},[]]},{"951":[{"id":"951","fileName":"1575129288.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int>circ;\n        for(auto n:nums)\n            circ.push_back(n);\n        for(auto n:nums)\n            circ.push_back(n);\n        map<int,vector<int>>mp;\n        for(int i=0;i<circ.size();i++)\n            mp[circ[i]].push_back(i);\n        vector<int>ans;\n        for(auto q:queries){\n            int elem = nums[q];\n            int sz = mp[elem].size();\n            int new_q = q + nums.size();\n            int nxt_idx1 = upper_bound(mp[elem].begin(),mp[elem].end(),q) - mp[elem].begin();\n            int prev_idx1 = lower_bound(mp[elem].begin(),mp[elem].end(),q)-mp[elem].begin();\n            int min_dist1 = nums.size()+1;\n            if(nxt_idx1!=sz)\n                min_dist1 = min(min_dist1,mp[elem][nxt_idx1]-q);\n            if((prev_idx1-1)>=0)\n                min_dist1 = min(min_dist1,q - mp[elem][prev_idx1-1]);\n            int nxt_idx2 = upper_bound(mp[elem].begin(),mp[elem].end(),new_q) - mp[elem].begin();\n            int prev_idx2 = lower_bound(mp[elem].begin(),mp[elem].end(),new_q)-mp[elem].begin();\n            int min_dist2 = nums.size()+1;\n            if(nxt_idx2!=sz)\n                min_dist2 = min(min_dist2,mp[elem][nxt_idx2]-new_q);\n            if((prev_idx2-1)>=0)\n                min_dist2 = min(min_dist2,new_q - mp[elem][prev_idx2-1]);\n            int min_dist = min(min_dist1,min_dist2);\n            if(min_dist==nums.size())\n                ans.push_back(-1);\n            else\n                ans.push_back(min_dist);\n            \n        }\n        return ans;\n    }\n};","author":"coder1227","submissionId":"1575129288"},[]]},{"953":[{"id":"953","fileName":"1575129421.txt","sourceCode":"#define ll long long\n#define ull unsigned long long\n#define MOD 1000000007\n#define pb push_back\n#define F first\n#define S second\n#define all(v) (v).begin(),(v).end()\n#define rall(v) (v).rbegin(),(v).rend()\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rrep(i,n) for(int i=(n)-1;i>=0;--i)\n#define lloop(i,a,b) for(int i=(a);i<=(b);++i)\n#define jloop(i,a,b,k) for(int i=(a);i<=(b);i+=(k))\n#define nlloop(i,a,b) for(int i=(a);i>=(b);--i)\n#define njloop(i,a,b,k) for(int i=(a);i>=(b);i-=(k))\n#define vi vector<int>\n#define vll vector<long long>\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vpii vector<pair<int,int>>\n#define vpll vector<pll>\n#define vvi vector<vi>\n#define vb vector<bool>\n#define umii unordered_map<int,int>\n#define umci unordered_map<char,int>\n#define umli unordered_map<ll,int>\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        vi ans(n,-1),res;\n        unordered_map<int,vi>mp;\n        rep(i,n)\n            mp[nums[i]].pb(i);\n        for(auto it:mp)\n        {\n            vi temp=it.S;\n            int sz=temp.size();\n            if(sz<2)\n                continue;\n            sort(all(temp));\n            rep(j,sz)\n            {\n                int now=temp[j],pre=temp[(j+sz-1)%sz],nex=temp[(j+1)%sz];\n                int ldiff=abs(pre-now),rdiff=abs(nex-now);\n                ldiff=min(ldiff,n-ldiff);\n                rdiff=min(rdiff,n-rdiff);\n                ans[now]=min(ldiff,rdiff);\n            }\n        }\n        for(int i:queries)\n            res.pb(ans[i]);\n        return res;\n    }\n};","author":"Aditya Mondal","submissionId":"1575129421"},[]]},{"955":[{"id":"955","fileName":"1575129390.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& qry) {\n        int n = a.size(), qn = qry.size();\n        map<int, vector<int>> mp;\n        vector<int> ans(qn);\n\n        for (int i = 0; i < n; ++i) mp[a[i]].push_back(i);\n\n        for (int i = 0; i < qn; ++i) {\n            int d = a[qry[i]];\n            auto &vec = mp[d];\n            int len = vec.size();\n\n            if (len <= 1) {\n                ans[i] = -1;\n                continue;\n            }\n\n            int idx = lower_bound (vec.begin(), vec.end(), qry[i]) - vec.begin();\n            ans[i] = min ((vec[idx] - vec[(idx-1+len)%len] + n)%n, (vec[(idx+1)%len] - vec[idx] + n)%n);\n        }\n        return ans;\n    }\n};","author":"Shyam","submissionId":"1575129390"},[]]},{"27":[{"id":"27","fileName":"1575092719.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        positions = {}\n        for i, num in enumerate(nums):\n            positions.setdefault(num, []).append(i)\n\n        res = []\n        for q in queries:\n            val = nums[q]\n            pos_list = positions[val]\n\n            if len(pos_list) == 1:\n                res.append(-1)\n                continue\n\n            pos = bisect_left(pos_list, q)\n            left_idx = pos_list[pos - 1] if pos > 0 else pos_list[-1]\n            right_idx = pos_list[pos + 1] if pos + 1 < len(pos_list) else pos_list[0]\n\n            def circular_distance(i, j):\n                d = abs(i - j)\n                return min(d, n - d)\n\n            d_left = circular_distance(q, left_idx)\n            d_right = circular_distance(q, right_idx)\n            res.append(min(d_left, d_right))\n\n        return res","author":"Keerthi Rao C","submissionId":"1575092719"},[{"id":"27","similarity":0.7209302325581395,"totOverlap":93,"longestOverlap":17}]],"957":[{"id":"957","fileName":"1575129477.txt","sourceCode":"import bisect\nfrom collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        positions = defaultdict(list)\n        for i, num in enumerate(nums):\n            positions[num].append(i)\n        for num in positions:\n            positions[num].sort()\n\n        result = []\n        for q in queries:\n            candidate = nums[q]\n            pos_list = positions[candidate]\n            if len(pos_list) == 1:\n                result.append(-1)\n                continue\n\n            idx = bisect.bisect_left(pos_list, q)\n            prev_index = pos_list[(idx - 1) % len(pos_list)]\n            next_index = pos_list[(idx + 1) % len(pos_list)]\n            \n            def circular_distance(a: int, b: int) -> int:\n                diff = abs(a - b)\n                return min(diff, n - diff)\n            \n            d_prev = circular_distance(q, prev_index)\n            d_next = circular_distance(q, next_index)\n            result.append(min(d_prev, d_next))\n\n        return result\n","author":"lkhlc","submissionId":"1575129477"},[{"id":"1010","similarity":0.7218045112781954,"totOverlap":96,"longestOverlap":24},{"id":"1010","similarity":0.7209302325581395,"totOverlap":93,"longestOverlap":17}]],"1010":[{"id":"1010","fileName":"1575130720.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        positions = {}\n        for i, num in enumerate(nums):\n            if num not in positions:\n                positions[num] = []\n            positions[num].append(i)\n        result = []\n\n        for idx in queries:\n            num = nums[idx]\n            pos_list = positions[num]\n            if len(pos_list) == 1:\n                result.append(-1)\n                continue\n\n            pos = bisect.bisect_left(pos_list, idx)\n            right_idx = pos_list[(pos + 1) % len(pos_list)]\n            left_idx = pos_list[(pos - 1) % len(pos_list)]\n            \n            def circular_distance(a, b):\n                diff = abs(a - b)\n                return min(diff, n - diff)\n            \n            dist_right = circular_distance(idx, right_idx)\n            dist_left = circular_distance(idx, left_idx)\n            result.append(min(dist_left, dist_right))\n        \n        return result\n","author":"code_jarvis","submissionId":"1575130720"},[{"id":"957","similarity":0.7218045112781954,"totOverlap":96,"longestOverlap":24}]]},{"958":[{"id":"958","fileName":"1575129434.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, int> left, right;\n        int n = nums.size();\n        vector<int> dist(n, INT_MAX);\n        for(int i=0; i<n; i++) {\n            int val = nums[i];\n            if(right.count(val)) {\n                dist[i] = min(dist[i], i-right[val]);\n            }\n            if(left.count(val)) {\n                dist[i] = min(dist[i], n+left[val]-i);\n            }\n            // update leftmost and rightmost for the current num\n            if(!left.count(val)) {\n                left[val] = i;\n            }\n            right[val] = i;\n        }\n\n        unordered_map<int, int> left2, right2;\n        for(int i=n-1; i>=0; i--) {\n            int val = nums[i];\n            if(left2.count(val)) {\n                dist[i] = min(dist[i], left2[val]-i);\n            }\n            if(right2.count(val)) {\n                dist[i] = min(dist[i], i+n-right2[val]);\n            }\n            // update\n            if(!right2.count(val)) right2[val] = i;\n            left2[val] = i;\n        }\n\n        vector<int> res;\n        for(int q : queries) {\n            if(dist[q] == INT_MAX) res.push_back(-1);\n            else res.push_back(dist[q]);\n        }\n        return res;\n    }\n};","author":"RoyL","submissionId":"1575129434"},[]]},{"960":[{"id":"960","fileName":"1575129489.txt","sourceCode":"class Solution:\n    import bisect\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        indices = {}\n        for i,j in enumerate(nums):\n            if j not in indices:\n                indices[j] = []\n            indices[j].append(i)\n        ans = []\n        for q in queries:\n            ind = q\n            val = nums[ind]\n            allvals = indices[val]\n            n = len(allvals)\n            myind = bisect.bisect_left(allvals,ind)\n            #print(ind,val,allvals,myind)\n            if n < 2:\n                a = -1\n            elif myind > 0 and myind < n-1:\n                a = min(allvals[myind+1]- allvals[myind],allvals[myind] - allvals[myind-1] )\n            elif myind == 0:\n                a = min(allvals[myind+1]- allvals[myind], allvals[myind] + len(nums) - allvals[-1])\n            else:\n                a = min(allvals[myind]- allvals[myind-1], allvals[0] + len(nums) - allvals[myind])\n            ans.append(a)\n        return ans\n            \n        ","author":"Harry P","submissionId":"1575129489"},[]]},{"963":[{"id":"963","fileName":"1575129517.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[]} queries\n * @return {number[]}\n */\nvar solveQueries = function(nums, queries) {\n    const n = nums.length;\n    const m = queries.length;\n    const {abs, min} = Math\n    \n    const map = {}\n    \n    for (let i=0; i<n; i++) {\n        const num = nums[i];\n        if (!map[num]) {\n            map[num] = [];\n        }\n        map[num].push(i);\n    }\n    \n    const res = [];\n\n    const lowerbound = (t, arr)=> {\n        let l=0; \n        let r=arr.length;\n        while (l<r) {\n            const m=(l+r)>>1;\n            if(t<=arr[m]) {\n                r=m;\n            } else{\n                l=m+1;\n            }\n        }\n        return l;\n    }\n    \n    \n    for (let i=0; i<m; i++) {\n        const q = queries[i];\n        const num = nums[q];\n        \n        const arr = map[num];\n        \n        if (arr.length===1) {\n            res.push(-1);\n            continue;\n        }\n        \n        const idx = lowerbound(q, arr);\n        let a, b;\n        if (idx===0) {\n            a = idx+1;\n            b = arr.length-1;\n        } else if (idx === arr.length-1) {\n            a = 0;\n            b = idx-1;\n        } else {\n            a = idx-1;\n            b = idx+1;\n        }\n        \n        // console.log(num, arr[a], arr[b], arr[idx])\n\n        let curr = min(abs(arr[a]-arr[idx]),abs(arr[a] + n -arr[idx]),  abs(arr[idx]-arr[b]), abs(arr[idx]+n-arr[b]))\n        res.push(curr)\n    }\n    \n    return res;\n};","author":"abawlau","submissionId":"1575129517"},[]]},{"964":[{"id":"964","fileName":"1575129642.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        index_map = defaultdict(list)\n        for i, num in enumerate(nums):\n            index_map[num].append(i)\n        # print(index_map)\n        nearest = [-1] * len(nums)\n        for indices in index_map.values():\n            n = len(indices)\n            if n == 1: continue\n            for i, index in enumerate(indices):\n                next_index = indices[(i+1)%n]\n                prev_index = indices[i-1]\n                if prev_index < index < next_index:\n                    nearest[index] = min(next_index - index, index - prev_index)\n                elif index < prev_index:\n                    nearest[index] = min(next_index - index, len(nums) - prev_index + index)\n                else:\n                    nearest[index] = min(len(nums) - index + next_index, index - prev_index)\n        # print(nearest)\n        return [nearest[i] for i in queries]\n            ","author":"Rajesh S V","submissionId":"1575129642"},[]]},{"965":[{"id":"965","fileName":"1575129501.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        num_to_indexes = defaultdict(list)\n        for i, num in enumerate(nums):\n            num_to_indexes[num].append(i)\n        print(num_to_indexes)\n\n        ret = []\n        for q in queries:\n            # print(\"@@@@@@ q = \", q, \"num = \", nums[q])\n            assert 1 <= len(num_to_indexes[nums[q]])\n            if len(num_to_indexes[nums[q]]) == 1:\n                ret.append(-1)\n                continue\n\n            indexes = num_to_indexes[nums[q]]\n            i = bisect.bisect_left(indexes, q)\n            ret.append(self.min_dist(indexes, i, nums))\n\n        return ret\n\n    def min_dist(self, arr, i, nums):\n        # print(arr, i)\n        n = len(arr)\n        assert 0 <= i <= len(arr) - 1\n\n\n        # next_dist\n        if i == n - 1:\n            next_dist = arr[0] + len(nums) - arr[i]\n        else:\n            next_dist = arr[i+1] - arr[i]\n\n        # prev_dist\n        if i == 0:\n            prev_dist = arr[0] + len(nums) - arr[-1]\n        else:\n            prev_dist = arr[i] - arr[i-1]\n\n        assert 0 < next_dist\n        assert 0 < prev_dist\n        return min(next_dist, prev_dist)\n","author":"kudojp","submissionId":"1575129501"},[]]},{"966":[{"id":"966","fileName":"1575129645.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        // use a vector for each number\n        // 1: 0,2,4\n        // 3: 1,5    // distance to back = size - last + 1st = 7-5+1 = 3\n        // map of index to index\n        // 1,3,1,4,1,3,2 -> 0,0,1,0,...\n        vector<int> indexes(nums.size());\n        unordered_map<int, vector<int>> m;\n        for (int i = 0; i < nums.size(); ++i) {\n            auto& v = m[nums[i]];\n            indexes[i] = v.size();\n            v.push_back(i);\n        }\n        vector<int> ans(queries.size());\n        for (int i = 0; i < queries.size(); ++i) {\n            int idx = queries[i];\n            int indexIntoV = indexes[idx];\n            auto& v = m[nums[idx]];\n            if (v.size() == 1) {\n                ans[i] = -1;\n                continue;\n            }\n            int leftDist = indexIntoV == 0 ? nums.size() - v[v.size() - 1] + v[0] : v[indexIntoV] - v[indexIntoV - 1];\n            int rightDist = indexIntoV == v.size() - 1 ? nums.size() - v[indexIntoV] + v[0] : v[indexIntoV + 1] - v[indexIntoV];\n            ans[i] = min(leftDist, rightDist);\n        }\n        return ans;\n    }\n};","author":"xorcutor","submissionId":"1575129645"},[]]},{"967":[{"id":"967","fileName":"1575129647.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n    int n = nums.size();\n    unordered_map<int,vector<int>>mp;\n    for(int i=0;i<n;i++){\n        mp[nums[i]].push_back(i);\n    }\n    for(auto &p:mp){\n        sort(p.second.begin(),p.second.end());\n    }\n    \n    auto circularDist = [&](int i, int j) -> int {\n        int diff = abs(i - j);\n        return min(diff, n - diff);\n    };\n    \n    vector<int> ans;\n    ans.reserve(queries.size());\n    for (int idx : queries) {\n        int val = nums[idx];\n        const auto &vec = mp[val];\n        if (vec.size() < 2) {\n            ans.push_back(-1);\n            continue;\n        }\n        \n        int best = INT_MAX;\n        auto it = lower_bound(vec.begin(), vec.end(), idx);\n        \n        auto checkCandidate = [&](int candidate) {\n            if (candidate == idx) return;\n            best = min(best, circularDist(idx, candidate));\n        };\n        \n        if (it != vec.end()) {\n            if (*it == idx) {\n                if (it + 1 != vec.end())\n                    checkCandidate(*(it + 1));\n                if (it != vec.begin())\n                    checkCandidate(*(it - 1));\n            } else {\n                checkCandidate(*it);\n                if (it != vec.begin())\n                    checkCandidate(*(it - 1));\n            }\n        } else {\n            checkCandidate(vec.back());\n        }\n        \n        if (vec.front() == idx && vec.size() > 1)\n            checkCandidate(vec[1]);\n        else\n            checkCandidate(vec.front());\n        \n        if (vec.back() == idx && vec.size() > 1)\n            checkCandidate(vec[vec.size() - 2]);\n        else\n            checkCandidate(vec.back());\n        \n        ans.push_back(best);\n    }\n    return ans;\n}\n};","author":"Ch Sunil Patra","submissionId":"1575129647"},[]]},{"968":[{"id":"968","fileName":"1575129662.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), ms = queries.size();\n        vector<int> v(n, -1), res(ms);\n        map<int, vector<int>> m;\n        for(int i = 0; i < n; i++)m[nums[i]].push_back(i);\n        for(auto&[key, val]: m){\n            if(val.size() == 1)continue;\n            int prev = -(n-val.back());\n            val.push_back(val.front()+n);\n            \n            for(int i = 0; i < val.size()-1; i++){\n                v[val[i]] = min(val[i]-prev, val[i+1]-val[i]);\n                prev = val[i];\n            }\n        }\n        for(auto&i: v)cout << i << \" \";\n\n        \n        for(int i = 0; i < ms; i++){\n            res[i] = v[queries[i]];\n        }\n        return res;\n        \n    }\n};","author":"Nehcled","submissionId":"1575129662"},[]]},{"970":[{"id":"970","fileName":"1575129739.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        # coded by Arun Pranav A T\n        n = len(nums)\n        answer = []\n        minidict = {}\n        inddict = defaultdict(list)\n        for i, num in enumerate(nums):\n            inddict[num].append(i)\n        for num, indices in inddict.items():\n            if len(indices) <= 1:\n                for ind in indices:\n                    minidict[(num, ind)] = -1\n            else:\n                sortedind = sorted(indices)\n                for i, ind in enumerate(sortedind):\n                    next = sortedind[(i+1) % len(sortedind)]\n                    prev = sortedind[i-1] if i > 0 else sortedind[-1]\n                    nextdist = min(abs(ind - next), n - abs(ind - next))\n                    prevdist = min(abs(ind - prev), n - abs(ind - prev))               \n                    minidict[(num, ind)] = min(prevdist, nextdist)\n        for q in queries:\n            target = nums[q]\n            answer.append(minidict[(target, q)])\n        return answer","author":"Arun Pranav A T","submissionId":"1575129739"},[]]},{"971":[{"id":"971","fileName":"1575129666.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[]} queries\n * @return {number[]}\n */\nvar solveQueries = function(nums, queries) {\n    n = nums.length;\n    m = new Map();\n    for(let i = 0;i<nums.length;i+=1){\n        const v = nums[i];\n        if(m.has(v)){\n            m.get(v).push(i);\n        } else{\n            m.set(v,[i]);\n        }\n    }\n    M  = new Map();\n    for(const [k, arr] of m.entries()) {\n        for(let i = 0; i < arr.length; i += 1){\n            obj = {};\n            const I = arr[i];\n            if(i - 1 >= 0){\n                obj.left = I-arr[i-1];\n            }\n            if(i+1 < arr.length){\n                obj.right = arr[i+1]-I;\n            }\n            if(i === 0 && arr.length>1){\n                obj.left = I + (n-arr[arr.length-1]);\n            }\n            if(i===arr.length-1 && arr.length>1){\n                obj.right = (n-I) + arr[0];\n            }\n            M.set(I,obj);\n        }\n        \n    }\n    res = [];\n    for(const q of queries){\n        const obj = M.get(q);\n        if(obj.left === undefined || obj.right===undefined){\n            res.push(-1);\n        } else {\n            res.push(Math.min(obj.left,obj.right));\n        }\n    }\n    return res\n};","author":"ItsOver9000","submissionId":"1575129666"},[]]},{"972":[{"id":"972","fileName":"1575129678.txt","sourceCode":"from collections import defaultdict\nimport bisect\n\nclass Solution:\n    def preprocess(self, a):\n        d = defaultdict(list)\n        for i, x in enumerate(a):\n            d[x].append(i)\n        for x in d:\n            d[x].sort()\n        return d\n    \n    def circDist(self, i, j, n):\n        return min(abs(i - j), n - abs(i - j))\n        \n    def solveFunc(self):\n        class FenwickTree:\n            def __init__(self, n):\n                self.f = [0] * (n + 1)\n\n            def prefixSum(self, i):\n                s = 0\n                while i > 0:\n                    s += self.f[i]\n                    i -= (i & -i)\n                return s\n\n            def update(self, i, v):\n                while i < len(self.f):\n                    self.f[i] += v\n                    i += (i & -i)\n\n            def find(self, k):\n                c, ans, pSum = 0, 0, 0\n                for i in range(log2(k), -1, -1):\n                    if self.f[c + (i << i)] + pSum < k:\n                        c += (1 << i)\n                        pSum += self.f[c]\n                return c + 1\n\n    \n    def solveQueries(self, a, b):\n        d = self.preprocess(a)\n        n = len(a)\n        res = []\n        \n        for i in b:\n            x, pos = a[i], d[a[i]]\n            if len(pos) == 1:\n                res.append(-1)\n                continue\n            \n            idx = bisect.bisect_left(pos, i)\n            l = pos[idx - 1] if idx > 0 else pos[-1]\n            r = pos[idx + 1] if idx + 1 < len(pos) else pos[0]\n            \n            res.append(min(self.circDist(i, l, n), self.circDist(i, r, n)))\n        \n        return res\n\n    \n    def zFunction(self,patt, txt):\n        st = patt + \"#\" + txt\n        zArray = [0 for _ in range(len(st))]\n        # here zArray[i] is representing - the longest substring which is also a proper prefix starting at index i.\n        l = 0\n        r = 0\n        for i in range(1, len(st)):\n            # it is the range step which tells us that we have traversed till r and if there are anything we have\n            # calculated then take it. take example ababadababae for better understanding\n            if r >= i:\n                zArray[i] = min(r - i + 1, zArray[i - l])\n\n            # it is just brute forcing to increase the count\n            while i + zArray[i] < len(st) and st[zArray[i]] == st[zArray[i] + i]:\n                zArray[i] += 1\n            # it is setting our l and r\n            if zArray[i] + i - 1 > r:\n                l = i\n                r = i + zArray[i] - 1\n            # return the count of pattern in the string text\n        return zArray.count(len(patt))\n\n    def kmp(self, txt, patt):\n        newString = patt + '#' + txt\n        freqCount = 0\n        freqArray = [0 for _ in range(len(newString))]\n        # here freqArray[i] is representing the length of longest proper prefix which is also proper suffix ending at index i.\n        i = 1\n        length = 0\n        while i < len(newString):\n            if newString[i] == newString[length]:\n                length += 1\n                freqArray[i] = length\n                i += 1\n            else:\n                if length > 0:\n                    length = freqArray[length - 1]\n                else:\n                    freqArray[i] = 0\n                    i += 1\n        for i in freqArray:\n            if i == len(patt):\n                freqCount += 1\n        return freqCount\n    \n    def countVisibleTowers(self, h):\n        def nsr(a):\n            ans, stk = [], []\n            for i in range(len(a) - 1, -1, -1):\n                while stk and stk[-1][1] <= a[i]:\n                    stk.pop()\n                ans.append(len(a) if not stk else stk[-1][0])\n                stk.append((i, a[i]))\n            return ans[::-1]\n        \n        def nsl(a):\n            ans, stk = [], []\n            for i in range(len(a)):\n                while stk and stk[-1][1] <= a[i]:\n                    stk.pop()\n                ans.append(-1 if not stk else stk[-1][0])\n                stk.append((i, a[i]))\n            return ans\n        \n        l, r = nsl(h), nsr(h)\n        return [(i - l[i] - 1 + r[i] - i - 1) for i in range(len(h))]\n","author":"4bP7qaO8Qi","submissionId":"1575129678"},[]]},{"973":[{"id":"973","fileName":"1575129848.txt","sourceCode":"class Solution {\n// #define int long long int\n#define double long double\n#define f(i,a,b) for(int i=a;i<b;i++)\n#define pb push_back\n#define pii pair<int, int>\n#define vi vector<int>\n#define vpi vector<pii>\n#define si set<int>\n#define spi set<pii>\n#define all(v) v.begin(), v.end()\n#define umpi unordered_map<int, int>\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        unordered_map<int,vi> pos;\n        int n=nums.size(),m=q.size();\n        for(int i=0;i<n;i++){\n            pos[nums[i]].pb(i);\n        }\n        for(auto &p: pos){\n            sort(all(p.second));\n        }\n        vi ans(m,-1);\n        for(int i=0;i<m;i++){\n            int idx=q[i],x=nums[idx];\n            if(pos[x].size()==1){\n                ans[i]=-1;\n                continue;\n            }\n            auto &v=pos[x];\n            int loc=lower_bound(all(v),idx)-v.begin();\n            int l=v[(loc-1+v.size())%v.size()];\n            int r=v[(loc+1)%v.size()];\n            int d1=abs(idx-l),d2=abs(idx-r);\n            ans[i]=min({d1,n-d1,n-d2,d2});\n        }\n        return ans;\n    }\n};","author":"Aditya Raj","submissionId":"1575129848"},[]]},{"975":[{"id":"975","fileName":"1575129870.txt","sourceCode":"// Jai shree ram \nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& v, vector<int>& q) {\n        int n = v.size();\n        int m = q.size();\n        vector<int> ans;\n        unordered_map<int, vector<int>> mp;\n        for(int i = 0; i < n; i++)\n        {\n            mp[v[i]].push_back(i);\n        }\n\n        for(auto &it: q)\n        {\n            int id = it;\n            int ele = v[id];\n            if (mp[ele].size() == 1) \n            {\n                ans.push_back(-1);\n            }\n            else \n            {\n                int pos = lower_bound(mp[ele].begin(), mp[ele].end(), id) - mp[ele].begin();\n                int sz = mp[ele].size();\n                int piche, aage;\n\n                if (pos == 0)\n                {\n                    piche = mp[ele].back();\n                    aage = mp[ele][1];\n                }\n                else if (pos == sz - 1)\n                {\n                    piche = mp[ele][pos - 1];\n                    aage = mp[ele][0];\n\n                    // cout << ele <<  \"  \" << piche << \" \" << aage <<\" \"  << pos << 'n';\n                }\n                else \n                {\n                    piche = mp[ele][pos - 1];\n                    aage = mp[ele][pos + 1];\n                }\n\n                // int d1;\n                // int d2;\n\n                // if (piche < id)\n                // {\n                //     d1 = abs(id - piche);\n                // }\n                // else \n                // {\n                //     int x1 = id + (n - piche);\n                //     int x2 = abs(id - piche);\n                //     d1 = min(x1, x2);\n                // }\n\n                // if (aage < id)\n                // {\n                //     int x1 = (n - id) + aage;\n                //     int x2 = abs(id - aage);\n                //     d2 = min(x1, x2);\n                // }\n                // else \n                // {\n                //     d2 = abs(id - aage);\n                // }\n\n                int d1 = min(abs(id - piche), n - abs(id - piche));\n                int d2 = min(abs(id - aage), n - abs(id - aage));\n                ans.push_back(min(d1, d2));\n            \n                // ans.push_back(min(d1, d2));    \n            }\n        }\n\n        return ans;\n    \n    }\n};","author":"Ajay Bansal","submissionId":"1575129870"},[]]},{"976":[{"id":"976","fileName":"1575129934.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> mp;\n        int n = nums.size();\n        for (int i=0; i<n; i++)mp[nums[i]].push_back(i);\n        vector<int> ans;\n        for (auto i:queries){\n            int m = mp[nums[i]].size();\n            if (m == 1)ans.push_back(-1);\n            else {\n                int idx = lower_bound(mp[nums[i]].begin(), mp[nums[i]].end(), i) - mp[nums[i]].begin();\n                if (idx == 0){\n                    ans.push_back(min(mp[nums[i]][1] - i, n - mp[nums[i]].back() + i));\n                }\n                else if (idx == m-1){\n                    ans.push_back(min(i-mp[nums[i]][m-2], n- i + mp[nums[i]][0]));\n                }\n                else {\n                    ans.push_back(min(mp[nums[i]][idx+1] - i, i - mp[nums[i]][idx-1]));\n                }\n                //cout << i << \" \" << idx << \" \" << ans.back() << \"n\";\n            }\n        }\n        return ans;\n    }\n};","author":"gammadelta","submissionId":"1575129934"},[{"id":"1265","similarity":0.71,"totOverlap":142,"longestOverlap":16}]],"1265":[{"id":"1265","fileName":"1575137345.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>>mp;\n        int n = nums.size();\n        vector<int>ans;\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        for(int i : queries){\n            if(mp[nums[i]].size()==1){\n                ans.push_back(-1);\n            }else{\n                auto b = upper_bound(mp[nums[i]].begin(),mp[nums[i]].end(),i);\n                auto c = lower_bound(mp[nums[i]].begin(),mp[nums[i]].end(),i);\n                int val1 = b-mp[nums[i]].begin(),val2 = c-mp[nums[i]].begin();\n                if(val2==0){\n                    int v = n-mp[nums[i]].back()+i;\n                    ans.push_back(min(mp[nums[i]][val1]-i,v));\n                }else if(b==mp[nums[i]].end()){\n                    int v = n-i+mp[nums[i]][0];\n                    ans.push_back(min(i-mp[nums[i]][val2-1],v));\n                }else{\n                    ans.push_back(min(mp[nums[i]][val1]-i,i-mp[nums[i]][val2-1]));\n                }\n            }\n        }\n        return ans;\n    }\n};","author":"Dhanush krishna","submissionId":"1575137345"},[{"id":"976","similarity":0.71,"totOverlap":142,"longestOverlap":16}]]},{"979":[{"id":"979","fileName":"1575129981.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        // unordered_map<int,int> dis;\n        unordered_map<int,int> mp;\n        for (int x: nums) mp[x] = -1;\n        int n = nums.size();\n        for (int i=0; i<n; i++)\n            nums.push_back(nums[i]);\n        vector<int> dis(nums.size(), -1);\n        \n        for (int i=0; i<nums.size(); i++) {\n            if (mp[nums[i]] == -1) {\n                mp[nums[i]] = i;\n            } else {\n                int last = mp[nums[i]];\n                dis[i] = i - last;\n                if (dis[last] == -1) {\n                    dis[last] = i - last;\n                } else {\n                    dis[last] = min(dis[last], i - last);\n                }\n                mp[nums[i]] = i;\n            }\n        }\n        vector<int> ans;\n        for (int q: queries) {\n            int a = dis[q], b = dis[q+n];\n            if (a == n && b == n)\n                ans.push_back(-1);\n            else\n                ans.push_back(min(a,b));\n            // ans.push_back(dis[q] == n ? -1 : dis[q]);\n        }\n        return ans;\n    }\n};","author":"Shannon Lis","submissionId":"1575129981"},[]]},{"980":[{"id":"980","fileName":"1575129993.txt","sourceCode":"class Solution {\npublic:\n    int n;\n\n    int shortestDistance(set<int>& indices, int targetIdx, int n) {\n        if (indices.empty()) return -1; \n        int minDist = INT_MAX;\n        auto it = indices.lower_bound(targetIdx);\n        if (it != indices.end()) {\n            minDist = min(minDist, abs(*it - targetIdx));\n        }\n        if (it != indices.begin()) {\n            minDist = min(minDist, abs(*prev(it) - targetIdx));\n        }\n        if (!indices.empty()) {\n            minDist = min(minDist, abs(*indices.begin() + n - targetIdx));\n            minDist = min(minDist, abs(targetIdx + n - *indices.rbegin()));\n        }\n\n        return minDist;\n    }\n\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, set<int>> alpha; \n        n = nums.size();\n        for (int i = 0; i < n; i++) {\n            alpha[nums[i]].insert(i);\n        }\n\n        vector<int> answer;\n        for (int x : queries) {\n            int targetNum = nums[x];\n            set<int>& indices = alpha[targetNum];\n\n            indices.erase(x);\n\n            int result = shortestDistance(indices, x, n);\n            answer.push_back(result == INT_MAX ? -1 : result);\n\n            indices.insert(x);\n        }\n        return answer;\n    }\n};","author":"Aashutosh Singh","submissionId":"1575129993"},[]]},{"981":[{"id":"981","fileName":"1575129973.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int,vector<int>>mp;\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        map<pair<int,int>,int>mpp;\n        for(auto i:mp){\n            if(i.second.size()==1){\n                mpp[{i.first,i.second[0]}] = -1;\n                continue;\n            }\n            int x = n-i.second[i.second.size()-1];\n            int y = i.second[0];\n            for(int j=0;j<i.second.size();j++){\n                if(j>0&&j<i.second.size()-1){\n                    mpp[{i.first,i.second[j]}]=min(i.second[j]-i.second[j-1],i.second[j+1]-i.second[j]);\n                }\n                else if(j==0){\n                    mpp[{i.first,i.second[j]}]=min( (i.second[j+1]-i.second[j]) , x+y);\n                }\n                else{\n                    mpp[{i.first,i.second[j]}]=min(i.second[j]-i.second[j-1],x+y);\n                }\n            }\n        }\n        vector<int>ans;\n        for(auto i:queries){\n            int ele = nums[i];\n            int ind = i;\n            ans.push_back(mpp[{ele,ind}]);\n        }\n        return ans;\n    }\n};","author":"20je0056","submissionId":"1575129973"},[]]},{"982":[{"id":"982","fileName":"1575129990.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> m;\n        int n = nums.size();\n        vector<int> ans(queries.size());\n\n        for (int i = 0; i < n; i++) {\n            m[nums[i]].push_back(i);\n        }\n\n        for (int i = 0; i < queries.size(); i++) {\n            if (queries[i] < 0 || queries[i] >= n) {\n                ans[i] = -1;\n                continue;\n            }\n\n            int x = nums[queries[i]];\n            if (m[x].size() == 1) {\n                ans[i] = -1;\n                continue;\n            }\n\n            int j = lower_bound(m[x].begin(), m[x].end(), queries[i]) - m[x].begin();\n            int sz = m[x].size();\n            int left, right;\n\n            if (j == 0) {\n                left = m[x][j] + (n - 1) - m[x][sz - 1]+1;\n            } else {\n                left = m[x][j] - m[x][j - 1];\n            }\n\n            if (j == sz - 1) {\n                right = (n - 1) - m[x][j] + m[x][0]+1;\n            } else {\n                right = m[x][j + 1] - m[x][j];\n            }\n\n            ans[i] = min(left, right);\n        }\n        return ans;\n    }\n};\n","author":"Pratik Priyam","submissionId":"1575129990"},[]]},{"983":[{"id":"983","fileName":"1575130020.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int>ret(queries.size());\n        map<int,vector<int>>mp;\n        for(int i=0;i<nums.size();++i){\n            mp[nums[i]].push_back(i);\n            mp[nums[i]].push_back(i+nums.size());\n        }\n        for(auto &[_,vec]:mp) sort(vec.begin(),vec.end());\n        for(int i=0;i<queries.size();++i){\n            int a=queries[i],b=a+nums.size();\n            if(mp[nums[queries[i]]].size()==2) {\n                ret[i]=-1;\n                continue;\n            }\n            int j=lower_bound(mp[nums[queries[i]]].begin(),mp[nums[queries[i]]].end(),a)-mp[nums[queries[i]]].begin();\n            int k=lower_bound(mp[nums[queries[i]]].begin(),mp[nums[queries[i]]].end(),b)-mp[nums[queries[i]]].begin();\n            if(j==0){\n                ret[i]=mp[nums[queries[i]]][j+1]-a;\n            } else {\n                ret[i]=min(mp[nums[queries[i]]][j+1]-a,a-mp[nums[queries[i]]][j-1]);\n            }\n            if(k==(mp[nums[queries[i]]].size()-1)){\n                ret[i]=min(ret[i],b-mp[nums[queries[i]]][k-1]);\n            } else {\n                ret[i]=min(ret[i],min(mp[nums[queries[i]]][k+1]-b,b-mp[nums[queries[i]]][k-1]));\n            }\n        }\n        return ret;\n    }\n};","author":"ads169573","submissionId":"1575130020"},[]]},{"985":[{"id":"985","fileName":"1575130053.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& que) {\n        int mx = 0;\n        for (int i : a) {\n            mx = max(i, mx);\n        }\n        \n        int n = a.size();\n        vector<int> nxt(n, -1);\n        vector<int> prv(n, -1);\n        \n        vector<int> cur(mx + 1, -1);\n        for (int i = 0; i < n; i++) {\n            cur[a[i]] = i;\n        }\n        for (int i = 0; i < n; i++) {\n            if (cur[a[i]] != i) {\n                prv[i] = cur[a[i]];\n            }\n            cur[a[i]] = i;\n        }\n\n        cur = vector<int>(mx + 1, -1);\n        for (int i = n - 1; i >= 0; i--) {\n            cur[a[i]] = i;\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            if (cur[a[i]] != i) {\n                nxt[i] = cur[a[i]];\n            }\n            cur[a[i]] = i;\n        }\n\n        auto cmp = [&] (int x, int y) -> int {\n            if (y < x) {\n                swap(x, y);\n            }\n            return min(y - x, x + n - y);\n        };\n        vector<int> ans(que.size(), -1);\n        for (int i = 0; i < (int)que.size(); i++) {\n            int x = que[i];\n            if (nxt[x] != -1) {\n                ans[i] = cmp(nxt[x], que[i]);\n            }\n            if (prv[x] != -1) {\n                ans[i] = min(ans[i], cmp(prv[x], que[i]));\n            }\n        }\n        return ans;\n    }\n};","author":"Dang Nguyen Bao","submissionId":"1575130053"},[]]},{"987":[{"id":"987","fileName":"1575130128.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        unordered_map<int,vector<int>> mp;\n        int n = nums.size();\n        for(int i = 0; i < n; ++i) {\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        int cnt = 0;\n        for(auto i: q) {\n            if(mp[nums[i]].size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            int idx = lower_bound(mp[nums[i]].begin(),mp[nums[i]].end(), i) - mp[nums[i]].begin();\n            int left = idx - 1, right = idx + 1;\n            int val1 = 0,val2 = 0;\n            if(left == -1) {\n                val1 += mp[nums[i]][idx];\n                val1 += n - mp[nums[i]].back();\n            } else {\n                val1 += mp[nums[i]][idx] - mp[nums[i]][left];\n            }\n            if(right == mp[nums[i]].size()) {\n                val2 += n - mp[nums[i]].back();\n                val2 += mp[nums[i]][0];\n            }else{\n                val2 += mp[nums[i]][right] - mp[nums[i]][idx];\n            }\n            ans.push_back(min(val1,val2));\n        }\n        return ans;\n    }\n};","author":"Chandraveer Singh","submissionId":"1575130128"},[]]},{"989":[{"id":"989","fileName":"1575130215.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n    map<int,vector<int>> occur;\n    map<int,int> index_to_index;\n    int n = nums.size();\n    for(int i = 0;i<n;i++){\n        index_to_index[i] = occur[nums[i]].size();\n        occur[nums[i]].push_back(i);\n    };\n    int q = queries.size();\n    for(int i = 0;i<q;i++){\n        int idx = queries[i];\n        int val = nums[idx];\n        // cout<<\"idx is \"<<idx<<\" and val is \"<<val<<endl;\n        int new_idx = index_to_index[idx];\n        //find the closest \n        if(occur[val].size() == 1){\n            queries[i] = -1;\n            continue;\n        }\n        else{\n            //first one \n            int prev_idx = new_idx != 0 ? new_idx -1 : occur[val].size()-1; \n            int idx1 = occur[val][prev_idx];\n            // cout<<\"idx1 = \"<<idx1<<endl;\n            int dist1;\n            if(idx1<idx){\n                dist1 = idx - idx1;\n            }\n            else{\n                dist1 = n - abs(idx - idx1);\n            };\n            //next one\n            int next_idx = new_idx != (occur[val].size() -1) ? new_idx+1 : 0;\n            int idx2 = occur[val][next_idx];\n            int dist2 = (idx2 - idx);\n            if(idx2<idx){\n                dist2 = n - abs(dist2);\n            };\n            // cout<<\"idx2 = \"<<idx2<<endl;\n            queries[i] = min(dist1,dist2);\n        }\n            \n    };\n        return queries;\n    \n\n        \n    }\n};","author":"Advaita Soni","submissionId":"1575130215"},[]]},{"990":[{"id":"990","fileName":"1575130171.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> ans(n, 0);\n        unordered_map <int, deque<int>> leftmost;\n        unordered_map <int, deque<int>> rightmost;\n        for(int i = nums.size() - 1; i >= 0; i--) {\n            rightmost[nums[i]].push_front(i);\n        }\n        for(int i = 0; i < nums.size(); i++) {\n            // remove this element from rightmost\n            rightmost[nums[i]].pop_front();\n            \n            // now check the size of this queue\n            if (!rightmost[nums[i]].size() && !leftmost[nums[i]].size()) {\n                ans[i] = -1;\n            }\n            else {\n                int leftdist = INT_MAX;\n                if (leftmost[nums[i]].size()) leftdist = min(i - leftmost[nums[i]].front(), n + leftmost[nums[i]].back() - i);            \n                int rightdist = INT_MAX;\n                if (rightmost[nums[i]].size()) rightdist = min(rightmost[nums[i]].front() - i, n + i - rightmost[nums[i]].back());\n                int dist = min(leftdist, rightdist);\n                ans[i] = dist;\n            }\n\n            leftmost[nums[i]].push_front(i);\n        }\n        vector<int> q;\n        for(int i = 0; i < queries.size(); i++) {\n            q.push_back(ans[queries[i]]);\n        }\n        return q;\n    }\n};","author":"Vikrant Dewngan","submissionId":"1575130171"},[]]},{"991":[{"id":"991","fileName":"1575130098.txt","sourceCode":"class Solution {\n    func solveQueries(_ nums: [Int], _ queries: [Int]) -> [Int] {\n        let n = nums.count\n        let nums = nums + nums\n        var pos = [Int: Int](), prepos = [Int: Int]()\n        var pp = [Int](repeating: 1000000, count: nums.count)\n        var pre = [Int](repeating: 1000000, count: nums.count)\n        for i in stride(from: nums.count-1, through: 0, by: -1) {\n            if let p = pos[nums[i]] {\n                pp[i] = p\n            }\n            pos[nums[i]] = i\n        }\n        \n        for i in stride(from: 0, to: nums.count, by: 1) {\n            if let p = prepos[nums[i]] {\n                pre[i] = p\n            }\n            prepos[nums[i]] = i\n        }\n        \n        var res = [Int]()\n        for q in queries {\n            var c1 = 1000000//pp[q] - q\n            var c2 = 1000000//pre[q]\n            if abs(pp[q] - q) != n {\n                c1 = abs(pp[q] - q)\n            }\n            if abs(pre[q+n] - (q+n)) != n {\n                c2 = abs(pre[q+n] - (q+n))\n            }\n            if min(c1,c2) == 1000000 {\n                res.append(-1)\n            } else {\n                res.append(min(c1,c2))\n            }\n            \n        }\n        return res\n    }\n}\n","author":"Safari1291","submissionId":"1575130098"},[]]},{"992":[{"id":"992","fileName":"1575130241.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int len = nums.size();\n        unordered_map<int,int> nmap;\n        vector<int> lmap = vector<int>(len,-1);\n        vector<int> rmap = vector<int>(len,-1);\n        for(int i = 0 ; i < nums.size() ; i++) {\n            int n = nums[i];\n            if(nmap.contains(n)) lmap[i] = i-nmap[n];\n            nmap[n] = i;\n        }\n        for(int i = 0 ; i < nums.size() ; i++) {\n            int n = nums[i];\n            if(lmap[i] == -1){\n                if(nmap[n]!=i) lmap[i] = len-nmap[n]+i;\n            }\n            // printf(\"lmap[%d] = %dn\",n,lmap[i]);\n        }\n        nmap.clear();\n        for(int i = len-1 ; i >= 0 ; i--) {\n            int n = nums[i];\n            if(nmap.contains(n)) rmap[i] = nmap[n]-i;\n            nmap[n] = i;\n        }\n        for(int i = len-1 ; i >= 0 ; i--) {\n            int n = nums[i];\n            if(rmap[i] == -1){\n                if(nmap[n]!=i) rmap[i] = len+nmap[n]-i;\n            }\n            // printf(\"rmap[%d] = %dn\",n,rmap[i]);\n        }\n        vector<int> rst;\n        for(int q : queries){\n            rst.push_back(min(rmap[q],lmap[q]));\n        }\n        return rst;\n    }\n};","author":"Adas","submissionId":"1575130241"},[]]},{"278":[{"id":"278","fileName":"1575109161.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        int n = a.size();\n        unordered_map<int, vector<int>> mp;\n        \n        for (int i = 0; i < n; i++) {\n            mp[a[i]].push_back(i);\n        }\n        \n        vector<int> ans;\n        \n        for (int it : q) {\n            int num = a[it];\n            vector<int>& temp = mp[num];\n            \n            if (temp.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            \n            auto pos = lower_bound(temp.begin(), temp.end(), it);\n            int up = INT_MAX, lo = INT_MAX;\n            \n            if (pos != temp.begin()) {\n                lo = it - *(prev(pos));\n            } else {\n                lo = it + n - temp.back();\n            }\n            \n            if (pos != temp.end() && pos != temp.end() - 1) {\n                up = *(next(pos)) - it;\n            } else {\n                up = temp.front() + n - it;\n            }\n            \n            ans.push_back(min(up, lo));\n        }\n        \n        return ans;\n    }\n};\n","author":"am_607","submissionId":"1575109161"},[{"id":"278","similarity":0.7261146496815286,"totOverlap":114,"longestOverlap":29}]],"993":[{"id":"993","fileName":"1575130411.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> val2pos;\n        for(int i = 0; i < n; i++) {\n            val2pos[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(int index: queries) {\n            auto& pos = val2pos[nums[index]];\n            if(pos.size() < 2) {\n                ans.push_back(-1);\n                continue;\n            }\n            auto itl = lower_bound(pos.begin(), pos.end(), index);\n            auto itr = upper_bound(pos.begin(), pos.end(), index);\n            int mn = 0x3f3f3f3f;\n            if(itl != pos.begin()) {\n                itl--;\n                mn = min(mn, index - (*itl));\n            }else {\n                mn = min(mn, n - pos.back() + index);\n            }\n            if(itr != pos.end()) {\n                mn = min(mn, (*itr) - index);\n            }else {\n                mn = min(mn, n - index + pos[0]);\n            }\n            ans.push_back(mn);\n        }\n        return ans;\n    }\n};","author":"pein531","submissionId":"1575130411"},[{"id":"1889","similarity":0.700507614213198,"totOverlap":138,"longestOverlap":11},{"id":"1093","similarity":0.7195121951219512,"totOverlap":118,"longestOverlap":26},{"id":"1093","similarity":0.7261146496815286,"totOverlap":114,"longestOverlap":29}]],"1093":[{"id":"1093","fileName":"1575132966.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> indexMap;\n\n        // Step 1: Store indices of each number in a hashmap\n        for (int i = 0; i < n; i++) {\n            indexMap[nums[i]].push_back(i);\n        }\n\n        vector<int> result;\n        for (int q : queries) {\n            int value = nums[q];\n            auto& indices = indexMap[value];\n\n            // If there's only one occurrence, return -1\n            if (indices.size() == 1) {\n                result.push_back(-1);\n                continue;\n            }\n\n            // Binary search to find closest indices\n            auto it = lower_bound(indices.begin(), indices.end(), q);\n            int minDist = n;\n            \n            // Get previous index\n            if (it == indices.begin()) {\n                minDist = min(minDist, q+n-indices.back());                \n            } else {\n                minDist = min(minDist, q-*(it - 1));                \n            }\n\n            // Get next index\n            if ((it+1) == indices.end()) {\n                minDist = min(minDist, indices.front()+n-q);\n            } else {\n                minDist = min(minDist, *(it + 1)- q);                \n            }\n\n            result.push_back(minDist);\n        }\n\n        return result;\n    }\n};","author":"Santosh Kumar Singh","submissionId":"1575132966"},[{"id":"993","similarity":0.7195121951219512,"totOverlap":118,"longestOverlap":26}]],"1889":[{"id":"1889","fileName":"611248084.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int q = queries.size(), n = nums.size();\n        vector<int> res;\n        map<int, vector<int>> mp;\n        for(int i = 0; i < nums.size(); i ++) {\n            mp[nums[i]].push_back(i);\n            mp[nums[i]].push_back(i + n);\n        }\n        for(auto &[u, v] : mp) {\n            ranges::sort(v);\n        }\n        for(auto id : queries) {\n            auto &v = mp[nums[id]];\n            if(v.size() == 2) {\n                res.push_back(-1);\n                continue;\n            }\n            int mn = 1e8;\n            auto h = upper_bound(v.begin(), v.end(), id);\n            auto l = (lower_bound(v.begin(), v.end(), id));\n            if(h != v.end()) {\n                mn = min(mn, *h - id);\n            }\n            auto hh = upper_bound(v.begin(), v.end(), id + n);\n            auto ll = (lower_bound(v.begin(), v.end(), id + n));\n            if(hh != v.end()) {\n                mn = min(mn, *hh - id - n);\n            }\n            if(ll != v.end()) mn = min(mn, id + n - *prev(ll));\n            res.push_back(mn);\n        }\n        return res;\n    }\n};","author":"zouyu","submissionId":"611248084"},[{"id":"993","similarity":0.700507614213198,"totOverlap":138,"longestOverlap":11}]]},{"995":[{"id":"995","fileName":"1575130329.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        firstOccur = {}\n        recentOccur = {}\n        rtl = [0] * len(nums)\n\n        for i, v in enumerate(nums):\n            if v not in firstOccur:\n                firstOccur[v] = i\n            else:\n                rtl[recentOccur[v]] = i - recentOccur[v]\n            recentOccur[v] = i\n\n        for key in firstOccur:\n            rtl[recentOccur[key]] = len(nums) - recentOccur[key] + firstOccur[key]\n\n        firstOccur = {}\n        recentOccur = {}\n        ltr = [0] * len(nums)\n\n        for i in range(len(nums) - 1, -1, -1):\n            v = nums[i]\n            if v not in firstOccur:\n                firstOccur[v] = i\n            else:\n                ltr[recentOccur[v]] = recentOccur[v] - i \n            recentOccur[v] = i\n\n        for key in firstOccur:\n            ltr[recentOccur[key]] = len(nums) - firstOccur[key] + recentOccur[key]\n        \n\n        ans = []\n\n        for q in queries:\n            tmp = min(ltr[q], rtl[q])\n            ans.append(tmp if tmp != len(nums) else -1)\n\n        return ans","author":"syji","submissionId":"1575130329"},[]]},{"996":[{"id":"996","fileName":"1575130338.txt","sourceCode":"class Solution {\npublic:\nvector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n    int n = nums.size();\n    map<int, vector<int>> mp;\n    \n    for (int i = 0; i < n; i++) {\n        mp[nums[i]].push_back(i);\n    }\n\n    vector<int> v(n, -1);\n    \n    for (auto &iter : mp) {\n        int len = iter.second.size();\n        for (int i = 0; i < len; i++) {\n            if (len == 1) continue;\n\n            int left = (i - 1 + len) % len;\n            int right = (i + 1) % len;\n\n            \n            int t1 , t2 ; \n            if(iter.second[left] > iter.second[i]){\n                t1 = n  - abs(iter.second[left] - iter.second[i]) ; \n            }\n            else{\n                t1 = iter.second[i] - iter.second[left] ; \n            }\n\n            if(iter.second[right] < iter.second[i]){\n                t2 = n - abs(iter.second[right] - iter.second[i]) ; \n            }\n            else{\n                t2 = abs(iter.second[right] - iter.second[i]) ; \n            }\n\n            v[iter.second[i]] = min(t1, t2);\n        }\n    }\n\n    // print(v) ; \n\n    int q = queries.size();\n    vector<int> ans(q, -1);\n    for (int i = 0; i < q; i++) {\n        ans[i] = v[queries[i]];\n    }\n\n    return ans;\n}\n};","author":"Abhishek12115047","submissionId":"1575130338"},[{"id":"1232","similarity":0.7081339712918661,"totOverlap":148,"longestOverlap":14}]],"1232":[{"id":"1232","fileName":"1575136399.txt","sourceCode":"class Solution {\npublic:\n\n    unordered_map<int, vector<int>> m;\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int N=nums.size();\n        vector<int> dis(N, -1);\n        for(int i=0;i<N;i++){\n            m[nums[i]].push_back(i);\n        }\n\n        for(auto it: m){\n            int n = it.second.size();\n            if(n>1){\n                for(int i=0;i<n;i++){\n                    int left = (i-1+n)%n;\n                    int right = (i+1+n)%n;\n                    int left_dis = min (abs(it.second[i] - it.second[left]), N- abs(it.second[i] - it.second[left]));\n                    int right_dis = min(abs(it.second[i] - it.second[right]), N- abs(it.second[i] - it.second[right]));\n                    dis[it.second[i]]= left_dis > right_dis ?right_dis: left_dis;\n                }\n                \n            }\n        }\n        // for(auto it: dis){\n        //     cout << it << ' ';\n        // }\n        \n        for(int& it: q){    \n            it = dis[it];\n        }\n\n        return q;\n    }\n};","author":"Stan","submissionId":"1575136399"},[{"id":"996","similarity":0.7081339712918661,"totOverlap":148,"longestOverlap":14}]]},{"997":[{"id":"997","fileName":"1575130452.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n = q.size();\n        vector<int>ans(n, 0);\n\n        int nn = nums.size();\n        map<int,int>m; // key is number, not index, val is last appear position \n        vector<int> tempAns(nn, INT_MAX);\n        // 1st round, check before and after\n        for(int i = 0; i < nn; ++i) {\n            int num = nums[i];\n            if(m.find(num) == m.end()) {\n                m[num] = i;\n                // cout << \"get idx \" << i << \" num \"<< num << endl;\n            } else {\n                int dis = i - m[num];\n                tempAns[m[num]] = min(tempAns[m[num]], dis);\n                tempAns[i] = dis;\n                m[num] = i;\n            }\n        }\n\n        // for(int i = 0; i < nn; ++i) {\n        //     cout << \"111 get idx \" << i << \" num \"<< tempAns[i] << endl;\n        // }\n        \n        // 2nd round, check circular list\n        for(int i = 0; i < nn; ++i) {\n            if(m[nums[i]] != i) {\n                \n                int dis = abs(i - m[nums[i]]);\n                dis = min(dis, nn-dis);\n                // cout << \"2nd   get chance \" << i << \" diff is \"<< dis << endl;\n                tempAns[i] = min(tempAns[i], dis);\n                tempAns[m[nums[i]]] = min(tempAns[m[nums[i]]], dis);\n            }\n        }\n\n        // for(int i = 0; i < nn; ++i) {\n        //     cout << \"222 get idx \" << i << \" num \"<< tempAns[i] << endl;\n        // }\n\n        // get answer\n        for(int i = 0; i < n; ++i) {\n            ans[i] = tempAns[q[i]] < INT_MAX? tempAns[q[i]]: -1;\n        }\n\n        return ans;\n    }\n};","author":"Jialuo Yuan","submissionId":"1575130452"},[]]},{"998":[{"id":"998","fileName":"1575130455.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        int n=a.size();\n        int m=q.size();\n        map<int,vector<int>> mp;\n        vector<int> ans(m,-1);\n\n        for(int i=0;i<n;i++){\n            mp[a[i]].push_back(i);\n        }\n\n        for(int i=0;i<n;i++){\n            mp[a[i]].push_back(i+n);\n        }\n\n\n        for(int i=0;i<m;i++){\n            int x=a[q[i]];\n            if(!mp.count(x)) continue;\n            vector<int>& v=mp[x];\n            if(v.size()==1) continue;\n            int j=q[i];\n            auto it=upper_bound(v.begin(),v.end(),j);\n            \n            if(it!=v.end()) ans[i]=min(*it-q[i],n+q[i]-*it);\n            \n            \n            it--;\n            if(it!=v.begin()){\n                it--;\n                ans[i]=min(ans[i],q[i]-*it);\n                ans[i]=min(ans[i],n+q[i]-*it);\n            }else{\n                auto it1=prev(v.end());\n                int xx=*it1;\n                xx%=n;\n                ans[i]=min(ans[i],xx-q[i]);\n                \n                ans[i]=min(ans[i],n+q[i]-xx);\n            }\n            if(ans[i]==n||ans[i]==0) ans[i]=-1;\n            if(ans[i]>=1 && ans[i]<n){\n                ans[i]=min(ans[i],n-ans[i]);\n            }\n        }\n        return ans;\n    }\n};","author":"Raghav Mangla","submissionId":"1575130455"},[]]},{"999":[{"id":"999","fileName":"1575130492.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>>mp;\n        map<int,int>f;\n\n        for(int i = 0 ; i < nums.size() ; i ++){\n            mp[nums[i]].push_back(i);\n            f[nums[i]] ++;\n        }\n\n        vector<int>ans;\n\n       for(int i = 0; i < queries.size(); i++) {\n            int it = queries[i];\n            if (f[nums[it]] == 1) {\n                ans.push_back(-1);\n            } else {\n                auto &indices = mp[nums[it]];\n                int len = indices.size();\n                int crr = lower_bound(indices.begin(), indices.end(), it) - indices.begin();\n                int left = (crr - 1 + len) % len;\n                int right = (crr + 1) % len;\n                int distLeft = (indices[crr] - indices[left] + nums.size()) % nums.size();\n                int distRight = (indices[right] - indices[crr] + nums.size()) % nums.size();\n        \n                ans.push_back(min(distLeft, distRight));\n            }\n        }\n\n        return ans;\n    }\n};","author":"Mercer_2","submissionId":"1575130492"},[]]},{"1000":[{"id":"1000","fileName":"1575130435.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int>vec(nums.size(),INT_MAX);\n        map<int,int>mp;\n        int n=nums.size();\n        for(int i=0;i<nums.size();i++)\n            {\n                if(mp.find(nums[i])!=mp.end())\n                    {\n                        int idx=mp[nums[i]];\n                        int k=min(i-idx,n-i+idx);\n                        vec[i]=min(vec[i],k);\n                        vec[idx]=min(vec[idx],k);\n                    }\n                mp[nums[i]]=i;\n            }\n        for(int i=0;i<nums.size();i++)\n            {\n                if(mp.find(nums[i])!=mp.end() and mp[nums[i]]!=i)\n                {\n                    int idx=mp[nums[i]];\n                    int k=min(idx-i,n-idx+i);\n                    vec[i]=min(vec[i],k);\n                    vec[idx]=min(vec[idx],k);\n                    mp.erase(nums[i]);\n                }\n            }\n        vector<int>ans;\n        for(int i=0;i<queries.size();i++)\n            {\n                if(vec[queries[i]]==INT_MAX)ans.push_back(-1);\n                else\n                ans.push_back(vec[queries[i]]);\n            }\n        return ans;\n    }\n};","author":"Palak Shah","submissionId":"1575130435"},[]]},{"1001":[{"id":"1001","fileName":"1575130456.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        cout<<n;\n        for(int i=0;i<n;i++){\n            nums.push_back(nums[i]);\n        }\n        vector<int>um(1000007,-1),um2(1000007,-1);\n        vector<int>pre(n,-1),pre2(n,-1);\n        for(int i=0;i<nums.size();i++){\n             if(i>=n){\n                if(um2[nums[i]]!=-1)\n                pre2[i-n]=i-um2[nums[i]];\n            }\n            um2[nums[i]]=i;\n        }\n        for(int i=nums.size()-1;i>=0;i--){\n            \n            if(i<n){\n                if(um[nums[i]]!=-1)\n                pre[i]=um[nums[i]]-i;\n            }\n            um[nums[i]]=i;\n        }\n        vector<int>ans;\n        for(int i=0;i<queries.size();i++){\n            int q=queries[i];\n            int val=pre[q];\n            int val2=pre2[q];\n            int act;\n            if(val==-1||val==n) act=val2;\n            else if(val2==-1||val2==n) act=val;\n            else act=min(val,val2);\n            if(act!=n)\n            ans.push_back(act);\n            else ans.push_back(-1);\n        }\n        return ans;\n        \n    }\n};","author":"Utkarsh Raghuvanshi","submissionId":"1575130456"},[]]},{"1002":[{"id":"1002","fileName":"1575130568.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for (int i= 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n\n        vector<int> ans;\n        for (auto& i : queries) {\n            auto& vec = mp[nums[i]];\n            int j = lower_bound(begin(vec), end(vec), i) - begin(vec);\n            int m = vec.size();\n            if (m == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            int prev = (j-1+m) % m;\n            int next = (j+1) % m;\n            int d1 = min(abs(i-vec[prev]), abs(n-(abs(i-vec[prev]))));\n            int d2 = min(abs(i-vec[next]), abs(n-abs(i-vec[next])));\n            if (d1 < d2) {\n                ans.push_back(d1);\n            } else {\n                ans.push_back(d2);\n            }\n        }\n        return ans;\n    }\n};","author":"Apurv Chauhan","submissionId":"1575130568"},[]]},{"1003":[{"id":"1003","fileName":"1575130622.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        vector<int> store(n,INT_MAX);\n        unordered_map<int,int> seen;\n        \n        for(int i=0; i<2*n ;i++){\n            int currIdx = i % n;\n            int val = nums[i%n];\n            if(seen.count(val)){\n                int dist = i - seen[val];\n                store[i%n] = min(store[i%n], dist);\n                store[seen[val]%n] = min(store[seen[val]%n], dist);\n            }\n            seen[val] = i;\n        }\n        \n        vector<int> res;\n        \n        for(auto& q : queries){\n            int v = store[q];\n            if(v == n) res.push_back(-1);\n            else res.push_back(v);\n        }\n        return res;\n    }\n};","author":"Pritam Barman","submissionId":"1575130622"},[]]},{"1005":[{"id":"1005","fileName":"1575130447.txt","sourceCode":"#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> mn_dist(n, INT_MAX);\n        unordered_map<int, vector<int>> pos;\n\n        for (int i = 0; i < n; i++) {\n            pos[nums[i]].push_back(i);\n        }\n\n        for (auto& p : pos) {\n            auto& in = p.second;\n            sort(in.begin(), in.end());\n\n            if (in.size() == 1) {\n                mn_dist[in[0]] = -1;\n            }\n            else {\n                int m = in.size();\n                for (int i = 0; i < m; i++) {\n                    int j = (i + 1) % m; \n                    int diff = abs(in[j] - in[i]);\n                    diff = min(diff, n - diff);\n                    mn_dist[in[i]] = min(mn_dist[in[i]], diff);\n                    mn_dist[in[j]] = min(mn_dist[in[j]], diff);\n                }\n            }\n        }\n\n        vector<int> ans;\n        ans.reserve(queries.size());\n        for (int idx : queries) {\n            ans.push_back(mn_dist[idx]);\n        }\n\n        return ans;\n    }\n};","author":"wjhbr","submissionId":"1575130447"},[]]},{"1007":[{"id":"1007","fileName":"1575130619.txt","sourceCode":"class Solution {\n\nint fd(List<int>nums,int len,int target){\n    //print(\"--------------------\");\n    //print(nums);\n    //print(\"$len -- $target\");\n    if(nums.length<=1)return -1;\n    for(int i=0 ; i<nums.length ; i++){\n        if(nums[i]==target){\n            //print(i);\n            if(i==0){\n                return min(len-nums.last+nums[i],nums[i+1]-nums[i]);\n            }\n            else if(i==nums.length-1){\n                return min(nums[i]-nums[i-1],len-nums[i]+nums[0]);\n            }\n            else{\n                return min(nums[i]-nums[i-1],nums[i+1]-nums[i]);\n            }\n        }\n    }\n    return -1;\n}\n  List<int> solveQueries(List<int> nums, List<int> queries) {\n    Map<int,List<int>>mp={};\n      for(int i=0 ; i<nums.length ; i++){\n          if(mp[nums[i]]==null){\n              mp[nums[i]]=[i];\n          }\n          else{\n              mp[nums[i]]!.add(i);\n          }\n      }\n      //print(mp);\n      List<int>op=[];\n      for(int i=0 ; i<queries.length ; i++){\n          op.add(fd(mp[nums[queries[i]]]??[], nums.length, queries[i]));\n      }\n      return op;\n  }\n}","author":"Nguyen Duc","submissionId":"1575130619"},[]]},{"1008":[{"id":"1008","fileName":"1575130664.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int> > Map;\n\t\tint i;\n\t\tint N = nums.size();\n\t\tint M = queries.size();\n\t\tvector<int> Result(M);\n\t\t\n\t\tfor(i = 0; i < N; i++)\n\t\t{\n\t\t\tMap[nums[i]].push_back(i);\n\t\t}\n\t\t\n\t\tfor(i = 0; i < M; i++)\n\t\t{\n\t\t\tint Temp = nums[queries[i]];\n\t\t\t\n\t\t\t//cout << i << \" \" << Temp << \" \" << Map[Temp].size() << endl;\n\t\t\t\n\t\t\tif(Map[Temp].size() == 1)\n\t\t\t{\n\t\t\t\tResult[i] = -1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint Idx = lower_bound(Map[Temp].begin(), Map[Temp].end(), queries[i]) - Map[Temp].begin();\n\t\t\t\tint Target;\n\t\t\t\n\t\t\t\tif(Idx == 0)\n\t\t\t\t{\n\t\t\t\t\tTarget = Map[Temp].back() - queries[i];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tTarget = queries[i] - Map[Temp][Idx - 1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tResult[i] = min(Target, (N - Target));\n\n\t\t\t\tif(Idx == Map[Temp].size() - 1)\n\t\t\t\t{\n\t\t\t\t\tTarget = queries[i] - Map[Temp][0];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tTarget = Map[Temp][Idx + 1] - queries[i];\n\t\t\t\t}\n\n\t\t\t\tResult[i] = min(Result[i], min(Target, (N - Target)));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Result;\n    }\n};","author":"Adam Tai","submissionId":"1575130664"},[]]},{"1009":[{"id":"1009","fileName":"1575130708.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        mp = defaultdict(list)\n        \n        for i in range(n):\n            mp[nums[i]].append(i)\n        \n        for key in mp:\n            mp[key].sort()\n        \n        ans = []\n        \n        for q in queries:\n            num = nums[q]\n            arr = mp[num]\n            \n            if len(arr) == 1:\n                ans.append(-1)\n                continue\n            \n            idx = bisect_left(arr, q)\n            \n            if idx + 1 < len(arr):\n                next_idx = arr[idx + 1]\n            else:\n                next_idx = arr[0]\n            \n            if idx - 1 >= 0:\n                prev_idx = arr[idx - 1]\n            else:\n                prev_idx = arr[-1]\n            \n            pp = min(abs(q - prev_idx), abs(n - (prev_idx - q)))\n            nn = min(abs(q - next_idx), abs(n - (q - next_idx)))\n            \n            ans.append(min(pp, nn))\n        \n        return ans","author":"Rudra Narola","submissionId":"1575130708"},[]]},{"1011":[{"id":"1011","fileName":"1575130727.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dict = defaultdict(list)\n        n = len(nums)\n        for i, x in enumerate(nums):\n            dict[x].append(i)\n        dict2 = {x: inf for x in range(len(nums))}\n        for x in dict:\n            list_ = dict[x]\n            if len(list_) != 1:\n                list_ = dict[x]+[dict[x][0]]\n            for a, b in pairwise(list_):\n                dict2[a] = min(dict2[a], abs(b - a), n - abs(b - a))\n                dict2[b] = min(dict2[b], abs(b - a), n - abs(b - a))\n            \n        return [dict2[x] if dict2[x] != inf else -1 for x in queries]","author":"bayibo","submissionId":"1575130727"},[]]},{"1012":[{"id":"1012","fileName":"1575130751.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        int n = nums.length;\n        \n        for (int i = 0; i < n; i++) {\n            List<Integer> list = map.computeIfAbsent(nums[i], v -> new ArrayList<>());\n            list.add(i);\n        }\n        \n        int qn = queries.length;\n        List<Integer> res = new ArrayList<>();\n        \n        for (int i = 0; i < qn; i++) {\n            int pos = queries[i], k = nums[pos];\n            List<Integer> list = map.get(k);\n            \n            //System.out.println(list);\n            \n            if (list.size() == 1) {\n                res.add(-1);\n            } else {\n                int p = Collections.binarySearch(list, pos);\n                \n                int l = p > 0 ? diff(pos, list.get(p - 1), n) : diff(pos, list.get(list.size() - 1), n);\n                int r = p + 1 < list.size() ? diff(list.get(p + 1), pos, n) : diff(pos, list.get(0), n);\n                \n                //System.out.println(\"p: \" + p + \"; l : \" + l + \"; r: \" + r);\n                \n                res.add(Math.min(l, r));\n            }\n        }\n        \n        return res;\n    }\n    \n    private int diff(int i1, int i2, int n) {\n        int min = Math.min(i1, i2), max = Math.max(i1, i2);\n        return Math.min(max - min, n - (max - min));\n    }\n}","author":"volodymyr_k","submissionId":"1575130751"},[]]},{"1014":[{"id":"1014","fileName":"1575130786.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        hashmap = defaultdict(int)\n        temp = nums + nums\n        res = [float(\"inf\")] * len(nums)\n        n = len(nums)\n        \n        for i in range(len(temp)):\n            if nums[i % n] in hashmap:\n                # print(nums[i % n], i)\n                # print(hashmap)\n                # print(res)\n                if hashmap[nums[i % n]] == i % n:\n                    continue\n\n                \n                j = hashmap[nums[i % n]]\n                valjnjknjk1 = i % n\n                diff = abs(i - j)\n\n                res[i % n] = min(diff, res[i % n])\n                res[j] = min(diff, res[j])\n\n            hashmap[nums[i % n]] = i % n\n\n        adjvndns = []\n        # print(res)\n\n        for num in queries:\n            adjvndns.append(res[num] if res[num] != float(\"inf\") else -1)\n\n        return adjvndns\n\n                \n                \n        ","author":"james Paul","submissionId":"1575130786"},[]]},{"1015":[{"id":"1015","fileName":"1575130894.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& qry) {\n        unordered_map<int,vector<int>> m;\n        int n=nums.size();\n        int q=qry.size();\n        \n        for(int i=0;i<n;i++){\n            m[nums[i]].push_back(i);\n        }\nvector<int> ans(q);\n        for(int i=0;i<q;i++){\n            int ind=qry[i];\n        \n            int index=lower_bound(m[nums[ind]].begin(),m[nums[ind]].end(),ind)-m[nums[ind]].begin();\n            // index++;\n            int diff=INT_MAX;\n            \n            if(index>0){\n                int d=abs(m[nums[ind]][index]-m[nums[ind]][index-1]);\n                d=min(d,n-d);\n                diff=min(diff,d);\n            } \n            \n            if(index<m[nums[ind]].size()-1){\n                int d=abs(m[nums[ind]][index]-m[nums[ind]][index+1]);\n                d=min(d,n-d);\n                diff=min(diff,d);\n            }\n                    // diff=min(diff,abs(m[nums[ind]][index]-m[nums[ind]][index+1]));\n            int d=abs(m[nums[ind]][index]-m[nums[ind]][0]);\n            d=min(d,n-d);\n            if(index!=0) diff=min(diff,d);\n\n            if(index!=m[nums[ind]].size()-1){\n                 d=abs(m[nums[ind]][index]-m[nums[ind]].back());\n                d=min(d,n-d);\n                diff=min(diff,d);\n            }\n            \n            if(diff==INT_MAX) diff=-1;\n            ans[i]=diff;\n        }\n        return ans;\n    }\n};","author":"Abhi_jack","submissionId":"1575130894"},[{"id":"1903","similarity":0.7344398340248963,"totOverlap":177,"longestOverlap":16}]],"1903":[{"id":"1903","fileName":"611250078.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>>mp;\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int>ans;\n        for(auto  i:queries){\n            int a=1000000;\n            if(mp[nums[i]].size()>1){\n                int j=lower_bound(mp[nums[i]].begin(),mp[nums[i]].end(),i)-mp[nums[i]].begin();\n                int b=mp[nums[i]].size();\n                int c=abs(mp[nums[i]][(j+1)%b]-mp[nums[i]][j]);\n                c=min(c,n-c);\n                a=min(a,c);\n                int d=abs(mp[nums[i]][(j+b-1)%b]-mp[nums[i]][j]);\n                d=min(d,n-d);\n                a=min(a,d);\n                //cout<<i<<\"-\"<<a<<endl;\n            }else{\n                a=-1;\n            }\n            ans.push_back(a);\n        }\n        return ans;\n    }\n};","author":"行走天地间","submissionId":"611250078"},[{"id":"1015","similarity":0.7344398340248963,"totOverlap":177,"longestOverlap":16}]]},{"1016":[{"id":"1016","fileName":"1575130816.txt","sourceCode":"class Solution {\n    private int N;\n    \n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        N = nums.length;\n        \n        for (int i = 0; i < N; i++) {\n            map.computeIfAbsent(nums[i], l -> new ArrayList<>()).add(i);\n        }\n        \n        List<Integer> res = new LinkedList<>();\n        \n        for (int q : queries) {\n            List<Integer> indices = map.get(nums[q]);\n            if (indices.size() == 1) {\n                res.addLast(-1);\n            } else {\n                // System.out.println(nums[q]);\n                res.addLast(getDistance(indices, q));\n            }\n        }\n\n        return res;\n    }\n\n    private int getDistance(List<Integer> indices, int keyIdx) {\n        int idx = Collections.binarySearch(indices, keyIdx);\n        // System.out.println(indices + \" \" + keyIdx + \" \" + idx);\n        int size = indices.size();\n        int prevIdx = (idx - 1 + size) % size;\n        int nextIdx = (idx + 1) % size;\n        int prev = indices.get(prevIdx);\n        int next = indices.get(nextIdx);\n        // System.out.println(prevIdx + \" \" + nextIdx);\n        // System.out.println(prev + \" \" + next);\n\n        \n        return Math.min(getMinDiff(prev, keyIdx), getMinDiff(next, keyIdx));\n    }\n\n    private int getMinDiff(int x, int y) {\n        if (x > y) {\n            int temp = x;\n            x = y;\n            y = temp;\n        }\n        return Math.min(y - x, N - y + x);\n    }\n}","author":"aarons_daniel","submissionId":"1575130816"},[]]},{"1017":[{"id":"1017","fileName":"1575130780.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>>mp;\n        int m=0;\n        for(auto &i:nums)\n            {\n                mp[i].push_back(m);\n                m++;\n            }\n        vector<int>a(queries.size());\n        for(int i=0;i<queries.size();i++)\n            {\n                int ans=INT_MAX;\n                if(mp[nums[queries[i]]].size()==1)\n                {\n                    ans=-1;\n                }\n                // for(auto &p:mp[nums[queries[i]]])\n                //     {\n                //         cout<<p<<\" \";\n                //     }\n                // cout<<\"n\";\n               int ind = lower_bound(mp[nums[queries[i]]].begin(), mp[nums[queries[i]]].end(), queries[i]) - mp[nums[queries[i]]].begin();\n                // cout<<\"ind : \"<<ind<<\"n\";\n               if(ind==mp[nums[queries[i]]].size()-1)\n               {\n                   ans=min(ans,mp[nums[queries[i]]][0]+m-mp[nums[queries[i]]][ind]);\n               }else{\n                   ans=min(ans,mp[nums[queries[i]]][ind+1]-mp[nums[queries[i]]][ind]);\n               }\n                       if(ind>0){\n                       ans=min(ans,mp[nums[queries[i]]][ind]-mp[nums[queries[i]]][ind-1]);\n                   }else{\n                           ans=min(ans,mp[nums[queries[i]]][0]+m-mp[nums[queries[i]]][mp[nums[queries[i]]].size()-1]);\n                       }\n                // cout<<ans<<\"n\";\n                a[i]=ans;\n            }\n        return a;\n    }\n};","author":"ky198484","submissionId":"1575130780"},[]]},{"1018":[{"id":"1018","fileName":"1575130917.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        // int n = nums.size();\n        // vector<int> answer(queries.size(), -1);\n        \n        // // For each number, store all its indices\n        // unordered_map<int, vector<int>> indices;\n        // for (int i = 0; i < n; i++) {\n        //     indices[nums[i]].push_back(i);\n        // }\n        \n        // // Process each query\n        // for (int i = 0; i < queries.size(); i++) {\n        //     int queryIndex = queries[i];\n        //     int value = nums[queryIndex];\n            \n        //     // If this value appears only once in the array\n        //     if (indices[value].size() <= 1) {\n        //         continue; // answer[i] already initialized to -1\n        //     }\n            \n        //     // Find the minimum distance\n        //     int minDist = INT_MAX;\n        //     for (int idx : indices[value]) {\n        //         if (idx == queryIndex) continue; // Skip the same index\n                \n        //         // Calculate regular distance\n        //         int regularDist = abs(idx - queryIndex);\n                \n        //         // Calculate circular distance (going the other way around)\n        //         int circularDist = n - regularDist;\n                \n        //         // Take the minimum of the two possible paths\n        //         int currentDist = min(regularDist, circularDist);\n                \n        //         minDist = min(minDist, currentDist);\n        //     }\n            \n        //     answer[i] = minDist;\n        // }\n        \n        // return answer;\n        int n = nums.size();\n        vector<int> answer(queries.size(), -1);\n        \n        // Precompute all occurrences of each value\n        unordered_map<int, vector<int>> indices;\n        for (int i = 0; i < n; i++) {\n            indices[nums[i]].push_back(i);\n        }\n        \n        // Process each query\n        for (int i = 0; i < queries.size(); i++) {\n            int queryIndex = queries[i];\n            int value = nums[queryIndex];\n            \n            const vector<int>& positions = indices[value];\n            \n            // If this value appears only once, answer remains -1\n            if (positions.size() <= 1) {\n                continue;\n            }\n            \n            int minDist = n; // Initialize to maximum possible distance\n            \n            // Binary search to find the queryIndex in the positions array\n            auto it = lower_bound(positions.begin(), positions.end(), queryIndex);\n            int idx = it - positions.begin();\n            \n            // The value must exist at queryIndex\n            if (idx < positions.size() && positions[idx] == queryIndex) {\n                // Check previous element (if exists)\n                if (idx > 0) {\n                    int dist = min(queryIndex - positions[idx-1], \n                                   n - (queryIndex - positions[idx-1]));\n                    minDist = min(minDist, dist);\n                }\n                \n                // Check next element (if exists)\n                if (idx < positions.size() - 1) {\n                    int dist = min(positions[idx+1] - queryIndex, \n                                   n - (positions[idx+1] - queryIndex));\n                    minDist = min(minDist, dist);\n                }\n                \n                // If only two occurrences with the same value, we've already found the answer\n                if (positions.size() > 2) {\n                    // If queryIndex is at first position, check the last position\n                    if (idx == 0) {\n                        int dist = min(positions.back() - queryIndex, \n                                       n - (positions.back() - queryIndex));\n                        minDist = min(minDist, dist);\n                    }\n                    \n                    // If queryIndex is at last position, check the first position\n                    if (idx == positions.size() - 1) {\n                        int dist = min(queryIndex - positions.front(), \n                                       n - (queryIndex - positions.front()));\n                        minDist = min(minDist, dist);\n                    }\n                }\n            }\n            \n            answer[i] = minDist;\n        }\n        \n        return answer;\n    }\n};","author":"MANTEJ SINGH","submissionId":"1575130917"},[]]},{"1019":[{"id":"1019","fileName":"1575130965.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        min_dist = [-1]*n\n\n        last_seen = {}\n\n        for j, num in enumerate(nums):\n            if num in last_seen:\n                # calc dist between and update both\n                i = last_seen[num]\n                dist = min(j-i, n-j+i)\n                min_dist[i] = dist if min_dist[i] == -1 else min(min_dist[i], dist)\n                min_dist[j] = dist\n                \n            last_seen[num] = j\n\n        # Update wrap around numbers\n        for j, num in enumerate(nums):\n            if num in last_seen and last_seen[num] > j:\n                # calc dist between and update both\n                i, j = j, last_seen[num]\n                dist = min(j-i, n-j+i)\n                min_dist[i] = min(min_dist[i], dist)\n                min_dist[j] = min(min_dist[j], dist)\n\n        return [min_dist[i] for i in queries]","author":"KNuggies","submissionId":"1575130965"},[]]},{"1020":[{"id":"1020","fileName":"1575130975.txt","sourceCode":"import bisect\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        from collections import defaultdict\n        index_map = defaultdict(list)\n        for idx, num in enumerate(nums):\n            index_map[num].append(idx)\n        for key in index_map:\n            index_map[key].sort()\n        answer = []\n        for q in queries:\n            value = nums[q]\n            indices = index_map[value]\n            if len(indices) == 1:\n                answer.append(-1)\n                continue\n            pos = bisect.bisect_left(indices, q)\n            k = len(indices)\n            prev_pos = (pos - 1) % k\n            next_pos = (pos + 1) % k\n            j_prev = indices[prev_pos]\n            j_next = indices[next_pos]\n            distance_prev = min(abs(q - j_prev), n - abs(q - j_prev))\n            distance_next = min(abs(q - j_next), n - abs(q - j_next))\n            answer.append(min(distance_prev, distance_next))\n        return answer        ","author":"_hari_18_","submissionId":"1575130975"},[{"id":"1637","similarity":0.7769230769230769,"totOverlap":101,"longestOverlap":13}]],"1637":[{"id":"1637","fileName":"611238666.txt","sourceCode":"from bisect import bisect_left\nfrom collections import defaultdict\n\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        pos_dict = defaultdict(list)\n        for idx, num in enumerate(nums):\n            pos_dict[num].append(idx)\n        for key in pos_dict:\n            pos_dict[key].sort()\n\n        n = len(nums)\n        answer = []\n\n        for q in queries:\n            v = nums[q]\n            pos_list = pos_dict[v]\n            if len(pos_list) == 1:\n                answer.append(-1)\n                continue\n\n            idx =bisect_left(pos_list, q)\n            k = len(pos_list)\n            pre_idx = (idx - 1) % k\n            suc_idx = (idx + 1) % k\n            pre = pos_list[pre_idx]\n            suc = pos_list[suc_idx]\n\n            distance_pre = min(abs(q - pre), n - abs(q - pre))\n            distance_suc = min(abs(q - suc), n - abs(q - suc))\n            min_distance = min(distance_pre, distance_suc)\n            answer.append(min_distance)\n\n        return answer","author":"天大小菜","submissionId":"611238666"},[{"id":"1020","similarity":0.7769230769230769,"totOverlap":101,"longestOverlap":13}]]},{"1021":[{"id":"1021","fileName":"1575130848.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        prev = {}\n        dist = [float('inf')] * n\n        counter = Counter(nums)\n\n        for index in range(n * 2):\n            i = index % n\n            if nums[i] in prev and counter[nums[i]] >= 2:\n                diff = index - prev[nums[i]]\n                if diff < n:\n                    prev_i = prev[nums[i]]\n                    dist[prev_i] = min(dist[prev_i], diff)\n                    dist[i] = min(dist[i], diff)\n            prev[nums[i]] = i\n\n        return [dist[query] if dist[query] != float('inf') else -1 for query in queries]\n            \n        \n\n\"\"\"\n1 3 1 4 1 3 2 1 3 1 4 1 3 2\n\n\"\"\"","author":"Huskat","submissionId":"1575130848"},[]]},{"1022":[{"id":"1022","fileName":"1575131017.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        idx = defaultdict(list)\n        for i, n in enumerate(nums):\n            idx[n].append(i)\n        ans = []\n        for i in queries:\n            v = nums[i]\n            near = math.inf\n            if len(idx[v]) == 1:\n                ans.append(-1)\n                continue\n            ii = bisect.bisect_left(idx[v], i)    #0 2 4\n            if ii == 0:\n                ans.append(min(idx[v][1]-idx[v][0], len(nums)-idx[v][-1]+idx[v][0]))\n            elif ii == len(idx[v])-1:\n                ans.append(min(idx[v][-1]-idx[v][-2], len(nums)-idx[v][-1]+idx[v][0]))\n            else:\n                ans.append(min(idx[v][ii+1]-idx[v][ii], idx[v][ii]-idx[v][ii-1]))\n            \n\n        return ans\n        \n                \n            \n            ","author":"slowoldman","submissionId":"1575131017"},[]]},{"1023":[{"id":"1023","fileName":"1575131058.txt","sourceCode":"class Solution {\npublic:\nvector<int> solveQueries(vector<int> &nums, vector<int> &queries) {\n  unordered_map<int, int> last_seen;\n  for (int i = 0; i < nums.size(); ++i) {\n    last_seen[nums[i]] = i;\n  }\n\n  vector<int> before(nums.size(), -1);\n  vector<int> after(nums.size(), -1);\n\n  for (int i = 0; i < nums.size(); ++i) {\n    before[i] = last_seen[nums[i]];\n    last_seen[nums[i]] = i;\n  }\n\n  last_seen.clear();\n\n  for (int i = nums.size() - 1; i >= 0; --i) {\n    last_seen[nums[i]] = i;\n  }\n\n  for (int i = nums.size() - 1; i >= 0; --i) {\n    after[i] = last_seen[nums[i]];\n    last_seen[nums[i]] = i;\n  }\n\n    /*\n  for (int n : before) {\n    cout << n << \" \";\n  }\n  cout << endl;\n  for (int n : after) {\n    cout << n << \" \";\n  }\n  cout << endl;\n*/\n\n    vector<int> ans;\n  for (int q : queries) {\n    int i = before[q];\n    int j = after[q];\n\n    if (i == j && i == q) {\n        ans.push_back(-1);\n        continue;\n    }\n    int di = q - i;\n    int dj = j - q;\n    if (di <= 0)\n        di += nums.size();\n    if (dj <= 0)\n        dj += nums.size();\n\n    ans.push_back(min(di, dj));\n  }\n\n  return ans;\n}\n\n};","author":"mustart","submissionId":"1575131058"},[]]},{"1024":[{"id":"1024","fileName":"1575131090.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        for(int i = 0; i < nums.size(); i++){\n            if(mp.find(nums[i]) == mp.end())\n                mp[nums[i]] = vector<int>();\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans(queries.size(), -1);\n        for(int i = 0; i < queries.size(); i++){\n            vector<int>& v = mp[nums[queries[i]]];\n            if(v.size() > 1){\n                int val = queries[i];\n                int it = lower_bound(v.begin(), v.end(), val) - v.begin();\n                int res = INT_MAX;\n                if(v[(it+1)%v.size()] < val){\n                    res = min(res, (int)nums.size() - val + v[(it+1)%v.size()]);\n                }\n                else{\n                    res = min(res, v[(it+1)%v.size()] - val);\n                }\n                if(v[(it-1+v.size())%v.size()] > val){\n                    res = min(res, (int)nums.size() - v[(it-1+v.size())%v.size()] + val);\n                }\n                else{\n                    res = min(res, val - v[(it-1+v.size())%v.size()]);\n                }\n                ans[i] = res;\n                // cout << i << \" \" << val << \" \" << it << \" \" << v[(it-1+v.size())%v.size()] << endl;\n                // cout << abs(v[(it+1)%(v.size())] - val) << \" \" <<  abs(v[(it-1+v.size())%(v.size())] - val) << endl;\n            }\n        }\n        return ans;\n    }\n};","author":"Mohammad","submissionId":"1575131090"},[]]},{"1025":[{"id":"1025","fileName":"1575130973.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        indices = {}\n        for i in range(len(nums)):\n            if nums[i] not in indices:\n                indices[nums[i]] = []\n\n            indices[nums[i]].append(i)\n\n        res = []\n        for indx in queries:\n            arr = indices[nums[indx]]\n            n = len(arr)\n            if n == 1:\n                res.append(-1)\n                continue\n\n            left = 0\n            right = n-1\n            while left <= right:\n                mid = (left+right)//2\n                if arr[mid] <= indx:\n                    left = mid+1\n\n                else:\n                    right = mid-1\n                    \n            n = len(nums)\n            diff = float(\"inf\")\n            if left < len(arr) and arr[left] != indx:\n                diff = min(abs(arr[left]-indx), n-arr[left]+indx, n-indx+arr[left-2])\n            \n            if left and arr[left-1] != indx:\n                diff = min(diff, abs(arr[left-1]-indx), n-arr[left-1]+indx, n-indx+arr[left-2])\n\n            if left > 1:\n                diff = min(diff, abs(arr[left-2]-indx), n-arr[left-2]+indx, n-indx+arr[left-2])\n\n            if left < len(arr)-1 and arr[left+1] != indx:\n                diff = min(diff, abs(arr[left+1]-indx), n-arr[left+1]+indx, n-indx+arr[left+1])\n\n            if arr[0] != indx:\n                diff = min(diff, n-indx+arr[0], n-arr[0]+indx)\n\n            if arr[-1] != indx:\n                diff = min(diff, n-indx+arr[-1], n-arr[-1]+indx)\n\n            res.append(diff)\n\n        return res","author":"David Yee","submissionId":"1575130973"},[]]},{"1026":[{"id":"1026","fileName":"1575131105.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int i,j,k,n=nums.size(),m,t;\n        vector<int> left1(n,0),right1(n,0),left2(n,0),right2(n,0);\n        unordered_map<int,int> mp;\n        for(i=0;i<n;i++) {\n            if(mp[nums[i]]>0) {\n                left1[i]=mp[nums[i]];\n            }\n            mp[nums[i]]=i+1;\n        }\n        mp.clear();\n        for(i=0;i<n;i++) {\n            if(mp[nums[i]]>0) {\n                left2[i]=mp[nums[i]];\n            } else {\n                mp[nums[i]]=i+1;\n            }\n        }\n        mp.clear();\n        for(i=n-1;i>=0;i--) {\n            if(mp[nums[i]]>0) {\n                right1[i]=mp[nums[i]];\n            }\n            mp[nums[i]]=i+1;\n        }\n        mp.clear();\n        for(i=n-1;i>=0;i--) {\n            if(mp[nums[i]]>0) {\n                right2[i]=mp[nums[i]];\n            } else {\n                mp[nums[i]]=i+1;\n            }\n        }\n        // for(i=0;i<n;i++) {\n        //     cout<<left1[i]<<\" \"<<left2[i]<<\" \"<<right1[i]<<\" \"<<right2[i]<<\"n\";\n        // }\n        // cout<<\"n\";\n        vector<int> ans;\n        for(i=0;i<queries.size();i++) {\n            k=queries[i];\n            t=INT_MAX;\n            if(left1[k]>0) {\n                t=min(t,k-left1[k]+1);\n            }\n            // cout<<t<<\" \";\n            if(left2[k]>0) {\n                t=min(t,n-k+left2[k]-1);\n            }\n            // cout<<t<<\" \";\n            if(right1[k]>0) {\n                t=min(t,right1[k]-1-k);\n            }\n            // cout<<t<<\" \";\n            if(right2[k]>0) {\n                t=min(t,n-right2[k]+1+k);\n            }\n            // cout<<t<<\"n\";\n            if(t==INT_MAX) {\n                ans.push_back(-1);\n            } else {\n                ans.push_back(t);\n            }\n        }\n        return ans;\n        \n    }\n};","author":"shivamkrghosh","submissionId":"1575131105"},[]]},{"1027":[{"id":"1027","fileName":"1575130849.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        arr = [-1] * len(nums)\n        hashMap = {}\n        length = len(nums)\n        for i in range(len(nums)):\n            num = nums[i]\n\n            if num in hashMap:\n                a = i - hashMap[num][1]\n                b = hashMap[num][0] + length - i\n                arr[i] = min(a, b)\n                hashMap[num][1] = i\n            else:\n                hashMap[num] = [i, i]\n\n        # print(arr)\n        hashMap = {}\n        for i in range(len(nums) - 1, -1, -1):\n            num = nums[i]\n\n            if num in hashMap:\n                a = hashMap[num][0] - i\n                b = i + length - hashMap[num][1]\n                if arr[i] == -1:\n                    arr[i] = min(a, b)\n                else:\n                    arr[i] = min(arr[i], a, b)\n                hashMap[num][0] = i\n            else:\n                hashMap[num] = [i, i]\n\n        # print(arr)\n        ans = []\n        for q in queries:\n            ans.append(arr[q])\n        return ans","author":"Stephen Sun","submissionId":"1575130849"},[]]},{"1029":[{"id":"1029","fileName":"1575131060.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int[][] temp=new int[nums.length][2];\n        for(int[] t:temp)Arrays.fill(t,-1);\n        HashMap<Integer,Integer> hm=new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            if(hm.containsKey(nums[i])){\n                temp[i][0]=hm.get(nums[i]);\n                temp[hm.get(nums[i])][1]=i;\n            }\n            hm.put(nums[i],i);            \n        }\n        for(int i=0;i<nums.length;i++){\n            if(temp[i][0]==-1){\n                temp[i][0]=hm.get(nums[i]);\n                temp[hm.get(nums[i])][1]=i;\n            }          \n        }\n        List<Integer> ls=new LinkedList<>();\n        for(int q:queries){\n            if(temp[q][0]==q){\n                ls.add(-1);\n            }else{\n           // System.out.println(temp[q][0]+\" \"+temp[q][1]+\" \"+q);\n                int x=Math.abs(temp[q][1]-q);\n               // System.out.println(x);\n                if(x>nums.length-Math.abs(temp[q][1]-q)){\n                    x=nums.length-Math.abs(temp[q][1]-q);\n                }\n               // System.out.println(x);\n                if(x>Math.abs(temp[q][0]-q))x=Math.abs(temp[q][0]-q);\n               // System.out.println(x);\n                if(x>nums.length-Math.abs(temp[q][0]-q))x=nums.length-Math.abs(temp[q][0]-q);\n               // System.out.println(x);\n                ls.add(x);\n            }\n        }\n        return ls;\n        \n    }\n}","author":"chinnamsaireddy1369","submissionId":"1575131060"},[]]},{"1031":[{"id":"1031","fileName":"1575131178.txt","sourceCode":"class Solution\n{\n    public List<Integer> solveQueries (int[] nums, int[] queries)\n    {\n        int len = nums.length;\n        HashMap<Integer, ArrayList<Integer>> map = new HashMap<Integer, ArrayList<Integer>> ();\n        for (int ind=0;ind<len;ind++)\n        {\n            if (!map.containsKey (nums[ind]))\n            {\n                map.put (nums[ind], new ArrayList<Integer> ());\n            }\n            map.get (nums[ind]).add (ind);\n        }\n        int[] minDist = new int[len];\n        for (int ind=0;ind<len;ind++)\n        {\n            if (map.containsKey (nums[ind]))\n            {\n                int size = map.get (nums[ind]).size ();\n                if (size == 1)\n                {\n                    minDist[map.get (nums[ind]).get (0)] = -1;\n                }\n                else\n                {\n                    int first = map.get (nums[ind]).get (0);\n                    int second = map.get (nums[ind]).get (1);\n                    int last = map.get (nums[ind]).get (size - 1);\n                    minDist[first] = Math.min (second - first, first + len - last);\n                    for (int i=1;i<size-1;i++)\n                    {\n                        int prev = map.get (nums[ind]).get (i - 1);\n                        int curr = map.get (nums[ind]).get (i);\n                        int next = map.get (nums[ind]).get (i + 1);\n                        minDist[curr] = Math.min (curr - prev, next - curr);\n                    }\n                    int secondLast = map.get (nums[ind]).get (size - 2);\n                    minDist[last] = Math.min (last - secondLast, len - last + first);\n                }\n                map.remove (nums[ind]);\n            }\n        }\n        len = queries.length;\n        List<Integer> ans = new ArrayList<Integer> ();\n        for (int ind=0;ind<len;ind++)\n        {\n            ans.add (minDist[queries[ind]]);\n        }\n        return ans;\n    }\n}","author":"Rahul Ahuja","submissionId":"1575131178"},[]]},{"1032":[{"id":"1032","fileName":"1575131284.txt","sourceCode":"from typing import List\nfrom bisect import bisect_left\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        positions = {}\n        for i in range(len(nums)):\n            num = nums[i]\n            if num not in positions:\n                positions[num] = []\n            positions[num].append(i)\n        for val in positions:\n            positions[val].sort()\n        results = []\n        for i in queries:\n            val = nums[i]\n            ind = positions[val]\n            if len(ind) == 1:\n                results.append(-1)\n                continue\n            pos = bisect_left(ind, i)\n            left_idx = ind[pos-1]\n            if pos == len(ind):\n                right_idx = ind[0]\n            elif ind[pos] == i:\n                right_idx = ind[(pos+1) % len(ind)]\n            else:\n                right_idx = ind[pos]\n            dist_left = min(abs(i - left_idx), n - abs(i - left_idx))\n            dist_right = min(abs(i - right_idx), n - abs(i - right_idx))\n            results.append(min(dist_left, dist_right))\n        \n        return results\n","author":"Vaibhav Varshney","submissionId":"1575131284"},[]]},{"1033":[{"id":"1033","fileName":"1575131281.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, int> mp;\n        vector<int> dist(nums.size(), -1);\n        for (int i = 0; i<nums.size(); i++) {\n            if (mp.contains(nums[i])) {\n                if (dist[mp[nums[i]]]!=-1) {\n                    dist[mp[nums[i]]] = min(dist[mp[nums[i]]], i - mp[nums[i]]);\n                } else {\n                    dist[mp[nums[i]]] = i - mp[nums[i]];\n                }\n                dist[i] = i - mp[nums[i]];\n            }\n            mp[nums[i]] = i;\n        }\n\n        for (int i = 0; i<nums.size(); i++) {\n          //  cout << dist[i] << \" \";\n            if (mp[nums[i]]!=i) {\n                int val = i + nums.size()-mp[nums[i]];\n                dist[i] = min(dist[i], val );\n                dist[mp[nums[i]]] = min(dist[mp[nums[i]]], val);\n            }\n        }\n        cout << \"n\";\n       // for (int i : dist) cout << i << \" \";\n\n        vector<int> res;\n        for (int q : queries) {\n            res.push_back(dist[q]);\n        }\n        return res;\n    }\n};","author":"Bekzhan","submissionId":"1575131281"},[]]},{"887":[{"id":"887","fileName":"1575128051.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        vector<int> ans(q, 1e9);\n        // for(int i=0; i<n; i++){\n        //     nums.push_back(nums[i]);\n        // }\n\n        map<int,vector<int>> mp;\n        for(int i=0; i<3*n; i++){\n            mp[nums[i%n]].push_back(i);\n        }\n\n        for(int i=0; i<q; i++){\n            auto it = lower_bound(mp[nums[queries[i]]].begin(), mp[nums[queries[i]]].end(), n+queries[i]);\n            int idx = it - mp[nums[queries[i]]].begin();\n            int sz = mp[nums[queries[i]]].size();\n            if(sz > 3){\n                int temp1 = mp[nums[queries[i]]][(idx+1)%sz];\n                int temp2 = mp[nums[queries[i]]][(idx-1+sz)%sz];\n\n                ans[i] = min(temp1 - queries[i] - n, queries[i] + n - temp2);\n            }else{\n                ans[i] = -1;\n            }\n        }\n\n        return ans;\n    }\n};","author":"Pramod Biradar","submissionId":"1575128051"},[{"id":"887","similarity":0.7333333333333333,"totOverlap":143,"longestOverlap":18}]],"1034":[{"id":"1034","fileName":"1575131296.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n = nums.size();\n        int m = q.size();\n        vector<int> ans(m);\n        map<int, vector<int>> mp;\n        for(int i =0; i<n; ++i){\n            mp[nums[i]].push_back(i);\n        }\n        for(int i =0; i<m; ++i){\n            if(mp[nums[q[i]]].size()==1){\n                ans[i] = -1;\n            }\n            else{\n                auto idx = lower_bound(mp[nums[q[i]]].begin(), mp[nums[q[i]]].end(), q[i])-mp[nums[q[i]]].begin();\n                int sz = mp[nums[q[i]]].size();\n                \n                int bef = mp[nums[q[i]]][(idx-1+sz)%sz];\n                int aft = mp[nums[q[i]]][(idx+1)%sz];\n                \n                ans[i] = min({abs(q[i]-bef), n-abs((bef-q[i])), n-abs(aft-q[i]), abs(q[i]-aft)});\n            }\n        }\n        return ans;\n    }\n};","author":"MemoMeto","submissionId":"1575131296"},[{"id":"1275","similarity":0.7330316742081447,"totOverlap":162,"longestOverlap":17},{"id":"1034","similarity":0.7333333333333333,"totOverlap":143,"longestOverlap":18}]],"1275":[{"id":"1275","fileName":"1575137800.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& v, vector<int>& qe) {\n        int n = v.size();\n        int q = qe.size();\n        map<int , vector<int> > ind;\n        for(int i = 0 ; i < n ; i ++){\n            ind[v[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(int i = 0 ; i < q ; i ++){\n            if(ind[v[qe[i]]].size() < 2){\n                ans.push_back(-1);\n                continue;\n            }\n            int ne = ind[v[qe[i]]].size();\n            int low = lower_bound(ind[v[qe[i]]].begin() , ind[v[qe[i]]].end() , qe[i]) - ind[v[qe[i]]].begin();\n            // cout << qe[i] << \" -> \" << low << \" \" << ne << endl; \n            ans.push_back(min({abs(ind[v[qe[i]]][low] - ind[v[qe[i]]][(low - 1 + ne) % ne]) , abs(ind[v[qe[i]]][(low + 1 + ne) % ne] - ind[v[qe[i]]][low]) , ind[v[qe[i]]][0] + n - ind[v[qe[i]]][low] , n - (ind[v[qe[i]]].back() - ind[v[qe[i]]][low])}));\n            \n        }\n        return ans;\n    }\n};","author":"simplesheep03","submissionId":"1575137800"},[{"id":"1034","similarity":0.7330316742081447,"totOverlap":162,"longestOverlap":17}]]},{"1035":[{"id":"1035","fileName":"1575131355.txt","sourceCode":"class Solution {\n    int bin(vector<int> &arr, int low, int high, int x) {\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (arr[mid] == x)\n                return mid;\n            if (arr[mid] < x)\n                low = mid + 1;\n            else\n                high = mid - 1;\n        }\n        return -1;\n    }\n    int find(int n, int e, vector<int> &r) {\n        int x = bin(r, 0, r.size()-1, e), p = r[r.size()-1];;\n        if(x == 0) return min(n-p+r[0], r[1]-r[0]);\n        else if(x == r.size()-1) {\n            int w = min(n-p+r[0], p-r[r.size()-2]);\n            return w;\n        }\n        else return min(r[x+1]-r[x], r[x]-r[x-1]);\n    }\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> mp;\n        for(int i=0;i<nums.size();i++) mp[nums[i]].push_back(i);\n        vector<int> ans;\n        for(int i=0;i<queries.size();i++) {\n            int x = nums[queries[i]];\n            if(mp[x].size() < 2) {\n                ans.push_back(-1);\n                continue;\n            }\n            ans.push_back(find(nums.size(), queries[i], mp[x]));\n        }\n        return ans;\n    }\n};","author":"Hardik Soni","submissionId":"1575131355"},[]]},{"1037":[{"id":"1037","fileName":"1575131141.txt","sourceCode":"public class Solution {\n    public IList<int> SolveQueries(int[] nums, int[] queries) {\n                    var answer = new List<int>();\n\n    var dict = new Dictionary<int, List<int>>();\n    for (int i = 0; i < nums.Length; i++)\n    {\n        if (dict.ContainsKey(nums[i]))\n        {\n            dict[nums[i]].Add(i);\n        }\n        else\n        {\n            dict[nums[i]] = new List<int> { i };\n        }\n    }\n\n    for (int i = 0; i < queries.Length; i++) {\n        var index = queries[i];\n        if (index < 0 || index >= nums.Length)\n        {\n            answer.Add(-1);\n            continue;\n        }\n\n        var value = nums[index];\n\n        var list = dict[value];\n\n        if (list.Count == 1)\n        {\n            answer.Add(-1);\n            continue;\n        }\n\n        var binaryIndex = BinarySearch(list, index);\n\n        if (binaryIndex == 0)\n        {\n            var min = Math.Min(list[binaryIndex + 1] - list[binaryIndex], nums.Count() - list.Last() + list[binaryIndex]);\n            answer.Add(min);\n            continue;\n        }\n\n        if (binaryIndex == list.Count - 1)\n        {\n            var min = Math.Min(list[binaryIndex] - list[binaryIndex - 1], nums.Count() - list[binaryIndex] + list[0]);\n            answer.Add(min);\n            continue;\n        }\n\n        answer.Add(Math.Min(list[binaryIndex] - list[binaryIndex - 1], list[binaryIndex + 1] - list[binaryIndex]));\n    }\n\n    return answer;\n}\n\npublic static int BinarySearch(List<int> nums, int value)\n{\n    int l = 0;\n    int r = nums.Count - 1;\n    while (l <= r)\n    {\n        int mid = l + (r - l) / 2;\n        if (nums[mid] == value)\n        {\n            return mid;\n        }\n        else if (nums[mid] < value)\n        {\n            l = mid + 1;\n        }\n        else\n        {\n            r = mid - 1;\n        }\n    }\n    return r;\n}\n}","author":"leducthinh55","submissionId":"1575131141"},[]]},{"1038":[{"id":"1038","fileName":"1575131407.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n\n        n = len(nums)\n        index_map = defaultdict(list)\n\n\n        for i in range(n):\n            index_map[nums[i]].append(i)\n        \n        res = []\n        for query in queries:\n            ele = nums[query]\n            positions = index_map[ele]\n\n            if len(positions) > 1:\n               \n                idx = bisect_left(positions, query)\n                closest = float(\"inf\")\n\n                if idx > 0:\n                    closest = min(closest, query - positions[idx - 1])\n                if idx < len(positions) - 1:\n                    closest = min(closest, positions[idx + 1] - query)\n\n                \n                closest = min(closest, (n - abs(positions[0] - query)), (n - abs(positions[-1] - query)))\n\n                res.append(closest)\n            else:\n                res.append(-1)\n        \n        return res\n            \n        ","author":"Maanit Goyal","submissionId":"1575131407"},[]]},{"1039":[{"id":"1039","fileName":"1575131557.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> ans(queries.size());\n        unordered_map<int, vector<int>> umap;\n        for(int i=0; i<nums.size(); i++){\n            umap[nums[i]].push_back(i);\n        }\n        int size = nums.size();\n\n        for(int i=0; i<queries.size(); i++){\n            int idx = queries[i];\n            int num = nums[idx];\n            vector<int>& vec = umap[num];\n            int n = vec.size();\n            if(vec.size()==1){\n                ans[i]= -1;\n                continue;\n            }\n            if(idx == vec[n-1]){\n                ans[i] = min(size - idx + vec[0], vec[n-1] - vec[n-2]);\n                continue;\n            }\n            if(idx == vec[0]){\n                ans[i] = min(size - vec[n-1]+vec[0], vec[1]-vec[0]);\n                continue;\n            }\n            int s = 0, e = vec.size()-1;\n            int ind = lower_bound(vec.begin(), vec.end(), idx) - vec.begin();\n            \n            ans[i] = min(vec[ind]-vec[ind-1], vec[ind+1]- vec[ind]);\n        }\n        return ans;\n    }\n};","author":"Prabhjot Singh Walia","submissionId":"1575131557"},[]]},{"1040":[{"id":"1040","fileName":"1575131574.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        extended_arr = nums + nums + nums  \n        result = [100002] * (3 * n)  \n        last_seen = {}\n        m = len(queries)\n\n        for i in range(3 * n):\n            if extended_arr[i] in last_seen:\n                result[i] = min(result[i], i - last_seen[extended_arr[i]])\n            last_seen[extended_arr[i]] = i\n\n        last_seen.clear()\n        for i in range(3 * n - 1, -1, -1):\n            if extended_arr[i] in last_seen:\n                result[i] = min(result[i], last_seen[extended_arr[i]] - i)\n            last_seen[extended_arr[i]] = i\n        ans = []\n        for j in range(0, m):\n            index = queries[j] + n\n            if result[index] == n:\n                ans.append(-1)\n            else:\n                ans.append(result[index])\n        return ans\n            \n        \n                \n            \n        \n","author":"YitLuo","submissionId":"1575131574"},[]]},{"1041":[{"id":"1041","fileName":"1575131526.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, TreeSet<Integer>> mp = new HashMap<>();\n        \n        for (int i = 0; i < n; i++) {\n            mp.computeIfAbsent(nums[i], k -> new TreeSet<>()).add(i);\n        }\n        \n        int[] min1 = new int[n];\n        Arrays.fill(min1, -1);\n        \n        for (int val : mp.keySet()) {\n            TreeSet<Integer> ind = mp.get(val);\n            if (ind.size() == 1) continue;\n            \n            int prev = ind.last();\n            for (int curr : ind) {\n                int d1 = (curr - prev + n) % n;\n                int d2 = n - d1;\n                int dist = Math.min(d1, d2);\n                min1[prev] = min1[prev] == -1 ? dist : Math.min(min1[prev], dist);\n                min1[curr] = min1[curr] == -1 ? dist : Math.min(min1[curr], dist);\n                \n                prev = curr;\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (min1[i] != -1) continue; \n            TreeSet<Integer> ind = mp.get(nums[i]);\n            if (ind.size() == 1) continue; \n            \n            int ma = n;\n            for (int idx : ind) {\n                int d1 = Math.abs(i - idx);\n                int d2 = n - d1;\n                ma = Math.min(ma, Math.min(d1, d2));\n            }\n            min1[i] = ma;\n        }\n        \n        List<Integer> ans = new ArrayList<>(queries.length);\n        for (int q : queries) {\n            ans.add(min1[q]);\n        }\n        \n        return ans;\n    }\n}","author":"Slot","submissionId":"1575131526"},[]]},{"1042":[{"id":"1042","fileName":"1575131436.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& n, vector<int>& q) {\n        unordered_map<int, vector<int>> m;\n        int sz = n.size();\n        vector<int> dist(sz, -1);\n        for (int i = 0; i < sz; i++) m[n[i]].push_back(i);\n        for (auto& [v,in] : m) {\n            int k = in.size();\n            for (int i = 0; i < k; i++) {\n                int idx = in[i];\n                int ni = in[(i + 1) % k];\n                int pi = in[(i - 1 + k) % k];\n                int dn = (ni >= idx) ? ni - idx : sz - idx + ni;\n                int dp = (idx >= pi) ? idx - pi : sz - pi + idx;\n                if (dist[idx] == -1) dist[idx] = min(dn, dp);\n                else dist[idx] = min(dist[idx], min(dn, dp));\n            }\n        }\n        vector<int> ans(q.size());\n        for (int i = 0; i < q.size(); i++) {\n            ans[i] = dist[q[i]];\n            if(ans[i]==0) ans[i]-=1;\n        }\n        return ans;\n    }\n};","author":"Chanakya2456","submissionId":"1575131436"},[]]},{"1044":[{"id":"1044","fileName":"1575131725.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        lastIdx = {}\n        n = len(nums)\n        dist = [inf]*n\n        nums.extend(nums)\n        for i, num in enumerate(nums):\n            if num in lastIdx:\n                idx = lastIdx[num]\n                dist[idx%n] = min(dist[idx%n], i - idx)\n                dist[i%n] = min(dist[i%n], i - idx)\n                lastIdx[num] = i\n            else:\n                lastIdx[num] = i\n\n        res =[]\n        for q in queries:\n            if dist[q%n] == n:\n                res.append(-1)\n            else:\n                res.append(dist[q%n])\n        return res\n                ","author":"yui","submissionId":"1575131725"},[]]},{"1045":[{"id":"1045","fileName":"1575131621.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        mp = {}\n\n        for idx, num in enumerate(nums):\n            if num in mp:\n                mp[num].append(idx)\n            else:\n                mp[num] = [idx]\n\n        res = []\n        for i in queries:\n            num = nums[i]\n            arr = mp[num]\n            if len(arr) == 1:\n                res.append(-1)\n                continue\n            # find pos of i in map\n            left = 0\n            right = len(arr) - 1\n\n            while left <= right:\n                mid = (right + left) // 2\n                if arr[mid] == i:\n                    left = mid\n                    break\n                if arr[mid] > i:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            if left == 0:\n                res.append(min(i - arr[len(arr) - 1] + n, arr[left + 1] - i))\n            elif left == len(arr) - 1:\n                res.append(min(i - arr[left - 1], arr[0] - i + n))\n            else:\n                res.append(min(i - arr[left - 1], arr[left + 1] - i))\n        return res\n","author":"quanbnz","submissionId":"1575131621"},[]]},{"1046":[{"id":"1046","fileName":"1575131623.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        nums = nums \n        hmap = defaultdict(list)\n        for i, j in enumerate(nums):\n            hmap[j].append(i)\n        res = []\n        for i in queries:\n            indices = hmap[nums[i]]\n            if len(indices) == 1:\n                res.append(-1)\n                continue\n            pos = bisect_right(indices, i)\n            left = bisect_left(indices, i)\n            if pos < len(indices):\n                forward = (indices[pos] - i)\n            else:\n                forward = (len(nums) - i + indices[0])\n            if left > 0:\n                backward = i - indices[left - 1]\n            else:\n                 backward = i + (len(nums) - indices[-1])\n            res.append(min(forward, backward))\n        return res ","author":"mvar","submissionId":"1575131623"},[]]},{"1048":[{"id":"1048","fileName":"1575131642.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        map<int,vector<int>> mp;\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(auto it:q){\n            int dif=1e9;\n            int num=nums[it];\n            int idx=lower_bound(mp[num].begin(),mp[num].end(),it)-mp[num].begin();\n            int sz=mp[num].size();\n            int prev_idx=(idx-1+sz)%sz;\n            int next_idx=(idx+1+sz)%sz;\n            cout<<prev_idx<<\" \"<<next_idx<<endl;\n            dif=min(dif, min(  abs(it-mp[num][prev_idx])   ,   n-(abs(it-mp[num][prev_idx])) ));\n            \n            dif=min(dif,min(  abs(mp[num][next_idx]-it) ,  n-(abs(mp[num][next_idx]-it)) ));\n            if(dif==0 || dif==1e9){\n                dif=-1;\n            }\n            ans.push_back(dif);\n        }\n        return ans;\n    }\n};","author":"Harshil","submissionId":"1575131642"},[]]},{"1049":[{"id":"1049","fileName":"1575131813.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        vector<int> a(n,INT_MAX),v(2*n);\n        for(int i=0 ; i<n ; i++) v[i]=nums[i];\n        for(int i=n ; i<2*n ; i++) v[i]=nums[i-n];\n        map<int,int> mp;\n        for(int i=0 ; i<2*n ; i++){\n            if(mp.find(v[i])==mp.end()) mp[v[i]]=i;\n            else{\n                if(mp[v[i]]<n){\n                    a[mp[v[i]]]=min(a[mp[v[i]]],abs(i-mp[v[i]]));\n                    a[i%n]=min(a[i%n],abs(i-mp[v[i]]));\n                    mp[v[i]]=i;\n                }\n            }\n        }\n        vector<int> ans(queries.size(),-1);\n        for(int i=0 ; i<queries.size() ; i++){\n            if(a[queries[i]]==n) ans[i]=-1;\n            else ans[i]=a[queries[i]];\n        }\n        return ans;\n    }\n};","author":"The mogorgon","submissionId":"1575131813"},[]]},{"1051":[{"id":"1051","fileName":"1575131762.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        prev = defaultdict(int)\n        next = defaultdict(int)\n        lastSeen = defaultdict(int)\n        for i in range(len(nums)):\n            n = nums[i]\n            if n in lastSeen:\n                prev[i] = lastSeen[n]\n            lastSeen[n] = i\n        for i in range(len(nums)):\n            n = nums[i]\n            if n in lastSeen:\n                prev[i] = lastSeen[n]\n            lastSeen[n] = i\n\n\n        # .....j........k.........n\n        \n        def dist(j,k):\n            return min(abs(k-j), len(nums)-abs(k-j))\n\n            \n        lastSeen = defaultdict(int)\n        for i in range(len(nums)-1, -1, -1):\n            n = nums[i]\n            if n in lastSeen:\n                next[i] = lastSeen[n]\n            lastSeen[n] = i\n        for i in range(len(nums)-1, -1, -1):\n            n = nums[i]\n            if n in lastSeen:\n                next[i] = lastSeen[n]\n            lastSeen[n] = i\n        ans = [-1]*len(queries)\n        for i in range(len(queries)):\n            q = queries[i]\n            j = prev[q]\n            k = next[q]\n            if j == q and k == q:\n                continue\n            elif j == q:\n                ans[i] = dist(k,q)\n            elif k == q:\n                ans[i] = dist(j,q)\n            else:\n                ans[i] = min(dist(j,q), dist(k,q))\n        return ans","author":"arty","submissionId":"1575131762"},[]]},{"1052":[{"id":"1052","fileName":"1575131936.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        loc = defaultdict(list)\n        for i, v in enumerate(nums):\n            loc[v].append(i)\n\n        n = len(nums)\n\n        # pre calculate\n        forward = [-1] * n\n        backward = [-1] * n\n\n        for key in loc:\n            if len(loc[key]) <= 1:\n                continue\n\n            # forward\n            prev = loc[key][0]\n            for idx in loc[key][1:]:\n                forward[prev] = idx - prev\n                prev = idx\n\n            forward[loc[key][-1]] = n + loc[key][0] - loc[key][-1]\n            \n            # backward\n            back = loc[key][::-1]\n            prev = back[0]\n            for idx in back[1:]:\n                backward[prev] = prev - idx\n                prev = idx\n\n            backward[back[-1]] = back[-1] + n - back[0]\n\n        out = []\n        for q in queries:\n            out.append(min(forward[q], backward[q]))\n\n        return out","author":"sslance","submissionId":"1575131936"},[]]},{"1053":[{"id":"1053","fileName":"1575131834.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        numsLastOccurance = dict()\n        l = len(nums)\n\n        minDistance = [l+1 for i in range(l)]\n\n        for j in range(2):\n            for i in range(l):\n                if nums[i] in numsLastOccurance:\n                    pi = numsLastOccurance[nums[i]]\n                    if i != pi:\n                        \n                        distance =  (l + i - pi) % l\n                        \n                        minDistance[pi] = min(minDistance[pi],distance)\n                        minDistance[i] = min(minDistance[i], distance)\n    \n                numsLastOccurance[nums[i]] = i\n\n        print(minDistance)\n        res = []\n        for query in queries:\n            distance = minDistance[query]\n            if distance <= l:\n                res.append(distance)\n            else:\n                res.append(-1)\n\n        return res","author":"amithshettya","submissionId":"1575131834"},[]]},{"1054":[{"id":"1054","fileName":"1575131904.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        chars = defaultdict(list)\n        ans = []\n        for i in range(len(nums)):\n            chars[nums[i]].append(i)\n        def helper(target, n): #target idx, n is number\n            if target == chars[n][0]:\n                return min(chars[n][1]-chars[n][0], len(nums)-(chars[n][-1]-chars[n][0]))\n            if target == chars[n][-1]:\n                return min(chars[n][-1]-chars[n][-2], len(nums)-(chars[n][-1]-chars[n][0]))\n            l, r = 0, len(chars[n])-1\n            idx = -1\n            while l<=r: #find index of target\n                \n                m = (l+r)//2\n                #print(m, l, r, target, n)\n                if chars[n][m] == target:\n                    idx = m\n                    return min(chars[n][idx]-chars[n][idx-1], chars[n][idx+1]-chars[n][idx])\n                elif chars[n][m]<target:\n                    l = m+1\n                else:\n                    r = m-1\n            \n        #print(chars)\n        for q in queries:\n            if len(chars[nums[q]])==1:\n                ans.append(-1)\n            elif len(chars[nums[q]])==2:\n                ans.append(min(chars[nums[q]][1]-chars[nums[q]][0], len(nums)-(chars[nums[q]][1]-chars[nums[q]][0])))\n            else:\n                ans.append(helper(q, nums[q]))\n        return ans","author":"westonz7042","submissionId":"1575131904"},[]]},{"1055":[{"id":"1055","fileName":"1575131984.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        unordered_map<int, vector<int>> mp;\n        int n = nums.size();\n        int m = q.size();\n\n        for(int i=0; i<n; i++){\n            mp[nums[i]].push_back(i);\n        }\n\n        vector<int> res(m, -1);\n        for(int i=0; i<m; i++){\n            if(mp[nums[q[i]]].size() == 1) continue;\n            res[i] = search(mp[nums[q[i]]], q[i], n);\n        }\n\n        return res;\n    }\n    int search(vector<int> &v, int i, int sz){\n        int n = v.size();\n\n        auto it = lower_bound(v.begin(), v.end(), i);\n        int ind = it-v.begin();\n\n        int d = INT_MAX;\n        if(ind == 0 || ind == n-1){\n            d = sz-v[n-1]+v[0];\n        }\n        if(ind > 0) d = min(d, v[ind]-v[ind-1]);\n        if(ind < n-1) d = min(d, v[ind+1]-v[ind]);\n        \n        return d;\n    }\n};\n/*\n[-1,1,1,2,-1]\n*/","author":"Abhijeet Jadhav","submissionId":"1575131984"},[]]},{"1056":[{"id":"1056","fileName":"1575132027.txt","sourceCode":"/*\nnums = [1,3,1,4,2,1,5,1]\nres = [1,-1,2,-1,-1,2,-1,1]\n*/\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> mdis(n, 100000);\n\n        unordered_map<int, pair<int, int> > m;\n        for (int i = 0; i < n; i++) {\n            int val = nums[i];\n            if (m.count(val)) {\n                int dis1 = n - (i - m[val].first);\n                int dis2 = i - m[val].second;\n                mdis[i] = min(mdis[i], dis1);\n                mdis[m[val].first] = min(mdis[m[val].first], dis1);\n                mdis[i] = min(mdis[i], dis2);\n                mdis[m[val].second] = min(mdis[m[val].second], dis2);\n\n                m[val].second = i;\n            } else {\n                m[val] = {i, i};\n            }\n        }\n        vector<int> res;\n        for (auto &q : queries) {\n            if (mdis[q] == 100000) {\n                res.push_back(-1);\n            } else {\n                res.push_back(mdis[q]);\n            }\n        }\n        return res;\n    }\n};","author":"Jason","submissionId":"1575132027"},[]]},{"1057":[{"id":"1057","fileName":"1575131970.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), q = queries.size();\n        vector<int> res(q);\n        map<int, vector<int>> pos;\n        for (int i = 0; i < n; i++){\n            pos[nums[i]].push_back(i);\n            pos[nums[i]].push_back(i + n);\n        }\n        for (auto &[a, b] : pos) sort(b.begin(), b.end());\n        for (int i = 0; i < q; i++){\n            int v = nums[queries[i]];\n            int ans = 1e9;\n            int prv = lower_bound(pos[v].begin(), pos[v].end(), queries[i]) - pos[v].begin();\n            if (prv && pos[v][prv - 1] - n != queries[i]){\n                prv--;\n                ans = min(ans, queries[i] - pos[v][prv]);\n            }\n            int nxt = upper_bound(pos[v].begin(), pos[v].end(), queries[i]) - pos[v].begin();\n            if (nxt < pos[v].size() && pos[v][nxt] - n != queries[i]){\n                ans = min(ans, pos[v][nxt] - queries[i]);\n            }\n            prv = lower_bound(pos[v].begin(), pos[v].end(), queries[i] + n) - pos[v].begin();\n            if (prv && pos[v][prv - 1] != queries[i]){\n                prv--;\n                ans = min(ans, queries[i] + n - pos[v][prv]);\n            }\n            nxt = upper_bound(pos[v].begin(), pos[v].end(), queries[i] + n) - pos[v].begin();\n            if (nxt < pos[v].size() && pos[v][nxt] != queries[i]){\n                ans = min(ans, pos[v][nxt] - queries[i] - n);\n            }\n            res[i] = (ans == 1e9)? -1: ans;\n        }\n        return res;\n    }\n};","author":"Win Chang","submissionId":"1575131970"},[]]},{"1058":[{"id":"1058","fileName":"1575132048.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        List<Integer> res = new ArrayList<>();\n        Map<Integer, TreeSet<Integer>> map= new HashMap<>();\n        for(int i = 0; i < nums.length; i++){\n            map.putIfAbsent(nums[i], new TreeSet<>());\n            if(map.get(nums[i]).size() == 0){\n                map.get(nums[i]).add(-1);\n                map.get(nums[i]).add(n + 1);\n            }\n            map.get(nums[i]).add(i);\n        }\n        for(int q : queries){\n            int val = nums[q];\n            int low = map.get(val).lower(q);\n            int high = map.get(val).higher(q);\n            if(low == -1 && high == n + 1){\n                res.add(-1);\n                continue;\n            }\n            if(low == -1){\n                low = map.get(val).lower(n + 1);\n            }\n            if(high == n + 1){\n                high = map.get(val).higher(-1);\n            }\n            if(low == q)\n                res.add(Math.min(Math.abs(high - q), n - Math.max(high, q)  + Math.min(high, q)));\n            else if(high == q)\n                res.add(Math.min(Math.abs(q - low), n - Math.max(low, q)  + Math.min(low, q)));\n            else{\n                int a = Math.min(Math.abs(high - q), n - Math.max(high, q)  + Math.min(high, q));\n                int b = Math.min(Math.abs(q - low), n - Math.max(low, q)  + Math.min(low, q));\n                res.add(Math.min(a,b));\n            }\n        }\n        return res;\n    }\n}","author":"nickee1942","submissionId":"1575132048"},[]]},{"1059":[{"id":"1059","fileName":"1575132109.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> res;\n        for (int q : queries) {\n            if (mp[nums[q]].size() == 0) res.push_back(-1);\n            int dist = INT_MAX, idx = -1;\n            int pos = lower_bound(mp[nums[q]].begin(), mp[nums[q]].end(), q) - mp[nums[q]].begin();\n            // cout << pos;\n            int m = mp[nums[q]].size();\n            int a = ((mp[nums[q]][(pos + 1) % m] - mp[nums[q]][pos]) + n) % n;\n            int b = (mp[nums[q]][pos] - mp[nums[q]][(pos - 1 + m) % m] + n) % n;\n            if (a != 0) {\n                if (a < dist) {\n                    dist = a;\n                    idx = (pos + 1) % m;\n                }\n            }\n            if (b != 0) {\n                if (b < dist) {\n                    dist = b;\n                    idx = (pos - 1 + m) % m;\n                }\n            }\n            if (idx == -1) res.push_back(-1);\n            else res.push_back(dist);\n        }\n        return res;\n    }\n};","author":"AegeanYU","submissionId":"1575132109"},[]]},{"1060":[{"id":"1060","fileName":"1575132073.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        vector<int>res(queries.size(),-1);\n        map<int,vector<int>>posi;\n        for(int i=0;i<nums.size();i++){\n            posi[nums[i]].push_back(i);\n        }\n        for(int i=0;i<queries.size();i++){\n            int currele=nums[queries[i]];\n            int curridx=queries[i];\n            //next idx after it\n            int mini=1e9;\n            int idx=lower_bound(posi[currele].begin(),posi[currele].end(),curridx)-posi[currele].begin();\n            if(idx<posi[currele].size()-1){\n                mini=min(mini,posi[currele][idx+1]-posi[currele][idx]);\n            }\n            if(idx>0){\n                int firstposi=posi[currele][idx];\n                int lastposi=posi[currele][idx-1];\n                mini=min(mini,firstposi-lastposi);\n            }\n            if(posi[currele][0]!=posi[currele][idx]){\n                mini=min(mini,n-posi[currele][idx]+posi[currele][0]);\n            }\n            if(posi[currele][posi[currele].size()-1]!=posi[currele][idx]){\n                mini=min(mini,posi[currele][idx]+n-posi[currele][posi[currele].size()-1]);\n            }\n            if(mini!=1e9){\n                res[i]=mini;\n            }\n        }\n        return res;\n    }\n};","author":"Tanmay khandelwal","submissionId":"1575132073"},[]]},{"1061":[{"id":"1061","fileName":"1575132117.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n  = nums.size();\n        vector<int> dist(n, INT_MAX);\n        map<int, int> last;\n        map<int, int> firstIdx;\n        map<int, int> lastIdx;\n        for(int i = 0; i < n; i++) {\n            auto it = last.find(nums[i]);\n            if(it == last.end()) {\n                last[nums[i]] = i;\n            }\n            else {\n                auto pos = it -> second;\n                dist[i] = i - pos;\n                dist[pos] = min(dist[pos], i - pos);\n            }\n            it -> second = i;\n\n            if(firstIdx.find(nums[i]) == firstIdx.end()) {\n                firstIdx[nums[i]] = i;\n            }\n            lastIdx[nums[i]] = i;\n        }\n\n        for(auto& f: firstIdx) {\n            if(dist[f.second] != INT_MAX) {\n                dist[f.second] = min(dist[f.second], f.second + (n - lastIdx[f.first]));\n            }\n        }\n        for(auto& l: lastIdx) {\n            if(dist[l.second] != INT_MAX) {\n                dist[l.second] = min(dist[l.second], (n - l.second) + firstIdx[l.first]);\n            }\n        }\n\n        vector<int> ans(queries.size());\n        for(int i = 0; i < queries.size(); i++) {\n            if(dist[queries[i]] == INT_MAX) {\n                ans[i] = -1;\n            }\n            else {\n                ans[i] = dist[queries[i]];\n            }\n        }\n        return ans;\n    }\n};","author":"振群 高","submissionId":"1575132117"},[]]},{"1062":[{"id":"1062","fileName":"1575132150.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[]} queries\n * @return {number[]}\n */\nvar solveQueries = function (nums, queries) {\n    const map = new Map();\n    const distances = Array(nums.length).fill(-1);\n    for (let i = 0; i < nums.length; i++) {\n        let indices = [i, i];\n        if (map.has(nums[i])) {\n            indices = map.get(nums[i]);\n            const distance1 = i - indices[1];\n            const distance2 = nums.length - i + indices[0];\n            distances[i] = Math.min(distance1, distance2);\n            if (distances[indices[0]] === -1) {\n                distances[indices[0]] = distance2;\n            } else {\n                distances[indices[0]] = Math.min(\n                    distances[indices[0]],\n                    distance2\n                );\n            }\n            if (distances[indices[1]] === -1) {\n                distances[indices[1]] = distance1;\n            } else {\n                distances[indices[1]] = Math.min(\n                    distances[indices[1]],\n                    distance1\n                );\n            }\n\n            indices[1] = i;\n        }\n        map.set(nums[i], indices);\n    }\n    const result = Array(queries.length);\n    for (let i = 0; i < queries.length; i++) {\n        result[i] = distances[queries[i]];\n    }\n    return result;\n};\n","author":"Duandz","submissionId":"1575132150"},[]]},{"1063":[{"id":"1063","fileName":"1575132096.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[]} queries\n * @return {number[]}\n */\nvar solveQueries = function(nums, queries) {\n  const n = nums.length;\n  const m = queries.length;\n  \n  const indexes = new Map();\n  for (let i = 0; i < n; i += 1) {\n    const v = nums[i];\n    if (!indexes.has(v)) indexes.set(v, []);\n    indexes.get(v).push(i);\n  }\n  \n  const ans = [];\n  for (const i of queries) {\n    const x = nums[i];\n    const idxs = indexes.get(x);\n    // console.log(idxs)\n    if (idxs.length === 1) {\n      ans.push(-1);\n      continue;\n    }\n    const idx = bisectLeft(i, idxs);\n    // console.log(idx)\n    const k = idxs.length;\n    const sm = idxs[(idx - 1 + k) % k];\n    const gm = idxs[(idx + 1) % k];\n    // console.log(i, sm, gm)\n    let md;\n    if (sm < i) {\n      md = i - sm;\n      md = Math.min(md, n - i + sm);\n    } else {\n      md = sm - i;\n      md = Math.min(md, n - sm + i);\n    }\n    \n    if (gm < i) {\n      md = Math.min(md, i - gm);\n      md = Math.min(md, n - i + gm);\n    } else {\n      md = Math.min(md, gm - i);\n      md = Math.min(md, n - gm + i);\n    }\n    \n    // const minDist = Math.min(Math.max(i, sm) - Math.min(i, sm), Math.max(i, gm) - Math.min(i, gm));\n    ans.push(md);\n  }\n  \n  return ans;\n};\n\nfunction bisectLeft(x, nums) {\n  const n = nums.length;\n  let left = 0;\n  let right = n - 1;\n  let ans = n;\n  \n  while (left <= right) {\n    const mid = left + Math.floor((right - left) / 2);\n    \n    if (nums[mid] < x) {\n      left = mid + 1;\n    } else {\n      ans = mid;\n      right = mid - 1;\n    }\n  }\n  \n  return ans;\n}","author":"espr3ss0","submissionId":"1575132096"},[]]},{"1064":[{"id":"1064","fileName":"1575132116.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        table = defaultdict(list)\n        for i, e in enumerate(nums):\n            table[e].append(i)\n        # print(table)\n        res = []\n        for q in queries:\n            num = nums[q]\n            idx_list = table[num]\n            # print(idx_list)\n            if len(idx_list) == 1: res.append(-1)\n            elif len(idx_list) == 2:\n                res.append(min(idx_list[1] - idx_list[0], idx_list[0] + n - idx_list[1]))\n            else:\n                list_len = len(idx_list)\n                idx = bisect_left(idx_list, q)\n                # print(idx)\n                if idx != 0 and idx != list_len - 1:\n                    res.append(min(idx_list[idx] - idx_list[idx - 1], idx_list[idx + 1] - idx_list[idx]))\n                elif idx == 0:\n                    res.append(min(idx_list[1] - idx_list[0], idx_list[0] + n - idx_list[-1]))\n                elif idx == list_len - 1:\n                    res.append(min(idx_list[idx] - idx_list[idx - 1], abs(idx_list[0] + n - idx_list[-1])))\n        return res","author":"hank95179","submissionId":"1575132116"},[]]},{"1065":[{"id":"1065","fileName":"1575132262.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,set<int>> mp;\n        int n=nums.size(),m=queries.size();\n        vector<int> ans(m,-1);\n        for(int i=0;i<n;i++){\n            mp[nums[i]].insert(i);\n        }\n        for(int i=0;i<m;i++){\n            if(mp[nums[queries[i]]].size()==1) continue;\n            auto it=mp[nums[queries[i]]].find(queries[i]);\n            int before=1e9,after=1e9;\n            if(it!=mp[nums[queries[i]]].begin()) {\n                auto it2=it;\n                it2--;\n                before=queries[i]-*it2;\n            }else{\n                before=n-*mp[nums[queries[i]]].rbegin()+*it;\n            }\n            auto it2=it;\n            it2++;\n            if(it2!=mp[nums[queries[i]]].end()) {\n                after=*it2-queries[i];\n            }else{\n                after=n+*mp[nums[queries[i]]].begin()-*it;\n            }\n            ans[i]=min(after,before);\n        }\n        return ans;\n    }\n};","author":"Mostafa Wael","submissionId":"1575132262"},[]]},{"1066":[{"id":"1066","fileName":"1575132200.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        hm = {}\n        for i, e in enumerate(nums):\n            if e not in hm:\n                hm[e] = []\n            hm[e].append(i)\n        ans = []\n        for q in queries:\n            e = nums[q]\n            indexes = hm[e]\n            if len(indexes) == 1:\n                ans.append(-1)\n                continue\n            curr = self.binsearch(indexes, q)\n            ret = -1\n            if curr == 0:\n                ret = min(abs(q - indexes[1]), abs(q+len(nums)-indexes[-1]))\n                \n            elif curr == len(indexes) - 1:\n                ret = min(abs(q - indexes[-2]), abs(q-(indexes[0]+len(nums))))\n                \n            else:\n                ret = (min(abs(q - indexes[curr-1]), abs(q-indexes[curr+1])))\n            ans.append(ret)\n        return ans\n\n    def binsearch(self, arr, e):\n        start = 0\n        end = len(arr) - 1\n        while start <= end:\n            mid = start + (end- start) // 2\n            if arr[mid]<e:\n                start = mid + 1\n            elif arr[mid] > e:\n                end = mid - 1\n            else:\n                return mid","author":"Aziz Jabbar Shiddiq","submissionId":"1575132200"},[]]},{"1067":[{"id":"1067","fileName":"1575132266.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int n1 = queries.size();\n        vector<int> ans(n1,-1);\n        map<int,vector<int>> m;\n        for(int i=0;i<n;i++){\n            m[nums[i]].push_back(i);\n        }\n        for(int i=0;i<n1;i++){\n            if(m[nums[queries[i]]].size() == 1)\n                continue;\n            int ind = lower_bound(m[nums[queries[i]]].begin(),m[nums[queries[i]]].end(),queries[i])-m[nums[queries[i]]].begin();\n            int d1, d2;\n            int t1 = queries[i];\n             int n2 = m[nums[t1]].size()-1;\n            if(ind >0){\n                 d1 = min(m[nums[t1]][ind] - m[nums[t1]][ind-1],n-(m[nums[t1]][ind] - m[nums[t1]][ind-1]));\n            }\n            else{\n         \n                 d1 = min(m[nums[t1]][n2] - m[nums[t1]][ind],n-(m[nums[t1]][n2] - m[nums[t1]][ind]));\n            }\n            \n            if(ind < n2){\n                 d2 = min(m[nums[t1]][ind+1] - m[nums[t1]][ind],n-(m[nums[t1]][ind+1] - m[nums[t1]][ind]));\n            }\n            else{\n                d2 = min(m[nums[t1]][ind] - m[nums[t1]][0],n-(m[nums[t1]][ind] - m[nums[t1]][0]));\n            }\n            ans[i] = min(d1,d2);\n        }\n        return ans;\n    }\n};","author":"anukul7060","submissionId":"1575132266"},[]]},{"1068":[{"id":"1068","fileName":"1575132250.txt","sourceCode":"class Solution\n{\n    /**\n     * @param Integer[] $nums\n     * @param Integer[] $queries\n     * @return Integer[]\n     */\n    public function solveQueries(array $nums, array $queries): array\n    {\n        $n = count($nums);\n\n        $lasts = [];\n        $firsts = [];\n        $bestDists = array_fill(0, $n, $n);\n        for ($i = 0; $i < $n; $i++) {\n            $num = $nums[$i];\n\n            if (!isset($firsts[$num])) {\n                $firsts[$num] = $i;\n            }\n\n            if (isset($lasts[$num])) {\n                $lastI = $lasts[$num];\n                $dist = $i - $lastI;\n\n                $bestDists[$i] = min($bestDists[$i], $dist);\n                $bestDists[$lastI] = min($bestDists[$lastI], $dist);\n            }\n\n            $lasts[$num] = $i;\n        }\n\n        foreach ($lasts as $num => $lastI) {\n            if ($firsts[$num] !== $lastI) {\n                $firstI = $firsts[$num];\n                $dist = $n - $lastI + $firstI;\n\n                $bestDists[$firstI] = min($bestDists[$firstI], $dist);\n                $bestDists[$lastI] = min($bestDists[$lastI], $dist);\n            }\n        }\n\n        //print_r($bestDists);\n\n        $res = [];\n        foreach ($queries as $ind => $qIdx) {\n            $num = $nums[$qIdx];\n\n            //echo \"checking queries[$ind] ($qIdx). Num: $num. bestDists[$qIdx]: {$bestDists[$qIdx]}n\";\n            \n            $res[] = ($n === $bestDists[$qIdx] ? -1 : $bestDists[$qIdx]);\n        }\n\n        return $res;\n    }\n}","author":"lzref","submissionId":"1575132250"},[]]},{"1069":[{"id":"1069","fileName":"1575132277.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& arr, vector<int>& queries) {\n        int n = arr.size();\n        int q = queries.size();\n        vector<int> closest(n, 1e9);\n        vector<int> nums(2*n);\n\n        for(int i=0; i<n; ++i){\n            nums[i] = arr[i];\n            nums[n+i] = arr[i];\n        }\n        \n        unordered_map<int, int> left, right;\n\n        closest[0] = 1e9;\n        \n        left[nums[0]] = 0;\n        for(int i=1; i<2*n; ++i){\n            int lclosest = 1e9;\n            if(left.find(nums[i]) != left.end()) lclosest = left[nums[i]];\n\n            if(lclosest == i-n) continue;\n            closest[i%n] = min(closest[i%n], abs(i - lclosest));\n            left[nums[i]] = i;\n        }\n\n        right[nums[n-1]] = 2*n-1;\n        for(int i=2*n-2; i>-1; -- i){\n            int rclosest = 1e9;\n            \n            if(right.find(nums[i]) != right.end()) rclosest = right[nums[i]];\n            if(rclosest == i+n) continue;\n            \n            closest[i%n] = min(closest[i%n], abs(rclosest - i ));\n            right[nums[i]] = i;\n        }\n\n        vector<int> ans(q);\n\n        for(int i=0; i<q; ++i){\n            int dist = closest[queries[i]];\n            if(dist > n || dist < 1) ans[i]= -1;\n            else ans[i] = dist;\n        }\n        return ans;\n    }\n};","author":"Gunanka D","submissionId":"1575132277"},[]]},{"1071":[{"id":"1071","fileName":"1575132344.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n=nums.length;\n        int pre[]=new int[n];\n        Map<Integer,Integer> map=new HashMap<>();\n        for(int i=0;i<n;i++){\n            pre[i]=map.getOrDefault(nums[i],-1);\n            map.put(nums[i],i);\n        }\n        for(int i=0;i<n;i++){\n            if(pre[i]==-1) pre[i]=map.getOrDefault(nums[i],-1);\n        }\n\n        int suff[]=new int[n];\n        map=new HashMap<>();\n        for(int i=n-1;i>=0;i--){\n            suff[i]=map.getOrDefault(nums[i],-1);\n            map.put(nums[i],i);\n        }\n        for(int i=0;i<n;i++){\n            if(suff[i]==-1) suff[i]=map.getOrDefault(nums[i],-1);\n        }\n\n        // for(int i=0;i<n;i++) System.out.print(pre[i]+\" \");\n        // System.out.println();\n        // for(int i=0;i<n;i++) System.out.print(suff[i]+\" \");\n        // 4 5 0 3 2 1 6 \n        // 2 5 4 3 0 1 6 \n        List<Integer> list=new ArrayList<>();\n        for(int i=0;i<queries.length;i++){\n            int j=queries[i];\n            if(pre[j]==j && suff[j]==j) list.add(-1);\n            else{\n                int a=0;\n                if(pre[j]>j) a=n-pre[j]+j;\n                else a=j-pre[j];\n                int b=0;\n                if(suff[j]<j) b=n-j+suff[j];\n                else b=suff[j]-j;\n                list.add(Math.min(a,b));\n            }\n        }\n        return list;\n    }\n}","author":"vg_","submissionId":"1575132344"},[]]},{"1073":[{"id":"1073","fileName":"1575132389.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        map<int,int> mpn,mpp;\n        int n = nums.size();\n        vector<int> nxt(n,-1),prev(n,-1);\n        for(int i=0;i<n;i++){\n            if(mpn.find(nums[i]) == mpn.end()){\n                mpn[nums[i]] = i;\n            }\n            else{\n                prev[i] = mpn[nums[i]];\n                mpn[nums[i]] = i;\n            }\n        }\n        for(int i=0;i<n;i++){\n            if(prev[i] == -1 && mpn.find(nums[i]) != mpn.end()){\n                if(mpn[nums[i]] != i){\n                    prev[i] = mpn[nums[i]];\n                }\n            }\n        }\n\n        for(int i=n-1;i>=0;i--){\n            if(mpp.find(nums[i]) == mpp.end()) mpp[nums[i]] = i;\n            else{\n                nxt[i] = mpp[nums[i]];\n                mpp[nums[i]] = i;\n            }\n        }\n\n        for(int i=n-1;i>=0;i--){\n            if(nxt[i] == -1 && mpp.find(nums[i]) != mpp.end()){\n                if(mpp[nums[i]] != i){\n                    nxt[i] = mpp[nums[i]];\n                }\n            }\n        }\n\n        // for(int i=0;i<n;i++) cout<<nxt[i]<<\" \";\n        int sz = q.size();\n        vector<int> res(sz,0);\n\n        for(int i=0;i<sz;i++){\n            int ind = q[i];\n            if(nxt[ind] == -1 && prev[ind] == -1) res[i] = -1;\n            else{\n                int dr = -1;\n                if(nxt[ind] < ind) dr = (n - ind) + nxt[ind];\n                else dr = nxt[ind] - ind;\n\n                int dl = -1;\n                if(prev[ind] > ind) dl = ind + (n - prev[ind]);\n                else dl = ind - prev[ind];\n                \n                res[i] = min(dr,dl);\n            }\n        }\n\n        return res;\n    }\n};","author":"Harshit Chauhan","submissionId":"1575132389"},[]]},{"1074":[{"id":"1074","fileName":"1575132457.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        numIDs = defaultdict(list)\n        for i, num in enumerate(nums):\n            numIDs[num].append(i)\n        n = len(nums)\n        m = len(queries)\n        answer = [-1] * m\n        for i in range(m):\n            idx1 = queries[i]\n            num = nums[idx1]\n            j = bisect.bisect_right(numIDs[num], idx1)\n            if j == len(numIDs[num]): j = 0\n            \n            idx2 = numIDs[num][j]\n            dist11 = abs(idx2 - idx1)\n            dist12 = min(idx2, idx1) + (n-max(idx1, idx2))\n\n            j2 = bisect.bisect_left(numIDs[num], idx1) - 1\n            idx3 = numIDs[num][j2]\n            dist21 = abs(idx3 - idx1)\n            dist22 = min(idx3, idx1) + (n-max(idx1, idx3))\n            \n            dist = min(dist11, dist12, dist21, dist22)\n            if dist == 0: continue\n            answer[i] = dist\n        return answer\n            \n            ","author":"Max Chang","submissionId":"1575132457"},[]]},{"0":[{"id":"0","fileName":"1575081865.txt","sourceCode":"import java.util.*;\nclass Solution {\n    public List<Integer> solveQueries(int[] a, int[] q) {\n        int n = a.length;\n        Map<Integer, List<Integer>> m = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            m.computeIfAbsent(a[i], k -> new ArrayList<>()).add(i);\n        }\n        for (List<Integer> l : m.values()) Collections.sort(l);\n        List<Integer> ans = new ArrayList<>();\n        for (int x : q) {\n            int v = a[x];\n            List<Integer> l = m.get(v);\n            if (l.size() == 1) {\n                ans.add(-1);\n                continue;\n            }\n            int p = Collections.binarySearch(l, x);\n            int lp = l.get((p - 1 + l.size()) % l.size());\n            int rp = l.get((p + 1) % l.size());\n            int d1 = Math.abs(x - lp);\n            int d2 = Math.abs(rp - x);\n            d1 = Math.min(d1, n - d1);\n            d2 = Math.min(d2, n - d2);\n            ans.add(Math.min(d1, d2));\n        }\n        return ans;\n    }\n}\n","author":"user0685BD","submissionId":"1575081865"},[{"id":"125","similarity":0.921875,"totOverlap":177,"longestOverlap":27},{"id":"0","similarity":0.8871794871794871,"totOverlap":173,"longestOverlap":22}]],"2":[{"id":"2","fileName":"1575080400.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] a, int[] q) {\n        int n = a.length;\n        Map<Integer, List<Integer>> m = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            m.computeIfAbsent(a[i], k -> new ArrayList<>()).add(i);\n        }\n        for (List<Integer> l : m.values()) Collections.sort(l);\n        List<Integer> ans = new ArrayList<>();\n        for (int x : q) {\n            int v = a[x];\n            List<Integer> l = m.get(v);\n            if (l.size() < 2) { ans.add(-1); continue; }\n            int idx = Collections.binarySearch(l, x);\n            int k = l.size();\n            int p = (idx + k) % k;\n            int d1 = (x - l.get((p - 1 + k) % k) + n) % n;\n            int d2 = (l.get((p + 1) % k) - x + n) % n;\n            ans.add(Math.min(d1, d2));\n        }\n        return ans;\n    }\n}\n","author":"Aira Jena","submissionId":"1575080400"},[{"id":"2","similarity":0.7760416666666666,"totOverlap":149,"longestOverlap":22}]],"7":[{"id":"7","fileName":"1575087215.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        List<Integer> answer = new ArrayList<>();\n        \n        // Precompute the nearest same-value neighbors for each index\n        // For each index, store the minimum distance to another occurrence\n        int[] minDistances = new int[n];\n        Arrays.fill(minDistances, -1);\n        \n        Map<Integer, List<Integer>> valueToIndices = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            valueToIndices.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        \n        // Precompute minimum distances for each index\n        for (List<Integer> indices : valueToIndices.values()) {\n            if (indices.size() > 1) {\n                // Sort the indices if they're not already sorted\n                Collections.sort(indices);\n                \n                // Process each index in this list\n                for (int i = 0; i < indices.size(); i++) {\n                    int currentIndex = indices.get(i);\n                    int minDist = Integer.MAX_VALUE;\n                    \n                    // Check distance to previous index (with wraparound)\n                    int prevIndex = indices.get((i - 1 + indices.size()) % indices.size());\n                    int distToPrev = Math.min(\n                        Math.abs(currentIndex - prevIndex),\n                        n - Math.abs(currentIndex - prevIndex)\n                    );\n                    minDist = Math.min(minDist, distToPrev);\n                    \n                    // Check distance to next index (with wraparound)\n                    int nextIndex = indices.get((i + 1) % indices.size());\n                    int distToNext = Math.min(\n                        Math.abs(currentIndex - nextIndex),\n                        n - Math.abs(currentIndex - nextIndex)\n                    );\n                    minDist = Math.min(minDist, distToNext);\n                    \n                    minDistances[currentIndex] = minDist;\n                }\n            }\n        }\n        \n        // Process queries using the precomputed distances\n        for (int queryIndex : queries) {\n            answer.add(minDistances[queryIndex]);\n        }\n        \n        return answer;\n    }\n}","author":"pavitra_dakarapu","submissionId":"1575087215"},[{"id":"114","similarity":0.8370044052863436,"totOverlap":190,"longestOverlap":46},{"id":"128","similarity":0.7990867579908676,"totOverlap":175,"longestOverlap":18},{"id":"7","similarity":0.7342342342342343,"totOverlap":163,"longestOverlap":18}]],"14":[{"id":"14","fileName":"1575089514.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        for (int q : queries) {\n            int val = nums[q];\n            List<Integer> indices = map.get(val);\n            if (indices.size() == 1) {\n                result.add(-1);\n            } else {\n                int pos = Collections.binarySearch(indices, q);\n                int size = indices.size();\n                \n                int leftIndex = indices.get((pos - 1 + size) % size);\n                int rightIndex = indices.get((pos + 1) % size);\n                \n                int dLeft = circularDistance(q, leftIndex, n);\n                int dRight = circularDistance(q, rightIndex, n);\n                \n                result.add(Math.min(dLeft, dRight));\n            }\n        }\n        return result;\n    }\n    \n    private int circularDistance(int i, int j, int n) {\n        int diff = Math.abs(i - j);\n        return Math.min(diff, n - diff);\n    }\n}\n","author":"madhank46","submissionId":"1575089514"},[{"id":"899","similarity":0.9629629629629629,"totOverlap":182,"longestOverlap":76},{"id":"14","similarity":0.8497409326424871,"totOverlap":164,"longestOverlap":52}]],"16":[{"id":"16","fileName":"1575089532.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n         int n = nums.length;\n        Map<Integer, List<Integer>> posMap = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            posMap.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        int[] answer = new int[queries.length];\n        for (int q = 0; q < queries.length; q++) {\n            int index = queries[q];\n            int value = nums[index];\n            List<Integer> positions = posMap.get(value);\n            if (positions.size() == 1) {\n                answer[q] = -1;\n                continue;\n            }\n            int pos = Collections.binarySearch(positions, index);\n            int prev = positions.get((pos - 1 + positions.size()) % positions.size());\n            int next = positions.get((pos + 1) % positions.size());\n            int dPrev = circularDistance(index, prev, n);\n            int dNext = circularDistance(index, next, n);\n            answer[q] = Math.min(dPrev, dNext);\n        }\n        List<Integer> res = new ArrayList<>();\n        for (int a : answer) {\n            res.add(a);\n        }\n        return res;\n    }\n    \n    private int circularDistance(int i, int j, int n) {\n        int diff = Math.abs(i - j);\n        return Math.min(diff, n - diff);\n    }\n}","author":"Ashwin Kumar","submissionId":"1575089532"},[{"id":"1315","similarity":0.8333333333333334,"totOverlap":175,"longestOverlap":36},{"id":"1858","similarity":0.7962962962962963,"totOverlap":172,"longestOverlap":25},{"id":"1568","similarity":0.7601809954751131,"totOverlap":168,"longestOverlap":30}]],"19":[{"id":"19","fileName":"1575090410.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        \n        // Pre-compute the minimum distance for each index\n        Map<Integer, TreeSet<Integer>> valueToIndices = new HashMap<>();\n        \n        // First pass: collect all indices for each value\n        for (int i = 0; i < n; i++) {\n            valueToIndices.computeIfAbsent(nums[i], k -> new TreeSet<>()).add(i);\n        }\n        \n        // Create answer array\n        List<Integer> answer = new ArrayList<>();\n        \n        // Process each query\n        for (int queryIndex : queries) {\n            int value = nums[queryIndex];\n            TreeSet<Integer> indices = valueToIndices.get(value);\n            \n            // If there's only one occurrence, no other index has the same value\n            if (indices.size() == 1) {\n                answer.add(-1);\n                continue;\n            }\n            \n            // Find the closest indices (one before and one after)\n            Integer lower = indices.lower(queryIndex);\n            Integer higher = indices.higher(queryIndex);\n            \n            int minDistance = Integer.MAX_VALUE;\n            \n            // Check distance to the previous occurrence (if exists)\n            if (lower != null) {\n                minDistance = Math.min(minDistance, queryIndex - lower);\n            } else {\n                // Wrap around to the largest index\n                Integer last = indices.last();\n                if (last != queryIndex) {\n                    minDistance = Math.min(minDistance, queryIndex + (n - last));\n                }\n            }\n            \n            // Check distance to the next occurrence (if exists)\n            if (higher != null) {\n                minDistance = Math.min(minDistance, higher - queryIndex);\n            } else {\n                // Wrap around to the smallest index\n                Integer first = indices.first();\n                if (first != queryIndex) {\n                    minDistance = Math.min(minDistance, (n - queryIndex) + first);\n                }\n            }\n            \n            answer.add(minDistance);\n        }\n        \n        return answer;\n    }\n}","author":"Anurag Singh","submissionId":"1575090410"},[{"id":"1829","similarity":0.7564102564102564,"totOverlap":177,"longestOverlap":26},{"id":"1385","similarity":0.8037383177570093,"totOverlap":172,"longestOverlap":12},{"id":"1890","similarity":0.7633928571428571,"totOverlap":171,"longestOverlap":44},{"id":"19","similarity":0.7016806722689075,"totOverlap":167,"longestOverlap":48}]],"21":[{"id":"21","fileName":"1575090870.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> indexMap = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            indexMap.putIfAbsent(nums[i], new ArrayList<>());\n            indexMap.get(nums[i]).add(i);\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        for (int idx : queries) {\n            int num = nums[idx];\n            List<Integer> positions = indexMap.get(num);\n            if (positions.size() == 1) {\n                result.add(-1);\n                continue;\n            }\n            int closestDist = Integer.MAX_VALUE;\n            int pos = Collections.binarySearch(positions, idx);\n            if (pos < 0) pos = -pos - 1;\n            if (pos > 0) \n                closestDist = Math.min(closestDist, idx - positions.get(pos - 1));\n            if (pos < positions.size() - 1) \n                closestDist = Math.min(closestDist, positions.get(pos + 1) - idx);\n            int first = positions.get(0), last = positions.get(positions.size() - 1);\n            closestDist = Math.min(closestDist, n - Math.abs(idx - first));\n            closestDist = Math.min(closestDist, n - Math.abs(idx - last));\n            \n            result.add(closestDist);\n        }\n        \n        return result;\n    }\n}","author":"Shri Varshini","submissionId":"1575090870"},[{"id":"21","similarity":0.8465346534653465,"totOverlap":171,"longestOverlap":23}]],"30":[{"id":"30","fileName":"1575093450.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> valueIndices = new HashMap<>();\n\n        // Preprocess the array to map each value to its list of indices\n        for (int i = 0; i < n; i++) {\n            int num = nums[i];\n            valueIndices.putIfAbsent(num, new ArrayList<>());\n            valueIndices.get(num).add(i);\n        }\n\n        List<Integer> results = new ArrayList<>();\n\n        for (int query : queries) {\n            int value = nums[query];\n            List<Integer> indices = valueIndices.get(value);\n\n            // If the value occurs only once, no other index exists\n            if (indices.size() == 1) {\n                results.add(-1);\n                continue;\n            }\n\n            // Find the position of the queried index in the list\n            int pos = Collections.binarySearch(indices, query);\n            int size = indices.size();\n\n            // Determine previous and next positions in the circular list\n            int prevPos = (pos - 1 + size) % size;\n            int nextPos = (pos + 1) % size;\n\n            int prevIndex = indices.get(prevPos);\n            int nextIndex = indices.get(nextPos);\n\n            // Calculate the minimal distances\n            int distPrev = getMinDistance(query, prevIndex, n);\n            int distNext = getMinDistance(query, nextIndex, n);\n\n            results.add(Math.min(distPrev, distNext));\n        }\n\n        return results;\n    }\n\n    // Helper method to compute the minimal distance in a circular array\n    private int getMinDistance(int i, int j, int n) {\n        int diff = Math.abs(i - j);\n        return Math.min(diff, n - diff);\n    }\n}","author":"Hari Preyadharshan S P","submissionId":"1575093450"},[{"id":"1072","similarity":0.8792270531400966,"totOverlap":182,"longestOverlap":21},{"id":"1072","similarity":0.8682926829268293,"totOverlap":178,"longestOverlap":28}]],"35":[{"id":"35","fileName":"1575093739.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for(int i = 0; i < n; i++){\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n\n        int[] result = new int[n];\n        Arrays.fill(result, -1);\n\n        for(Map.Entry<Integer, List<Integer>> entry : map.entrySet()){\n            List<Integer> indices = entry.getValue();\n            if(indices.size() < 2) continue;\n            \n            Collections.sort(indices);\n            int size = indices.size();\n            for(int i = 0; i < size; i++){\n                int curr = indices.get(i);\n                int next = indices.get((i + 1) % size);\n                int prev = indices.get((i - 1 + size) % size);\n                int d1 = Math.abs(next - curr);\n                d1 = Math.min(d1, n - d1);\n                int d2 = Math.abs(curr - prev);\n                d2 = Math.min(d2, n - d2);\n                result[curr] = Math.min(d1, d2);\n            }\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int q : queries) ans.add(result[q]);\n        return ans;\n    }\n}","author":"Md Yusuf","submissionId":"1575093739"},[{"id":"35","similarity":0.7525252525252525,"totOverlap":149,"longestOverlap":23}]],"52":[{"id":"52","fileName":"1575095982.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        List<Integer> result = new ArrayList<>();\n        Map<Integer, List<Integer>> indcmpz = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            indcmpz.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        \n        int[] ans = new int[n];\n        Arrays.fill(ans, -1);\n        \n        for (List<Integer> list : indcmpz.values()) {\n            if (list.size() == 1) continue;\n            Collections.sort(list);\n            int size = list.size();\n            for (int i = 0; i < size; i++) {\n                int curr = list.get(i);\n                int leftn = list.get((i - 1 + size) % size);\n                int rightn = list.get((i + 1) % size);\n                int leftdf = Math.abs(curr - leftn);\n                int rightdf = Math.abs(rightn - curr);\n                leftdf = Math.min(leftdf, n - leftdf);\n                rightdf = Math.min(rightdf, n - rightdf);\n                ans[curr] = Math.min(leftdf, rightdf);\n            }\n        }\n        \n        for (int query : queries) {\n            result.add(ans[query]);\n        }\n        return result;\n    }\n}","author":"Ritik Kumar Sahoo","submissionId":"1575095982"},[{"id":"128","similarity":0.8910891089108911,"totOverlap":180,"longestOverlap":74},{"id":"114","similarity":0.7990867579908676,"totOverlap":175,"longestOverlap":18}]],"95":[{"id":"95","fileName":"1575099803.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n       int n = nums.length;\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        for (List<Integer> list : map.values()) {\n            Collections.sort(list);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int qi = 0; qi < queries.length; qi++) {\n            int index = queries[qi];\n            int val = nums[index];\n            List<Integer> list = map.get(val);\n            if (list.size() < 2) {\n                ans.add(-1);\n                continue;\n            }\n            int pos = Collections.binarySearch(list, index);\n            int k = list.size();\n            int prev = list.get((pos - 1 + k) % k);\n            int next = list.get((pos + 1) % k);\n            int d1 = Math.abs(index - prev);\n            int d2 = Math.abs(next - index);\n            d1 = Math.min(d1, n - d1);\n            d2 = Math.min(d2, n - d2);\n            ans.add(Math.min(d1, d2));\n        }\n        return ans; \n    }\n}","author":"SUNDARA VINAYAGAM V","submissionId":"1575099803"},[{"id":"330","similarity":0.9146919431279621,"totOverlap":193,"longestOverlap":51},{"id":"330","similarity":0.8177570093457944,"totOverlap":175,"longestOverlap":26}]],"114":[{"id":"114","fileName":"1575101344.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        List<Integer> answer = new ArrayList<>();\n        \n       \n        int[] minDistances = new int[n];\n        Arrays.fill(minDistances, -1);\n        \n      \n        Map<Integer, List<Integer>> valueToIndices = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            valueToIndices.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        \n       \n        for (List<Integer> indices : valueToIndices.values()) {\n            if (indices.size() > 1) {\n                computeMinDistances(indices, minDistances, n);\n            }\n        }\n        \n      \n        for (int queryIndex : queries) {\n            answer.add(minDistances[queryIndex]);\n        }\n        \n        return answer;\n    }\n    \n    private void computeMinDistances(List<Integer> indices, int[] minDistances, int n) {\n        int size = indices.size();\n        \n      \n        Collections.sort(indices);\n        \n       \n        for (int i = 0; i < size; i++) {\n            int current = indices.get(i);\n            int minDist = Integer.MAX_VALUE;\n            \n        \n            if (size > 1) {\n                int prev = indices.get((i - 1 + size) % size);\n                minDist = Math.min(minDist, Math.min(\n                    Math.abs(current - prev), \n                    n - Math.abs(current - prev)\n                ));\n                \n               \n                int next = indices.get((i + 1) % size);\n                minDist = Math.min(minDist, Math.min(\n                    Math.abs(current - next), \n                    n - Math.abs(current - next)\n                ));\n                \n                minDistances[current] = minDist;\n            }\n        }\n    }\n}","author":"Suraj Chaudhary","submissionId":"1575101344"},[{"id":"7","similarity":0.8370044052863436,"totOverlap":190,"longestOverlap":46}]],"125":[{"id":"125","fileName":"1575102006.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public List<Integer> solveQueries(int[] a, int[] q) {\n        int n = a.length;\n        Map<Integer, List<Integer>> m = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            m.computeIfAbsent(a[i], k -> new ArrayList<>()).add(i);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int x : q) {\n            int v = a[x];\n            List<Integer> l = m.get(v);\n            if (l.size() == 1) {\n                ans.add(-1);\n            } else {\n                int pos = Collections.binarySearch(l, x);\n                int p = l.get((pos - 1 + l.size()) % l.size());\n                int nxt = l.get((pos + 1) % l.size());\n                int d1 = Math.abs(x - p);\n                d1 = Math.min(d1, n - d1);\n                int d2 = Math.abs(x - nxt);\n                d2 = Math.min(d2, n - d2);\n                ans.add(Math.min(d1, d2));\n            }\n        }\n        return ans;\n    }\n}\n","author":"saicharanshetty","submissionId":"1575102006"},[{"id":"0","similarity":0.921875,"totOverlap":177,"longestOverlap":27}]],"128":[{"id":"128","fileName":"1575102037.txt","sourceCode":"import java.util.*;\n\nclass Solution \n{\n    public List<Integer> solveQueries(int[] nums, int[] queries) \n    {\n        int n = nums.length;\n        List<Integer> result = new ArrayList<>();\n        Map<Integer, List<Integer>> valueToIndices = new HashMap<>();\n        for (int i = 0; i < n; i++) \n        {\n            valueToIndices.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        int[] minDistance = new int[n];\n        Arrays.fill(minDistance, -1);\n        for (List<Integer> indices : valueToIndices.values()) \n        {\n            if (indices.size() == 1) continue;\n            Collections.sort(indices);\n            int size = indices.size();\n            for (int i = 0; i < size; i++) \n            {\n                int curr = indices.get(i);\n                int prev = indices.get((i - 1 + size) % size);\n                int next = indices.get((i + 1) % size);\n                int distPrev = Math.min(Math.abs(curr - prev), n - Math.abs(curr - prev));\n                int distNext = Math.min(Math.abs(curr - next), n - Math.abs(curr - next));\n                minDistance[curr] = Math.min(distPrev, distNext);\n            }\n        }\n        for (int query : queries) \n        {\n            result.add(minDistance[query]);\n        }\n        return result;\n    }\n}\n","author":"vinay","submissionId":"1575102037"},[{"id":"52","similarity":0.8910891089108911,"totOverlap":180,"longestOverlap":74}]],"132":[{"id":"132","fileName":"1575102686.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        // Group indices by value\n        Map<Integer, List<Integer>> valueToIndices = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            valueToIndices.putIfAbsent(nums[i], new ArrayList<>());\n            valueToIndices.get(nums[i]).add(i);\n        }\n        \n        List<Integer> answer = new ArrayList<>();\n        \n        for (int i = 0; i < queries.length; i++) {\n            int queryIndex = queries[i];\n            int value = nums[queryIndex];\n            \n            if (valueToIndices.get(value).size() <= 1) {\n                answer.add(-1);\n                continue;\n            }\n            \n            // Find the minimum circular distance\n            List<Integer> indices = valueToIndices.get(value);\n            int minDistance = Integer.MAX_VALUE;\n            \n            // Find the position of queryIndex in the indices list\n            int pos = Collections.binarySearch(indices, queryIndex);\n            \n            // Check the closest index to the left\n            if (pos > 0) {\n                int leftIdx = indices.get(pos - 1);\n                int distance = Math.min(queryIndex - leftIdx, n - (queryIndex - leftIdx));\n                minDistance = Math.min(minDistance, distance);\n            }\n            \n            if (pos < indices.size() - 1) {\n                int rightIdx = indices.get(pos + 1);\n                int distance = Math.min(rightIdx - queryIndex, n - (rightIdx - queryIndex));\n                minDistance = Math.min(minDistance, distance);\n            }\n            if (pos == 0 && indices.size() > 1) {\n                int lastIdx = indices.get(indices.size() - 1);\n                int distance = Math.min(queryIndex + n - lastIdx, lastIdx - queryIndex);\n                minDistance = Math.min(minDistance, distance);\n            } else if (pos == indices.size() - 1 && indices.size() > 1) {\n                int firstIdx = indices.get(0);\n                int distance = Math.min(queryIndex - firstIdx, n - (queryIndex - firstIdx));\n                minDistance = Math.min(minDistance, distance);\n            }\n            \n            answer.add(minDistance);\n        }\n        \n        return answer;\n    }\n}","author":"ChristopherJiang","submissionId":"1575102686"},[{"id":"21","similarity":0.7063829787234043,"totOverlap":166,"longestOverlap":28}]],"151":[{"id":"151","fileName":"1575103265.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, ArrayList<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (!map.containsKey(nums[i])) map.put(nums[i], new ArrayList<>());\n            map.get(nums[i]).add(i);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int i : queries) {\n            var list = map.get(nums[i]);\n            if (list.size() == 1) {\n                ans.add(-1);\n                continue;\n            }\n            int idx = Collections.binarySearch(list, i);\n            int minDist = 2 * nums.length;\n            minDist = Integer.min(minDist, dist(nums, i, list.get((idx - 1 + list.size()) % list.size())));\n            minDist = Integer.min(minDist, dist(nums, i, list.get((idx + 1) % list.size())));\n            ans.add(minDist);\n        }\n        return ans;\n    }\n    \n    public int dist(int[] nums, int i, int j) {\n        return Math.min(Math.abs(i - j), nums.length - Math.abs(i - j));\n    }\n}","author":"Samuel","submissionId":"1575103265"},[{"id":"151","similarity":0.7142857142857143,"totOverlap":140,"longestOverlap":10}]],"205":[{"id":"205","fileName":"1575105726.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] q) {\n        List<Integer> l = new ArrayList<>();\n        HashMap<Integer,TreeSet<Integer>> map = new HashMap<>();\n        int x=0;\n        for(int i :nums){\n            if(!map.containsKey(i)){\n                map.put(i,new TreeSet<>());\n            }\n            map.get(i).add(x);\n            x++;\n        }\n        for(int i :q){\n            int p = nums[i];\n            TreeSet<Integer> set = map.get(p);\n            if(set.size()==1){\n                l.add(-1);\n                continue;\n            }\n            ArrayList<Integer> list = new ArrayList<>();\n            list.add(set.first());\n            list.add(set.last());\n            if(set.lower(i)!=null){\n                list.add(set.lower(i));\n            }\n            if(set.higher(i)!=null){\n                list.add(set.higher(i));\n            }\n            int ans = nums.length;\n            for(int j : list){\n                if(j!=i){\n                    ans= Math.min(ans,Math.min(Math.abs(j-i), nums.length -Math.abs(j-i)));\n                }\n            }\n                l.add(ans);\n        }\n            return l;\n    }\n}","author":"TechDeck","submissionId":"1575105726"},[{"id":"205","similarity":0.7731958762886598,"totOverlap":150,"longestOverlap":15}]],"226":[{"id":"226","fileName":"1575106701.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        for (List<Integer> list : map.values()) {\n            Collections.sort(list);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int q : queries) {\n            int val = nums[q];\n            List<Integer> ind = map.get(val);\n            if (ind.size() == 1) {\n                ans.add(-1);\n                continue;\n            }\n            int pos = Collections.binarySearch(ind, q);\n            int prev = (pos - 1 + ind.size()) % ind.size();\n            int next = (pos + 1) % ind.size();\n            int d1 = Math.abs(q - ind.get(prev));\n            d1 = Math.min(d1, n - d1);\n            int d2 = Math.abs(q - ind.get(next));\n            d2 = Math.min(d2, n - d2);\n            ans.add(Math.min(d1, d2));\n        }\n        return ans;\n        \n    }\n}","author":"abcdabcdefgh","submissionId":"1575106701"},[{"id":"1568","similarity":0.8926829268292683,"totOverlap":183,"longestOverlap":47},{"id":"1568","similarity":0.875,"totOverlap":182,"longestOverlap":41},{"id":"1568","similarity":0.8403755868544601,"totOverlap":179,"longestOverlap":21},{"id":"952","similarity":0.8246445497630331,"totOverlap":174,"longestOverlap":24}]],"235":[{"id":"235","fileName":"1575106836.txt","sourceCode":"class Solution {\n    public int cd(int i, int j, int n) {\n        int diff = Math.abs(i - j);\n        return Math.min(diff, n - diff);\n    }\n\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        List<Integer> result = new ArrayList<>();\n        Map<Integer, List<Integer>> p = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            p.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        for (int q : queries) {\n            int value = nums[q];\n            List<Integer> pl = p.get(value);\n            if (pl.size() < 2) {\n                result.add(-1);\n                continue;\n            }\n            int pos = Collections.binarySearch(pl, q);\n            int c = Integer.MAX_VALUE;\n            if (pos > 0) {\n                c = Math.min(c, cd(q, pl.get(pos - 1), n));\n            }\n            if (pos < pl.size() - 1) {\n                c = Math.min(c, cd(q, pl.get(pos + 1), n));\n            }\n            if (pos == 0) {\n                c = Math.min(c, cd(q, pl.get(pl.size() - 1), n));\n            }\n            if (pos == pl.size() - 1) {\n                c = Math.min(c, cd(q, pl.get(0), n));\n            }\n\n            result.add(c);\n        }\n\n        return result;\n    }\n}","author":"MONISH REDDY","submissionId":"1575106836"},[{"id":"235","similarity":0.7459016393442623,"totOverlap":182,"longestOverlap":22}]],"255":[{"id":"255","fileName":"1575107845.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n\n        int n = nums.length;\n\n        Map<Integer, List<Integer>> map = new HashMap<>();\n\n        for (int i = 0; i < n; i++) {\n\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n\n        }\n\n        List<Integer> result = new ArrayList<>();\n\n        for (int q : queries) {\n\n            int num = nums[q];\n\n            List<Integer> posList = map.get(num);\n\n            if (posList.size() == 1) {\n\n                result.add(-1);\n\n                continue;\n\n            }\n\n            int idx = Collections.binarySearch(posList, q);\n\n            int minDist = Integer.MAX_VALUE;\n\n            if (idx > 0) {\n\n                int leftNeighbor = posList.get(idx - 1);\n\n                int diff = q - leftNeighbor;\n\n                minDist = Math.min(minDist, Math.min(diff, n - diff));\n\n            }\n\n            if (idx < posList.size() - 1) {\n\n                int rightNeighbor = posList.get(idx + 1);\n\n                int diff = rightNeighbor - q;\n\n                minDist = Math.min(minDist, Math.min(diff, n - diff));\n\n            }\n\n            if (idx == 0) {\n\n                int last = posList.get(posList.size() - 1);\n\n                int diff = (q + n - last) % n;\n\n                minDist = Math.min(minDist, diff);\n\n            }\n\n            if (idx == posList.size() - 1) {\n\n                int first = posList.get(0);\n\n                int diff = (first + n - q) % n;\n\n                minDist = Math.min(minDist, diff);\n\n            }\n\n            result.add(minDist);\n\n        }\n\n        return result;\n\n    }\n\n}","author":"Shanjay Piranav M J","submissionId":"1575107845"},[{"id":"255","similarity":0.8524590163934426,"totOverlap":208,"longestOverlap":57}]],"276":[{"id":"276","fileName":"1575109191.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] delhi, int[] mumbai) {\n        int chennai = china(delhi);\n        int[] kolkata = japan(chennai);\n        HashMap<Integer, List<Integer>> hyderabad = germany(delhi);\n        australia(hyderabad, kolkata, chennai);\n        return brazil(mumbai, kolkata);\n    }\n    private int china(int[] delhi) {\n        return delhi.length;\n    }\n\n    private int[] japan(int chennai) {\n        int[] kolkata = new int[chennai];\n        Arrays.fill(kolkata, -1);\n        return kolkata;\n    }\n\n    private HashMap<Integer, List<Integer>> germany(int[] delhi) {\n        HashMap<Integer, List<Integer>> hyderabad = new HashMap<>();\n        for (int i = 0; i < delhi.length; i++) {\n            hyderabad.computeIfAbsent(delhi[i], k -> new ArrayList<>()).add(i);\n        }\n        return hyderabad;\n    }\n\n    private void australia(HashMap<Integer, List<Integer>> hyderabad, int[] kolkata, int chennai) {\n        for (List<Integer> bangalore : hyderabad.values()) {\n            if (bangalore.size() < 2) continue;\n            Collections.sort(bangalore);\n            russia(bangalore, kolkata, chennai);\n        }\n    }\n\n    private void russia(List<Integer> bangalore, int[] kolkata, int chennai) {\n        int size = bangalore.size();\n        for (int j = 0; j < size; j++) {\n            int jaipur = bangalore.get(j);\n            int lucknow = bangalore.get((j - 1 + size) % size);\n            int pune = bangalore.get((j + 1) % size);\n            kolkata[jaipur] = italy(jaipur, lucknow, pune, chennai);\n        }\n    }\n\n    private int italy(int jaipur, int lucknow, int pune, int chennai) {\n        int diffPrev = Math.abs(jaipur - lucknow);\n        int diffNext = Math.abs(pune - jaipur);\n        int candidatePrev = Math.min(diffPrev, chennai - diffPrev);\n        int candidateNext = Math.min(diffNext, chennai - diffNext);\n        return Math.min(candidatePrev, candidateNext);\n    }\n\n    private List<Integer> brazil(int[] mumbai, int[] kolkata) {\n        List<Integer> results = new ArrayList<>();\n        for (int q : mumbai) {\n            results.add(kolkata[q]);\n        }\n        return results;\n    }\n}","author":"Thrisha","submissionId":"1575109191"},[{"id":"1215","similarity":0.7509578544061303,"totOverlap":196,"longestOverlap":19},{"id":"114","similarity":0.7836538461538461,"totOverlap":163,"longestOverlap":33}]],"298":[{"id":"298","fileName":"1575110225.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> mp = new HashMap<>();\n\n        for (int i = 0; i < n; i++) {\n            mp.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n\n        List<Integer> ans = new ArrayList<>();\n        for (int idx : queries) {\n            int val = nums[idx];\n\n            List<Integer> positions = mp.get(val);\n            if (positions.size() == 1) {\n                ans.add(-1);\n                continue;\n            }\n            int pos = Collections.binarySearch(positions, idx);\n            if (pos < 0) pos = -pos - 1;\n\n            int mini = Integer.MAX_VALUE;\n            if (pos < positions.size() - 1) {\n                mini = Math.min(mini, positions.get(pos + 1) - idx);\n            }\n            if (pos > 0) {\n                mini = Math.min(mini, idx - positions.get(pos - 1));\n            }\n\n            int first = positions.get(0);\n            int last = positions.get(positions.size() - 1);\n            mini = Math.min(mini, n - Math.abs(idx - first));\n            mini = Math.min(mini, n - Math.abs(idx - last));\n\n            ans.add(mini);\n        }\n        return ans;\n\n    }\n}","author":"Atul Bora","submissionId":"1575110225"},[{"id":"298","similarity":0.7911111111111111,"totOverlap":178,"longestOverlap":58}]],"330":[{"id":"330","fileName":"1575111632.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        for (List<Integer> list : map.values()) {\n            list.sort((a,b)->a-b);\n        }\n        \n        List<Integer> res = new ArrayList<>();\n        for (int i = 0; i < queries.length; i++) {\n            int q = queries[i];\n            int value = nums[q];\n            List<Integer> pos = map.get(value);\n            if (pos.size() == 1) {\n                res.add(-1);\n                continue;\n            }\n            int p = Collections.binarySearch(pos, q);\n            \n            int size = pos.size();\n            int prevIndex = pos.get((p - 1 + size) % size);\n            int nextIndex = pos.get((p + 1) % size);\n            int d1 = Math.min(Math.abs(q - prevIndex), n - Math.abs(q - prevIndex));\n            int d2 = Math.min(Math.abs(q - nextIndex), n - Math.abs(q - nextIndex));\n            res.add(Math.min(d1, d2));\n        }\n        \n        return res;\n    }\n    \n  \n}\n","author":"Ankith_Kumar","submissionId":"1575111632"},[{"id":"95","similarity":0.9146919431279621,"totOverlap":193,"longestOverlap":51}]],"358":[{"id":"358","fileName":"1575112615.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> hm = new HashMap<>();\n        for (int i = 0; i < n; i++)  hm.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        for (List<Integer> list : hm.values()) Collections.sort(list);\n        \n        List<Integer> res = new ArrayList<>();\n        for (int i = 0; i < queries.length; i++) {\n            int x = queries[i];\n            int y = nums[x];\n            List<Integer> li = hm.get(y);\n            if (li.size() == 1) {\n                res.add(-1);\n                continue;\n            }\n            int pos = Collections.binarySearch(li, x);\n            int l = pos - 1;\n            int r = pos + 1;\n            if (l < 0) l = li.size() - 1;\n            if (r >= li.size()) r = 0;\n            \n            int d1 = Math.abs(x - li.get(l));\n            d1 = Math.min(d1, n - d1);\n            int d2 = Math.abs(x - li.get(r));\n            d2 = Math.min(d2, n - d2);\n            res.add(Math.min(d1, d2));\n        }\n        return res;\n    }\n}","author":"Vansh Agrawal","submissionId":"1575112615"},[{"id":"95","similarity":0.8407960199004975,"totOverlap":169,"longestOverlap":34}]],"361":[{"id":"361","fileName":"1575112666.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        List<Integer> ans = new ArrayList<>();\n\n        Map<Integer, List<Integer>> mp = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            mp.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        for (int query : queries) {\n            int target = nums[query];\n\n            List<Integer> idx = mp.get(target);\n\n            if (idx == null || idx.size() == 1) {\n                ans.add(-1);\n                continue;\n            }\n\n            int minDistance = n;\n            int queryIndex = Collections.binarySearch(idx, query);\n\n            int left = (queryIndex - 1 + idx.size()) % idx.size();\n            int right = (queryIndex + 1) % idx.size();\n            minDistance = Math.min(minDistance, Math.min(\n                Math.abs(idx.get(left) - query),\n                n - Math.abs(idx.get(left) - query)\n            ));\n\n            minDistance = Math.min(minDistance, Math.min(\n                Math.abs(idx.get(right) - query),\n                n - Math.abs(idx.get(right) - query)\n            ));\n\n            ans.add(minDistance);\n        }\n\n        return ans;\n    }\n}","author":"CodeCrafterYash","submissionId":"1575112666"},[{"id":"361","similarity":0.8403755868544601,"totOverlap":179,"longestOverlap":21}]],"365":[{"id":"365","fileName":"1575112719.txt","sourceCode":"class Solution {\n  public List<Integer> solveQueries(int[] nums, int[] queries) {\n    Map<Integer, List<Integer>> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int curr = nums[i];\n      if (!map.containsKey(curr)) {\n         map.put(curr, new ArrayList<>()); \n      }\n      map.get(curr).add(i);\n    }\n\n    for (int n : map.keySet()) {\n      Collections.sort(map.get(n));\n    }\n\n    List<Integer> ret = new ArrayList<>();\n    for (int i = 0; i < queries.length; i++) {\n      int idx = queries[i], val = nums[idx];\n      List<Integer> curr = map.get(val);\n      if (curr.size() == 1) {\n        ret.add(-1);\n        continue;\n      }\n\n      int m = Collections.binarySearch(curr, idx);\n      int l = curr.get((m - 1 + curr.size()) % curr.size());\n      int r = curr.get((m + 1 + curr.size()) % curr.size());\n\n      int lD = Math.min(Math.abs(l - idx), nums.length - Math.abs(l - idx));\n      int rD = Math.min(Math.abs(r - idx), nums.length - Math.abs(r - idx));\n      ret.add(Math.min(lD, rD));\n    }\n    return ret;\n  }\n}","author":"Zachary Bi","submissionId":"1575112719"},[{"id":"330","similarity":0.7377777777777778,"totOverlap":166,"longestOverlap":19}]],"367":[{"id":"367","fileName":"1575112924.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer,TreeSet<Integer>> map = new HashMap<>();\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            TreeSet<Integer> tree = map.getOrDefault(nums[i], new TreeSet<>());\n            tree.add(i);\n            map.put(nums[i], tree);\n        }\n        List<Integer> res = new ArrayList<>();\n        for (int i = 0; i < queries.length; i++) {\n            int pos = queries[i], num = nums[pos];\n            TreeSet<Integer> tree = map.get(num);\n            int dist = Integer.MAX_VALUE;\n            Integer prev = tree.lower(pos), next = tree.higher(pos);\n            if (prev != null) dist = Math.min(dist, pos - prev);\n            else {\n                prev = tree.last();\n                if (prev != pos) dist = Math.min(dist, pos + n - prev);\n            }\n            if (next != null) dist = Math.min(dist, next - pos);\n            else {\n                next = tree.first();\n                if (next != pos) dist = Math.min(dist, next + n - pos);\n            }\n            res.add(dist == Integer.MAX_VALUE ? -1 : dist);\n        }\n        return res;\n    }\n}","author":"hulot-bak","submissionId":"1575112924"},[{"id":"1547","similarity":0.8018867924528302,"totOverlap":170,"longestOverlap":16},{"id":"1547","similarity":0.7183098591549296,"totOverlap":153,"longestOverlap":25},{"id":"465","similarity":0.7081339712918661,"totOverlap":148,"longestOverlap":28}]],"371":[{"id":"371","fileName":"1575112967.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> posMap = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            posMap.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        for (List<Integer> list : posMap.values()) {\n            Collections.sort(list);\n        }\n        List<Integer> result = new ArrayList<>();\n        for (int q : queries) {\n            int val = nums[q];\n            List<Integer> indices = posMap.get(val);\n            int ans;\n            if (indices.size() < 2) {\n                ans = -1;\n            } else {\n                int pos = Collections.binarySearch(indices, q);\n                int prev = indices.get((pos - 1 + indices.size()) % indices.size());\n                int next = indices.get((pos + 1) % indices.size());\n                int d1 = Math.abs(q - prev);\n                int d2 = Math.abs(q - next);\n                d1 = Math.min(d1, n - d1);\n                d2 = Math.min(d2, n - d2);\n                ans = Math.min(d1, d2);\n            }\n            result.add(ans);\n        }\n        return result;\n    }\n}","author":"pragathish007","submissionId":"1575112967"},[{"id":"607","similarity":0.9067357512953368,"totOverlap":175,"longestOverlap":48},{"id":"1004","similarity":0.9259259259259259,"totOverlap":175,"longestOverlap":39},{"id":"607","similarity":0.8871794871794871,"totOverlap":173,"longestOverlap":22},{"id":"546","similarity":0.8826530612244898,"totOverlap":173,"longestOverlap":27}]],"409":[{"id":"409","fileName":"1575114475.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (!map.containsKey(nums[i])) {\n                map.put(nums[i], new ArrayList<>());\n            }\n            map.get(nums[i]).add(i);\n        }\n\n        List<Integer> ans = new ArrayList<>();\n        for (int q : queries) {\n            List<Integer> list = map.get(nums[q]);\n            if (list.size() == 1) {\n                ans.add(-1);\n                continue;\n            }\n            int i = bs(list, q);\n            int distance;\n            if (i == 0) {\n                distance = Math.min(list.get(1) - list.get(0), list.get(0) + nums.length - list.getLast());\n            } else if (i == list.size() - 1) {\n                distance = Math.min(list.getLast() - list.get(i - 1), list.getFirst() + nums.length - list.getLast());\n            } else {\n                distance = Math.min(list.get(i) - list.get(i - 1), list.get(i + 1) - list.get(i));\n            }\n            ans.add(distance);\n        }\n        return ans;\n    }\n\n    private int bs(List<Integer> list, int t) {\n        int left = 0, right = list.size() - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (list.get(mid) == t) {\n                return mid;\n            }\n            if (list.get(mid) < t) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return -1;\n    }\n}","author":"Tianqi","submissionId":"1575114475"},[{"id":"409","similarity":0.797752808988764,"totOverlap":213,"longestOverlap":27}]],"465":[{"id":"465","fileName":"1575116370.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer,TreeSet<Integer>> mp = new HashMap<>();\n        for(int i=0;i<n;i++){\n            if(!mp.containsKey(nums[i])) mp.put(nums[i], new TreeSet<>());\n            mp.get(nums[i]).add(i);\n        }\n        // int c = -1;\n        // for(int i=n-1;i>=0;i--) mp.get(nums[i]).add(c--);\n        List<Integer> ans = new ArrayList<>();\n        for(int x:queries){\n            int val = nums[x];\n            TreeSet<Integer> set = mp.get(val);\n            if(set.size()==1){\n                ans.add(-1);\n                continue;\n            }\n            // System.out.println(set);\n            Integer l = set.lower(x);\n            Integer r = set.higher(x);\n            if(l==null) l = set.last();\n            if(r==null) r = set.first();\n            // System.out.println(l + \" \" + r);\n            int dis = Integer.MAX_VALUE;\n            if(l!=x) dis = Math.min(Math.abs(x-l), n-Math.abs(x-l));\n            if(r!=x) dis = Math.min(dis, Math.min(Math.abs(x-r), n-Math.abs((x-r))));\n            ans.add(dis);\n        }\n        return ans;\n    }\n}","author":"BJbTI92iGT","submissionId":"1575116370"},[{"id":"826","similarity":0.845,"totOverlap":169,"longestOverlap":44},{"id":"826","similarity":0.8291457286432161,"totOverlap":165,"longestOverlap":26}]],"530":[{"id":"530","fileName":"1575118152.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n       \n\nint n = nums.length;\n\nMap<Integer, List<Integer>> indexMap = new HashMap<>();\n\nfor (int i = 0; i < n; i++) {\n\n    indexMap.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n\n}\n\nfor (List<Integer> list : indexMap.values()) {\n\n    Collections.sort(list);\n\n}\n\nList<Integer> answer = new ArrayList<>();\n\nfor (int q : queries) {\n\n    List<Integer> L = indexMap.get(nums[q]);\n\n    if (L.size() == 1) {\n\n        answer.add(-1);\n\n    } else {\n\n        int pos = Collections.binarySearch(L, q);\n\n        int k = L.size();\n\n        int j1 = L.get((pos - 1 + k) % k);\n\n        int j2 = L.get((pos + 1) % k);\n\n        int dist1 = Math.min(Math.abs(q - j1), n - Math.abs(q - j1));\n\n        int dist2 = Math.min(Math.abs(q - j2), n - Math.abs(q - j2));\n\n        answer.add(Math.min(dist1, dist2));\n\n    }\n\n}\n\nreturn answer;\n    }\n}","author":"Pedamallu Umesh Gupta","submissionId":"1575118152"},[{"id":"330","similarity":0.8472906403940886,"totOverlap":172,"longestOverlap":41}]],"546":[{"id":"546","fileName":"1575118638.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> positions = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            positions.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        \n        List<Integer> answer = new ArrayList<>();\n        \n        for (int query : queries) {\n            int value = nums[query];\n            List<Integer> list = positions.get(value);\n            \n            if (list.size() == 1) {\n                answer.add(-1);\n            } else {\n                int pos = Collections.binarySearch(list, query);\n                int leftIndex = (pos - 1 + list.size()) % list.size();\n                int rightIndex = (pos + 1) % list.size();               \n                int leftCandidate = list.get(leftIndex);\n                int rightCandidate = list.get(rightIndex);\n                int diffLeft = Math.abs(query - leftCandidate);\n                int diffRight = Math.abs(query - rightCandidate);\n                int circularLeft = Math.min(diffLeft, n - diffLeft);\n                int circularRight = Math.min(diffRight, n - diffRight);\n    \n                answer.add(Math.min(circularLeft, circularRight));\n            }\n        }\n        return answer;\n    }\n}","author":"Suhail Ansari","submissionId":"1575118638"},[{"id":"546","similarity":0.875,"totOverlap":182,"longestOverlap":41}]],"568":[{"id":"568","fileName":"1575119118.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] arr) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        \n        for (int i = 0; i < n; i++) {\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        \n        for (List<Integer> i : map.values()) {\n            Collections.sort(i);\n        }\n        \n        List<Integer> list = new ArrayList<>();\n        \n        for (int q : arr) {\n            int cur = nums[q];\n            List<Integer> i = map.get(cur);\n            if (i.size() == 1) {\n                list.add(-1);\n                continue;\n            }\n            int l = Collections.binarySearch(i, q);\n            if (l < 0) {\n                l = -l - 1;\n            }\n            int sum = Integer.MAX_VALUE;\n            if (l > 0) {\n                int diff = Math.abs(q - i.get(l - 1));\n                sum = Math.min(sum, Math.min(diff, n - diff));\n            }\n            if (l < i.size() - 1) {\n                int diff = Math.abs(i.get(l + 1) - q);\n                sum = Math.min(sum, Math.min(diff, n - diff));\n            }\n            if (l == 0) {\n                int diff = Math.abs(q - i.get(i.size() - 1));\n                sum = Math.min(sum, Math.min(diff, n - diff));\n            }\n            if (l == i.size() - 1) {\n                int diff = Math.abs(q - i.get(0));\n                sum = Math.min(sum, Math.min(diff, n - diff));\n            }\n            list.add(sum);\n        }\n        return list;\n    }\n}","author":"Ayyappan M P","submissionId":"1575119118"},[{"id":"1030","similarity":0.90234375,"totOverlap":231,"longestOverlap":52},{"id":"1030","similarity":0.8524590163934426,"totOverlap":208,"longestOverlap":57},{"id":"568","similarity":0.7459016393442623,"totOverlap":182,"longestOverlap":22},{"id":"1030","similarity":0.7911111111111111,"totOverlap":178,"longestOverlap":58},{"id":"568","similarity":0.7196652719665272,"totOverlap":172,"longestOverlap":47}]],"607":[{"id":"607","fileName":"1575120634.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        for (List<Integer> lst : map.values()) {\n            Collections.sort(lst);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int q : queries) {\n            int val = nums[q];\n            List<Integer> lst = map.get(val);\n            if (lst.size() == 1) {\n                ans.add(-1);\n            } else {\n                int pos = Collections.binarySearch(lst, q);\n                int left = lst.get((pos - 1 + lst.size()) % lst.size());\n                int right = lst.get((pos + 1) % lst.size());\n                int d1 = Math.abs(q - left);\n                d1 = Math.min(d1, n - d1);\n                int d2 = Math.abs(q - right);\n                d2 = Math.min(d2, n - d2);\n                ans.add(Math.min(d1, d2));\n            }\n        }\n        return ans;\n    }\n}\n","author":"Abhishek Tripathi Kuberji","submissionId":"1575120634"},[{"id":"371","similarity":0.9067357512953368,"totOverlap":175,"longestOverlap":48}]],"616":[{"id":"616","fileName":"1575121023.txt","sourceCode":"class Solution {\n\n    public int bs(List<Integer> list, int q) {\n        int i=0, j=list.size() - 1;\n\n        while(i <= j) {\n            int mid = (i + j) / 2;\n            if(list.get(mid) == q) {\n                return mid;\n            } else if(list.get(mid) > q) {\n                j = mid - 1;\n            } else {\n                i = mid + 1;\n            }\n        }\n\n        return -1;\n    }\n\n    public int minDistance(List<Integer> list, int query, int n) {\n        final int m = list.size();\n        int index = bs(list, query);\n\n        int nearest1 = list.get((index - 1 + m) % m);\n        int nearest2 = list.get((index + 1) % m);\n\n        int val1 = Math.abs(query - nearest1);\n        val1 = Math.min(val1, n - val1);\n\n        int val2 = Math.abs(query - nearest2);\n        val2 = Math.min(val2, n - val2);\n\n        return Math.min(val1, val2);\n    }\n    \n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        final int n = nums.length;\n        final int q = nums.length;\n        \n        HashMap<Integer, List<Integer>> map = new HashMap<>();\n\n        for(int i=0; i<n; i++) {\n            map.putIfAbsent(nums[i], new ArrayList<>());\n            map.get(nums[i]).add(i);\n        }\n\n        List<Integer> ans = new ArrayList<>();\n        for(int query: queries) {\n            int key = nums[query];\n            List<Integer> list = map.get(key);\n            if(list.size() == 1) {\n                ans.add(-1);\n            } else {\n                ans.add(minDistance(list, query, n));\n            }\n\n           \n        }\n\n        return ans;\n    }\n}","author":"Jayakrishna Paripelli","submissionId":"1575121023"},[{"id":"616","similarity":0.7074235807860262,"totOverlap":162,"longestOverlap":21}]],"620":[{"id":"620","fileName":"1575121091.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> indexMap = new HashMap<>();\n        int n = nums.length;\n        \n        for (int i = 0; i < n; i++) {\n            indexMap.putIfAbsent(nums[i], new ArrayList<>());\n            indexMap.get(nums[i]).add(i);\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        \n        for (int query : queries) {\n            int value = nums[query];\n            \n            if (!indexMap.containsKey(value) || indexMap.get(value).size() == 1) {\n                result.add(-1);\n                continue;\n            }\n            \n            List<Integer> positions = indexMap.get(value);\n            int minDistance = Integer.MAX_VALUE;\n            \n            int idx = Collections.binarySearch(positions, query);\n            //System.out.println(positions);\n           // System.out.println(idx+\" \"+query);\n            if (idx < 0) idx = -idx - 1; \n            \n            if (idx+1 < positions.size()) {\n                \n                minDistance = Math.min(minDistance, Math.abs(positions.get(idx+1) - query));\n            }\n            if (idx > 0) {\n                minDistance = Math.min(minDistance, Math.abs(positions.get(idx - 1) - query));\n            }\n            \n            int first = positions.get(0);\n            int last = positions.get(positions.size() - 1);\n            minDistance = Math.min(minDistance, Math.min(query + n - last, first + n - query));\n\n            result.add(minDistance);\n        }\n        \n        return result;\n    }\n}\n","author":"chauhan_shivam","submissionId":"1575121091"},[{"id":"620","similarity":0.7897196261682243,"totOverlap":169,"longestOverlap":28}]],"642":[{"id":"642","fileName":"1575121651.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for(int i = 0; i < n; i++)\n        {\n            if(!map.containsKey(nums[i])) map.put(nums[i], new ArrayList<>());\n            map.get(nums[i]).add(i);\n        }\n        List<Integer> list = new ArrayList<>();\n        for(int q : queries)\n        {\n            int idx = q;\n            int val = nums[idx];\n            List<Integer> vlist = map.get(val);\n            if(vlist.size() == 1)\n            {\n                list.add(-1);\n                continue;\n            }\n            list.add(nextItem(vlist, idx, n));\n        }\n        return list;\n    }\n    \n    int nextItem(List<Integer> list, int value, int ss)\n    {\n        int pos = findpos(list, value);\n        int size = list.size();\n        int pos0 = (pos - 1 + size) % size, pos1 = (pos + 1) % size;\n        // System.out.println(list);\n        // System.out.printf(\"targ= %d pos=%d p0 = %d p1 = %dn\", value, pos, pos0, pos1);\n        int d1 = dist(list.get(pos0), value, ss), d2 = dist(list.get(pos1), value, ss);\n        return Math.min(d1, d2);\n    }\n    \n    int dist(int d1, int d2, int n)\n    {\n        // System.out.printf(\"d1=%d d2=%d n=%dn\", d1, d2, n);\n        int e1 = Math.abs(d1 - d2);\n        int e2 = Math.min(d1, d2) + n - Math.max(d1, d2);\n        return Math.min(e1, e2);\n    }\n    \n    int findpos(List<Integer> list, int targ)\n    {\n        return Collections.binarySearch(list, targ);\n//         int lo = 0, hi = list.size() - 1;\n//         while(lo < hi)\n//         {\n            \n//         }\n    }\n}","author":"xianglaniunan","submissionId":"1575121651"},[{"id":"642","similarity":0.7018348623853211,"totOverlap":153,"longestOverlap":17}]],"703":[{"id":"703","fileName":"1575122786.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        HashMap<Integer, List<Integer>> mp = new HashMap<>(); \n        for (int i = 0; i < n; i++) {\n            mp.putIfAbsent(nums[i], new ArrayList<>());\n            mp.get(nums[i]).add(i);\n        }\n        \n        List<Integer> res = new ArrayList<>();\n        \n        for (int query : queries) {\n            int target = nums[query];\n            List<Integer> indices = mp.get(target); \n            if (indices.size() <= 1) {\n                res.add(-1);\n                continue;\n            } \n            int pos = Collections.binarySearch(indices, query);\n            int minDist = Integer.MAX_VALUE; \n            int prev = (pos > 0) ? indices.get(pos - 1) : indices.get(indices.size() - 1);\n            if (prev != query) {\n                int directDist = Math.abs(query - prev);\n                int circularDist = n - directDist;\n                minDist = Math.min(directDist, circularDist);\n            }\n             \n            int next = (pos < indices.size() - 1) ? indices.get(pos + 1) : indices.get(0);\n            if (next != query) {\n                int directDist = Math.abs(query - next);\n                int circularDist = n - directDist;\n                minDist = Math.min(minDist, Math.min(directDist, circularDist));\n            }\n            \n            res.add(minDist);\n        }\n        \n        return res;\n    }\n}","author":"SOMANATH MIKALI","submissionId":"1575122786"},[{"id":"703","similarity":0.7336448598130841,"totOverlap":157,"longestOverlap":26}]],"768":[{"id":"768","fileName":"1575124643.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> valToIndices = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            valToIndices.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        for (List<Integer> list : valToIndices.values()) {\n            Collections.sort(list);\n        }\n        List<Integer> result = new ArrayList<>();\n        for (int q : queries) {\n            int val = nums[q];\n            List<Integer> list = valToIndices.get(val);\n            if (list.size() < 2) {\n                result.add(-1);\n                continue;\n            }\n            int pos = Collections.binarySearch(list, q);\n            int prevPos = (pos == 0) ? list.size() - 1 : pos - 1;\n            int nextPos = (pos == list.size() - 1) ? 0 : pos + 1;\n            int dist1 = circularDistance(q, list.get(prevPos), n);\n            int dist2 = circularDistance(q, list.get(nextPos), n);\n            result.add(Math.min(dist1, dist2));\n        }\n        return result;\n    }\n    \n    private int circularDistance(int i, int j, int n) {\n        int diff = Math.abs(i - j);\n        return Math.min(diff, n - diff);\n    }\n    \n}","author":"lily_shen","submissionId":"1575124643"},[{"id":"1281","similarity":0.7867298578199052,"totOverlap":166,"longestOverlap":27},{"id":"768","similarity":0.7836538461538461,"totOverlap":163,"longestOverlap":47}]],"773":[{"id":"773","fileName":"1575124679.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, ArrayList<Integer>> indexesOfValues = new HashMap<>();\n\n        for (int index = 0; index < nums.length; ++index) {\n            int value = nums[index];\n            if (!indexesOfValues.containsKey(value)) {\n                indexesOfValues.put(value, new ArrayList<>());\n            }\n\n            indexesOfValues.get(value).add(index);\n        }\n\n        ArrayList<Integer> result = new ArrayList<>();\n        for (int index = 0; index < queries.length; ++index) {\n            int query = queries[index];\n            int valueOfQuery = nums[query];\n            ArrayList<Integer> indexesOfTheSameValue = indexesOfValues.get(valueOfQuery);\n            if (indexesOfTheSameValue.size() == 1) {\n                result.add(-1);\n            } else {\n                int leftIndex = 0;\n                int rightIndex = indexesOfTheSameValue.size() - 1;\n                int indexOfValue = -1;\n                while (leftIndex <= rightIndex) {\n                    int midIndex = (leftIndex + rightIndex) / 2;\n                    if (indexesOfTheSameValue.get(midIndex) == query) {\n                        indexOfValue = midIndex;\n                        break;\n                    }\n\n                    if (indexesOfTheSameValue.get(midIndex) < query) {\n                        leftIndex = midIndex + 1;\n                    } else {\n                        rightIndex = midIndex - 1;\n                    }\n                }\n\n                if (indexOfValue == 0) {\n                    result.add(Math.min(indexesOfTheSameValue.get(1) - query, nums.length - indexesOfTheSameValue.get(indexesOfTheSameValue.size() - 1) + query));\n                } else {\n                    if (indexOfValue == indexesOfTheSameValue.size() - 1) {\n                        result.add(Math.min(indexesOfTheSameValue.get(0) + (nums.length - query), query - indexesOfTheSameValue.get(indexesOfTheSameValue.size() - 2)));\n                    } else {\n                        result.add(Math.min(query - indexesOfTheSameValue.get(indexOfValue - 1), indexesOfTheSameValue.get(indexOfValue + 1) - query));\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n}","author":"Stanislau2","submissionId":"1575124679"},[{"id":"773","similarity":0.7091633466135459,"totOverlap":178,"longestOverlap":16}]],"783":[{"id":"783","fileName":"1575124934.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        List<Integer> res = new ArrayList<>();\n        for (int i : queries) {\n            int x = nums[i];\n            List<Integer> arr = map.get(x);\n            int m = arr.size();\n            if (m == 1) {\n                res.add(-1);\n            } else {\n                int idx = Collections.binarySearch(arr, i);\n                int cur1 = Math.abs(arr.get((idx - 1 + m) % m) - i);\n                int cur2 = Math.abs(arr.get((idx + 1) % m) - i);\n                cur1 = Math.min(cur1, n - cur1);\n                cur2 = Math.min(cur2, n - cur2);\n                res.add(Math.min(cur1, cur2));\n            }\n        }\n        return res;\n    }\n}\n\n/*\n\n[1,3,1,4,1,3,2]\n\n1: [0,2,4]\n\nquery[2] = 5\ni = 5\nx = 3\narr = [1,5]\n         ^idx\nidx = 0\n\n\n*/","author":"sunsq","submissionId":"1575124934"},[{"id":"546","similarity":0.8478260869565217,"totOverlap":156,"longestOverlap":43}]],"798":[{"id":"798","fileName":"1575125416.txt","sourceCode":"import java.util.*;\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> im = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            im.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        List<Integer> result = new ArrayList<>();\n        for (int query : queries) {\n            int num = nums[query];\n            List<Integer> pos = im.get(num);\n            if (pos.size() <= 1) {\n                result.add(-1);\n                continue;\n            }\n            int idx = Collections.binarySearch(pos, query);\n            int l = (idx - 1 + pos.size()) % pos.size();\n            int r = (idx + 1) % pos.size();\n            int dl = getDistance(query, pos.get(l), n);\n            int dr = getDistance(query, pos.get(r), n);\n            result.add(Math.min(dl, dr));\n        }\n        return result;\n    }\n    private int getDistance(int a, int b, int n) {\n        int diff = Math.abs(a - b);\n        return Math.min(diff, n - diff);\n    }\n}\n","author":"Nivin Ashinth KJ","submissionId":"1575125416"},[{"id":"546","similarity":0.8636363636363636,"totOverlap":171,"longestOverlap":47}]],"817":[{"id":"817","fileName":"1575126007.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            map.putIfAbsent(nums[i], new ArrayList<>());\n            map.get(nums[i]).add(i);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int q : queries) {\n            int num = nums[q];\n            List<Integer> list = map.get(num);\n            if (list.size() == 1) {\n                ans.add(-1);\n                continue;\n            }\n            int j = lowerBound(list, q);\n            int x = n;\n            if (j == list.size() - 1) {\n                x = Math.min(x, n + list.get(0) - q);\n            }\n            else {\n                x = Math.min(x, list.get(j + 1) - q);\n            }\n            if (j == 0) {\n                x = Math.min(x, n + q - list.get(list.size() - 1));\n            }\n            else {\n                x = Math.min(x, q - list.get(j - 1));\n            }\n            ans.add(x);\n        }\n        return ans;\n    }\n    public int lowerBound(List<Integer> list, int q) {\n        int lo = 0;\n        int hi = list.size();\n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (list.get(mid) >= q) {\n                hi = mid;\n            }\n            else {\n                lo = mid + 1;\n            }\n        }\n        return lo;\n    }\n}","author":"Yinghua Hu","submissionId":"1575126007"},[{"id":"817","similarity":0.7051792828685259,"totOverlap":177,"longestOverlap":9}]],"826":[{"id":"826","fileName":"1575126243.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, TreeSet<Integer>> map = new HashMap<>();\n        \n        for(int i = 0; i < n; i++)\n            map.computeIfAbsent(nums[i], k -> new TreeSet<>()).add(i);\n        \n        List<Integer> res = new ArrayList<>();\n        for(int query : queries){\n            int value = nums[query];\n            TreeSet<Integer> indices = map.get(value);\n            \n            if(indices.size() == 1){\n                res.add(-1);\n                continue;\n            }\n            \n            Integer lower = indices.lower(query);  \n            Integer higher = indices.higher(query); \n            \n            if(lower == null)\n                lower = indices.last();\n            if(higher == null)\n                higher = indices.first();\n            \n            int lowDist = Math.min(Math.abs(query - lower), n - Math.abs(query - lower));\n            int highDist = Math.min(Math.abs(query - higher), n - Math.abs(query - higher));\n            \n            res.add(Math.min(lowDist, highDist));\n        }\n        \n        return res;\n    }\n}","author":"Sandesh Atulya","submissionId":"1575126243"},[{"id":"465","similarity":0.845,"totOverlap":169,"longestOverlap":44}]],"856":[{"id":"856","fileName":"1575127168.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> indexMap = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            indexMap.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int q : queries) {\n            int value = nums[q];\n            List<Integer> positions = indexMap.get(value);\n            if (positions.size() == 1) {\n                ans.add(-1);\n                continue;\n            }\n            int pos = Collections.binarySearch(positions, q);\n            int left = positions.get((pos - 1 + positions.size()) % positions.size());\n            int right = positions.get((pos + 1) % positions.size());\n            int d1 = Math.abs(q - left);\n            int d2 = Math.abs(q - right);\n            int cd1 = n - d1;\n            int cd2 = n - d2;\n            int best = Math.min(Math.min(d1, d2), Math.min(cd1, cd2));\n            ans.add(best);\n        }\n        return ans;\n        \n    }\n}","author":"Shivansh Shukla","submissionId":"1575127168"},[{"id":"856","similarity":0.907103825136612,"totOverlap":166,"longestOverlap":73}]],"899":[{"id":"899","fileName":"1575128268.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    private int computeDistance(int index1, int index2, int len) {\n        int diff = Math.abs(index1 - index2);\n        return Math.min(diff, len - diff);\n    }\n    \n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int len = nums.length;\n        Map<Integer, ArrayList<Integer>> positionsMap = new HashMap<>();\n        for (int i = 0; i < len; i++) {\n            positionsMap.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        \n        List<Integer> results = new ArrayList<>();\n        for (int q : queries) {\n            int num = nums[q];\n            ArrayList<Integer> indices = positionsMap.get(num);\n            if (indices.size() <= 1) {\n                results.add(-1);\n            } else {\n                int pos = Collections.binarySearch(indices, q);\n                int size = indices.size();\n                int prevIdx = indices.get((pos - 1 + size) % size);\n                int nextIdx = indices.get((pos + 1) % size);\n                int distance1 = computeDistance(q, prevIdx, len);\n                int distance2 = computeDistance(q, nextIdx, len);\n                results.add(Math.min(distance1, distance2));\n            }\n        }\n        return results;\n    }\n}\n","author":"budidha_2","submissionId":"1575128268"},[{"id":"14","similarity":0.9629629629629629,"totOverlap":182,"longestOverlap":76}]],"912":[{"id":"912","fileName":"1575128489.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        List<Integer> answer = new ArrayList<>();\n\n        for(int i=0;i<nums.length;i++){\n            map.putIfAbsent(nums[i], new ArrayList<>());\n            map.get(nums[i]).add(i);\n        }\n\n        for(int i=0;i<queries.length;i++){\n            List<Integer> list = map.get(nums[queries[i]]);\n             if (list.size() == 1) {\n                answer.add(-1);\n                continue;\n            }\n            int index = queries[i];\n            int pos = Collections.binarySearch(list, index);\n\n            int minDist = Integer.MAX_VALUE;\n            int n = nums.length;\n                \n            int j = list.get(pos==0?list.size()-1:pos - 1);\n            minDist = Math.min(Math.abs(index - j), n - Math.abs(index - j));\n            \n            j = list.get((pos + 1) % list.size());\n            minDist = Math.min(minDist, Math.min(Math.abs(index - j), n - Math.abs(index - j)));\n            \n            answer.add(minDist);\n        }\n\n        return answer;\n    }\n}","author":"Manali","submissionId":"1575128489"},[{"id":"912","similarity":0.746268656716418,"totOverlap":150,"longestOverlap":14}]],"947":[{"id":"947","fileName":"1575129171.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        // values -> positions , binary search or treeset.\n        \n        // [1,3,1,4,1,3,2]\n        //  0 1 2 3 4 5 6  size=7\n        //  0 + 7 - 6 = 1\n        \n        int size = nums.length;\n        \n        Map<Integer, TreeSet<Integer>> valueToIndices = new HashMap<>();\n        for (int idx = 0; idx < nums.length; ++idx) {\n            TreeSet<Integer> indices = valueToIndices.getOrDefault(nums[idx], new TreeSet<>());\n            indices.add(idx);\n            valueToIndices.put(nums[idx], indices);\n        }\n        \n        List<Integer> res = new ArrayList<>();\n        for (int idx : queries) {\n            int num = nums[idx];\n            TreeSet<Integer> indices = valueToIndices.get(num);\n            if (indices.size() == 1) {\n                res.add(-1);\n                continue;\n            }\n            Integer higher = indices.higher(idx);\n            Integer lower = indices.lower(idx);\n            higher = higher != null ? higher : indices.first();\n            lower = lower != null ? lower : indices.last();\n            \n            int distance = Integer.MAX_VALUE;\n            distance = Math.min(distance, Math.abs(higher - idx));\n            distance = Math.min(distance, Math.abs(idx - lower));\n            distance = Math.min(distance, Math.abs(higher + size - idx));\n            distance = Math.min(distance, Math.abs(idx + size - lower));\n            \n            res.add(distance);\n        }\n        \n        return res;\n    }\n}","author":"Minchen Wang","submissionId":"1575129171"},[{"id":"947","similarity":0.7183098591549296,"totOverlap":153,"longestOverlap":25}]],"952":[{"id":"952","fileName":"1575129294.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            map.putIfAbsent(nums[i], new ArrayList<>());\n            map.get(nums[i]).add(i);\n        }\n\n        for (List<Integer> list : map.values()) {\n            Collections.sort(list);\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int q : queries) {\n            int val = nums[q];\n            List<Integer> positions = map.get(val);\n\n            if (positions.size() == 1) {\n                result.add(-1);\n                continue;\n            }\n\n            int size = positions.size();\n            int idx = Collections.binarySearch(positions, q);\n\n            int leftIdx = (idx - 1 + size) % size;\n            int rightIdx = (idx + 1) % size;\n\n            int leftPos = positions.get(leftIdx);\n            int rightPos = positions.get(rightIdx);\n\n            int minLeft = minDistance(q, leftPos, n);\n            int minRight = minDistance(q, rightPos, n);\n            int minDist = Math.min(minLeft, minRight);\n\n            result.add(minDist);\n        }\n\n        return result;\n    }\n\n    private int minDistance(int i, int j, int n) {\n        int distance = Math.abs(j - i);\n        return Math.min(distance, n - distance);\n    }\n}","author":"Yuqi Guo","submissionId":"1575129294"},[{"id":"952","similarity":0.8955223880597015,"totOverlap":180,"longestOverlap":32}]],"984":[{"id":"984","fileName":"1575130067.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer,ArrayList<Integer>> hp = new HashMap<>();\n        int ind = 0;\n        for(int i:nums)\n            {\n                if(!hp.containsKey(i))\n                    hp.put(i,new ArrayList<>());\n\n                hp.get(i).add(ind);\n                ind++;\n            }\nList<Integer> ans= new ArrayList<>();\n        for(int q:queries)\n            {\n                int ele = nums[q];\n                ArrayList<Integer> temp = hp.get(ele);\n                if(temp.size() == 1)\n                    ans.add(-1);\n                else\n                {\n                    // System.out.println(temp);\n                    int ind1 = Collections.binarySearch(temp, q);\n                    // System.out.println(ind1);\n                    int ind2 = temp.get((ind1+1)%temp.size());\n                    int ind3 = temp.get((ind1-1+temp.size())%temp.size());\n                    // System.out.println(ind2+\" \"+ind3);\n                    int ans1 = Math.min(Math.abs(q-ind2), nums.length - Math.abs(q-ind2) );\n                    int ans2 = Math.min(Math.abs(q-ind3), nums.length - Math.abs(q-ind3) );\n                    ans.add(Math.min(ans1,ans2));\n                }\n                    \n            }\n        return ans;\n        \n    }\n}","author":"tushar19280","submissionId":"1575130067"},[{"id":"984","similarity":0.7149321266968326,"totOverlap":158,"longestOverlap":20}]],"986":[{"id":"986","fileName":"1575130033.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n       \n        Map<Integer, List<Integer>> valueToIndices = new HashMap<>();\n        \n        for (int i = 0; i < n; i++) {\n            valueToIndices.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        \n        List<Integer> answer = new ArrayList<>(queries.length);\n        for (int queryIndex : queries) {\n            int queryValue = nums[queryIndex];\n            List<Integer> indices = valueToIndices.get(queryValue);\n            \n           \n            if (indices.size() == 1) {\n                answer.add(-1);\n                continue;\n            }\n            \n            int minDist = n; \n            \n            int pos = Collections.binarySearch(indices, queryIndex);\n            \n            int prevPos = (pos - 1 + indices.size()) % indices.size();\n            int prevIdx = indices.get(prevPos);\n            int distToPrev = (queryIndex >= prevIdx) ? \n                queryIndex - prevIdx : queryIndex + n - prevIdx;\n            \n          \n            int nextPos = (pos + 1) % indices.size();\n            int nextIdx = indices.get(nextPos);\n            int distToNext = (nextIdx >= queryIndex) ? \n                nextIdx - queryIndex : nextIdx + n - queryIndex;\n            \n           \n            minDist = Math.min(distToPrev, distToNext);\n            answer.add(minDist);\n        }\n        \n        return answer;\n    }\n}","author":"Prabhat Mishra","submissionId":"1575130033"},[{"id":"986","similarity":0.8217821782178217,"totOverlap":166,"longestOverlap":23}]],"988":[{"id":"988","fileName":"1575130106.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        /*\n        # Brute Force\n        for each query, do a loop forwards and a loop backwards\n        ## Time\n        O(n^2)\n\n        # Binary Search + Track numsToIndices\n        For eacn num, keep track of its numsToIndices\n        Given a query, the index in question is queries[i], the num in question is nums[queries[i]]\n        Do binary search on the array in the map that corresponds to nums[queries[i]] and find queries[i], find left and right and calc min distnace\n        If last/first element, check first/last.\n        */\n\n        int n = nums.length;\n        Map<Integer, List<Integer>> numsToIndices = new HashMap<>();\n\n        for(int i = 0; i < n; i++) {\n            numsToIndices.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n\n        List<Integer> answer = new ArrayList<>();\n        for(int query : queries) {\n            List<Integer> indices = numsToIndices.get(nums[query]);\n            if(indices.size() == 1) {\n                answer.add(-1);\n                continue;\n            }\n            \n            int relativeIndex = binarySearch(indices, query);\n            int minDistance = Integer.MAX_VALUE;\n            \n            if(relativeIndex == 0) {\n                minDistance = Math.min(\n                    indices.get(relativeIndex+1) - indices.get(relativeIndex),\n                    indices.get(relativeIndex) + nums.length - indices.get(indices.size()-1)\n                );\n            } else if(relativeIndex == indices.size()-1) {\n                minDistance = Math.min(\n                    indices.get(relativeIndex) - indices.get(relativeIndex-1),\n                    indices.get(0) + nums.length - indices.get(relativeIndex)\n                );\n                \n            } else {\n                minDistance = Math.min(\n                    indices.get(relativeIndex) - indices.get(relativeIndex-1),\n                    indices.get(relativeIndex+1) - indices.get(relativeIndex)\n                );\n                \n            }\n            answer.add(minDistance);\n        }\n        \n        return answer;\n    }\n\n    private static int binarySearch(List<Integer> arr, int target) {\n        int left = 0, right = arr.size()-1;\n        while(left < right) {\n            int mid = left + (right - left) / 2;\n\n            if(arr.get(mid)>=target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}","author":"pianomyn","submissionId":"1575130106"},[{"id":"409","similarity":0.7865612648221344,"totOverlap":199,"longestOverlap":21}]],"1004":[{"id":"1004","fileName":"1575130597.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        HashMap<Integer, List<Integer>> m = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            m.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n\n\n        \n        List<Integer> ans = new ArrayList<>();\n        for (int q : queries) {\n            int v = nums[q];\n            List<Integer> l = m.get(v);\n            if (l.size() == 1) {\n                ans.add(-1);\n                continue;\n            }\n\n            \n            int pos = Collections.binarySearch(l, q);\n            int p = l.get((pos - 1 + l.size()) % l.size());\n            int nxt = l.get((pos + 1) % l.size());\n            int d1 = Math.abs(q - p);\n            d1 = Math.min(d1, n - d1);\n            int d2 = Math.abs(q - nxt);\n            d2 = Math.min(d2, n - d2);\n            ans.add(Math.min(d1, d2));\n        }\n        return ans;\n    }\n}","author":"Navneet Shriwastav","submissionId":"1575130597"},[{"id":"607","similarity":0.9259259259259259,"totOverlap":175,"longestOverlap":39}]],"1030":[{"id":"1030","fileName":"1575131274.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> check = new HashMap<>();\n\n        for (int i = 0; i < n; i++) {\n            check.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n\n        List<Integer> res= new ArrayList<>();\n        for (int idx: queries) {\n            int value = nums[idx];\n            List<Integer> cur= check.get(value);\n\n            if (cur.size() == 1) {\n                res.add(-1);\n                continue;\n            }\n\n            int pos = Collections.binarySearch(cur, idx);\n            if (pos < 0) pos = -pos - 1;\n\n            int minDist = Integer.MAX_VALUE;\n\n            if (pos > 0) {\n                int d = Math.abs(idx - cur.get(pos - 1));\n                minDist = Math.min(minDist, Math.min(d, n - d));\n            }\n            if (pos < cur.size() - 1) {\n                int d = Math.abs(cur.get(pos + 1) - idx);\n                minDist = Math.min(minDist, Math.min(d, n - d));\n            }\n            if (pos == 0) {\n                int d = Math.abs(idx - cur.get(cur.size() - 1));\n                minDist = Math.min(minDist, Math.min(d, n - d));\n            }\n            if (pos == cur.size() - 1) {\n                int d = Math.abs(cur.get(0) - idx);\n                minDist = Math.min(minDist, Math.min(d, n - d));\n            }\n\n            res.add(minDist);\n        }\n        return res;\n    }\n}\n","author":"Barathsingh","submissionId":"1575131274"},[{"id":"568","similarity":0.90234375,"totOverlap":231,"longestOverlap":52}]],"1047":[{"id":"1047","fileName":"1575131664.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> ans = new ArrayList<>();\n        HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();\n        \n        for(int i = 0; i < nums.length; i++) {\n            if(!hm.containsKey(nums[i])) {\n                hm.put(nums[i], new ArrayList<Integer>());\n            }\n            hm.get(nums[i]).add(i);\n        }\n\n        for(int query: queries) {\n            ArrayList<Integer> temp = hm.get(nums[query]);\n            int currI = bs(temp, query);\n            int nearest = -1;\n            if(temp.size() == 1) {\n                \n            } else if(currI == temp.size()-1) {\n                nearest = Math.min(nums.length-temp.get(currI)+temp.get(0), temp.get(currI) - temp.get(currI-1));\n            } else if(currI == 0) {\n                nearest = Math.min(temp.get(currI+1)-temp.get(currI), nums.length - temp.get(temp.size()-1) + temp.get(currI));\n            } else {\n                nearest = Math.min(temp.get(currI+1)-temp.get(currI), temp.get(currI) - temp.get(currI-1));\n            }\n            ans.add(nearest);\n\n        }\n        return ans;\n    }\n\n    int bs(ArrayList<Integer> list, int val) {\n        int l = 0, r = list.size()-1;\n        while(l <= r) {\n            int mid = l + (r-l)/2;\n            if(list.get(mid) == val) return mid;\n            else if(list.get(mid) < val) l = mid+1;\n            else r = mid-1;\n        }\n        return l;\n    }\n}","author":"Manikya Sabharwal","submissionId":"1575131664"},[{"id":"409","similarity":0.7108433734939759,"totOverlap":177,"longestOverlap":15}]],"1070":[{"id":"1070","fileName":"1575132214.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        int len = nums.length;\n        for (int i = 0; i < len; i++) {\n            if (!map.containsKey(nums[i])) {\n                map.put(nums[i], new ArrayList<>());\n            }\n            map.get(nums[i]).add(i);\n        }\n        List<Integer> res = new ArrayList<>();\n        for (int q : queries) {\n            List<Integer> cs = map.get(nums[q]);\n            if (cs.size() == 1) {\n                res.add(-1);\n                continue;\n            }\n            int idx = getIdx(cs, q);\n            if (idx == 0) {\n                int tmp = cs.get(idx + 1) - cs.get(idx);\n                tmp = Math.min(tmp, cs.get(0) + len - cs.get(cs.size() - 1));\n                res.add(tmp);\n            } else if (idx == cs.size() - 1) {\n                int tmp = cs.get(idx) - cs.get(idx - 1);\n                tmp = Math.min(tmp, len - cs.get(cs.size() - 1) - 1 + cs.get(0) + 1);\n                res.add(tmp);\n            } else {\n                int tmp = cs.get(idx) - cs.get(idx - 1);\n                tmp = Math.min(tmp,  cs.get(idx + 1) - cs.get(idx));\n                res.add(tmp);\n            }\n        }\n        return res;\n    }\n\n    private int getIdx(List<Integer> l, int idx) {\n        int lo = 0, hi = l.size() - 1;\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (l.get(mid) == idx) {\n                return mid;\n            } else if (l.get(mid) < idx) {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n        return lo;\n    }\n}","author":"jizhengfei","submissionId":"1575132214"},[{"id":"409","similarity":0.7575757575757576,"totOverlap":200,"longestOverlap":32}]],"1072":[{"id":"1072","fileName":"1575132151.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> valueIndicesMap = new HashMap<>();\n        int n = nums.length;\n        \n        // Build the map of value to its indices\n        for (int i = 0; i < n; i++) {\n            int value = nums[i];\n            valueIndicesMap.putIfAbsent(value, new ArrayList<>());\n            valueIndicesMap.get(value).add(i);\n        }\n        \n        // Sort each list of indices for binary search\n        for (List<Integer> indices : valueIndicesMap.values()) {\n            Collections.sort(indices);\n        }\n        \n        List<Integer> results = new ArrayList<>();\n        for (int queryIndex : queries) {\n            int value = nums[queryIndex];\n            List<Integer> indices = valueIndicesMap.get(value);\n            \n            if (indices.size() == 1) {\n                results.add(-1);\n            } else {\n                int pos = Collections.binarySearch(indices, queryIndex);\n                int len = indices.size();\n                int prevPos = (pos - 1 + len) % len;\n                int nextPos = (pos + 1) % len;\n                int prevIndex = indices.get(prevPos);\n                int nextIndex = indices.get(nextPos);\n                \n                int minDistance = Math.min(\n                    computeMinDistance(queryIndex, prevIndex, n),\n                    computeMinDistance(queryIndex, nextIndex, n)\n                );\n                results.add(minDistance);\n            }\n        }\n        \n        return results;\n    }\n    \n    private int computeMinDistance(int i, int j, int n) {\n        int diff = Math.abs(i - j);\n        return Math.min(diff, n - diff);\n    }\n}","author":"Sagar TH","submissionId":"1575132151"},[{"id":"30","similarity":0.8792270531400966,"totOverlap":182,"longestOverlap":21}]],"1075":[{"id":"1075","fileName":"1575132381.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        \n        for (int i = 0; i < n; i++) {\n            int num = nums[i];\n            map.computeIfAbsent(num, k -> new ArrayList<>()).add(i);\n        }\n        \n        for (List<Integer> indices : map.values()) {\n            Collections.sort(indices);\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        \n        for (int queryIndex : queries) {\n            int value = nums[queryIndex];\n            List<Integer> indices = map.get(value);\n            \n            if (indices.size() == 1) {\n                result.add(-1);\n                continue;\n            }\n            \n            int pos = Collections.binarySearch(indices, queryIndex);\n            int size = indices.size();\n            \n            int prevPos = (pos - 1 + size) % size;\n            int nextPos = (pos + 1) % size;\n            \n            int prevIndex = indices.get(prevPos);\n            int nextIndex = indices.get(nextPos);\n            \n            int distPrev = Math.min(Math.abs(queryIndex - prevIndex), n - Math.abs(queryIndex - prevIndex));\n            int distNext = Math.min(Math.abs(queryIndex - nextIndex), n - Math.abs(queryIndex - nextIndex));\n            \n            result.add(Math.min(distPrev, distNext));\n        }\n        \n        return result;\n    }\n}\n","author":"SACHIN GUSAIN","submissionId":"1575132381"},[{"id":"1351","similarity":0.8714285714285714,"totOverlap":183,"longestOverlap":67},{"id":"1244","similarity":0.8872549019607843,"totOverlap":181,"longestOverlap":82},{"id":"1244","similarity":0.8955223880597015,"totOverlap":180,"longestOverlap":32},{"id":"1244","similarity":0.8682926829268293,"totOverlap":178,"longestOverlap":28},{"id":"1075","similarity":0.8177570093457944,"totOverlap":175,"longestOverlap":26},{"id":"1568","similarity":0.8246445497630331,"totOverlap":174,"longestOverlap":24},{"id":"1329","similarity":0.7330508474576272,"totOverlap":173,"longestOverlap":25},{"id":"607","similarity":0.8826530612244898,"totOverlap":173,"longestOverlap":27},{"id":"530","similarity":0.8472906403940886,"totOverlap":172,"longestOverlap":41},{"id":"1568","similarity":0.7196652719665272,"totOverlap":172,"longestOverlap":47},{"id":"298","similarity":0.8465346534653465,"totOverlap":171,"longestOverlap":23},{"id":"1084","similarity":0.7990654205607477,"totOverlap":171,"longestOverlap":21},{"id":"798","similarity":0.8636363636363636,"totOverlap":171,"longestOverlap":47},{"id":"358","similarity":0.8407960199004975,"totOverlap":169,"longestOverlap":34},{"id":"1084","similarity":0.7897196261682243,"totOverlap":169,"longestOverlap":28},{"id":"1858","similarity":0.7601809954751131,"totOverlap":168,"longestOverlap":30},{"id":"1030","similarity":0.7016806722689075,"totOverlap":167,"longestOverlap":48},{"id":"132","similarity":0.7063829787234043,"totOverlap":166,"longestOverlap":28},{"id":"365","similarity":0.7377777777777778,"totOverlap":166,"longestOverlap":19},{"id":"1004","similarity":0.907103825136612,"totOverlap":166,"longestOverlap":73},{"id":"1568","similarity":0.8217821782178217,"totOverlap":166,"longestOverlap":23},{"id":"1937","similarity":0.7377777777777778,"totOverlap":166,"longestOverlap":17},{"id":"1075","similarity":0.8291457286432161,"totOverlap":165,"longestOverlap":26},{"id":"798","similarity":0.8497409326424871,"totOverlap":164,"longestOverlap":52},{"id":"330","similarity":0.7342342342342343,"totOverlap":163,"longestOverlap":18},{"id":"1490","similarity":0.7616822429906542,"totOverlap":163,"longestOverlap":13},{"id":"1215","similarity":0.7836538461538461,"totOverlap":163,"longestOverlap":33},{"id":"1568","similarity":0.7836538461538461,"totOverlap":163,"longestOverlap":47},{"id":"952","similarity":0.7074235807860262,"totOverlap":162,"longestOverlap":21},{"id":"1207","similarity":0.7666666666666667,"totOverlap":161,"longestOverlap":9},{"id":"1897","similarity":0.7219730941704036,"totOverlap":161,"longestOverlap":10},{"id":"817","similarity":0.7441860465116279,"totOverlap":160,"longestOverlap":47},{"id":"1850","similarity":0.8102564102564103,"totOverlap":158,"longestOverlap":28},{"id":"1329","similarity":0.7149321266968326,"totOverlap":158,"longestOverlap":20},{"id":"1281","similarity":0.7336448598130841,"totOverlap":157,"longestOverlap":26},{"id":"783","similarity":0.8478260869565217,"totOverlap":156,"longestOverlap":43},{"id":"1905","similarity":0.850828729281768,"totOverlap":154,"longestOverlap":41},{"id":"952","similarity":0.7018348623853211,"totOverlap":153,"longestOverlap":17},{"id":"984","similarity":0.7731958762886598,"totOverlap":150,"longestOverlap":15},{"id":"1207","similarity":0.746268656716418,"totOverlap":150,"longestOverlap":14},{"id":"1568","similarity":0.7760416666666666,"totOverlap":149,"longestOverlap":22},{"id":"52","similarity":0.7525252525252525,"totOverlap":149,"longestOverlap":23},{"id":"947","similarity":0.7081339712918661,"totOverlap":148,"longestOverlap":28},{"id":"1784","similarity":0.7552083333333334,"totOverlap":145,"longestOverlap":22},{"id":"1676","similarity":0.7035175879396985,"totOverlap":140,"longestOverlap":10},{"id":"912","similarity":0.7142857142857143,"totOverlap":140,"longestOverlap":10},{"id":"1475","similarity":0.7247191011235955,"totOverlap":129,"longestOverlap":17}]],"1084":[{"id":"1084","fileName":"1575132700.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\n        int n = nums.length;\n\n    \n        for (int i = 0; i < n; i++) {\n            map.putIfAbsent(nums[i], new ArrayList<>());\n            map.get(nums[i]).add(i);\n        }\n\n       \n        for (List<Integer> list : map.values()) {\n            Collections.sort(list);\n        }\n\n        List<Integer> ans = new ArrayList<>();\n\n        for (int idx : queries) {\n            int element = nums[idx];\n\n            if (!map.containsKey(element) || map.get(element).size() == 1) {\n                ans.add(-1);\n                continue;\n            }\n\n            List<Integer> list = map.get(element);\n            int pos = Collections.binarySearch(list, idx);\n            if (pos < 0){\n               pos = -pos - 1;     \n            } \n\n            int temp = Integer.MAX_VALUE;\n\n            // Check left neighbor\n            if (pos > 0) {\n                temp = Math.min(temp, idx - list.get(pos - 1));\n            }\n            \n            if (pos < list.size() - 1) {\n                temp = Math.min(temp, list.get(pos + 1) - idx);\n            }\n\n          \n            int first = list.get(0), last = list.get(list.size() - 1);\n            temp = Math.min(temp, n - Math.abs(idx - first));\n            temp = Math.min(temp, n - Math.abs(idx - last));\n\n            ans.add(temp);\n        }\n\n        return ans;\n    }\n}\n","author":"om_contest","submissionId":"1575132700"},[{"id":"21","similarity":0.7990654205607477,"totOverlap":171,"longestOverlap":21}]],"1207":[{"id":"1207","fileName":"1575135796.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n=nums.length;\n        int q=queries.length;\n        HashMap<Integer,ArrayList<Integer>> map=new HashMap<>();\n        for(int i=0;i<n;i++){\n            if(!map.containsKey(nums[i])){\n            map.put(nums[i],new ArrayList<Integer>());\n            }\n            map.get(nums[i]).add(i);\n        }\n\n        List<Integer> res=new ArrayList<>();\n        for(int x=0;x<q;x++){\n            int ind=queries[x];\n            ArrayList<Integer> list=map.get(nums[ind]);\n            //System.out.println(x);\n            //System.out.println(list);\n            if(list.size()==1){\n                res.add(-1);\n                continue;\n            }\n            int sz=list.size();\n            int idx=Collections.binarySearch(list,ind);\n            int upper=list.get((idx+1)%sz);\n            int lower=list.get((idx-1+sz)%sz);\n            \n            int dis=Integer.MAX_VALUE;\n            dis=Math.min(dis,Math.min(Math.abs(upper-ind),n-Math.abs(upper-ind)));\n            dis=Math.min(dis,Math.min(Math.abs(ind-lower),n-Math.abs(ind-lower)));\n            res.add(dis);\n        }\n        return res;\n    }\n}","author":"Aditya Chauhan","submissionId":"1575135796"},[{"id":"330","similarity":0.7666666666666667,"totOverlap":161,"longestOverlap":9}]],"1215":[{"id":"1215","fileName":"1575135869.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        int[] ans = new int[n];\n        Arrays.fill(ans, -1);\n        \n        Map<Integer, List<Integer>> positions = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            positions.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        \n        for (List<Integer> posList : positions.values()) {\n            if (posList.size() < 2) continue;\n            int size = posList.size();\n            for (int i = 0; i < size; i++) {\n                int cur = posList.get(i);\n                int prev = posList.get((i - 1 + size) % size);\n                int next = posList.get((i + 1) % size);\n                int d1 = circularDistance(cur, prev, n);\n                int d2 = circularDistance(cur, next, n);\n                ans[cur] = Math.min(d1, d2);\n            }\n        }\n        \n        List<Integer> res = new ArrayList<>();\n        for (int q : queries) {\n            res.add(ans[q]);\n        }\n        return res;\n    }\n    \n    private int circularDistance(int i, int j, int n) {\n        int diff = Math.abs(i - j);\n        return Math.min(diff, n - diff);\n    }\n}\n","author":"krobzh","submissionId":"1575135869"},[{"id":"276","similarity":0.7509578544061303,"totOverlap":196,"longestOverlap":19}]],"1233":[{"id":"1233","fileName":"1575136518.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for(int i = 0; i < nums.length; i++){\n            List<Integer> list = map.getOrDefault(nums[i], new ArrayList<>());\n            list.add(i);\n            map.put(nums[i], list);\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        for(int i = 0; i < queries.length; i++){\n            int val = nums[queries[i]];\n            List<Integer> list = map.get(val);\n            \n            if(list.size() == 1){\n                    result.add(-1);\n            }\n            else {\n                int index = findIndex(list, queries[i]);\n                if(index == 0){\n                    int min = Math.min((list.get(index) - 0) + (nums.length - list.get(list.size() - 1)), list.get(index + 1) - list.get(index));\n                    result.add(min);\n                }\n\n                else if(index == list.size() - 1){\n                    \n                    int min = Math.min(list.get(index) - list.get(index - 1), (list.get(0) - 0) + (nums.length -list.get(index)));\n                result.add(min);\n                }\n                else {\n                    int min = Math.min(list.get(index) - list.get(index - 1), list.get(index + 1) - list.get(index));\n                    result.add(min);\n                }\n            }\n            \n            \n        }\n        \n        \n        return result;\n        \n    }\n    \n    \n    private int findIndex(List<Integer> list, int num){\n        \n        int low = 0;\n        int high = list.size();\n\n        while(low <= high){\n            int mid = low + (high - low) / 2;\n            if(list.get(mid) == num){\n                return mid;  \n            }\n            \n            if(list.get(mid) > num){\n                high = mid - 1;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        \n        return -1;\n        \n    }\n    \n}","author":"neil_seattle","submissionId":"1575136518"},[{"id":"1678","similarity":0.7559322033898305,"totOverlap":223,"longestOverlap":24},{"id":"1678","similarity":0.797752808988764,"totOverlap":213,"longestOverlap":27},{"id":"1070","similarity":0.7575757575757576,"totOverlap":200,"longestOverlap":32},{"id":"988","similarity":0.7865612648221344,"totOverlap":199,"longestOverlap":21},{"id":"1597","similarity":0.7424242424242424,"totOverlap":196,"longestOverlap":22},{"id":"1778","similarity":0.7222222222222222,"totOverlap":182,"longestOverlap":18},{"id":"1597","similarity":0.7003891050583657,"totOverlap":180,"longestOverlap":44},{"id":"1424","similarity":0.7091633466135459,"totOverlap":178,"longestOverlap":16},{"id":"1047","similarity":0.7108433734939759,"totOverlap":177,"longestOverlap":15},{"id":"1070","similarity":0.7051792828685259,"totOverlap":177,"longestOverlap":9},{"id":"21","similarity":0.7441860465116279,"totOverlap":160,"longestOverlap":47}]],"1244":[{"id":"1244","fileName":"1575136768.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> valueIndicesMap = new HashMap<>();\n        \n        \n        for (int i = 0; i < n; i++) {\n            int num = nums[i];\n            valueIndicesMap.computeIfAbsent(num, k -> new ArrayList<>()).add(i);\n        }\n        \n        \n        for (List<Integer> indices : valueIndicesMap.values()) {\n            Collections.sort(indices);\n        }\n        \n        List<Integer> answer = new ArrayList<>();\n        \n        for (int queryIndex : queries) {\n            int value = nums[queryIndex];\n            List<Integer> indices = valueIndicesMap.get(value);\n            \n            if (indices.size() == 1) {\n                answer.add(-1);\n                continue;\n            }\n            \n            \n            int pos = Collections.binarySearch(indices, queryIndex);\n            int size = indices.size();\n            \n            \n            int leftNeighbor = (pos - 1 + size) % size;\n            int rightNeighbor = (pos + 1) % size;\n            \n            int leftIndex = indices.get(leftNeighbor);\n            int rightIndex = indices.get(rightNeighbor);\n            \n            \n            int minDistance = Math.min(\n                computeDistance(queryIndex, leftIndex, n),\n                computeDistance(queryIndex, rightIndex, n)\n            );\n            answer.add(minDistance);\n        }\n        \n        return answer;\n    }\n    \n    private int computeDistance(int i, int j, int n) {\n        int diff = Math.abs(i - j);\n        return Math.min(diff, n - diff);\n    \n    }\n}","author":"Shweta_199","submissionId":"1575136768"},[{"id":"1075","similarity":0.8872549019607843,"totOverlap":181,"longestOverlap":82}]],"1259":[{"id":"1259","fileName":"1575137314.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        List<Integer> result = new ArrayList<Integer>();\n        if (queries.length == 0) {\n            return result;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (!map.containsKey(nums[i])) {\n                map.put(nums[i], new ArrayList<Integer>());\n            }\n            map.get(nums[i]).add(i);\n        }\n        for (List<Integer> list : map.values()) {\n            Collections.sort(list);\n        }\n        for (int query : queries) {\n            int key = nums[query];\n            int minDistance = Integer.MAX_VALUE;\n            int minIndex = -1;\n            List<Integer> indices = map.get(key);\n            if (indices.size() == 1) {\n                result.add(-1);\n            } else {\n                int queryIndex = binarySearch(indices, query);\n                if (queryIndex == 0) {\n                    minDistance = Math.min(Math.abs(indices.get(1) - query), nums.length - Math.abs(query - indices.get(indices.size() - 1)));\n                } else if (queryIndex == indices.size() - 1) {\n                    minDistance = Math.min(nums.length - Math.abs(indices.get(0) - query), Math.abs(query - indices.get(indices.size() - 2)));\n                } else {\n                    minDistance = Math.min(Math.abs(indices.get(queryIndex + 1) - query), Math.abs(indices.get(queryIndex - 1) - query));\n                }\n                \n                result.add(minDistance);\n            }\n        }\n        return result;\n    }\n\n    private int binarySearch(List<Integer> indices, int query) {\n        int low = 0;\n        int high = indices.size() - 1;\n\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (indices.get(mid) == query) {\n                return mid;\n            } else if (indices.get(mid) < query) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return -1;\n    }\n}","author":"A A","submissionId":"1575137314"},[{"id":"1424","similarity":0.7065637065637066,"totOverlap":183,"longestOverlap":16},{"id":"1424","similarity":0.7003891050583657,"totOverlap":180,"longestOverlap":44}]],"1281":[{"id":"1281","fileName":"1575137959.txt","sourceCode":"class Solution {\n    \n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        \n        Map<Integer, List<Integer>> memo = new HashMap<>();\n\n        for (int i = 0; i < n; i++) {\n            int num = nums[i];\n            List<Integer> indexList = memo.getOrDefault(num, new ArrayList<>());\n            indexList.add(i);\n            memo.put(num, indexList);\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int searchIndex : queries) {\n            int searchValue = nums[searchIndex];\n            List<Integer> indexList = memo.get(searchValue);\n            \n            if (indexList.size() == 1) {\n                result.add(-1);\n                continue;\n            }\n            \n            int pos = Collections.binarySearch(indexList, searchIndex);\n            if (pos < 0) {\n                pos = -pos - 1;\n            }\n            \n            int leftPos = (pos == 0) ? indexList.size() - 1 : pos - 1;\n            int rightPos = (pos == indexList.size() - 1) ? 0 : pos + 1;\n            \n            int leftIndex = indexList.get(leftPos);\n            int rightIndex = indexList.get(rightPos);\n            \n            int distanceLeft = Math.abs(searchIndex - leftIndex);\n            int distanceRight = Math.abs(searchIndex - rightIndex);\n            int circularLeft = n - distanceLeft;\n            int circularRight = n - distanceRight;\n            \n            int candidateLeft = Math.min(distanceLeft, circularLeft);\n            int candidateRight = Math.min(distanceRight, circularRight);\n            \n            result.add(Math.min(candidateLeft, candidateRight));\n        }\n        \n        return result;\n    }\n    \n}","author":"Sorano Lan","submissionId":"1575137959"},[{"id":"768","similarity":0.7867298578199052,"totOverlap":166,"longestOverlap":27}]],"1315":[{"id":"1315","fileName":"1575138754.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        HashMap<Integer, ArrayList<Integer>> map = new HashMap<>();\n        \n        for (int i = 0; i < n; i++) map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        for (ArrayList<Integer> list : map.values()) Collections.sort(list);\n        \n        int[] ans= new int[queries.length];\n        for(int i =0;i <queries.length;i++) {\n            int q = queries[i];\n            int value = nums[q];\n            ArrayList<Integer> pin =map.get(value);\n            if (pin.size() ==1) {\n                ans[i] =-1;\n                continue;\n            }\n            int mid = Collections.binarySearch(pin,q);\n            int s = pin.size();\n            int l = pin.get((mid-1+s) %s);\n            int r = pin.get((mid+1) %s);\n            ans[i] = Math.min(f(q, l, n), f(q, r, n));\n        }\n        return new ArrayList<>(Arrays.asList(Arrays.stream(ans).boxed().toArray(Integer[]::new)));\n    }\n    public int f(int i, int j, int n) {\n        int diff = Math.abs(i - j);\n        return Math.min(diff, n - diff);\n    }\n}","author":"1amSuraj","submissionId":"1575138754"},[{"id":"16","similarity":0.8333333333333334,"totOverlap":175,"longestOverlap":36}]],"1329":[{"id":"1329","fileName":"1575139117.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> result = new ArrayList<>();\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0;i < nums.length; i++) {\n            if (map.containsKey(nums[i])) {\n                List<Integer> list = map.get(nums[i]);\n                list.add(i);\n                map.put(nums[i], list);\n            } else {\n                List<Integer> list = new ArrayList<>();\n                list.add(i);\n                map.put(nums[i], list);\n            }\n        }\n        for (List<Integer> indices : map.values()) {\n            Collections.sort(indices);\n        }\n        \n        for (int query : queries) {\n            int num = nums[query];\n            List<Integer> indices = map.get(num);\n            if (indices.size() == 1) {\n                result.add(-1);\n                continue;\n            } \n            int position = Collections.binarySearch(indices, query);\n            int size = indices.size();\n            int nextIndex = indices.get((position + 1) % size);\n            int prevIndex = indices.get((position - 1 + size) % size);\n            int distNext = Math.min(Math.abs(nextIndex - query), nums.length - Math.abs(nextIndex - query));\n            int distPrev = Math.min(Math.abs(prevIndex - query), nums.length - Math.abs(prevIndex - query));\n            int minDistance = Math.min(distNext, distPrev);\n            result.add(minDistance);\n        }\n        return result;\n    }\n}","author":"solved3","submissionId":"1575139117"},[{"id":"330","similarity":0.7330508474576272,"totOverlap":173,"longestOverlap":25}]],"1351":[{"id":"1351","fileName":"611228897.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> numIndices = new HashMap<>();\n        int n = nums.length;\n        \n        for (int i = 0; i < n; i++) {\n            int num = nums[i];\n            numIndices.computeIfAbsent(num, k -> new ArrayList<>()).add(i);\n        }\n        for (List<Integer> indices : numIndices.values()) {\n            Collections.sort(indices);\n        }\n        \n        List<Integer> answer = new ArrayList<>();\n        for (int query : queries) {\n            int num = nums[query];\n            List<Integer> indices = numIndices.get(num);\n            if (indices.size() == 1) {\n                answer.add(-1);\n                continue;\n            }\n            \n            int pos = Collections.binarySearch(indices, query);\n            int m = indices.size();\n            int prePos = (pos - 1 + m) % m;\n            int nextPos = (pos + 1) % m;\n            \n            int pre = indices.get(prePos);\n            int next = indices.get(nextPos);\n            \n            // 计算两个方向的距离\n            int d1 = Math.abs(pre - query);\n            d1 = Math.min(d1, n - d1);\n            int d2 = Math.abs(next - query);\n            d2 = Math.min(d2, n - d2);\n            \n            answer.add(Math.min(d1, d2));\n        }\n        \n        return answer;\n    }\n}","author":"北海有你","submissionId":"611228897"},[{"id":"1075","similarity":0.8714285714285714,"totOverlap":183,"longestOverlap":67}]],"1385":[{"id":"1385","fileName":"611231099.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, TreeSet<Integer>> map = new HashMap<>();\n        int n = nums.length;\n        List<Integer> res = new ArrayList<>();\n\n        for(int i = 0; i < n; i++){\n            map.computeIfAbsent(nums[i], id -> new TreeSet<>()).add(i);\n        }\n\n        \n        for(int q : queries){\n            int val = nums[q];\n            TreeSet<Integer> set = map.get(val);\n            int cur = n + 1;\n\n            int first = set.first();\n            int last = set.last();\n\n            if(first != q){\n                cur = Math.min(cur, first + n - q);\n            }\n\n            if(last != q){\n                cur = Math.min(cur, q + n - last);\n            }\n\n            Integer before = set.lower(q);\n            Integer after = set.higher(q);\n\n            if(before != null){\n                cur = Math.min(cur, q - before);\n            }\n\n            if(after != null){\n                cur = Math.min(cur, after - q);\n            }\n\n            res.add(cur >= n ? -1 : cur);\n        }\n\n        return res;\n    }\n}","author":"KAI FENG XUE","submissionId":"611231099"},[{"id":"19","similarity":0.8037383177570093,"totOverlap":172,"longestOverlap":12}]],"1424":[{"id":"1424","fileName":"611232799.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> ans = new ArrayList<>();\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (!map.containsKey(nums[i])) {\n                map.put(nums[i], new ArrayList<>());\n            }\n            map.get(nums[i]).add(i);\n        }\n        for (int q : queries) {\n            int x = nums[q];\n            List<Integer> list = map.get(x);\n            if (list.size() == 1) {\n                ans.add(-1);\n            } else {\n                int idx = binarySearch(list, q);\n                if (idx == 0) {\n                    ans.add(Math.min(list.get(1) - q, q + nums.length - list.get(list.size() - 1)));\n                } else if (idx == list.size() - 1) {\n                    ans.add(Math.min(q - list.get(idx - 1), list.get(0) + nums.length - q));\n                } else {\n                    ans.add(Math.min(q - list.get(idx - 1), list.get(idx + 1) - q));\n                }\n            }\n        }\n        return ans;\n    }\n    \n    int binarySearch(List<Integer> list, int target) {\n        int left = 0, right = list.size() - 1;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (list.get(mid) < target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n}","author":"橘右京","submissionId":"611232799"},[{"id":"1259","similarity":0.7065637065637066,"totOverlap":183,"longestOverlap":16}]],"1430":[{"id":"1430","fileName":"611232986.txt","sourceCode":"class Solution {\n        public List<Integer> solveQueries(int[] nums, int[] queries) {\n            List<Integer> ans = new ArrayList<>();\n            int n = nums.length;\n            Map<Integer, TreeSet<Integer>> map = new HashMap<>();\n\n            for (int i = 0; i < n; i++) {\n                map.putIfAbsent(nums[i], new TreeSet<>());\n                map.get(nums[i]).add(i);\n            }\n\n            for (int query : queries) {\n                int num = nums[query];\n                TreeSet<Integer> set = map.get(num);\n                if (set == null || set.size() < 2) {\n                    ans.add(-1);\n                    continue;\n                }\n                int res = n;\n\n                Integer lower = set.lower(query);\n                if (lower != null) {\n                    res = Math.min(res, query - lower);\n                }\n                Integer higher = set.higher(query);\n                if (higher != null) {\n                    res = Math.min(res, higher - query);\n                }\n\n                if (query != set.last()) {\n                    res = Math.min(res, query + n - set.last());\n                }\n                if (query != set.first()) {\n                    res = Math.min(res, set.first() + n - query);\n                }\n                ans.add(res);\n            }\n\n            return ans;\n        }\n    }","author":"啦啦啦","submissionId":"611232986"},[{"id":"1439","similarity":0.7936507936507936,"totOverlap":200,"longestOverlap":18},{"id":"1832","similarity":0.7137254901960784,"totOverlap":182,"longestOverlap":11},{"id":"1937","similarity":0.7990430622009569,"totOverlap":167,"longestOverlap":22},{"id":"1829","similarity":0.7377777777777778,"totOverlap":166,"longestOverlap":17}]],"1439":[{"id":"1439","fileName":"611233146.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] a, int[] queries) {\n        List<Integer> res = new ArrayList<>();\n        int n = a.length;\n        Map<Integer, TreeSet<Integer>> map = new HashMap<>();\n        for(int i=0; i<n; i++) {\n            if(map.get(a[i]) == null) {\n                map.put(a[i], new TreeSet<>());\n            }\n            map.get(a[i]).add(i);\n        } \n\n        for(int idx : queries) {\n            int key = a[idx];\n            TreeSet<Integer> set = map.get(key);\n            if(set.size() == 1) {\n                res.add(-1);\n                continue;\n            }\n            int r = Integer.MAX_VALUE;\n            Integer v1 = set.higher(idx);\n            if(v1 != null) {\n                r = Math.min(r, Math.abs(v1.intValue() - idx));\n                r = Math.min(r, n-v1.intValue()+idx);\n            }\n            Integer v2 = set.lower(idx);\n            if(v2 != null) {\n                r = Math.min(r, Math.abs(v2.intValue() - idx));\n                r = Math.min(r, n-idx+v2.intValue());\n            }\n            Integer f = set.first();\n            if(f.intValue() != idx) {\n                r = Math.min(r, Math.abs(f.intValue() - idx));\n                r = Math.min(r, n-idx+f.intValue());\n            }\n            Integer l = set.last();\n            if(l.intValue() != idx) {\n                r = Math.min(r, Math.abs(l.intValue() - idx));\n                r = Math.min(r, n-l.intValue()+idx);\n            }\n            res.add(r);\n        }\n\n        return res;\n    }\n}","author":"KaiShen","submissionId":"611233146"},[{"id":"1430","similarity":0.7936507936507936,"totOverlap":200,"longestOverlap":18}]],"1475":[{"id":"1475","fileName":"611234310.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int i : queries) {\n            List<Integer> aux = map.get(nums[i]);\n            int m = aux.size();\n            if (m == 1) {\n                ans.add(-1);\n                continue;\n            }\n            int lo = 0, hi = m - 1;\n            while (lo <= hi) {\n                int mid = lo + (hi - lo) / 2;\n                if (aux.get(mid) < i) {\n                    lo = mid + 1;\n                } else {\n                    hi = mid - 1;\n                }\n            }\n            int min = n;\n            int j = Math.abs(i - aux.get((lo - 1 + m) % m));\n            min = Math.min(min, Math.min(j, n - j));\n            j = Math.abs(aux.get((lo + 1) % m) - i);\n            min = Math.min(min, Math.min(j, n - j));\n            ans.add(min);\n        }\n        return ans;\n    }\n}","author":"秋心","submissionId":"611234310"},[{"id":"783","similarity":0.7247191011235955,"totOverlap":129,"longestOverlap":17}]],"1490":[{"id":"1490","fileName":"611234444.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, ArrayList<Integer>> mapCount = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int num = nums[i];\n            mapCount.computeIfAbsent(num, k -> new ArrayList<>()).add(i);\n        }\n        for (List<Integer> list : mapCount.values()) {\n            Collections.sort(list);\n        }\n        List<Integer> ansList = new ArrayList<>();\n        queryAns(nums, queries, mapCount, ansList, nums.length);\n        return ansList;\n    }\n\n    public void queryAns(int[] nums, int[] queries,\n                                 Map<Integer, ArrayList<Integer>> mapCount, List<Integer> answer, int n) {\n        for (int query : queries) {\n            List<Integer> integerList = mapCount.get(nums[query]);\n            if (1 == integerList.size()) {\n                answer.add(-1);\n                continue;\n            }\n            int len = integerList.size();\n            int pos = Collections.binarySearch(integerList, query);\n            int pre = integerList.get((pos - 1 + len) % len);\n            int number = integerList.get((pos + 1) % len);\n            int ans1 = Math.abs(pre - query);\n            ans1 = Math.min(ans1, n - ans1);\n            int ans2 = Math.abs(number - query);\n            ans2 = Math.min(ans2, n - ans2);\n            answer.add(Math.min(ans1, ans2));\n        }\n    }\n}","author":"Java攻城狮","submissionId":"611234444"},[{"id":"95","similarity":0.7616822429906542,"totOverlap":163,"longestOverlap":13}]],"1547":[{"id":"1547","fileName":"611236209.txt","sourceCode":"\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, TreeSet<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            TreeSet<Integer> orDefault = map.getOrDefault(nums[i], new TreeSet<>());\n            orDefault.add(i);\n            map.put(nums[i], orDefault);\n        }\n        int n = nums.length;\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < queries.length; i++) {\n            int index = queries[i];\n            TreeSet<Integer> set = map.get(nums[index]);\n            int a = Integer.MAX_VALUE;\n            Integer ceiling = set.ceiling(index + 1);\n            if (ceiling != null) a = Math.min(a, ceiling - index);\n            Integer floor = set.floor(index - 1);\n            if (floor != null) a = Math.min(a, index - floor);\n            // 两边\n            int first = set.first();\n            if (first != index) a = Math.min(a, n - index + first );\n            int last = set.last();\n            if (last != index) a = Math.min(a, n - last + index);\n            result.add(a == Integer.MAX_VALUE ? -1 : a);\n        }\n        return result;\n    }\n}","author":"一只小蜗牛呀","submissionId":"611236209"},[{"id":"367","similarity":0.8018867924528302,"totOverlap":170,"longestOverlap":16}]],"1568":[{"id":"1568","fileName":"611236852.txt","sourceCode":"class Solution {\n    public static List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        \n        for (int i = 0; i < n; i++) {\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        for (List<Integer> list : map.values()) {\n            Collections.sort(list);\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int query : queries) {\n            int target = nums[query];\n            List<Integer> indices = map.get(target);\n            if (indices == null || indices.size() <= 1) {\n                result.add(-1);\n                continue;\n            }\n\n            int pos = Collections.binarySearch(indices, query);\n            int left = (pos - 1 + indices.size()) % indices.size();\n            int right = (pos + 1) % indices.size();\n\n            int leftIndex = indices.get(left);\n            int rightIndex = indices.get(right);\n\n            int d1 = Math.abs(query - leftIndex);\n            int d2 = Math.abs(rightIndex - query);\n            int dist1 = Math.min(d1, n - d1);\n            int dist2 = Math.min(d2, n - d2);\n            int mindist = Math.min(dist1, dist2);\n\n            result.add(mindist);\n        }\n        \n        return result;\n    }\n}","author":"Eliauk","submissionId":"611236852"},[{"id":"226","similarity":0.8926829268292683,"totOverlap":183,"longestOverlap":47}]],"1597":[{"id":"1597","fileName":"611237445.txt","sourceCode":"class Solution {\npublic List<Integer> solveQueries(int[] nums, int[] queries) {\n        int len = queries.length;\n        List<Integer> resultList = new ArrayList<>();\n        if (len == 0) {\n            return resultList;\n        }\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (!map.containsKey(nums[i])) {\n                map.put(nums[i], new ArrayList<>());\n            }\n            map.get(nums[i]).add(i);\n        }\n        for (int query : queries) {\n            int num = nums[query];\n            List<Integer> indices = map.get(num);\n            if (indices.size() == 1) {\n                resultList.add(-1);\n            } else {\n                // 找索引i（query）在indices中位置。\n                int size = indices.size();\n                int index = -1;\n                int left = 0;\n                int right = size - 1;\n                while (left <= right) {\n                    int mid = (left + right) / 2;\n                    if (indices.get(mid) > query) {\n                        right = mid - 1;\n                    } else if (indices.get(mid) < query) {\n                        left = mid + 1;\n                    } else {\n                        index = mid;\n                        break;\n                    }\n                }\n                int d;\n                if (index == 0) {\n                    d = Math.min(indices.get(0) + nums.length - indices.get(size - 1), indices.get(1) - indices.get(0));\n                } else if (index == size - 1) {\n                    d = Math.min(indices.get(0) + nums.length - indices.get(size - 1), indices.get(size - 1) - indices.get(size - 2));\n                } else {\n                    d = Math.min(indices.get(index) - indices.get(index - 1), indices.get(index + 1) - indices.get(index));\n                }\n                resultList.add(d);\n            }\n        }\n        return resultList;\n    }\n}","author":"crud_boy","submissionId":"611237445"},[{"id":"409","similarity":0.7424242424242424,"totOverlap":196,"longestOverlap":22}]],"1676":[{"id":"1676","fileName":"611239749.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int x = nums[i];\n            map.computeIfAbsent(x, e -> new ArrayList<>()).add(i);\n        }\n        ArrayList<Integer> res = new ArrayList<>();\n        int n = nums.length;\n        for (int query : queries) {\n            List<Integer> list = map.get(nums[query]);\n            if (list.size() == 1) {\n                res.add(-1);\n                continue;\n            }\n            int m = list.size();\n            int j = Collections.binarySearch(list, query);\n            int c = list.get(j);\n            int a = list.get((j - 1 + m) % m);\n            int b = list.get((j + 1) % m);\n            int tmp = Integer.MAX_VALUE;\n            for (int value : new int[]{a, b}) {\n                if (value < c) {\n                    tmp = Math.min(tmp, Math.min(c - value, value + n - c));\n                } else {\n                    tmp = Math.min(tmp, Math.min(value - c, c + n - value));\n                }\n            }\n            res.add(tmp);\n        }\n        return res;\n    }\n}","author":"Funny Ben2Gom","submissionId":"611239749"},[{"id":"95","similarity":0.7035175879396985,"totOverlap":140,"longestOverlap":10}]],"1678":[{"id":"1678","fileName":"611239803.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> map = new HashMap();\n        for (int i = 0; i < nums.length; i++) {\n            List<Integer> idxList = map.getOrDefault(nums[i], new ArrayList<>());\n            idxList.add(i);\n            map.put(nums[i], idxList);\n        }\n        List<Integer> res = new ArrayList<>();\n        for (int query : queries) {\n            List<Integer> idxList = map.get(nums[query]);\n            if (idxList.size() == 1) {\n                res.add(-1);\n            } else {\n                int idx = binarySearch(idxList, query);\n                int curDistance = -1;\n                if (idx == 0) {\n                    curDistance = Math.min(idxList.get(1) - idxList.get(0), idxList.get(0) + nums.length - idxList.get(idxList.size() - 1));\n                    \n                } else if (idx == idxList.size() - 1) {\n                    curDistance = Math.min(idxList.get(idxList.size() - 1) - idxList.get(idxList.size() - 2), idxList.get(0) + nums.length - idxList.get(idxList.size() - 1));\n                } else {\n                    curDistance = Math.min(idxList.get(idx) - idxList.get(idx - 1), idxList.get(idx + 1) - idxList.get(idx));\n                }\n                res.add(curDistance);\n            }\n        }\n        return res;\n    }\n    \n    private int binarySearch(List<Integer> list, int target) {\n        int left = 0;\n        int right = list.size() - 1;\n        while (left < right) {\n            int mid = left + ((right - left) >> 1);\n            if (list.get(mid) == target) {\n                return mid;\n            } else if (list.get(mid) > target) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}","author":"这谁扛得住","submissionId":"611239803"},[{"id":"1233","similarity":0.7559322033898305,"totOverlap":223,"longestOverlap":24}]],"1778":[{"id":"1778","fileName":"611242539.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.computeIfAbsent(nums[i], x -> new ArrayList<>()).add(i);\n        }\n\n        map.forEach((k, v) -> v.sort(Comparator.naturalOrder()));\n\n        List<Integer> res = new LinkedList<>();\n        for (int i : queries) {\n            List<Integer> list = map.get(nums[i]);\n            if (list == null || list.size() == 1) {\n                res.add(-1);\n            } else {\n                int left = 0;\n                int right = list.size() - 1;\n                while (left <= right) {\n                    int mid = left + (right - left) / 2;\n                    if (list.get(mid) > i) {\n                        right = mid - 1;\n                    } else {\n                        left = mid + 1;\n                    }\n                }\n\n                if (right == 0) {\n                    res.add(Math.min(\n                            list.get(right + 1) - list.get(right),\n                            list.get(right) + nums.length - list.get(list.size() - 1)\n                    ));\n                } else if (right == list.size() - 1) {\n                    res.add(Math.min(\n                            list.get(right) - list.get(right - 1),\n                            list.get(0) + nums.length - list.get(right)\n                    ));\n                } else {\n                    res.add(Math.min(list.get(right) - list.get(right - 1), list.get(right + 1) - list.get(right)));\n                }\n            }\n        }\n\n        return res;\n    }\n}","author":"吴所知","submissionId":"611242539"},[{"id":"988","similarity":0.7222222222222222,"totOverlap":182,"longestOverlap":18}]],"1784":[{"id":"1784","fileName":"611242730.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        // 构建元素到下标的映射\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n\n        // 预处理每个位置到最近相同元素的循环距离\n        int[] minDist = new int[n];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        for (List<Integer> indices : map.values()) {\n            int m = indices.size();\n            if (m < 2) continue; // 只有一个元素，无需计算距离\n\n            // 计算相邻元素之间的循环距离\n            for (int i = 0; i < m; i++) {\n                int curr = indices.get(i);\n                int next = indices.get((i + 1) % m); // 下一个元素（循环）\n                int prev = indices.get((i - 1 + m) % m); // 上一个元素（循环）\n\n                // 计算与下一个元素的循环距离\n                int distNext = Math.min((next - curr + n) % n, (curr - next + n) % n);\n                // 计算与上一个元素的循环距离\n                int distPrev = Math.min((prev - curr + n) % n, (curr - prev + n) % n);\n\n                // 取两者中的较小值\n                minDist[curr] = Math.min(distNext, distPrev);\n            }\n        }\n\n        // 处理查询\n        List<Integer> ans = new ArrayList<>();\n        for (int q : queries) {\n            int res = minDist[q];\n            ans.add(res == Integer.MAX_VALUE ? -1 : res);\n        }\n\n        return ans;\n    }\n}","author":"ngi","submissionId":"611242730"},[{"id":"52","similarity":0.7552083333333334,"totOverlap":145,"longestOverlap":22}]],"1829":[{"id":"1829","fileName":"611245181.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, TreeSet<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.computeIfAbsent(nums[i], a -> new TreeSet<>()).add(i);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int query : queries) {\n            int queryNum = nums[query];\n            TreeSet<Integer> indexs = map.get(queryNum);\n            if (indexs == null || indexs.isEmpty() || indexs.size() == 1) {\n                ans.add(-1);\n                continue;\n            }\n            //从indexs找到最近的\n            int v = Integer.MAX_VALUE;\n            //左边跟右边\n            Integer higher = indexs.higher(query);\n            if (higher != null) {\n                v = Math.min(v, higher - query);\n            } else {\n                //右边没有即为最左边\n                Integer first = indexs.first();\n                v = Math.min(v, nums.length - query + first);\n                v = Math.min(v, query - first);\n            }\n            Integer lower = indexs.lower(query);\n            //左边没有即为最右边\n            if (lower != null) {\n                v = Math.min(v, query - lower);\n            } else {\n                Integer last = indexs.last();\n                v = Math.min(v, last - query);\n                v = Math.min(v, nums.length - last + query);\n            }\n            ans.add(v);\n        }\n        return ans;\n    }\n}","author":"Yaron-Xiong","submissionId":"611245181"},[{"id":"19","similarity":0.7564102564102564,"totOverlap":177,"longestOverlap":26}]],"1832":[{"id":"1832","fileName":"611245092.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> ans = new ArrayList<>();\n        Map<Integer, TreeSet<Integer>> map  =new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (!map.containsKey(nums[i])) {\n                map.put(nums[i], new TreeSet<>());\n            }\n            map.get(nums[i]).add(i);\n        }\n        for (int query : queries) {\n            TreeSet<Integer> set = map.get(nums[query]);\n            if (set.size() == 1) {\n                ans.add(-1);\n            } else {\n                int dis = Integer.MAX_VALUE;\n                Integer low = set.lower(query);\n                if (low == null) {\n                    low = set.last();\n                    dis = Math.min(low - query, query + nums.length - low);\n                } else {\n                    dis = Math.min(dis, query - low);\n                }\n                Integer high = set.higher(query);\n                if (high == null) {\n                    high = set.first();\n                    dis = Math.min(dis, Math.min(query - high, high + nums.length - query));\n                } else {\n                    dis = Math.min(dis, high - query);\n                }\n                ans.add(dis);\n            }\n        }\n        return ans;\n    }\n}","author":"幸福啦啦啦","submissionId":"611245092"},[{"id":"1439","similarity":0.7137254901960784,"totOverlap":182,"longestOverlap":11}]],"1850":[{"id":"1850","fileName":"611246227.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for(int i = 0; i < n; i++){\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n\n        List<Integer> res = new ArrayList<>();\n        for(int x : queries){\n            int val = nums[x];\n            List<Integer> positions = map.get(val);\n            if(positions.size() == 1){\n                res.add(-1);\n                continue;\n            }\n\n            int pos = Collections.binarySearch(positions, x);\n            // 左侧候选和右侧候选\n            int left = (pos == 0) ? positions.get(positions.size() - 1) : positions.get(pos - 1);\n            int right = (pos == positions.size() - 1) ? positions.get(0) : positions.get(pos + 1);\n\n            int d1 = circularDistance(x, left, n);\n            int d2 = circularDistance(x, right, n);\n            res.add(Math.min(d1, d2));\n        }\n        return res;\n    }\n\n    // 循环数组下标差\n    private int circularDistance(int i, int j, int n) {\n        int diff = Math.abs(i - j);\n        return Math.min(diff, n - diff);\n    }\n}","author":"Richer","submissionId":"611246227"},[{"id":"768","similarity":0.8102564102564103,"totOverlap":158,"longestOverlap":28}]],"1858":[{"id":"1858","fileName":"611246585.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> posDict = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            posDict.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        for (List<Integer> list : posDict.values()) {\n            Collections.sort(list);\n        }\n        \n        int[] answer = new int[queries.length];\n        for (int i = 0; i < queries.length; i++) {\n            int q = queries[i];\n            int x = nums[q];\n            List<Integer> posList = posDict.getOrDefault(x, new ArrayList<>());\n            if (posList.size() <= 1) {\n                answer[i] = -1;\n                continue;\n            }\n            int idx = Collections.binarySearch(posList, q);\n            \n            int left = (idx - 1 + posList.size()) % posList.size(); \n            int dLeft = Math.abs(posList.get(left) - posList.get(idx));\n            dLeft = Math.min(dLeft, n - dLeft);\n            int right = (idx + 1) % posList.size();\n            int dRight = Math.abs(posList.get(right) - posList.get(idx));\n            \n            dRight = Math.min(dRight, n - dRight);\n            answer[i] = Math.min(dLeft, dRight);\n        }\n        List<Integer> ans = new ArrayList();\n        for(int i : answer)\n            ans.add(i);\n        \n        return ans;\n    }\n\n}","author":"嘉然今天刷力扣","submissionId":"611246585"},[{"id":"16","similarity":0.7962962962962963,"totOverlap":172,"longestOverlap":25}]],"1890":[{"id":"1890","fileName":"611248411.txt","sourceCode":"class Solution {\n   public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, TreeSet<Integer>> mts = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            mts.computeIfAbsent(nums[i], ignore -> new TreeSet<>()).add(i);\n        }\n\n        List<Integer> ans = new ArrayList<>();\n        for (int i : queries) {\n            int num = nums[i];\n            TreeSet<Integer> ts = mts.get(num);\n            if (ts.size() == 1) {\n                ans.add(-1);\n            } else {\n                Integer higher = ts.higher(i);\n                Integer lower = ts.lower(i);\n                int l = Integer.MAX_VALUE;\n                int r = Integer.MAX_VALUE;\n                if (higher != null) {\n                    r = Math.min(r, higher - i);\n                } else {\n                    r = Math.min(r, ts.first() + nums.length - i);\n                }\n                if (lower != null) {\n                    l = Math.min(l, i - lower);\n                } else {\n                    l = Math.min(l, i + nums.length - ts.last());\n                }\n                ans.add(Math.min(l, r));\n            }\n        }\n        return ans;\n    }\n}","author":"peterqiu-007","submissionId":"611248411"},[{"id":"1829","similarity":0.7633928571428571,"totOverlap":171,"longestOverlap":44}]],"1897":[{"id":"1897","fileName":"611249103.txt","sourceCode":"class Solution {\npublic List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, TreeSet<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.computeIfAbsent(nums[i], v -> new TreeSet<>()).add(i);\n        }\n        int n = nums.length;\n        List<Integer> ans = new ArrayList<>();\n        for (int query : queries) {\n            TreeSet<Integer> set = map.get(nums[query]);\n            set.remove(query);\n            Integer ceiling = set.ceiling(query);\n            int min = Integer.MAX_VALUE;\n            if (ceiling != null) {\n                min = Math.min(min, Math.abs(query - ceiling));\n            }\n            Integer floor = set.floor(query);\n            if (floor != null) {\n                min = Math.min(min, Math.abs(query - floor));\n            }\n            if (!set.isEmpty()) {\n                Integer first = set.first();\n                \n                    min = Math.min(min, Math.min(Math.abs(query - first), n-Math.abs(first - query)));\n                \n                Integer last = set.last();\n                \n                    min = Math.min(min, Math.min(Math.abs(query - last), n-Math.abs( query - last)));\n                \n            }\n            ans.add(min == Integer.MAX_VALUE ? -1 : min);\n            set.add(query);\n        }\n        return ans;\n    }\n}","author":"风铃","submissionId":"611249103"},[{"id":"465","similarity":0.7219730941704036,"totOverlap":161,"longestOverlap":10}]],"1905":[{"id":"1905","fileName":"611249342.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n         int n = nums.length;\n        int[] dist = new int[n];\n        Arrays.fill(dist, -1);\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        for (List<Integer> m : map.values()) {\n            if (m.size() <= 1) continue;\n            Collections.sort(m);\n            int size = m.size();\n            for (int i = 0; i < size; i++) {\n                int cur = m.get(i);\n                int prev = m.get((i - 1 + size) % size);\n                int next = m.get((i + 1) % size);\n                int d1 = (cur - prev + n) % n;\n                int d2 = (next - cur + n) % n;\n                dist[cur] = Math.min(d1, d2);\n            }\n        }\n        List<Integer> res = new ArrayList<>();\n        for (int query : queries) {\n            res.add(dist[query]);\n        }\n        return res;\n    }\n}","author":"不懂语言的崽子","submissionId":"611249342"},[{"id":"1215","similarity":0.850828729281768,"totOverlap":154,"longestOverlap":41}]],"1937":[{"id":"1937","fileName":"611254822.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, TreeSet<Integer>> posMem = new HashMap<>();\n        for (int i = 0; i < nums.length; ++i) {\n            if (!posMem.containsKey(nums[i])) {\n                posMem.put(nums[i], new TreeSet<>());\n            }\n            posMem.get(nums[i]).add(i);\n        }\n        List<Integer> res = new ArrayList<>();\n        for (int p : queries) {\n            int n = nums[p];\n            if (posMem.get(n).size() == 1) {\n                res.add(-1);\n            } else {\n                TreeSet<Integer> set = posMem.get(n);\n                Integer higher = set.higher(p);\n                int cur = Integer.MAX_VALUE;\n                if (higher == null) {\n                    cur = Math.min(cur, nums.length - p + set.first());\n                } else {\n                    cur = Math.min(cur, higher - p);\n                }\n                Integer lower = set.lower(p);\n                if (lower == null) {\n                    cur = Math.min(cur, p + nums.length - set.last());\n                } else {\n                    cur = Math.min(cur, p - lower);\n                }\n                res.add(cur);\n            }\n        }\n        return res;\n    }\n}","author":"NeoStart","submissionId":"611254822"},[{"id":"1832","similarity":0.7990430622009569,"totOverlap":167,"longestOverlap":22}]]},{"1076":[{"id":"1076","fileName":"1575132460.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> valind;\n        for (int i = 0; i < n; i++) valind[nums[i]].push_back(i);\n\n        vector<int> ans (queries.size(),-1);\n        for (int i = 0; i < queries.size(); i++) {\n            int val = nums[queries[i]];\n            if (valind[val].size() == 1) continue; \n            \n            vector<int>& ind = valind[val];\n            auto it = lower_bound(ind.begin(), ind.end(), queries[i]);\n            int index = it-ind.begin();\n            // cout<<val<<\" \"<<index<<\" \";\n            if(index>0 && index<ind.size()-1)\n                ans[i]=min(ind[index]-ind[index-1],ind[index+1]-ind[index]);\n            else if(index==0)\n                ans[i]=min(ind[index+1]-ind[index],n-ind[ind.size()-1]+ind[index]);\n            else \n                ans[i]=min(ind[index]-ind[index-1],n-ind[index]+ind[0]);\n            // cout<<ans[i]<<\" \";\n        }\n        return ans;\n    }\n};","author":"Vidit Agrawal","submissionId":"1575132460"},[]]},{"1077":[{"id":"1077","fileName":"1575132634.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        mx = max(nums)\n        pos = [[] for _ in range(mx+1)]\n        p = [0] * n\n        for i, x in enumerate(nums):\n            p[i] = len(pos[x])\n            pos[x].append(i)\n\n        def get(p: int, q: int) -> int:\n            d = abs(p - q)\n            return min(d, n - d)\n\n        ans = []\n        for q in queries:\n            x = nums[q]\n            if len(pos[x]) == 1:\n                ans.append(-1)\n            else:\n                p_idx = p[q]\n                l = len(pos[x])\n                pre_idx = pos[x][(p_idx - 1 + l) % l]\n                suf_idx = pos[x][(p_idx + 1) % l]\n                ans.append(min(get(q, pre_idx), get(q, suf_idx)))\n        return ans","author":"fovait","submissionId":"1575132634"},[]]},{"1079":[{"id":"1079","fileName":"1575132653.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        int[] doori = new int[n];\n        for (int i = 0; i < n; i++) {\n            doori[i] = -1;\n        }\n        int[] nums1 = new int[n * 2];\n        for (int i = 0; i < n; i++) {\n            nums1[i] = nums[i];\n        }\n        for (int i = 0; i < n; i++) {\n            nums1[i + n] = nums[i];\n        }\n        for (int i = 0; i < n * 2; i++) {\n            int cur = nums1[i];\n            List<Integer> list;\n            // System.out.println(\"checking for ind \" + i + \" val \" + cur);\n            if (map.containsKey(nums1[i])) {\n                list = map.get(nums1[i]);\n            } else {\n                list = new ArrayList<>();\n            }\n            list.add(i);\n            // System.out.println(\" list is. \" + list);\n            if (list.size() > 1) {\n                int val = list.get(list.size() - 1) - list.get(list.size() - 2);\n                // System.out.println(\"val is \" + val);\n                if (val >= n)\n                    continue;\n                if (doori[i % n] != -1) {\n                    doori[i % n] = Math.min(doori[i % n], val);\n                    int j = list.get(list.size() - 2);\n                    doori[j % n] = Math.min(doori[j % n], val);\n                } else {\n                    int j = list.get(list.size() - 2);\n\n                    doori[i % n] = val;\n                    doori[j % n] = Math.min(doori[j % n], val);\n\n                }\n                // System.out.println(\"doori \" + Arrays.toString(doori));\n            }\n\n            map.put(cur, list);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int q : queries) {\n            ans.add(doori[q]);\n        }\n        return ans;\n    }\n}","author":"Sandeep Bhaisora","submissionId":"1575132653"},[]]},{"1080":[{"id":"1080","fileName":"1575132652.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> mp;\n        int n = nums.size();\n        for (int i = 0; i < nums.size(); i++) {\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for (int i : queries) {\n            if (mp[nums[i]].size() == 1) ans.push_back(-1);\n            else {\n                int tt = mp[nums[i]].size();\n                auto t = lower_bound(mp[nums[i]].begin(), mp[nums[i]].end(), i) - mp[nums[i]].begin();\n                \n                auto it2 = mp[nums[i]][((t - 1) + tt) % tt];\n                auto it3 = mp[nums[i]][(t + 1) % tt];\n                int prev, nxt;\n                if (it2 < i) {\n                    prev = i - it2;\n                } else {\n                    prev = n - it2 + i;\n                } \n                if (it3 > i) {\n                    nxt = it3 - i;\n                } else {\n                    nxt = n - i + it3;\n                }\n                ans.push_back(min(nxt, prev));\n                \n                \n            }\n        }\n    return ans;\n    }\n};","author":"math84081155","submissionId":"1575132652"},[]]},{"1082":[{"id":"1082","fileName":"1575132712.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d={}\n        s=set()\n        a=[]\n        for i in range(len(nums)):\n            if(nums[i] not in s):\n                s.add(nums[i])\n                d[nums[i]]=[i]\n            else:\n                d[nums[i]].append(i)         \n        for i in queries:\n            l=0\n            r=len(d[nums[i]])-1\n            ans=-1\n            if(l==r):\n                ans=-1\n                a.append(ans)\n                continue  \n            while(l<=r):\n                mid=(l+r)//2\n                if(d[nums[i]][mid]<i):\n                    l=mid+1\n                elif(d[nums[i]][mid]==i):\n                    ans=mid\n                    break\n                else:\n                    r=mid-1\n            if(ans==0):\n                p=min(abs(d[nums[i]][ans]+len(nums)-d[nums[i]][-1]),abs(d[nums[i]][ans]-d[nums[i]][ans+1]))\n                a.append(p)\n            elif(ans==len(d[nums[i]])-1):\n                p=min(abs(d[nums[i]][ans]-d[nums[i]][ans-1]),(d[nums[i]][0]+len(nums)-d[nums[i]][-1]))\n                a.append(p)\n            else:\n                p=min(abs(d[nums[i]][ans]-d[nums[i]][ans+1]),abs(d[nums[i]][ans]-d[nums[i]][ans-1]))\n                a.append(p)\n        return a        ","author":"KartikeyThakur","submissionId":"1575132712"},[]]},{"1083":[{"id":"1083","fileName":"1575132691.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, set<int>> table;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) table[nums[i]].insert(i);\n\n        vector<int> ans;\n        for (auto i: queries){\n            int x = nums[i];\n            if (table[x].size() == 1) ans.push_back(-1);\n            else{\n                auto it = table[x].find(i), it2 = it;\n                int temp;\n                if (it == table[x].begin()){\n                    temp = i + 1 + n - 1 - *(table[x].rbegin());\n                }\n                else temp = i - *(--it2);\n\n                if (i == *(table[x].rbegin())){\n                    temp = min(temp, n - 1 - i + *(table[x].begin()) + 1);\n                }\n                else temp = min(temp, *(++it) - i);\n\n                ans.push_back(temp);\n            }\n        }\n\n        return ans;\n    }\n};","author":"syampawan","submissionId":"1575132691"},[]]},{"1085":[{"id":"1085","fileName":"1575132666.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[]} queries\n * @return {number[]}\n */\nvar solveQueries = function(nums, queries) {\n    const N = nums.length\n    const ans = Array(queries.length)\n    // queries = queries.map((q, i) => [q, i]).sort((l, r) => r[0] - l[0])\n    const next = Array(N), prev = Array(N)\n    const last = new Map(), first = new Map()\n    for (let i = 0; i < N; i++) {\n        const num = nums[i]\n\n        if (last.has(num)) {\n            next[last.get(num)] = i\n            prev[i] = last.get(num)\n        }\n        // if (first.has(num)) {\n        //     next[i] = first.get(num)\n        //     prev[first.get(num)] = i\n        // }\n        \n        if (!first.has(num)) first.set(num, i)\n        last.set(num, i)\n    }\n    console.log(first, next)\n    return queries.map(q => {\n        let dist = Infinity\n        if (prev[q] !== undefined) dist = Math.min(dist, q - prev[q])\n        if (next[q] !== undefined) dist = Math.min(dist, next[q] - q)\n        if (first.has(nums[q]) && q !== first.get(nums[q])) dist = Math.min(dist, first.get(nums[q]) + N - q)\n        if (last.has(nums[q]) && q !== last.get(nums[q])) dist = Math.min(dist, q + N - last.get(nums[q]))\n        return dist === Infinity ? -1 : dist\n    })\n};","author":"Harttle","submissionId":"1575132666"},[]]},{"1086":[{"id":"1086","fileName":"1575132766.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n#define siddhantnema ios_base::sync_with_stdio(0); cin.tie(0);\n#define ll long long\n#define forn(_i, N) for (ll _i = 0; _i < N; _i++)\n#define trc(x) cout << #x << \" -> \" << x << 'n';\n#define len(x) (ll)x.size()\n\nclass Solution\n{\npublic:\n    vector<int> solveQueries(vector<int> &nums, vector<int> &queries)\n    {\n        siddhantnema;\n\n        int N = len(nums);\n\n        map<int, vector<int>> ok;\n        forn(i, N)\n        {\n            ok[nums[i]].push_back(i);\n        }\n        vector<int> res;\n\n        \n        for(int &qry: queries)\n        {\n            int ele = nums[qry];\n            if(ok.contains(ele) and ok[ele].size() > 1)\n            {\n                int idx = lower_bound(ok[ele].begin(), ok[ele].end(), qry) - ok[ele].begin();\n\n                int n = len(ok[ele]);\n                int v1 = idx + 1;\n                if(v1 == n) v1 = 0;\n                int v2 = idx - 1;\n                if(v2  < 0) v2 = n -1;\n                // trc(idx);\n                // trc(ele);\n                // trc(v1);\n                // trc(v2);\n                int d1 = abs(ok[ele][idx] - ok[ele][v1]), d2 = abs(ok[ele][idx] - ok[ele][v2]);\n                \n                int tmp = min({d1, N - d1, d2, N - d2});\n    \n                res.push_back(tmp);\n\n            }\n            else\n                res.push_back(-1);\n\n        }\n        return res;\n    }\n};\n","author":"Siddhant Nema","submissionId":"1575132766"},[]]},{"1090":[{"id":"1090","fileName":"1575132734.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dic = {}\n        indices = [10 ** 5] * len(nums)\n        for i, n in enumerate(nums):\n            if n not in dic:\n                dic[n] = []\n            dic[n].append(i)\n            if len(dic[n]) > 1:\n                prev = dic[n][-2]\n                indices[prev] = min(indices[prev], i - prev)\n                indices[dic[n][0]] = min(indices[dic[n][0]], dic[n][0] + len(nums) - i)\n                indices[i] = min(i - dic[n][-2], dic[n][0] + len(nums) - i)\n        for i, n in enumerate(nums):\n            if len(dic[n]) == 1:\n                indices[i] = -1\n        answer = []\n        for q in queries:\n            answer.append(indices[q])\n        return answer\n            ","author":"charlieterle","submissionId":"1575132734"},[]]},{"1091":[{"id":"1091","fileName":"1575132876.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        '''n = len(nums)\n        hm = defaultdict(list)\n        for i,j in enumerate(nums):\n            hm[j].append(i)\n        res = []\n        for q in queries:\n            target = nums[q]\n            if len(hm[target]) == 1:\n                res.append(-1)\n            else:\n                mini = float('inf')\n                for idx in hm[target]:\n                    if idx != q:\n                        dist = min(abs(idx-q),n-abs(idx-q))\n                        mini = min(mini,dist)\n                res.append(mini)\n        return res'''\n        n = len(nums)\n        hm = defaultdict(list)\n        for i,j in enumerate(nums):\n            hm[j].append(i)\n        def bs(arr, target):\n            left, right = 0, len(arr) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if arr[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return left\n        res = []\n        for q in queries:\n            target = nums[q]\n            if len(hm[target]) == 1:\n                res.append(-1)\n            else:\n                arr = hm[target]\n                idx = bs(arr,q)\n                prev = arr[idx-1] if idx > 0 else arr[-1]\n                next = arr[idx] if idx < len(arr) and arr[idx] != q else arr[(idx + 1) % len(arr)]\n                dist = min(abs(prev-q),n-abs(prev-q))\n                dist2 = min(abs(next-q),n-abs(next-q))\n                res.append(min(dist,dist2))\n        return res\n\n\n","author":"Niharika","submissionId":"1575132876"},[]]},{"1094":[{"id":"1094","fileName":"1575132987.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), q = queries.size();\n        map<int, vector<int>> mpp;\n        for (int i = 0; i < n; i++) {\n            mpp[nums[i]].push_back(i);\n        }\n        vector<int> ans(q);\n        for (int i = 0; i < q; i++) {\n            int x = nums[queries[i]];\n            int low = 0, high = mpp[x].size() - 1, lB = -1, uB = -1;\n            while (low <= high) {\n                int mid = low + (high - low) / 2;\n                if (mpp[x][mid] > queries[i]) {\n                    uB = mpp[x][mid];\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n            low = 0;\n            high = mpp[x].size() - 1;\n            while (low <= high) {\n                int mid = low + (high - low) / 2;\n                if (mpp[x][mid] < queries[i]) {\n                    lB = mpp[x][mid];\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            }\n            int minDist = INT_MAX;\n            if (uB != -1) {\n                if (abs(uB - queries[i]) < minDist) {\n                    minDist = abs(uB - queries[i]);\n                }\n            }\n            if (lB != -1) {\n                if (abs(lB - queries[i]) < minDist) {\n                    minDist = abs(lB - queries[i]);\n                }\n            }\n            // circular check\n            if (mpp[x].size() > 0 && mpp[x][0] < queries[i] &&\n                abs(n + mpp[x][0] - queries[i]) < minDist) {\n                minDist = abs(n + mpp[x][0] - queries[i]);\n            }\n            if (mpp[x].size() > 0 && mpp[x].back() > queries[i] &&\n                abs((n+queries[i])-mpp[x].back()) < minDist) {\n                minDist = abs((n+queries[i])-mpp[x].back());\n            }\n            if (minDist == INT_MAX) {\n                ans[i] = -1;\n            } else {\n                ans[i] = minDist;\n            }\n        }\n        return ans;\n    }\n};","author":"Divye Maloo","submissionId":"1575132987"},[]]},{"1095":[{"id":"1095","fileName":"1575133019.txt","sourceCode":"pub trait BinarySearch<T> {\n    fn lower_bound(&self, x: &T) -> usize;\n    fn upper_bound(&self, x: &T) -> usize;\n}\n\nimpl<T: Ord> BinarySearch<T> for [T] {\n    fn lower_bound(&self, x: &T) -> usize {\n        let mut low = 0;\n        let mut high = self.len();\n\n        while low != high {\n            let mid = (low + high) / 2;\n            match self[mid].cmp(x) {\n                std::cmp::Ordering::Less => {\n                    low = mid + 1;\n                }\n                std::cmp::Ordering::Equal | std::cmp::Ordering::Greater => {\n                    high = mid;\n                }\n            }\n        }\n        low\n    }\n\n    fn upper_bound(&self, x: &T) -> usize {\n        let mut low = 0;\n        let mut high = self.len();\n\n        while low != high {\n            let mid = (low + high) / 2;\n            match self[mid].cmp(x) {\n                std::cmp::Ordering::Less | std::cmp::Ordering::Equal => {\n                    low = mid + 1;\n                }\n                std::cmp::Ordering::Greater => {\n                    high = mid;\n                }\n            }\n        }\n        low\n    }\n}\nimpl Solution {\n    pub fn solve_queries(nums: Vec<i32>, queries: Vec<i32>) -> Vec<i32> {\n        use std::collections::HashMap;\n        let mut loc = HashMap::new();\n        let n = nums.len();\n        for i in 0..3 {\n            for j in 0..nums.len() {\n                let val = nums[j];\n                loc.entry(val).or_insert(vec![]).push(j + n * i);\n            }\n        }\n        let mut ans = vec![0; queries.len()];\n        for i in 0..queries.len() {\n            let e = queries[i] as usize;\n            let val = nums[e];\n            let cv = n + e;\n            let li = loc[&val].upper_bound(&(cv - 1)) - 1;\n            let ri = loc[&val].lower_bound(&(cv + 1));\n            let lv = loc[&val][li];\n            let rv = loc[&val][ri];\n            if rv - cv == n {\n                ans[i] = -1;\n            } else {\n                ans[i] = (rv - cv).min(cv - lv) as i32;\n            }\n        }\n        ans\n    }\n}","author":"tomarin","submissionId":"1575133019"},[]]},{"1097":[{"id":"1097","fileName":"1575132812.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> index_map;\n        for (int i = 0; i < n; i++) index_map[nums[i]].push_back(i);\n\n        vector<int> answer;\n        for (int q : queries) {\n            int v = nums[q];\n            const auto& L = index_map[v];\n            if (L.size() == 1) {\n                answer.push_back(-1);\n                continue;\n            }\n\n            vector<int> candidates;\n            auto it = lower_bound(L.begin(), L.end(), q);\n            if (it != L.begin()) candidates.push_back(min(abs(q - *(it - 1)), n - abs(q - *(it - 1))));\n            it = upper_bound(L.begin(), L.end(), q);\n            if (it != L.end()) candidates.push_back(min(abs(q - *it), n - abs(q - *it)));\n            if (L[0] != q) candidates.push_back(min(abs(q - L[0]), n - abs(q - L[0])));\n            if (L.back() != q) candidates.push_back(min(abs(q - L.back()), n - abs(q - L.back())));\n            \n            answer.push_back(*min_element(candidates.begin(), candidates.end()));\n        }\n        return answer;\n    }\n};\n","author":"Sarban Sah","submissionId":"1575132812"},[]]},{"1098":[{"id":"1098","fileName":"1575133061.txt","sourceCode":"class Solution {\npublic:\n\n    int findDist(int x, int y, int n){\n        if(x<=y) return y-x;\n        return n-x+y;\n    }\n\n\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<vector<int>> arr(n,vector<int>(2,-1));\n        unordered_map<int,int> umap;\n        for(int i=0;i<n;i++){\n            if(umap.find(nums[i])==umap.end()){\n                umap[nums[i]]=i;\n            } else {\n                int preIndex = umap[nums[i]];\n                arr[preIndex][1] = i;\n                arr[i][0] = preIndex;\n                umap[nums[i]]=i;\n            }\n        }\n        for(int i=0;i<n;i++){\n            if(umap.find(nums[i])==umap.end()){\n                umap[nums[i]]=i;\n            } else {\n                int preIndex = umap[nums[i]];\n                arr[preIndex][1] = i;\n                arr[i][0] = preIndex;\n                umap[nums[i]]=i;\n            }\n        }\n\n        int q = queries.size();\n        vector<int> ans(q);\n        for(int i=0;i<q;i++){\n            int index = queries[i];\n            //cout<<arr[index][0]<<\" \"<<index<<\" \"<<arr[index][1]<<\"n\";\n            if(arr[index][0]==index && arr[index][1]==index){\n                ans[i]=-1;\n            } else {\n                ans[i] = min(findDist(arr[index][0],index,n), findDist(index,arr[index][1],n));\n            }\n        }\n        return ans;\n    }\n};","author":"Abhinesh","submissionId":"1575133061"},[]]},{"1100":[{"id":"1100","fileName":"1575133141.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, TreeSet<Integer>> numIndices = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            numIndices.computeIfAbsent(nums[i], k -> new TreeSet<>());\n            numIndices.get(nums[i]).add(i - nums.length);\n            numIndices.get(nums[i]).add(i);\n            numIndices.get(nums[i]).add(i + nums.length);         \n        }\n\n        List<Integer> ans = new ArrayList<>();\n        for (int i = 0; i < queries.length; i++) {\n            int idx = queries[i];\n            int num = nums[idx];\n\n            if (numIndices.get(num).size() == 3) {\n                ans.add(-1);\n            } else {\n                int minDist = Integer.MAX_VALUE;\n                Integer higher = numIndices.get(num).higher(idx);\n                if (higher != null) {\n                    minDist = Math.min(minDist, higher.intValue() - idx);\n                }\n                Integer lower = numIndices.get(num).lower(idx);\n                if (lower != null) {\n                    minDist = Math.min(minDist, idx - lower.intValue());\n                }\n                ans.add(minDist == Integer.MAX_VALUE ? -1 : minDist);\n            }\n        }\n        return ans;\n    }\n}","author":"ddd","submissionId":"1575133141"},[]]},{"1101":[{"id":"1101","fileName":"1575133248.txt","sourceCode":"class Solution(object):\n    def solveQueries(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        idx = defaultdict(list)\n        for i,e in enumerate(nums):\n            idx[e].append(i)\n\n\n        res = [0]*len(queries)\n        for e,q in enumerate(queries):\n            indexes = idx[nums[q]]\n            i = bisect.bisect_left(indexes,q)\n            if len(indexes) == 1:\n                res[e]=-1\n                continue\n            # print(indexes,nums[q],i)\n            if i == len(indexes)-1:\n               \n                d = min(indexes[i]-indexes[i-1],len(nums)-indexes[i]+indexes[0])\n            elif i == 0:\n                d = min(indexes[i+1]-indexes[i],len(nums) - indexes[-1] +indexes[i])\n            else:\n                d = min(indexes[i]-indexes[i-1],indexes[i+1]-indexes[i])    \n        \n            res[e]=d\n        return res","author":"Vibranium","submissionId":"1575133248"},[]]},{"1102":[{"id":"1102","fileName":"1575133069.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int[] minDis=new int[nums.length];\n        List<Integer> ans=new ArrayList<>();\n        for(int i=0;i<minDis.length;i++){\n            minDis[i]=Integer.MAX_VALUE;\n        } \n        Map<Integer,Integer> firstOccur=new HashMap<>();\n        Map<Integer,Integer> lastOccur=new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            if(!firstOccur.containsKey(nums[i])){\n                firstOccur.put(nums[i],i);\n                lastOccur.put(nums[i],i);\n            }else{\n                minDis[i]=Math.min(i-lastOccur.get(nums[i]),nums.length-i+firstOccur.get(nums[i]));\n                minDis[lastOccur.get(nums[i])]=Math.min(minDis[lastOccur.get(nums[i])],i-lastOccur.get(nums[i]));\n                minDis[firstOccur.get(nums[i])]=Math.min(minDis[firstOccur.get(nums[i])],nums.length-i+firstOccur.get(nums[i]));\n                lastOccur.put(nums[i],i);\n            }\n        }\n        for(int i=0;i<nums.length;i++){\n            if(minDis[i]==Integer.MAX_VALUE)minDis[i]=-1;\n        }\n        for(int i=0;i<queries.length;i++){\n            ans.add(minDis[queries[i]]);\n        }\n        return ans;\n    }\n}","author":"OAACKY","submissionId":"1575133069"},[]]},{"1103":[{"id":"1103","fileName":"1575133182.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, int> lastOccur;\n        unordered_map<int, int> firstOccur;\n        int n = nums.size();\n        vector<int> minDis(n, -1);\n        for (int i = 0; i < n; i++) {\n            if (firstOccur.count(nums[i])) {\n                minDis[i] = min({i - lastOccur[nums[i]], firstOccur[nums[i]] + n - i});\n                if (minDis[lastOccur[nums[i]]] == -1) {\n                    minDis[lastOccur[nums[i]]] = firstOccur[nums[i]] + n - i;\n                }\n                minDis[lastOccur[nums[i]]] = min({minDis[lastOccur[nums[i]]], i - lastOccur[nums[i]]});\n            }\n            else {\n                firstOccur[nums[i]] = i;\n            }\n            lastOccur[nums[i]] = i;\n        }\n        for (const auto& search : firstOccur) {\n            minDis[search.second] = min(minDis[search.second], search.second + n - lastOccur[search.first]);\n        }\n        vector<int> ans;\n        for (int i = 0; i < queries.size(); i++) {\n            ans.push_back(minDis[queries[i]]);\n        }\n        return ans;\n    }\n};","author":"flametonat","submissionId":"1575133182"},[]]},{"1104":[{"id":"1104","fileName":"1575133151.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, n) for (lli i = (a); i < (n); ++i)\n#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define sz(a) ((int)a.size())\n#define YES cout << \"YES\" << endl;\n#define NO cout << \"NO\" << endl;\n#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);\n#define pb push_back\n#define pp pop_back()\n#define fi first\n#define si second\n#define v(a) vector<int>(a)\n#define vv(a) vector<vector<int>>(a)\n#define present(c, x) ((c).find(x) != (c).end())\n#define set_bits __builtin_popcountll\n#define MOD 1000000007\n\ntypedef long long lli;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<lli, lli> pll;\ntypedef pair<int, int> pii;\ntypedef unordered_map<int, int> umpi;\ntypedef map<int, int> mpi;\ntypedef vector<pii> vp;\ntypedef vector<lli> vll;\ntypedef vector<vll> vvll;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = sz(nums);\n        unordered_map<int, vi> pos;\n        loop(i, 0, n)\n            pos[nums[i]].pb(i);\n        for (auto &p : pos)\n            sort(all(p.si));\n        \n        auto diff = [&](int a, int b) {\n            int d = abs(a - b);\n            return min(d, n - d);\n        };\n        \n        int m = sz(queries);\n        vector<int> ans(m, -1);\n        loop(k, 0, m) {\n            int idxQuery = queries[k];\n            int val = nums[idxQuery];\n            const auto &v = pos[val];\n            if (sz(v) >= 2) {\n                int i = int(lower_bound(all(v), idxQuery) - v.begin());\n                int d1 = diff(idxQuery, v[(i - 1 + sz(v)) % sz(v)]);\n                int d2 = diff(idxQuery, v[(i + 1) % sz(v)]);\n                ans[k] = min(d1, d2);\n            }\n        }\n        return ans;\n    }\n};\n","author":"Aaryan Saraswat","submissionId":"1575133151"},[]]},{"1105":[{"id":"1105","fileName":"1575133183.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map < int , vector < int > > mp;\n        int n = nums.size();\n        \n        for (int i = 0 ;i < nums.size(); i++){\n            mp[nums[i]].push_back(i);\n        }\n        \n        vector < int > res;\n        for (int i = 0 ; i < queries.size() ; i++){\n            int idx = queries[i];\n            int t = nums[idx];\n            if (mp[t].size()==1)\n                res.push_back(-1);\n            else{\n                auto uit = upper_bound(mp[t].begin() ,  mp[t].end() , idx);\n                auto lit = lower_bound(mp[t].begin() ,  mp[t].end() , idx);\n                int ans = n;\n                if (lit!=mp[t].begin()){\n                    lit--;\n                    ans = min(ans , idx - *lit);\n                    ans = min(ans , *lit - idx + n);\n                }\n                else{\n                    auto lst = mp[t].end();\n                    lst--;\n                    ans = min(ans , idx-*lst + n);\n                }\n                if (uit!=mp[t].end()){\n                    ans = min(ans , *uit - idx);\n                    ans = min(ans , idx - *uit  + n);\n                }\n                else{\n                    ans = min(ans , *mp[t].begin() - idx + n);\n                }\n                res.push_back(ans);\n            }\n        }\n        return res;\n        \n        \n    }\n};","author":"SATYAJEET","submissionId":"1575133183"},[]]},{"1106":[{"id":"1106","fileName":"1575133194.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        nums += nums\n        n = len(nums)\n        dt = dict()\n        INF = 10**10\n        lr = [INF]*n\n        rl = [INF]*n\n        \n        for i in range(n):\n            \n            if nums[i] not in dt:\n                dt[nums[i]] = i\n                continue\n            \n            lr[i] = i - dt[nums[i]]\n            dt[nums[i]] = i\n        \n        dtt = dict()\n        for i in range(n-1, -1, -1):\n            if nums[i] not in dtt:\n                dtt[nums[i]] = i\n                continue\n            rl[i] = dtt[nums[i]] - i\n            dtt[nums[i]] = i\n        \n        \n        \n        print(lr)\n        print(rl)\n            \n        lr = lr[-n//2:]\n        rl = rl[:n//2]\n        ans = []\n        for q in queries:\n            mn = min(lr[q], rl[q])\n            if mn == INF or mn >= n//2:\n                ans.append(-1)\n            else:\n                ans.append(mn)\n        \n        return ans","author":"Vivek Kumar","submissionId":"1575133194"},[]]},{"1107":[{"id":"1107","fileName":"1575133249.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int>v = nums;\n        for(auto e:nums) v.push_back(e);\n        for(auto e:nums) v.push_back(e);\n        map<int,int> mn;\n        int n = nums.size();\n        vector<int> ans(n);\n        \n        map<int,int> left,right;\n        for(int i=0;i<2*n;i++){\n            if(i>=n){\n                \n                ans[i-n] = i-left[v[i]];\n                mn[v[i]] = i-left[v[i]];\n                \n            }\n            left[v[i]] = i;\n            \n        }\n        for(int i=3*n-1;i>=n;i--){\n            if(i<2*n){\n                ans[i-n] = min(ans[i-n],right[v[i]]-i);\n                mn[v[i]] = min(mn[v[i]],right[v[i]]-i);\n            }\n            right[v[i]] = i;\n        }\n        vector<int> fans;\n        for(auto el:queries){\n            fans.push_back(ans[el] == n ? -1 : ans[el]);\n        }\n        return fans;\n    }\n};","author":"user1067tL","submissionId":"1575133249"},[]]},{"1108":[{"id":"1108","fileName":"1575133362.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,set<int>>mp;\n        int m = nums.size();\n        vector<int>res;\n        for(int i = 0; i < nums.size(); i++) {\n            mp[nums[i]].insert(i);\n        }\n        int n;\n        int mx;\n        for(int q:queries) {\n            n = mp[nums[q]].size();\n            if(n == 1){\n                res.push_back(-1);\n                continue;\n            }\n            auto it = mp[nums[q]].find(q);\n            mx = INT_MAX;\n            if(it != mp[nums[q]].begin()) {\n                mx = min(mx, q-(*prev(it)));\n            }else{\n                mx = min(mx, q-(*prev(mp[nums[q]].end()) )+m);\n            }\n            if(it != prev(mp[nums[q]].end())) {\n                mx = min(mx, (*next(it))-q);\n            }else{\n                mx = min(mx, (*mp[nums[q]].begin()-q+m));\n            }\n            res.push_back(mx);\n        }\n        return res;\n    }\n};","author":"Udit Dwivedi","submissionId":"1575133362"},[]]},{"1109":[{"id":"1109","fileName":"1575133308.txt","sourceCode":"class Solution {\npublic:\n    int myfunc(vector<int> &posvec,int idx,int N){\n        int l=0,r=posvec.size()-1,n=posvec.size();\n        int mid;\n        \n        while(l<=r){\n            mid=(l+r)/2;\n            if(posvec[mid]==idx)\n                break;\n            else if(posvec[mid]>idx)\n                r=mid-1;\n            else \n                l=mid+1;\n        }\n\n        //finding left\n        if(mid>=1){\n            l=idx-posvec[mid-1];\n        }\n        else{\n            l=idx+N-posvec[n-1];\n        }\n\n        //finding right\n        if(mid<n-1){\n            r=posvec[mid+1]-idx;\n        }\n        else{\n            r=N-idx+posvec[0];\n        }\n\n        return min(l,r);\n    }\n\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int i,idx,num,ans,n=nums.size(),m=queries.size();\n        vector<int> ansvec;\n        //vector<vector<int>> posvec(1e6 + 1);\n        unordered_map<int,vector<int>> posvec;\n\n        //storing idx\n        for(i=0;i<n;i++)\n            posvec[nums[i]].push_back(i);\n\n        //forming ansvec\n        for(i=0;i<m;i++){\n            idx=queries[i];\n            num=nums[idx];\n\n            if(posvec[num].size()==1)\n                ans=-1;\n            else{\n                ans=myfunc(posvec[num],idx,n);\n            }\n\n            ansvec.push_back(ans);\n        }\n\n        return ansvec;\n    }\n};","author":"devpatel123","submissionId":"1575133308"},[]]},{"1110":[{"id":"1110","fileName":"1575133373.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> adj;\n        for (int i = 0; i < nums.size(); i++) {\n            adj[nums[i]].push_back(i);\n        }\n        // 1 3 1 4 1 3 2\n        // 0 1 2 3 4 5 6\n        // \n        vector<int> ans;\n        for (auto idx : queries) {\n            int val = nums[idx];\n            auto& v = adj[val];\n            // for (auto t : v) {\n            //     cout << t << \" \";\n            // }\n            // cout << endl;\n            int index = lower_bound(begin(v), end(v), idx) - begin(v);\n            cout<<index<<endl;\n            if (v.size() <= 1) {\n                ans.push_back(-1);\n            } else {\n                int left = (index - 1 + v.size()) % v.size(),\n                    right = (index + 1 + v.size()) % v.size();\n                // cout<<left<<\" \"<<right<<endl;\n                // cout<<abs(v[left] - idx)<<\" \"<<abs(v[right] - idx)<<endl;\n                // cout<<abs(v[left] - idx)<<\" \"<<(nums.size()-1-abs(v[left] - idx))<<endl;\n                int ldist = min(abs(v[left] - idx),int(1+(nums.size()-1-abs(v[left] - idx))));\n                int rdist = min(abs(v[right] - idx),int(1+(nums.size()-1-abs(v[right] - idx))));\n                // cout<<ldist<<\" \"<<rdist<<endl;\n                ans.push_back(min(ldist,rdist));\n            }\n        }\n        return ans;\n    }\n};","author":"Prateek8696","submissionId":"1575133373"},[]]},{"1111":[{"id":"1111","fileName":"1575133388.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> ans;\n        \n        int n = queries.size();\n        int m = nums.size();\n        \n        unordered_map<int, vector<int>> pos;\n        \n        for(int i = 0; i < nums.size(); i++) {\n            pos[nums[i]].push_back(i);\n        }\n        \n        for(int i = 0; i < n; i++) {\n            int num = nums[queries[i]];\n            auto& idxs = pos[num];\n            \n            // cout << num << \": \";\n            // for(int x : idxs) {\n            //     cout << x << \" \";\n            // }\n            // cout << endl;\n            if(idxs.size() == 1) {\n                ans.push_back(-1);\n            } else {\n                int cur_i = lower_bound(idxs.begin(), idxs.end(), queries[i]) - idxs.begin();\n                // cout << num << \" cur_i: \" << cur_i << endl;\n                if(cur_i == 0) {\n                    int left_dist = (m - idxs.back()) + idxs[cur_i];\n                    int right_dist = idxs[cur_i+1] - idxs[cur_i];\n                    \n                    // cout << left_dist << \"!!\" << right_dist << endl;\n                    ans.push_back(min(left_dist, right_dist));\n                    \n                } else if(cur_i == idxs.size() - 1) {\n                    int left_dist = idxs[cur_i] - idxs[cur_i-1];\n                    int right_dist = (m - idxs[cur_i]) + idxs[0];\n                    \n                    // cout << left_dist << \"!!\" << right_dist << endl;\n                    ans.push_back(min(left_dist, right_dist));\n                    \n                } else {\n                    int left_dist = idxs[cur_i] - idxs[cur_i-1];\n                    int right_dist = idxs[cur_i+1] - idxs[cur_i];\n                    ans.push_back(min(left_dist, right_dist));\n                }\n                \n            }\n            \n        }\n        \n        return ans;\n        \n        \n    }\n};\n\n/*\n\n    [12,19,12,8,12,10]\n    [0,5,3,1]\n\n*/","author":"midnight_simon","submissionId":"1575133388"},[]]},{"1112":[{"id":"1112","fileName":"1575133439.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int>answer;\n        unordered_map<int,vector<int>>mp;\n        int n=nums.size(),m=queries.size(),k,t;\n\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        for(int i=0;i<m;i++){\n            vector<int> &tmp=mp[nums[queries[i]]];\n            k=INT_MAX;\n            t=tmp.size();\n            if(t==1){\n                answer.push_back(-1);\n            }\n            else{\n                auto it=lower_bound(tmp.begin(),tmp.end(),queries[i]);\n\n                if(it!=tmp.begin()){\n                    k=min(k,queries[i]-*prev(it));\n                }\n                if(next(it)!=tmp.end()){\n                    k=min(k,*next(it)-queries[i]);\n                }\n                k=min(k,min(n-abs(queries[i]-tmp[0]),n-abs(queries[i]-tmp[t-1])));\n                answer.push_back(k);\n            }\n        }\n        return answer;\n    }\n};","author":"Franky_Hsiao","submissionId":"1575133439"},[]]},{"1113":[{"id":"1113","fileName":"1575133428.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n\n        List<Integer> list = new ArrayList<>();\n\n        int n = queries.length;\n        int m = nums.length;\n\n        Map<Integer, TreeSet<Integer>> map = new HashMap<>();\n\n        for(int i=0;i<m*3;i++){\n\n            int z = nums[i%m];\n\n            if(!map.containsKey(z)){\n                map.put(z, new TreeSet<>());\n            }\n            map.get(z).add(i);\n        }\n\n        for(int i=0;i<n;i++){\n\n            int q = queries[i];\n            int x = nums[q];\n\n            TreeSet<Integer> temp = map.get(x);\n            if(temp.size()<4){\n                list.add(-1);\n            }\n            else{\n\n                int s= q+m;\n\n                //System.out.println(s);\n\n                int low = temp.floor(s-1);\n                int high = temp.ceiling(s+1);\n\n                //System.out.println(low+\" \"+high+\" \"+temp.size());\n\n                int d = Math.min( s-low, high-s  );\n                list.add(d);\n            }\n        }\n\n        return list;\n    }\n}","author":"perfection98","submissionId":"1575133428"},[]]},{"1114":[{"id":"1114","fileName":"1575133423.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> umap;\n        int n = nums.size();\n        \n        for (int i = 0; i < n; i++) {\n            umap[nums[i]].push_back(i);\n        }\n\n        vector<int> result;\n        int m = queries.size();\n        for (int i = 0; i < m; i++) {\n            int target_idx = queries[i], target = nums[target_idx];\n            int l = 0, r = umap[target].size()-1;\n            if (l == r) {\n                result.push_back(-1);\n                continue;\n            }\n\n            auto& cur_vec = umap[target];\n            // cout << target << endl;\n            // for (int tmp : cur_vec) {\n            //     cout << tmp << \" \";\n            // }\n            // cout << endl;\n            \n            int target_idx_in_umap = 0;\n            while (l <= r) {\n                int mid = l + (r-l)/2;\n                if (cur_vec[mid] == target_idx) {\n                    target_idx_in_umap = mid;\n                    break;\n                } else if (cur_vec[mid] > target_idx) {\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            }\n\n            // cout << target_idx_in_umap << endl;\n\n            int cur_size = cur_vec.size();\n            int cur_result = INT_MAX;\n            \n            int x = abs(cur_vec[(target_idx_in_umap+1) % cur_size] - cur_vec[target_idx_in_umap]);\n            // cout << x << endl;\n            cur_result = min(cur_result, x);\n            cur_result = min(cur_result, n-x);\n            x = abs(cur_vec[(target_idx_in_umap+cur_size-1) % cur_size] - cur_vec[target_idx_in_umap]);\n            // cout << x << endl;\n            cur_result = min(cur_result, x);\n            cur_result = min(cur_result, n-x);\n\n            result.push_back(cur_result);\n            // cout << endl;\n        }\n\n        return result;\n    }\n};","author":"Chi-Shen Chan","submissionId":"1575133423"},[]]},{"1117":[{"id":"1117","fileName":"1575133450.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        unordered_map<int,vector<int>>freq;\n        for (int i = 0; i <n ; ++i) {\n            freq[nums[i]].push_back(i);\n        }\n        vector<int>ans(n,-1);\n        for(auto it:freq){\n            if(it.second.size()==1)\n                continue;\n            for (int i = 0; i <it.second.size() ; ++i) {\n                ans[it.second[i]]=min((it.second[i]-it.second[(i-1+it.second.size())%it.second.size()]+n)%n\n                        ,(it.second[(i+1)%it.second.size()]-it.second[i]+n)%n);\n            }\n        }\n        for (int i = 0; i <queries.size() ; ++i) {\n            queries[i]=ans[queries[i]];\n        }\n        return queries;\n    }\n};","author":"AbdalrhmanEssam","submissionId":"1575133450"},[]]},{"1118":[{"id":"1118","fileName":"1575133479.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        first = {}\n        last = {}\n        pt, nt = {}, {}\n        prev = [0 for _ in range(n)]\n        next = [0 for _ in range(n)]\n        \n        for i in range(n):\n            first[nums[i]] = min(first.get(nums[i], inf), i)\n            last[nums[i]] = max(last.get(nums[i], -inf), i)\n\n        #print(first, last)\n\n        for i in range(n):\n            if nums[i] not in pt:\n                pt[nums[i]] = i\n                prev[i] = last[nums[i]]\n            else:\n                prev[i] = pt[nums[i]]\n                pt[nums[i]] = i\n\n        for i in range(n - 1, -1, -1):\n            if nums[i] not in nt:\n                nt[nums[i]] = i\n                next[i] = first[nums[i]]\n            else:\n                next[i] = nt[nums[i]]\n                nt[nums[i]] = i\n            \n        prev[0] = last[nums[0]]\n        next[-1] = first[nums[-1]]\n        ans = []\n\n        # print(prev)\n        # print(next)\n        for q in queries:\n            p, ne = prev[q], next[q]\n            # same index\n            if ne == q and p == q:\n                ans.append(-1)\n                continue\n            d1, d2 = min(abs(q - p), abs(n - abs((q - p)))), min(abs(q - ne), abs(n - abs((q - ne))))\n            #print(d1, d2)\n            \n            \n            ans.append(min(d1, d2))\n\n        return ans\n                \n                \n            ","author":"monkeylogic","submissionId":"1575133479"},[]]},{"1119":[{"id":"1119","fileName":"1575133747.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> ans = new ArrayList<>();\n        int n = nums.length;\n        Map<Integer, int[]> map = new HashMap();\n        int[] dist = new int[n];\n        Arrays.fill(dist,-1);\n        for(int i =0 ; i < n ;i++){\n            if(!map.containsKey(nums[i])){\n                map.put(nums[i],new int[2]);\n                map.get(nums[i])[0] =i;\n                map.get(nums[i])[1] =-1;\n            }else{\n                int[] j = map.get(nums[i]);\n                if(j[1]==-1){\n                    j[1]=i;\n                    dist[i] = Math.min(i - j[0], n+j[0]-i);\n                    dist[j[0]]=dist[i];\n                }\n                else{\n                    dist[i] = Math.min(i-j[1], n+j[0] - i);\n                    dist[j[0]]  = Math.min(n+j[0] - i, dist[j[0]]);\n                    dist[j[1]] = Math.min(i-j[1],dist[j[1]]);\n                    //System.out.println(i +\": \" +dist[i]+\"  \" + j[1]+\": \"+ dist[j[1]]) ;\n                }\n                j[1] = i;\n            }   \n        }\n        //System.out.println(Arrays.toString(dist));\n        for(int query:queries){\n            ans.add(dist[query]);\n        }\n        return ans;\n    }\n}","author":"lmaosuvuong","submissionId":"1575133747"},[]]},{"1120":[{"id":"1120","fileName":"1575133636.txt","sourceCode":"class Solution {\npublic:\nvector<int> minCircularDistances(vector<int>& nums, vector<int>& queries) {\n    int n = nums.size();\n    unordered_map<int, vector<int>> indices;\n    for (int i = 0; i < n; i++) {\n        indices[nums[i]].push_back(i);\n    }\n    \n    vector<int> result;\n    for (int q : queries) {\n        int target = nums[q];\n        if (indices[target].size() == 1) {\n            result.push_back(-1);\n            continue;\n        }\n       vector<int>& pos = indices[target];\n        auto it = lower_bound(pos.begin(), pos.end(), q)-pos.begin();\n        auto idx=it;\n        int minDist = n;\n        if(idx+1<pos.size())\n          minDist=min(minDist,pos[idx+1]-pos[idx]);\n        else \n           minDist=min(minDist,n-pos[idx]+pos[0]);\n       if(idx-1>=0)\n          minDist=min(minDist,pos[idx]-pos[idx-1]);\n      else\n          minDist=min(minDist,n-pos[pos.size()-1]+pos[idx]);\n        result.push_back(minDist);\n    }\n    return result;\n}\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n\n      return minCircularDistances(nums,queries);\n    }\n};","author":"Bhawnachauhan","submissionId":"1575133636"},[]]},{"1121":[{"id":"1121","fileName":"1575133733.txt","sourceCode":"import java.util.*;\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> hm = new HashMap<>();\n\n        for (int i = 0; i < n; i++) {\n            if (!hm.containsKey(nums[i])) {\n                hm.put(nums[i], new ArrayList<>());\n            }\n            hm.get(nums[i]).add(i);\n        }\n        int q = queries.length;\n\n        int answer[] = new int[q];\n\n        for (int i = 0; i < q; i++) {\n            answer[i] = Integer.MAX_VALUE;\n            int index = queries[i];\n            List<Integer> indices = hm.get(nums[index]);\n\n            if (indices.size() == 1) {\n                answer[i] = -1;\n                continue;\n            }\n\n            int lowerIndex = findLower(indices,index);\n            int higherIndex = findHigher(indices, index);\n\n            if (lowerIndex != -1) {\n                answer[i] = Math.min(answer[i], index - lowerIndex);\n            }\n\n            if (higherIndex != -1) {\n                answer[i] = Math.min(answer[i], higherIndex - index);\n            }\n\n            if (index != indices.get(0)) {\n                answer[i] = Math.min(answer[i], n - index + indices.get(0));\n            }\n\n            if (index != indices.get(indices.size() - 1)) {\n                answer[i] = Math.min(answer[i], index + n -  indices.get(indices.size() - 1));\n            }\n\n            if (answer[i] == Integer.MAX_VALUE) {\n                answer[i] = -1;\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n\n        for (int i = 0; i < answer.length; i++) {\n            result.add(answer[i]);\n        }\n\n        return result;\n        \n    }\n\n    public int findLower(List<Integer> indices, int val) {\n        int low = 0, high = indices.size() - 1, result = -1;\n\n        while (low <= high) {\n            int mid = low + ((high - low)/2);\n\n            if (indices.get(mid) < val) {\n                result = indices.get(mid);\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n\n        return result;\n    }\n\n\n     public int findHigher(List<Integer> indices, int val) {\n        int low = 0, high = indices.size() - 1, result = -1;\n\n        while (low <= high) {\n            int mid = low + ((high - low)/2);\n\n            if (indices.get(mid) > val) {\n                result = indices.get(mid);\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return result;\n    }\n}","author":"Macharla Venkata Ravi Teja","submissionId":"1575133733"},[]]},{"1122":[{"id":"1122","fileName":"1575133645.txt","sourceCode":"from bisect import bisect_left\nfrom collections import defaultdict\nfrom typing import List, Optional\n\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        num_and_positions = defaultdict(list)\n        for i, num in enumerate(nums):\n            num_and_positions[num].append(i)\n\n        n = len(nums)\n        result = []\n        INF = 10**20\n        for query in queries:\n            num = nums[query]\n            num_pos_list = num_and_positions[num]\n            curr_pos = bisect_left(num_pos_list, query)\n            prev: Optional[int] = num_pos_list[curr_pos - 1] if curr_pos > 0 else None\n            forward_loop: Optional[int] = num_pos_list[0] if curr_pos > 0 else None\n            nxt: Optional[int] = (\n                num_pos_list[curr_pos + 1] if curr_pos < len(num_pos_list) - 1 else None\n            )\n            reverse_loop: Optional[int] = num_pos_list[-1] if curr_pos < len(num_pos_list) - 1 else None\n            distance = INF\n            if prev is not None:\n                distance = min(distance, query - prev)\n            if nxt is not None:\n                distance = min(distance, nxt - query)\n            if forward_loop is not None:\n                distance = min(distance, n - query + forward_loop)\n            if reverse_loop is not None:\n                distance = min(distance, query + n - reverse_loop)\n            result.append(distance if distance != INF else -1)\n        return result","author":"AlTalib","submissionId":"1575133645"},[]]},{"1123":[{"id":"1123","fileName":"1575133799.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,int> first,last;\n        int n = nums.size();\n\n        vector<int> nearest(n,INT_MAX);\n        first[nums[0]] = 0;\n        last[nums[0]] = 0;\n        for(int i=1;i<n;i++){\n            if(first.find(nums[i])==first.end()){\n                first[nums[i]] = i;\n                last[nums[i]] = i;\n            }else{\n                nearest[i] = min(i-last[nums[i]],n-i-1+(first[nums[i]]+1));\n                last[nums[i]] = i;\n            }\n        }\n\n        first.clear();\n        last.clear();\n        first[nums[n-1]] = n-1;\n        last[nums[n-1]] = n-1;\n        for(int i=n-2;i>=0;i--){\n            if(first.find(nums[i])==first.end()){\n                first[nums[i]] = i;\n                last[nums[i]] = i;\n            }else{\n                nearest[i] = min(nearest[i],min(last[nums[i]]-i,i+(n-first[nums[i]])));\n                last[nums[i]] = i;\n            }\n        }\n\n        vector<int> ans;\n        for(auto it:queries){\n            if(nearest[it]==INT_MAX){\n                ans.push_back(-1);\n            }else{\n                ans.push_back(nearest[it]);\n            }\n        }\n        return ans;\n    }\n};","author":"tanmayshingde8","submissionId":"1575133799"},[]]},{"1125":[{"id":"1125","fileName":"1575133808.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        map<int, vector<int>> mp1;\n        map<int, int> mp2, mp3;\n        for(int i=0; i<n; i++){\n            mp1[nums[i]].push_back(i);\n        }\n        vector<int> getCnt(n, 0);\n        for(int i=0; i<n; i++){\n            int cnt = mp3[nums[i]];\n            getCnt[i] = cnt;\n            mp3[nums[i]]++;\n        }\n        vector<int> ans;\n\n        for(int i=0; i<m; i++){\n            int cur = nums[queries[i]];\n            int cn = mp1[cur].size();\n            if(cn == 1) ans.push_back(-1);\n            else{\n                int p = getCnt[queries[i]];\n                int d1 = 1e7, d2 = 1e7;\n                if(p == 0){\n                    d1 = mp1[cur][p] + (n - mp1[cur][cn-1]);\n                }\n                else{\n                    d1 = mp1[cur][p] - mp1[cur][p-1];\n                }\n\n                if(p == cn-1){\n                    d2 = (n - mp1[cur][p]) + (mp1[cur][0]);\n                }\n                else{\n                    d2 = mp1[cur][p+1] - mp1[cur][p];\n                }\n        \n                ans.push_back(min(d1, d2));\n                p++;\n                mp2[cur] = p;\n            }\n        }\n\n        return ans;\n    }\n};","author":"Vijeth G","submissionId":"1575133808"},[]]},{"1126":[{"id":"1126","fileName":"1575133838.txt","sourceCode":"class Solution {\n    int size = 0;\n    public int distance (int a, int b) {\n        \n        if (a==b) return -1;\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        int norm = b-a;\n        int circ = (size - b) + a;\n\n        int dis=  Math.min(norm, circ);\n        //System.out.println(a+\",\" + b + \" :: \"+ dis);\n        return dis;\n    }\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        size = nums.length;\n        Map<Integer, TreeSet<Integer>> numSet = new HashMap<>();\n        for (int i=0; i<nums.length; i++) {\n            TreeSet<Integer> indexes = numSet.getOrDefault(nums[i], new TreeSet<>());\n            indexes.add(i);\n            numSet.put(nums[i], indexes);\n        }\n        List<Integer> res = new ArrayList<>();\n        //System.out.println(numSet);\n        for (int i=0; i<queries.length; i++) {\n            int lookup = nums[queries[i]];\n            TreeSet<Integer> indexes = numSet.get(lookup);\n            int thisIndex = queries[i];\n            int nextValue = indexes.higher(queries[i]) == null ? \n                    indexes.first() : indexes.higher(queries[i]);\n            int previousValue = indexes.lower(queries[i]) == null ? \n                    indexes.last() : indexes.lower(queries[i]);\n            \n            res.add(Math.min(\n                distance(nextValue, thisIndex), \n                distance(previousValue, thisIndex)));\n            \n        }\n        return res;\n    }\n}","author":"hiandhello5","submissionId":"1575133838"},[]]},{"1127":[{"id":"1127","fileName":"1575133914.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>>mpp;\n        for(int i = 0; i < nums.size(); i++){\n            mpp[nums[i]].push_back(i);\n        }\n        int n = nums.size();\n        vector<int>res(nums.size());\n        for(auto ar : mpp){\n            vector<int>arr = ar.second;\n            if(arr.size() == 1){\n                res[arr[0]] = -1;\n                continue;\n            }\n            for (int i = 0; i < arr.size(); i++) {\n                res[arr[i]] = min((i == 0) ? (arr[i] + n - arr[arr.size() - 1]) : (arr[i] - arr[i - 1]), (i == arr.size() - 1) ? (arr[0] + n - arr[i]) : (arr[i + 1] - arr[i]) );\n            }\n        }\n        vector<int> ans(queries.size());\n        for(int i = 0; i < queries.size(); i++)ans[i] = res[queries[i]];\n        return ans;\n    }\n};","author":"im_nitin","submissionId":"1575133914"},[]]},{"1128":[{"id":"1128","fileName":"1575133938.txt","sourceCode":"from bisect import bisect_left\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n=len(nums)\n        pos={}\n        for i,num in enumerate(nums):\n            pos.setdefault(num,[]).append(i)\n        for key in pos:\n            pos[key].sort()\n        ans=[]\n        for q in queries:\n            val=nums[q]\n            if len(pos[val])<2:\n                ans.append(-1)\n                continue\n            lst=pos[val]\n            k=bisect_left(lst,q)\n            left=lst[k-1] if k>0 else lst[-1]\n            right=lst[k+1] if k+1<len(lst) else lst[0]\n            dleft=min(abs(q-left),n-abs(q-left))\n            dright=min(abs(q-right),n-abs(q-right))\n            ans.append(min(dleft,dright))\n        return ans","author":"santhosh-k","submissionId":"1575133938"},[]]},{"1129":[{"id":"1129","fileName":"1575133810.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,set<int>>mp;\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            mp[nums[i]].insert(i);\n        }\n        \n        for(auto &x:mp){\n            if(x.second.size()==1)continue;\n            int first=*x.second.begin();\n            int last=*x.second.rbegin();\n            int lastIndex=last-n;\n            int firstIndex=n+first;\n            x.second.insert(lastIndex);\n            x.second.insert(firstIndex);\n        }\n        vector<int>ans(queries.size());\n        int qn=queries.size();\n        for(int i=0;i<qn;i++){\n            if(mp[nums[queries[i]]].size()!=1){\n                  auto it=mp[nums[queries[i]]].find(queries[i]);\n            auto next_it=next(it);\n            auto prev_it=prev(it);\n            ans[i]=min(*next_it-*it,*it-*prev_it);\n            }else{\n                ans[i]=-1;\n            }\n          \n        }\n        return ans;\n    }\n};","author":"Samyak Rote","submissionId":"1575133810"},[]]},{"1130":[{"id":"1130","fileName":"1575133800.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[]} queries\n * @return {number[]}\n */\nvar solveQueries = function(nums, queries) {\n    let numLists = [];\n\n    for(let i = 0; i < nums.length; ++i) {\n        let num = nums[i];\n        if(!numLists[num]) {\n            numLists[num] ||= [];\n        }\n        numLists[num].push(i);\n    }\n\n    let ret = [];\n    for(let q of queries) {\n        let num = nums[q];\n        let list = numLists[num];\n        if(list.length < 2) {\n            ret.push(-1);\n            continue;\n        }\n\n        let lo = 0, hi = list.length;\n        while(lo < hi) {\n            let mid = Math.floor((lo+hi)/2);\n            if(list[mid] < q) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n\n        let dist1;\n        if(lo < 1) {\n            dist1 = q + 1 + ((nums.length-1) - list.at(-1));\n        } else {\n            dist1 = q-list[lo-1];\n        }\n\n        let dist2;\n        if(lo >= (list.length-1)) {\n            dist2 = ((nums.length)-q)+list[0];\n        } else {\n            dist2 = list[lo+1]-q;\n        }\n\n        ret.push(Math.min(\n            dist1,\n            dist2\n        ));\n\n\n    }\n\n    return ret;\n};\n","author":"Michael","submissionId":"1575133800"},[]]},{"1131":[{"id":"1131","fileName":"1575133922.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        tb = defaultdict(list)\n        pos = [0] * len(nums)\n        for i, x in enumerate(nums):\n            tb[x].append(i)\n            pos[i] = len(tb[x]) - 1\n            \n        ans = [-1] * len(queries)\n        for i, q in enumerate(queries):\n            x = nums[q]\n            arr = tb[x]\n            m = len(tb[x])\n            if m == 1:\n                continue\n            j = pos[q]\n            a = arr[-1] if j == 0 else arr[j - 1]\n            b = arr[0] if j + 1 == m else arr[j + 1]\n            ans[i] = min(min(abs(arr[j] - a), n - abs(arr[j] - a)), min(abs(arr[j] - b), n - abs(arr[j] - b)))\n        return ans","author":"hanbro0112","submissionId":"1575133922"},[]]},{"1132":[{"id":"1132","fileName":"1575133941.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        m = len(queries)\n\n        d = defaultdict(lambda: list())\n        for i, num in enumerate(nums):\n            d[num].append(i)\n\n        for num in d.keys():\n            d[num].sort()\n\n        print(d)\n\n        out = []\n\n        for i in queries:\n            num = nums[i]\n\n            inds = d[num]\n\n            if len(inds) == 1:\n                out.append(-1)\n                continue\n\n            # iddeal = (i + (n//2))%n\n\n            pos = bisect.bisect_left(inds, i)\n            nn = len(inds)\n            \n            \n            tr = [inds[(pos-1)%nn],inds[(pos+1)%nn]]\n            \n            dist = float('inf')\n            for p in tr:\n                if p != i:\n                    di = self.distt(i, p, n)\n                    if di < dist:\n                        dist = di\n            out.append(dist)\n        return out\n\n    def distt(self, i, j, n):\n        if j < i:\n            i,j=j,i\n\n        md = min(\n            j-i,\n            i+(n-j)\n        )\n        return md\n        \n        \n        \n                    \n            \n\n            ","author":"Xander Gardner","submissionId":"1575133941"},[]]},{"1133":[{"id":"1133","fileName":"1575133961.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,set<int>>mp;\n        int n = nums.size();\n        for(int i=0;i<n;i++){\n            mp[nums[i]].insert(i);\n        }\n        vector<int>ans;\n        for(auto c:queries){\n            if( int(mp[nums[c]].size())==1){\n                ans.push_back(-1);\n                continue;\n            }\n            auto ele = mp[nums[c]].lower_bound(c);\n            int mn = 1e9;\n            auto end = mp[nums[c]].end();\n            end--;\n            if(ele==mp[nums[c]].begin()){\n                ele++;\n                mn = min(mn, *ele-c);\n                mn = min(mn, n-(*mp[nums[c]].rbegin())+c);\n            }else if(ele == end ){\n                ele--;\n                mn = min(mn, c-*ele);\n                mn = min(mn, n-c+ (*mp[nums[c]].begin()));\n            }else{\n                ele--;\n                mn = min(mn, c-*ele);\n                ele++;\n                ele++;\n                mn = min(mn, *ele-c);\n            }\n           ans.push_back(mn);\n            \n        }\n\n        return ans;\n    }\n};","author":"Santosh Kumar","submissionId":"1575133961"},[]]},{"1134":[{"id":"1134","fileName":"1575133984.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n                int n = nums.length;\n\n        \n        HashMap<Integer,Integer> prev = new HashMap<>();\n        \n        int[] pa = new int[n];\n        \n        for(int i =0;i<n;i++){\n            int e = nums[i];\n            pa[i] = prev.getOrDefault(e,-1);\n            prev.put(e,i);\n        }\n        \n        \n        HashMap<Integer,Integer> next = new HashMap<>();\n        \n        int[] na = new int[n];\n        \n        for(int i =n-1;i>=0;i--){\n            int e = nums[i];\n            na[i] = next.getOrDefault(e,-1);\n            next.put(e,i);\n        }\n        \n        List<Integer> res = new ArrayList<>();\n        \n        for(int q : queries){\n            int e = nums[q];\n            \n            int pv = pa[q];\n            int nv = na[q];\n            int cr = 0;\n            int cn = 0;\n            System.out.println(pv + \" \" + nv);\n            if(pv == -1 ){\n                if(prev.containsKey(e) && prev.get(e) != q){\n                 \n                    pv = prev.get(e);\n\n                    cr += q + n - pv;\n                    pv = 0;   \n                }\n            }else{\n                \n                cr += q - pv;\n            }\n             \n            if(nv == -1 ){\n                if(next.containsKey(e) && next.get(e) != q){\n                 \n                    nv = next.get(e);\n\n                    cn += n - q + nv;\n                    nv = 0;   \n                }\n            }else{\n                cn += nv - q;\n            }        \n            \n            if(pv == -1 && nv == -1) res.add(-1);\n            else if(pv == -1 && nv != -1) res.add(cn);\n            else if(pv != -1 && nv == -1) res.add(cr);\n            \n            else res.add(Math.min(cn,cr));\n            \n            \n        }\n        \n        return res;\n        \n    }\n}","author":"Navpreet Singh","submissionId":"1575133984"},[]]},{"1135":[{"id":"1135","fileName":"1575134021.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, int> map;\n        unordered_map<int, int> map2;\n        unordered_map<int, int> map3;\n        unordered_map<int, int> map4;\n        vector<int> res;\n        vector<int> pref(nums.size(), -1), post(nums.size(), -1);\n        for (int i = 0; i < nums.size(); i++) {\n            int curr = nums[i];\n            if (map.find(curr) != map.end()) pref[i] = i - map[curr];\n            else map3[curr] = i;\n            map[curr] = i;\n        }\n        for (int i = nums.size() - 1; i >= 0; i--) {\n            int curr = nums[i];\n            if (map2.find(curr) != map2.end()) post[i] = map2[curr] - i;\n            else map4[curr] = i;\n            map2[curr] = i;\n        }\n        for (int i = 0; i < nums.size(); i++) {\n            int curr = nums[i];\n            if (map4.find(curr) != map4.end() && pref[i] == -1) {\n                pref[i] = nums.size() - map4[curr] + i;\n            }\n        }\n        for (int i = nums.size() - 1; i >= 0; i--) {\n            int curr = nums[i];\n            if (map3.find(curr) != map3.end() && post[i] == -1) {\n                post[i] = nums.size() + map3[curr] - i;\n            }\n        }\n        for (int q : queries) res.push_back(min(pref[q], post[q]));\n        for (int i = 0; i < res.size(); i++) if (res[i] == nums.size()) res[i] = -1;\n        return res;\n    }\n};","author":"Jacob Wu","submissionId":"1575134021"},[]]},{"1136":[{"id":"1136","fileName":"1575134019.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> v;\n\n        for (int i = 0; i < n; i++) {\n            v[nums[i]].push_back(i);\n        }\n\n        vector<int> ans;\n\n        for (int query : queries) {\n            int targetValue = nums[query];\n            const vector<int>& indices = v[targetValue];\n\n            if (indices.size() <= 1) {\n                ans.push_back(-1);\n                continue;\n            }\n\n            int idx = lower_bound(indices.begin(), indices.end(), query)-indices.begin();\n            int sz=indices.size();\n            if(idx==0){\n                ans.push_back(min(indices[idx+1]-indices[idx],n-indices[sz-1]+indices[idx]));\n            }else if(idx==sz-1){\n                ans.push_back(min(indices[idx]-indices[idx-1],n-(indices[idx]-indices[0])));\n            }else{\n                ans.push_back(min(indices[idx]-indices[idx-1],indices[idx+1]-indices[idx]));\n            }\n        }\n\n        return ans;\n    }\n};","author":"Random Coder","submissionId":"1575134019"},[]]},{"1137":[{"id":"1137","fileName":"1575133968.txt","sourceCode":"\nusing i8 = int8_t;\nusing u8 = uint8_t;\nusing i16 = int16_t;\nusing u16 = uint16_t;\nusing i32 = int32_t;\nusing u32 = uint32_t;\nusing i64 = int64_t;\nusing u64 = uint64_t;\n\nusing f32 = float;\nusing f64 = double;\n\n#define all(x) (x).begin(), (x).end()\n#define ll long long int\n#define VI vector<ll>\n#define VVI vector<VI>\n\n#define ISD true\n#define debug(x) \n    if (ISD)     \n    cout << #x << \": \" << x << endl\n#define DEBUG(x) cout << #x << \": \" << x << endl\n\ntemplate <typename C>\ni64 SIZE(const C &c)\n{\n    return static_cast<i64>(c.size());\n}\n\ntemplate <typename T, size_t N>\ni64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }\n\ntemplate <typename T, typename U, typename Comp = less<>>\nbool chmax(T &xmax, const U &x, Comp comp = {})\n{\n    if (comp(xmax, x))\n    {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T, typename U, typename Comp = less<>>\nbool chmin(T &xmin, const U &x, Comp comp = {})\n{\n    if (comp(x, xmin))\n    {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\n#define CPP_STR(x) CPP_STR_I(x)\n#define CPP_CAT(x, y) CPP_CAT_I(x, y)\n#define CPP_STR_I(args...) #args\n#define CPP_CAT_I(x, y) x##y\n\n#define ASSERT(expr...) assert((expr))\n\n// }}}\n\nconstexpr i64 INF = 1'010'000'000'000'000'017LL;\n\nconstexpr i64 MOD = 998244353LL;\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n#define M5 100007\n#define M9 1000000000\n\n#define F first\n#define S second\n\n// util {{{\n#define FOR(i, start, end) for (i64 i = (start), CPP_CAT(i, xxxx_end) = (end); i < CPP_CAT(i, xxxx_end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nclass Solution\n{\npublic:\n    vector<int> solveQueries(vector<int> &nums, vector<int> &queries)\n    {\n        ll Q = queries.size();\n        ll N = nums.size();\n        ll NN = N;\n        REP(i, N)\n        {\n            nums.push_back(nums[i]);\n        }\n        REP(i, N)\n        {\n            nums.push_back(nums[i]);\n        }\n        vector<int> ans(Q);\n        REP(i, Q)\n        {\n            queries[i] += N;\n        }\n        map<ll, VI> MP;\n        N *= 3;\n        REP(i, N)\n        {\n            MP[nums[i]].push_back(i);\n        }\n\n        REP(i, Q)\n        {\n            ll t = nums[queries[i]];\n            auto itr = lower_bound(all(MP[t]), queries[i]);\n            auto ritr = itr;\n            auto litr = itr;\n            ritr++;\n            litr--;\n            // cout << *litr << \" \" << *ritr << endl;\n            auto d = min(*itr - *litr, *ritr - *itr);\n            if (d == NN)\n            {\n                ans[i] = -1;\n            }\n            else\n            {\n                ans[i] = d;\n            }\n        }\n        return ans;\n    }\n};","author":"atm314","submissionId":"1575133968"},[]]},{"1138":[{"id":"1138","fileName":"1575134031.txt","sourceCode":"class Solution {\npublic:\n    int find(int i,vector<int>&v){\n        int n=v.size();\n        int s=0,e=n-1;\n\n        int ans=0;\n\n        while(s<=e){\n            int m=(e+s)/2;\n\n            if(v[m]==i)\n                return m;\n\n            else if(v[m]>i)e=m-1;\n\n            else s=m+1;\n        }\n\n        return 0;\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>>m;\n        int n=nums.size();\n        vector<int>ans;\n        \n        for(int i=0;i<n;i++){\n            m[nums[i]].push_back(i);\n        }\n\n        for(auto i:queries){\n            int t=nums[i];\n            int s=m[t].size();\n\n           \n\n            int ind=find(i,m[t]);\n\n\n            int temp=n;\n\n            if(s==1){\n                ans.push_back(-1);\n                continue;\n            }\n\n            if(ind==0){\n                temp=min(m[t][1]-m[t][0],m[t][0]+n-m[t][s-1]);\n            }\n\n            else if\n                (ind==s-1)temp=min(m[t][s-1]-m[t][s-2],m[t][0]+n-m[t][s-1]);\n\n            else \n                 temp=min(m[t][ind]-m[t][ind-1],m[t][ind+1]-m[t][ind]);\n            \n            ans.push_back(temp);\n        }\n\n\n        return ans;\n    }\n};","author":"debaprasad_70","submissionId":"1575134031"},[]]},{"1139":[{"id":"1139","fileName":"1575134166.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        index_map = defaultdict(list)\n    \n        for i, num in enumerate(nums):\n            index_map[num].append(i)\n    \n        n = len(nums)\n        result = []\n        \n        for q in queries:\n            num = nums[q]\n            if len(index_map[num]) == 1:  \n                result.append(-1)\n                continue\n    \n            indices = index_map[num]  \n            pos = bisect.bisect_left(indices, q) \n\n            left_index = indices[pos - 1] if pos > 0 else indices[-1]\n            right_index = indices[pos+1] if pos+1 < len(indices) else indices[0]\n            \n\n            left_distance= 0\n            right_distance=0\n            \n            if left_index<q:\n                left_distance = (q - left_index)\n            else:\n                left_distance = q  + (n-left_index)\n\n            if right_index>q:\n                right_distance = (right_index - q)\n            else:\n                right_distance = (n-q)+right_index\n\n                \n            [0,0,0,0]\n            right_distance = (right_index - q) % n  \n    \n            result.append(min(left_distance, right_distance))\n    \n        return result","author":"Sanjeev","submissionId":"1575134166"},[]]},{"1140":[{"id":"1140","fileName":"1575134032.txt","sourceCode":"class Solution {\n    unordered_map<int,int>p,r,u;\n    void xx(int p,int d){\n        if(r.count(p))r[p]=min(r[p],d);else r[p]=d;\n    }\npublic:\n    vector<int> solveQueries(vector<int>&_x, vector<int>& Q) {\n        vector<int>RR;auto x=_x;\n        x.insert(x.end(),_x.cbegin(),_x.cend());\n        x.insert(x.end(),_x.cbegin(),_x.cend());\n        for(auto t:_x)++u[t];\n        for(int i=0;i<x.size();++i)if(u[x[i]]==1)r[i]=-1;else{\n            if(p.count(x[i])){\n                xx(i,i-p[x[i]]);\n                xx(p[x[i]],i-p[x[i]]);\n            }\n            p[x[i]]=i;\n        }\n        for(auto&q:Q)RR.push_back(r[q+_x.size()]);\n        return RR;\n    }\n};","author":"rip.nsk","submissionId":"1575134032"},[]]},{"1141":[{"id":"1141","fileName":"1575134180.txt","sourceCode":"from bisect import bisect_left\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        index_map = {}\n        for i, num in enumerate(nums):\n            if num not in index_map:\n                index_map[num] = []\n            index_map[num].append(i)\n        \n        def circular_dist(i, j):\n            return min(abs(i - j), n - abs(i - j))\n        \n        answers = []\n        for query in queries:\n            x = nums[query]\n            indices = index_map[x]\n            if len(indices) == 1:\n                answers.append(-1)\n                continue\n    \n            pos = bisect.bisect_left(indices, query)\n    \n            left = indices[pos - 1] if pos > 0 else indices[-1]\n            right = indices[pos + 1] if pos + 1 < len(indices) else indices[0]\n    \n            d_left = circular_dist(query, left)\n            d_right = circular_dist(query, right)\n            answers.append(min(d_left, d_right))\n        \n        return answers","author":"That Panda","submissionId":"1575134180"},[]]},{"1142":[{"id":"1142","fileName":"1575134153.txt","sourceCode":"using ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\n#define all(x) begin(x), end(x)\n#define F first\n#define S second\n#define pb push_back\n\ntemplate<class T> inline T& ckmin(T& a, const T& b) { if(b < a) a = b; return a; }\ntemplate<class T> inline T& ckmax(T& a, const T& b) { if(a < b) a = b; return a; }\n\nnamespace IO {\n    template<typename... Args> void rd(Args&... args) {\n        ((cin >> args), ...); }\n\n    template<typename... Args> void print(Args... args) {\n        ((cout << args << \" \"), ...); }\n}\n\nusing namespace IO;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), q = queries.size();\n        map<int, vector<int>> ind;\n        for (int i = 0; i < n; i++) {\n            ind[nums[i]].pb(i);\n        }\n        vector<int> ans(q);\n        for (int i = 0; i < q; i++) {\n            int t = nums[queries[i]];\n            if (ind[t].size() == 1) {\n                ans[i] = -1;\n            } else {\n                int lft = 0, rit = ind[t].size() - 1, L = -1, R = -1;\n                while (lft <= rit) {\n                    int mid = (lft + rit) / 2;\n                    if (ind[t][mid] >= queries[i]) {\n                        rit = mid - 1;\n                    } else {\n                        L = mid;\n                        lft = mid + 1;\n                    }\n                }\n                lft = 0, rit = ind[t].size() - 1;\n                while (lft <= rit) {\n                    int mid = (lft + rit) / 2;\n                    if (ind[t][mid] <= queries[i]) {\n                        lft = mid + 1;\n                    } else {\n                        R = mid;\n                        rit = mid - 1;\n                    }\n                }\n                \n                // print(L, R, 'n');\n                int cl, cr;\n                if (L == -1) {\n                    cl = queries[i] + n - ind[t].back();    \n                } else {\n                    cl = abs(queries[i] - ind[t][L]);\n                }\n                \n                if (R == -1) {\n                    cr = (n - queries[i]) + ind[t].front();\n                } else {\n                    cr = abs(queries[i] - ind[t][R]);\n                }\n                \n                printf(\"cl: %d cr: %dn\", cl, cr);\n                ans[i] = min(cl, cr);\n            }\n        }\n        return ans;\n    }\n};","author":"_chiikawa","submissionId":"1575134153"},[]]},{"1143":[{"id":"1143","fileName":"1575134184.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size(),q=queries.size();\n        map<int,vector<int>> mp;\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans(q);\n        for(int i=0;i<q;i++){\n            int idx=queries[i];\n            int x=nums[idx];\n            if(mp[x].size()==1)\n            { \n                ans[i]=-1;}\n            else{\n                auto it=upper_bound(mp[x].begin(),mp[x].end(),idx);\n                ans[i]=INT_MAX;\n                if(it!=mp[x].end()){\n                    int k=*it;\n                    ans[i]=k-idx;\n                }else{\n                    int k=*mp[x].begin();\n                    k+=n;\n                    ans[i]=k-idx;\n                }\n                it--;\n                if(it!=mp[x].begin()){\n                    it--;\n                    int k=*it;\n                    ans[i]=min(ans[i],idx-k);\n                }else{\n                    it=mp[x].end();\n                    it--;\n                    int k=*it;\n                    idx+=n;\n                    ans[i]=min(ans[i],idx-k);\n                }\n            }\n        }\n        return ans;\n    }\n};","author":"parthgupta1911","submissionId":"1575134184"},[]]},{"1144":[{"id":"1144","fileName":"1575134190.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> ans;\n        vector<int> v;\n        for(int ch : nums) v.push_back(ch);\n        for(int ch : nums) v.push_back(ch);\n        for(int ch : nums) v.push_back(ch);\n        int n = v.size();\n        vector<int> left(n,-1),right(n,-1);\n        map<int,int> ma,me;\n\n        for(int i = 0; i < n; i++) {\n            if(me[v[i]]) {\n                left[i] = ma[v[i]];\n            }\n            me[v[i]] = 1;\n            ma[v[i]] = i;\n        }\n        for(int i = n-1; i >= 0; i--) {\n            if(me[v[i]] == 2) {\n                right[i] = ma[v[i]];\n            }\n            me[v[i]] = 2;\n            ma[v[i]] = i;\n        }\n        for(int ch : queries) {\n            int ind = ch + nums.size();\n            int a = nums.size();\n            int b = a;\n            if(left[ind] != -1) {\n                a = ind - left[ind];\n            }\n            if(right[ind] != -1) {\n                b = right[ind] - ind;\n            }\n            a = min(a,b);\n            if(a == nums.size()) a = -1;\n            ans.push_back(a);\n        }\n        return ans;\n    }\n};","author":"Tutul_dhar","submissionId":"1575134190"},[]]},{"1145":[{"id":"1145","fileName":"1575134206.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> arr(n, -1);\n        vector<int> res;\n        unordered_map<int, vector<int>>mp;\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n\n        for (auto& [i, a] : mp) {\n            int k = a.size();\n            if (k > 1) {\n                for (int j = 0; j < k; j++) {\n                    int prev = j - 1, next = j + 1, r = n, d = 0;\n                    if (prev < 0)  prev += k;\n                    if (next >= k) next -= k;\n                    //cout <<i << \" \" <<  a[prev] << \" \" << a[j] << \" \" << a[next] << endl;\n                    if (prev != j) {\n                        d = abs(a[prev] - a[j]);\n                        r = min(r, d);\n                        r = min(r, n - d);\n                    }\n\n                    if (next != j) {\n                        d = abs(a[next] - a[j]);\n                        r = min(r, d);\n                        r = min(r, n - d);\n                    }\n                    \n                    arr[a[j]] = r;\n                    //cout << i << \" \" << r << endl;\n                }\n            }\n        }\n\n        for (auto q : queries) {\n            res.push_back(arr[q]);\n        }\n\n        return res;\n    }\n};","author":"dragon76","submissionId":"1575134206"},[]]},{"1146":[{"id":"1146","fileName":"1575134277.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        // shri radhe\n        int n=nums.size(),m=queries.size();\n        map<int,vector<int> >mp;\n        for(int i=0;i<n;i++)mp[nums[i]].push_back(i);\n        vector<int>ramji;\n        for(int i=0;i<m;i++){\n            int ele=queries[i];\n            if(mp[nums[ele]].size()<=1)ramji.push_back(-1);\n            else{\n                int tgt=nums[ele];\n                auto it=lower_bound(mp[tgt].begin(),mp[tgt].end(),ele);\n                int index=it-mp[tgt].begin(),sz=mp[tgt].size();\n                // int mini=min(abs(mp[tgt][(index+1)%sz]-mp[tgt][index]),abs(mp[tgt][(index-1+sz)%sz]-mp[tgt][index]));\n                int mini=1e9+7;\n                // if(mp[tgt][(index+1)%sz]>mp[tgt][index]){\n                    mini=min(mini,abs(mp[tgt][(index+1)%sz]-mp[tgt][index]));\n                    mini=min(mini,n-abs(mp[tgt][(index+1)%sz]-mp[tgt][index]));\n                    mini=min(mini,abs(mp[tgt][(index-1+sz)%sz]-mp[tgt][index]));\n                    mini=min(mini,n-abs(mp[tgt][(index-1+sz)%sz]-mp[tgt][index]));\n                // }\n                ramji.push_back(mini);\n            }\n        }\n        return ramji;\n    }\n};","author":"deepak giri","submissionId":"1575134277"},[]]},{"1147":[{"id":"1147","fileName":"1575134228.txt","sourceCode":"int n;\n\nint dis(int x, int y){\n    return min(abs(x - y), n - abs(x - y));\n}\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        n = nums.size();\n        int q = queries.size();\n        vector<int> answer(n, -1);\n        vector<int> answer_queries;\n        map<int, int> first_seen;\n        map<int, int> last_seen;\n        for (int i = 0;i < n;i++){\n            if (first_seen.find(nums[i]) == first_seen.end()){\n                first_seen[nums[i]] = i;\n            }\n        }\n        for (int i = 0;i < n;i++){\n            if (first_seen[nums[i]] != i){\n                if (answer[i] == -1){\n                    answer[i] = dis(i, first_seen[nums[i]]);\n                }\n                else if (answer[i] > dis(i, first_seen[nums[i]])){\n                    answer[i] = dis(i, first_seen[nums[i]]);\n                }\n            }\n            if (last_seen.find(nums[i]) != last_seen.end()){\n                if (answer[i] == -1){\n                    answer[i] = dis(i, last_seen[nums[i]]);\n                }\n                else if (answer[i] > dis(i, last_seen[nums[i]])){\n                    answer[i] = dis(i, last_seen[nums[i]]);\n                }\n            }\n            last_seen[nums[i]] = i;\n        }\n        first_seen.clear();\n        last_seen.clear();\n        for (int i = n - 1;i >= 0;i--){\n            if (first_seen.find(nums[i]) == first_seen.end()){\n                first_seen[nums[i]] = i;\n            }\n        }\n        for (int i = n - 1;i >= 0;i--){\n            if (first_seen[nums[i]] != i){\n                if (answer[i] == -1){\n                    answer[i] = dis(i, first_seen[nums[i]]);\n                }\n                else if (answer[i] > dis(i, first_seen[nums[i]])){\n                    answer[i] = dis(i, first_seen[nums[i]]);\n                }\n            }\n            if (last_seen.find(nums[i]) != last_seen.end()){\n                if (answer[i] == -1){\n                    answer[i] = dis(i, last_seen[nums[i]]);\n                }\n                else if (answer[i] > dis(i, last_seen[nums[i]])){\n                    answer[i] = dis(i, last_seen[nums[i]]);\n                }\n            }\n            last_seen[nums[i]] = i;\n        }\n        for (int i = 0;i < q;i++){\n            answer_queries.push_back(answer[queries[i]]);\n        }\n        return answer_queries;\n    }\n};","author":"littlemouse","submissionId":"1575134228"},[]]},{"1148":[{"id":"1148","fileName":"1575134297.txt","sourceCode":"class Solution {\n    int distances[200005];\n\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        nums.insert(nums.end(), nums.begin(), nums.end());\n        \n        unordered_map<int, int> value_preIndex;\n        for (int i = 0; i < 2 * n; ++i) {\n            distances[i] = INT_MAX;\n            if (value_preIndex.find(nums[i]) == value_preIndex.end()) {\n                value_preIndex.insert(pair<int, int>(nums[i], i));\n            } else {\n                int preIndex = value_preIndex[nums[i]];\n                if (i >= n && distances[preIndex] == INT_MAX) continue;\n                int dist = i - preIndex;\n                distances[preIndex] = min(distances[preIndex], dist);\n                distances[i] = min(distances[i], dist);\n\n                value_preIndex[nums[i]] = i;\n            }\n        }\n\n\n        vector<int> res;\n        for (int query: queries) {\n            int minDis = min(distances[query], distances[query+n]);\n            if (minDis == INT_MAX) {\n                res.push_back(-1);\n            } else {\n                res.push_back(minDis);\n            }\n        }\n        return res;\n    }\n};\n\n// n = nums.size()\n// distance[n * 2]: min distance to the same value","author":"allen01690","submissionId":"1575134297"},[]]},{"1149":[{"id":"1149","fileName":"1575134338.txt","sourceCode":"class Solution {\npublic:\n    vector<int> preprocess(vector<int>& nums)\n    {\n        int n=nums.size();\n        map<int,vector<int>> mp;\n        vector<int> res(n,INT_MAX);\n        for(int i=0;i<n;i++)\n        {\n            int val=nums[i];\n            if(!mp[val].empty())\n            {\n                int k=mp[val].size();\n                res[mp[val][0]]=min(res[mp[val][0]],min(i-mp[val][0],n-i+mp[val][0]));\n                res[mp[val][k-1]]=min(res[mp[val][k-1]],min(i-mp[val][k-1],n-i+mp[val][k-1]));\n                res[i]=min(min(i-mp[val][k-1],n-i+mp[val][k-1]),min(i-mp[val][0],n-i+mp[val][0]));\n            }\n            mp[val].push_back(i);\n        }\n        return res;\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> val=preprocess(nums);\n        // for(auto it:val)\n        // {\n        //     cout<<it<<\" \";\n        // }\n        // cout<<endl;\n        vector<int> res;\n        for(auto q:queries)\n        {\n            res.push_back(val[q]==INT_MAX?-1:val[q]);\n        }\n        return res;\n    }\n};","author":"LemonDrop","submissionId":"1575134338"},[]]},{"1150":[{"id":"1150","fileName":"1575134367.txt","sourceCode":"/*\nCircular array - goes around\nminimum distance between element and the other index\nnums[j] = nums[queries[i]], -1 if DNE\n\n[1,3,1,4,1,3,2] [0,3,5]\nclosest to value at index 0(1) is at index 2\nindex 3 = 4. No other elements so -1\nindex 5 = 3. closest is 3 since it wraps around.\n\ncurrent solution:\ncreate map of {num, vector<int>indexes}\nindexes are sorted.\nbinary search to find our current index\nthen compare + or - one index to find the closest one.\nreturn -1 if it is size of 0\n*/\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        std::unordered_map<int, std::vector<int>> indexes;\n        for (int i = 0; i < nums.size(); ++i) {\n            const auto num = nums[i];\n            indexes[num].push_back(i);\n        }\n\n        for (auto &[value, index] : indexes) {\n            index.push_back(index[0]+nums.size());\n        }\n\n        // already in sorted order\n        std::vector<int> ans;\n        ans.reserve(queries.size());\n\n        for (const auto query : queries) {\n            const auto num = nums[query];\n            const auto& index_list = indexes[num];\n            if (index_list.size() == 2) {\n                ans.push_back(-1);\n                continue;\n            }\n\n            auto it = std::lower_bound(index_list.cbegin(), index_list.cend(), query);\n            auto index = std::distance(index_list.cbegin(), it);\n            int num_size = nums.size();\n            if (index == 0) {\n                // special logic seconhd last element\n                int forward = index_list[index + 1] - index_list[index];\n                int backward = std::min((int)(index_list.back() - index_list[index_list.size() - 2]), (int)(index_list[index_list.size() - 2] - index_list[0]));\n                ans.push_back(std::min(forward, backward));\n            } else {\n                int forward = index_list[index + 1] - index_list[index];\n                int backward = index_list[index] - index_list[index - 1];\n                ans.push_back(std::min(forward, backward));\n            }\n        }\n        return ans;\n    }\n};","author":"Zachary","submissionId":"1575134367"},[]]},{"1151":[{"id":"1151","fileName":"1575134352.txt","sourceCode":"public class Solution {\n    public IList<int> SolveQueries(int[] nums, int[] queries) {\n        var n = nums.Length;\n        var q = queries.Length;\n        var lastPos = new Dictionary<int, int>();\n        var doubleNums = new int[n * 2];\n        for (int i = 0; i < n * 2; i++)\n        {\n            doubleNums[i] = nums[i % n];\n        }\n\n        var distance = new int[n];\n        Array.Fill(distance, int.MaxValue);\n        for (int i = 0; i < 2 * n; i++)\n        {\n            if (lastPos.TryGetValue(doubleNums[i], out var prevIndex))\n            {\n                if (i - prevIndex != n)\n                {\n                    distance[prevIndex % n] = int.Min(distance[prevIndex % n], i - prevIndex);\n                    distance[i % n] = int.Min(distance[i % n], i - prevIndex);\n                }\n            }\n\n            lastPos[doubleNums[i]] = i;\n        }\n\n        var res = new List<int>();\n        for (int i = 0; i < q; i++)\n        {\n            \n            res.Add(distance[queries[i]] == int.MaxValue ? -1 : distance[queries[i]]);\n        }\n\n        return res;\n    }\n}","author":"Walias","submissionId":"1575134352"},[]]},{"1153":[{"id":"1153","fileName":"1575134373.txt","sourceCode":"const int MAXN = 1e6;\n\nclass Solution {\npublic:\n    int calc(int a, int b, int len)\n    {\n        if (a > b)\n        {\n            swap(a, b);\n        }\n        \n        return min(b - a, a + len - b);\n    }\n    \n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int maxVal = -1;\n        for (auto& num : nums)\n        {\n            maxVal = max(maxVal, num);\n        }\n        \n        vector<vector<int>> pos(maxVal + 1);\n        \n        int n = nums.size();\n        \n        for (int i = 0; i < n; i++)\n        {\n            int val = nums[i];\n            pos[val].push_back(i);\n        }\n        \n        int m = queries.size();\n        vector<int> ans(m, -1);\n        \n        vector<int> cache(n, -2);\n        \n        for (int i = 0; i < m; i++)\n        {\n            int ind = queries[i];\n            int val = nums[ind];\n            \n            if (pos[val].size() == 1)\n            {\n                continue;\n            }\n            if (cache[ind] != -2)\n            {\n                ans[i] = cache[ind];\n                continue;\n            }\n            \n            auto it = lower_bound(pos[val].begin(), pos[val].end(), ind);\n            \n            int cur = distance(pos[val].begin(), it);\n            int len = pos[val].size();\n            int pre, nxt;\n            if (cur == 0)\n            {\n                pre = len - 1;\n            }\n            else\n            {\n                pre = cur - 1;\n            }\n            if (cur == len - 1)\n            {\n                nxt = 0;\n            }\n            else\n            {\n                nxt = cur + 1;\n            }\n            \n            int d = 1e9;\n            d = min(d, calc(pos[val][cur], pos[val][pre], n));\n            d = min(d, calc(pos[val][cur], pos[val][nxt], n));\n            ans[i] = d;\n            cache[ind] = d;\n        }\n        return ans;\n    }\n};","author":"agix","submissionId":"1575134373"},[]]},{"1154":[{"id":"1154","fileName":"1575134421.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        \n        \n        n, m = len(nums), len(queries)\n        count = defaultdict(list)\n        for i, num in enumerate(nums):\n            count[num].append(i)        \n        print(count)\n        \n        d = dict()\n        for num, indices in count.items():\n            k = len(indices)\n            if k == 1:\n                d[indices[0]] = -1\n                continue\n            for j in range(1, k-1):\n                d[indices[j]] = min(indices[j] - indices[j-1], indices[j+1] - indices[j])\n            d[indices[0]] = min(indices[1] - indices[0], n - indices[-1] + indices[0])\n            d[indices[-1]] = min(indices[-1] - indices[-2], n - indices[-1] + indices[0])\n                    \n        \n        res = []\n        for i in queries:\n            res.append(d[i])\n            \n        return res\n        ","author":"Rahul","submissionId":"1575134421"},[]]},{"1155":[{"id":"1155","fileName":"1575134405.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(),x;\n        vector<int> new_num(2*n);\n        vector<int> min_distance(2*n, n);\n        map<int, int> mp, mpl;\n        for(int i=0;i<n;i++) new_num[i] = nums[i], new_num[i+n]= nums[i];\n        \n        for(int i=0;i<2*n;i++){\n            x = new_num[i];\n            auto it = mp.find(x);\n            if(it != mp.end() ) {\n                int prev_pos = it->second;\n                int dist = abs(prev_pos-i);\n                min_distance[i] = min(min_distance[i], dist);\n            }\n            mp[x]=i;\n        }\n        for(int i = 2*n-1;i>=0;i--){\n            x = new_num[i];\n            auto it = mpl.find(x);\n            if(it != mpl.end() ) {\n                int prev_pos = it->second;\n                int dist = abs(prev_pos-i);\n                min_distance[i] = min(min_distance[i], dist);\n            }\n            mpl[x]=i;\n        }\n        for(int i=0;i<n;i++){\n            min_distance[i] = min(min_distance[i], min_distance[i+n]);\n        }\n        vector<int> ans;\n        for(int i;i<queries.size();i++){\n            int min_dis = min_distance[queries[i]];\n            if(min_dis==n) ans.push_back(-1);\n            else ans.push_back(min_dis);\n        }\n        return ans;\n        \n        \n    }\n};","author":"yash gupta","submissionId":"1575134405"},[]]},{"1156":[{"id":"1156","fileName":"1575134428.txt","sourceCode":"class Solution {\nprivate:\n    void fillTheDistances(vector<int> &nums, vector<int> &arr, int dir) {\n        int n = nums.size();\n        unordered_map<int, pair<int, int>> mp;\n        int i = dir > 0 ? 0 : n-1;\n\n        for(; i<n && i>=0; i+=dir) {\n            int num = nums[i];\n            if(mp.count(num) == 0) {\n                mp[num] = {i, i};\n            } else {\n\n                int l = mp[num].first, r = mp[num].second;\n                int mn = abs(i - r);\n                mn = min(mn, n - abs(i - l));\n\n                arr[i] = min(arr[i], mn);\n                \n                mp[num].second = i;\n            }\n        }\n    }\n\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> arr(n, INT_MAX);\n        fillTheDistances(nums, arr, 1);\n        fillTheDistances(nums, arr, -1);\n\n        int m = queries.size();\n        vector<int> ans(m);\n        for(int i = 0; i<m; i++) {\n            if(arr[queries[i]] == INT_MAX) ans[i] = -1;\n            else ans[i] = arr[queries[i]];\n        }\n\n        return ans;\n    }\n};","author":"Parth Gupta","submissionId":"1575134428"},[]]},{"1157":[{"id":"1157","fileName":"1575134493.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        ans = [-1] * n\n        posi = defaultdict(list)\n\n        for i in range(n):\n            posi[nums[i]].append(i)\n\n        for z in posi.values():\n            if len(z) < 2:\n                continue\n\n            z.sort()\n            m = len(z)\n\n            for j in range(m):\n                curr = z[j]\n                left = z[(j - 1 + m) % m]\n                right = z[(j + 1) % m]\n\n                disl = (curr - left + n) % n\n                disr = (right - curr + n) % n\n\n                ans[curr] = min(disl, disr)\n\n        return [ans[q] for q in queries]","author":"srujan","submissionId":"1575134493"},[]]},{"1159":[{"id":"1159","fileName":"1575134444.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int> nums, vector<int> queries) {\n        unordered_map<int, vector<int>> hm;\n        int n = nums.size();\n        unordered_map<int, int> ans;\n        for (int i = 0; i < n; i++) {\n            hm[nums[i]].push_back(i);\n            int sz = hm[nums[i]].size();\n            if (sz > 1) {\n                int last = hm[nums[i]][sz - 1];\n                int secondLast = hm[nums[i]][sz - 2];\n                int dist = last - secondLast;\n                ans[last] = dist;\n                if (ans.find(secondLast) == ans.end()) {\n                    ans[secondLast] = dist;\n                } else {\n                    ans[secondLast] = min(ans[secondLast], dist);\n                }\n            }\n        }\n        for (auto& it : hm) {\n            vector<int>& res = it.second;\n            if (res.size() > 1) {\n                int first = res[0];\n                int last = res[res.size() - 1];\n                int circularDist = n - abs(last - first);\n                \n                ans[first] = min(ans[first], circularDist);\n                ans[last] = min(ans[last], circularDist);\n            }\n        }\n        vector<int> in;\n        for (int q : queries) {\n            in.push_back(ans.count(q) ? ans[q] : -1);\n        }\n        return in;\n    }\n};\n","author":"balaganesh","submissionId":"1575134444"},[]]},{"1160":[{"id":"1160","fileName":"1575134572.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n\n        dic=defaultdict(lambda : 0)\n        for i in nums:\n            dic[i]+=1\n\n        def fun():\n            n = len(nums)\n            extended_nums = nums + nums + nums\n            m = len(extended_nums)\n            prefix = [-1] * m\n            suffix = [-1] * m\n            last_seen = {}\n            for i in range(m):\n                if extended_nums[i] in last_seen:\n                    prefix[i] = last_seen[extended_nums[i]]\n                last_seen[extended_nums[i]] = i\n        \n            last_seen = {}\n        \n            for i in range(m-1, -1, -1):\n                if extended_nums[i] in last_seen:\n                    suffix[i] = last_seen[extended_nums[i]]\n                last_seen[extended_nums[i]] = i\n        \n            result = []\n            for q in queries:\n                original_index = q + n  \n                min_dist = float('inf')\n                if prefix[original_index] != -1:\n                    min_dist = min(min_dist, abs(original_index - prefix[original_index]))\n                if suffix[original_index] != -1:\n                    min_dist = min(min_dist, abs(original_index - suffix[original_index]))\n        \n                if dic[nums[q]]==1:\n                    result.append(-1)\n                else:\n                    result.append(min_dist)\n            \n            return result\n\n        \n        return fun()\n                    \n        \n                    \n        \n        \n        \n                \n                ","author":"Mahesh Reddy","submissionId":"1575134572"},[]]},{"1161":[{"id":"1161","fileName":"1575134489.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        ct = defaultdict(list)\n        nums_order = []\n        n = len(nums)\n        for i,num in enumerate(nums):\n            nums_order.append(len(ct[num]))\n            ct[num].append(i)\n\n        ans = []\n        for q in queries:\n            num = nums[q]\n            order = nums_order[q]\n            if len(ct[num]) <=1:\n                ans.append(-1)\n            else:\n                if order==0:\n                    tmp_ans = q +n - ct[num][order - 1]\n                else:\n                    tmp_ans = q-ct[num][order-1]\n                if order+1 == len(ct[num]):\n                    tmp_ans = min(tmp_ans,n+ct[num][0]-q)\n                else:\n                    tmp_ans = min(tmp_ans,ct[num][(order+1)]-q)\n                ans.append(tmp_ans)\n        return ans\n","author":"Sunny","submissionId":"1575134489"},[]]},{"1162":[{"id":"1162","fileName":"1575134685.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int mx = *max_element(nums.begin(), nums.end());\n        vector<vector<int>> idx(mx + 1);\n        for(int i = 0; i < n; i++) {\n            idx[nums[i]].push_back(i);\n        }\n        vector<int> res;\n        for(int x : queries) {\n            if(idx[nums[x]].size() == 1) {\n                res.push_back(-1); continue;\n            }\n            int m = idx[nums[x]].size(), ans = 1e9;\n            int lb = lower_bound(idx[nums[x]].begin(), idx[nums[x]].end(), x) - idx[nums[x]].begin();\n            // cout << lb << endl;\n            if(lb + 1 < m) {\n                ans = min(ans, abs(x - idx[nums[x]][lb + 1]));\n            }\n            if(lb - 1 >= 0) ans = min(ans, abs(x - idx[nums[x]][lb - 1]));\n            if(lb != m - 1) ans = min(ans, abs(idx[nums[x]].back() - (n + x)));\n            if(lb != 0) ans = min(ans, abs(idx[nums[x]][0] + n - x));\n            res.push_back(ans);\n        }\n        return res;\n    }\n};","author":"Priyank Bisht","submissionId":"1575134685"},[]]},{"1163":[{"id":"1163","fileName":"1575134619.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        map<int,vector<int>> mp;\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        map<int,map<int,int>> temp;\n        for(auto i:mp){\n            vector<int> v = i.second;\n            int m = v.size();\n            map<int,int> track;\n            if(v.size()>1){\n            for(int j=0;j<m;j++){\n                if(j==0){\n                    int x = abs(v[j+1] - v[j]);\n                    int y = v[j] + abs(v[m-1]-(n-1))+1;\n                    int mn = min(x,y);\n                    track[v[j]] = mn;\n                    continue;\n                    \n                }\n                if(j==m-1){\n                    int x = abs(v[j-1] - v[j]);\n                    int y = abs((n-1)-v[j])+v[0]+1;\n                    int mn = min(x,y);\n                    track[v[j]] = mn;\n                    continue;\n                }\n                int x = abs(v[j-1] - v[j]);\n                int y = abs(v[j+1]-v[j]);\n                int mn = min(x,y);\n                track[v[j]] = mn;\n                \n            }\n            }\n            temp[i.first] = track;\n        }\n\n        vector<int> ans(m,-1);\n        for(auto j=0;j<m;j++){\n            int val = nums[queries[j]];\n            int idx = queries[j];\n            if(mp[val].size()<=1) continue;\n            ans[j] = temp[val][idx];\n        }\n        return ans;\n    }\n};","author":"Vasu Tayal","submissionId":"1575134619"},[]]},{"1164":[{"id":"1164","fileName":"1575134740.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> res = new ArrayList<>();\n        int n = nums.length;\n        Map<Integer, Integer> prevIndMap = new HashMap<>();\n        int prevInds[] = new int[n];\n        int nextInds[] = new int[n];\n        for(int i = 0; i < nums.length ; i++) {\n            int curr = nums[i];\n            int prevInd = prevIndMap.getOrDefault(curr, -1);\n            if(prevInd == -1) {\n                prevInds[i] = -1;\n            } else {\n                prevInds[i] = prevInd;\n                nextInds[prevInd] = i;\n            }\n            prevIndMap.put(curr, i);\n        }\n        for(int i = 0; i < nums.length; i++) {\n            int curr = nums[i];\n            int prevInd = prevIndMap.get(curr);\n            if(prevInd == i) {\n                // This is the fist and last element with that value.\n                continue;\n            } else if(prevInds[i] == -1) {\n                // This is the first element with that value, but not last.\n                prevInds[i] = prevInd;\n                nextInds[prevInd] = i;\n            }\n        }\n        for(int ind: queries) {\n            if(prevInds[ind] == -1) {\n                // This is the only element.\n                res.add(-1);\n            } else {\n                int prevInd = prevInds[ind];\n                int nextInd = nextInds[ind];\n                int nextDist = nextInd > ind ? nextInd - ind : (n + nextInd) - ind;\n                int prevDist = prevInd < ind ? ind - prevInd : (ind + 1) + (n - 1 - prevInd);\n                res.add(Math.min(nextDist, prevDist));\n            }\n        }\n        return res;\n    }\n}","author":"skcodes31","submissionId":"1575134740"},[]]},{"1165":[{"id":"1165","fileName":"1575134785.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> ans(queries.size(),-1);\n        map<int,vector<int>> mp;\n        for(int i=0;i<nums.size();i++) {\n            if(mp.find(nums[i])!=mp.end())\n                mp[nums[i]].push_back(i);\n            else\n                mp[nums[i]]={i};\n        }\n        for(int i=0;i<queries.size();i++) {\n            int n=mp[nums[queries[i]]].size();\n            if(mp[nums[queries[i]]].size()>1) {\n                int idx=lower_bound(mp[nums[queries[i]]].begin(),mp[nums[queries[i]]].end(),\n                    queries[i])-mp[nums[queries[i]]].begin();\n                if(idx+1<n)\n                    ans[i]=mp[nums[queries[i]]][idx+1]-queries[i];\n                else\n                    ans[i]=nums.size()-(queries[i]+1)+mp[nums[queries[i]]][0]+1;\n                if(idx-1>=0)\n                    ans[i]=min(ans[i],queries[i]-mp[nums[queries[i]]][idx-1]);\n                else\n                    ans[i]=min(ans[i],int(nums.size())-(mp[nums[queries[i]]].back()+1)+queries[i]+1 );\n            }\n        }\n        return ans;\n    }\n};","author":"Ujjwal Gupta","submissionId":"1575134785"},[]]},{"1166":[{"id":"1166","fileName":"1575134762.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer,List<Integer>>map=new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            int a=nums[i];\n            if(!map.containsKey(a)) map.put(a,new ArrayList<>());\n            map.get(a).add(i);\n        }\n        Map<Integer,List<Integer>>q=new HashMap<>();\n        for(int i=0;i<queries.length;i++){\n            q.putIfAbsent(queries[i],new ArrayList<>());\n            q.get(queries[i]).add(i);\n        }\n        int ans[]=new int[queries.length];\n        Arrays.fill(ans,-1);\n        for(int a:map.keySet()){\n            List<Integer>list=map.get(a);\n            for(int i=0;i<list.size();i++){\n                int idx=list.get(i);\n                if(!q.containsKey(idx)) continue;\n                int n=list.size();\n                int l=list.get((i-1+n)%n);\n                int h=list.get((i+1)%n);\n                for(int j:q.get(idx)){\n                    \n                   \n                    int aa=Integer.MAX_VALUE;\n                    if(idx!=l) {\n                        aa=Math.min(aa,Math.abs(idx-l));\n                        aa=Math.min(aa,nums.length-Math.abs(idx-l));\n                    }\n                    if(idx!=h){\n                        aa=Math.min(aa,Math.abs(idx-h));\n                        aa=Math.min(aa,nums.length-Math.abs(idx-h));\n                    }\n                    if(aa!=Integer.MAX_VALUE) ans[j]=aa;\n                }\n            }\n        }\n        List<Integer>l=new ArrayList<>();\n        for(int a:ans) l.add(a);\n        return l;\n    }\n}","author":"user2134Ue","submissionId":"1575134762"},[]]},{"1167":[{"id":"1167","fileName":"1575134809.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int,vector<int>> m;\n        for (int i=0;i<n;i++){\n            m[nums[i]].push_back(i);\n        }\n\n        \n        vector<int> ans;\n        for (auto &i:queries){\n            if (m[nums[i]].size()==1){\n                ans.push_back(-1);\n                continue;\n            }\n            int ind = lower_bound(m[nums[i]].begin(),m[nums[i]].end(),i)-m[nums[i]].begin();\n            int l = m[nums[i]].size();\n            m[nums[i]].push_back(m[nums[i]][0]+n);\n            int k = INT_MAX;\n\n            \n            if (ind==0){\n                k = min(m[nums[i]][1]-m[nums[i]][0],m[nums[i]][l]-m[nums[i]][l-1]);\n            }\n            else if (ind==l-1){\n                k = min(m[nums[i]][l-1]-m[nums[i]][l-2],m[nums[i]][l]-m[nums[i]][l-1]);\n            }\n            else{\n                k = min(m[nums[i]][ind+1]-m[nums[i]][ind],m[nums[i]][ind]-m[nums[i]][ind-1]);\n            }\n            m[nums[i]].pop_back();\n           ans.push_back(k);\n        }\n\n        return ans;\n    }\n};","author":"Sparsh Dawra","submissionId":"1575134809"},[]]},{"1168":[{"id":"1168","fileName":"1575134793.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& arr, vector<int>& q) {\n        int n = arr.size();\n        map<int, vector<int>> m;\n        for(int i = 0;i < n;i++){\n            m[arr[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(int i = 0;i < q.size();i++){\n            if(m[arr[q[i]]].size() == 1){\n                ans.push_back(-1);\n            }\n            else{\n                int idx = q[i],mini = INT_MAX;\n                // vector<int> temp = m[arr[idx]];\n                auto it = lower_bound(m[arr[idx]].begin(), m[arr[idx]].end(), idx);\n                if(it != m[arr[idx]].begin()){\n                    int i1 = *it;\n                    it--;\n                    int i2 = *it;\n                    mini = i1 - i2;\n                    it++;\n                }\n                else{\n                    mini = n - m[arr[idx]].back() + *it;  \n                }\n                int i1 = *it;\n                it++;\n                if(it != m[arr[idx]].end()){\n                    int i2 = *it;\n                    mini = min(mini, i2 - i1);\n                }\n                else{\n                    mini = min(mini, n - i1 + m[arr[idx]][0]);\n                }\n                ans.push_back(mini);\n            }                \n        }\n        return ans;\n    }\n};","author":"Manav Majithia","submissionId":"1575134793"},[]]},{"1170":[{"id":"1170","fileName":"1575134846.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> inds;\n        int n = nums.size();\n        for(int i=0;i<n;i++) inds[nums[i]].push_back(i);\n\n        int q=queries.size();\n        vector<int> ans(q,-1);\n        for(int i=0;i<q;i++){\n            int idx = queries[i];\n            vector<int> &v = inds[nums[idx]];\n            if(v.size()==1) continue;\n\n            int j = lower_bound(v.begin(),v.end(),idx) - v.begin();\n            int l,r;\n            int x = v.size();\n            if(j==0) l = v[j] + n - v.back();\n            else l = v[j] - v[j-1];\n            if(j==x-1) r = n - v[j] + v[0];\n            else r = v[j+1] - v[j];\n            ans[i] = min(l,r);\n        }\n        return ans;\n    }\n};","author":"RUPAM BHATTACHARJEE","submissionId":"1575134846"},[]]},{"1171":[{"id":"1171","fileName":"1575134824.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int max_ele = 0;\n        for ( int a : nums){\n            max_ele = Math.max(max_ele, a);\n        }\n\n        List<Integer> [] indices = new List [max_ele+1];\n\n        int n = nums.length;\n        for ( int i = 0 ; i < n ; i++){\n            if ( indices[nums[i]] == null){\n                indices[nums[i]] = new ArrayList<>();\n            }\n            indices[nums[i]].add(i);\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for ( int q : queries){\n            int num = nums[q];\n            int sz = indices[num].size();\n            if ( sz == 1){\n                result.add(-1);\n            }\n            else{\n                \n                int idx = Collections.binarySearch(indices[num], q);\n                // idx would be definitely found\n                int left = 0, right = 0;\n                if ( idx == 0){\n                    int rightIdx = indices[num].get(sz-1);\n                    right = Math.abs(q - indices[num].get(idx+1));\n                    left = q + n - rightIdx;\n                }\n                else if(idx == sz - 1){\n                    int leftIdx = indices[num].get(0);\n                    left = Math.abs(q - indices[num].get(idx - 1));\n                    right = ((n - 1) - q) + (leftIdx + 1);\n                }\n                else{\n                    left = Math.abs(q - indices[num].get(idx - 1));\n                    right = Math.abs(q - indices[num].get(idx+1));\n                }\n                result.add(Math.min(left, right));\n            }\n        }\n\n        return result;\n    }\n}","author":"rana_1234","submissionId":"1575134824"},[]]},{"1172":[{"id":"1172","fileName":"1575134848.txt","sourceCode":"class Solution {\npublic:\n    \n    int getAnswerForValue(int idxQ,unordered_map<int,vector<int>> &indices,vector<int> &nums,int n){\n        int elem = nums[idxQ];\n        \n        if(indices[elem].size() == 1)\n            return -1;\n        \n        int idxI = lower_bound(indices[elem].begin(), indices[elem].end(), idxQ) - indices[elem].begin();\n        \n        int elemArrSize = indices[elem].size();\n        \n        int prevElem = (idxI == 0) ? (indices[elem][0] + (n - indices[elem].back())) : (idxQ - indices[elem][idxI-1]);\n        \n        int nextElem = (idxI == elemArrSize - 1) ? (n - idxQ + indices[elem][0]) : (indices[elem][idxI + 1] - idxQ);\n        \n        return min(prevElem,nextElem);\n    }\n\n    \n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        \n        int n = nums.size();\n        \n        unordered_map<int,vector<int>> indices;\n        \n        for(int i=0;i<n;i++)\n            indices[nums[i]].push_back(i);\n        \n        vector<int> ans;\n        \n        for(auto q: queries){\n            ans.push_back(getAnswerForValue(q, indices, nums, n));\n        }\n        return ans;\n    }\n};","author":"Harmandeep Singh","submissionId":"1575134848"},[]]},{"1173":[{"id":"1173","fileName":"1575134926.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n\n        res = []\n        prev = {}\n        close = defaultdict(list)\n        first = {}\n        last = {}\n\n        for i,n in enumerate(nums):\n            if n not in prev:\n                first[n] = i\n            else:\n                pi = prev[n]\n\n                close[i].append(pi)\n                close[pi].append(i)\n\n            prev[n] = i\n            last[n] = i\n\n        for n,v in first.items():\n\n            fi = first[n]\n            li = last[n]\n\n            if first[n]==last[n]:\n                close[fi].append(-1)\n            else:\n                close[fi].append(li)\n                close[li].append(fi)\n\n        def dist(i,j):\n\n            i,j = int(min(i,j)),(max(i,j))\n            l = len(nums)\n            return min(j-i,l-(j-i))\n            \n        for i in queries:\n            res0 = close[i]\n\n            if len(res0)==1:\n                res.append(-1)\n                continue\n\n            fi,li = close[i]\n\n            res0 = min(dist(i,fi),dist(i,li))\n\n            res.append(res0)         \n\n\n        return res\n            \n        ","author":"forquant","submissionId":"1575134926"},[]]},{"1174":[{"id":"1174","fileName":"1575134849.txt","sourceCode":"class Solution {\n public:\n  vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n    int n = nums.size();\n    auto fn = [&] (int i, int j) {\n      if (i > j) {\n        swap(i, j);\n      }\n      return min(j - i, n - j + i);\n    };\n    unordered_map<int, vector<int>> idxs{};\n    for (int i = 0; i < n; ++i) {\n      idxs[nums[i]].push_back(i);\n    }\n    vector<int> ret{};\n    ret.reserve(queries.size());\n    for (int idx : queries) {\n      auto it = idxs.find(nums[idx]);\n      if (it == idxs.end() || it->second.size() == 1) {\n        ret.push_back(-1);\n        continue;\n      }\n      auto pos = lower_bound(it->second.begin(), it->second.end(), idx);\n      auto prev = pos - 1 >= it->second.begin() ? pos - 1 : it->second.end() - 1;\n      auto next = pos + 1 != it->second.end() ? pos + 1 : it->second.begin();\n      int minDist = min(fn(*prev, *pos), fn(*next, *pos));\n      ret.push_back(minDist);\n    }\n    return ret;\n  }\n};","author":"HowAbout3Sum","submissionId":"1575134849"},[]]},{"1175":[{"id":"1175","fileName":"1575135044.txt","sourceCode":"class Solution {\npublic:\n    int get(vector<int> &arr, int t, int n) {\n        int l = 0;\n        int r = arr.size()-1;\n        int m = 0;\n        int best = INT_MAX;\n        while(l <= r) {\n            m = (l+r) / 2;\n            if(arr[m] == t) {\n                break;    \n            }\n            if(arr[m] > t) {\n                r = m-1;\n            }\n            else {\n                l = m+1;\n            }\n        }\n        if(m-1 >= 0)\n            best = min(best, arr[m] - arr[m-1]);\n        if(m+1 < arr.size()) \n            best = min(best, arr[m+1] - arr[m]);\n        if((m == 0 || m == arr.size()-1) && arr.size() > 1)\n            best = min(best, n - arr.back() + arr[0]);\n        int ans = best == INT_MAX ? -1 : best;\n// for(auto x: arr)\n// cout<<x<<' ';\n// cout<<endl<<\"--- \"<<t<<\" \"<<arr.size()<<\" | \"<<m<<' '<<ans<<endl;\n        return ans;\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        int n = nums.size();\n        for(int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(auto i: queries) {\n            ans.push_back(get(mp[nums[i]], i, n));\n        }\n        return ans;\n    }\n};","author":"JVDP LNS","submissionId":"1575135044"},[]]},{"1176":[{"id":"1176","fileName":"1575134944.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n\n        map<int,set<int>> mp;\n        int n = nums.size();\n        for(int i=0;i<nums.size();i++)\n        {\n            mp[nums[i]].insert(i);\n        }\n        for(int i=0;i<nums.size();i++)\n        {\n            mp[nums[i]].insert(i+n);\n        }\n        for(int i=0;i<nums.size();i++)\n        {\n            mp[nums[i]].insert(i-n);\n        }\n\n        vector<int> arr(q.size());\n        for(int i=0;i<q.size();i++)\n        {\n            int id = q[i];\n            int val = nums[id];\n            if(mp[val].size()==3)\n            {\n                arr[i] = -1;\n                continue;\n            }\n            // cout << \"val \" << val << endl;\n            // for(auto itt:mp[val])\n            //     cout << itt << \" \";\n            // cout << endl;\n            auto it = mp[val].lower_bound(id);\n            it--;\n            int prev = (*(it));\n            if(prev<0)\n                prev = prev--;\n            it++;it++;\n            int next = (*it);\n            if(abs(next-id) < abs(id-prev))\n            {\n                arr[i] = abs(next-id);\n            }\n            else\n            {\n                arr[i] = abs(id-prev);\n            }\n            // cout << \"arr \" << arr[i] << endl << endl;\n        }\n        return(arr);\n    }\n};","author":"prabh_","submissionId":"1575134944"},[]]},{"1177":[{"id":"1177","fileName":"1575135037.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        def search(arr,i):\n            l, h = 0, len(arr)-1\n            while True:\n                m = (l+h)//2\n                if arr[m] == i:\n                    return m\n                elif arr[m]>i:\n                    h = m - 1\n                else:\n                    l = m +1\n        def calculate_distance(a,b,x):\n            # if b == 5:\n            #     print(a-b)\n            return min(abs(a-b), x-abs(a-b))\n        n = len(nums)\n        d = defaultdict(list)\n        for i in range(len(nums)):\n            d[nums[i]].append(i)\n        res = []\n        for i in queries:\n            if len(d[nums[i]])==1:\n                res.append(-1)\n            else:\n                tmp = 0\n                arr = d[nums[i]]\n                m = search(arr, i)\n                if m == 0:\n                    res.append(min(calculate_distance(arr[-1],i,n),calculate_distance(arr[1],i,n) ))\n                elif m == len(arr)-1:\n                    # print(i,m,arr)\n                    res.append(min(calculate_distance(arr[m-1],i,n),calculate_distance(arr[0],i,n) ))\n                else:\n                    res.append(min(calculate_distance(arr[m-1],i,n),calculate_distance(arr[m+1],i,n) ))\n        return res\n                    ","author":"Honghui Zhang","submissionId":"1575135037"},[]]},{"1178":[{"id":"1178","fileName":"1575135045.txt","sourceCode":"/*\n1: 0 2 4\n3: 1 5\n*/\nclass Solution {\nprivate:\n    int getValue(int idx, vector<int> &vec) {\n        int n = vec.size();\n        if (idx >= n)\n            return vec[idx-n];\n        if (idx < 0)\n            return vec[idx+n];\n        return vec[idx];\n    }\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        vector<int> ans(q, -1);\n        unordered_map<int, vector<int> > mp;\n\n        for (int i=0 ; i<n ; i++) {\n            if (mp.find(nums[i]) == mp.end())\n                mp[nums[i]] = {};\n            mp[nums[i]].push_back(i);\n        }\n        \n        for (int i=0 ; i<q ; i++) {\n            int v = nums[queries[i]];\n            if (mp[v].size() == 1)\n                continue;\n\n            auto itr = lower_bound(mp[v].begin(), mp[v].end(), queries[i]);\n            int idx = itr - mp[v].begin();\n            int t = INT_MAX;\n\n            // cout << getValue(idx-1, mp[v]) << \" \" << mp[v][idx] << \" \" << getValue(idx+1, mp[v]) << endl;\n            \n            int d1 = mp[v][idx] - getValue(idx-1, mp[v]);\n            if (d1 < 0)\n                d1 += n;\n            int d2 = getValue(idx+1, mp[v]) - mp[v][idx];\n            if (d2 < 0)\n                d2 += n;\n            t = min(d1, d2);\n            ans[i] = t;\n        }\n        \n        return ans;\n    }\n};","author":"eugenechouy","submissionId":"1575135045"},[]]},{"1179":[{"id":"1179","fileName":"1575135069.txt","sourceCode":"from bisect import bisect_left\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        m = {}\n        for i, num in enumerate(nums):\n            if num not in m:\n                m[num] = [i]\n            else:\n                m[num].append(i)\n        res = []\n        for query in queries:\n            if len(m[nums[query]]) == 1:\n                res.append(-1)\n            else:\n                curr = m[nums[query]]\n                i = bisect_left(curr, query)\n                left = i-1 if i > 0 else len(curr)-1 \n                right = i+1 if i < len(curr)-1 else 0\n                leftDis = abs(curr[i]-curr[left])\n                leftDis = min(leftDis, n-leftDis)\n                rightDis = abs(curr[right]-curr[i])\n                rightDis = min(rightDis, n-rightDis)\n                res.append(min(leftDis, rightDis))\n        return res","author":"fast benz","submissionId":"1575135069"},[]]},{"962":[{"id":"962","fileName":"1575129611.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n = nums.size();\n        map<int, vector<int>> fre;\n        for (int i = 0; i < n; i++) {\n            fre[nums[i]].push_back(i);\n        }\n        for (auto &p: fre) {\n            if (p.second.size() > 1) {\n                p.second.push_back(p.second[0] + n);\n            }\n        }\n        vector<int> ans(q.size(), 0);\n        for (int i = 0; i < q.size(); i++) {\n            int a = nums[q[i]];\n            if (fre[a].size() <= 1) {\n                ans[i] = -1;\n                continue;\n            }\n            auto idx = lower_bound(fre[a].begin(), fre[a].end(), q[i]) - fre[a].begin();\n            if (idx != 0) {\n                ans[i] = min(q[i] - fre[a][idx-1], fre[a][idx+1] - q[i]);\n            } else {\n                ans[i] = min(fre[a][idx+1] - q[i], n - fre[a][fre[a].size()-2] + q[i]);\n            }\n        }\n        return ans;\n    }\n};","author":"Siddharth Maddikayala","submissionId":"1575129611"},[{"id":"962","similarity":0.7142857142857143,"totOverlap":140,"longestOverlap":11}]],"1089":[{"id":"1089","fileName":"1575132853.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        vector<int>ans(q.size());\n        map<int,vector<int>>mp;\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        for(int i=0;i<q.size();i++){\n            int val=nums[q[i]];\n            if(mp[val].size()==1)\n                ans[i]=-1;\n            else\n            {\n                auto idx2=lower_bound(mp[val].begin(),mp[val].end(),q[i])-mp[val].begin();\n                if(idx2-1>=0 && idx2+1<mp[val].size()){\n                    ans[i]=min(q[i]-mp[val][idx2-1],mp[val][idx2+1]-q[i]);\n                }\n                else if(idx2-1>=0)\n                {\n                    ans[i]=min(q[i]-mp[val][idx2-1],n-(q[i]-mp[val][0]));\n                }\n                else\n                {\n                    ans[i]=min(mp[val][idx2+1]-q[i],n-(mp[val][mp[val].size()-1]-q[i]));\n                }\n            }\n        }\n        return ans;\n    }\n};","author":"Anurag Vaibhav","submissionId":"1575132853"},[{"id":"1089","similarity":0.7247706422018348,"totOverlap":158,"longestOverlap":14}]],"1180":[{"id":"1180","fileName":"1575135064.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        unordered_map<int, vector<int>> mp;\n        for(int i=0;i<n;i++) {\n            mp[nums[i]].push_back(i);\n        }\n\n        int m=queries.size();\n        vector<int> ans(m, -1);\n        for(int i=0;i<m;i++) {\n            int num=nums[queries[i]];\n            int sz=mp[num].size();\n            if(sz>1) {\n                int index=lower_bound(mp[num].begin(), mp[num].end(), queries[i])-mp[num].begin();\n                if(index>0 && index!=sz-1)  {\n                    ans[i]=min(abs(mp[num][index]-mp[num][index-1]), abs(mp[num][index+1]-mp[num][index]));\n                }\n                else if(index==0) {\n                    ans[i]=min(abs(mp[num][index]+n-mp[num][sz-1]), abs(mp[num][index+1]-mp[num][index]));\n                }\n                else if(index==sz-1) {\n                    ans[i]=min(abs(mp[num][index]-mp[num][index-1]), abs(n-mp[num][index])+mp[num][0]);\n                }\n            }\n        }\n        return ans;\n    }\n};","author":"Nipun","submissionId":"1575135064"},[{"id":"1647","similarity":0.7012987012987013,"totOverlap":162,"longestOverlap":9},{"id":"1647","similarity":0.7247706422018348,"totOverlap":158,"longestOverlap":14},{"id":"1585","similarity":0.7156862745098039,"totOverlap":146,"longestOverlap":9},{"id":"1089","similarity":0.7142857142857143,"totOverlap":140,"longestOverlap":11}]],"1585":[{"id":"1585","fileName":"611237098.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n=nums.size();\n        map<int,vector<int>>p;\n        for(int i=0;i<n;i++) {\n            p[nums[i]].push_back(i);\n        }\n        vector<int>res(q.size());\n        for(int i=0;i<q.size();i++) {\n            int v=nums[q[i]];\n            int k=lower_bound(p[v].begin(),p[v].end(),q[i])-p[v].begin();\n            if(p[v].size()==1) {\n                res[i]=-1;\n            }else if(p[v].size()-1==k) {\n                res[i]=min(q[i]-p[v][k-1],p[v][0]+n-q[i]);\n            }else if(k==0) {\n                res[i]=min(p[v][1]-q[i],q[i]+n-p[v].back());\n            }else{\n                res[i]=min(p[v][k+1]-q[i],q[i]-p[v][k-1]);\n            }\n        }\n        return res;\n    }\n};","author":"DestinyGod","submissionId":"611237098"},[{"id":"1089","similarity":0.7156862745098039,"totOverlap":146,"longestOverlap":9}]],"1647":[{"id":"1647","fileName":"611238743.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> ans(queries.size(), -1);\n        map<int, vector<int>> search;\n        for (int i = 0; i < nums.size(); i++) {\n            search[nums[i]].push_back(i);\n        }\n        int n = nums.size();\n        for (int j = 0; j < queries.size(); j++) {\n            int val = nums[queries[j]];\n            if (search[val].size() == 1) {\n                continue;\n            }\n            int k = std::lower_bound(search[val].begin(), search[val].end(), queries[j]) - search[val].begin();\n            if (k == 0) {\n                ans[j] = min(search[val].front() + n - search[val].back(), search[val][k + 1] - search[val][k]);\n            }\n            else if (k == search[val].size() - 1) {\n                ans[j] = min(search[val].front() + n - search[val].back(), search[val][k] - search[val][k  - 1]);\n            }\n            else {\n                ans[j] = min(search[val][k] - search[val][k - 1], search[val][k + 1] - search[val][k]);\n            }\n            \n        }\n        return ans;\n    }\n};","author":"hit-lu","submissionId":"611238743"},[{"id":"1180","similarity":0.7012987012987013,"totOverlap":162,"longestOverlap":9}]]},{"1181":[{"id":"1181","fileName":"1575135167.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        nn = nums+nums[:-1]\n        l = [inf]*len(nums)\n        last = {} # record last index\n        for i, n in enumerate(nn):\n            if n in last:\n                idx = i%len(nums)\n                l[idx] = min(l[idx], i-last[n])\n                l[last[n]%len(nums)] = min(l[last[n]%len(nums)], i-last[n])\n            last[n]=i\n            \n        ret = [-1] *len(queries)\n        for i, q in enumerate(queries):\n            if l[q]<len(nums):\n                ret[i] = l[q]\n            \n        return ret     ","author":"zanbin2046python","submissionId":"1575135167"},[]]},{"1182":[{"id":"1182","fileName":"1575135313.txt","sourceCode":"class Solution {\npublic:\n   vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n       int n = nums.size();\n       int q = queries.size();\n       map<int, set<int>> mp;\n       for(int i = 0; i < n; i++) {\n           mp[nums[i]].insert(i);\n       }\n       vector<int> ans(q);\n       for(int i = 0; i < q; i++) {\n           int queryIndex = queries[i];\n           int val = nums[queryIndex];\n           if(mp[val].size() == 1) {\n               ans[i] = -1;\n               continue;\n           }\n           auto it = mp[val].find(queryIndex);\n           int minDist = INT_MAX;\n           if(it != mp[val].end()) {\n               auto nextIt = it;\n               ++nextIt;\n               if(nextIt != mp[val].end()) {\n                   minDist = min(minDist, abs(*nextIt - queryIndex));\n                   minDist=min(minDist,queryIndex+n-(*mp[val].rbegin()));\n               }\n               if(it != mp[val].begin()) {\n                   auto prevIt = it;\n                   --prevIt;\n                   minDist = min(minDist, abs(*prevIt - queryIndex));\n                   minDist = min(minDist, (n - queryIndex + *prevIt));\n               }\n                minDist=min(minDist,queryIndex+n-(*mp[val].rbegin()));\n                minDist=min(minDist,n-queryIndex + *mp[val].begin());\n               \n\n           }\n           ans[i] = (minDist == INT_MAX) ? -1 : minDist;\n       }\n       return ans;\n   }\n};","author":"Lakshya Shukla","submissionId":"1575135313"},[]]},{"1183":[{"id":"1183","fileName":"1575135301.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> dp(n, 1e7);\n        unordered_map<int, int> prev = {};\n        for (int i = 0; i < n; i++) {\n            if (prev.count(nums[i])) {\n                dp[prev[nums[i]]] = min(dp[prev[nums[i]]], i - prev[nums[i]]);\n                dp[i] = i - prev[nums[i]];\n            }\n            prev[nums[i]] = i;\n        }\n        for (int i = 0; i < n; i++) {\n            if (prev.count(nums[i]) && prev[nums[i]] != i) {\n                dp[prev[nums[i]]] = min(n + i - prev[nums[i]], dp[prev[nums[i]]]);\n                dp[i] = min(dp[i], n + i - prev[nums[i]]);\n            }\n        }\n        for (int& q: queries) {\n            q = dp[q];\n            if (q == 1e7) q = -1;\n        }\n        return queries;\n    }\n};","author":"Dan Tran","submissionId":"1575135301"},[]]},{"1184":[{"id":"1184","fileName":"1575135152.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        indexToDistance = defaultdict(lambda: float(\"inf\"))\n        numToIndex = {}\n        firstTimeWeSeeNum = {}\n\n        for i, num in enumerate(nums):\n            if num in numToIndex:\n                indexToDistance[numToIndex[num]] = min(indexToDistance[numToIndex[num]], i - numToIndex[num])\n                indexToDistance[i] = i - numToIndex[num]\n                numToIndex[num] = i\n            else:\n                firstTimeWeSeeNum[num] = i\n                numToIndex[num] = i\n\n        for num, i in firstTimeWeSeeNum.items():\n            if i == numToIndex[num]:\n                continue\n            indexToDistance[numToIndex[num]] = min(indexToDistance[numToIndex[num]], i - (numToIndex[num] - len(nums)))\n            indexToDistance[i] = min(indexToDistance[i], i - (numToIndex[num] - len(nums)))\n\n        \n        return [indexToDistance[query] if indexToDistance[query] != float(\"inf\") else -1 for query in queries]\n\n\n\n        \n        ","author":"Lawrence Hoerst","submissionId":"1575135152"},[]]},{"1185":[{"id":"1185","fileName":"1575135175.txt","sourceCode":"class Solution {\n    public:\n\n        template<typename T>\n        int binary_search_left(vector<T> &vec, T target) {\n\n            int left = -1;\n            int right = vec.size();\n\n            while (1 < right - left) {\n\n                int mid = (left + right) / 2;\n\n                if (vec[mid] < target) {\n                    left = mid;\n                } else {\n                    right = mid;\n                }\n            }\n\n            return left;\n        }\n\n        template<typename T>\n        int binary_search_right(vector<T> &vec, T target) {\n\n            int left = -1;\n            int right = vec.size();\n\n            while (1 < right - left) {\n\n                int mid = (left + right) / 2;\n\n                if (vec[mid] < target) {\n                    left = mid;\n                } else {\n                    right = mid;\n                }\n            }\n\n            return right;\n        }\n\n        vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n\n            int n = nums.size();\n            int q = queries.size();\n            const int THRESHOLD = 1 << 29;\n            const int INF = 1 << 30;\n\n            unordered_map<int, vector<int>> counters;\n            unordered_map<int, int> dp;\n            for (int i = 0; i < n; i++) {\n                counters[nums[i]].push_back(i);\n            }\n\n            vector<int> ans_list(q, -1);\n\n            for (int i = 0; i < q; i++) {\n\n                int index = queries[i];\n                int x = nums[index];\n\n                if ((int) counters[x].size() == 1) {\n                    ans_list[i] = -1;\n                    continue;\n                }\n\n                int left = binary_search_left(counters[x], index);\n                int right = binary_search_right(counters[x], index + 1);\n\n                int ans = INF;\n                if (left == -1) {\n                    ans = min(ans, n + index - counters[x].back());\n                } else {\n                    ans = min(ans, index - counters[x][left]);\n                }\n\n                if (right == (int) counters[x].size()) {\n                    ans = min(ans, n + counters[x].front() - index);\n                } else {\n                    ans = min(ans, counters[x][right] - index);\n                }\n\n                ans_list[i] = (ans < THRESHOLD ? ans : -1);\n            }\n\n            return ans_list;\n        }\n    };","author":"drifter","submissionId":"1575135175"},[]]},{"1188":[{"id":"1188","fileName":"1575135332.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        \n        unordered_map<int, vector<int>> map;\n        for (int i = 0; i < nums.size(); ++i) {\n            map[nums[i]].push_back(i);\n        }\n\n        vector<int> ans;\n        for (int query : queries) {\n            int num = nums[query];\n            vector<int> &indexes = map[num];\n\n            if (indexes.size() < 2) {\n                ans.push_back(-1);\n                continue;\n            } else {\n                auto left_it = lower_bound(indexes.begin(), indexes.end(), query);\n                if (left_it == indexes.begin()) {\n                    left_it = indexes.end();\n                }\n                --left_it;\n\n                auto right_it = left_it;\n                ++right_it;\n                if (right_it == indexes.end()) right_it = indexes.begin();\n                ++right_it;\n                if (right_it == indexes.end()) right_it = indexes.begin();\n\n                int left = *left_it;\n                int right = *right_it;\n\n                int min_dist = min({abs(query - left), abs(query - right), n - abs(query - left), n - abs(query - right)});\n                ans.push_back(min_dist);\n            }\n        }\n\n        return ans;\n    }\n};","author":"Jack Palaia","submissionId":"1575135332"},[]]},{"1189":[{"id":"1189","fileName":"1575135357.txt","sourceCode":"class Solution {\npublic:\n    unordered_map<int,vector<int>>freq ;\n    \n    int solve( int i , int value , int n )\n    {\n        int index = -1 ;\n        int s = 0 , e = freq[value].size()-1;\n        while( s<=e )\n        {\n            int mid = s + (e-s)/2;\n            if( freq[value][mid] == i )\n            {\n                index = mid ;\n                break;\n            }\n            \n            if( freq[value][mid] > i )\n                e = mid -1 ;\n            else if( freq[value][mid] < i )\n                s = mid + 1 ;\n        }\n        \n        \n        // now smaller into left and into right \n        int left ;\n        if( index != 0 )\n            left = freq[value][index] - freq[value][index-1];\n        else\n            left = freq[value][index] + n-freq[value][freq[value].size()-1]; \n            \n        int right ;\n        if( index != freq[value].size()-1 )\n            right = freq[value][index+1] - freq[value][index];\n        else\n            right = n-i + freq[value][0];\n        \n        return min( left , right );\n    }\n    \n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) \n    {\n        int n = nums.size();\n        for( int i =0 ; i<nums.size() ; i++ )\n            freq[nums[i]].push_back(i);\n        \n        vector<int>ans;\n        for( auto index : queries )\n        {\n            int value = nums[index];\n            if( freq[value].size() == 1 ){\n                ans.push_back(-1);\n                continue ;\n            }\n            else{\n                int ansDis = solve( index , value , n );\n                ans.push_back(ansDis); \n            }\n        }\n        return ans ;\n    }\n};","author":"kartikgarg991","submissionId":"1575135357"},[]]},{"1190":[{"id":"1190","fileName":"1575135448.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        vector<int> arr(n, -1);\n        for(int i=0; i<n; ++i) {\n            mp[nums[i]].push_back(i);\n        }\n        for(auto& it: mp) {\n            int sz = it.second.size();\n            if(sz <= 1) continue;\n            for(int i=0; i<sz; ++i) {\n                int curr = it.second[i];\n                int prevPos = it.second[(i + sz - 1) % sz];\n                int nextPos = it.second[(i + 1) % sz];\n                int distPrev = (curr - prevPos + n) % n;\n                int distNext = (nextPos - curr + n) % n;\n                arr[curr] = min(distPrev, distNext);\n            } \n        }\n        vector<int> ans;\n        for(auto it: queries) {\n            ans.push_back(arr[it]);\n        }\n        return ans;\n    }\n};","author":"Krishna Sharma","submissionId":"1575135448"},[]]},{"1191":[{"id":"1191","fileName":"1575135477.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) \n    {\n        int n=nums.size();\n        map<int,vector<int>>mpp;\n        int i=0;\n        for(auto &it:nums)\n            {\n                mpp[it].push_back(i);\n                i+=1;\n            }\n        vector<int>answer(n,-1);\n        for(auto &it:mpp)\n            {\n                int val=it.first;\n                vector<int>size2=it.second;\n                int size=size2.size();\n                if(size>1)\n                {\n                    for(int i=0;i<size;i++)\n                        {\n                             if(!i)\n                             {\n                                 int ft=size2[1]-size2[0];\n                                 int lt=n-size2[size-1]+size2[0];\n                                 // printf(\"FT:%d lt:%dn\",ft,lt);\n                                 answer[size2[i]]=min(ft,lt);\n                             }\n                            else if(i<size-1)\n                             {\n                                  int ft=size2[i+1]-size2[i];\n                                 int lt=size2[i]-size2[i-1];\n                                 // printf(\"FT:%d lt:%dn\",ft,lt);\n                                 answer[size2[i]]=min(ft,lt);   \n                             }\n                            else\n                            {\n                                 int ft=n-size2[size-1]+size2[0];\n                                 int lt=size2[i]-size2[i-1];\n                                // printf(\"FT:%d lt:%dn\",ft,lt);\n                                 answer[size2[i]]=min(ft,lt);     \n                            }\n                            // printf(\"I:%d answer:%dn\",size2[i],answer[size2[i]]);\n                        }\n                }\n            }\n        vector<int>main;\n                for(auto i:queries)\n                    {\n                        main.push_back(answer[i]);\n                    }\n                return main;\n    }\n};","author":"fucking_coder","submissionId":"1575135477"},[]]},{"1192":[{"id":"1192","fileName":"1575135437.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        map<int,vector<int>> mp;\n        for(int i = 0;i < nums.size();i++){\n            mp[nums[i]].push_back(i);\n        }\n        int n = q.size();\n        vector<int> an(n,-1);\n        for(int i = 0;i < n;i++){\n            int idx = q[i];\n            if (idx < 0 || idx >= nums.size()){\n                continue;\n            }\n            int k = nums[idx];\n            if (mp[k].size() == 1){\n                continue;\n            }\n            int ans = nums.size()+1;\n            if(mp[k][0] != q[i]){\n                ans = min(ans,(mp[k][0] + ((int)nums.size() - q[i])));\n            }\n            if(mp[k][mp[k].size()-1] != q[i]){\n                ans = min(ans,(((int)nums.size() - mp[k][mp[k].size()-1]) + q[i]));\n            }\n            auto it = lower_bound(mp[k].begin(), mp[k].end(), idx);\n            int p1 = it - mp[k].begin();\n            if(p1 > 0){\n                ans = min(ans,abs(mp[k][p1-1]-idx));\n            }\n            if(p1 < mp[k].size()-1){\n                ans = min(ans,abs(mp[k][p1+1] - idx));\n            }\n            an[i] = ans;\n        }\n        return an;\n    }\n};","author":"itsabhishek9534","submissionId":"1575135437"},[]]},{"1193":[{"id":"1193","fileName":"1575135509.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        hs = {}\n        vals= {}\n\n        for x in range(len(nums)):\n            if nums[x] not in hs:\n                hs[nums[x]] = []\n            hs[nums[x]].append(x)\n            vals[x] = nums[x]\n        ret = []\n\n        \n        for q in queries:\n            cr = vals[q]\n            #print(cr)\n            #print(hs[cr])\n            \n            if len(hs[cr]) <=1:\n                ret.append(-1)\n                #print(\"-----\")\n                continue\n            \n            search = hs[cr]\n            l = 0\n            r = len(search)-1\n            found = -1\n            while l<=r:\n                mid = (l+r)//2\n                if search[mid] == q:\n                    found = mid\n                    break\n                elif search[mid] > q:\n                    r = mid-1\n                else:\n                    l = mid+1\n            #print(found)\n            #print(search)\n            if found != 0 and found!= len(search)-1:\n                #print(\"first\")\n                ret.append(min(search[found]-search[found-1], search[found+1]-search[found]))\n            if found==0:\n                #print(\"second\")\n                ret.append(min(search[found+1]-search[found], (search[found]+len(nums))-search[len(search)-1]))\n            if found==len(search)-1:\n                #print(\"third\")\n                ret.append(min(search[found]-search[found-1], (search[0]+len(nums))-search[found]))\n            #print(\"-----\")\n        return ret\n        \n        ","author":"nepthius","submissionId":"1575135509"},[]]},{"1194":[{"id":"1194","fileName":"1575135525.txt","sourceCode":"#define ll long long \nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n\n        ll n=nums.size();\n\n        vector<ll>v(n,1e9);\n         map<ll,ll>mp;\n        map<ll,ll>mpp;\n        map<ll,ll>mpa;\n        map<ll,ll>mpb;\n        ll val,idx;\n        ll i;\n        for(i=0;i<n;i++){\n             mpp[nums[i]]=1e9;\n            mpa[nums[i]]=1e9;\n            mpb[nums[i]]=0;\n                 \n        }\n        for(i=0;i<n;i++){\n            // val=nums[i];\n            if(mp.find(nums[i])!=mp.end()){\n                ll idx=i-mp[nums[i]];\n                 v[i]=min(v[i],idx);\n            }\n            mp[nums[i]]=i;\n        }\n          mp.clear();\n        for(i=n-1;i>=0;i--){\n          //   val=nums[i];\n            if(mp.find(nums[i])!=mp.end()){\n                ll idx=mp[nums[i]]-i;\n                 v[i]=min(v[i],idx);\n            }\n            mp[nums[i]]=i;\n        }\n\n      for(i=0;i<n;i++){\n       val=nums[i];\n          mpa[val]=min(mpa[val],i);\n          mpb[val]=max(mpb[val],i);\n      }\n\n        for(i=0;i<n;i++){\n            val=nums[i];\n            if(mpa[val]==mpb[val]){\n                continue;\n            }\n            ll p,q;\n            p=n-i+mpa[val];\n            q=n-mpb[val]+i;\n            p=min(p,q);\n            v[i]=min(v[i],p);\n        }\n\n        \n      ll x;\n        \n        vector<int>ans;\n        for(i=0;i<queries.size();i++){\n            val=queries[i];\n            if(v[val]==1e9){\n                 ans.push_back(-1);\n                continue;\n            }\n            ans.push_back(v[val]);\n        }\n\n\n        return  ans;\n    }\n};","author":"Ronit Raj","submissionId":"1575135525"},[]]},{"1195":[{"id":"1195","fileName":"1575135523.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        # [1,3,1,4,1,3,2]\n        # [2,4,2,7,3,3,7]\n        # [3,3,2,7,2,4,7]\n        bucket = {}\n        pos_j = [-1] * (len(nums) * 2)\n        neg_j = [-1] * (len(nums) * 2)\n\n        for n, num in enumerate(nums + nums):\n            if num in bucket:\n                pos_j[bucket[num]] = n - bucket[num]\n                \n            bucket[num] = n\n\n        bucket = {}\n        for n in range(len(nums) * 2 - 1, -1, -1):\n            num = nums[n % len(nums)]\n            \n            if num in bucket:\n                neg_j[bucket[num]] = bucket[num] - n\n                \n            bucket[num] = n\n\n        ans = []\n        \n        for q in queries:\n            value = min(pos_j[q], neg_j[len(nums) + q])\n            if value < len(nums):\n                ans.append(value)\n            else:\n                ans.append(-1)\n                \n        return ans","author":"HoaLA","submissionId":"1575135523"},[]]},{"1196":[{"id":"1196","fileName":"1575135428.txt","sourceCode":"class Solution {\npublic:\n    // vector<int> pos;\n    vector<int> dis;\n    int n;\n\n    vector<int> duplicate(const vector<int>& nums){\n        vector<int> new_nums(2*n, 0);\n        for (int i = 0; i < 2*n; ++i)\n            new_nums[i] = nums[i%n];\n        return new_nums;\n    }\n\n    void _update(int l, int i){\n        if (dis[l % n] == -1 || dis[l % n] > abs(i-l)) {\n            // pos[l % n] = i%n;\n            dis[l % n] = abs(i-l);\n        }        \n    }\n\n    void init(const vector<int>& nums){\n        vector<int> a = duplicate(nums);\n        vector<int> last(int(1e6+1), -1);\n        // pos = vector<int> (n, -1);\n        dis = vector<int> (n, -1);\n        for (int i = 0; i < 2*n; ++i){\n            int l = last[a[i]];\n            last[a[i]] = i;\n            if (l == -1 || i%n == l) continue;\n            _update(l, i);\n            _update(i, l);\n        }\n    }\n    \n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        n = nums.size();\n        init(nums);\n        vector<int> ans(0);\n        for (int q: queries) ans.push_back(dis[q]);\n        return ans;\n    }\n};","author":"Lulu","submissionId":"1575135428"},[]]},{"1197":[{"id":"1197","fileName":"1575135535.txt","sourceCode":"import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> ans= new ArrayList<>();\n        HashMap<Integer,List<Integer>> hm= new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            if(hm.containsKey(nums[i])){\n                List<Integer> al= hm.get(nums[i]);\n                al.add(i);\n                hm.put(nums[i],al);\n            }\n            else{\n                List<Integer> al= new ArrayList<>();\n                al.add(i);\n                hm.put(nums[i],al);\n            }\n        }\n        for(int i:queries){\n            int req=nums[i];\n            List<Integer> arl= hm.get(req);\n            if(arl.size()==1){\n                ans.add(-1);\n            }\n            else{\n                int ind=bs(i,arl);\n                int dist=arl.size();\n                if(ind==arl.size()-1){\n                    int d=nums.length-arl.get(ind)+arl.get(0);\n                    int p=arl.get(ind)-arl.get(ind-1);\n                    ans.add(Math.min(d,p));\n                }\n                else if(ind==0){\n                    int d=arl.get(1)-arl.get(0);\n                    int p=nums.length-arl.get(arl.size()-1)+arl.get(0);\n                    ans.add(Math.min(d,p));\n                }\n                else{\n                    int n=arl.get(ind+1)-arl.get(ind);\n                    int p=arl.get(ind)-arl.get(ind-1);\n                    ans.add(Math.min(n,p));\n                }\n                \n            }\n            \n        }\n        return ans;\n    }\n    private int bs(int i,List<Integer> arl ){\n        int start=0;\n        int end=arl.size()-1;\n        while (start<=end){\n            int mid=(start+end)/2;\n            if(arl.get(mid)==i){\n                return mid;\n            }\n            if(arl.get(mid)>i){\n                end=mid-1;\n            }\n            else{\n                start=mid+1;\n            }\n        }\n        return -1;\n    }\n}","author":"Sri Ramya Nemani","submissionId":"1575135535"},[]]},{"1198":[{"id":"1198","fileName":"1575135601.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n=len(nums)\n        dic=defaultdict(list)\n        for i in range(n):\n            dic[nums[i]].append(i)\n\n        dis=[-1]*n\n        for i in dic:\n            nm=len(dic[i])\n            for j in range(nm):\n                d=1<<44\n                c=(j+1)%nm\n                if c!=j:\n                    d=min(d,n-dic[i][j]+dic[i][c],abs(dic[i][j]-dic[i][c]))\n                c=(j-1)%nm\n                if c!=j:\n                    d=min(d,n-dic[i][c]+dic[i][j],abs(dic[i][j]-dic[i][c]))\n                        \n                if d!=1<<44:\n                    dis[dic[i][j]]=d\n        \n        ret=[]\n        for i in queries:\n            ret.append(dis[i])\n        return ret","author":"FrogFox","submissionId":"1575135601"},[]]},{"1199":[{"id":"1199","fileName":"1575135647.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n#define vii vector<vector<int>>\n#define vpp vector<vector<pair<int, int>>>\n#define vi vector<int>\n#define pb push_back\n#define fi first\n#define se second\n#define s(v) sort(v.begin(), v.end())\n#define r(v) reverse(v.begin(), v.end())\nclass disjointset\n{\npublic:\n    vector<int> rank, size, parent;\n    disjointset(int n)\n    {\n        rank.resize(n + 1, 0);\n        size.resize(n + 1);\n        parent.resize(n + 1);\n        for (int i = 0; i <= n; i++)\n        {\n            size[i] = 1;\n            parent[i] = i;\n        }\n    }\n    int findupar(int node)\n    {\n        if (node == parent[node])\n        {\n            return node;\n        }\n        else\n        {\n            return parent[node] = findupar(parent[node]);\n        }\n    }\n    void unionbyrank(int u, int v)\n    {\n        int ulp_u = findupar(u);\n        int ulp_v = findupar(v);\n        if (ulp_u == ulp_v)\n        {\n            return;\n        }\n        if (rank[ulp_u] < rank[ulp_v])\n        {\n            parent[ulp_u] = ulp_v;\n        }\n        else if (rank[ulp_v] < rank[ulp_u])\n        {\n            parent[ulp_v] = ulp_u;\n        }\n        else\n        {\n            parent[ulp_v] = ulp_u;\n            rank[ulp_u]++;\n        }\n    }\n    void unionbysize(int u, int v)\n    {\n        int ulp_u = findupar(u);\n        int ulp_v = findupar(v);\n        if (ulp_u == ulp_v)\n            return;\n        if (size[ulp_u] < size[ulp_v])\n        {\n            parent[ulp_u] = ulp_v;\n            size[ulp_v] += size[ulp_u];\n        }\n        else\n        {\n            parent[ulp_v] = ulp_u;\n            size[ulp_u] += size[ulp_v];\n        }\n    }\n};\nclass Solution\n{\npublic:\n    vector<int> solveQueries(vector<int> &nums, vector<int> &queries)\n    {\n        map<int, set<int>> z;\n        vector<int> v;\n        vi a = nums;\n        vi b = queries;\n        int n = a.size();\n        disjointset ds(3);\n        for (int i = 0; i < n; i++)\n        {\n            z[a[i]].insert(i);\n        }\n        for (auto ip : b)\n        {\n            int x = a[ip];\n            auto &st = z[x];\n\n            if (st.size() == 1)\n            {\n                v.push_back(-1);\n                continue;\n            }\n            int res = 1e9;\n            auto it = st.find(ip);\n            if (it != st.begin())\n            {\n                auto bp = it;\n                bp--;\n                res = min(res, ip - *bp);\n            }\n            else\n            {\n                auto it2 = st.end();\n                it2--;\n                res = min(res, ip + n - *it2);\n            }\n            auto it1 = it;\n            it1++;\n            if (it1 != st.end())\n            {\n                res = min(res, *it1 - ip);\n            }\n            else\n            {\n                res = min(res, *st.begin() + n - ip);\n            }\n            v.push_back(res);\n        }\n\n        return v;\n    }\n};\n","author":"manideep2004","submissionId":"1575135647"},[]]},{"1200":[{"id":"1200","fileName":"1575135722.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        const int sz = nums.size();\n\n        unordered_map<int, vector<int>> positions;\n\n        for (int i = 0; i < sz; ++i) {\n            positions[nums[i]].push_back(i);\n        }\n\n        vector<int> result;\n        for (int q: queries) {\n            const auto& pos = positions[nums[q]];\n            \n            if (pos.size() < 2) {\n                result.push_back(-1);\n            } else {\n                int idx = distance(pos.begin(), lower_bound(pos.begin(), pos.end(), q));\n                int val = 0;\n                \n                if (idx == 0) {\n                    val = min(pos[idx+1]-q, sz - pos.back() + q);\n                } else if (idx == pos.size()-1) {\n                    val = min(q-pos[idx-1], sz- pos.back() + pos.front());\n                } else {\n                    val = min(q-pos[idx-1], pos[idx+1]-q);\n                }\n\n                result.push_back(val);\n            }\n        }\n        \n        return result;\n    }\n};","author":"Daniel","submissionId":"1575135722"},[]]},{"1201":[{"id":"1201","fileName":"1575135767.txt","sourceCode":"\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        contain = dict()\n        values = [10 ** 12] * n\n        for ind in range(n - 1, -1, -1):\n            num = nums[ind]\n            if num in contain:\n                other_ind = contain[num]\n                values[ind] = min(values[ind], other_ind - ind)\n                values[other_ind] = min(values[other_ind], other_ind - ind)\n\n            contain[num] = ind\n        for ind in range(n - 1, -1, -1):\n            num = nums[ind]\n            if num in contain and contain[num] != ind:\n                other_ind = contain[num]\n                values[ind] = min(values[ind], n - ind + other_ind)\n                values[other_ind] = min(values[other_ind], n - ind + other_ind)\n\n        for ind in range(n):\n            if values[ind] == 10**12:\n                values[ind] = -1\n\n        answers = []\n        for ind in queries:\n            answers.append(values[ind])\n\n        return answers","author":"N Venkat Abhilash","submissionId":"1575135767"},[]]},{"1202":[{"id":"1202","fileName":"1575135692.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        pre = {}\n        nx = {}\n        first = {}\n        cur = {}\n        for i, val in enumerate(nums):\n            if val not in first:\n                first[val] = i\n            if val in cur:\n                pre[i] = cur[val]\n                nx[cur[val]] = i\n            cur[val] = i\n        ans = []\n        for index in queries:\n            if index not in pre and index not in nx:\n                ans.append(-1)\n                continue\n            if index not in nx:\n                ans.append(min(index - pre[index], first[nums[index]] + n - index))\n                continue\n            if index not in pre:\n                ans.append(min(nx[index] - index, index + n - cur[nums[index]]))\n                continue\n            ans.append(min(index - pre[index], nx[index] - index))\n        return ans\n        ","author":"YC W","submissionId":"1575135692"},[]]},{"1203":[{"id":"1203","fileName":"1575135735.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n=len(nums)\n        a={}\n        for i in range(len(nums)):\n            a[nums[i]]=a.get(nums[i],[])+[i]\n        ans=[]\n        \"\"\"  1 2 3 4 3 2 1 \"\"\"\n        for i in queries:\n            b=bisect.bisect_left(a[nums[i]],i)\n            p=q=-1\n            if(b==len(a[nums[i]])-1):\n                p=n+a[nums[i]][0]-a[nums[i]][b]\n            else:\n                p=a[nums[i]][b+1]-a[nums[i]][b]\n            if(b==0):\n                q=n-a[nums[i]][-1]+a[nums[i]][b]\n            else:\n                q=a[nums[i]][b]-a[nums[i]][b-1]\n            p=-1 if p==n else p\n            q=-1 if q==n else q\n            # print(p,q,i,nums[i])\n            if(p==-1):\n                ans.append(q)\n            elif(q==-1):\n                ans.append(p)\n            else:\n                ans.append(min(p,q))\n        return ans\n                    \n                \n        # ans=[]\n        # def do(i):\n        #     b=bisect.bisect_left(a[nums[i]],i)\n        #     # print(a[nums[i]],b)\n        #     if(b+1<len(a[nums[i]])):\n        #         p=abs(a[nums[i]][b+1]-a[nums[i]][b])\n        #     else:\n        #         p=-1\n        #     q=abs(a[nums[i]][b-1]-a[nums[i]][b])\n        #     p=p if (p!=n or 0) else -1\n        #     q=q if (q!=n or 0) else -1\n        #     if(p==-1):\n        #         return q\n        #     elif(q==-1):\n        #         return p\n        #     else:\n        #         return (min(p,q))\n        # for cur in queries:\n        #     ans.append(min(do(cur),do(cur+n)))\n        # return ans\n        ","author":"Vishnu Bathla","submissionId":"1575135735"},[]]},{"1204":[{"id":"1204","fileName":"1575135845.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& que) {\n        vector<int>a=nums;\n        for(auto it:nums)a.push_back(it);\n        int n=nums.size();\n        vector<int>dis(n,-1);\n        unordered_map<int,int>mp;\n        for(int i=0;i<a.size();i++)\n        {\n            if(mp.find(a[i])!=mp.end())\n            {\n                int d=i-mp[a[i]];\n                if(dis[i%n]>d || dis[i%n]==-1)\n                {\n                    dis[i%n]=d;\n                }\n                \n            }\n            mp[a[i]]=i;\n        }\n        unordered_map<int,int>m;\n        for(int i=a.size()-1;i>=0;i--)\n        {\n            if(m.find(a[i])!=m.end())\n            {\n                int d=m[a[i]]-i;\n                if(dis[i%n]>d || dis[i%n]==-1)\n                {\n                    dis[i%n]=d;\n                }\n                \n            }\n            m[a[i]]=i;\n        }\n        // for(auto it:dis)cout<<it<<\" \";\n        vector<int>ans;\n        for(auto it:que)\n        {\n            if(dis[it]!=n)\n           ans.push_back(dis[it]); \n            else ans.push_back(-1); \n        }\n        return ans;\n    }\n};","author":"Ankur Borkar","submissionId":"1575135845"},[]]},{"1205":[{"id":"1205","fileName":"1575135812.txt","sourceCode":"class Solution(object):\n    def solveQueries(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n\n        d = {}\n\n        for i in range(len(nums)):\n            if nums[i] not in d:\n                d[nums[i]] = []\n\n            d[nums[i]].append(i)\n\n        def BS(arr, target):\n            low = 0\n            high = len(arr) - 1\n            while(low <= high):\n                mid = (low + high) // 2\n                if(arr[mid] == target):\n                    return mid\n                elif(arr[mid] > target):\n                    high = mid - 1\n                else:\n                    low = mid + 1\n\n        res = []\n\n        for i in queries:\n            if nums[i] not in d:\n                res.append(-1)\n            elif(len(d[nums[i]]) == 1):\n                res.append(-1)\n            else:\n                x = d[nums[i]]\n                index = BS(x, i)\n                if(index == 0):\n                    distance = min((x[index + 1] - x[index]), len(nums) - x[-1] + x[0])\n                elif(index == len(x) - 1):\n                    distance = min(x[index] - x[index - 1], len(nums) - x[-1] + x[0])\n                else:\n                    distance = min(x[index + 1] - x[index], x[index] - x[index - 1]) \n                res.append(distance)\n        return res\n        ","author":"saivardhan_1999","submissionId":"1575135812"},[]]},{"1206":[{"id":"1206","fileName":"1575135768.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,set<int>> m;\n        for(int i = 0 ;i<nums.size();i++)\n        {\n            m[nums[i]].insert(i);\n        }\n        \n        vector<int> ans(queries.size() ,  -1);\n        \n        int ind = -1 ;\n        for(auto &q:queries)\n        {\n            ind++;\n            if( m[nums[q]].size() ==1 ) continue;\n            \n            auto u  = m[nums[q]].find(q);\n            \n            int cand = 1e9;\n            if( u != m[nums[q]].begin() )\n            {\n              cand = ( *prev(u) - q + nums.size() )%nums.size();\n              cand = min(cand ,  -*prev(u) + q );\n            }\n            else \n            {\n                auto v = m[nums[q]].rbegin();\n                cand = min(cand , (+*v - q) );\n                int temp = ( -*v + q + nums.size() )%nums.size();\n                cand = min(cand , temp  );\n            }\n            \n            \n            if( next(u) != m[nums[q]].end() )\n            {\n                cand = min(cand , (*next(u) - q) );\n                int temp = ( -*next(u) + q + nums.size() )%nums.size();\n                cand = min(cand , temp  );\n            }\n            else\n            {\n                auto v = m[nums[q]].begin();\n                cand = min(cand , (-*v + q) );\n                int temp = ( +*v - q + nums.size() )%nums.size();\n                cand = min(cand , temp  );\n            }\n            \n            if(cand!=1e9) ans[ind] = cand;\n        }\n        \n        return ans;\n    }\n};","author":"ak_fo7","submissionId":"1575135768"},[]]},{"1208":[{"id":"1208","fileName":"1575135868.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        distance = [float('inf')] * n\n        # left to right\n        visits = defaultdict(lambda: -float('inf'))\n        for i, num in enumerate(nums + nums):\n            val = i-visits[num]\n            val = min(val, n-val)\n            distance[i%n] = i-visits[num]\n            visits[num] = i\n\n        visits = defaultdict(lambda: float('inf'))\n        for i in range(2*n-1, -1, -1):\n            num = nums[i%n]\n            dist = visits[num]-i\n            dist = min(dist, n-dist)\n            if isfinite(dist) and dist < distance[i%n]:\n                distance[i%n] = dist\n            visits[num] = i\n\n        res = []\n        for q in queries:\n            val = distance[q]\n            if val == 0:\n                res.append(-1)\n            else:\n                res.append(val)\n        return res","author":"swagggn0","submissionId":"1575135868"},[]]},{"1210":[{"id":"1210","fileName":"1575135894.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> hash = new HashMap<>();\n        int n = nums.length;\n        \n        for(int i=0;i<n;i++){\n            List<Integer> list = hash.getOrDefault(nums[i], new ArrayList<>());\n            list.add(i);\n            \n            hash.put(nums[i], list);\n        }\n        \n        List<Integer> ans = new ArrayList<>();\n        for(int i=0;i<queries.length;i++){\n            if(hash.get(nums[queries[i]]).size() == 1){\n                ans.add(-1);\n            }\n            \n            else{\n                int toFind = queries[i];\n                List<Integer> list = hash.get(nums[queries[i]]);\n                \n                //System.out.println(toFind);\n                int idx = binarySearch(list, toFind);\n                int from = list.get(idx);\n                \n                int reach1 = list.get((idx + 1)%list.size());\n                int reach2 = idx == 0 ? list.get(list.size() - 1) : list.get(idx - 1);\n                \n                //System.out.println(from + \" \" + reach);\n                \n                int dist1 = 0, dist2 = 0;\n                \n                if(reach1 > from){\n                    dist1 = reach1 - from;\n                }\n                \n                else{\n                    dist1 = n - from + reach1;\n                }\n                \n                if(reach2 > from){\n                    dist2 = n - reach2 + from;\n                }\n                \n                else{\n                    dist2 = from- reach2;\n                }\n                \n                ans.add(Math.min(dist1, dist2));\n            }\n        }\n        \n        return ans;\n    }\n    \n    public int binarySearch(List<Integer> list, int x){\n        int start = 0, end = list.size() - 1;\n        \n        while(start <= end){\n            int mid = (start + end)/2;\n            \n            if(list.get(mid) == x){\n                return mid;\n            }\n            \n            else if(list.get(mid) > x){\n                end = mid - 1;\n            }\n            \n            else{\n                start = mid + 1;\n            }\n        }\n        \n        return -1;\n    }\n}","author":"Yatnesh Gyani","submissionId":"1575135894"},[]]},{"1211":[{"id":"1211","fileName":"1575135912.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        \n        vector<int> ans(q, -1);\n        map<int, vector<int>> mp;\n        for(int i=0; i<n; i++){\n            mp[nums[i]].push_back(i);\n        }\n\n        for(int i=0; i<q; i++){\n            int x = queries[i];\n            int num = nums[x];\n            if(mp[num].size()==1) continue;\n            int mn = 1e9;\n            \n            auto it1 = upper_bound(mp[num].begin(), mp[num].end(), x);\n            if(it1 != mp[num].end()){\n                int y = *it1 - x;\n                mn = min(mn, y);\n            }\n            else{\n                mn = min(mn, n-x+mp[num][0]);\n            }\n\n            it1--;\n            if(it1 != mp[num].begin()){\n                it1--;\n                int y = x-*it1;\n                mn = min(mn, y);\n            }\n            else{\n                mn = min(mn, x+n-mp[num].back());\n            }\n\n            ans[i] = mn;\n        }\n        return ans;\n    }\n};","author":"shivamCodes24_7","submissionId":"1575135912"},[]]},{"92":[{"id":"92","fileName":"1575099674.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        nums.insert(nums.end(), nums.begin(), nums.end());\n        vector<int> res(queries.size(), n);\n        vector<int> mndist(nums.size(), n);\n        unordered_map<int, int> mp;\n        for(int i=0;i<2*n;i++) {\n            if(mp.count(nums[i])) mndist[i] = i - mp[nums[i]];\n            mp[nums[i]] = i;\n        }\n        mp.clear();\n        for(int i=2*n-1;i>=0;i--) {\n            if(mp.count(nums[i])) mndist[i] = min(mndist[i], mp[nums[i]] - i);\n            mp[nums[i]] = i;\n        }\n        for(int i=0;i<queries.size();++i) res[i] = min(mndist[queries[i]], mndist[n+queries[i]]);\n        for(int &i : res) if(i == n) i = -1;\n        return res;\n    }\n};","author":"facelessvoid","submissionId":"1575099674"},[{"id":"92","similarity":0.7023809523809523,"totOverlap":118,"longestOverlap":17}]],"176":[{"id":"176","fileName":"1575104545.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int>copied = nums;\n        int n = nums.size();\n        for(int i=0;i<n;i++)\n            copied.push_back(nums[i]);\n        //move from right to left\n        vector<int>closest(copied.size(),n);\n        \n        unordered_map<int,int>last_seen_r;\n        \n        for(int i=copied.size()-1;i>=0;i--)\n        {\n            if(last_seen_r.count(copied[i]))\n                closest[i] = last_seen_r[copied[i]] - i; //distance\n            last_seen_r[copied[i]] = i;\n        }\n        unordered_map<int,int>last_seen_l;\n        for(int i=0;i<copied.size();i++)\n        {\n            if(last_seen_l.count(copied[i]))\n                closest[i] = min(closest[i],i - last_seen_l[copied[i]]); //distance\n            last_seen_l[copied[i]] = i;\n        }\n        for(int i=0;i<n;i++)\n        {\n            closest[i] =min(closest[i],closest[i+n]);\n        }\n        vector<int>ans;\n        for(int q: queries)\n        {\n            if(closest[q]==n )\n                ans.push_back(-1);\n            else\n                ans.push_back(closest[q]);\n        }\n        return ans;\n    }\n};","author":"Mridul Gupta","submissionId":"1575104545"},[{"id":"176","similarity":0.70042194092827,"totOverlap":166,"longestOverlap":10}]],"290":[{"id":"290","fileName":"1575110088.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n=nums.size();\n        vector<int>r(n,1e9),l(n,1e9);\n        int m=q.size();\n        vector<int>ans(m);\n        map<int,int>mp;\n        for(int i=n-1;i>=0;i--)\n        {\n            if(mp.count(nums[i]))\n            {\n                r[i]=min(r[i],mp[nums[i]]-i);\n            }\n            mp[nums[i]]=i;\n        }\n        mp.clear();\n        for(int i=0;i<n;i++)\n        {\n            if(mp.count(nums[i]))\n            {\n                r[i]=min(r[i],n-i+mp[nums[i]]);\n            }\n            if(!mp.count(nums[i]))\n            mp[nums[i]]=i;\n        }\n        mp.clear();\n        for(int i=0;i<n;i++)\n        {\n            if(mp.count(nums[i]))\n            {\n                l[i]=min(l[i],i-mp[nums[i]]);\n            }\n            mp[nums[i]]=i;\n        }\n        mp.clear();\n        for(int i=n-1;i>=0;i--)\n        {\n            if(mp.count(nums[i]))\n            {\n                l[i]=min(l[i],i+n-mp[nums[i]]);\n            }\n            if(!mp.count(nums[i]))\n            mp[nums[i]]=i;\n        }\n        for(int i=0;i<m;i++)\n        {\n            int j=q[i];\n            if(min(l[j],r[j])==1e9)\n            ans[i]=-1;\n            else ans[i]=min(l[j],r[j]);\n        }\n        return ans;\n    }\n};","author":"kushal46","submissionId":"1575110088"},[{"id":"456","similarity":0.7528089887640449,"totOverlap":201,"longestOverlap":15},{"id":"1974","similarity":0.7730769230769231,"totOverlap":201,"longestOverlap":34},{"id":"639","similarity":0.7076923076923077,"totOverlap":184,"longestOverlap":13},{"id":"1373","similarity":0.7449392712550608,"totOverlap":184,"longestOverlap":16}]],"345":[{"id":"345","fileName":"1575112224.txt","sourceCode":"class Solution {\npublic:\nvector<int> solveQueries(vector<int>& a, vector<int>& queries) {\n    int n=a.size(),q=queries.size();\n    vector<int>pref(n,1e9),suff(n,1e9);\n    map<int,int> mp;\n    map<int,int> first;\n    for(int i=0;i<n;i++){\n        if(mp.count(a[i])==0){\n            first[a[i]]=i;\n        }\n        else{\n            int ind=mp[a[i]];\n            int cir = n -(i-ind);\n            pref[ind]=min(pref[ind],i-ind);\n            pref[ind]=min(pref[ind],cir);\n            pref[i]=min(pref[i],i-ind);\n            pref[i]=min(pref[i],cir);\n            int idx=first[a[i]];\n            int circ = n-(i-idx);\n            pref[idx]=min(pref[idx],i-idx);\n            pref[idx]=min(pref[idx],circ);\n            pref[i]=min(pref[i],i-idx);\n            pref[i]=min(pref[i],circ);\n        }\n        mp[a[i]]=i;\n    }\n    vector<int>ans(q,-1);\n    for(int i=0;i<q;i++){\n        int ind=queries[i];\n        if(pref[ind]!=1e9){\n            ans[i]=pref[ind];\n        }\n    }\n    return ans;\n}\n\n};","author":"Meet Modi","submissionId":"1575112224"},[{"id":"898","similarity":0.7192118226600985,"totOverlap":146,"longestOverlap":10},{"id":"1767","similarity":0.7182320441988951,"totOverlap":130,"longestOverlap":10},{"id":"447","similarity":0.7371428571428571,"totOverlap":129,"longestOverlap":10}]],"447":[{"id":"447","fileName":"1575115758.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        int n = a.size();\n        vector<int> res(n, INT_MAX);\n        unordered_map<int, int> m;\n        for(int i = 0; i < n; i++){\n            if(m.count(a[i])){\n                int j = m[a[i]];\n                res[i] = i - j;\n                res[j] = min(res[j], res[i]);\n            }\n            m[a[i]] = i;\n        }\n        for(int i = 0; i < n; i++){\n            if(m[a[i]] > i){\n                int j = m[a[i]];\n                int temp = n - j + i;\n                res[j] = min(res[j], temp);\n                res[i] = min(res[i], temp);\n            }\n        }\n        vector<int> ans(q.size(), -1);\n        for(int i = 0; i < q.size(); i++){\n            if(res[q[i]] != INT_MAX){\n                ans[i] = res[q[i]];\n            }\n        }\n        return ans;\n    }\n};","author":"thilak","submissionId":"1575115758"},[{"id":"447","similarity":0.7244094488188977,"totOverlap":184,"longestOverlap":13}]],"456":[{"id":"456","fileName":"1575115946.txt","sourceCode":"class Solution {\npublic:\n    const int INF = 1e9;\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        map<int,int> prev, next, first, last;\n        vector<int> dist(n,INF);\n        for(int i = 0; i < n; i++) {\n            if(prev.count(nums[i]))\n                dist[i] = min(dist[i],i-prev[nums[i]]);\n            prev[nums[i]] = i;\n            if(!first.count(nums[i]))\n                first[nums[i]] = i;\n        }\n        for(int i = n-1; i >= 0; i--) {\n            if(next.count(nums[i]))\n                dist[i] = min(dist[i],next[nums[i]]-i);\n            next[nums[i]] = i;\n            if(!last.count(nums[i]))\n                last[nums[i]] = i;\n        }\n        for(int i = 0; i < n; i++) {\n            if(last.count(nums[i]) && last[nums[i]] > i)\n                dist[i] = min(dist[i],n-last[nums[i]]+i);\n            if(first.count(nums[i]) && first[nums[i]] < i)\n                dist[i] = min(dist[i],n-i+first[nums[i]]);\n        }\n        vector<int> ans(m);\n        for(int i = 0; i < m; i++)\n            ans[i] = dist[queries[i]] >= INF ? -1 : dist[queries[i]];\n        return ans;\n    }\n};","author":"Manas Kumar","submissionId":"1575115946"},[{"id":"290","similarity":0.7528089887640449,"totOverlap":201,"longestOverlap":15}]],"562":[{"id":"562","fileName":"1575118930.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,int> mp;\n        \n        int n = nums.size();\n        for(int i = 0;i < n;i++){\n            nums.push_back(nums[i]);\n        }\n        vector<int> ans(nums.size(),-1);\n        for(int i = nums.size()-1;i >= 0;i--){\n            if(mp.count(nums[i])){\n                if((mp[nums[i]]-i) < n){\n                    // cout << mp[nums[i]]-i << \" \" << n << 'n';\n                    ans[i] = mp[nums[i]]-i;    \n                }\n                \n            }\n            mp[nums[i]] = i;\n        }\n        mp.clear();\n        for(int i = 0;i < nums.size();i++){\n            if(mp.count(nums[i])){\n                if(ans[i] == -1){\n                    if((i-mp[nums[i]]) < n){\n                        // assert((i-mp[nums[i]]) < n);\n                        // cout << i-mp[nums[i]] << \" \" << n << 'n';\n                        ans[i] = i-mp[nums[i]];    \n                    }\n                    \n                }else{\n                    if((i-mp[nums[i]]) < n){\n                        // assert((i-mp[nums[i]]) < n);\n                        // cout << i-mp[nums[i]] << \" \" << n << 'n';\n                        ans[i] = min(ans[i],i-mp[nums[i]]);    \n                    }\n                    \n                }\n            }\n            mp[nums[i]] = i;\n        }\n        vector<int> res;\n        for(auto &query : queries){\n            res.push_back(min(ans[query],ans[query+n]));\n        }\n        return res;\n    }\n};","author":"Parth Vijay","submissionId":"1575118930"},[{"id":"562","similarity":0.7130044843049327,"totOverlap":159,"longestOverlap":16}]],"639":[{"id":"639","fileName":"1575121547.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        vector<int>mind(n,n);\n        unordered_map<int,int>prev,next;\n        for(int i=1;i<n;i++) prev[nums[i]]=i;\n        for(int i=0;i<n;i++){\n            if(prev.count(nums[i])){\n                if(prev[nums[i]]<i) mind[i]=min(mind[i],i-prev[nums[i]]);\n                else if(prev[nums[i]]>i) mind[i]=min(mind[i],i+n-prev[nums[i]]);\n                \n            }\n            prev[nums[i]]=i;\n        }\n        for(int i=n-2;i>=0;i--) next[nums[i]]=i;\n        for(int i=n-1;i>=0;i--){\n            if(next.count(nums[i])){\n                if(next[nums[i]]>i) mind[i]=min(mind[i],next[nums[i]]-i);\n                else if(next[nums[i]]<i) mind[i]=min(mind[i],n-i+next[nums[i]]);\n                \n            }\n            next[nums[i]]=i;\n        }\n        for(int i=0;i<queries.size();i++){\n            queries[i]=mind[queries[i]]<n?mind[queries[i]]:-1;\n        }\n        return queries;\n    }\n};","author":"Honey Gupta","submissionId":"1575121547"},[{"id":"290","similarity":0.7076923076923077,"totOverlap":184,"longestOverlap":13}]],"643":[{"id":"643","fileName":"1575121628.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, int> first;\n        for(int i = 0; i < nums.size(); i++)\n            if(first.find(nums[i]) == first.end())\n                first[nums[i]] = i;\n        unordered_map<int, int> last;\n        for(int i = nums.size() - 1; i >= 0; i--)\n            if(last.find(nums[i]) == last.end())\n                last[nums[i]] = i;\n        vector<int> vec(nums.size(), INT_MAX);\n        unordered_map<int, int> prev;\n        for(int i = 0; i < nums.size(); i++) {\n            if(prev.find(nums[i]) == prev.end())\n                vec[i] = (last[nums[i]] != i) ? (int)nums.size() - last[nums[i]] + i : INT_MAX;\n            else\n                vec[i] = i - prev[nums[i]];\n            prev[nums[i]] = i;\n        }\n        prev.clear();\n        for(int i = nums.size() - 1; i >= 0; i--) {\n            if(prev.find(nums[i]) == prev.end())\n                vec[i] = min(vec[i], (first[nums[i]] != i) ? (int)nums.size() - i + first[nums[i]] : INT_MAX);\n            else\n                vec[i] = min(vec[i], prev[nums[i]] - i);\n            prev[nums[i]] = i;\n        }\n        vector<int> result(queries.size(), 0);\n        for(int i = 0; i < result.size(); i++)\n            result[i] = vec[queries[i]] < INT_MAX ? vec[queries[i]] : -1;\n        return result;\n    }\n};","author":"Ting","submissionId":"1575121628"},[{"id":"643","similarity":0.7311827956989247,"totOverlap":204,"longestOverlap":8}]],"898":[{"id":"898","fileName":"1575128231.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int q = queries.size();\n        int n = nums.size();\n        vector<int> ans(q);\n        unordered_map<int, int> mp;\n        vector<int> vec(n, 1e9);\n\n        for(int i = 0; i < 2*n; i++){\n            int ind = i%n;\n            if(mp.find(nums[ind]) == mp.end()){\n                mp[nums[ind]] = ind;\n            }\n            else{\n                int prev = mp[nums[ind]];\n                int diff = abs(ind-prev);\n                vec[ind] = min(vec[ind], min(diff, n-diff));\n                vec[prev] = min(vec[prev], min(diff, n-diff));\n                mp[nums[ind]] = ind;\n            }\n        }\n\n        for(int i = 0; i < q; i++){\n            if(vec[queries[i]] == 1e9 || vec[queries[i]] == 0){\n                ans[i] = -1;\n                continue;\n            }\n            ans[i] = vec[queries[i]];\n        }\n\n        return ans;\n    }\n};","author":"Sanskar Sureka","submissionId":"1575128231"},[{"id":"345","similarity":0.7192118226600985,"totOverlap":146,"longestOverlap":10}]],"917":[{"id":"917","fileName":"1575128573.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> a;\n        map<int, int> prev, mpp, freq;\n\n        for(auto &i: nums) a.push_back(i), freq[i]++;\n        for(auto &i: nums) a.push_back(i);\n\n        int n = a.size();\n        vector<int> dist(n, 1e9);\n\n        for(int i = 0; i < n; i++) {\n            if(prev.count(a[i])) {\n                dist[i] = min(dist[i], i - prev[a[i]]);\n            }\n\n            prev[a[i]] = i;\n        }\n\n        prev.clear();\n\n        for(int i = n - 1; i >= 0; i--) {\n            if(prev.count(a[i])) {\n                dist[i] = min(dist[i], prev[a[i]] - i);\n            }\n\n            prev[a[i]] = i;\n        }\n\n        vector<int> ans;\n        int m = nums.size();\n\n        for(auto &i: queries) {\n            if(freq[nums[i]] > 1) ans.push_back(min(dist[i], dist[m + i]));\n            else ans.push_back(-1);\n        }\n\n        return ans;        \n    }\n};","author":"Akash0P","submissionId":"1575128573"},[{"id":"290","similarity":0.7310924369747899,"totOverlap":174,"longestOverlap":32}]],"925":[{"id":"925","fileName":"1575128688.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& arr, vector<int>& qr) {\n\n        int n = arr.size();\n        vector<int> pre(n, -1);\n\n        unordered_map<int, int> lr;\n\n        unordered_map<int, int> focc; // first occurrance\n        \n        for(int i=0; i<n; i++)\n        {\n            if(lr.find(arr[i])!=lr.end())\n            {\n                pre[i] = min(abs(i-lr[arr[i]]), abs(focc[arr[i]] + n - i));\n            }\n\n            if(focc.find(arr[i])==focc.end())\n            {\n                focc[arr[i]]=i;\n            }\n\n            lr[arr[i]]=i;\n        }\n\n        // for(int i: pre)\n        //     {\n        //         cout<<i<<\" | \";\n        //     }\n\n        unordered_map<int, int> rl;\n        unordered_map<int, int> locc; // last occ\n        \n        for(int i=n-1; i>=0; i--)\n        {\n            if(rl.find(arr[i])!=rl.end())\n            {\n                int dist = min(abs(rl[arr[i]]-i), abs(i + n - locc[arr[i]]));\n\n                if(pre[i]==-1)\n                {\n                    pre[i]=dist;\n                }\n                else\n                {\n                    pre[i] = min(pre[i], dist);\n                }\n            }\n\n            if(locc.find(arr[i])==locc.end())\n            {\n                locc[arr[i]]=i;\n            }\n\n            rl[arr[i]]=i;\n        }\n\n        vector<int> ans;\n\n        for(int i: qr)\n            {\n                ans.push_back(pre[i]);\n            }\n\n        return ans;\n    }\n};","author":"Samarth Patel","submissionId":"1575128688"},[{"id":"925","similarity":0.72,"totOverlap":180,"longestOverlap":12}]],"1213":[{"id":"1213","fileName":"1575135975.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n=nums.size();\n        unordered_map<int,int>mp1;\n        unordered_map<int,int>mp2;\n        unordered_map<int,int>first;\n        // vector<int>near(nums.size(),-1);\n        // vector<int>near2(nums.size(),-1);\n        vector<int>dist(nums.size(),1e9);\n        for(int i=0;i<nums.size();i++){\n            if(mp1.find(nums[i])!=mp1.end()){\n                dist[i]=min(dist[i],i-mp1[nums[i]]);\n            }\n            mp1[nums[i]]=i;\n            if(first.find(nums[i])==first.end()){\n                first[nums[i]]=i;\n            }\n        }\n        for(int i=0;i<n;i++){\n            if(mp1.find(nums[i])!=mp1.end() && mp1[nums[i]]!=i){\n                dist[i]=min(dist[i],i+n-mp1[nums[i]]);\n            }\n        }\n        for(int i=n-1;i>=0;i--){\n            if(mp2.find(nums[i])!=mp2.end()){\n                dist[i]=min(dist[i],mp2[nums[i]]-i);\n            }\n            else if(first.find(nums[i])!=first.end() && first[nums[i]]!=i){\n                dist[i]=min(dist[i],first[nums[i]]+n-i);\n            }\n        \n            mp2[nums[i]]=i;\n        }\n        vector<int>ans;\n        for(int i=0;i<q.size();i++){\n            if(dist[q[i]]==1e9){\n                ans.push_back(-1);\n            }\n            else{\n            ans.push_back(dist[q[i]]);\n            }\n        }\n        return ans;\n    }\n};","author":"crying_2003","submissionId":"1575135975"},[{"id":"1952","similarity":0.717948717948718,"totOverlap":224,"longestOverlap":10},{"id":"1213","similarity":0.7311827956989247,"totOverlap":204,"longestOverlap":8},{"id":"1373","similarity":0.7084870848708487,"totOverlap":192,"longestOverlap":12},{"id":"1332","similarity":0.7022058823529411,"totOverlap":191,"longestOverlap":15},{"id":"1952","similarity":0.7244094488188977,"totOverlap":184,"longestOverlap":13},{"id":"1974","similarity":0.7449392712550608,"totOverlap":184,"longestOverlap":16},{"id":"1213","similarity":0.72,"totOverlap":180,"longestOverlap":12},{"id":"917","similarity":0.7310924369747899,"totOverlap":174,"longestOverlap":32},{"id":"1493","similarity":0.75,"totOverlap":174,"longestOverlap":12},{"id":"643","similarity":0.70042194092827,"totOverlap":166,"longestOverlap":10},{"id":"1356","similarity":0.7256637168141593,"totOverlap":164,"longestOverlap":18},{"id":"1974","similarity":0.7130044843049327,"totOverlap":159,"longestOverlap":16},{"id":"1767","similarity":0.7371428571428571,"totOverlap":129,"longestOverlap":10},{"id":"1603","similarity":0.7251461988304093,"totOverlap":124,"longestOverlap":17},{"id":"1356","similarity":0.7023809523809523,"totOverlap":118,"longestOverlap":17}]],"1332":[{"id":"1332","fileName":"1575139188.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        // vector<int> temp;\n        int n = a.size();\n        unordered_map<int, int> mp, md;\n        for(int i=0; i<n; i++) {\n            if(mp.find(a[i]) == mp.end()) {\n                mp[a[i]] = i;\n            }\n            else {\n                md[i] = i - mp[a[i]];\n                mp[a[i]] = i;\n            }\n        }\n        // for(auto &[key, val]: md) {\n        //     cout<<key<<\" \"<<val<<endl;\n        // }\n        // cout<<endl;\n        for(int i=0; i<n; i++) {\n            if(md.find(i) != md.end())\n                md[i] = min(md[i], n+i-mp[a[i]]);\n            else {\n                md[i] = n+i-mp[a[i]];\n            }\n        }\n\n        mp.clear();\n\n        for(int i=n-1; i>=0; i--) {\n            if(mp.find(a[i]) == mp.end()) {\n                mp[a[i]] = i;\n            }\n            else {\n                md[i] = min(md[i], mp[a[i]] - i);\n                mp[a[i]] = i;\n            }\n        }\n\n        for(int i=n-1; i>=0; i--) {\n            if(md.find(i) != md.end())\n                md[i] = min(md[i], n-i+mp[a[i]]);\n            else {\n                md[i] = n-i+mp[a[i]];\n            }\n        }\n        \n        vector<int> ans;\n        for(auto u: q) {\n            if(md[u] == a.size())\n                ans.push_back(-1);\n            else ans.push_back(md[u]);\n                    \n        }\n        return ans;\n    }\n};","author":"abcd","submissionId":"1575139188"},[{"id":"1213","similarity":0.7022058823529411,"totOverlap":191,"longestOverlap":15}]],"1356":[{"id":"1356","fileName":"611229120.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& num, vector<int>& q) {\n        int n = num.size();\n        for (int i = 0; i < n; i++) num.push_back(num[i]);\n        n *= 2;\n        vector<int> ans(n, 1e9);\n        map<int, int> pre;\n        for (int i = 0; i < n; i++) {\n            if (pre.count(num[i])) ans[i] = min(ans[i], i - pre[num[i]]);\n            pre[num[i]] = i;\n        }\n        pre.clear();\n        for (int i = n - 1; i >= 0; i--) {\n            if (pre.count(num[i])) ans[i] = min(ans[i], pre[num[i]] - i);\n            pre[num[i]] = i;\n        }\n        vector<int> res;\n        for (int &i : q) {\n            int tmp = min(ans[i], ans[i + n / 2]);\n            if (tmp < n / 2) res.push_back(tmp);\n            else res.push_back(-1);\n        }\n        return res;\n    }\n};","author":"tobo","submissionId":"611229120"},[{"id":"290","similarity":0.7256637168141593,"totOverlap":164,"longestOverlap":18}]],"1373":[{"id":"1373","fileName":"611230241.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector <int> res(nums.size(), 0x3f3f3f3f);\n        unordered_map <int, int> mp;\n        for(int i = 0; i < nums.size(); i++){\n            if(mp.count(nums[i])){\n                res[i] = min(res[i], i - mp[nums[i]]);\n            }\n            mp[nums[i]] = i;\n        }\n        mp.clear();\n        for(int i = 0; i < nums.size(); i++){\n            if(mp.count(nums[i])){\n                res[i] = min(res[i], (int)nums.size() - i + mp[nums[i]]);\n            }else{\n                mp[nums[i]] = i;\n            }\n        }\n        mp.clear();\n        for(int i = nums.size() - 1; i >= 0; i--){\n            if(mp.count(nums[i])){\n                res[i] = min(res[i], mp[nums[i]] - i);\n            }\n            mp[nums[i]] = i;\n        }\n        mp.clear();\n        for(int i = nums.size() - 1; i >= 0; i--){\n            if(mp.count(nums[i])){\n                res[i] = min(res[i], (int)nums.size() - mp[nums[i]] + i);\n            }else{\n                mp[nums[i]] = i;\n            }\n        }\n        vector <int> ans;\n        for(auto i : queries){\n            if(res[i] == 0x3f3f3f3f) ans.push_back(-1);\n            else ans.push_back(res[i]);\n        }\n        return ans;\n    }\n};","author":"dhxh","submissionId":"611230241"},[{"id":"643","similarity":0.7084870848708487,"totOverlap":192,"longestOverlap":12}]],"1493":[{"id":"1493","fileName":"611234694.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, int> st1, st2, st3, st4;\n        int n = nums.size();\n        vector<int> res(n, INT_MAX);\n\n        for(int i = 0; i < n; i ++) {\n            if(st1.find(nums[i]) != st1.end())\n                res[i] = min(res[i], i - st1[nums[i]]);\n            st1[nums[i]] = i;\n            if(st3.find(nums[i]) == st3.end()) st3[nums[i]] = i;\n            else {\n                res[i] = min(res[i], n - i + st3[nums[i]]);\n            }\n        }\n\n        for(int i = n - 1; i >= 0; i --) {\n            if(st2.find(nums[i]) != st2.end())\n                res[i] = min(res[i], st2[nums[i]] - i);\n            st2[nums[i]] = i;\n            if(st4.find(nums[i]) == st4.end()) st4[nums[i]] = i;\n            else {\n                res[i] = min(res[i], n + i - st4[nums[i]]);\n            }\n        }\n        \n        for(int& i : queries) {\n            if(res[i] == INT_MAX) i = -1;\n            else i = min(n - res[i], res[i]);\n        }\n\n        return queries;\n    }\n};","author":"Christinaの✓","submissionId":"611234694"},[{"id":"456","similarity":0.75,"totOverlap":174,"longestOverlap":12}]],"1603":[{"id":"1603","fileName":"611237604.txt","sourceCode":"    class Solution {\n    public:\n        vector<int> solveQueries(vector<int>& nums, vector<int>& queries) \n        {\n            int len = nums.size();\n            for (int i = 0; i < len; i++)nums.push_back(nums[i]);\n            int n = nums.size();\n            vector<int>qian(n + 1, INT_MAX);\n            vector<int>hou(n + 1, INT_MAX);\n            unordered_map<int, int>biao;\n            for (int i = 0; i < n; i++)\n            {\n                if (biao.count(nums[i]))qian[i] = i - biao[nums[i]];\n                biao[nums[i]] = i;\n            }\n            biao.clear();\n            for (int i = n-1; i >= 0; i--)\n            {\n                if (biao.count(nums[i]))hou[i] = biao[nums[i]] - i;\n                biao[nums[i]] = i;\n            }\n            vector<int>daan;\n            for (auto i:queries)\n            {\n                int temp = min({ qian[i], hou[i] ,qian[i+len],hou[i+len]});\n                if (temp == INT_MAX||temp==len)temp = -1;\n                daan.push_back(temp);\n            }\n            return daan;\n        }\n    }; ","author":"粉色妖精小姐♪​","submissionId":"611237604"},[{"id":"1356","similarity":0.7251461988304093,"totOverlap":124,"longestOverlap":17}]],"1767":[{"id":"1767","fileName":"611242411.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<int> ans(m);\n        vector<int> dis(n, 1e9);\n        unordered_map<int, int> mp;\n        unordered_map<int, int> first;\n        for (int i = 0; i < n; i++) {\n            if (mp.find(nums[i]) == mp.end()) {\n                mp[nums[i]] = i;\n                first[nums[i]] = i;\n            } else {\n                int preIndex = mp.at(nums[i]);\n                int tempDis = i - preIndex;\n                int firstIndex = first.at(nums[i]);\n                int circleDis = n - i + firstIndex;\n                dis[firstIndex] = min(dis[firstIndex], circleDis);\n                if (tempDis < circleDis) {\n                    dis[i] = tempDis;\n                } else {\n                    dis[i] = circleDis;\n                }\n                if (tempDis < dis[preIndex]) {\n                    dis[preIndex] = tempDis;\n                }\n                mp[nums[i]] = i;\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            if (dis[queries[i]] == 1e9) {\n                ans[i] = -1;\n            } else {\n                ans[i] = dis[queries[i]];\n            }\n        }\n        return ans;\n    }\n};","author":"八达鸟","submissionId":"611242411"},[{"id":"898","similarity":0.7182320441988951,"totOverlap":130,"longestOverlap":10}]],"1952":[{"id":"1952","fileName":"611254818.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        const int n = nums.size();\n        vector<int> dpl(n, n);\n        vector<int> dpl2(n, n);\n        vector<int> dpr(n, n);\n        vector<int> dpr2(n, n);\n        map<int, int> m;\n        map<int, int> m2;\n        for(int i = 0; i < n; ++i) {\n            if(m.find(nums[i]) != m.end()) {\n                dpl[i] = m[nums[i]];\n            }\n            m[nums[i]] = i;\n            if(m2.find(nums[i]) == m2.end()) m2[nums[i]] = i;\n            else dpl2[i] = m2[nums[i]];\n        }\n        map<int, int> m1; \n        map<int, int> m3;\n        for(int i = n - 1; i >= 0; --i) {\n            if(m1.find(nums[i]) != m1.end()) {\n                dpr[i] = m1[nums[i]];\n            }\n            m1[nums[i]] = i;\n            if(m3.find(nums[i]) == m3.end()) m3[nums[i]] = i;\n            else dpr2[i] = m3[nums[i]];\n        }\n        // for(int i = 0; i < n; ++i) cout << dpl[i] << \" \";\n        // cout << endl;\n        // for(int i = 0; i < n; ++i) cout << dpr[i] << \" \";\n        // cout << endl;\n        \n        vector<int> res(queries.size(), 1e9);\n        for(int i = 0; i < queries.size(); ++i) {\n            if(dpl[queries[i]] != n) res[i] = min(res[i], queries[i] - dpl[queries[i]]);\n            if(dpl2[queries[i]] != n) res[i] = min(res[i], n - (queries[i] - dpl2[queries[i]]));\n            if(dpr[queries[i]] != n) res[i] = min(res[i], dpr[queries[i]] - queries[i]);\n            if(dpr2[queries[i]] != n) res[i] = min(res[i], n - (dpr2[queries[i]] - queries[i]));\n            if(res[i] == 1e9) res[i] = -1;\n        }\n        return res;\n\n    }\n};","author":"zyj","submissionId":"611254818"},[{"id":"1213","similarity":0.717948717948718,"totOverlap":224,"longestOverlap":10}]],"1974":[{"id":"1974","fileName":"611263829.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, int> flag;\n        int len1 = nums.size();\n        vector<int> index(len1, INT_MAX);\n        for(int i = 0; i < len1; i++){\n            if(flag.count(nums[i])){\n                index[i] = len1-i+flag[nums[i]];\n            }else{\n                flag[nums[i]] = i;\n            }            \n        }\n        flag.clear();\n        for(int i = 0; i < len1; i++){\n            if(flag.count(nums[i])){\n                index[i] = min(index[i], i-flag[nums[i]]);\n            }\n            flag[nums[i]] = i;\n        }\n        flag.clear();\n        for(int i = len1-1; i >= 0; i--){\n            if(flag.count(nums[i])){\n                index[i] = min(index[i], len1-flag[nums[i]]+i);\n            }else{\n                flag[nums[i]] = i;\n            }\n        }\n        flag.clear();\n        for(int i = len1-1; i >= 0; i--){\n            if(flag.count(nums[i])){\n                index[i] = min(index[i], flag[nums[i]]-i);\n            }else if(index[i] == INT_MAX){\n                index[i] = -1;\n            }\n            flag[nums[i]] = i;\n        }\n        vector<int> ans;\n        for(auto& q: queries){\n            ans.push_back(index[q]);\n        }\n        return ans;\n    }\n};","author":"birtiland","submissionId":"611263829"},[{"id":"290","similarity":0.7730769230769231,"totOverlap":201,"longestOverlap":34}]]},{"1214":[{"id":"1214","fileName":"1575136071.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q){\n        int n=a.size();\n        int m=q.size();\n        map<int,vector<int>> mp;\n        for(int i=0;i<n;i++){\n             mp[a[i]].push_back(i);\n        }\n        auto chk = [&](int ind)->int{\n             int x=a[q[ind]]; \n            vector<int> &tp=mp[x]; \n            if(tp.size()==1) return -1;\n            int lo=0,hi=tp.size()-1,y=-1;\n            while(lo<=hi){\n                int mid=lo+(hi-lo)/2;\n                if(tp[mid]==q[ind]){\n                    y=mid;\n                    break;\n                }\n                else if(tp[mid]<q[ind]){\n                    lo=mid+1;\n                }\n                else{\n                    hi=mid-1;\n                }\n            }\n            \n            if(y==-1) y=lo; \n            int prev=(y-1+tp.size())%tp.size();\n            int nxt=(y+1)%tp.size();\n            int dif1=abs(q[ind]-tp[prev]);\n            int dif2=abs(tp[nxt]-q[ind]);\n            return min(min(dif1,n-dif1),min(dif2,n-dif2));\n        };\n        vector<int> res;\n        for(int i=0;i<m;i++){\n             // int x = a[q[i]];\n             res.push_back(chk(i));\n        }\n        return res;\n    }\n};","author":"Sai","submissionId":"1575136071"},[]]},{"1216":[{"id":"1216","fileName":"1575136124.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> idxs;\n        for (int i=0; i<nums.size(); ++i) {\n            idxs[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for (int q : queries) {\n            if (idxs[nums[q]].size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            auto it = lower_bound(idxs[nums[q]].begin(), idxs[nums[q]].end(), q);\n            int prev = it != idxs[nums[q]].begin() ? *(it - 1) : *(idxs[nums[q]].end()-1);\n            int next = it != idxs[nums[q]].end() - 1 ? *(it + 1) : *(idxs[nums[q]].begin());\n\n            int d1Direct = abs(q-prev);\n            int d1Indirect = (n - max(q, prev)) + min(q, prev);\n            int d2Direct = abs(q-next);\n            int d2Indirect = (n - max(q, next)) + min(q, next);\n            \n            ans.push_back(min(min(d1Direct, d1Indirect), min(d2Direct, d2Indirect)));\n        }\n        return ans;\n    }\n};","author":"pp2925","submissionId":"1575136124"},[]]},{"1217":[{"id":"1217","fileName":"1575136127.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> ans;\n        int n = nums.size(), qSize = queries.size();\n        unordered_map<int, vector<int>> record;\n        unordered_map<int, int> pos;\n        for(int i = 0; i < n; i++){\n            pos[i] = record[nums[i]].size();\n            record[nums[i]].push_back(i);\n        }\n        for(int i = 0; i < qSize; i++){\n            int val = nums[queries[i]];\n            int size = record[val].size();\n            if(size == 1){\n                ans.push_back(-1);\n            }else{\n                int res = INT_MAX, p = pos[queries[i]];\n                int next = record[val][(p + 1) % size];\n                int last = record[val][(p + size - 1) % size];\n                int now = record[val][p];\n                if(next < now){\n                    res = min(res, next + n - now);\n                }else{\n                    res = min(res, next - now);\n                }\n                if(last > now){\n                    res = min(res, now + n - last);\n                }else{\n                    res = min(res, now - last);\n                }\n                ans.push_back(res);\n            }\n        }\n        return ans;\n    }\n};","author":"KJer","submissionId":"1575136127"},[]]},{"1218":[{"id":"1218","fileName":"1575136140.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        int n = a.size() , m = q.size();\n        vector<int> ans(m,-1);\n        map<int,vector<int>>mp;\n        for(int i=0;i<n;i++) mp[a[i]].push_back(i);\n        int cnt = 0;\n        for(auto i : q){\n            int e = a[i];\n            if(mp[e].size() == 1) {\n                cnt++;\n                continue;\n            }\n            \n            auto up = upper_bound(mp[e].begin(),mp[e].end(),i);\n            auto lp = lower_bound(mp[e].begin(),mp[e].end(),i);\n            int r = -1,l = -1;\n            if(up != mp[e].end()) r = *up;\n            if(lp != mp[e].begin()){\n                lp--;\n                l = *lp;\n            }\n            // cout<<\"up \"<<r<<\" lp \"<<l<<endl;\n            int k = 1e9;\n            if(r != -1){\n                k = min(k , r - i);\n                k = min(k , i + n - r);\n            }\n            if(l != -1){\n                k = min(k , i - l);\n                k = min(k , l + n - i);\n            }\n            if(i != mp[e].back()){\n                k = min(k , i + n - mp[e].back());\n            }\n            if(mp[e][0] != i){\n                k = min(k , n - i + mp[e][0]);\n            }\n            if(k != 1e9) ans[cnt] = k;\n            cnt++;\n        }\n        return ans;\n    }\n};","author":"Gaurav Kumar Jangam","submissionId":"1575136140"},[]]},{"1219":[{"id":"1219","fileName":"1575136153.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int maxElement = Arrays.stream(nums).max().getAsInt();\n        \n        int[] leftNearest = new int[nums.length];\n        Arrays.fill(leftNearest, -1);\n        int[] left = new int[maxElement + 1];\n        Arrays.fill(left, -1);\n        \n        int[] rightNearest = new int[nums.length];\n        Arrays.fill(rightNearest, -1);\n        int[] right = new int[maxElement + 1];\n        Arrays.fill(right, -1);\n\n        int[] lastIndex = new int[maxElement + 1];\n        Arrays.fill(lastIndex, -1);\n        int[] firstIndex = new int[maxElement + 1];\n        Arrays.fill(firstIndex, -1);\n        \n        for(int i = 0; i < nums.length; ++i) {\n            if(firstIndex[nums[i]] == -1) \n                firstIndex[nums[i]] = i;\n\n            leftNearest[i] = left[nums[i]]; \n            left[nums[i]] = i;\n        }\n\n        for(int i = nums.length - 1; i >= 0; --i) {\n            if(lastIndex[nums[i]] == -1) \n                lastIndex[nums[i]] = i;\n\n            rightNearest[i] = right[nums[i]];\n            right[nums[i]] = i;\n        }\n\n        List<Integer> answer = new ArrayList<>();\n        for(int index : queries) {\n            int L = leftNearest[index] != -1 ? index - leftNearest[index]\n                : nums.length - lastIndex[nums[index]] + index;\n         \n            int R = rightNearest[index] != - 1 ? rightNearest[index] - index\n                : nums.length - index + firstIndex[nums[index]];\n         \n            int result = Math.min(L, R);\n            result = result < nums.length ? result : -1;\n            answer.add(result);\n        }\n        return answer;\n    }\n}","author":"haiminh042003","submissionId":"1575136153"},[]]},{"1220":[{"id":"1220","fileName":"1575136151.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n      n = len(nums)\n      idx_map = collections.defaultdict(list)\n      for i, num in enumerate(nums):\n        idx_map[num].append(i)\n\n      def find_dist(val, arr):\n        if len(arr) <= 1:\n          return -1\n        idx = bisect.bisect_left(arr, val)\n        # print(idx, val, arr)\n        if idx == 0:\n          return min(arr[idx+1] - arr[idx], arr[idx] + n - arr[-1])\n        elif idx == len(arr) - 1:\n          return min(arr[idx] - arr[idx-1], arr[0] + n - arr[-1])\n        else:\n          return min(arr[idx] - arr[idx-1], arr[idx+1] - arr[idx])\n\n      ans = []\n      for q in queries:\n        val = nums[q]\n        # print(val, idx_map)\n        ans.append(find_dist(q, idx_map[val]))\n      return ans","author":"hakuna_matata7","submissionId":"1575136151"},[]]},{"1222":[{"id":"1222","fileName":"1575136201.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), q = queries.size();\n        vector<int> prev(n,-1),next(n,-1), ans(q,1e9);\n        map<int,int> pmp,nmp;\n        for(int i=0; i<n; i++){\n            if(pmp.count(nums[i])) prev[i] = pmp[nums[i]];\n            pmp[nums[i]] = i;\n        }\n        for(int i=0; i<n; i++){\n            if(pmp.count(nums[i])) prev[i] = pmp[nums[i]];\n            pmp[nums[i]] = i;\n        }\n        for(int i=n-1; i>=0; i--){\n            if(nmp.count(nums[i])) next[i] = nmp[nums[i]];\n            nmp[nums[i]] = i;\n        }\n        for(int i=n-1; i>=0; i--){\n            if(nmp.count(nums[i])) next[i] = nmp[nums[i]];\n            nmp[nums[i]] = i;\n        }\n        int i = 0;\n        for(int q:queries){\n            if(next[q] != q) ans[i] = (next[q]-q+n)%n;\n            if(prev[q] != q) ans[i] = min(ans[i],(q-prev[q]+n)%n);\n            if(ans[i] == 1e9) ans[i] = -1;\n            i++;\n        }\n        return ans;\n    }\n};","author":"Tushar Agarwal","submissionId":"1575136201"},[]]},{"1223":[{"id":"1223","fileName":"1575136269.txt","sourceCode":"from collections import defaultdict\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        val_to_arr = defaultdict(list)\n        for i, d in enumerate(nums):\n            val_to_arr[d].append(i)\n        n = len(nums)\n        min_dist = [0]*n\n        for _, arr in val_to_arr.items():\n            if len(arr) == 1:\n                min_dist[arr[0]] = -1\n            else:\n                m = len(arr)\n                for j in range(1, m-1):\n                    cur_ind = arr[j]\n                    prev_ind, next_ind = arr[j-1], arr[j+1]\n                    min_dist[cur_ind] = (\n                        min(cur_ind - prev_ind, next_ind - cur_ind)\n                    )\n                \n                # Handle two ends j = 0 and j = m-1\n                min_dist[arr[0]] = min(n - arr[m-1] + arr[0], arr[1] - arr[0])\n                min_dist[arr[m-1]] = min(n - arr[m-1] + arr[0], arr[m-1] - arr[m-2])\n                \n        return [min_dist[q] for q in queries]","author":"mpn","submissionId":"1575136269"},[]]},{"1225":[{"id":"1225","fileName":"1575136260.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int>v2;\n        for(int i:nums) v2.push_back(i);\n        for(int i:nums) v2.push_back(i);\n        unordered_map<int,int>m1,m2,dis1,dis2;\n        for(int i=0; i<v2.size(); ++i)\n        {   \n            if(m1.find(v2[i])!=m1.end())\n            {\n                dis1[i%nums.size()]=i-m1[v2[i]];\n            }\n            m1[v2[i]]=i;\n        }\n        for(int i=v2.size()-1; i>=0; --i)\n        {   \n            if(m2.find(v2[i])!=m2.end()) dis2[i%nums.size()]=m2[v2[i]]-i;\n            m2[v2[i]]=i;\n        }\n        vector<int>ans;\n        for(int i=0; i<queries.size(); ++i)\n        {   \n            if(m1.find(nums[queries[i]])!=m1.end()) ans.push_back(min(dis1[queries[i]],dis2[queries[i]]));\n            else ans.push_back(-1);\n            if(ans.back()>=nums.size()) ans.back()=-1;\n        }\n        return ans;\n    }\n};","author":"stfudevansh","submissionId":"1575136260"},[]]},{"227":[{"id":"227","fileName":"1575106689.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        \n        indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            indices[num].append(i)\n        \n        ans = []\n        \n        for q in queries:\n            target = nums[q]\n            pos_list = indices[target]\n        \n            if len(pos_list) == 1:\n                ans.append(-1)\n                continue\n            \n            pos = bisect.bisect_left(pos_list, q)\n           \n            next_idx = pos_list[(pos + 1) % len(pos_list)]\n            prev_idx = pos_list[(pos - 1) % len(pos_list)]\n            \n            dist_next = min(abs(q - next_idx), n - abs(q - next_idx))\n            dist_prev = min(abs(q - prev_idx), n - abs(q - prev_idx))\n            \n            ans.append(min(dist_next, dist_prev))\n        \n        return ans\n","author":"anish ramesh","submissionId":"1575106689"},[{"id":"227","similarity":0.8691588785046729,"totOverlap":93,"longestOverlap":26}]],"291":[{"id":"291","fileName":"1575110115.txt","sourceCode":"class Solution:\n    def solveQueries(self, a: List[int], q: List[int]) -> List[int]:\n        n = len(a)\n        d = defaultdict(list)\n        for i, v in enumerate(a):\n            d[v].append(i)\n        \n        for k in d:\n            d[k].sort()\n        \n        ans = []\n        for x in q:\n            v = a[x]\n            l = d[v]\n            if len(l) <= 1:\n                ans.append(-1)\n                continue\n            \n            p = bisect_left(l, x)\n            p1 = (p - 1) % len(l)\n            p2 = (p + 1) % len(l)\n            \n            c1 = l[p1]\n            c2 = l[p2]\n            \n            d1 = min(abs(x - c1), n - abs(x - c1))\n            d2 = min(abs(x - c2), n - abs(x - c2))\n            \n            ans.append(min(d1, d2))\n        \n        return ans\n","author":"Yash Singhal","submissionId":"1575110115"},[{"id":"291","similarity":0.819672131147541,"totOverlap":100,"longestOverlap":23}]],"325":[{"id":"325","fileName":"1575111627.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        pos = defaultdict(list)\n        for i, num in enumerate(nums):\n            pos[num].append(i)\n\n        res = []\n        for q in queries:\n            value = nums[q]\n            indices = pos[value]\n            if len(indices) == 1:\n                res.append(-1)\n                continue\n            p = bisect_left(indices, q)\n            pi = indices[p-1] if p > 0 else indices[-1]\n            ni = indices[(p+1)%len(indices)]\n            d1 = min(abs(q-pi), n-abs(q-pi))\n            d2 = min(abs(q-ni), n-abs(q-ni))\n            res.append(min(d1, d2))\n        return res","author":"Yilun Wu","submissionId":"1575111627"},[{"id":"1092","similarity":0.8703703703703703,"totOverlap":94,"longestOverlap":25},{"id":"325","similarity":0.8691588785046729,"totOverlap":93,"longestOverlap":26},{"id":"325","similarity":0.7927927927927928,"totOverlap":88,"longestOverlap":18}]],"840":[{"id":"840","fileName":"1575126666.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        v = defaultdict(list)\n        for idx, num in enumerate(nums):\n            v[num].append(idx)\n        \n        result = []\n        for q in queries:\n            i = q\n            ve = nums[i]\n            indices = v[ve]\n            if len(indices) == 1:\n                result.append(-1)\n                continue\n            \n            pos = bisect_left(indices, i)\n            m = len(indices)\n            prev_pos = (pos - 1) % m\n            next_pos = (pos + 1) % m\n            prev_j = indices[prev_pos]\n            next_j = indices[next_pos]\n            \n            distance_prev = min(abs(i - prev_j), n - abs(i - prev_j))\n            distance_next = min(abs(i - next_j), n - abs(i - next_j))\n            result.append(min(distance_prev, distance_next))\n        \n        return result        ","author":"R velavan","submissionId":"1575126666"},[{"id":"840","similarity":0.8512396694214877,"totOverlap":103,"longestOverlap":26}]],"1092":[{"id":"1092","fileName":"1575132967.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        positions_by_num = defaultdict(list)\n        for i, num in enumerate(nums):\n            positions_by_num[num].append(i)\n            \n        results = []\n        for query in queries:\n            num = nums[query]\n            positions = positions_by_num[num]\n            if len(positions) == 1:\n                results.append(-1)\n                continue\n            \n            pos = bisect.bisect_left(positions, query)\n            prev_pos = positions[pos - 1] if pos > 0 else positions[-1]\n            next_pos = positions[(pos + 1) % len(positions)]\n            \n            distance_prev = min(abs(query - prev_pos), n - abs(query - prev_pos))\n            distance_next = min(abs(next_pos - query), n - abs(next_pos - query))\n            results.append(min(distance_prev, distance_next))\n            \n        return results\n","author":"akshita_mb","submissionId":"1575132967"},[{"id":"325","similarity":0.8703703703703703,"totOverlap":94,"longestOverlap":25}]],"1226":[{"id":"1226","fileName":"1575136311.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        value_to_indices = defaultdict(list)\n        for idx, num in enumerate(nums):\n            value_to_indices[num].append(idx)\n        \n        for num in value_to_indices:\n            value_to_indices[num].sort()\n        \n        n = len(nums)\n        answer = []\n        \n        for q in queries:\n            v = nums[q]\n            indices = value_to_indices[v]\n            if len(indices) == 1:\n                answer.append(-1)\n                continue\n            \n            pos = bisect.bisect_left(indices, q)\n            m = len(indices)\n            \n            prev_pos = (pos - 1) % m\n            next_pos = (pos + 1) % m\n            \n            prev_idx = indices[prev_pos]\n            next_idx = indices[next_pos]\n            \n            distance_prev = min(abs(q - prev_idx), n - abs(q - prev_idx))\n            distance_next = min(abs(q - next_idx), n - abs(q - next_idx))\n            \n            answer.append(min(distance_prev, distance_next))\n        \n        return answer\n    \n","author":"Sravanam Charan","submissionId":"1575136311"},[{"id":"1599","similarity":0.8721804511278195,"totOverlap":116,"longestOverlap":15},{"id":"1602","similarity":0.8217054263565892,"totOverlap":106,"longestOverlap":26},{"id":"1602","similarity":0.8512396694214877,"totOverlap":103,"longestOverlap":26},{"id":"1602","similarity":0.819672131147541,"totOverlap":100,"longestOverlap":23},{"id":"1953","similarity":0.7307692307692307,"totOverlap":95,"longestOverlap":18},{"id":"840","similarity":0.7927927927927928,"totOverlap":88,"longestOverlap":18},{"id":"1939","similarity":0.7142857142857143,"totOverlap":85,"longestOverlap":15},{"id":"1927","similarity":0.7075471698113207,"totOverlap":75,"longestOverlap":26}]],"1434":[{"id":"1434","fileName":"611233099.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        value_indices = defaultdict(list)\n        n = len(nums)\n        for idx, num in enumerate(nums):\n            value_indices[num].append(idx)\n        \n        for num in value_indices:\n            value_indices[num].sort()\n        \n        answer = []\n        for pos in queries:\n            v = nums[pos]\n            indices = value_indices[v]\n            if len(indices) <= 1:\n                answer.append(-1)\n                continue\n            \n            k = bisect.bisect_left(indices, pos)\n            m = len(indices)\n            pre_idx = (k - 1) % m\n            post_idx = (k + 1) % m\n            pre = indices[pre_idx]\n            post = indices[post_idx]\n            \n            d_pre = min(abs(pre - pos), n - abs(pre - pos))\n            d_post = min(abs(post - pos), n - abs(post - pos))\n            min_dist = min(d_pre, d_post)\n            answer.append(min_dist)\n        \n        return answer","author":"SwissRoll","submissionId":"611233099"},[{"id":"1602","similarity":0.896,"totOverlap":112,"longestOverlap":31},{"id":"1226","similarity":0.8217054263565892,"totOverlap":106,"longestOverlap":26}]],"1599":[{"id":"1599","fileName":"611237510.txt","sourceCode":"import bisect\nfrom collections import defaultdict\nclass Solution:\n\n    \n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        num_dict = defaultdict(list)\n        for idx, num in enumerate(nums):\n            num_dict[num].append(idx)\n        \n        # 对每个数值的下标列表进行排序\n        for num in num_dict:\n            num_dict[num].sort()\n        \n        n = len(nums)\n        result = []\n        for idx in queries:\n            v = nums[idx]\n            lst = num_dict[v]\n            if len(lst) == 1:\n                result.append(-1)\n                continue\n            \n            # 找到当前下标在列表中的位置\n            pos = bisect.bisect_left(lst, idx)\n            m = len(lst)\n            prev_pos = (pos - 1) % m\n            next_pos = (pos + 1) % m\n            \n            s_prev = lst[prev_pos]\n            s_next = lst[next_pos]\n            \n            # 计算两个方向的距离并取最小值\n            d_prev = min(abs(idx - s_prev), n - abs(idx - s_prev))\n            d_next = min(abs(idx - s_next), n - abs(idx - s_next))\n            \n            result.append(min(d_prev, d_next))\n        \n        return result","author":"Lucky7","submissionId":"611237510"},[{"id":"1226","similarity":0.8721804511278195,"totOverlap":116,"longestOverlap":15}]],"1602":[{"id":"1602","fileName":"611237740.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        pos = defaultdict(list)\n        for idx, num in enumerate(nums):\n            pos[num].append(idx)\n        for num in pos:\n            pos[num].sort()\n        \n        ans = []\n        for q in queries:\n            x = nums[q]\n            lst = pos[x]\n            if len(lst) == 1:\n                ans.append(-1)\n                continue\n            idx = bisect.bisect_left(lst, q)\n            assert lst[idx] == q\n            size = len(lst)\n            prev_idx = (idx - 1) % size\n            next_idx = (idx + 1) % size\n            p1 = lst[prev_idx]\n            p2 = lst[next_idx]\n            d1 = min(abs(p1 - q), n - abs(p1 - q))\n            d2 = min(abs(p2 - q), n - abs(p2 - q))\n            ans.append(min(d1, d2))\n        return ans","author":"心，月","submissionId":"611237740"},[{"id":"1434","similarity":0.896,"totOverlap":112,"longestOverlap":31}]],"1927":[{"id":"1927","fileName":"611253931.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n=len(nums)\n        pos=defaultdict(list)\n        for i,x in enumerate(nums):\n            pos[x].append(i)\n        res=[]\n        for q in queries:\n            vq=nums[q]\n            row=pos[vq]\n            if len(row)==1:\n                res.append(-1)\n                continue\n            idx=bisect_left(row,q)\n            if idx==0:\n                l=row[-1]\n            else:\n                l=row[idx-1]\n            if idx==len(row)-1:\n                r=row[0]\n            else:\n                r=row[idx+1]\n            ans=min(abs(q-l),n-abs(q-l),abs(q-r),n-abs(q-r))\n            res.append(ans)\n        return res","author":"凉薄一夏","submissionId":"611253931"},[{"id":"325","similarity":0.7075471698113207,"totOverlap":75,"longestOverlap":26}]],"1939":[{"id":"1939","fileName":"611255459.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        cnt=collections.defaultdict(list)\n        n=len(nums)\n        for i,x in enumerate(nums):\n            cnt[x].append(i)\n        ans=[]\n        for j in queries:\n            x=nums[j]\n            if len(cnt[x])==1:\n                ans.append(-1)\n                continue\n            i=bisect.bisect_left(cnt[x],j)\n            k=len(cnt[x])\n            l=(i-1)%k\n            r=(i+1)%k\n            l_idx=cnt[x][l]\n            r_idx=cnt[x][r]\n            l_i=min(abs(j-l_idx),n-abs(j-l_idx))\n            r_i=min(abs(j-r_idx),n-abs(j-r_idx))\n            ans.append(min(l_i,r_i))\n        return ans","author":"绫小路","submissionId":"611255459"},[{"id":"840","similarity":0.7142857142857143,"totOverlap":85,"longestOverlap":15}]],"1953":[{"id":"1953","fileName":"611256538.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        pos_dict = defaultdict(list)\n        for idx, num in enumerate(nums):\n            pos_dict[num].append(idx)\n        for key in pos_dict:\n            pos_dict[key].sort()\n\n        ans = []\n        n = len(nums)\n        for q in queries:\n            v = nums[q]\n            positions = pos_dict[v]\n            if len(positions) <= 1:\n                ans.append(-1)\n                continue\n            k = bisect_left(positions, q)\n            m = len(positions)\n            prev_k = (k - 1) % m\n            p_prev = positions[prev_k]\n            next_k = (k + 1) % m\n            p_next = positions[next_k]\n            d_prev = min(abs(p_prev - q), n - abs(p_prev - q))\n            d_next = min(abs(p_next - q), n - abs(p_next - q))\n            ans.append(min(d_prev, d_next))\n\n        return ans","author":"ning1ing","submissionId":"611256538"},[{"id":"1226","similarity":0.7307692307692307,"totOverlap":95,"longestOverlap":18}]]},{"1227":[{"id":"1227","fileName":"1575136178.txt","sourceCode":"#define SIZE 1000000\n#define MIN(x,y) ((x)<(y)?(x):(y))\n\nclass Solution {\n    int pos[SIZE+1];\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        \n        int n = nums.size();\n        vector<int> tmp(n, SIZE);\n        \n        memset(pos, -1, sizeof(pos));\n        \n        for(int i=0;i<2*n;i++)\n        {\n            int x = nums[i%n];\n            if(pos[x] >= 0)\n                tmp[i%n] = MIN(tmp[i%n], i-pos[x]);\n            pos[x] = i;\n        }\n        \n        memset(pos, -1, sizeof(pos));\n        \n        for(int i=2*n-1;i>=0;i--)\n        {\n            int x = nums[i%n];\n            if(pos[x] >= 0)\n                tmp[i%n] = MIN(tmp[i%n], pos[x] - i);\n            pos[x] = i;\n        }\n        \n        int m = queries.size();\n        vector<int> result(m, -1);\n        \n        for(int i=0;i<m;i++)\n        {\n            int idx = queries[i];\n            if(idx < n)\n            {\n                if(tmp[idx] >= n)\n                    result[i] = -1;\n                else\n                    result[i] = tmp[idx];\n            }\n        }\n        \n        return result;\n    }\n};","author":"Yuvansh Agrawal","submissionId":"1575136178"},[]]},{"1228":[{"id":"1228","fileName":"1575136335.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> val_idxs;\n        for(int i = 0; i < nums.size(); ++i) {\n            val_idxs[nums[i]].push_back(i);\n        }\n\n        int n = nums.size();\n        vector<int> ans;\n        ans.reserve(queries.size());\n        for(int q : queries) {\n            const vector<int>& idxs = val_idxs[nums[q]];\n            if(idxs.size() == 1) {\n                ans.push_back(-1);\n            }\n            else {\n                auto it = lower_bound(idxs.begin(), idxs.end(), q);\n\n                int d1 = (++it) == idxs.end() ? n - q + idxs.front() : *it - q;\n                --it;\n                int d2 = it == idxs.begin() ? n - idxs.back() + q : q - *(--it);\n                ans.push_back(min(d1, d2));\n            }\n        }\n        return ans;\n    }\n};","author":"Sam Lee","submissionId":"1575136335"},[]]},{"1229":[{"id":"1229","fileName":"1575136322.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        unordered_map<int,vector<int>>m;\n        int n=nums.size();\n        for(int i=0;i<n;i++)m[nums[i]].push_back(i);\n        int k=q.size();\n        vector<int>ans(k,-1);\n        for(int i=0;i<k;i++){\n            int g=m[nums[q[i]]].size();\n            if(m[nums[q[i]]].size()==1){\n                continue;\n            }\n            int index=lower_bound(m[nums[q[i]]].begin(),m[nums[q[i]]].end(),q[i])-m[nums[q[i]]].begin();\n            int a=n;\n            if(index!=0){\n                int b=abs(m[nums[q[i]]][index-1]-q[i]);\n                a=min(a,b);\n            }else{\n                int b=abs(n-m[nums[q[i]]][g-1]+q[i]);\n                // cout<<b;\n                a=min(a,b);\n            }\n            if(index!=g-1){\n                int b=abs(m[nums[q[i]]][index+1]-q[i]);\n                a=min(a,b);\n            }else{\n                int b=abs(n+m[nums[q[i]]][0]-q[i]);\n                // cout<<q[i];\n                // cout<<i;\n                a=min(a,b);\n            }\n            ans[i]=a;\n        }\n        return ans;\n    }\n};","author":"aditya kumar","submissionId":"1575136322"},[]]},{"1231":[{"id":"1231","fileName":"1575136371.txt","sourceCode":"class Solution {\npublic:\n    int bs(vector<int> &arr,int val){\n        int ans = -1;\n        int low = 0;\n        int high = arr.size() - 1;\n        while(low <= high){\n            int mid = (low+high)/2;\n            if(arr[mid] == val){\n                ans = mid;\n                break;\n            }\n            else if(arr[mid] > val){\n                high = mid - 1;\n            }\n            else{\n                low = mid + 1;\n            }\n        }\n        return ans;\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>> m;\n        int n = nums.size();\n        for(int i=0;i<n;i++){\n            m[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(auto i:queries){\n            int si = m[nums[i]].size();\n            // cout<<i<<\" \"<<si<<endl;;\n            if(si == 1){\n                ans.push_back(-1);\n            }\n            else{\n                int ind = bs(m[nums[i]],i);\n                int right = -1;\n                int left = -1;\n                // cout<<i<<\" \"<<ind<<\" \"<<si<<endl;\n                if(ind == 0){\n                    right = m[nums[i]][ind+1]-m[nums[i]][ind];\n                    left = (n-m[nums[i]][si-1])+(m[nums[i]][ind]);\n                }\n                else if(ind == si-1){\n                    right = (m[nums[i]][0]) + (n-m[nums[i]][ind]);\n                    left = m[nums[i]][ind] - m[nums[i]][ind-1]; \n                }\n                else{\n                    right = m[nums[i]][ind+1] - m[nums[i]][ind]; \n                    left = m[nums[i]][ind] - m[nums[i]][ind-1];\n                }\n                // cout<<i<<\" \"<<right<<\" \"<<left<<endl;\n                ans.push_back(min(right,left));\n            }\n        }\n        return ans;\n    }\n};","author":"yogesh_j_9296","submissionId":"1575136371"},[]]},{"1234":[{"id":"1234","fileName":"1575136480.txt","sourceCode":"#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define uint unsigned long long\n#define pb push_back\n#define py cout<<\"Yesn\"\n#define pn cout<<\"Non\"\n#define PYES cout<<\"YESn\"\n#define PNO cout<<\"NOn\"\n#define f(i,a,b) for(int i=a;i<b;i++)\n#define fe(i,a,b) for(int i=a;i<=b;i++)\n#define ff(i,a,b) for(int i=b-1;i>=a;i--)\n#define all(c) (c).begin(),(c).end()\n#define present(c,x) ((c).find(x) != (c).end())\n#define sz(a) int((a).size())\n#define X first\n#define Y second\n#define nn endl\n#define FAST_IO ios::sync_with_stdio(false); cin.tie(0);cout.tie(0);\n#define V vector\n#define ss string\n#define pd(x) cout<<fixed<<setprecision(10)<<x;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pair<ll,ll>> vpl;\n\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& v, vector<int>& q) {\n        vi ans(sz(q),-1);\n            map<int,int> t;\n            map<pair<int,int>,int> mp,xp;\n            f(i,0,sz(v))\n            {\n                    t[v[i]]++;\n                    ll c = t[v[i]];\n                    mp[{v[i],i}]=c;\n                    xp[{v[i],c}]=i;\n            }\n            int n = sz(v);\n            f(i,0,sz(q))\n            {\n                    ll ele = v[q[i]];\n                    if(t[ele]==1) continue;\n                    if(t[ele]==2)\n                    {\n                            ans[i]=min(xp[{ele,2}]-xp[{ele,1}],n+xp[{ele,1}]-xp[{ele,2}]);\n                            continue;\n                    }\n                    ll fin = t[ele];\n                    if(mp[{ele,q[i]}]==1)\n                    {\n                            // cout<<\"here\";\n                            ans[i]=min(xp[{ele,2}]-xp[{ele,1}],n+xp[{ele,1}]-xp[{ele,fin}]);\n                            continue;\n                    }\n                    if(mp[{ele,q[i]}]==fin)\n                    {\n                            ans[i]=min(xp[{ele,fin}]-xp[{ele,fin-1}],n+xp[{ele,1}]-xp[{ele,fin}]);\n                            continue;\n                    }\n                    ll here = mp[{ele,q[i]}];\n                    ans[i]=min(xp[{ele,here}]-xp[{ele,here-1}],xp[{ele,here+1}]-xp[{ele,here}]);\n            }\n            return ans;\n    }\n};","author":"okokwebweb","submissionId":"1575136480"},[]]},{"1235":[{"id":"1235","fileName":"1575136665.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int , vector<int>> ump ;\n        vector<int> v1 ;\n\n        for(int i = 0 ; i < nums.size() ; i++){\n            ump[nums[i]].push_back(i);\n        }\n\n        for(int i = 0 ; i < queries.size() ; i++)\n        {\n            if(ump[nums[queries[i]]].size() == 1){\n                v1.push_back(-1);\n            }\n            else{\n                int p = nums[queries[i]];\n                int ans = INT_MAX;\n                int y = lower_bound(ump[p].begin() , ump[p].end() , queries[i])-ump[p].begin();\n                if(y+1 < ump[p].size()){\n                    ans = ump[p][y+1] - queries[i]; \n                }\n                else{\n                    ans = nums.size() - queries[i] + ump[p][0];\n                }\n\n                if(y-1 >= 0){\n                    ans = min(ans , queries[i]-ump[p][y-1]);\n                }\n                else{\n                    int k = ump[p].size();\n                    int g = (ump[p][0] + (nums.size() - ump[p][k-1]));\n                    ans = min(ans , g);\n                }\n\n                v1.push_back(ans);\n            }\n        }\n\n        return v1 ;\n    }\n};","author":"progressor","submissionId":"1575136665"},[]]},{"1236":[{"id":"1236","fileName":"1575136536.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        \"\"\"\n        1 -> 0, 2, 4\n        \"\"\"\n        n = len(nums)\n        positions = defaultdict(list)\n        \n        for i, num in enumerate(nums):\n            positions[num].append(i)\n\n        distances = []\n        for query in queries:\n            value = nums[query]\n            if len(positions[value]) == 1:\n                distances.append(-1)\n            else:\n                low = 0\n                high = len(positions[value])-1\n                \n                while low < high:\n                    mid = (low + high)//2\n                    if query > positions[value][mid]:\n                        low = mid + 1\n                    else:\n                        high = mid\n\n                if low == 0:\n                    distance = min(positions[value][low + 1] - positions[value][low], n - positions[value][-1] + positions[value][low])    \n                elif low == len(positions[value])-1:\n                    distance = min(n - positions[value][low] + positions[value][0], positions[value][low] - positions[value][low-1])\n                else:\n                    distance = min(positions[value][low] - positions[value][low-1], positions[value][low+1] - positions[value][low])\n\n                distances.append(distance)\n\n        return distances","author":"FabianColque","submissionId":"1575136536"},[]]},{"1237":[{"id":"1237","fileName":"1575136610.txt","sourceCode":"class Solution {\npublic:\n    int help(int i1,int i2,int n){\n        if(i1>i2)swap(i1,i2);\n        int op1=i2-i1;\n        int op2=(n-i2)+i1;\n        return min(op1,op2);\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>&q) {\n        int n=nums.size();\n        int maxi=*max_element(nums.begin(),nums.end());\n        vector<vector<int>>index(maxi+1);\n        for(int i=0;i<n;i++){\n            index[nums[i]].push_back(i);\n        }\n        int sz=q.size();\n        vector<vector<pair<int,int>>>v(maxi+1);\n        \n        for(int i=0;i<sz;i++){\n            v[nums[q[i]]].push_back({q[i],i});\n        }\n        for(auto&it:v)sort(it.begin(),it.end());\n        vector<int>ans(sz);\n        for(int i=1;i<=maxi;i++){\n            if(v[i].empty())continue;\n            int idx=0, ptr=0;\n            int ln=index[i].size();\n            while(ptr<v[i].size()){\n                while(index[i][idx]<v[i][ptr].first)idx++;\n                int curr=INT_MAX;\n                int left=((idx-1)%ln+ln)%ln, right = ((idx+1)%ln+ln)%ln;\n                if(left!=idx)curr=help(index[i][idx],index[i][left],n);\n                if(right!=idx)curr=min(curr,help(index[i][idx],index[i][right],n));\n                if(curr==INT_MAX)curr=-1;\n                ans[v[i][ptr].second]=curr;\n                ptr++;\n            }\n        }\n        return ans;\n    }\n};","author":"prashant_kashyap9759","submissionId":"1575136610"},[]]},{"1238":[{"id":"1238","fileName":"1575136674.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d=defaultdict(list)\n\n        n=len(nums)\n\n        for i in range(n):\n            d[nums[i]].append(i)\n\n        m=len(queries)\n\n        res=[-1]*m \n\n        for i in range(m):\n            v=nums[queries[i]]\n            ix=queries[i]\n            if len(d[v])>1:\n                x=len(d[v])\n\n                p=bisect.bisect(d[v],ix)\n                p-=1\n   \n                l=d[v][(p-1)%x]\n                r=d[v][(p+1)%x]\n  \n                if l>ix:\n                    res[i]=min(n-l+ix,r-ix)\n                elif r<ix:\n                    res[i]=min(n-ix+r,ix-l)\n                else:\n                    res[i]=min(ix-l,r-ix)\n                    \n\n        return res","author":"Baladithya vaka","submissionId":"1575136674"},[]]},{"1239":[{"id":"1239","fileName":"1575136800.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n1=nums.size();\n        int n2=queries.size();\n        map<int,vector<int>> m;\n        for(int i=0;i<n1;i++){\n            m[nums[i]].push_back(i);\n        }\n        vector<int> v(n1);\n        for(auto& it:m){\n            int num=it.first;\n            vector<int> &vec=it.second;\n            if(vec.size()==1) v[vec[0]]=-1;\n            else{\n                v[vec[0]]=min(vec[1]-vec[0],n1-vec.back()+vec[0]);\n                for(int i=1;i<vec.size()-1;i++){\n                    v[vec[i]]=min(vec[i]-vec[i-1],vec[i+1]-vec[i]);\n                }\n                v[vec[vec.size()-1]]=min(vec[vec.size()-1]-vec[vec.size()-2],n1-vec.back()+vec[0]);\n            }\n        }\n        vector<int> ans(n2);\n        for(int i=0;i<n2;i++){\n            ans[i]=v[queries[i]];\n        }\n        return ans;\n    }\n};","author":"Devansh Singh","submissionId":"1575136800"},[{"id":"1413","similarity":0.7109004739336493,"totOverlap":150,"longestOverlap":22}]],"1413":[{"id":"1413","fileName":"611232509.txt","sourceCode":"class Solution {\npublic:\n    #define x first\n    #define y second\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for(int i = 0; i < nums.size(); i++) mp[nums[i]].push_back(i);\n        unordered_map<int, int> ans;\n        for(auto o : mp){\n            auto vt = o.y;\n            // cout << o.x << \" \" << vt.size() << 'n';\n            if(vt.size() == 1) ans[vt[0]] = -1;\n            else{\n                for(int i = 1; i < vt.size() - 1; i++){\n                    ans[vt[i]] = min(vt[i] - vt[i - 1], vt[i + 1] - vt[i]);\n                }\n                ans[vt[0]] = min(vt[1] - vt[0], (n - vt.back() + vt[0]));\n                ans[vt.back()] = min(vt[vt.size() - 1] - vt[vt.size() - 2], (n - vt.back() + vt[0]));\n            }\n        }\n        vector<int> res;\n        for(int i = 0; i < queries.size(); i++) res.push_back(ans[queries[i]]);\n        return res;\n    }\n};","author":"ppaker","submissionId":"611232509"},[{"id":"1239","similarity":0.7109004739336493,"totOverlap":150,"longestOverlap":22}]]},{"1240":[{"id":"1240","fileName":"1575136676.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        \n        d = defaultdict(list)\n        for i, x in enumerate(nums):\n            d[x].append(i)\n        n = len(nums)\n\n        def bs(x, arr):\n            l, r = 0, len(arr)-1\n            while l<r:\n                m = (l+r)//2\n                if arr[m]==x:\n                    return m\n                elif arr[m]<x:\n                    l = m+1\n                else:\n                    r = m-1\n            return l\n        \n        res = []\n        for q in queries:\n            x = nums[q]\n            y = d[x]\n            #find min cicular dist\n            if len(y) == 1:\n                res.append(-1)\n            else:\n                pos = bs(q, y)\n                #print(y)\n                #print(y[pos],y[(pos-1)+(len(y))%len(y)],y[(pos+1)%(len(y))])\n                #look right\n                r = y[(pos+1)%(len(y))]\n                r = min(abs(r-q),n-abs(r-q))\n                #look left\n                l = y[(pos-1)+(len(y))%len(y)]\n                l = min(abs(l-q),n-abs(l-q))\n                \n                res.append(min(l,r))\n        return res\n        ","author":"Kumar Saurabh","submissionId":"1575136676"},[]]},{"1242":[{"id":"1242","fileName":"1575136803.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        # Pre-compute minimum distances for each index\n        min_distances = {}\n        \n        # Group indices by their values\n        value_indices = {}\n        for i, num in enumerate(nums):\n            if num not in value_indices:\n                value_indices[num] = []\n            value_indices[num].append(i)\n        \n        # Pre-compute minimum distance for each index\n        for value, indices in value_indices.items():\n            if len(indices) == 1:\n                # If this value appears only once, set distance to -1\n                min_distances[indices[0]] = -1\n            else:\n                # For each index with this value\n                for i, idx in enumerate(indices):\n                    # Find closest index with same value\n                    if len(indices) == 2:\n                        # Only one other index with same value\n                        other_idx = indices[1-i]\n                        clockwise = abs(other_idx - idx)\n                        counter_clockwise = n - clockwise\n                        min_distances[idx] = min(clockwise, counter_clockwise)\n                    else:\n                        # Multiple other indices with same value\n                        # Get previous and next indices in the sorted list\n                        prev_idx = indices[i-1] if i > 0 else indices[-1]\n                        next_idx = indices[(i+1) % len(indices)]\n                        \n                        # Calculate minimum distance\n                        clockwise_prev = (idx - prev_idx) % n\n                        clockwise_next = (next_idx - idx) % n\n                        min_distances[idx] = min(clockwise_prev, clockwise_next)\n        \n        # Process queries using pre-computed distances\n        return [min_distances[query] for query in queries]","author":"Sean4843","submissionId":"1575136803"},[]]},{"1243":[{"id":"1243","fileName":"1575136858.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>>mp;\n        int n = nums.size();\n        vector<int>ans;\n        int m = queries.size();\n        for(int i=0 ; i<n ; i++){\n            mp[nums[i]].push_back(i);\n        }\n        for(int i=0 ; i<m ; i++){\n            int ele = nums[queries[i]];\n            if(mp[ele].size()==1)ans.push_back(-1);\n            else{\n                int lb = lower_bound(mp[ele].begin(),mp[ele].end(),queries[i])-mp[ele].begin();\n                if(lb==mp[ele].size()-1){\n                    int dis = mp[ele][0]+n-queries[i];\n                    int diss = mp[ele][lb-1]-queries[i];\n                    int min_dis = min(abs(dis),abs(diss));\n                    ans.push_back(min_dis);\n                }\n                else if(lb==0){\n                    int sz = mp[ele].size();\n                    int dis = mp[ele][lb+1]-queries[i];\n                    int diss = queries[i]+n-mp[ele][sz-1];\n                    int min_dis = min(abs(dis),abs(diss));\n                    ans.push_back(min_dis);\n                }\n                else{\n                    int dis = mp[ele][lb+1]-queries[i];\n                    int diss = mp[ele][lb-1]-queries[i];\n                    int min_dis = min(abs(dis),abs(diss));\n                    ans.push_back(min_dis);\n                }\n            }\n        }\n        return ans;\n    }\n};","author":"Chetan Sharma","submissionId":"1575136858"},[]]},{"1246":[{"id":"1246","fileName":"1575136957.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n\n        unordered_map<int,vector<int>>mp;\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int>ans(queries.size(),-1);\n\n        for(int i=0;i<queries.size();i++){\n            int val=nums[queries[i]];\n            int m=mp[val].size();\n\n            int dist1=0;\n            int dist2=0;\n\n            if(m>1){\n                // aage se dist\n                auto it=\n                upper_bound(mp[val].begin(),mp[val].end(),queries[i]);\n                if(it==mp[val].end()){\n                    dist1=n-queries[i]+mp[val][0];\n                }else{\n                    dist1=*it-queries[i];\n                }\n\n                auto it2=\n                lower_bound(mp[val].begin(),mp[val].end(),queries[i]);\n                if(it2==mp[val].begin()){\n                    dist2=queries[i]+(n-mp[val].back());\n                }else{\n                    dist2=queries[i]-*(it2-1);\n                }\n\n                ans[i]=min(dist1,dist2);\n            }\n        }\n        return ans;\n        \n    }\n};","author":"AMAN","submissionId":"1575136957"},[]]},{"1247":[{"id":"1247","fileName":"1575136880.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] q) {\n        HashMap<Integer,List<Integer>> hm = new HashMap<>();\n        int n = nums.length;\n        for(int i = 0;i < n;i++){\n            if(!hm.containsKey(nums[i])){\n                hm.put(nums[i],new ArrayList<>());\n            }\n            hm.get(nums[i]).add(i);\n        }\n        int m = q.length;\n        List<Integer> ans =new ArrayList<>();\n        for(int i = 0;i < m;i++){\n            int id = q[i];\n            int val = nums[id];\n            List<Integer> arr = hm.get(val);\n            if(arr.size() == 1){\n               ans.add(-1);\n                continue;\n            }\n            int l = 0;\n            int r = arr.size();\n            int loc = -1;\n            while(l <= r){\n                int mid = (l+r)/2;\n                if(arr.get(mid) == id){\n                    loc = mid;\n                    break;\n                }\n                else if(arr.get(mid) < id){\n                    l = mid+1;\n                }\n                else{\n                    r = mid-1;\n                }\n            }\n            int siz = arr.size();\n            int prev = (siz+loc-1)%siz;\n            int nex = (loc+1)%siz;\n            // System.out.println(prev+\" \"+nex+\" \"+val+\" \"+id);\n            int t = Math.min(Math.abs(arr.get(prev)-id),Math.abs(arr.get(nex)-id));\n            int x = Math.min(arr.get(prev),id) + n-Math.max(arr.get(prev),id);\n            int y = Math.min(arr.get(nex),id) + n-Math.max(arr.get(nex),id);\n            ans.add(Math.min(Math.min(x,y),t));\n        }\n        return ans;\n    }\n}","author":"Greeshwar R S","submissionId":"1575136880"},[]]},{"1248":[{"id":"1248","fileName":"1575136989.txt","sourceCode":"std::ostream& operator<<(std::ostream& os, const std::vector<int>& elements) {\n    for (const auto& elem : elements) {\n        os << std::setw(4) << elem;\n    }\n    return os;\n}\n\nstd::ostream& operator<<(std::ostream& os, const vector<vector<int>>& vec) {\n    for (const auto& row : vec) {\n        for (const auto& elem : row) {\n            os << std::setw(4) << elem;\n        }\n        os << std::endl;\n    }\n    return os;\n}\n\nclass Solution {\npublic:\n    int search(const vector<int>& vec, int v) {\n        int l, r, m;\n\n        l = 0; r = vec.size() - 1;\n        for (; l < r; ) {\n            m = (l + r) / 2;\n            if (vec[m] == v) {\n                return m;\n            } else if (vec[m] < v) {\n                l = m + 1;\n            } else {\n                r = m;\n            }\n        }\n\n        return l;\n    }\n\n    int circular(int x, int n) {\n        if (x < 0) {\n            return x + n;\n        } else if (x >= n) {\n            return x - n;\n        } else {\n            return x;\n        }\n    }\n\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        const int n = nums.size();\n\n        unordered_map<int, vector<int>> indices;\n        vector<int> ans; ans.reserve(queries.size());\n        int p, p1, p2;\n        int d1, d2;\n        int i;\n        \n        for (i = 0; i < n; ++i) {\n            indices[nums[i]].push_back(i);\n            // cout << nums[i] << ' ' << indices[nums[i]] << endl;\n        }\n\n        for (auto q: queries) {\n            const auto& arr = indices[nums[q]];\n\n            if (arr.size() <= 1) {\n                ans.push_back(-1);\n                continue;\n            }\n\n            // cout << arr << endl;\n            p = search(arr, q);\n            p1 = arr[circular(p - 1, arr.size())];\n            p2 = arr[circular(p + 1, arr.size())];\n            d1 = circular(q - p1, n);\n            d2 = circular(p2 - q, n);\n\n            // cout << nums[q] << ' ' << arr.size() << ' ' << p << ' ' << p1 << ' ' << p2 << endl;\n            ans.push_back(min(d1, d2));\n        }\n\n        return ans;\n    }\n};","author":"Edward Lee","submissionId":"1575136989"},[]]},{"1249":[{"id":"1249","fileName":"1575136916.txt","sourceCode":"from collections import defaultdict, Counter\nfrom bisect import bisect_left\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        # for each num value, keep track of the indices where it is located\n        n, m = len(nums), len(queries)\n        res = [0] * m\n\n        locs = defaultdict(list)\n        for i, num in enumerate(nums):\n            locs[num].append(i)\n\n        for i, query in enumerate(queries):\n            val = nums[query]\n            j = bisect_left(locs[val], query)\n            l = len(locs[val])\n\n            if l == 1:\n                res[i] = -1\n            else:\n                right = abs(locs[val][(j + 1) % l] - query)\n                left = abs(locs[val][(j - 1) % l] - query)\n                print(locs[val][(j + 1) % l], locs[val][(j - 1) % l])\n                \n                res[i] = min(right, left, n - right, n - left)\n\n        return res","author":"RAY2L","submissionId":"1575136916"},[]]},{"1250":[{"id":"1250","fileName":"1575137028.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> res = new ArrayList<>();\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\n        int n = nums.length;\n\n        \n        for (int i = 0; i < n; i++) {\n            int num = nums[i];\n            map.putIfAbsent(num, new ArrayList<>());\n            map.get(num).add(i);\n        }\n\n       \n        for (int q : queries) {\n            int num = nums[q];\n            List<Integer> list = map.get(num);\n            int k = list.size();\n            \n            if (k == 1) {\n                res.add(-1); \n                continue;\n            }\n\n          \n            int idx = Collections.binarySearch(list, q);\n            \n            int right = list.get((idx + 1) % k);\n            int left = list.get((idx - 1 + k) % k);\n\n            res.add(Math.min((q - left + n) % n, (right - q + n) % n));\n        }\n        return res;\n    }\n}\n","author":"siddarth singh","submissionId":"1575137028"},[]]},{"1251":[{"id":"1251","fileName":"1575136994.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        dp = [-1] * n\n\n        c = defaultdict(list)\n\n        for ind, num in enumerate(nums):\n            c[num].append(ind)\n\n        for ind, num in enumerate(nums):\n            if dp[ind] != -1: continue\n            if len(c[num]) > 1:\n                for j in range(0, len(c[num])):\n                    cur_ind = c[num][j]\n                    if j == 0:\n                        dp[cur_ind] = min(abs(c[num][j+1] - cur_ind), abs(cur_ind + n - c[num][-1]))\n                    elif j == len(c[num]) - 1:\n                        dp[cur_ind] = min(abs(cur_ind - c[num][j-1]), abs(c[num][0] + n - cur_ind))\n                    else:\n                        dp[cur_ind] = min(abs(cur_ind - c[num][j+1]), abs(cur_ind - c[num][j-1]))\n        ans = [-1] * len(queries)\n\n        for ind, q in enumerate(queries):\n            ans[ind] = dp[q]\n\n        return ans\n            \n\n        \n        ","author":"Tung Hoang","submissionId":"1575136994"},[]]},{"1252":[{"id":"1252","fileName":"1575137059.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        # return answer for each query, where answer is the min distance between the element at index queries[i]\n        # and any other index in the circular array where the element is the same\n        # if no such index exists, return -1\n        n = len(nums)\n        numToInd = defaultdict(list)\n        for i, x in enumerate(nums):\n            numToInd[x].append(i)\n        qToInds = defaultdict(list)\n        for i, x in enumerate(queries):\n            qToInds[x].append(i)\n\n        res = [-1] * len(queries)\n        # print(numToInd)\n\n        for num, inds in numToInd.items():\n            if len(inds) > 1:\n                for i in range(len(inds)):\n                    idx = inds[i]\n                    if idx in qToInds:\n                        qinds = qToInds[idx]\n                        left, right = float('inf'), float('inf')\n                        left = min(max(idx, inds[i-1]) - min(idx, inds[i-1]), n - max(idx, inds[i-1]) + min(idx, inds[i-1]))\n                        r1, r2 = idx, inds[(i+1) % len(inds)]\n                        if r1 > r2:\n                            r1, r2 = r2, r1\n                        right = min(r2 - r1, n - r2 + r1)\n                        # if num == 3:\n                        #     print(left, right)\n                        for qind in qinds:\n                            res[qind] = min(left, right)\n\n        return res","author":"hufflepuffpastry","submissionId":"1575137059"},[]]},{"1254":[{"id":"1254","fileName":"1575137070.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        nums_idx = collections.defaultdict(list)\n        for i in range(n):\n            nums_idx[nums[i]].append(i)\n        res = []\n        for i in queries:\n            x = nums[i]\n            idx = nums_idx[x]\n            m = len(idx)\n            if m == 1:\n                res.append(-1)\n            else:\n                p = bisect.bisect_left(idx, i)\n                nxt = (p + 1) % m\n                prv = (m + p - 1) % m\n                j1 = idx[nxt]\n                j2 = idx[prv]\n                d1 = min((n + j1 - i) % n, (n + i - j1) % n)\n                d2 = min((n + j2 - i) % n, (n + i - j2) % n)\n                res.append((min(d1, d2)))\n        return res\n        ","author":"icherkasov","submissionId":"1575137070"},[]]},{"1255":[{"id":"1255","fileName":"1575137073.txt","sourceCode":"using ip = pair<int, int>;\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, int> firstOcc;\n        unordered_map<int, int> lastPos;\n        // last nextttt\n        vector<ip> lastAndNext(n, { -1, -1 });\n        for (int i = 0; i < n; i += 1) {\n            int num = nums[i];\n            auto itr = firstOcc.find(num);\n            if (itr == firstOcc.end()) {\n                firstOcc[num] = i;\n            }\n            else {\n                // previous of first update to latest element\n                lastAndNext[itr->second].first = i;\n                lastAndNext[i].second = itr->second;\n            }\n\n            auto itr2 = lastPos.find(num);\n            if (itr2 != lastPos.end()) {\n                int lastPosition = itr2->second;\n                lastAndNext[lastPosition].second = i;\n                lastAndNext[i].first = lastPosition;\n                lastPos[num] = i;\n            }\n            else {\n                // update last to this\n                lastPos[num] = i;\n            }\n            \n        }\n        // for (int i = 0; i < n; i += 1) {\n        //     cout << lastAndNext[i].first << \" \" << lastAndNext[i].second << \" \" << endl;\n        // }\n        int q = queries.size();\n        for (int i = 0; i < q; i += 1) {\n            int index = queries[i];\n            auto [prev, next] = lastAndNext[index];\n            int answer = n + 1;\n            if (prev == -1 && next == -1) {\n                answer = -1;\n            }\n            if (prev != -1) {\n                // reach by going backwards\n                answer = min({ answer, abs(prev - index), min(prev, index) + n - max(prev, index) });\n            }\n            if (next != -1) {\n                answer = min({ answer, abs(next - index), min(next, index) + n - max(next, index) });\n            }\n            queries[i] = answer;\n        }\n        return queries;\n    }\n};","author":"Atharva","submissionId":"1575137073"},[]]},{"1256":[{"id":"1256","fileName":"1575137177.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, TreeSet<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.putIfAbsent(nums[i], new TreeSet<>());\n            map.get(nums[i]).add(i);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int i = 0; i < queries.length; i++) {\n            int index = queries[i];\n            if (index >= nums.length) {\n                ans.add(-1);\n                continue;\n            }\n\n            int value = nums[index];\n            if (map.get(value).size() < 2) {\n                ans.add(-1);\n                continue;\n            }\n\n            TreeSet<Integer> ts = map.get(value);\n            int beforeGap = 0;\n            int afterGap = 0;\n            if (ts.higher(index) == null) {\n                int after = ts.first();\n                afterGap = after + nums.length - index;\n            } else {\n                int after = ts.higher(index);\n                afterGap = after - index;\n            }\n            if (ts.lower(index) == null) {\n                int before = ts.last();\n                beforeGap = index + nums.length - before;\n            } else {\n                int before = ts.lower(index);\n                beforeGap = index - before;\n            }\n            int min = Integer.MAX_VALUE;\n            min = Math.min(beforeGap, Math.min(min, afterGap));\n            ans.add(min);\n        }\n        return ans;\n        \n    }\n}","author":"xuZxnAWFes","submissionId":"1575137177"},[]]},{"1257":[{"id":"1257","fileName":"1575137246.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer,List<Integer>> map = new HashMap<>();\n        int[] ans = new int[nums.length];\n        Arrays.fill(ans,Integer.MAX_VALUE);\n        for (int i=0 ; i<nums.length ; i++){\n            if (!map.containsKey(nums[i])){\n                List<Integer> list = new ArrayList<>();\n                list.add(i);\n                map.put(nums[i],list);\n            }\n            else{\n                List<Integer> list = map.get(nums[i]);\n                int left = list.get(list.size()-1);  \n                int right = list.get(0);\n                ans[left]=Math.min(ans[left],i-left);\n                System.out.println(ans[left]+\"  \"+left);\n                ans[right]=Math.min(ans[right],nums.length-i+right);\n                System.out.println(ans[right]+\"  \"+right);\n                ans[i]=Math.min(i-left,nums.length-i+right);\n                System.out.println(ans[i]+\"  \"+i);\n                list.add(i);\n            }\n        }\n        List<Integer> Ans = new ArrayList<>();\n        for (int i=0 ; i<queries.length ; i++){\n            if (ans[queries[i]]==Integer.MAX_VALUE){\n                Ans.add(-1);\n            }\n            else Ans.add(ans[queries[i]]);\n        }\n        return Ans;\n        \n    }\n}","author":"Strikable","submissionId":"1575137246"},[]]},{"1258":[{"id":"1258","fileName":"1575137106.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        ans = []\n        indices = {}\n        left, right = {}, {}\n        for i in range(len(nums)):\n            num = nums[i]\n            if num not in indices:\n                indices[num] = [i]\n                left[i] = -1\n                right[i] = -1\n            else:\n                right[indices[num][-1]] = i-indices[num][-1]\n                left[indices[num][0]] = len(nums)+indices[num][0]-i\n                left[i] = i-indices[num][-1]\n                right[i] = len(nums)+indices[num][0]-i\n                indices[num].append(i)\n        for query in queries:\n            if left[query] == None and right[query] == None:\n                ans.append(-1)\n            elif left[query] == None:\n                ans.append(right[query])\n            elif right[query] == None:\n                ans.append(left[query])\n            else:\n                ans.append(min(right[query], left[query]))\n        return ans","author":"Manki Min","submissionId":"1575137106"},[]]},{"1260":[{"id":"1260","fileName":"1575137212.txt","sourceCode":"map<int,int>pk;\nint fi[100001], ls[100001];\nint ans[100001];\nint lso[100001];\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n=nums.size();\n        int st=0;\n        pk.clear();memset(ls,-1,sizeof(ls));\n        memset(ans,-1,sizeof(ans));\n        \n        memset(fi,-1,sizeof(fi));\n        for(int i=0;i<n;i++) {\n            ans[i]=INT_MAX;\n            if(pk.find(nums[i])==pk.end()) pk[nums[i]]=st++;\n        }\n        \n        for(int i=0;i<n;i++) {\n            \n            int cv=pk[nums[i]];\n            lso[cv]=i;\n            if(fi[cv]==-1) fi[cv]=i;\n            if(ls[cv]!=-1) {\n                ans[i]=i-ls[cv];\n            }\n            ls[cv]=i;\n        } \n        \n        memset(ls,-1,sizeof(ls));\n        \n        for(int i=n-1;i>-1;i--) {\n            int cv=pk[nums[i]];\n            if(ls[cv]!=-1) {\n                ans[i]=min(ans[i], ls[cv]-i);\n            }\n            if((fi[cv]!=-1) && (fi[cv]!=i)) {\n                ans[i]=min(ans[i], n-i+fi[cv]);\n            }\n            \n            if(lso[cv]!=i) {\n                ans[i]=min(ans[i], n-lso[cv]+i);\n            }\n            //cout<<i<<\" \"<<lso[cv]<<\"n\";\n            \n            ls[cv]=i;\n        }\n        \n        vector<int>re;\n        for(int i: q) {\n            if(ans[i]==INT_MAX) ans[i]=-1;\n            re.push_back(ans[i]);\n        }\n        return re;\n        \n    }\n};","author":"SIDDHARTH","submissionId":"1575137212"},[]]},{"1261":[{"id":"1261","fileName":"1575137316.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        int n=a.size(),i,m=q.size();\n        vector<int> d(m,-1);\n        unordered_map<int,vector<int>> h;\n        for(i=0;i<n;i++){\n            h[a[i]].push_back(i);\n        }\n        for(i=0;i<m;i++){\n            if(h[a[q[i]]].size()>1){\n            int r=h[a[q[i]]].size();\n                int x=0,y=r-1,z,c=-1;\n                while(x<=y){\n                    z=(x+y)/2;\n                    if(h[a[q[i]]][z]<=q[i]){\n                        c=z;\n                        x=z+1;\n                    }\n                    else{\n                    y=z-1;\n                    }\n                }\n                int e=abs(q[i]-h[a[q[i]]][(r+c-1)%r]);\n                int f=abs(q[i]-h[a[q[i]]][(r+c+1)%r]);\n                d[i]=e;\n                if(e>abs(n-e)){\n                    d[i]=abs(n-e);\n                }\n                if(d[i]>f){\n                    d[i]=f;\n                }\n                if(d[i]>abs(n-f)){\n                    d[i]=abs(n-f);\n                }\n                }\n            }\n        return d;\n    }\n};","author":"praveenkumarm1","submissionId":"1575137316"},[]]},{"1262":[{"id":"1262","fileName":"1575137276.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        if not nums: return []\n        \n        mapper = collections.defaultdict(list)\n        for i, e in enumerate(nums):\n            mapper[e].append(i)\n        \n        n = len(nums)\n        # for circular array\n        def compute_dist(idx1, idx2):\n            dist1 = abs(idx2 - idx1)\n            dist2 = n - dist1\n            return min(dist1, dist2)\n            \n            \n        cache = {}  # key: index, value: shortest distance\n        for num, indices in mapper.items():\n            if not indices: continue\n            if len(indices) == 1:\n                cache[indices[0]] = -1 \n                continue\n\n            size = len(indices)\n            for i in range(len(indices)):\n                idx = indices[i]\n                left = indices[i - 1] if i >= 1 else indices[-1]\n                right = indices[i + 1] if i + 1 < size else indices[0]\n                dist = min(compute_dist(left, idx), compute_dist(right, idx))\n                assert idx not in cache, \"Must not appear\"\n                cache[idx] = dist\n            \n        return [cache[q] for q in queries]\n            \n            \n            \n                \n                ","author":"park29","submissionId":"1575137276"},[]]},{"1263":[{"id":"1263","fileName":"1575137252.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        res = [-1]*len(queries)\n        \n        D = collections.defaultdict(list)\n        for idx,n in enumerate(nums):\n            D[n].append(idx)\n        \n        for idx,q in enumerate(queries):\n            if len(D[nums[q]])<=1:\n                continue\n            A = D[nums[q]]\n            j = bisect.bisect_left(A,q)\n            curr = math.inf\n            if j==0:\n                curr = min(curr, len(nums)-A[-1]+A[j])\n            else:\n                curr = min(curr, A[j]-A[j-1])\n            if j==len(A)-1:\n                curr = min(curr, A[0]+len(nums)-A[j])\n            else:\n                curr = min(curr, A[j+1]-A[j])\n            \n            res[idx] = curr\n        \n        return res","author":"unknown","submissionId":"1575137252"},[]]},{"1264":[{"id":"1264","fileName":"1575137451.txt","sourceCode":"class Solution(object):\n    def solveQueries(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        prev = [-1]*n\n        next = [-1]*n\n        pm,nm = {},{}\n        for i in range(n):\n            x = nums[i]\n            if x in pm:\n                prev[i] = pm[x] \n            pm[x] = i\n        # print(pm)\n        for i in range(n-1,-1,-1):\n            x = nums[i]\n            if x in nm:\n                next[i] = nm[x]\n            nm[x] = i\n        # print(nm)\n        for i in range(n):\n            if prev[i]==-1:\n                prev[i] = pm[nums[i]]\n            pass\n        for i in range(n-1,-1,-1):\n            if next[i]==-1:\n                next[i] = nm[nums[i]]\n            pass\n        # print(prev)\n        # print(next)\n        ans = []\n        for i in range(len(queries)):\n            q = queries[i]\n            pos = q\n            pr = prev[pos]\n            en = next[pos]\n            # print(q,pr,en)\n            prevd = pos-pr\n            if prevd<0:\n                prevd = prevd+n\n            nextd = en-pos\n            if nextd<0:\n                nextd = nextd+n\n            # print('prevd ',prevd,'nextd',nextd)\n            d = min(prevd,nextd)\n            if d==0:\n                ans.append(-1)\n            else:\n                ans.append(d)\n        return ans\n                \n            ","author":"prudvinit","submissionId":"1575137451"},[]]},{"1266":[{"id":"1266","fileName":"1575137511.txt","sourceCode":"\n\nclass Solution {\npublic:\n\t\n\tint dis(int a, int b, int n) {\n\t\tif (a > b) swap(a, b);\n\t\treturn min(b - a, a + n - b);\n\t}\n\n\tvector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n\t\tint n = nums.size(), q = queries.size();\n\t\tmap<int, vector<int>> idx;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tidx[nums[i]].push_back(i);\n\t\t}\n\n\t\tvector<int> res(q, -1);\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint j = queries[i];\n\t\t\tauto& lsIdx = idx[nums[j]];\n\t\t\tint r = -1;\n\t\t\tif (lsIdx.size() > 1) {\n\t\t\t\tauto it1 = lower_bound(lsIdx.begin(), lsIdx.end(), j),\n\t\t\t\t\tit2 = upper_bound(lsIdx.begin(), lsIdx.end(), j);\n\t\t\t\tif (it2 != lsIdx.end()) r = *it2;\n\t\t\t\telse r = *lsIdx.begin();\n\t\t\t\tif (it1 != lsIdx.begin()) {\n\t\t\t\t\tit1--;\n\t\t\t\t\tif (dis(r, j, n) > dis(j, *it1, n)) {\n\t\t\t\t\t\tr = *it1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tit1 = lsIdx.end();\n\t\t\t\t\tit1--;\n\t\t\t\t\tif (dis(r, j, n) > dis(j, *it1, n)) {\n\t\t\t\t\t\tr = *it1;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tres[i] = dis(r, j, n);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};","author":"PHUC","submissionId":"1575137511"},[]]},{"1267":[{"id":"1267","fileName":"1575137469.txt","sourceCode":"function solveQueries(nums: number[], queries: number[]): number[] {\n    const valueMap = new Map<number, number[]>();\n    const n = nums.length;\n\n    for (let i = 0; i < n; i++) {\n        const value = nums[i];\n        if (!valueMap.has(value)) {\n            valueMap.set(value, []);\n        }\n        valueMap.get(value)!.push(i);\n    }\n\n    for (const indices of valueMap.values()) {\n        indices.sort((a, b) => a - b);\n    }\n\n    const answer: number[] = [];\n    for (const query of queries) {\n        const value = nums[query];\n        const indices = valueMap.get(value)!;\n        if (indices.length === 1) {\n            answer.push(-1);\n            continue;\n        }\n\n        let left = 0;\n        let right = indices.length - 1;\n        let k = -1;\n        while (left <= right) {\n            const mid = Math.floor((left + right) / 2);\n            if (indices[mid] === query) {\n                k = mid;\n                break;\n            } else if (indices[mid] < query) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        const candidates = new Set<number>();\n        if (k > 0) {\n            candidates.add(indices[k - 1]);\n        }\n        if (k < indices.length - 1) {\n            candidates.add(indices[k + 1]);\n        }\n        if (k !== 0) {\n            candidates.add(indices[0]);\n        }\n        if (k !== indices.length - 1) {\n            candidates.add(indices[indices.length - 1]);\n        }\n\n        let minDistance = Infinity;\n        for (const j of candidates) {\n            const distance = Math.abs(query - j);\n            const circularDistance = Math.min(distance, n - distance);\n            if (circularDistance < minDistance) {\n                minDistance = circularDistance;\n            }\n        }\n        answer.push(minDistance);\n    }\n\n    return answer;\n};","author":"Anand Kumar Jha","submissionId":"1575137469"},[]]},{"1268":[{"id":"1268","fileName":"1575137528.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for(int i=0;i<n;i++)\n            mp[nums[i]].push_back(i);\n        vector<int> func(n, 1e9);\n        for(auto& val : mp) {\n            vector<int>& arr = val.second;\n            int m = arr.size();\n            if(m == 1)\n                continue;\n            for(int j=0;j<m;j++) {\n                if(j+1 < m)\n                    func[arr[j]] = min(func[arr[j]], arr[j+1]-arr[j]);\n                if(j-1 > -1)\n                    func[arr[j]] = min(func[arr[j]], arr[j] - arr[j-1]);\n            }\n            func[arr[0]] = min(func[arr[0]], n - arr[m-1] + arr[0]);\n            func[arr[m-1]] = min(func[arr[m-1]], n - arr[m-1] + arr[0]);\n        }\n        for(auto& val : func)\n            if(val == 1e9)\n                val = -1;\n        vector<int> ans;\n        for(auto& val : queries)\n            ans.push_back(func[val]);\n        return ans;\n    }\n};","author":"Shobhit Tewari","submissionId":"1575137528"},[]]},{"1270":[{"id":"1270","fileName":"1575137612.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        idx = defaultdict(list)\n        for i, v in enumerate(nums):\n            idx[v].append(i)\n\n        n = len(nums)\n        res = []\n        for q in queries:\n            t = nums[q]\n            v = maxsize\n            i = bisect_left(idx[t], q)\n\n            if i:\n                left = idx[t][i - 1]\n                v = min(v, q - left, idx[t][0] + n - q)\n\n            if i + 1 < len(idx[t]):\n                right = idx[t][i + 1]\n                v = min(v, right - q, q + n - idx[t][-1])\n\n            res.append(-1 if v == maxsize else v)\n\n        return res","author":"Maxim Vasilic","submissionId":"1575137612"},[]]},{"1271":[{"id":"1271","fileName":"1575137702.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        adj = defaultdict(list)\n        for idx, val in enumerate(nums):\n            adj[val].append(idx)\n\n        for key in adj:\n            adj[key].sort()\n\n        ans = []\n        for q in queries:\n            val = nums[q]\n            if len(adj[val]) <= 1:\n                ans.append(-1)\n            else:\n                idx = bisect_left(adj[val], q)\n\n                prev = len(adj[val]) - 1 if idx - 1 < 0 else idx - 1\n                prev = adj[val][prev]\n                nxt = 0 if idx + 1 == len(adj[val]) else idx + 1\n                nxt = adj[val][nxt]\n                curr = q\n                res = min(abs(curr - nxt), abs(max(curr, nxt) - len(nums) - min(curr, nxt)))\n                res = min(res, abs(curr - prev))\n                res = min(res, abs(max(curr, prev) - len(nums) - min(curr, prev)))\n                ans.append(res)\n\n        return ans","author":"hathacker5","submissionId":"1575137702"},[]]},{"1272":[{"id":"1272","fileName":"1575137627.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        ans=[]\n        m=defaultdict(list)\n        for i ,j in enumerate(nums):\n            m[j]+=[i]\n        for q in queries:\n            x=nums[q]\n            ind=m[x]\n            if len(ind)==1:\n                ans.append(-1)\n                continue\n            pos=bisect.bisect_left(ind,q)\n            l,r=ind[(pos-1)%len(ind)],ind[(pos+1)%len(ind)]\n            dl,dr=min(abs(q-l),len(nums)-abs(q-l)),min(abs(q-r),len(nums)-abs(q-r))\n            ans.append(min(dl,dr))\n        return ans","author":"kenpachizaraki123","submissionId":"1575137627"},[]]},{"1273":[{"id":"1273","fileName":"1575137705.txt","sourceCode":"def binsch(arr,n):\n        l=0\n        r=len(arr)\n        while l+1<r:\n            mid=(l+r)//2\n            if arr[mid]<=n:\n                l=mid\n            else:\n                r=mid\n        return l\n\n\n\nclass Solution:\n    \n    def solveQueries(self, nums: List[int], qu: List[int]) -> List[int]:\n        n=len(nums)\n        dig={}\n        for i in range(n):\n            if nums[i] not in dig:\n                dig[nums[i]]=[i]\n            else:\n                dig[nums[i]].append(i)\n        m=len(qu)\n        ans=[]\n        for i in range(m):\n            a=qu[i]\n            nm=nums[a]\n            arr=dig[nm]\n            ss=len(arr)\n            if len(arr)==1:\n                ans.append(-1)\n                continue\n            else:\n                l=binsch(arr,a)\n                curr=arr[l]\n                prev=0\n                next=0\n                x=1000000\n                \n                if l>0:\n                    prev=arr[l-1]\n                    x=min(x,arr[l]-prev)\n        \n                else:\n                    \n                    prev=arr[-1]\n                    x=min(x,n-prev+arr[l])\n                    \n                if l<ss-1:\n                    next=arr[l+1]\n                    x=min(x,next-arr[l])\n                    \n                else:\n                    next=arr[0]\n                    x=min(x,n-arr[l]+next)\n                    \n                ans.append(x)\n                \n        return ans\n                \n    \n\n\n\n\n                \n        return ans\n                    \n                \n                ","author":"Naveents1915","submissionId":"1575137705"},[]]},{"1274":[{"id":"1274","fileName":"1575137710.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, ArrayList<Integer>> hs = new HashMap<>();\n        int n = nums.length, m = queries.length;\n        int[] second = new int[n];\n        ArrayList<Integer> ans = new ArrayList<>();\n        \n        for(int i = 0 ; i < n ; i++){\n            if(hs.containsKey(nums[i])){\n                second[i] = hs.get(nums[i]).size();\n                hs.get(nums[i]).add(i);\n            }\n            else{\n                hs.put(nums[i], new ArrayList<>());\n                hs.get(nums[i]).add(i);\n            }\n        }\n\n        for(int i = 0 ; i < m ; i++){\n            int s = hs.get(nums[queries[i]]).size();\n            if(s == 1) ans.add(-1);\n            else{\n                int idx = second[queries[i]];\n                int a = 0, b = 0;\n                if(idx == 0){\n                    a = hs.get(nums[queries[i]]).get(0) + n \n                        - hs.get(nums[queries[i]]).get(s-1);\n                }\n                else{\n                    a = hs.get(nums[queries[i]]).get(idx) -\n                        hs.get(nums[queries[i]]).get(idx-1);\n                }\n                if(idx == s-1){\n                    b = hs.get(nums[queries[i]]).get(0) + n \n                        - hs.get(nums[queries[i]]).get(s-1);\n                }\n                else{\n                    b = hs.get(nums[queries[i]]).get(idx+1) -\n                        hs.get(nums[queries[i]]).get(idx);\n                }\n                ans.add(Math.min(a, b));\n            }\n        }\n        \n        return ans;\n    }\n}","author":"Aakash Verma","submissionId":"1575137710"},[]]},{"1276":[{"id":"1276","fileName":"1575137745.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> ans;\n        unordered_map<int, vector<int>> mp;\n\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n\n        for (int q : queries) {\n            int curr = nums[q];\n            vector<int>& temp = mp[curr];\n\n            if (temp.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            int l=0,r=temp.size()-1,ind=-1;\n            while(l<=r){\n                int mid = l + (r-l)/2;\n                if(temp[mid]==q){\n                    ind=mid;\n                    break;\n                }\n                if(temp[mid]>q)r=mid-1;\n                else l=mid+1;\n            }\n            int next,prev;\n            int tempans=INT_MAX;\n            if(ind==temp.size()-1){\n                tempans=min(tempans,abs(temp[temp.size()-1]-temp[temp.size()-2]));\n                tempans=min(tempans,n-abs(temp[temp.size()-1]-temp[0]));\n            }else if(ind==0){\n                tempans=min(tempans,abs(temp[0]-temp[1]));\n                tempans=min(tempans,n-abs(temp[temp.size()-1]-temp[0]));\n            }else{\n                tempans=min(tempans,abs(temp[ind+1]-temp[ind]));\n                tempans=min(tempans,abs(temp[ind]-temp[ind-1]));\n            }\n            ans.push_back(tempans);\n        }\n        \n        return ans;\n    }\n};\n","author":"Patel Patel","submissionId":"1575137745"},[]]},{"1277":[{"id":"1277","fileName":"1575137868.txt","sourceCode":"import bisect\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n\n        indices = defaultdict(list)\n        for i,num in enumerate(nums):\n            indices[num].append(i)\n        ans = []\n        for query in queries:\n            num = nums[query]\n            if len(indices[num]) == 1:\n                ans.append(-1)\n            else:\n                query_index_pos = bisect.bisect_left(indices[num],query)\n                sz = len(indices[num])\n                if query_index_pos == 0:\n                    left = -1\n                    right = 1\n                    ans.append(\n                        min(\n                            abs(query+len(nums)-indices[num][left]),\n                            abs(len(nums) + indices[num][left]-query),\n                            abs(len(nums) + indices[num][right]-query),\n                            abs(indices[num][left]-query),\n                            abs(indices[num][right]-query),\n                            abs(query+len(nums)-indices[num][right]),\n                            \n                        )\n                    )\n                elif query_index_pos == sz-1:\n                    left = sz-2\n                    right = 0\n                    ans.append(\n                        min(\n                            abs(query+len(nums)-indices[num][left]),\n                            abs(len(nums) + indices[num][left]-query),\n                            abs(len(nums) + indices[num][right]-query),\n                            abs(indices[num][left]-query),\n                            abs(indices[num][right]-query),\n                            abs(query+len(nums)-indices[num][right]),\n                            \n                        )\n                    )\n                else:\n                    left = query_index_pos-1\n                    right = query_index_pos+1\n                    ans.append(\n                        min(\n                            abs(query-indices[num][left]),\n                            abs(indices[num][right]-query),\n                        )\n                    )\n        return ans","author":"Arya veer Singh Chauhan","submissionId":"1575137868"},[]]},{"1278":[{"id":"1278","fileName":"1575137785.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        int n = nums.size();\n\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n\n        vector<int> ans;\n\n        for (int j : queries) {\n            int numb = nums[j];\n            auto& indices = mp[numb];\n            if (indices.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n\n            int value = INT_MAX;\n\n            int idx = lower_bound(indices.begin(), indices.end(), j) -\n                      indices.begin();\n\n            if (idx < indices.size() - 1) {\n                int nextIdx = indices[idx + 1];\n                int d = abs(nextIdx - j);\n                value = min({value, d, n - d});\n            } else {\n                int nextIdx = indices[0];\n                int d = abs(nextIdx - j);\n                value = min({value, d, n - d});\n            }\n\n            if (idx > 0) {\n                int prevIdx = indices[idx - 1];\n                int d = abs(prevIdx - j);\n                value = min({value, d, n - d});\n            } else {\n                int prevIdx = indices.back();\n                int d = abs(prevIdx - j);\n                value = min({value, d, n - d});\n            }\n\n            ans.push_back(value);\n        }\n\n        return ans;\n    }\n};\n","author":"Lubesh","submissionId":"1575137785"},[]]},{"1279":[{"id":"1279","fileName":"1575137852.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        mp = defaultdict(list)\n        for i, n in enumerate(nums):\n            mp[n].append(i)\n        ans = []\n        # print(mp)\n        def bs(l, t):\n            left, right, pivot = 0, len(l), len(l)//2\n            while l[pivot] != t:\n                if t < l[pivot]:\n                    right = pivot - 1\n                else:\n                    left = pivot + 1\n                pivot = (left + right)//2\n            return pivot\n        # print(bs(nums, 4))\n        loop = len(nums)\n        for q in queries:\n            cur = nums[q]\n            if len(mp[cur]) == 1:\n                ans.append(-1)\n            else:\n                # pos = mp[cur].index(q)\n                pos = bs(mp[cur], q)\n                left, right = -1, -1\n                if pos == 0:\n                    left = loop - mp[cur][-1] + mp[cur][pos]\n                else:\n                    left = mp[cur][pos] - mp[cur][pos - 1]\n                if pos == len(mp[cur]) - 1:\n                    right = mp[cur][0] + loop - mp[cur][pos]\n                else:\n                    right = mp[cur][pos + 1] - mp[cur][pos]\n    \n                ans.append(min(left, right))\n        return ans\n            ","author":"Jerry Zhu","submissionId":"1575137852"},[]]},{"1280":[{"id":"1280","fileName":"1575137894.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,set<int>>mp;\n        for(int i = 0;i < nums.size(); i++){\n            mp[nums[i]].insert(i);\n        }\n        int n = nums.size();\n        vector<int>fin((int)queries.size());\n        int i = 0;\n        for(auto &it : queries){\n            int index = it;\n            int ans = 1e9;\n            int val = nums[index];\n            mp[val].erase(index);\n            cout << val << endl;\n            auto lwb = mp[val].lower_bound(index);\n            // nearest\n            if(lwb != mp[val].end()){\n                ans = min({ans,*lwb - index});\n            }\n            if(lwb != mp[val].begin()){\n                lwb--;\n                ans = min({ans,index - *lwb}); \n            }\n            // cout << it <<\":\" << ans << endl;\n            // left and rightmost\n            // cout << *mp[val].begin() <<\" \" << *mp[val].rbegin() <<\" \" << n << endl;\n            // cout << \"(\";\n            // for(auto &it : mp[val]) cout << it <<\" \";\n            // cout << endl;\n            if(mp[val].size() > 0  && *mp[val].begin() < index){\n                ans = min(ans,n - index + *mp[val].begin());\n            }\n            if(mp[val].size() > 0 && *mp[val].rbegin() > index){\n                cout << \"Ok :\" << n <<\" \" << *mp[val].rbegin() << endl;\n                ans = min(ans,n - *mp[val].rbegin() + index);\n            }\n            mp[val].insert(index);\n            fin[i++] = (ans == 1e9 ? -1 : ans);\n        }\n        return fin;\n    }\n};","author":"sahil_726","submissionId":"1575137894"},[]]},{"1282":[{"id":"1282","fileName":"1575137892.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[]} queries\n * @return {number[]}\n */\nvar solveQueries = function (nums, queries) {\n  const n = nums.length;\n  const map = new Map();\n  const minDistance = new Array(n).fill(Infinity);\n\n  for (let i = 0; i < n; i++) {\n    map.set(nums[i], map.get(nums[i]) ?? []);\n    map.get(nums[i]).push(i);\n  }\n\n  for (const [_, val] of map) {\n    if (val.length === 1) continue;\n\n    for (let i = 0; i < val.length; i++) {\n      const idx = val[i];\n      if (i === 0) {\n        const right = val[i + 1] - val[i];\n        const left = val[i] - val.at(-1) + n;\n        minDistance[idx] = Math.min(left, right);\n      } else if (i === val.length - 1) {\n        const left = val[i] - val[i - 1];\n        const right = val.at(0) + n - val[i];\n        minDistance[idx] = Math.min(left, right);\n      } else {\n        const left = val[i] - val[i - 1];\n        const right = val[i + 1] - val[i];\n        minDistance[idx] = Math.min(left, right);\n      }\n    }\n  }\n\n  const ans = [];\n  for (const query of queries) {\n    const result = minDistance[query] === Infinity ? -1 : minDistance[query];\n    ans.push(result);\n  }\n\n  return ans;\n};\n","author":"Fausta Leonardo","submissionId":"1575137892"},[]]},{"1283":[{"id":"1283","fileName":"1575137881.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        idx_map = {}\n        for idx, val in enumerate(nums):\n            idx_map.setdefault(val, []).append(idx)\n\n        min_dist = [-1] * len(nums)\n        \n        for value, indices in idx_map.items():\n            total = len(indices)\n            if total == 1:\n                continue\n            \n            for i in range(total):\n                current_idx = indices[i]\n                prev_idx = indices[i - 1]\n                dist1 = (current_idx - prev_idx) if current_idx >= prev_idx else (current_idx - prev_idx + len(nums))\n                next_idx = indices[(i + 1) % total]\n                dist2 = (next_idx - current_idx) if next_idx >= current_idx else (next_idx - current_idx + len(nums))\n                min_dist[current_idx] = min(dist1, dist2)\n\n        return [min_dist[q] for q in queries]\n","author":"KIRATHVIGNAN RG","submissionId":"1575137881"},[]]},{"1284":[{"id":"1284","fileName":"1575137986.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dic = defaultdict(list)\n        def bs(target, arr):\n            if target == arr[0]:\n                return 0\n            if target == arr[-1]:\n                return len(arr) - 1\n            l, r = 0, len(arr) - 1\n            while l < r:\n                m = (l + r)//2\n                if arr[m] == target:\n                    return m\n                elif arr[m] < target:\n                    l = m\n                else:\n                    r = m\n        ret = [] \n        for i, num in enumerate(nums):\n            dic[num].append(i)\n        for query in queries:\n            val = nums[query]\n            if len(dic[val]) == 1:\n                ret.append(-1)\n                continue\n            idx = bs(query, dic[val])\n            if idx == 0:\n                ans = min(len(nums) + dic[val][idx] - dic[val][-1], dic[val][idx + 1] - dic[val][idx])\n            elif idx == len(dic[val]) - 1:\n                ans = min(dic[val][idx] - dic[val][idx - 1], len(nums) + dic[val][0] - dic[val][-1])\n            else:\n                ans = min(dic[val][idx] - dic[val][idx - 1], dic[val][idx + 1] - dic[val][idx])\n            ret.append(ans)\n        return ret\n            \n            ","author":"lby1994","submissionId":"1575137986"},[]]},{"1285":[{"id":"1285","fileName":"1575138012.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& arr, vector<int>& queries) \n    {\n        int n=arr.size();\n        vector<int> ans(queries.size());\n        map<int,vector<int>> freq;\n        for(int i=0;i<n;i++) freq[arr[i]].push_back(i);\n        for(int i=0;i<queries.size();i++)\n        {\n            int curr=arr[queries[i]];\n            if(freq[curr].size()<2) ans[i]=-1;\n            else \n            {\n                int index=lower_bound(freq[curr].begin(),freq[curr].end(),queries[i])-freq[curr].begin();\n                int m=freq[curr].size();\n                int prev_index = (index - 1 + m) % m;\n                int next_index = (index + 1) % m;\n                ans[i] = min((queries[i] - freq[curr][prev_index] + n) % n, (freq[curr][next_index] - queries[i] + n) % n);\n            }\n        }\n        return ans;\n    }\n};","author":"Dishank Patel","submissionId":"1575138012"},[]]},{"1286":[{"id":"1286","fileName":"1575138066.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> mp = new HashMap<>();\n\n        for(int i = 0; i < nums.length; i++) {\n            List<Integer> existing = mp.getOrDefault(nums[i], new ArrayList<>());\n            existing.add(i);\n            mp.put(nums[i], existing);\n        }\n\n        List<Integer> result = new ArrayList<>();\n        \n        for(int q: queries) {\n            int num = nums[q];\n\n            List<Integer> idx = mp.get(num);\n            // for(int x = 0; x < idx.size(); x++) {\n            //     System.out.print(idx.get(x) + \" \");\n            // }\n            // System.out.println();\n            // System.out.println(\"Q \" + q);\n            if(idx.size() == 1) {\n                result.add(-1);\n            } else {\n                int i = 0, j = idx.size() - 1;\n                while(i <= j) {\n                    int mid = i + (j-i)/2;\n                    // System.out.println(mid + \" \" + idx.get(mid));\n                    if(idx.get(mid) == q) {\n                        int prev = mid - 1 >= 0 ? idx.get(mid-1) : idx.get(idx.size() - 1);\n                        int next = mid + 1 < idx.size() ? idx.get(mid+1) : idx.get(0);\n                        // System.out.println(\"PREV \" + prev);\n                        // System.out.println(\"NEXT \" + next);\n                        int min = prev > q ? (nums.length - prev + q) : q - prev;\n                        min = Math.min(min, next < q ? (nums.length - q + next) : next - q);\n                        result.add(min);\n                        break;\n                    } else if(idx.get(mid) < q) {\n                        i = mid + 1;\n                    } else {\n                        j = mid - 1;\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n}","author":"Lovepreet Singh","submissionId":"1575138066"},[]]},{"1287":[{"id":"1287","fileName":"1575138086.txt","sourceCode":"class Solution {\n#define ll long long\n#define pii pair<int,int>\n#define vvpii vector<vector<pii>>\n#define vvi vector<vector<int>>\n#define vvb vector<vector<bool>>\n#define uset unordered_set\n#define umap unordered_map\n#define vi vector<int>\n#define pll pair<ll, ll>\n#define vll vector<ll>\n#define vb vector<bool>\n#define umapii unordered_map<int, int>\n#define mapii map<int, int>\n#define useti unordered_set<int>\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vvi indices(*max_element(nums.begin(), nums.end()) + 1);\n        for(int i = 0; i<nums.size(); i++){\n            indices[nums[i]].push_back(i);\n        }\n        vi ans;\n        for(auto j: queries){\n            if(indices[nums[j]].size() == 1){\n                ans.push_back(-1);\n                continue;\n            }\n            int left = 0, right = indices[nums[j]].size()-1;\n            int index = left;\n            while(left<=right){\n                int mid = (left+right)/2;\n                if(indices[nums[j]][mid] == j){\n                    index = mid;\n                    break;\n                }\n                else if(indices[nums[j]][mid] > j) right = mid-1;\n                else left = mid+1;\n            }\n            int size = indices[nums[j]].size();\n            ans.push_back(\n                min((j - indices[nums[j]][(index+size -1) % size] + nums.size())%nums.size(), (indices[nums[j]][(index+1)%size] - j + nums.size())%nums.size())\n            );\n            \n        }\n        return ans;\n    }\n};","author":"Gurekamjot Singh","submissionId":"1575138086"},[]]},{"1288":[{"id":"1288","fileName":"1575138021.txt","sourceCode":"class Solution {\npublic:\n\n    /*\n        nums = [1,3,1,4,1,3,2], queries = [0,3,5]\n\n        1 = [0,2,4]\n        3 = [1,5]\n        4 = [3]\n        2 = [6]\n\n\n    */\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, set<int>> umap;\n        unordered_map<int, set<int>::iterator> positions;\n        int n = nums.size();\n        int m = queries.size();\n\n        for(int i = 0; i < nums.size(); i++){\n            positions[i] = (umap[nums[i]].insert(i)).first;\n        }\n\n        function<int(int, int)> minDist = [&](int i, int j){\n            if(i > j){\n                swap(i, j);\n            }\n            return min(j - i, i + n - j);\n        };\n\n        vector<int> ans(queries.size(), 0);\n\n        for(int i = 0; i < queries.size(); i++){\n            set<int>& itemSet = umap[nums[queries[i]]];\n            if(itemSet.size() == 1){\n                ans[i] = -1;\n            }else{\n                set<int>::iterator it = positions[queries[i]];\n\n                set<int>::iterator itNext = it;\n                set<int>::iterator itPrev = it;\n                if(it == begin(itemSet)){\n                    itNext = next(it);\n                    itPrev = prev(end(itemSet));\n                }else if(it == prev(end(itemSet))){\n                    itNext = begin(itemSet);\n                    itPrev = prev(it);\n                }else{\n                    itNext = next(it);\n                    itPrev = prev(it);\n                }\n\n                ans[i] = min(minDist(*it, *itNext), minDist(*it, *itPrev));\n                \n            }\n        }\n\n        return ans;        \n    }\n};","author":"Ian Arsenault","submissionId":"1575138021"},[]]},{"1289":[{"id":"1289","fileName":"1575138179.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> mp;\n        int i = 0;\n        for(auto x:nums)\n        {\n            mp[x].push_back(i++);\n        }\n        vector<int> ans;\n        int n = nums.size();\n        for(auto query:queries)\n        {\n            int val = nums[query];\n            auto index = lower_bound(mp[val].begin(),mp[val].end(),query)-mp[val].begin();\n            int cur = INT_MAX;\n            if(index>0)\n            {\n                cur = abs(mp[val][index - 1]-query);  \n            }\n            if(index<mp[val].size()-1)\n            {\n               cur = min(cur,abs(mp[val][index + 1]-query));\n            }\n            if(mp[val].size()>1 && index != 0)\n            {\n                cur = min(cur,mp[val][0]+ n - query);\n            }\n            if(mp[val].size()>1 && index!= mp[val].size()-1)\n            {\n                cur = min(cur, mp[val][index] + n - mp[val][mp[val].size() - 1]);\n            }\n            if(cur == INT_MAX) cur= - 1;\n            ans.push_back(cur);\n        }\n        return ans;\n    }\n};","author":"ami_2025","submissionId":"1575138179"},[]]},{"1290":[{"id":"1290","fileName":"1575138338.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        map<int,int> mp;\n        vector<int> ans(n,0);\n        map<int,int> first;\n        for(int j=0; j<n; j++){\n            if(mp[nums[j]]!=0){\n                ans[j]=j+1-mp[nums[j]];\n                int temp=mp[nums[j]]-1;\n                if(ans[temp]==0)ans[temp]=ans[j];\n                else ans[temp]=min(ans[temp],ans[j]);\n            }else{\n                first[nums[j]]=j+1;\n            }\n             mp[nums[j]]=j+1;\n        }\n        for(int j=0; j<n; j++){\n            if(mp[nums[j]]==j+1&&ans[j]!=0){\n                ans[j]=min(ans[j],n-mp[nums[j]]+first[nums[j]]);\n                ans[first[nums[j]]-1]=min(ans[first[nums[j]]-1],n-mp[nums[j]]+first[nums[j]]);\n            }\n        }\n        vector<int> arr;\n        int q=queries.size();\n        for(int j=0; j<q; j++){\n            if(ans[queries[j]]!=0)arr.push_back(ans[queries[j]]);\n            else arr.push_back(-1);\n        }\n        return arr;\n    }\n};","author":"AJ148","submissionId":"1575138338"},[]]},{"1291":[{"id":"1291","fileName":"1575138360.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int,vector<int>> idx_map;\n        for(int i=0; i<n; i++) {\n            idx_map[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(int &i: queries) {\n            int num = nums[i];\n            int size = idx_map[num].size();\n            if(size==1) {\n                ans.push_back(-1); continue;\n            }\n            int idx = get_index(idx_map[num],0,size-1,i);            \n            int l = abs(i-idx_map[num][(size+idx-1)%size]);\n            int r = abs(i-idx_map[num][(idx+1)%size]);\n            // cout << l << \" \" << r << endl;\n            ans.push_back(min({l,r,n-l,n-r}));\n        }\n        return ans;\n    }\nprivate:\n    int get_index(vector<int>& nums, int l, int h,int &val) {\n        while(l<=h) {\n            int m = (l+h)/2;\n            if(nums[m]==val) return m;\n            else if(nums[m]<val) l=m+1;\n            else h=m-1;\n        }\n        return -1;\n    }\n};","author":"Teja Routhu","submissionId":"1575138360"},[]]},{"1292":[{"id":"1292","fileName":"1575138108.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        # Pre-compute minimum distances for each index\n        min_distances = {}  # {(index, value): min_distance}\n        \n        # Group indices by value\n        value_indices = {}\n        for i, num in enumerate(nums):\n            if num not in value_indices:\n                value_indices[num] = []\n            value_indices[num].append(i)\n        \n        # Pre-compute minimum distances for each index\n        for value, indices in value_indices.items():\n            if len(indices) <= 1:\n                continue  # No other occurrence, skip\n                \n            # Sort indices for binary search\n            indices.sort()\n            \n            # For each index of this value, find minimum distance\n            for i, idx in enumerate(indices):\n                # Check distance to previous occurrence (with wraparound)\n                prev_idx = indices[i-1] if i > 0 else indices[-1]\n                # Check distance to next occurrence (with wraparound)\n                next_idx = indices[(i+1) % len(indices)]\n                \n                # Calculate distances\n                dist_to_prev = min(abs(idx - prev_idx), n - abs(idx - prev_idx)) if idx != prev_idx else float('inf')\n                dist_to_next = min(abs(idx - next_idx), n - abs(idx - next_idx)) if idx != next_idx else float('inf')\n                \n                # Store minimum distance\n                min_distances[idx] = min(dist_to_prev, dist_to_next)\n        \n        # Process queries\n        answer = []\n        for query in queries:\n            if query in min_distances:\n                answer.append(min_distances[query])\n            else:\n                answer.append(-1)\n        \n        return answer","author":"Alex","submissionId":"1575138108"},[]]},{"1293":[{"id":"1293","fileName":"1575138220.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, TreeSet<Integer>> indexMap = new HashMap<>();\n        int n = nums.length;\n        int[] answer = new int[queries.length];\n\n        // Store indices of each unique value in a TreeSet for binary search\n        for (int i = 0; i < n; i++) {\n            indexMap.putIfAbsent(nums[i], new TreeSet<>());\n            indexMap.get(nums[i]).add(i);\n        }\n\n        // Process each query\n        for (int i = 0; i < queries.length; i++) {\n            int queryIndex = queries[i];\n            int value = nums[queryIndex];\n\n            if (!indexMap.containsKey(value) || indexMap.get(value).size() == 1) {\n                answer[i] = -1;\n                continue;\n            }\n\n            TreeSet<Integer> indices = indexMap.get(value);\n            Integer higher = indices.higher(queryIndex); // Next occurrence (right direction)\n            Integer lower = indices.lower(queryIndex);   // Previous occurrence (left direction)\n\n            // Compute circular distances\n            int minDist = Integer.MAX_VALUE;\n            if (higher != null) minDist = Math.min(minDist, higher - queryIndex);\n            if (lower != null) minDist = Math.min(minDist, queryIndex - lower);\n            if (higher == null) higher = indices.first(); // Wrap around\n            if (lower == null) lower = indices.last();   // Wrap around\n\n            // Circular distance calculations\n            minDist = Math.min(minDist, (queryIndex + n - lower) % n);\n            minDist = Math.min(minDist, (higher - queryIndex + n) % n);\n\n            answer[i] = minDist;\n        }\n\n        // Convert int[] to List<Integer> and return\n        return Arrays.stream(answer).boxed().toList();\n    }\n}","author":"pushpa panimalar","submissionId":"1575138220"},[]]},{"1294":[{"id":"1294","fileName":"1575138410.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> dist(n, n);\n        unordered_map<int,int> mp;\n        for(int i=0; i< 2*n; i++){\n            if(mp.find(nums[i%n]) == mp.end()){\n                mp[nums[i%n]] = i;\n            }else{\n                int prev_id = mp[nums[i%n]];\n                dist[i%n] = min(dist[i%n] , (i - prev_id));\n                dist[prev_id%n] = min(dist[prev_id%n] , (i - prev_id));\n                mp[nums[i%n]] = i;\n            }\n        }\n        for(int i=0; i<n; i++){\n            if(dist[i]==n) dist[i] = -1;\n        }\n        vector<int> ans;\n        for(int q : queries){\n            ans.push_back(dist[q]);\n        }\n\n        return ans;\n        \n    }\n};","author":"gkishan","submissionId":"1575138410"},[]]},{"1295":[{"id":"1295","fileName":"1575138363.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        vector<int> ans(q, -1);\n\n        \n        map<int, vector<int>> hash;\n        for (int i = 0; i < n; i++) \n        {\n            hash[nums[i]].push_back(i);\n        }\n\n        for (int i = 0; i < q; i++) {\n            int ind = queries[i];\n            int val = nums[ind];\n\n            if (hash[val].size() == 1) \n            {\n                ans[i] = -1;\n                continue;\n            }\n\n            vector<int>& arr = hash[val];\n            int size = arr.size();\n            int l = 0, r = size - 1, j = -1;\n\n            while (l <= r) \n            {\n                int mid = l + (r - l) / 2;\n                if (arr[mid] == ind) \n                {\n                    j = mid;\n                    break;\n                } \n                else if (arr[mid] > ind) \n                {\n                    r = mid - 1;\n                } \n                else \n                {\n                    l = mid + 1;\n                }\n            }\n\n            int minDist = INT_MAX;\n\n            if (j > 0) \n            {\n                minDist = min(minDist, ind - arr[j - 1]);\n            }\n\n            if (j < size - 1) \n            {\n                minDist = min(minDist, arr[j + 1] - ind);\n            }\n\n            minDist = min({minDist, n + arr[0] - ind, ind + n - arr[size - 1]});\n\n            ans[i] = minDist;\n        }\n\n        return ans;\n    }\n};\n","author":"Kalyan Vasanth","submissionId":"1575138363"},[]]},{"1298":[{"id":"1298","fileName":"1575138456.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n\n        unordered_map<int, vector<int>> idx;\n        for (int i = 0; i < n; i++)\n            idx[nums[i]].push_back(i);\n\n        vector<int> ans(m, INT_MAX);\n        for (int i = 0; i < m; i++) { \n            int t = nums[queries[i]];\n            auto& dists = idx[t];\n\n            if (dists.size() == 1)\n                continue;\n            \n            int j = lower_bound(dists.begin(), dists.end(), queries[i]) - dists.begin();\n\n            cout << i << \": \" << j << endl;\n            \n            // circular left \n            if (j != (dists.size() - 1))\n                ans[i] = queries[i] + (n - dists.back());\n        \n            // circular right \n            if (j != 0)\n                ans[i] = min(ans[i], (n - queries[i]) + dists[0]);\n            \n            // after \n            if ((j + 1) < dists.size())\n                ans[i] = min(ans[i], abs(queries[i] - dists[j + 1]));\n            \n            // before\n            if ((j - 1) >= 0)\n                ans[i] = min(ans[i], abs(queries[i] - dists[j - 1]));\n        }\n\n        for (int i = 0; i < m; i++)\n            if (ans[i] == INT_MAX)\n                ans[i] = -1;\n        \n        return ans;\n    }\n};","author":"boredfunn","submissionId":"1575138456"},[]]},{"1299":[{"id":"1299","fileName":"1575138464.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> ans(n,INT_MAX), firstIndex(1e6,-1),lastIndex(1e6+1,-1);\n        for(int i = 0; i < n; i++){\n            if(firstIndex[nums[i]] != -1){\n                cout << i << endl;\n                int cur = i;\n                int last = lastIndex[nums[i]];\n                int first = firstIndex[nums[i]];\n                // find minimum distance \n                int dist1 = cur - last; // last \n                int dist2 = first + n - cur; // first\n                if(ans[last] > dist1){\n                    ans[last] = dist1;\n                }\n                if(ans[first] > dist2){\n                    ans[first] = dist2;\n                }\n                ans[cur] = min(dist1,dist2);\n            }\n            else firstIndex[nums[i]] = i;\n            lastIndex[nums[i]] = i;\n        }\n        vector<int> res;\n        for(int i = 0; i < queries.size(); i++){\n            if(ans[queries[i]] == INT_MAX){\n                res.push_back(-1);\n            }\n            else\n                res.push_back(ans[queries[i]]);\n        }\n        return res;\n    }\n};","author":"Abhishek Jain","submissionId":"1575138464"},[]]},{"1300":[{"id":"1300","fileName":"1575138489.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,int> mp;\n        int ct=0;\n\n        for(auto i: nums){\n            if(mp.find(i)==mp.end())\n                mp[i]=ct, ct++;\n        }\n\n        vector<vector<int>> index(ct);\n        vector<int> ans;\n\n        for(int i=0;i<nums.size();i++)\n            index[mp[nums[i]]].push_back(i);\n\n        for(auto i: queries){\n            int cur = mp[nums[i]];\n            int in = lower_bound(index[cur].begin(),index[cur].end(),i)- index[cur].begin();\n            //cout<<in<<\"   \";\n            int l=1e9,r=1e9;\n            if(in)\n                l=index[cur][in]-index[cur][in-1];\n            else if(index[cur].size() > 1)\n                l=index[cur][in] + nums.size() - index[cur][index[cur].size()-1]; \n            if(in+1 < index[cur].size())\n                r=index[cur][in+1]-index[cur][in];\n            else if(index[cur].size() > 1)\n                r= nums.size()-index[cur][in]+ index[cur][0];\n\n            \n            if(l==1e9&&r==1e9)\n                ans.push_back(-1);\n            else\n                ans.push_back(min(l,r));\n        }\n        return ans;\n    }\n};","author":"prasoon107","submissionId":"1575138489"},[]]},{"1301":[{"id":"1301","fileName":"1575138523.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] num, int[] queries) {\n        int n = num.length * 3;\n        int[] nums = new int[n];\n        for (int i = 0; i < n; i++)\n            nums[i] = num[i % (n / 3)];\n        \n        int[] lastIdx = new int[(int) 1e6 + 1];\n        int[] dist = new int[n];\n        \n        Arrays.fill(dist, n / 3);\n        Arrays.fill(lastIdx, -1);\n\n        for (int i = 0; i < n; i++) {\n            if (lastIdx[nums[i]] != -1) {\n                dist[i] = Math.min(dist[i], i - lastIdx[nums[i]]);\n            }\n            lastIdx[nums[i]] = i;\n        }\n        // System.out.println(Arrays.toString(dist));\n        Arrays.fill(lastIdx, -1);\n\n        for (int i = n - 1; i >= 0; i--) {\n            if (lastIdx[nums[i]] != -1) {\n                dist[i] = Math.min(dist[i], lastIdx[nums[i]] - i);\n            }\n            lastIdx[nums[i]] = i;\n        }\n\n        List<Integer> res = new ArrayList<>();\n        for (int q : queries) {\n            res.add(dist[q + (n / 3)] == n / 3 ? -1 : dist[q + (n / 3)]);\n        }\n        \n        return res;\n    }\n}","author":"Srinivas VJ","submissionId":"1575138523"},[]]},{"1302":[{"id":"1302","fileName":"1575138487.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums, queries):\n        # First pass: build a dictionary of indices for each number\n        indices = {}\n        for i, num in enumerate(nums):\n            if num not in indices:\n                indices[num] = []\n            indices[num].append(i)\n        \n        # Second pass: precompute minimum distances for each index\n        n = len(nums)\n        min_distances = {}\n        \n        for num, positions in indices.items():\n            # Skip if there's only one occurrence\n            if len(positions) <= 1:\n                continue\n                \n            # For each position, find its minimum distance to another occurrence\n            for i, pos in enumerate(positions):\n                # Check the position before (considering circular array)\n                prev_pos = positions[i-1] if i > 0 else positions[-1]\n                # Calculate both ways to reach prev_pos\n                dist1 = abs(pos - prev_pos)\n                dist2 = n - dist1\n                min_dist_prev = min(dist1, dist2)\n                \n                # Check the position after (considering circular array)\n                next_pos = positions[(i+1) % len(positions)]\n                # Calculate both ways to reach next_pos\n                dist1 = abs(next_pos - pos)\n                dist2 = n - dist1\n                min_dist_next = min(dist1, dist2)\n                \n                # Take the minimum of the two\n                min_distances[pos] = min(min_dist_prev, min_dist_next)\n        \n        # Process queries using precomputed distances\n        answer = []\n        for query in queries:\n            # If the index is in min_distances, use the precomputed value\n            if query in min_distances:\n                answer.append(min_distances[query])\n            else:\n                # Otherwise, there are no other occurrences of this number\n                answer.append(-1)\n        \n        return answer","author":"MUTHU KUMARAN M","submissionId":"1575138487"},[]]},{"1303":[{"id":"1303","fileName":"1575138567.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> answer;\n        unordered_map<int, vector<int>> toInd;\n        for (int i = 0; i < nums.size(); i++) {\n            toInd[nums[i]].push_back(i);\n        }\n        for (int i : queries) {\n            int l = 0, r = toInd[nums[i]].size() - 1, m = (l + r)/2;\n            while (l <= r && toInd[nums[i]][m] != i) {\n                m = (l + r)/2;\n                if (toInd[nums[i]][m] < i) {\n                    l = m + 1;\n                } else if (toInd[nums[i]][m] > i) {\n                    r = m - 1;\n                }\n            }\n            l = m - 1, r = m + 1;\n            if (l < 0) {\n                l += toInd[nums[i]].size();\n            }\n            r = r % toInd[nums[i]].size();\n            int dist1 = abs(toInd[nums[i]][l] - i);\n            dist1 = min(dist1, (int) nums.size() - dist1);\n            int dist2 = abs(toInd[nums[i]][r] - i);\n            dist2 = min(dist2, (int) nums.size() - dist2);\n            if (toInd[nums[i]].size() == 1) {\n                answer.push_back(-1);\n            } else if (dist1 < dist2) {\n                answer.push_back(dist1);\n            } else {\n                answer.push_back(dist2);\n            }\n        }\n        return answer;\n    }\n};","author":"Colin Moy","submissionId":"1575138567"},[]]},{"1304":[{"id":"1304","fileName":"1575138520.txt","sourceCode":"function solveQueries(nums: number[], queries: number[]): number[] {\n    const n = nums.length;\n    const map = new Map<number, number[]>();\n    const d = new Map<number, number[]>();\n    const pos = new Map<number, number>();\n    for (let i = 0; i < n; ++i) {\n        if (!map.has(nums[i])) map.set(nums[i], []);\n        const value = map.get(nums[i]);\n        pos.set(i, value.length);\n        value.push(i);\n    }\n\n    for (const [k, v] of map.entries()) {\n        const first = v[0];\n        const last = v[v.length - 1];\n        v.unshift(last - n);\n        v.push(first + n);\n    }\n\n    for (const [k, v] of map.entries()) {\n        const arr: number[] = [];\n        for (let i = 1; i < v.length - 1; ++i) {\n            arr.push(\n                Math.min(Math.abs(v[i] - v[i - 1]), Math.abs(v[i] - v[i + 1]))\n            );\n        }\n\n        d.set(k, arr);\n    }\n\n    // console.log(d);\n\n    const res: number[] = [];\n    for (const q of queries) {\n        const num = nums[q];\n        const dq = d.get(num);\n        if (dq.length === 1) {\n            res.push(-1);\n            continue;\n        }\n\n        const dqIndex = pos.get(q);\n\n        res.push(dq[dqIndex]);\n    }\n\n    return res;\n}\n","author":"Duy Long Nguyen","submissionId":"1575138520"},[]]},{"1305":[{"id":"1305","fileName":"1575138575.txt","sourceCode":"class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer[] $queries\n     * @return Integer[]\n     */\n    function solveQueries($nums, $queries) {\n\n\n        $N = count($nums);\n\n        $nums = array_merge($nums, $nums);\n\n        $min_dist = array_fill(0, count($nums), -1);\n\n        $last_seen = [];\n        for ($i=0; $i<count($nums); $i++) {\n            $num = $nums[$i];\n            if (isset($last_seen[$num])) {\n                $dist = $i - $last_seen[$num];\n                if ($dist === $N) continue;\n                if ($min_dist[$i] === -1) {\n                    $min_dist[$i] = $dist;\n                } else {\n                    $min_dist[$i] = min($min_dist[$i], $dist);\n                }\n            }\n            $last_seen[$num] = $i;\n        }\n\n        $last_seen = [];\n        for ($i=count($nums)-1; $i>=0; $i--) {\n            $num = $nums[$i];\n            if (isset($last_seen[$num])) {\n                $dist = $last_seen[$num] - $i;\n                if ($dist === $N) continue;\n                if ($min_dist[$i] === -1) {\n                    $min_dist[$i] = $dist;\n                } else {\n                    $min_dist[$i] = min($min_dist[$i], $dist);\n                }\n            }\n            $last_seen[$num] = $i;\n        }\n\n        $res = array_fill(0, count($queries), -1);\n        for ($i=0; $i<count($queries); $i++) {\n            $q = $queries[$i];\n            $res[$i] = min($min_dist[$q], $min_dist[$q+$N]);\n        }\n        \n        // echo json_encode($last_seen).PHP_EOL;\n        // echo json_encode($min_dist);\n        \n        return $res;\n    }\n}","author":"Andy K","submissionId":"1575138575"},[]]},{"1306":[{"id":"1306","fileName":"1575138579.txt","sourceCode":"class Solution {\n    int circDist(int a, int b, int n) {\n        int diff = a > b ? a - b : b - a;\n        return diff < n - diff ? diff : n - diff;\n    }\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for (auto x : queries) {\n            vector<int>& temp = mp[nums[x]];\n            if (temp.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            int mi = INT_MAX, t;\n            auto it = lower_bound(temp.begin(), temp.end(), x);\n            if (it != temp.end() && *it == x) {\n                if (it != temp.begin()) {\n                    t = circDist(x, *(it - 1), n);\n                    mi = min(mi, t);\n                } else {\n                    t = circDist(x, temp.back(), n);\n                    mi = min(mi, t);\n                }\n                if (it + 1 != temp.end()) {\n                    t = circDist(x, *(it + 1), n);\n                    mi = min(mi, t);\n                } else {\n                    t = circDist(x, temp.front(), n);\n                    mi = min(mi, t);\n                }\n            }\n            ans.push_back(mi);\n        }\n        return ans;\n    }\n};\n","author":"0NFi7lH5BH","submissionId":"1575138579"},[]]},{"1307":[{"id":"1307","fileName":"1575138612.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>>mp;\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int>ans;\n        for(int x:queries){\n            int elem=nums[x];\n            if(mp[elem].size()==1){\n                ans.push_back(-1);\n                continue;\n            }\n            else{\n                int start=0;\n                int end=mp[elem].size()-1;\n                int mid=-1;\n                while(start<=end){\n                    mid=start+(end-start)/2;\n                    if(mp[elem][mid]==x){\n                        break;\n                    }\n                    else if(mp[elem][mid]>x){\n                        end=mid-1;\n                    }\n                    else{\n                        start=mid+1;\n                    }\n                }\n                if((mid!=0)&&(mid!=mp[elem].size()-1)){\n                    ans.push_back(min(abs(mp[elem][mid]-mp[elem][mid-1]),abs(mp[elem][mid+1]-mp[elem][mid])));\n                }\n                else if(mid!=0){\n                    int ans1=mp[elem][0]+ nums.size()-mp[elem][mid];\n                    ans1=abs(ans1);\n                    ans.push_back(min(ans1,mp[elem][mid]-mp[elem][mid-1]));\n                }\n                else{\n                    int ans1=mp[elem][mid]+ nums.size()-mp[elem].back();\n                    ans1=abs(ans1);\n                    ans.push_back(min(ans1,abs(mp[elem][mid]-mp[elem][mid+1])));\n                }\n            }\n        }\n        return ans;\n    }\n};","author":"SinghalNayni","submissionId":"1575138612"},[]]},{"1308":[{"id":"1308","fileName":"1575138618.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        num_to_indices = defaultdict(list)\n        for idx, num in enumerate(nums):\n            num_to_indices[num].append(idx)\n    \n        answer = []\n        for query in queries:\n            if query >= len(nums):\n                answer.append(-1)\n                continue\n            target_num = nums[query]\n            indices = num_to_indices[target_num]\n            if len(indices) < 2:\n                answer.append(-1)\n                continue\n            pos = bisect.bisect_left(indices, query)\n            prev = indices[pos - 1] if pos > 0 else indices[-1]\n            next_ = indices[pos] if pos < len(indices) else indices[0]\n            if prev == query:\n                prev = indices[pos - 2] if pos > 1 else indices[-1]\n            if next_ == query:\n                next_ = indices[(pos + 1) % len(indices)]\n            dist_prev = (query - prev) % len(nums)\n            dist_next = (next_ - query) % len(nums)\n            min_dist = min(dist_prev, dist_next)\n            answer.append(min_dist)\n        return answer\n\n            \n        ","author":"Aditya_Kathpalia","submissionId":"1575138618"},[]]},{"1309":[{"id":"1309","fileName":"1575138642.txt","sourceCode":"class Solution {\npublic:\n    int dis(int x, int y, int n)\n    {\n        return min((x + n - y) % n, (y + n - x) % n);        \n    }\n\n    vector<int> solveQueries(vector<int>& nums, vector<int>& qs) {\n        unordered_map<int, vector<int>> mp;\n        int n = nums.size();\n        for (int i = 0; i < n; i++)\n        {\n            mp[nums[i]].push_back(i);\n        }\n\n        vector<int> dp(n, -1);\n        for (auto& p : mp)\n        {\n            auto& v = p.second;\n            int m = v.size();\n            if (m <= 1) continue;\n            //cout << p.first << endl;\n            for (int i = 0; i < m; i++)\n            {\n                int x = (i + m - 1) % m;\n                int y = (i + m + 1) % m;\n                int d1 = dis(v[x], v[i], n);\n                int d2 = dis(v[y], v[i], n);\n                //cout << v[i] << \",\" << d1 << \",\" << d2 << endl;\n                dp[v[i]] = min(d1, d2); \n            }\n        }\n        vector<int> ans;\n        for (auto q : qs)\n        {\n            ans.push_back(dp[q]);\n        }\n        return ans;\n    }\n};","author":"lyronly","submissionId":"1575138642"},[]]},{"1310":[{"id":"1310","fileName":"1575138631.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        mapping = defaultdict(list)\n        n = len(nums)\n        result = []\n        \n        def search(x): # x = queries[i]\n            arr = mapping[nums[x]]\n            if len(arr) == 1:\n                return -1\n\n            index = bisect_left(arr, x)\n            if index == 0:\n                target = min(arr[index + 1] - x, len(nums) - arr[-1] + x)\n            elif index == len(arr) - 1:\n                target = min(x - arr[index - 1], len(nums) - x + arr[0])\n            else:\n                target = min(arr[index + 1] - x, x - arr[index - 1])\n\n            return target\n        \n        for i in range(n):\n            mapping[nums[i]].append(i)\n\n        for x in queries:\n            result.append(search(x))\n\n        return result\n        \n        \n        # {\n        #     1: [0,2,4],\n        #     3: [1,5],\n        #     4: [3]\n        #     2: [6]            \n        # }\n\n        # sorted\n        # index = 2\n        # if index == n: try 0","author":"Kyne","submissionId":"1575138631"},[]]},{"1312":[{"id":"1312","fileName":"1575138767.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        from bisect import bisect_left        \n        n = len(nums)\n        imap = {}\n        for i, num in enumerate(nums):\n            if num in imap:\n                imap[num].append(i)\n            else:\n                imap[num] = [i]\n        def cd(i, j):\n            diff = abs(i - j)\n            return min(diff, n - diff)\n        result = []\n        for q in queries:\n            num = nums[q]\n            p = imap[num]\n            if len(p) == 1:\n                result.append(-1)\n                continue\n            pos = bisect_left(p, q)\n            l = p[(pos - 1) % len(p)]\n            r = p[(pos + 1) % len(p)]\n            dl = cd(q, l)\n            dr = cd(q, r)\n            result.append(min(dl, dr))\n        return result\n","author":"Mangalavinayagam","submissionId":"1575138767"},[]]},{"1313":[{"id":"1313","fileName":"1575138696.txt","sourceCode":"class Solution {\npublic:\n    int min_dis(int i, int j, int n) {\n        return min(abs(i - j), (n - abs(i - j)));\n    }\n\n    int dis(vector<int> &index, int i, int n) {\n        int mn = 1e9;\n        if (i != index[0]) {\n            mn = min_dis(index[0], i, n);    \n        }\n        if (i != index.back()) {\n            mn = min(mn, min_dis(index.back(), i, n));\n        } \n        auto it = lower_bound(index.begin(), index.end(), i + 1);\n        if (it != index.end()) {\n            mn = min(mn, min_dis(*it, i, n));\n        }\n        it = lower_bound(index.begin(), index.end(), i);\n        if (it != index.begin()) {\n            it--;\n            mn = min(mn, min_dis(*it, i, n));\n        }\n        return mn;\n    }\n\n    vector<int> solveQueries(vector<int>& arr, vector<int>& queries) {\n        unordered_map<int, vector<int>> m;\n        int n = arr.size();\n        for (int i = 0; i < n; i++) {\n            m[arr[i]].push_back(i);\n        }\n        vector<int> ans;\n        for (auto idx : queries) {\n            if (m[arr[idx]].size() == 1) {\n                ans.push_back(-1);\n            } else {\n                ans.push_back(dis(m[arr[idx]], idx, n));\n            }\n        }\n        return ans;\n    }\n};","author":"whitemagic7456","submissionId":"1575138696"},[]]},{"1314":[{"id":"1314","fileName":"1575138833.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();\n        int n = nums.length;\n        for(int i=0;i<n;i++){\n            if(hm.containsKey(nums[i])){\n                hm.get(nums[i]).add(i);\n            }\n            else{\n                hm.put(nums[i], new ArrayList<>());\n                hm.get(nums[i]).add(i);\n            }\n        }\n        int dp[] = new int[n];\n        Arrays.fill(dp, -1);\n        for(int keys : hm.keySet()){\n            ArrayList<Integer> arr = hm.get(keys);\n            int k = arr.size();\n            if(k == 1){\n                dp[arr.get(0)] = -1;\n                continue;\n            }\n            int mi = n;\n            for(int i=0;i<k;i++){\n                if(i == 0){\n                    int curr = arr.get(i);\n                    dp[curr] = Math.min(arr.get(i+1) - curr, curr + n - arr.get(k-1));\n                }\n                else if(i == k-1){\n                    int curr = arr.get(i);\n                    dp[curr] = Math.min(curr - arr.get(i-1), n - curr + arr.get(0));\n                }\n                else{\n                    int curr = arr.get(i);\n                    dp[curr] = Math.min(curr - arr.get(i-1), arr.get(i+1) - curr);\n                }\n            }\n        }\n        // for(int i=0;i<n;i++) System.out.printf(\"%d \", dp[i]);\n        List<Integer> li = new ArrayList<>();\n        for(int q : queries){\n            li.add(dp[q]);\n        }\n        return li;\n    }\n}","author":"Manoj Kumar Miriyala","submissionId":"1575138833"},[]]},{"1316":[{"id":"1316","fileName":"1575138715.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> mp;\n        int m=nums.size();\n        for (int i = 0; i < nums.size(); i++) {\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for (auto it : queries) {\n            vector<int> &v = mp[nums[it]];\n            int n=v.size();\n            if (v.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            auto idx = lower_bound(v.begin(), v.end(), it) - v.begin();\n            int prev = v[(idx - 1 + n) % n], next = v[(idx + 1) % n];\n            // cout<<idx<<\" \"<<prev<<\" \"<<next<<endl;\n            if (prev == it) {\n                ans.push_back((next - it+m)%m);\n            } else if (next == it) {\n                ans.push_back((it-prev+m)%m);\n            } else {\n                ans.push_back(min((it-prev+m)%m, (next - it+m)%m));\n            }\n        }\n        return ans;\n    }\n};","author":"Soumyadipto Pal","submissionId":"1575138715"},[]]},{"1317":[{"id":"1317","fileName":"1575138786.txt","sourceCode":"#define FOR(i,a,b)   for(int i = a; i < b.size(); ++i)\n#define F(i,a,b)     for(int i = a; i < b; ++i)\n#define F0(i,b)      for(int i = 0; i< b.size();++i)\n#define BE(a)        a.begin(), a.end()\n#define __S(a)       a.size()\n#define pb(a)        push_back(a)\n#define pr(a)        cout << a << \" \";\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef vector<string> vs;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector <long long> vl;\ntypedef vector<vector<long long> > vvl;\n\nclass Solution {\npublic:\nvector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int m = __S(q), n = __S(nums);\n        vi ans(q);\n\n        // num[queries[i]] => other element left or right, \n        vi dp(100001,200000);\n\n        //F(i, 0, 4)cout << dp[i] << \" \";\n\n        auto dist = [&](int i, int j){\n            return min(j-i, i+ n -j);\n        };\n\n        unordered_map <int,int> mpl, mpr;\n\n        // go from the left -> \n        F(i, 0, n){\n            if (mpl.count(nums[i])){\n                dp[i] = min(dp[i], min(dist(mpr[nums[i]], i), dist(mpl[nums[i]], i)));\n                mpr[nums[i]] = i;\n            }else{\n                mpl[nums[i]] = i;\n                mpr[nums[i]] = i;\n            }\n        }\n\n\n        mpr = unordered_map<int,int>();\n        mpl = unordered_map<int,int>();\n        \n        // go from the right <-\n        for (int i = n-1; i>=0; i--){\n            if (mpl.count(nums[i])){\n                dp[i] = min(dp[i], min(dist(i, mpr[nums[i]]), dist(i, mpl[nums[i]])));\n                mpr[nums[i]] = i;\n            }else{\n                mpl[nums[i]] = i;\n                mpr[nums[i]] = i;\n            }\n        }\n\n        \n        F(i, 0, m){\n            ans[i] = (dp[q[i]] == 200000) ? -1 : dp[q[i]];\n        }\n\n        return ans;\n    }\n\n};","author":"ziang","submissionId":"1575138786"},[]]},{"1318":[{"id":"1318","fileName":"1575138799.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> valueToIndices;\n        \n     \n        for (int i = 0; i < n; ++i) {\n            valueToIndices[nums[i]].push_back(i);\n        }\n\n        vector<int> result;\n\n\n        for (int idx : queries) {\n            int val = nums[idx];\n            const vector<int>& positions = valueToIndices[val];\n\n            if (positions.size() == 1) {\n              \n                result.push_back(-1);\n                continue;\n            }\n\n           \n            auto it = lower_bound(positions.begin(), positions.end(), idx);\n            int minDist = INT_MAX;\n\n           \n            if (it != positions.end()) {\n                int nextPos = *it;\n                if (nextPos != idx) {\n                    minDist = min(minDist, abs(nextPos - idx));\n                    minDist = min(minDist, n - abs(nextPos - idx));  // circular path\n                } else if (positions.size() >= 2) {\n                    // Skip self, take next (wrap around if needed)\n                    int nextIdx = (it - positions.begin() + 1) % positions.size();\n                    nextPos = positions[nextIdx];\n                    minDist = min(minDist, abs(nextPos - idx));\n                    minDist = min(minDist, n - abs(nextPos - idx));\n                }\n            }\n\n            if (it != positions.begin()) {\n                int prevPos = *(it - 1);\n                if (prevPos != idx) {\n                    minDist = min(minDist, abs(prevPos - idx));\n                    minDist = min(minDist, n - abs(prevPos - idx));\n                }\n            } else {\n                // Wrap to last index\n                int prevPos = positions.back();\n                if (prevPos != idx) {\n                    minDist = min(minDist, abs(prevPos - idx));\n                    minDist = min(minDist, n - abs(prevPos - idx));\n                }\n            }\n\n            result.push_back(minDist);\n        }\n\n        return result;\n    }\n};\n","author":"Himanshu","submissionId":"1575138799"},[]]},{"1320":[{"id":"1320","fileName":"1575138858.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>>mpp;\n\n        for(int i=0;i<nums.size();i++)\n            {\n                mpp[nums[i]].push_back(i);\n            }\n        int q=queries.size();\n        vector<int>ans(q);\n        vector<int>temp;\n        int n=nums.size();\n        for(int i=0;i<q;i++)\n            {\n                int ind=queries[i];\n                int el=nums[ind];\n                if((mpp.find(el)==mpp.end())||(mpp[el].size()<2))\n                {\n                   ans[i]=-1;\n                    continue;\n                }\n\n                temp=mpp[el];\n                int low=0;\n                int high=temp.size()-1;\n                int fi=0;\n                while(low<=high)\n                    {\n                        int mid=(low+high)>>1;\n\n                        if(temp[mid]<=ind)\n                        {\n                            low=mid+1;\n                        }\n                        else high=mid-1;\n\n                        if(temp[mid]==ind)\n                        {\n                            fi=mid;\n                        }\n                    }\n\n                int fs=INT_MAX;\n                if(fi!=temp.size()-1)\n                {\n                    fs=min(fs,temp[fi+1]-temp[fi]);\n                    fs=min(fs,temp[fi]+n-temp[temp.size()-1]);\n                }\n\n                if(fi!=0)\n                {\n                    fs=min(fs,temp[fi]-temp[fi-1]);\n                    fs=min(fs,temp[fi]-temp[0]);\n                    int d=(nums.size())-temp[fi]+temp[0];\n                    fs=min(fs,d);\n                }\n\n                ans[i]=fs;\n            }\n\n        return ans;\n    }\n};","author":"Shubham Pandey","submissionId":"1575138858"},[]]},{"1321":[{"id":"1321","fileName":"1575138898.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>>mp;\n        for(int i = 0; i < nums.size(); i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int>ans;\n        for(auto i: queries){\n            if(mp[nums[i]].size() == 1)   ans.push_back(-1);\n            else{\n                int n = mp[nums[i]].size();\n                int ind = lower_bound(mp[nums[i]].begin(), mp[nums[i]].end(), i) - mp[nums[i]].begin();\n                int nxt = mp[nums[i]][(ind + 1) % n];\n                int prev = mp[nums[i]][(ind - 1 + n) % n];\n                // cout << ind << \" \" << prev << \" \" << nxt << endl;\n                int diff1 = abs(i - prev);\n                if(prev > i)  diff1 = nums.size() - diff1;\n                int diff2 = abs(nxt - i);\n                if(nxt < i)   diff2 = nums.size() - diff2;\n                ans.push_back(min(diff1, diff2));\n            }\n        }\n        return ans;\n    }\n};","author":"Srdjr000","submissionId":"1575138898"},[]]},{"1322":[{"id":"1322","fileName":"1575138885.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<pair<int,int>> v(n);\n        unordered_map<int,int> last, first;\n        for(int i=0;i<n;i++){\n            v[i]={nums[i], i};\n            last[nums[i]]=i;\n            if(first.count(nums[i])==0)first[nums[i]]=i;\n        }\n        sort(v.begin(), v.end());\n        vector<int>dist(n, -1);\n        for(int i=0;i<n;i++){\n            if(i==0||v[i].first!=v[i-1].first){\n                if(i+1>=n||v[i].first!=v[i+1].first)continue;\n                else {\n                    dist[v[i].second] = v[i+1].second-v[i].second;\n                    dist[v[i].second]=min(\n                        dist[v[i].second],\n                        (last[v[i].first]!=v[i].second)?(n-last[v[i].first]+v[i].second):n\n                    );\n                }\n            }else if(i==n-1||v[i].first!=v[i+1].first){\n                if(i-1<0||v[i].first!=v[i-1].first)continue;\n                else {\n                    dist[v[i].second] = v[i].second-v[i-1].second;\n                    dist[v[i].second]=min(\n                        dist[v[i].second],\n                        (first[v[i].first]!=v[i].second)?(n+first[v[i].first]-v[i].second):n\n                    );\n                }\n            }else{\n                dist[v[i].second] = min(v[i].second-v[i-1].second, v[i+1].second-v[i].second);\n            }\n        }\n        int sz = queries.size();\n        vector<int>ans(sz);\n        for(int i=0;i<sz;i++){\n            ans[i]=dist[queries[i]];\n        }\n        return ans;\n    }\n};","author":"cassowary1","submissionId":"1575138885"},[]]},{"1323":[{"id":"1323","fileName":"1575138870.txt","sourceCode":"from bisect import bisect_left\n\nclass Solution:\n    \n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        pos_dict = {}\n        for i, num in enumerate(nums):\n            if num in pos_dict:\n                pos_dict[num].append(i)\n            else:\n                pos_dict[num] = [i]\n        print (pos_dict)\n        answers = []\n        for query in queries:\n            start = nums[query]\n            indexes = pos_dict[start]\n            if len(indexes) == 1:\n                answers.append(-1)\n            else:\n                start_index = bisect_left(indexes, query)\n                forward = -inf\n                backward = -inf\n                if start_index == 0:\n                    forward = len(nums) + query - indexes[start_index - 1]\n                    backward = indexes[start_index + 1] - query\n                elif start_index == len(indexes) - 1:\n                    forward = query - indexes[start_index - 1]\n                    backward = len(nums) + indexes[0] - query\n                else:\n                    forward = query - indexes[start_index - 1]\n                    backward = indexes[start_index + 1] - query\n                # print(\"for query %d, forward is %d and backward is %d\" % (query, forward, backward))\n                answers.append(min(forward, backward))\n        return answers","author":"lidiawu","submissionId":"1575138870"},[]]},{"1324":[{"id":"1324","fileName":"1575139037.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size(),ma=queries.size();\n        map<int,vector<int>>m;\n        for(int i=0;i<n;i++){\n            m[nums[i]].push_back(i);\n        }\n        vector<int>ans(ma,INT_MAX);\n        for(int i=0;i<ma;i++){\n            int q=queries[i];\n            auto it=lower_bound(m[nums[q]].begin(),m[nums[q]].end(),q);\n            int temp1=INT_MAX-1000000,temp2=INT_MAX-1000000;\n            if(it==m[nums[q]].begin() && m[nums[q]].size()>1){\n                temp1=*--m[nums[q]].end();\n            }\n            else if(it!=m[nums[q]].begin()){\n                temp1= *(it-1);\n            }\n            if((it+1)==m[nums[q]].end() && m[nums[q]].size()>1){\n                temp2= *m[nums[q]].begin();\n            }\n            else if((it+1)!=m[nums[q]].end()){\n                temp2=*(it+1);\n            }\n            // cout<<temp1<<\" \"<<temp2<<endl;\n            if(temp1<q){\n                ans[i]=min(ans[i],abs(temp1-q));\n                // cout<<\"h\"<<endl;\n            }\n            else{\n                ans[i]=min(ans[i],abs(q+(n-temp1)));\n            }\n            if(temp2>q){\n                // cout<<\"he\"<<endl;\n                ans[i]=min(ans[i],abs(temp2-q));\n            }\n            else{\n                ans[i]=min(ans[i],abs(temp2+(n-q)));\n            }            \n            if(ans[i]>n){\n                ans[i]=-1;\n            }\n            \n        }\n            return ans;\n    }\n};","author":"Garvit Goyal","submissionId":"1575139037"},[]]},{"1325":[{"id":"1325","fileName":"1575139023.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        for (int i = 0; i < 2 * n; ++i)\n            {\n                nums.push_back(nums[i % n]);\n            }\n        std::unordered_map<int, int> indexMap;     \n        std::vector<int> prefix(3 * n, -1), postfix(3 * n, -1), res(queries.size());\n        for (int i = 0; i <  3 * n; ++i)\n            {\n                if (indexMap.find(nums[i]) != indexMap.end()) prefix[i] = indexMap[nums[i]];\n                indexMap[nums[i]] = i;\n            }\n        indexMap.clear();\n        for (int i = 3 * n - 1; i >= 0; --i)\n            {\n                if (indexMap.find(nums[i]) != indexMap.end()) postfix[i] = indexMap[nums[i]];\n                indexMap[nums[i]] = i;\n            }\n        for (int i = 0; i < queries.size(); ++i)\n            {\n                int idx = queries[i] + n;\n                int dist = -1;\n                if (prefix[idx] != -1)\n                {\n                    dist = idx - prefix[idx];\n                }\n                if (postfix[idx] != -1)\n                {\n                    dist = std::min(dist, postfix[idx] - idx);\n                }\n                if (dist >= n) dist = -1;\n                res[i] = dist;\n            }\n        return res;\n    }\n};","author":"Yousef Said","submissionId":"1575139023"},[]]},{"1326":[{"id":"1326","fileName":"1575139005.txt","sourceCode":"class Solution {\npublic:\n    unordered_map<int, vector<int>> indexMap;\n\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        indexMap.clear();\n        int n = nums.size();\n\n        // Store indices of each number in nums\n        for (int i = 0; i < n; i++) {\n            indexMap[nums[i]].push_back(i);\n        }\n\n        vector<int> res;\n        for (int y : queries) {\n            int x = nums[y];  // Find the value at index y\n            auto& indices = indexMap[x];\n\n            // Find position of y in indices array\n            auto it = lower_bound(indices.begin(), indices.end(), y);\n            int pos = it - indices.begin();\n            int ans = INT_MAX;\n\n            // Check next occurrence\n            if (pos + 1 < indices.size()) {\n                ans = indices[pos + 1] - indices[pos];\n            } \n            else if (indices.size() > 1) { \n                // Wrap-around case (if y is the last occurrence)\n                ans = min(ans, n - indices.back() + indices.front());\n            }\n\n            // Check previous occurrence\n            if (pos - 1 >= 0) { \n                ans = min(ans, indices[pos] - indices[pos - 1]);\n            } \n            else if (indices.size() > 1) { \n                // Wrap-around case (if y is the first occurrence)\n                ans = min(ans, n - indices.back() + indices.front());\n            }\n\n            res.push_back(ans == INT_MAX ? -1 : ans);\n        }\n\n        return res;\n    }\n};","author":"Somya Singh","submissionId":"1575139005"},[]]},{"1327":[{"id":"1327","fileName":"1575139040.txt","sourceCode":"from typing import List\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        mp = {}\n        n = len(nums)\n        prefix = [-1] * n\n        suffix = [-1] * n\n        for j in range(2 * n):\n            i = j % n\n            x = nums[i]\n            if x not in mp:\n                mp[x] = i\n            elif mp[x] == i:\n                continue\n            else:\n                prefix[i] = mp[x]\n                suffix[mp[x]] = i\n                mp[x] = i\n        \n        res = [-1] * len(queries)\n        for j, i in enumerate(queries):\n            l = (i + n - prefix[i]) % n if prefix[i] != -1 else 10**7\n            r = (suffix[i] + n - i) % n if suffix[i] != -1 else 10**7\n            res[j] = min(l, r)\n            if res[j] == 10**7:\n                res[j] = -1\n        return res","author":"hrime","submissionId":"1575139040"},[]]},{"1328":[{"id":"1328","fileName":"1575139118.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        last = {}\n        n = len(nums)\n        near = [n for _ in range(n)]\n        for i in range(2*n):\n            i = i%n\n            v = nums[i]\n            pidx = last.get(v, i)\n            if pidx != i:\n                pidx = last[v]\n                min_dist = min(n - abs(i-pidx), abs(i-pidx))\n                near[i] = min(min_dist, near[i])\n                near[pidx] = min(near[pidx], min_dist)\n            last[v] = i\n            # print (i, near)\n            \n        # print (near)\n            \n        ans = [-1 for _ in range(len(queries))]\n        for i in range(len(queries)):\n            idx = queries[i]\n            if near[idx] != n:\n                ans[i] = near[idx]\n                \n        return ans\n            \n            \n        ","author":"saurav","submissionId":"1575139118"},[]]},{"1330":[{"id":"1330","fileName":"1575139169.txt","sourceCode":"class Solution(object):\n    def solveQueries(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        first = {}\n        last = {}\n        prev = [-1] * n\n        for i in range(n):\n            if nums[i] in last:\n                prev[i] = last[nums[i]]\n            else:\n                first[nums[i]] = i\n            last[nums[i]] = i\n        for i in first.keys():\n            if first[i] < last[i]:\n                prev[first[i]] = last[i]\n        # print(prev)\n        distance = [-1] * n\n        for i in range(n):\n            if prev[i] >= 0:\n                dist = (i + n - prev[i]) % n\n                if distance[i] < 0:\n                    distance[i] = dist\n                else:\n                    distance[i] = min(distance[i], dist)\n                if distance[prev[i]] < 0:\n                    distance[prev[i]] = dist\n                else:\n                    distance[prev[i]] = min(distance[prev[i]], dist)\n        res = []\n        for i in queries:\n            res.append(distance[i])\n        return res\n            \n            \n                ","author":"brandonleo","submissionId":"1575139169"},[]]},{"1333":[{"id":"1333","fileName":"1575139184.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> mp;\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> quer(1e5+1,-1);\n        for(auto &item:mp){\n            sort(item.second.begin(),item.second.end());\n            \n            for(int i=1;i<item.second.size()-1;i++){\n                int diff=abs(item.second[i]-item.second[i+1]);\n                int diff2=abs(item.second[i]-item.second[i-1]);\n                int si=nums.size();\n                diff=min(diff,si-diff);\n                diff2=min(diff2,si-diff2);\n                quer[item.second[i]]=min(diff,diff2);\n            }\n            int size=item.second.size();\n            if(item.second.size()>1){\n                int diff=abs(item.second[1]-item.second[0]);\n                int diff2=abs(item.second[0]-item.second[size-1]);\n                int diff3=abs(item.second[size-2]-item.second[size-1]);\n                int si=nums.size();\n                diff=min(diff,si-diff);\n                diff2=min(diff2,si-diff2);\n                diff3=min(diff3,si-diff3);\n                quer[item.second[0]]=min(diff,diff2);\n                quer[item.second[size-1]]=min(diff3,diff2);\n                \n            }\n        }\n        vector<int> answer(queries.size(),0);\n        for(int i=0;i<queries.size();i++){\n            answer[i]=quer[queries[i]];\n        }\n        return answer;\n    }\n};","author":"CHIRAG SHARMA","submissionId":"1575139184"},[]]},{"1334":[{"id":"1334","fileName":"1575139151.txt","sourceCode":"#define N 1000002\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        vector<int> a;\n        a.push_back(N);\n        for (auto x : nums)\n            a.push_back(x);\n        for (auto x : nums)\n            a.push_back(x);\n\n        for (int i = 0; i < N; i++) {            \n            last[i] = 0;\n        }\n        for (int i = 1; i < a.size(); i++) {\n            pr[i] = last[a[i]];\n            last[a[i]] = i;\n        }\n        \n        for (int i = 0; i < N; i++) {            \n            last[i] = N;            \n        }\n\n        for (int i = a.size() - 1; i >= 1; i--) {\n            nx[i] = last[a[i]];\n            last[a[i]] = i;\n        }\n        vector<int> res;\n\n        for (auto p:q){\n            int ans = N;\n            int ps = p + 1;\n            \n            if (nx[ps] != N) ans = min(ans, nx[ps] - ps);            \n            if (pr[ps] != 0) ans = min(ans, ps - pr[ps]);\n            if (nx[ps + nums.size()] != N) ans = min(ans, nx[ps + (int)nums.size()] - ps - (int)nums.size());\n            if (pr[ps + nums.size()] != 0) ans = min(ans, ps + (int)nums.size() - pr[ps + (int)nums.size()]);\n            if (ans == N || ans == nums.size()) ans = -1;\n            \n            res.push_back(ans);\n        }\n        return res;\n    }\n\n    int pr[N], last[N], nx[N];\n};","author":"Vlad Sobin","submissionId":"1575139151"},[]]},{"1335":[{"id":"1335","fileName":"1575139452.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        /*\n        先把數字的位置整理出來 val -> index, 2, 3, 6, ....\n        queries 的時候就看看是否該index有在queries裡面\n        unordered_map<int,int> queries = i\n        */\n        int n = nums.size(), m = queries.size();\n        vector<int> ans(m, -1);\n        unordered_map<int,int> q;\n        for(int i = 0; i < m; i++) {\n            q[queries[i]] = i;\n        }\n        unordered_map<int, vector<int>> val2idx;\n        for(int i = 0; i < n; i++) val2idx[nums[i]].push_back(i);\n        for(auto &[v, arr]: val2idx) {\n            int k = arr.size();\n            for(int i = 0; i < k; i++) {\n                if(q.count(arr[i])) {\n                    int cand1 = abs(arr[i] - arr[((i-1)%k + k) % k]);\n                    int cand2 = abs(arr[i] - arr[((i+1)%k + k) % k]);\n                    \n                    if(cand1 == 0) cand1 = INT_MAX;\n                    else {\n                        cand1 = min(cand1, n - cand1);\n                    }\n                    if(cand2 == 0) cand2 = INT_MAX;\n                    else cand2 = min(cand2, n - cand2);\n                    if(cand1 == INT_MAX && cand2 == INT_MAX) continue;\n                    ans[q[arr[i]]] = min(cand1, cand2);\n                }\n            }\n        }\n        return ans;\n    }\n};","author":"jcs_v1","submissionId":"1575139452"},[]]},{"1336":[{"id":"1336","fileName":"1575139412.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n=nums.size(),qs=q.size();\n        vector<int> ans(qs);\n        map<int,vector<int>> mp;\n        for(int i=0;i<n;i++) mp[nums[i]].push_back(i);\n        for(int i=0;i<qs;i++){\n            if(mp[nums[q[i]]].size()==1){\n                ans[i]=-1;continue;\n            }\n            vector<int>& pos = mp[nums[q[i]]];\n            auto it = lower_bound(pos.begin(), pos.end(), q[i]);\n            int j = it - pos.begin();\n            int mn = n;\n            if(j < pos.size() && pos[j] == q[i]) {\n                if(j > 0) {\n                    mn = min(mn, min(q[i] - pos[j-1], n - (q[i] - pos[j-1])));\n                } else if(pos.size() > 1) {\n                    mn = min(mn, min(q[i] + n - pos.back(), pos.back() - q[i]));\n                }\n                if(j < pos.size() - 1) {\n                    mn = min(mn, min(pos[j+1] - q[i], n - (pos[j+1] - q[i])));\n                } else if(pos.size() > 1) {\n                    mn = min(mn, min(pos[0] + n - q[i], q[i] - pos[0]));\n                }\n            }\n            ans[i] = mn;\n        }\n        return ans;\n    }\n};","author":"mhr","submissionId":"1575139412"},[]]},{"1337":[{"id":"1337","fileName":"1575139417.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int const N = nums.size();\n        vector<int> distance(N, -1);\n        unordered_map<int, vector<int>> numIdx;\n        \n        for (int i = 0; i < N; ++i) {\n            if (numIdx.count(nums[i]) != 0) {\n                int lastIdx = numIdx[nums[i]].back();\n                int dis = i - lastIdx;\n                // update last\n                if (distance[lastIdx] == -1) {\n                    distance[lastIdx] = dis;\n                } else {\n                    distance[lastIdx] = min(distance[lastIdx], dis);\n                }\n                // update this\n                distance[i] = dis;\n            }\n            numIdx[nums[i]].push_back(i);\n        }\n\n        for (auto &[n, vec]: numIdx) {\n            if (vec.size() > 1) {\n                int front = vec[0];\n                int back = vec.back();\n                int dis = N - (back - front);\n                distance[front] = min(distance[front], dis);\n                distance[back] = min(distance[back], dis);\n            }\n        }\n\n        vector<int> ans(queries.size(), 0);\n        for (int i = 0; i < queries.size(); ++i) {\n            ans[i] = distance[queries[i]];\n        }\n        return ans;\n    }\n};","author":"syujy","submissionId":"1575139417"},[]]},{"1338":[{"id":"1338","fileName":"1575139409.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[]} queries\n * @return {number[]}\n */\nvar solveQueries = function(nums, queries) {\n    const a = new Map();\n    const b = nums.length;\n    \n    for (let c = 0; c < nums.length; c++) {\n        if (!a.has(nums[c])) {\n            a.set(nums[c], []);\n        }\n        a.get(nums[c]).push(c);\n    }\n    \n    const d = [];\n    \n    for (let c of queries) {\n        const e = nums[c];\n        const f = a.get(e);\n        \n        if (f.length === 1) {\n            d.push(-1);\n            continue;\n        }\n        \n        let g = f.findIndex(index => index >= c);\n        if (g === -1) g = f.length;\n        \n        let h = Infinity, i = Infinity;\n        if (g > 0) {\n            h = c - f[g - 1];\n        }\n        if (g < f.length - 1) {\n            i = f[g + 1] - c;\n        }\n        \n        let j = b - Math.abs(c - f[f.length - 1]);\n        if (f[f.length - 1] === c) j = Infinity;\n        \n        let k = b - Math.abs(c - f[0]);\n        if (f[0] === c) k = Infinity;\n        \n        d.push(Math.min(h, i, j, k));\n    }\n    \n    return d;\n};\n","author":"velan_K","submissionId":"1575139409"},[]]},{"1339":[{"id":"1339","fileName":"1575139540.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> indexesWithValue;\n        for(int i = 0; i < nums.size(); i++){\n            auto iter = indexesWithValue.find(nums[i]);\n            if(iter == indexesWithValue.end()){\n                indexesWithValue[nums[i]] = vector<int>{ i };\n            }\n            else {\n                iter->second.push_back(i);\n            }\n        }\n        vector<int> answer(queries.size());\n        for(int i = 0; i < queries.size(); i++){\n            int query = queries[i];\n            vector<int>& indexesWithQueryValue = indexesWithValue[nums[query]];\n            //cout << \"query: \" << query << \" indexesWithQueryValue: \";\n            /*for(int num : indexesWithQueryValue){\n                cout << num << \", \";\n            }*/\n            //cout << endl;\n            if(indexesWithQueryValue.size()==1){\n                answer[i] = -1;\n            }\n            else {\n                int minDist = INT_MAX;\n                int indexIndex = lower_bound(\n                    indexesWithQueryValue.begin(), \n                    indexesWithQueryValue.end(), \n                    query) - indexesWithQueryValue.begin();\n                int candidates[4] = {\n                    indexesWithQueryValue[0],\n                    indexIndex == 0? query : indexesWithQueryValue[indexIndex-1],\n                    indexIndex == indexesWithQueryValue.size()-1? query : indexesWithQueryValue[indexIndex+1],\n                    indexesWithQueryValue.back()\n                };\n                minDist = min(minDist, (int)nums.size() - query + candidates[0]);\n                if(candidates[1] != query){\n                    minDist = min(minDist, query - candidates[1]);    \n                }\n                if(candidates[2] != query){\n                    minDist = min(minDist, candidates[2] - query);    \n                }\n                minDist = min(minDist, (int)nums.size() + query - candidates[3]);\n                /*if(dist < minDist)\n                for(int j = 0; j < indexesWithQueryValue.size(); j++){\n                    if(indexesWithQueryValue[j] == query){\n                        continue;\n                    }\n                    int dist;\n                    if(indexesWithQueryValue[j] > query){\n                        dist = min(indexesWithQueryValue[j] - query, (int)nums.size()-indexesWithQueryValue[j]+query);\n                    }\n                    else {\n                        dist = min(-indexesWithQueryValue[j] + query, (int)nums.size()+indexesWithQueryValue[j]-query);\n                    }\n                    if(dist < minDist){\n                        minDist = dist;\n                    }\n                }*/\n                answer[i] = minDist;\n            }\n        }\n        return answer;\n    }\n};","author":"FabioSungurlian","submissionId":"1575139540"},[]]},{"1340":[{"id":"1340","fileName":"1575139476.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& A, vector<int>& q) {\n        int n = A.size();\n        unordered_map<int, vector<int>> h;\n        for(int i = 0; i < n; ++i) {\n            int v = A[i];\n            h[v].push_back(i);\n        }\n        // for(auto& [i, v] : h) {\n        //     cout << \"i=\" << i << \"|\";\n        //     for(int k : v) {\n        //         cout << k << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        vector<int> ans;\n        for(int i : q) {\n            auto& v = h[A[i]];\n            if(v.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n//             cout << \"qi=\" << i << endl;\n            \n//             cout << \"v=\" ;\n//             for(int k : v) {\n//                 cout << k << \" \";\n//             }\n//             cout << endl;\n            \n            int idx = lower_bound(v.begin(), v.end(), i) - v.begin();\n            int t = INT_MAX;\n            int sz = A.size();\n            // cout << \" idx=\" << idx << endl;\n            if(idx != 0) {\n                t = min({t, v[idx] - v[idx - 1], sz - v[idx] + v[idx - 1]});\n            } else {\n                t = min({t, v[v.size() - 1] - v[0], sz - v[v.size() - 1] + v[0]});\n            }\n            if(idx != v.size() - 1) {\n                t = min({t, v[idx + 1] - v[idx], sz - v[idx + 1] + v[idx]});\n            }else {\n                t = min({t, v[v.size() - 1] - v[0], sz - v[v.size() - 1] + v[0]});\n            }\n            ans.push_back(t);\n        }\n        return ans;\n    }\n};","author":"ch1","submissionId":"1575139476"},[]]},{"1341":[{"id":"1341","fileName":"1575139465.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& qu) {\n        int i,j,n=nums.size(),k=0;\n        vector<int> dis(n,n+1);\n        map<int,int> mp;\n        for(i=0;i<2*n;i++){\n            if(i<n) j = i;\n            else j = i-n;\n            if(mp.find(nums[j])!=mp.end()){\n               int d = abs(i-mp[nums[j]]);\n                dis[j] = min(d, dis[j]);\n            }\n            mp[nums[j]] = i;\n        }\n        //cout<<\"here\"<<endl;\n        mp.clear();\n        for(i=(2*n-1);i>=0;i--){\n            if(i<n) j=i;\n            else j= i-n;\n            //cout<<\"here \"<<i<<endl;\n            if(mp.find(nums[j])!=mp.end()){\n               int d = abs(i-mp[nums[j]]);\n                dis[j] = min(d, dis[j]);\n            }\n            mp[nums[j]] = i;\n        }\n        int q = qu.size();\n        vector<int> ans(q,-1);\n        for(i=0;i<q;i++){\n            if(dis[qu[i]]>=n) ans[i]=-1;\n            else ans[i] = dis[qu[i]];\n        }\n        return ans;\n    }\n};","author":"Vineet Gupta","submissionId":"1575139465"},[]]},{"1342":[{"id":"1342","fileName":"1575139573.txt","sourceCode":"class Solution {\npublic:\n\n    int calc(int i, int j, int n) {\n        int x = 0;\n        if(i > j) {\n            x = abs(n-i+j);\n        }\n        else {\n            x = abs(n-j+i);\n        }\n        return min(abs(i-j), x);\n    }\n\n    int find(vector<int>& v, int key) {\n        int l = 0, r = v.size()-1;\n        while(l <= r) {\n            int mid = l+(r-l)/2;\n            if(v[mid] == key) return mid;\n            else if(v[mid] > key) {\n                r = mid-1;\n            }\n            else l = mid+1;\n        }\n        return -1;\n    }\n\n    int findc(vector<int>& v, int i, int n) {\n        if(v.size() == 2) {\n            int y = -1;\n            if(v[0] == i) y = v[1];\n            else y = v[0];\n            return calc(i, y, n);\n        }\n        int ind = find(v, i);\n        int x = -1, y = -1;\n        if(ind == 0) {\n            x = v.back();\n            y = v[ind+1];\n        }\n        else if(ind == v.size()-1) {\n            x = v[ind-1];\n            y = v[0];\n        }\n        else {\n            x = v[ind-1];\n            y = v[ind+1];\n        }\n        return min(calc(i, x, n), calc(i, y, n));\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        vector<int> ans(q, -1);\n        unordered_map<int, vector<int>> mp;\n        for(int i=0; i<n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        for(int i=0; i<q; i++) {\n            int ind = queries[i];\n            if(mp[nums[ind]].size() <= 1) continue;\n            // for(auto &j: mp[nums[ind]]) {\n            //     if(j == ind) continue;\n            //     int cost = findc(ind, j, n);\n            //     // cout<<cost<<endl;\n            //     if(ans[i] == -1) ans[i] = cost;\n            //     else ans[i] = min(ans[i], cost);\n            // }\n            int cost = findc(mp[nums[ind]], ind, n);\n            if(ans[i] == -1) ans[i] = cost;\n            else ans[i] = min(ans[i], cost);\n        }\n        return ans;\n    }\n};","author":"Prathamesh Mane","submissionId":"1575139573"},[]]},{"1344":[{"id":"1344","fileName":"1575139603.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        ArrayList<Integer> res=new ArrayList<>();\n        for(int i=0;i<nums.length;i++){\n            res.add(-1);\n        }\n        HashMap<Integer,Integer> last=new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            if(last.containsKey(nums[i])){\n                int lastindex=last.get(nums[i]);\n                if(res.get(lastindex)==-1 || res.get(lastindex)>i-lastindex){\n                    res.set(lastindex,i-lastindex);\n                }\n                res.set(i,i-lastindex);\n            }\n            last.put(nums[i],i);\n        }\n        for(int i=0;i<nums.length;i++){\n            if(last.containsKey(nums[i])){\n                int indx=last.get(nums[i]);\n                int lastindex=nums.length-last.get(nums[i]);\n                if(res.get(indx)>i+lastindex){\n                    res.set(indx,i+lastindex);\n                }\n                if(res.get(i)>i+lastindex){\n                    res.set(i,i+lastindex);\n                }\n            }\n        }\n        ArrayList<Integer> ans=new ArrayList<>();\n        for(int i:queries){\n            ans.add(res.get(i));\n        }\n        return ans;\n    }\n}","author":"Shiva Ganesh Reddy Linga","submissionId":"1575139603"},[]]},{"1345":[{"id":"1345","fileName":"611228821.txt","sourceCode":"class Solution:\n    def solveQueries(self, a: List[int], queries: List[int]) -> List[int]:\n        n=len(a)\n        a=a*2\n        pre={}\n        res=[inf]*(2*n)\n        for i in range(2*n):\n            x=a[i]\n            if x in pre:\n                res[i]=min(res[i],i-pre[x])\n            pre[x]=i\n        pre={}\n        for i in range(2*n-1,-1,-1):\n            x=a[i]\n            if x in pre:\n                res[i]=min(res[i],pre[x]-i)\n            pre[x]=i\n        ans=[]\n        for i in queries:\n            t=min(res[i],res[i+n])\n            if t>=n:\n                ans.append(-1)\n            else:\n                ans.append(t)\n        return ans","author":"poiujhgdsd","submissionId":"611228821"},[]]},{"1346":[{"id":"1346","fileName":"611228588.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        pos = defaultdict(list)\n        n = len(nums)\n        prev = [-1] * (n * 3)\n        nxt = [-1] * (n * 3)\n        for i, num in enumerate(nums + nums + nums):\n            if len(pos[num]) > 0:\n                prev[i] = pos[num][-1]\n                nxt[pos[num][-1]] = i\n            pos[num].append(i)\n        ans = []\n        for k in queries:\n            k += n\n            res = -1\n            if prev[k] != -1:\n                res = k - prev[k]\n            if nxt[k] != -1:\n                if res != -1:\n                    res = min(res, nxt[k] - k)\n                else:\n                    res = nxt[k] - k\n            if res >= n:\n                res = -1\n            ans.append(res)\n        return ans\n","author":"牧瀬 紅莉栖","submissionId":"611228588"},[]]},{"1347":[{"id":"1347","fileName":"611228733.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dc = defaultdict(list)\n        for i,j in enumerate(nums):\n            dc[j].append(i)\n        n = len(nums)\n        res = []\n        for i in queries:\n            v = nums[i]\n            if len(dc[v]) == 1:\n                res.append(-1)\n            else:\n                inx = bisect.bisect_left(dc[v], i)\n                a, b = i - (dc[v][inx-1] if inx else (dc[v][-1]-n)), (dc[v][inx+1] if inx+1 < len(dc[v]) else (dc[v][0] + n)) - i\n                res.append(min(a,b))\n        return res","author":"丁飞","submissionId":"611228733"},[]]},{"1348":[{"id":"1348","fileName":"611227284.txt","sourceCode":"using namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vll> vvll;\ntypedef vector<vvll> vvvll;\ntypedef vector<pii> vpii;\ntypedef vector<vpii> vvpii;\ntypedef vector<pll> vpll;\ntypedef vector<vpll> vvpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<vd> vvd;\n#define yn(ans) printf(\"%sn\", (ans)?\"Yes\":\"No\");\n#define YN(ans) printf(\"%sn\", (ans)?\"YES\":\"NO\");\ntemplate<class T> bool chmax(T &a, T b) {\n\tif (a >= b) return false;\n\ta = b; return true;\n}\ntemplate<class T> bool chmin(T &a, T b) {\n\tif (a <= b) return false;\n\ta = b; return true;\n}\n#define FOR(i, s, e, t) for ((i) = (s); (i) < (e); (i) += (t)) \n#define REP(i, e) for (int i = 0; i < (e); ++i) \n#define REP1(i, s, e) for (int i = (s); i < (e); ++i)\n#define RREP(i, e) for (int i = (e); i >= 0; --i)\n#define RREP1(i, e, s) for (int i = (e); i >= (s); --i)\n#define all(v) v.begin(), v.end()\n#define pb push_back\n#define qb pop_back\n#define pf push_front\n#define qf pop_front\n#define maxe max_element\n#define mine min_element\nll inf = 1e18;\n#define DEBUG printf(\"%dn\", __LINE__); fflush(stdout);\ntemplate<class T> void print(vector<T> &v, bool withSize = false) {\n\tif (withSize) cout << v.size() << endl;\n\tREP(i, v.size()) cout << v[i] << \" \"; \n\tcout << endl;\n}\nmt19937_64 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vi> m;\n        int N = nums.size();\n        REP(i, N) m[nums[i]].pb(i);\n\n        vi ans;\n        REP(i, queries.size()) {\n            int p = queries[i];\n            auto &q = m[nums[p]];\n            int id = lower_bound(all(q), p) - q.begin();\n            if (q.size() == 1) ans.pb(-1);\n            else {\n                int left = id == 0 ? N + p - q.back() : p - q[id - 1];\n                int right = id + 1 == q.size() ? N + q[0] - p : q[id + 1] - p;\n                ans.pb(min(left, right));\n            }\n        }\n        return ans;\n    }\n};","author":"Relaxed Visvesvaraya","submissionId":"611227284"},[]]},{"1349":[{"id":"1349","fileName":"611228989.txt","sourceCode":"#include<bits/stdc++.h>\n// #pragma GCC optimize(\"Ofast,no-stack-protector,fast-math\",3)\n#define cln cerr<<\"Line:   \"<<__LINE__<<\"    \"\n#define pct __builtin_popcountll\n#define ctz __builtin_ctzll\n#define mkp make_pair\n#define MST(x) memset(x,0,sizeof(x))\n#define all(x) x.begin(),x.end()\nusing namespace std;\nconstexpr int N=(1<<21)+100,_g=3,M1=1e9+7,M2=1e9+9,M=M1;\nusing ll=long long;\nnamespace fast_io{\n    char buf[N+10],*p1,*p2,c;\n#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2))?EOF:*p1++\ntemplate<typename _Tp>\n    void read(_Tp &x){\n        int f=0;for(c=gc;c<48;c=gc)f^=c=='-';\n        for(x=0;c>47;x=(x<<1)+(x<<3)+(48^c),c=gc);\n        if(f)x=-x;\n    }\ntemplate<typename _Tp,typename..._tps>\n    void read(_Tp &x,_tps&...y){read(x),read(y...);}\n    char ob[N+100],stk[505];int tp,ot;\n    void fls(){fwrite(ob,1,ot,stdout),ot=0;}\n    int cntt;\ntemplate<typename _Tp>\n    static inline void write(_Tp x,char c){\n        if(!cntt)atexit(fls),cntt=1;\n        while(x>9)stk[++tp]=48^(x%10),x/=10;\n        for(ob[ot++]=48^x;tp;ob[ot++]=stk[tp--]);\n        ob[ot++]=c;if(ot>N)fls();\n    }\n}using fast_io::read;\nusing fast_io::write;\n#define pli pair<ll,int>\n#define pii pair<int,int>\nusing ul=unsigned long long;\ntemplate<typename tp1,typename tp2>\n    void ckmx(tp1 &x,const tp2 &y){if(x<y)x=y;}\ntemplate<typename tp1,typename tp2>\n    void ckmn(tp1 &x,const tp2 &y){x>y?x=y:0;}\nvoid add(int &x,int y){(x+=y)>=M?x-=M:0;}\nvoid del(int &x,int y){(x-=y)<0?x+=M:0;}\nvoid add(int &x,ul y,int z){x=(y*z+x)%M;}\nvoid del(int &x,ul y,int z){(x-=y*z%M)<0&&(x+=M);}\nconstexpr int qp(ll a,ll x=M-2){\n    int res=1;for(;x;x>>=1,a=a*a%M)\n        (x&1)&&(res=a*res%M);return res;\n}\nconstexpr int qp(ll a,ll x,int M){\n    int res=1;for(;x;x>>=1,a=a*a%M)\n        (x&1)&&(res=a*res%M);return res;\n}\nstruct NTP{};\ntemplate<typename tp1,typename tp2,int N>\nstruct Htb{\n    static constexpr int M=1e7+19;\n    int hd[M+3],to[N],ct;\n    tp1 ed[N];tp2 w[N];\n    static int hc(ul v){\n        v^=v<<13,v^=v>>7;\n        return (v^(v<<17))%M;\n    }\n    void ins(tp1 x,tp2 y){\n        int &p=hd[hc(x)];\n        ed[++ct]=x,to[ct]=p;\n        w[p=ct]=y;\n    }\n    int count(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return 1;\n        return 0;\n    }\n    pair<tp2,bool>find(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return mkp(w[i],true);\n        return mkp(tp2(),false);\n    }\n    int operator[](tp1 x){\n        int &p=hd[hc(x)];\n        for(int i=p;i;i=to[i])\n            if(ed[i]==x)return i;\n        ed[++ct]=x,to[ct]=p;\n        return p=ct;\n    }\n    void clear(){while(ct)hd[hc(ed[ct--])]=0;}\n};\nnamespace MATH{\n    vector<int>jc,nv,_nv;\n    int dv2(int x){return x&1?x+M>>1:x>>1;}\n    int C(int n,int m){\n        assert(m<=n);\n        return 1ll*jc[n]*nv[m]%M*nv[n-m]%M;\n    }\n    int P(int n,int m){\n        return 1ll*jc[n]*nv[n-m]%M;\n    }\n    int D(int n,int m){\n        if(n<0||m<0)return 0;\n        if(!n)return 1;\n        if(!m)return 0;\n        return C(n+m-1,m-1);\n    }\n    void init(int n){\n        int x;\n        jc.resize(n+2);\n        jc[0]=jc[1]=1;\n        nv=_nv=jc;\n        for(x=2;x<=n;++x){\n            jc[x]=1ll*x*jc[x-1]%M;\n            _nv[x]=ll(M-M/x)*_nv[M%x]%M;\n            nv[x]=1ll*nv[x-1]*_nv[x]%M;\n        }\n    }\n}\nstruct DET{\n    int a[3005][3005],n;\n    int run(){\n        if(!n)return 1;\n        int x,y,z,k,res=1;\n        for(x=1;x<=n;++x){\n            for(y=x;y<=n&&!a[y][x];++y);\n            if(y>n)return 0;\n            if(y>x){\n                for(k=1;k<=n;++k)swap(a[x][k],a[y][k]);\n                res&&(res=M-res); \n            }\n            k=qp(a[x][x]);\n            res=1ll*res*a[x][x]%M;\n            for(z=1;z<=n;++z)\n                a[x][z]=1ll*a[x][z]*k%M;\n            for(y=1;y<=n;++y)\n                if(x!=y){\n                    k=a[y][x];\n                    for(z=1;z<=n;++z)\n                        del(a[y][z],a[x][z],k);\n                }\n        }\n        for(x=1;x<=n;++x)\n            res=1ll*res*a[x][x]%M;\n        return res;\n    }\n}det;\nll Gcd(ll x,ll y){\n    if(!x||!y)return x|y;\n    int k=min(ctz(x),ctz(y));\n    ll d;y>>=ctz(y);\n    while(x){\n        x>>=ctz(x),d=x-y;\n        if(x<y)y=x;\n        if(d<0)x=-d;\n        else x=d;\n    }return y<<k;\n}\nusing ll=long long;\nusing ul=unsigned long long;\nconstexpr int bceil(int n){return 1<<(std::__lg(n-1)+1);}\ntemplate<int mod>struct NTT{\n    constexpr int dil(int x){return x>>31?x+mod:x;}\n    constexpr int mul(ul x,int y){return x*y%mod;}\n    constexpr int qpow(int a,int b,int r=1){for(;b;a=mul(a,a),b>>=1){r=b&1?mul(r,a):r;}return r;}\n    int w[N>>1],wI[N>>1];\n    void init(int n){\n        int l=bceil(n)>>1;w[0]=wI[0]=1;\n        for(int i=1;i<l;i<<=1){w[i]=qpow(_g,((mod-1)>>2)/i),wI[i]=qpow(_g,mod-1-((mod-1)>>2)/i);}\n        for(int i=1;i<l;++i){w[i]=mul(w[i&(i-1)],w[i&-i]),wI[i]=mul(wI[i&(i-1)],wI[i&-i]);}\n    }\n    void dif(int *f,int lim){\n        for(int l=lim>>1,r=lim;l;l>>=1,r>>=1)\n            for(int*j=f,*o=w;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    (x=*k)>=mod&&(x-=mod),y=mul(k[l],*o),*k=x+y,k[l]=x-y+mod;\n    }\n    void dit(int *f,int lim){\n        for(int l=1,r=2;l<lim;l<<=1,r<<=1)\n            for(int*j=f,*o=wI;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    x=*k,y=mod-k[l],(*k=x-y)<0&&(*k+=mod),k[l]=mul(x+y,*o);\n        for(int i=0,p=mod-(mod-1)/lim;i<lim;++i)f[i]=1ll*f[i]*p%mod;\n    }\n    void mul(int *f,int *g,int n){\n        dif(f,n),dif(g,n);\n        for(int i=0;i<n;++i)f[i]=1ll*f[i]*g[i]%M;\n        dit(f,n);\n    }\n    void mul(int *f,int n){\n        dif(f,n);int i;\n        for(i=0;i<n;++i)f[i]=1ll*f[i]*f[i]%M;\n        dit(f,n);\n    }\n};\nNTT<M>ntt;\nusing namespace MATH;\nmt19937_64 rg(random_device{}());\nusing LL=__int128_t;\nusing vt=vector<int>;\nusing vl=vector<ll>;\nusing ld=double;\nconst ll INF=1e18;\nint T,n,m,a[N],b[N],to[N];\n// int main(){\n//     ios::sync_with_stdio(false),cin.tie(0);\n//     int i,j,k,l,r,x,y,z;\n//     return 0;\n// }\nvoid rmn(){\n    int i,j,k,l,r,x,y,z;\n    return;\n}\nvt lk[N];\nclass Solution {\n    public:\n        vector<int> solveQueries(vector<int>& a, vector<int>& qq) {\n            n=a.size();int i;\n            for(i=0;i<n;++i)b[i]=1e9;\n            for(i=0;i<n;++i)to[a[i]]=-1;\n            for(i=0;i<n;++i){\n                if(to[a[i]]>=0){\n                    ckmn(b[i],i-to[a[i]]);\n                    ckmn(b[to[a[i]]],i-to[a[i]]);\n                }to[a[i]]=i;\n            }\n            for(i=0;i<n;++i)\n                if(to[a[i]]>i){\n                    ckmn(b[i],i+n-to[a[i]]);\n                    ckmn(b[to[a[i]]],i+n-to[a[i]]);\n                }\n            for(i=0;i<n;++i)if(b[i]>n)b[i]=-1;\n            vt ac;\n            for(int v:qq)ac.push_back(b[v]);\n            return ac;\n        }\n    };","author":"EnofTaiPeople","submissionId":"611228989"},[]]},{"1350":[{"id":"1350","fileName":"1575139618.txt","sourceCode":"class Solution:\n    def solveQueries(self, a: List[int], q: List[int]) -> List[int]:\n        n = len(a)\n        m = len(q)\n        s = {}\n        prev = [-1]*n \n        nex = [-1]*n \n        first = [0]*(10**6+1)\n        last = [0]*(10**6+1)\n        res = [-1]*m\n        for i in range(n):\n            if a[i] not in s:\n                s[a[i]] = i\n                first[a[i]] = i\n            else:\n                prev[i] = s[a[i]]\n                s[a[i]] = i\n        \n        s = {}\n        for i in range(n-1,-1,-1):\n            if a[i] not in s:\n                s[a[i]] = i\n                last[a[i]] = i\n            else:\n                nex[i] = s[a[i]]\n                s[a[i]] = i\n        print(prev)\n        print(nex)\n        for i in range(m):\n            pos = q[i]\n            c = a[pos]\n            # print(q[i],pos, prev[pos], nex[pos])\n            if prev[pos] == -1 and nex[pos] == -1:\n                # if i == 2:\n                #     print(q[i],pos, prev[pos], nex[pos])\n                res[i] = -1\n            else:\n                # if i == 2:\n                #     print(\"ok\")\n                if prev[pos] > -1 and nex[pos] > -1:\n                    res[i] = min(pos - prev[pos], nex[pos] - pos)\n                if prev[pos] == -1 and nex[pos] > -1:\n                    res[i] = min(nex[pos] - pos, n - last[c] + pos)\n                if prev[pos] > -1 and nex[pos] == -1:\n                    res[i] = min(pos - prev[pos], n -pos + first[c] )\n        return res\n                \n        \n        ","author":"nazeeeef007","submissionId":"1575139618"},[]]},{"1352":[{"id":"1352","fileName":"611229035.txt","sourceCode":"class Solution:\n    def solveQueries(self, a: List[int], queries: List[int]) -> List[int]:\n        n = len(a)\n        q = len(queries)\n        a += a\n        pos = defaultdict(list)\n        for i, num in enumerate(a):\n            pos[num].append(i)\n        ans = [inf] * q\n        for i in range(q):\n            v = a[queries[i]]\n            if len(pos[v]) <= 1:\n                continue\n            j = bisect_left(pos[v], queries[i] + 1)\n            if j < len(pos[v]) and pos[v][j] != queries[i] + n:\n                ans[i] = min(ans[i], pos[v][j] - queries[i])\n            j = bisect_left(pos[v], queries[i] + n) - 1\n            if j >= 0 and pos[v][j] != queries[i]:\n                ans[i] = min(ans[i], -pos[v][j] + (queries[i] + n))\n        return [num if num != inf else -1 for num in ans]","author":"一只包zi","submissionId":"611229035"},[]]},{"1353":[{"id":"1353","fileName":"611228130.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        map<int, int> pos;\n        vector<int> pre(n), nxt(n);\n        for(int i = 0; i < n; ++i) pos[nums[i]] = -1;\n        for(int j = 0; j < 2; ++j) {\n            for(int i = 0; i < n; ++i) {\n                if(pos[nums[i]] != -1) pre[i] = pos[nums[i]];\n                pos[nums[i]] = i;\n            }\n        }\n        for(int i = 0; i < n; ++i) pos[nums[i]] = -1;\n        for(int j = 0; j < 2; ++j) {\n            for(int i = n - 1; i >= 0; --i) {\n                if(pos[nums[i]] != -1) nxt[i] = pos[nums[i]];\n                pos[nums[i]] = i;\n            }\n        }\n        vector<int> ans(m);\n        for(int i = 0; i < m; ++i) {\n            int x = queries[i];\n            int l = pre[x], r = nxt[x];\n            if(l == x && r == x) ans[i] = -1;\n            else {\n                if(x <= l) l -= n;\n                if(r <= x) r += n;\n                ans[i] = min(x - l, r - x);\n            }\n        }\n        return ans;\n    }\n};","author":"rui_er","submissionId":"611228130"},[]]},{"1354":[{"id":"1354","fileName":"611229231.txt","sourceCode":"import string\nfrom sortedcontainers import SortedList\nfrom collections import defaultdict, deque, Counter\nfrom bisect import bisect_left, bisect_right\nfrom typing import List, Set, Tuple, Optional\nfrom itertools import pairwise, permutations, combinations, groupby\nfrom heapq import heappush, heappop\nfrom random import shuffle\nfrom functools import cmp_to_key, lru_cache\nfrom fractions import Fraction\nfrom math import gcd, lcm\n\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        mp = defaultdict(list)\n        for i, x in enumerate(nums):\n            mp[x] += [i, n + i, n + n + i]\n        for k in mp.keys():\n            mp[k].sort()\n        ans = []\n        for i in queries:\n            x = nums[i]\n            v = mp[x]\n            val = 10 ** 9\n            p = bisect_left(v, i + n)\n            if p + 1 < len(v):\n                val = min(val, v[p + 1] - v[p])\n            if p - 1 >= 0:\n                val = min(val, v[p] - v[p - 1])\n            if val >= n:\n                val = -1\n            ans.append(val)\n        return ans\n","author":"Ujimatsu_Chiya","submissionId":"611229231"},[]]},{"1355":[{"id":"1355","fileName":"611229100.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = dict()\n        for i, x in enumerate(nums):\n            if x not in d:\n                d[x] = SortedList()\n            d[x].add(i)\n        ans = []\n        n = len(nums)\n        for q in queries:\n            if len(d[nums[q]]) == 1:\n                ans.append(-1)\n            else:\n                t = d[nums[q]].bisect_left(q)\n                cur = float('inf')\n                if t > 0:\n                    cur = min(cur, d[nums[q]][t] - d[nums[q]][t - 1])\n                else:\n                    cur = min(cur, n + d[nums[q]][0] - d[nums[q]][-1])\n                if t + 1 < len(d[nums[q]]):\n                    cur = min(cur, d[nums[q]][t + 1] - d[nums[q]][t])\n                else:\n                    cur = min(cur, n + d[nums[q]][0] - d[nums[q]][-1])\n                ans.append(cur)\n        return ans","author":"Shaaou","submissionId":"611229100"},[]]},{"1357":[{"id":"1357","fileName":"611229366.txt","sourceCode":"const int inf = 0x3f3f3f3f;\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& queries) {\n        int n = a.size();\n        unordered_map<int, int> lst, lft;\n        vector<int> pre(n, -1), nxt(n, -1);\n        for(int i=0; i<n; ++i){\n            if(lst.count(a[i])){\n                nxt[lst[a[i]]] = i;\n                pre[i] = lst[a[i]];\n            }\n            if(!lft.count(a[i])){\n                lft[a[i]] = i;\n            }\n            lst[a[i]] = i;\n        }\n        vector<int> ret;\n        for(int v : queries){\n            int cur = inf;\n            if(pre[v] != -1){\n                cur = min(cur, v - pre[v]);\n            } else if(lst[a[v]] != v){\n                cur = min(cur, v + n - lst[a[v]]);\n            }\n            if(nxt[v] != -1){\n                cur = min(cur, nxt[v] - v);\n            } else if(v != lft[a[v]]){\n                cur = min(cur, lft[a[v]] + n - v);\n            }\n            if(cur == inf)  cur = -1;\n            ret.push_back(cur);\n        }\n        return ret;\n    }\n};","author":"Hongrock","submissionId":"611229366"},[]]},{"1358":[{"id":"1358","fileName":"611229395.txt","sourceCode":"use std::collections::HashMap;\n\nimpl Solution {\n    pub fn solve_queries(nums: Vec<i32>, queries: Vec<i32>) -> Vec<i32> {\n        let n = nums.len();\n        let mut num_positions = HashMap::new();\n        for (i, &num) in nums.iter().enumerate() {\n            num_positions.entry(num).or_insert(vec![]).push(i as i32);\n        }\n        let mut ans = Vec::with_capacity(queries.len());\n        for &query in &queries {\n            let value = nums[query as usize];\n            let positions = num_positions.get(&value).unwrap();\n            let idx = positions.binary_search(&(query as i32)).unwrap() as i32;\n            let mut min_diff = i32::MAX;\n            // prev\n            if idx > 0 {\n                min_diff = query - positions[(idx - 1) as usize];\n            } else if positions.len() > 1 {\n                min_diff = query + n as i32 - positions[positions.len() - 1];\n            }\n            // next\n            if idx < positions.len() as i32 - 1 {\n                min_diff = min_diff.min(positions[(idx + 1) as usize] - query);\n            } else if positions.len() > 1 {\n                min_diff = min_diff.min(positions[0] + n as i32 - query);\n            }\n            if min_diff == i32::MAX {\n                min_diff = -1;\n            }\n            ans.push(min_diff);\n        }\n        ans\n    }\n}","author":"weiqizheng","submissionId":"611229395"},[]]},{"1359":[{"id":"1359","fileName":"611229607.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dic = dict()\n        n = len(nums)\n        for i, num in enumerate(nums):\n            if num not in dic:\n                dic[num] = []\n            dic[num].append(i)\n        \n        idx_L = [-1] * n\n        \n        for L in dic.values():\n            if len(L) > 1:\n                m = len(L)\n                for i in range(m):\n                    left = L[(i - 1) % m]\n                    right = L[(i + 1) % m]\n                    dist = min((L[i] - left + n) % n, (right - L[i] + n) % n)\n                    idx_L[L[i]] = dist\n        \n        ans = []\n        for q in queries:\n            ans.append(idx_L[q])\n        return ans\n        \n                \n        ","author":"Admiring ShockleyZns","submissionId":"611229607"},[]]},{"1360":[{"id":"1360","fileName":"611229135.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& queries) {\n        map<int, vector<int>> pos;\n        int n = a.size();\n        for (int i = 0; i < n; ++i) {\n            pos[a[i]].push_back(i);\n        }\n        vector<int> ret;\n        const int INF = 1e9;\n        auto get = [&](int x) {\n            return min(x, n - x);\n        };\n        for (auto& i : queries) {\n            int x = a[i];\n            int cur = INF;\n            auto it = upper_bound(pos[x].begin(), pos[x].end(), i);\n            if (it != pos[x].end()) cur = min(cur, get(abs(*it - i)));\n            auto it2 = lower_bound(pos[x].begin(), pos[x].end(), i);\n            if (it2 != pos[x].begin()) {\n                --it2;\n                cur = min(cur, get(abs(i - *it2)));\n            }\n            if (!pos[x].empty()) {\n                if (pos[x].back() != i) cur = min(cur, get(abs(pos[x].back() - i)));\n                if (pos[x][0] != i) cur = min(cur, get(abs(pos[x][0] - i)));\n            }\n            if (cur == INF) cur = -1;\n            ret.push_back(cur);\n        }\n        return ret;\n    }\n};","author":"cuiaoxiang","submissionId":"611229135"},[]]},{"1362":[{"id":"1362","fileName":"611229862.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();vector<int> ans(n,-1);unordered_map<int,vector<int>> gra;\n        for(int i{0};i<n;i++)gra[nums[i]].push_back(i);\n        for(auto&p:gra){\n        \tvector<int>& a=p.second;\n        \tif(a.size()<2)continue;\n        \tranges::sort(a.begin(),a.end());int sz=a.size();\n        \tfor(int j{0};j<sz;j++){\n        \t\tint cur=a[j],l,r;\n        \t\tif(j==0){\n        \t\t\tl=a[0]+n-a[sz-1];r=a[1]-a[0];\n        \t\t}else if(j==sz-1){\n        \t\t\tl=a[sz-1]-a[sz-2];r=a[0]+n-a[sz-1];\n        \t\t}else {\n        \t\t\tl=a[j]-a[j-1];r=a[j+1]-a[j];\n        \t\t}ans[cur]=min(l,r);\n        \t}\n        }vector<int> p;for(int i:queries)p.push_back(ans[i]);\n        return p;\n    }\n};","author":"forgo","submissionId":"611229862"},[]]},{"1363":[{"id":"1363","fileName":"611229612.txt","sourceCode":"from typing import *\n\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        ans = [-1] * n\n\n        d = {}\n        for i in range(n):\n            d[nums[i]] = i - n\n        for i in range(n):\n            if d[nums[i]] != i - n:\n                ans[i] = i - d[nums[i]]\n            d[nums[i]] = i\n\n        d = {}\n        for i in reversed(range(n)):\n            d[nums[i]] = i + n\n        for i in reversed(range(n)):\n            if d[nums[i]] != i + n:\n                w = d[nums[i]] - i\n                if ans[i] == -1 or ans[i] > w:\n                    ans[i] = w\n            d[nums[i]] = i\n        return [ans[q] for q in queries]","author":"PyIsBestLang","submissionId":"611229612"},[]]},{"1364":[{"id":"1364","fileName":"611229659.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        def get_d(x, y):\n            if len(c[x]) == 1:\n                return -1\n            idx = bisect.bisect_left(c[x], y)\n            left = (idx - 1 + len(c[x])) % len(c[x])\n            right = (idx + 1) % len(c[x])\n            left = (c[x][idx] + n - c[x][left]) % n\n            right = (c[x][right] + n - c[x][idx]) % n\n            return min(left, right)\n            \n        n = len(nums)\n        c = defaultdict(list)\n        for i, j in enumerate(nums):\n            c[j].append(i)\n        res = []\n        for i in queries:\n            res.append(get_d(nums[i], i))\n        return res\n        \n        ","author":"iofu728","submissionId":"611229659"},[]]},{"1365":[{"id":"1365","fileName":"611229945.txt","sourceCode":"constexpr long long inf = INT_MAX >> 1;\nconstexpr double eps = 1e-9;\n\nconstexpr int N = 2e5 + 10;\nconstexpr int M = 1000000007; // 998244343;\n\nint lc_init = ([]() {\n}(), 0);\n#define eput(...) 218\n\n#line 10\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& queries) {\n        constexpr int N = 1e6;\n        static int last[N];\n        for (auto x: a) last[x] = -1;\n        int n = a.size();\n        vector<int> b(n + 1, INT_MAX);\n        for (int i = 0; i < 2 * n; ++i) {\n            int j = last[a[i % n]];\n            if (j != -1) {\n                eput(i % n, j % n, i - j);\n                b[i % n] = min(b[i % n], i - j);\n                b[j % n] = min(b[j % n], i - j);\n            }\n            last[a[i % n]] = i;\n        }\n        for (auto &x: b)\n            if (x >= n) x = -1;\n        vector<int> ans;\n        for (auto x: queries)\n            ans.push_back(b[x]);\n        return ans;\n    }\n};","author":"sfiction","submissionId":"611229945"},[]]},{"1366":[{"id":"1366","fileName":"611228874.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        nums += nums\n        last = collections.defaultdict(int)\n        n = len(nums)\n        dis = [float(\"inf\")]*n\n        for i in range(n):\n            if nums[i] in last:\n                dis[i] = i-last[nums[i]]\n            last[nums[i]] = i\n        last.clear()\n        for i in range(n-1, -1, -1):\n            if nums[i] in last:\n                dis[i] = min(dis[i], last[nums[i]]-i)\n            last[nums[i]] = i\n        ans = []\n        for c in queries:\n            d = min(dis[c], dis[c+n//2])\n            if d == n//2:\n                ans.append(-1)\n            else:\n                ans.append(d)\n        return ans","author":"孙慢慢","submissionId":"611228874"},[]]},{"1367":[{"id":"1367","fileName":"611230026.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        idxs = collections.defaultdict(list)\n        for i, v in enumerate(nums):\n            idxs[v].append(i)\n        res = []\n        for q in queries:\n            v = nums[q]\n            cur_idx = idxs[v]\n            if len(cur_idx) == 1:\n                res.append(-1)\n                continue\n            m = len(cur_idx)\n            i = bisect.bisect_left(cur_idx, q)\n            a = (cur_idx[i] + n - cur_idx[(i - 1 + m) % m]) % n\n            b = (cur_idx[(i + 1) % m] - cur_idx[i] + n) % n\n            res.append(min(a, b))\n        return res","author":"Fzldq","submissionId":"611230026"},[]]},{"1368":[{"id":"1368","fileName":"611230128.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>> m;\n        int n=nums.size();\n        for(int i=0;i<n;++i){\n            m[nums[i]].push_back(i);\n        }\n        vector<int> res;\n        for(int q:queries){\n            int v=nums[q];\n            auto& a=m[v];\n            auto p=lower_bound(a.begin(),a.end(),q);\n            int r=-1;\n            if(p!=a.begin()){\n                auto z=p;\n                --z;\n                r=q-(*z);\n                r=min(r,n-r);\n            }\n            else{\n                int k=a.back();\n                if(k!=q){\n                    int d=abs(k-q);\n                    d=min(d,n-d);\n                    r=d;\n                }\n            }\n            ++p;\n            if(p!=a.end()){\n                int d=*p-q;\n                d=min(d,n-d);\n                if(r==-1||d<r){\n                    r=d;\n                }\n            }\n            else{\n                int k=a[0];\n                if(k!=q){\n                    int d=abs(k-q);\n                    d=min(d,n-d);\n                    if(r==-1||d<r){\n                        r=d;\n                    }\n                }\n            }\n            res.push_back(r);\n        }\n\n\n        return res;\n    }\n};","author":"w285714","submissionId":"611230128"},[]]},{"1369":[{"id":"1369","fileName":"611230236.txt","sourceCode":"import java.util.*;\n\nclass Solution extends U {\n\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, TreeSet<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.computeIfAbsent(nums[i], v -> new TreeSet<>()).add(i);\n        }\n        int n = nums.length;\n        List<Integer> ans = new ArrayList<>();\n        for (int i : queries) {\n            int v = nums[i];\n            TreeSet<Integer> set = map.get(v);\n            Integer f = set.floor(i - 1), c = set.ceiling(i + 1);\n            int x = Integer.MAX_VALUE;\n            if (f != null) {\n                x = min(x, i - f);\n            }\n            if (c != null) {\n                x = min(x, c - i);\n            }\n            int t = set.first();\n            if (t != i) {\n                x = min(x, n - (i - t));\n            }\n            t = set.last();\n            if (t != i) {\n                x = min(x, n - (t - i));\n            }\n            ans.add(x == Integer.MAX_VALUE ? -1 : x);\n        }\n        return ans;\n    }\n\n\n}\n\nclass U {                                                                                                                                                                                                                WU out=new WU();class WU{private java.io.OutputStream out=System.out;WU print(byte b){try{out.write(b);}catch(Exception e){}return this;}WU print(char c){return print((byte)c);}WU print(int x){return print(String.valueOf(x));}WU print(long x){return print(String.valueOf(x));}WU print(double x){return print(String.valueOf(x));}WU print(String s){for(int i=0;i<s.length();i++)print((byte)s.codePointAt(i));return this;}void writeln(){print((byte)'n');}void println(byte b){print(b).writeln();}void println(char c){print(c).writeln();}void println(int x){print(x).writeln();}void println(long x){print(x).writeln();}void println(double x){print(x).writeln();}void println(String s){print(s).writeln();}void println(Object o){deepPrint(o,true);}private void deepPrint(Object o,boolean f){if(o==null){print(f?\"nulln\":\"null\");return;}Class<?>c=o.getClass();if(c.isArray()){if(o instanceof Object[]){Object[]t=(Object[])o;int n=t.length;boolean b=f&&n>0&&t[0]!=null;print(b?\"[n\":\"[\");for(int i=0;i<n;i++){deepPrint(t[i],false);if(i<n-1)print(b?\", n\":\", \");else if(b)writeln();}print(\"]\");}else{print(o instanceof byte[]?Arrays.toString((byte[])o):o instanceof short[]?Arrays.toString((short[])o):o instanceof int[]?Arrays.toString((int[])o):o instanceof long[]?Arrays.toString((long[])o):o instanceof char[]?Arrays.toString((char[])o):o instanceof float[]?Arrays.toString((float[])o):o instanceof double[]?Arrays.toString((double[])o):Arrays.toString((boolean[])o));}}else if(o instanceof Collection){Collection<?>t=(Collection<?>)o;print(\"[\");int i=0;for(Object v:t){deepPrint(v,false);if(i<t.size()-1)print(\", \");i++;}print(\"]\");}else if(o instanceof Map){Map<?,?>t=(Map<?,?>)o;print(!t.isEmpty()&&f?\"{n\":\"{\");int i=0;for(Map.Entry<?,?>v:t.entrySet()){deepPrint(v.getKey(),false);print(\" = \");deepPrint(v.getValue(),false);if(++i<t.size())print(f?\", n\":\", \");else if(f)writeln();}print(\"}\");}else{print(o.toString());}if(f)writeln();}}int min(int a,int b){return a>b?b:a;}int min(int...args){int ans=Integer.MAX_VALUE;for(int v:args)if(ans>v)ans=v;return ans;}long min(long a,long b){return a>b?b:a;}long min(long...args){long ans=Long.MAX_VALUE;for(long v:args)if(ans>v)ans=v;return ans;}double min(double a,double b){return a>b?b:a;}double min(double...args){double ans=Double.MAX_VALUE;for(double v:args)if(ans>v)ans=v;return ans;}int max(int a,int b){return a<b?b:a;}int max(int...args){int ans=Integer.MIN_VALUE;for(int v:args)if(ans<v)ans=v;return ans;}long max(long a,long b){return a<b?b:a;}long max(long...args){long ans=Long.MIN_VALUE;for(long v:args)if(ans<v)ans=v;return ans;}double max(double a,double b){return a<b?b:a;}double max(double...args){double ans=Double.MIN_VALUE;for(double v:args)if(ans<v)ans=v;return ans;}int abs(int a){return a<0?-a:a;}long abs(long a){return a<0?-a:a;}double abs(double a){return a<0?-a:a;}\n}","author":"lyongwolf","submissionId":"611230236"},[]]},{"1370":[{"id":"1370","fileName":"611230317.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        pos = defaultdict(list)\n        n = len(nums)\n        dis = [-1] * n\n        for i, x in enumerate(nums):\n            if pos[x]:\n                dis[i] = i - pos[x][-1]\n                if dis[pos[x][-1]] == -1 or dis[pos[x][-1]] > dis[i]:\n                    dis[pos[x][-1]] = dis[i]\n            pos[x].append(i)\n        for p in pos.values():\n            i, j = p[0], p[-1]\n            if i != j:\n                dis[i] = min(dis[i], n - j + i)\n                dis[j] = min(dis[j], n - j + i)\n        return [dis[i] for i in queries]\n        ","author":"醉里挑灯看剑","submissionId":"611230317"},[]]},{"1371":[{"id":"1371","fileName":"611230004.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        v2in = collections.defaultdict(list)\n        for i, v in enumerate(nums) :\n            v2in[v].append(i)\n        \n        to_ret = []\n        for qi in queries :\n            vn = nums[qi]\n            if len(v2in[vn]) == 1 :\n                to_ret.append(-1)\n                continue\n            \n            pv = bisect.bisect(v2in[vn], qi-.1)\n            # print(v2in[vn], pv, vn)\n            dis1 = abs(v2in[vn][pv] - v2in[vn][pv-1])\n            dis2 = abs(v2in[vn][pv] - v2in[vn][(pv+1)%len(v2in[vn])])\n            dis1 = min(dis1, len(nums)-dis1)\n            dis2 = min(dis2, len(nums)-dis2)\n            to_ret.append(min(dis1, dis2))\n        return to_ret","author":"pku_erutan","submissionId":"611230004"},[]]},{"1372":[{"id":"1372","fileName":"611230409.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n\tn := len(nums)\n\tpos := map[int][]int{}\n\tfor i, x := range nums {\n\t\tpos[x] = append(pos[x], i)\n\t}\n\n\tans := make([]int, len(queries))\n\tfor i, q := range queries {\n\t\tx := nums[q]\n\t\tp := pos[x]\n\t\tif len(p) == 1 {\n\t\t\tans[i] = -1\n\t\t\tcontinue\n\t\t}\n\t\tidx := sort.Search(len(p), func(mid int) bool {\n\t\t\treturn p[mid] >= q\n\t\t})\n\t\tif idx == 0 {\n\t\t\tans[i] = min(p[1]-q, q+n-p[len(p)-1])\n\t\t} else if idx == len(p)-1 {\n\t\t\tans[i] = min(q-p[len(p)-2], p[0]+n-q)\n\t\t} else {\n\t\t\tans[i] = min(p[idx+1]-q, q-p[idx-1])\n\t\t}\n\t}\n\treturn ans\n}","author":"逍遥生","submissionId":"611230409"},[]]},{"1374":[{"id":"1374","fileName":"611230324.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        ix = {}\n        dx = {}\n        for i in range(n):\n            v = nums[i]\n            if v not in ix:\n                ix[v]=[]\n            ix[v].append(i)\n        rr = []\n        for q in queries:\n            v = nums[q]\n            \n            m = len(ix[v])\n            if m<=1: rr.append(-1)\n            else:\n                # print(ix[v])\n                i = bisect_left(ix[v], q)\n                ni=i-1\n                if ni<0: ni=m-1\n                r = abs(ix[v][ni]-q)\n                r = min(r, n-r)\n                ni = i+1\n                if ni>=m: ni=0\n                c = abs(ix[v][ni]-q)\n                c = min(c, n-c)\n                r = min(r, c)\n                rr.append(r)\n        return rr\n            \n        ","author":"82年的muggle","submissionId":"611230324"},[]]},{"1375":[{"id":"1375","fileName":"611230511.txt","sourceCode":"//by 72\n#include<bits/stdc++.h>\n#define pii pair<int, int>\n#define F(i, a, b) for(int i = (a); i <= (b); i ++)\n#define Fd(i, a, b) for(int i = (a); i >= (b); i --)\nusing namespace std;\n\ntemplate <typename T1, typename T2>\nostream& operator <<(ostream& out, pair<T1, T2> p) {\n    out << '(' << p.first << \", \" << p.second << ')';\n    return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, vector<T> v) {\n    cout << '[';\n    if (!v.empty()) cout << v[0];\n    for (int i = 1; i < (int)v.size(); i++) cout << \",\" << v[i];\n    cout << ']';\n    return out;\n}\n\ntypedef long long ll;\nconst int mod = 998244353;\nconst int inf = 1e9;\nconst bool test = true;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        vector<int> b;\n        int idx = 0;\n        map<int, int> mp;\n        for(auto x : a) b.push_back(x);\n        sort(b.begin(), b.end());\n        for(auto x : b) if(! mp[x]) mp[x] = ++ idx;\n        for(auto &x : a) x = mp[x];\n        vector<vector<int>> pos(idx + 1);\n\n        int n = a.size();\n        F(i, 0, n - 1) pos[a[i]].push_back(i);\n\n        vector<int> res;\n        for(auto x : q) {\n            if(pos[a[x]].size() == 1) {\n                res.push_back(-1);\n                continue;\n            }\n            int k = lower_bound(pos[a[x]].begin(), pos[a[x]].end(), x) - pos[a[x]].begin();\n            // cout << k << \"?\" << endl;\n            int lst = pos[a[x]][(k - 1 + pos[a[x]].size()) % pos[a[x]].size()];\n            int nxt = pos[a[x]][(k + 1) % pos[a[x]].size()];\n            int qaq = (x - lst + n) % n;\n            qaq = min(qaq, (lst - x + n) % n);\n            qaq = min(qaq, (nxt - x + n) % n);\n            qaq = min(qaq, (x - nxt + n) % n);\n            res.push_back(qaq);\n        }\n        return res;\n    }\n};","author":"Nanani","submissionId":"611230511"},[]]},{"1376":[{"id":"1376","fileName":"611230502.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        for (int i = 0; i < n; i++) nums.push_back(nums[i]);\n\n        int ans[n * 2];\n        for (int i = 0; i < n * 2; i++) ans[i] = 1e9;\n\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n * 2; i++) {\n            auto &vec = mp[nums[i]];\n            if (!vec.empty()) ans[i] = min(ans[i], i - vec.back());\n            vec.push_back(i);\n        }\n\n        mp.clear();\n        for (int i = n * 2 - 1; i >= 0; i--) {\n            auto &vec = mp[nums[i]];\n            if (!vec.empty()) ans[i] = min(ans[i], vec.back() - i);\n            vec.push_back(i);\n        }\n\n        vector<int> ret;\n        for (int x : queries) {\n            int t = min(ans[x], ans[x + n]);\n            if (t < n) ret.push_back(t);\n            else ret.push_back(-1);\n        }\n        return ret;\n    }\n};","author":"TsReaper","submissionId":"611230502"},[]]},{"1377":[{"id":"1377","fileName":"611230706.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dic = defaultdict(list)\n        for i, num in enumerate(nums):\n            dic[num].append(i)\n            \n        def cal(x, y):\n            if x > y:\n                x, y = y, x\n            \n            return min(y - x, x + len(nums) - y)\n        \n        ans = []\n        for q in queries:\n            num = nums[q]\n            if len(dic[num]) == 1:\n                ans.append(-1)\n                continue\n            idx = bisect_left(dic[num], q)\n            if idx == 0:\n                ans.append(min(cal(q, dic[num][idx + 1]), cal(q, dic[num][-1])))\n            elif idx == len(dic[num]) - 1:\n                ans.append(min(cal(q, dic[num][idx - 1]), cal(q, dic[num][0])))\n            else:\n                ans.append(min(cal(q, dic[num][idx - 1]), cal(q, dic[num][idx + 1])))\n        return ans","author":"sishenzhimu","submissionId":"611230706"},[]]},{"1378":[{"id":"1378","fileName":"611230211.txt","sourceCode":"import bisect\nfrom collections import defaultdict\nfrom typing import List\n\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        memo = defaultdict(list)\n        for idx, num in enumerate(nums):\n            memo[num].append(idx)\n\n        ans = []\n        n = len(nums)\n        for query in queries:\n            num = nums[query]\n            if len(memo[num]) == 1:\n                ans.append(-1)\n                continue\n            idx = bisect.bisect_left(memo[num], query)\n            if idx == 0:\n                ans.append(min(memo[num][1] - query, n + query - memo[num][-1]))\n            elif idx == len(memo[num]) - 1:\n                ans.append(min(query - memo[num][-2], n + memo[num][0] - query))\n            else:\n                ans.append(min(memo[num][idx + 1] - query, query - memo[num][idx - 1]))\n        return ans","author":"细菌小子","submissionId":"611230211"},[]]},{"1379":[{"id":"1379","fileName":"611230512.txt","sourceCode":"def min2(x, y):\n    return x if x < y else y\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        m = len(nums)\n        d = defaultdict(list)\n        for i, x in enumerate(nums):\n            d[x].append(i)\n        ans = []\n        for x in queries:\n            y = nums[x]\n            l = d[y]\n            n = len(l)\n            if n == 1:\n                ans.append(-1)\n            else:\n                idx = bisect_left(l, x)\n                r = l[idx + 1] - x if idx < n - 1 else l[0] + m - x\n                l = x - l[idx - 1] if idx > 0 else x + m - l[-1]\n                ans.append(min2(l, r))\n        return ans","author":"萨姆","submissionId":"611230512"},[]]},{"1380":[{"id":"1380","fileName":"611231036.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> f;\n        int n = nums.size();\n        int q = queries.size();\n        vector<int> ans(q, -1);\n        for(int i = 0; i < n; ++i)\n        {\n            f[nums[i]].push_back(i);\n            f[nums[i]].push_back(i+n);\n            f[nums[i]].push_back(i-n);\n        }\n        for(auto& [k, v]: f)\n        {\n            sort(v.begin(), v.end());\n        }\n        for(int i = 0; i < q; ++i)\n        {\n            int qr = queries[i];\n            auto& vec = f[nums[qr]];\n            auto it = upper_bound(vec.begin(), vec.end(), \n                qr);\n            auto it2 = lower_bound(vec.begin(), vec.end(),\n                qr);\n            int after = 1e9, before = 1e9;\n            if(it != vec.end())\n            {\n                after = *it - qr;\n            }\n            if(it2 != vec.begin())\n            {\n                before = qr - *(prev(it2));\n            }\n            int fuck = min(after, before);\n            if(fuck < n)\n            {\n                ans[i] = fuck;\n            }\n        }\n        return ans;\n    }\n};","author":"Boring Kepler7FY","submissionId":"611231036"},[]]},{"1381":[{"id":"1381","fileName":"611230545.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define maxn (int)(1e6 + 10)\n#define IOS ios::sync_with_stdio(0);\n#define FFF freopen(\"out\", \"w\", stdout);\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int> &nums, vector<int> &queries) {\n        vector<int> ans;\n        map<int, vector<int>> pos;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            int x = nums[i];\n            pos[x].push_back(i);\n        }\n        for (auto q : queries) {\n            int x = nums[q];\n            if (pos[x].size() == 1) {\n                ans.push_back(-1);\n            } else {\n                int p = lower_bound(pos[x].begin(), pos[x].end(), q) - pos[x].begin();\n                int tmp1 = 1 << 29;\n                int tmp2 = 1 << 29;\n                if (p+1 < pos[x].size()) {\n                    tmp1 = pos[x][p+1]-q;\n                } else {\n                    tmp1 = n-(q-pos[x][0]);\n                }\n\n                if (p > 0) {\n                    tmp2 = q-pos[x][p-1];\n                } else {\n                    tmp2 = n-(pos[x][pos[x].size()-1]-q);\n                }\n                ans.push_back(min(tmp1, tmp2));\n            }\n        }\n        return ans;\n    }\n};","author":"dydy","submissionId":"611230545"},[]]},{"1382":[{"id":"1382","fileName":"611230417.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = (int) nums.size();\n        int m = (int) queries.size();\n        unordered_map<int, vector<int>> pos;\n        for (int i = 0; i < n; ++i) {\n            int x = nums[i];\n            pos[x].push_back(i);\n        }\n        \n        \n        vector<int> res(m, -1);\n        \n        for (int i = 0; i < m; ++i) {\n            int p = queries[i];\n            int x = nums[p];\n            auto& V = pos[x];\n            int sz = (int) V.size();\n            if (sz == 1) {\n                continue;\n            }\n\n            auto it = lower_bound(V.begin(), V.end(), p);\n            \n            int pp = it - V.begin();\n            \n            \n            int ans = n + 123;\n            for (int j = -1; j < 2; j += 2) {\n                int k = (pp + j + sz) % sz;\n                if (k != pp) {\n                    int a = V[k], b = V[pp];\n                    if (a > b) {\n                        swap(a, b);\n                    }\n                    int d = min(b - a, a + n - b);\n                    ans = min(ans, d);\n                }\n            }\n            if (ans < n) {\n                res[i] = ans;\n            }\n        }\n        \n        return res;\n    }\n};","author":"gooday","submissionId":"611230417"},[]]},{"1383":[{"id":"1383","fileName":"611230839.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        g = defaultdict(list)\n        n = len(nums)\n        for i,v in enumerate(nums):\n            g[v].append(i)\n        ans = []\n        for i in queries:\n            a = g[nums[i]]\n            if len(a) == 1:\n                ans.append(-1)\n                continue\n            m = len(a)\n            p = bisect_left(a, i)\n            d = inf\n            if p:\n                d = min(d, a[p]-a[p-1])\n            else:\n                d = min(d, a[p]+n - a[-1])\n            if p == len(a)-1:\n                d = min(d, a[0]+n - a[p])\n            else:\n                d = min(d, a[p+1]-a[p])\n            ans.append(d)\n        return ans","author":"陆鸢","submissionId":"611230839"},[]]},{"1384":[{"id":"1384","fileName":"611231310.txt","sourceCode":"class Solution {\npublic:\n  vector<int> solveQueries(vector<int> &nums, vector<int> &queries) {\n    auto a = nums;\n    for (auto x : nums) {\n      a.emplace_back(x);\n    }\n    int n = a.size();\n    map<int, int> last;\n    vector<int> mi(n, INT_MAX);\n    for (int i = 0; i < n; ++i) {\n      if (last.find(a[i]) == last.end()) {\n        last[a[i]] = i;\n        continue;\n      }\n      mi[i] = min(mi[i], abs(i - last[a[i]]));\n      last[a[i]] = i;\n    }\n    last.clear();\n    for (int i = n - 1; i >= 0; --i) {\n      if (last.find(a[i]) == last.end()) {\n        last[a[i]] = i;\n        continue;\n      }\n      mi[i] = min(mi[i], abs(i - last[a[i]]));\n      last[a[i]] = i;\n    }\n    vector<int> ans;\n    for (auto x : queries) {\n      int ta = min(mi[x], mi[x + n / 2]);\n      if (ta == INT_MAX || ta == n / 2) {\n        ta = -1;\n      }\n      ans.emplace_back(ta);\n    }\n    return ans;\n  }\n};\n","author":"lnkkerst","submissionId":"611231310"},[]]},{"1386":[{"id":"1386","fileName":"611231281.txt","sourceCode":"class Solution {\n   public List<Integer> solveQueries(int[] nums, int[] queries) {\n        // 每个数值找到第一个左边和第一个右边\n        int[] mid = new int[nums.length * 3];\n        for (int i = 0; i < nums.length; i++) {\n            mid[i] = nums[i];\n            mid[i + nums.length] = nums[i];\n            mid[i + nums.length * 2] = nums[i];\n        }\n        int[] left = left(mid);\n        int[] right = right(mid);\n        List<Integer> ans = new ArrayList<>();\n        for (int q : queries) {\n            int idx = q + nums.length;\n            int a = -1;\n            int l = left[idx];\n            if (l != -1 && idx - l != nums.length) {\n                a = idx - l;\n            }\n            int r = right[idx];\n            if (r != -1 && r - idx != nums.length) {\n                if (a == -1) {\n                    a = r - idx;\n                } else {\n                    a = Math.min(a, r - idx);\n                }\n            }\n            ans.add(a);\n        }\n        return ans;\n\n\n    }\n\n    private int[] left(int[] nums) {\n        int[] left = new int[nums.length];\n        Map<Integer, Integer> count = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            left[i] = -1;\n            if (count.containsKey(nums[i])) {\n                left[i] = count.get(nums[i]);\n            }\n            count.put(nums[i], i);\n        }\n        return left;\n    }\n\n    private int[] right(int[] nums) {\n        int[] left = new int[nums.length];\n        Map<Integer, Integer> count = new HashMap<>();\n        for (int i = nums.length - 1; i >= 0; i--) {\n            left[i] = -1;\n            if (count.containsKey(nums[i])) {\n                left[i] = count.get(nums[i]);\n            }\n            count.put(nums[i], i);\n        }\n        return left;\n    }\n}","author":"欧海","submissionId":"611231281"},[]]},{"1387":[{"id":"1387","fileName":"611231502.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries)\n    {\n        int n = nums.size();\n        unordered_map<int, vector<int>> pos;\n        for (int i = 0; i < n; i++)\n            pos[nums[i]].push_back(i);\n        for (int i = 0; i < n; i++)\n            pos[nums[i]].push_back(i + n);\n        vector<int> ans;\n        for (auto x : queries)\n        {\n            int value = nums[x];\n            if (pos[value].size() <= 2)\n            {\n                ans.push_back(-1);\n                continue;\n            }\n            int cur = n + 1;\n            auto it1 = lower_bound(pos[value].begin(), pos[value].end(), x);\n            if (it1 != pos[value].begin())\n                cur = min(cur, *it1 - *prev(it1));\n            if (next(it1) != pos[value].end())\n                cur = min(cur, *next(it1) - *it1);\n            auto it2 = lower_bound(pos[value].begin(), pos[value].end(), x + n);\n            if (it2 != pos[value].begin())\n                cur = min(cur, *it2 - *prev(it2));\n            if (next(it2) != pos[value].end())\n                cur = min(cur, *next(it2) - *it2);\n            ans.push_back(cur);\n        }\n        return ans;\n    }\n};","author":"walk-alone","submissionId":"611231502"},[]]},{"1388":[{"id":"1388","fileName":"611231820.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        ans = [-1 for i in nums]\n        d = dict()\n        for i in range(n):\n            j = nums[i]\n            if j in d:\n                d[j].append(i)\n            else:\n                d[j] = [i]\n        for j in d:\n            tmp = d[j]\n            if len(tmp)==1:\n                ans[tmp[0]] = -1\n            else:\n                tmp += [tmp[0]+n]\n                ttmp = [2*n for i in tmp]\n                for i in range(len(tmp)-1):\n                    ttmp[i] = min(ttmp[i], tmp[i+1]-tmp[i])\n                    ttmp[i+1] = min(ttmp[i+1], tmp[i+1]-tmp[i])\n                ttmp[0] = min(ttmp[0], ttmp[-1])\n                tmp.pop()\n                ttmp.pop()\n                #print(tmp, ttmp)\n                for i in range(len(tmp)):\n                    ans[tmp[i]] = ttmp[i]\n        out = queries[:]\n        for i in range(len(out)):\n            out[i] = ans[out[i]]\n        return out\n        ","author":"aIkNVYH3CJ","submissionId":"611231820"},[]]},{"1389":[{"id":"1389","fileName":"611231463.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries)\n    {\n        unordered_map<int, vector<int>> um;\n        int n = nums.size();\n\n        for (int i = 0; i < n; ++i)\n            um[nums[i]].push_back(i);\n\n        vector<int> res;\n        for (auto& q : queries) {\n            auto& arr = um[nums[q]];\n            if (arr.size() == 1) {\n                res.push_back(-1);\n                continue;\n            }\n            auto idx = lower_bound(arr.begin(), arr.end(), q);\n            \n\n            int temp = INT_MAX;\n            if (idx != arr.begin())\n                temp = min<int>(temp, q - *prev(idx));\n            else {\n                temp = min<int>(temp, n - arr.back() + q);\n            }\n            if (next(idx) != arr.end())\n                temp = min<int>(temp, *next(idx) - q);\n            else {\n                temp = min<int>(temp, n - q + arr.front());\n            }\n            res.push_back(temp == INT_MAX ? -1 : temp);\n        }\n        return res;\n    }\n};","author":"Qiye","submissionId":"611231463"},[]]},{"1390":[{"id":"1390","fileName":"611231839.txt","sourceCode":"#pragma region template\n\n#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <cmath>\n#include <queue>\n#include <algorithm>\n#include <array>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; --i)\n#define forab(i, a, b) for(int i=(a);i<(b);++i)\n#define fore(v, a) for(auto &v: a)\n#define sqr(x) ((x)*(x))\n#define clr(a, b) memset(a, b, sizeof(a))\n#define sz(a) ((int)a.size())\n#define all(a) (a).begin(),(a).end()\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef map<int,int> mii;\ntypedef map<int,string> mis;\ntypedef map<string,int> msi;\ntemplate <class T> using max_heap = priority_queue<T>;\ntemplate <class T> using min_heap = priority_queue<T, vector<T>, greater<>>;\nconst double eps = 1e-8;\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / 2;\nint dcmp(double x) { if (x < -eps) return -1; else return x > eps;}\ntemplate <typename T> bool chmax(T &m, const T q) { return m < q ? (m = q, true) : false; }\ntemplate <typename T> bool chmin(T &m, const T q) { return m > q ? (m = q, true) : false; }\nconstexpr pii dx4[4] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\nconstexpr pii dx8[8] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};\ntemplate <class T> using vc = vector<T>;\ntemplate <class T> using vvc = vector<vc<T>>;\ntemplate <class T> using vvvc = vector<vvc<T>>;\n#define minall(v) *min_element(all(v))\n#define maxall(v) *max_element(all(v))\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\n#define unq(x) sort(all(x)), x.erase(unique(all(x)), x.end())\nint popcnt(unsigned int x) { return __builtin_popcount(x); }\nint popcntll(unsigned long long x) { return __builtin_popcountll(x); }\ntemplate <class T, class U> ostream& operator<<(ostream& os, const pair<T, U>& p){ return os<<\"(\"<<p.fi<<\",\"<<p.se<<\")\"; }\nvoid see0(){ cout<<endl; }\ntemplate<class H, class ...T> void see0(H && h, T && ...t) { cout<<h<<\",\"; see0(t...); }\n\n#pragma endregion template\n\n#ifdef CHEN_PC\n#include \"lc-struct.h\"\n#define see(...) {cout<<__LINE__<<\": \"<<#__VA_ARGS__<<\" = \";see0(__VA_ARGS__);}\n#define seev(a) {cout<<__LINE__<<\": \"<<#a<<\" = [\"; fore(v, a)cout<<(v)<<\",\"; cout<<\"]\"<<endl;}\n#else\n#define see(...)\n#define seev(...)\n#endif\n\nconst int N = 30010;\nconst int mod = 1000000007; // 10^9+7\n\nclass Solution {\npublic:\n\tvector<int> solveQueries(vector<int>& a, vector<int>& qr) {\n\t\tseev(a);\n\t\tseev(qr);\n\t\tint n = sz(a);\n\t\tint m = sz(qr);\n\t\tmap<int, vi> book;\n\t\tforn (i, n) {\n\t\t\tbook[a[i]].push_back(i);\n\t\t}\n\t\tvi ans;\n\t\tforn (i, m) {\n\t\t\tint x = a[qr[i]];\n\t\t\tsee(qr[i],x);\n\t\t\tauto &arr = book[x];\n\t\t\tint z = sz(arr);\n\t\t\tif (z == 1) {\n\t\t\t\tans.push_back(-1);\n\t\t\t} else {\n\t\t\t\tint val = inf<int>;\n\t\t\t\tint j = lb(arr, qr[i]);\n\t\t\t\tint jj = (j+1)%z;\n\t\t\t\tchmin(val, abs(arr[jj] - qr[i]));\n\t\t\t\tchmin(val, n - abs(arr[jj] - qr[i]));\n\t\t\t\tjj = (j-1+z)%z;\n\t\t\t\tchmin(val, abs(arr[jj] - qr[i]));\n\t\t\t\tchmin(val, n - abs(arr[jj] - qr[i]));\n\t\t\t\tans.push_back(val);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n};","author":"ch365","submissionId":"611231839"},[]]},{"1391":[{"id":"1391","fileName":"611231796.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> m;\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            m[nums[i]].push_back(i);\n        }\n\n        unordered_map<int, int> s;\n        for (auto& [k, v] : m) {\n            for (int i = 0; i < v.size(); ++i) {\n                int ld = INT_MAX;\n                if (0 < i)\n                    ld = v[i] - v[i - 1];\n                int rd = INT_MAX;\n                if (i + 1 < v.size())\n                    rd = v[i + 1] - v[i];\n                if (i == 0 || i + 1 == v.size()) {\n                    if (1 < v.size())\n                        ld = min(ld, n - v.back() + v.front());\n                }\n                if (min(ld, rd) == INT_MAX)\n                    s[v[i]] = -1;\n                else\n                    s[v[i]] = min(ld, rd);\n            }\n        }\n\n        vector<int> ans;\n        for (int q : queries) {\n            ans.push_back(s[q]);\n        }\n        return ans;\n    }\n};","author":"Sariabell","submissionId":"611231796"},[]]},{"1392":[{"id":"1392","fileName":"611231896.txt","sourceCode":"class Solution:\n    def bs(self, arr, target):\n        lo, hi = 0, len(arr)\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if arr[mid] < target:\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo\n        \n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        d = {}\n        for i, num in enumerate(nums):\n            if num not in d:\n                d[num] = []\n            d[num].append(i)\n        res = []\n        for q in queries:\n            num = nums[q]\n            arr = d[num]\n            if len(arr) < 2:\n                res.append(-1)\n                continue\n            pos = self.bs(arr, q)\n            left = arr[pos - 1] if pos > 0 else arr[-1]\n            right = arr[pos + 1] if pos + 1 < len(arr) else arr[0]\n            diff1 = abs(q - left)\n            diff2 = abs(q - right)\n            diff1 = diff1 if diff1 <= n - diff1 else n - diff1\n            diff2 = diff2 if diff2 <= n - diff2 else n - diff2\n            res.append(diff1 if diff1 < diff2 else diff2)\n        return res","author":"Alex-Yan","submissionId":"611231896"},[]]},{"1393":[{"id":"1393","fileName":"611231296.txt","sourceCode":"import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> res = new ArrayList<>();\n        int n = nums.length;\n\n        int[]arr = new int[2*n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = nums[i];\n        }\n        for (int i = n; i < 2 * n; ++i) {\n            arr[i] = nums[i-n];\n        }\n\n        HashMap<Integer, Integer>suf = new HashMap<>();\n        int []r = new int[2*n];\n        for(int i=2*n-1; i>=0; i--) {\n            r[i] = suf.getOrDefault(arr[i], -1);\n            suf.put(arr[i], i);\n        }\n\n        HashMap<Integer, Integer> pre = new HashMap<>();\n        int[]l = new int[2*n];\n        for(int i=0; i<2*n; i++) {\n            l[i]=pre.getOrDefault(arr[i], -1);\n            pre.put(arr[i], i);\n        }\n\n        for (int q : queries) {\n            int tmp = -1;\n            int li = l[q+n];\n\n            if(li!=-1 && q+n-li<n)tmp = q+n-li;\n\n            int ri = r[q];\n\n            int d = ri-q;\n            if(ri!=-1 && d<n) {\n\n                if(tmp==-1 || tmp>d){\n                    tmp = d;\n                }\n            }\n\n            res.add(tmp);\n        }\n\n        return res;\n\n    }\n}","author":"nickname","submissionId":"611231296"},[]]},{"1394":[{"id":"1394","fileName":"611232043.txt","sourceCode":"\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        # 预处理 nums 中每个值对应的索引位置\n        index_map = defaultdict(list)\n        n = len(nums)\n        \n        for i, num in enumerate(nums):\n            index_map[num].append(i)\n        \n        ans = []\n        for i in queries:\n            num = nums[i]\n            indices = index_map[num]\n            \n            if len(indices) == 1:\n                ans.append(-1)\n                continue\n            \n            # 二分查找最近的索引\n            pos = bisect.bisect_left(indices, i)\n            t = float('inf')\n            \n            if pos > 0:  # 前一个相同元素\n                t = min(t, i - indices[pos - 1])\n            \n            if pos < len(indices) - 1:  # 后一个相同元素\n                t = min(t, indices[pos + 1] - i)\n            \n            # 环形数组情况\n            t = min(t, n - abs(indices[0] - i), n - abs(indices[-1] - i))\n            ans.append(t)\n        \n        return ans","author":"Admiring LevvinsqZ","submissionId":"611232043"},[]]},{"1395":[{"id":"1395","fileName":"611231874.txt","sourceCode":"max2 = lambda x, y: x if x > y else y\nmin2 = lambda x, y: x if x < y else y\n\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        pos = defaultdict(list)\n        for i, x in enumerate(nums):\n            pos[x].append(i)\n        for v in pos:\n            pos[v].sort()\n        res = []\n        for i in queries:\n            x = nums[i]\n            idx = pos[x]\n            if len(idx) == 1:\n                res.append(-1)\n                continue\n            p = bisect_left(idx, i)\n\n            left = idx[p - 1] if p > 0 else idx[-1]\n            right = idx[p + 1] if p + 1 < len(idx) else idx[0]\n            res.append(min2((i - left) % n, (right - i) % n))\n        return res","author":"不造轮子","submissionId":"611231874"},[]]},{"1396":[{"id":"1396","fileName":"611231941.txt","sourceCode":"from typing import *\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nfrom queue import PriorityQueue\nfrom itertools import combinations\n\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        nums_three = nums + nums + nums\n        n = len(nums)\n        idx_pos = defaultdict(list)\n        for i, num in enumerate(nums_three):\n            idx_pos[num].append(i)\n        # print(idx_pos)\n        res = []\n        for q in queries:\n            num = nums[q]\n            pos = idx_pos[num]\n            if len(pos) == 3:\n                res.append(-1)\n                continue\n            idx = self.find_index_in_nums(pos, q+n)\n            num = q + n \n            left_num = pos[idx-1]\n            right_num = pos[idx+1]\n            # print(q+n, pos, idx - left_idx, right_idx - idx)\n            res.append(min(num - left_num, right_num - num))\n\n        return res\n\n            \n\n    def find_index_in_nums(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n\n","author":"wangsc","submissionId":"611231941"},[]]},{"1397":[{"id":"1397","fileName":"611231965.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        rcd = dict()\n        n, inf = len(nums), 1 << 30\n        dis = [inf] * n\n        for i in range(2 * n):\n            pos = i % n\n            if nums[pos] in rcd:\n                last = rcd[nums[pos]]\n                last_pos = last % n\n                dis[pos] = min(dis[pos], i - last)\n                dis[last_pos] = min(dis[last_pos], i - last)\n            rcd[nums[pos]] = i\n        # print(dis)\n        \n        ans = [0] * len(queries)\n        for q in range(len(queries)):\n            ans[q] = dis[queries[q]]\n            if ans[q] == n: ans[q] = -1\n        return ans","author":"Jos","submissionId":"611231965"},[]]},{"1398":[{"id":"1398","fileName":"611231967.txt","sourceCode":"using pii = pair<int, int>;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        int n = a.size(), m = q.size();\n        map<int, vector<int>> g;\n        for (int i = 0; i < n; i++) {\n            g[a[i]].push_back(i);\n        }\n        vector<int> res(n, -1);\n        for (auto& [_, b] : g) {\n            int sz = b.size();\n            if (sz == 1) res[b[0]] = -1;\n            else {\n                for (int j = 0; j < sz; j++) {\n                    int d = abs(b[j] - b[(j - 1 + sz) % sz]);\n                    res[b[j]] = min(d, n - d);\n                    d = abs(b[j] - b[(j + 1 + sz) % sz]);\n                    d = min(d, n - d);\n                    res[b[j]] = min(res[b[j]], d);\n                }\n            }\n        }\n        vector<int> ans(m, -1);\n        for (int i = 0; i < m; i++) ans[i] = res[q[i]];\n        return ans;\n    }\n};","author":"liang sheng","submissionId":"611231967"},[]]},{"1399":[{"id":"1399","fileName":"611232219.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        mp = defaultdict(list)\n        for i,x in enumerate(nums):\n            mp[x].append(i)\n        res = []\n        \n        for q in queries:\n            x = nums[q]\n            if len(mp[x]) == 1: res.append(-1)\n            else:\n                pos = bisect_left(mp[x],q)\n                t = min(abs(mp[x][(pos - 1) % len(mp[x])] - q),abs(mp[x][(pos + 1) % len(mp[x])] - q))\n                if pos == len(mp[x]) - 1:\n                    t = min(len(nums) + mp[x][0] - mp[x][-1],t)\n                if pos == 0:\n                    t = min(len(nums) + mp[x][0] - mp[x][-1],t)\n                res.append(t)\n        return res","author":"重生之我要上瓜","submissionId":"611232219"},[]]},{"1400":[{"id":"1400","fileName":"611232132.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<vector<int>> vis(1e5 + 10);\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            vis[nums[i]].emplace_back(i);\n        }\n        vector<int> ans(n);\n        for (int j = 1; j <= 1e5; j++) {\n            int m = vis[j].size();\n            if (m == 0) {\n                continue;\n            } else if (m == 1) {\n                ans[vis[j][0]] = -1;\n            } else {\n                for (int i = 0; i < m - 1; i++) {\n                    ans[vis[j][i]] = vis[j][i + 1] - vis[j][i];\n                }\n                ans[vis[j][m - 1]] = vis[j][0] + n - vis[j][m - 1];\n                for (int i = 1; i < m; i++) {\n                    ans[vis[j][i]] = min(ans[vis[j][i]], vis[j][i] - vis[j][i - 1]);\n                }\n                ans[vis[j][0]] = min(ans[vis[j][0]], vis[j][0] + n - vis[j][m - 1]);\n            }\n        }\n        vector<int> res;\n        for (auto i : queries) res.emplace_back(ans[i]);\n        return res;\n    }\n};","author":"若讷","submissionId":"611232132"},[]]},{"1401":[{"id":"1401","fileName":"611232148.txt","sourceCode":"int ans[100020];\nint now[1000020];\nint fir[1000020];\nclass Solution {\npublic:\n    void update(int &x,int y){\n        if(x == -1)x = y;\n        else x = min(x,y);\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        for(int i=0;i<n;++i) ans[i] = -1;\n        for(int i=1;i<=1000000;++i) fir[i] = now[i] = -1;\n        for(int i=0;i<n;++i){\n            int x = nums[i];\n            //printf(\"ck : %d %dn\",now[x], i);\n            if(now[x] >= 0){\n                update(ans[i], i-now[x]);\n                update(ans[now[x]], i-now[x]);\n                update(ans[i], n-i+fir[x]);\n                update(ans[fir[x]], n-i+fir[x]);\n            }\n            now[x] = i;\n            if(fir[x] == -1) fir[x] = i;\n        }\n        \n\n        vector<int> ret;\n        int m = queries.size();\n        for(int i=0;i<m;++i){\n            int x = queries[i];\n            ret.push_back(ans[x]);\n        }\n        return ret;\n    }\n};","author":"Milesian","submissionId":"611232148"},[]]},{"1402":[{"id":"1402","fileName":"611232111.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n\n        vector<int> prev(n, -1);\n        vector<int> next(n, -1);\n\n        unordered_map<int ,int> cache;\n        unordered_map<int, int> lastpos;\n        unordered_map<int, int> firstpos;\n        for (int i = 0; i < n; ++i) {\n            auto iter = cache.find(nums[i]);\n            if (iter != cache.end()) {\n                prev[i] = iter->second;\n            }\n            cache[nums[i]] = i;\n            lastpos[nums[i]] = i;\n        }\n        cache.clear();\n        for (int i = n - 1; i >= 0; --i) {\n            auto iter = cache.find(nums[i]);\n            if (iter != cache.end()) {\n                next[i] = iter->second;\n            }\n            cache[nums[i]] = i;\n            firstpos[nums[i]] = i;\n        }\n\n        vector<int> r;\n        for (auto q : queries) {\n            if (prev[q] < 0 && next[q] < 0) {\n                r.push_back(-1);\n            } else if (prev[q] < 0) {\n                r.push_back(min(next[q] - q, n - lastpos[nums[q]] + q));\n            } else if (next[q] < 0) {\n                r.push_back(min(q - prev[q], n - q + firstpos[nums[q]]));\n            } else {\n                r.push_back(min(q - prev[q], next[q] - q));\n            }\n        }\n\n        return r;\n    }\n};","author":"Haocheng","submissionId":"611232111"},[]]},{"1403":[{"id":"1403","fileName":"611232355.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long int\n#define db double\n#define ldb long double\n#define int128 __int128_t\n#define fr(x) freopen(x,\"r\",stdin);\n#define fw(x) freopen(x,\"w\",stdout);\n#define mst(x,a) memset(x,a,sizeof(x));\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define fi first\n#define se second\n#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define yes std::cout << \"Yesn\"\n#define no std::cout << \"Non\"\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#ifdef LOCAL\n#include \"leetcode.h\"\n#endif // LOCAL\ntemplate <typename T> int si(const T &x) { return x.size(); }\ntemplate <typename T, typename S> inline bool chmax(T &a, const S &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <typename T, typename S> inline bool chmin(T &a, const S &b) { if (b < a) { a = b; return true; } return false; }\nconst int mod = 1000000007;\nconst int inf = 0x3f3f3f3f;\nconst int M = 1000005;\nvector<int> use[M];\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n      for (int x : nums) use[x].clear();\n      int n = si(nums);\n      rep(i, si(nums)) {\n        use[nums[i]].push_back(i);\n      }\n      int Q = si(queries);\n      vector<int> ans(Q, -1);\n      rep(i, Q) {\n        int x = queries[i];\n        if (si(use[nums[x]]) > 1) {\n          int t = inf;\n          int j = lower_bound(all(use[nums[x]]), x) - use[nums[x]].begin();\n          if (j) {\n            int k = use[nums[x]][j-1];\n            chmin(t, x - k);\n            chmin(t, (k + n - x) % n);\n            k = use[nums[x]][0];\n            chmin(t, x - k);\n            chmin(t, (k + n - x) % n);\n          }\n          if (j + 1 < si(use[nums[x]])) {\n            int k = use[nums[x]][j+1];\n            chmin(t, k - x);\n            chmin(t, (x + n - k) % n);\n            k = use[nums[x]][si(use[nums[x]])-1];\n            chmin(t, k - x);\n            chmin(t, (x + n - k) % n);\n          }\n          ans[i] = t;\n        }\n      }\n      return ans;\n    }\n};","author":"gcasd001","submissionId":"611232355"},[]]},{"1404":[{"id":"1404","fileName":"611232062.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        unordered_map<int, vector<int>> pos;\n        int n = nums.size();\n        for(int i = 0; i < n; i ++) pos[nums[i]].push_back(i);\n        for(auto& [_, v] : pos) ranges::sort(v);\n        int m = q.size();\n        vector<int> ans(m, -1);\n        for(int i = 0; i < m; i ++) {\n            int x = q[i];\n            auto& v = pos[nums[x]];\n            auto it = lower_bound(v.begin(), v.end(), x);\n            int res = INT_MAX;\n            if(it != v.begin()) {\n                auto pre = prev(it);\n                res = min(res, *it - *pre);\n                res = min(res, n - (*it - *pre));\n            }\n            else if(v.size() > 1){\n                res = min(res, v.back() - *it);\n                res = min(res, n - (v.back() - *it));\n            }\n            auto nx = next(it);\n            if(nx != v.end()) {\n                res = min(res, *nx - *it);\n                res = min(res, n - (*nx - *it));           \n            }\n            else if(v.size() > 1) {\n                res = min(res, *it - v[0]);\n                res = min(res, n - (*it - v[0]));\n            }\n            ans[i] = (res == INT_MAX ? -1 : res);\n        }\n        return ans;\n    }\n};","author":"Stupefied Pare6Le","submissionId":"611232062"},[]]},{"1405":[{"id":"1405","fileName":"611232397.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d=defaultdict(list)\n        for i,x in enumerate(nums):\n            d[x].append(i)\n        res=[-1]*len(queries)\n        n=len(nums)\n        def dis(x,y,m):\n            x,y=min(x,y),max(x,y)\n            return min(y-x,x+n-y)\n        for i,q in enumerate(queries):\n            x=nums[q]\n            t=inf\n            j=bisect_right(d[x],q)\n            m=len(d[x])\n            for nj in [j-2,j-1,j]:\n                nj=nj%len(d[x])\n                print(nj)\n                if 0<=nj<len(d[x]) and d[x][nj] !=q:\n                    t=min(t,dis(d[x][nj],q,m))\n            \n            res[i]=t if t<inf else -1\n        return res\n        ","author":"krism","submissionId":"611232397"},[]]},{"1406":[{"id":"1406","fileName":"611232394.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        rec = {}\n        debug = 0\n        n = len(nums)\n        arr = [-1] * n\n        for i,v in enumerate(nums):\n            if v not in rec:\n                rec[v] = []\n            rec[v].append(i)\n            arr[i] = len(rec[v])-1\n        out = []\n        for q in queries:\n            v = nums[q]\n            vi = arr[q]\n            if debug:\n                print([q,v,vi],rec[v])\n            if len(rec[v]) == 1:\n                out.append(-1)\n            else:\n                l = len(rec[v])\n                minone = n+1\n                for diff in [-1,1]:\n                    a = rec[v][vi]\n                    b = rec[v][(vi+diff)%l]\n                    if a>b:\n                        a,b = b,a\n                    if debug:\n                        print(a,b,a+n-b,b-a)\n                    minone = min(minone,(a+n-b)%n,(b-a)%n)\n                out.append(minone)\n        return out\n        ","author":"大英权相吉姆哈克","submissionId":"611232394"},[]]},{"1407":[{"id":"1407","fileName":"611232416.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        mp = defaultdict(list)\n        for i, x in enumerate(nums):\n            mp[x].append(i)\n        n = len(nums)\n        ans = []\n        for i in queries:\n            x = nums[i]\n            p = mp[x]\n            if len(p) == 1:\n                ans.append(-1)\n                continue\n            k = bisect_left(p, i)\n            v = 10 ** 9\n            d = abs(p[k] - p[(k - 1) % len(p)])\n            v = min(v, d, n - d)\n            d = abs(p[(k + 1) % len(p)] - p[k])\n            v = min(v, d, n - d)\n            ans.append(v)\n        return ans","author":"5cm/s 🌸","submissionId":"611232416"},[]]},{"1408":[{"id":"1408","fileName":"611232480.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n\tn := len(nums)\n\n\tpre, nxt := map[int]int{}, map[int]int{}\n\tmn := make([]int, n)\n\tfor i := range n {\n\t\tmn[i] = n\n\t}\n\n\tnums = append(nums, nums...)\n\tfor i, x := range nums {\n\t\tif pi, ok := pre[x]; ok {\n\t\t\tmn[i%n] = min(mn[i%n], i-pi)\n\t\t}\n\t\tpre[x] = i\n\t}\n\n\tfor i := 2*n - 1; i >= 0; i-- {\n\t\tx := nums[i%n]\n\t\tif ni, ok := nxt[x]; ok {\n\t\t\tmn[i%n] = min(mn[i%n], ni-i)\n\t\t}\n\t\tnxt[x] = i\n\t}\n\n\tans := make([]int, len(queries))\n\tfor i, q := range queries {\n\t\tif mn[q] == n {\n\t\t\tans[i] = -1\n\t\t} else {\n\t\t\tans[i] = mn[q]\n\t\t}\n\t}\n\n\treturn ans\n}","author":"FallenLeaves","submissionId":"611232480"},[]]},{"1409":[{"id":"1409","fileName":"611232448.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        pos = defaultdict(list)\n        for i in range(n):\n            pos[nums[i]].append(i)\n\n        m = len(queries)\n        res = [-1]*m\n        for i in range(m):\n            tmpIndx = queries[i]\n            tmpValue = nums[tmpIndx]\n            if len(pos[tmpValue]) == 1:\n                continue\n            cur = bisect_left(pos[tmpValue], tmpIndx)\n            length = len(pos[tmpValue])\n            left = pos[tmpValue][(cur-1+length)%length]\n            right = pos[tmpValue][(cur+1)%length]\n            leftDis = min(abs(tmpIndx-left), n-abs(tmpIndx-left))\n            rightDis = min(abs(tmpIndx-right), n-abs(tmpIndx-right))\n            res[i] = min(leftDis, rightDis)\n        return res","author":"gauss","submissionId":"611232448"},[]]},{"1410":[{"id":"1410","fileName":"611232523.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        int n = a.size();\n        unordered_map<int, int> cnt, last;\n        for (int i = 0; i < n; ++i)\n            a.push_back(a[i]), ++cnt[a[i]];\n        n <<= 1;\n        \n        vector<int> pre(n), nxt(n);\n        for (int i = 0; i < n; ++i) {\n            if (last.find(a[i]) != last.end())\n                pre[i] = last[a[i]];\n            last[a[i]] = i;\n        }\n\n        last.clear();\n        for (int i = n-1; ~i; --i) {\n            if (last.find(a[i]) != last.end())\n                nxt[i] = last[a[i]];\n            last[a[i]] = i;\n        }\n\n        vector<int> ans;\n        for (int i : q) {\n            if (cnt[a[i]] == 1)\n                ans.push_back(-1);\n            else {\n                ans.push_back(min(nxt[i] - i, i+n/2 - pre[i+n/2]));\n            }\n        }\n        return ans;\n    }\n};","author":"维虵命","submissionId":"611232523"},[]]},{"1411":[{"id":"1411","fileName":"611232411.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n                Map<Integer,TreeSet<Integer>>dict=new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            dict.computeIfAbsent(nums[i],key->new TreeSet<>()).add(i);\n        }\n        List<Integer>res=new ArrayList<>();\n        for(int i=0;i<queries.length;i++){\n            int idx=queries[i];\n            int cur=nums[idx];\n            TreeSet<Integer>target=dict.get(cur);\n            if(target.size()==1){\n                res.add(-1);\n            }else {\n                int dis=Integer.MAX_VALUE;\n                Integer next=target.higher(idx)!=null?target.higher(idx):target.first();\n                if(next!=idx){\n                    dis=Math.min(dis,next>idx?next-idx:(nums.length+next-idx));\n                }\n                Integer pre=target.lower(idx)!=null?target.lower(idx):target.last();\n                if(pre!=idx){\n                    dis=Math.min(dis,pre<idx?idx-pre:(idx+nums.length-pre));\n                }\n                res.add(dis);\n            }\n        }\n        return res;\n    }\n}","author":"ReZero","submissionId":"611232411"},[]]},{"1412":[{"id":"1412","fileName":"611232490.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n = nums.size(), m = q.size();\n        vector<int> ans(m);\n        map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> l(n, -1);\n        vector<int> r(n, -1);\n        for (auto [a, b] : mp) {\n            int k = b.size();\n            // for (int l :b) cout << l <<' ';\n            // cout <<'n';\n            if (b.size() > 1) {\n                l[b[0]] = b[0] + n - b[k - 1];\n                r[b[k - 1]] = b[0] + n - b[k - 1];\n                for (int i = 1; i < k; i++) {\n                    l[b[i]] = b[i] - b[i - 1];\n                }\n                for (int i = 0; i < k- 1; i++) {\n                    r[b[i]] = b[i + 1] - b[i];\n                }\n            }\n        }\n        for (int i = 0;i <m; i++) {\n            if (l[q[i]] == -1 &&r[q[i]] == -1) ans[i] = -1;\n            else ans[i]= min(l[q[i]], r[q[i]]);\n        }\n        return ans;\n    }\n};","author":"Relaxed","submissionId":"611232490"},[]]},{"1414":[{"id":"1414","fileName":"611232616.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        d = [inf] * n\n        mp = {}\n        for i in range(n + n):\n            idx = i % n\n            val = nums[idx]\n            prev = mp.get(val, -inf)\n            delta = i - prev\n            if delta < n:\n                dist = min(delta, n - delta)\n                d[idx] = min(d[idx], dist)\n                d[prev % n] = min(d[prev % n], dist)\n            mp[val] = i\n        return [d[idx] if d[idx] != inf else -1 for idx in queries]\n        ","author":"lee0560","submissionId":"611232616"},[]]},{"1415":[{"id":"1415","fileName":"611232399.txt","sourceCode":"class Solution {\n  public List<Integer> solveQueries(int[] nums, int[] queries) {\n    int len = nums.length;\n    Map<Integer, TreeSet<Integer>> map = new HashMap<>();\n    for (int i = 0; i < len; i++) {\n      int v = nums[i];\n      TreeSet<Integer> set = map.computeIfAbsent(v, k -> new TreeSet<>());\n      set.add(i);\n    }\n    List<Integer> ans = new ArrayList<>(queries.length);\n    for (int i = 0; i < queries.length; i++) {\n      int v = nums[queries[i]];\n      TreeSet<Integer> set = map.get(v);\n      if (set == null || set.size() <= 1) {\n        ans.add(-1);\n      } else {\n        int left = len, right = len, q = queries[i];\n        Integer lower = set.lower(q);\n        if (lower == null) {\n          left = q + len - set.last();\n        } else {\n          left = q - lower;\n        }\n        Integer higher = set.higher(q);\n        if (higher == null) {\n          right = len - q + set.first();\n        } else {\n          right = higher - q;\n        }\n        ans.add(Math.min(left, right));\n      }\n    }\n    return ans;\n  }\n}","author":"lifam","submissionId":"611232399"},[]]},{"1416":[{"id":"1416","fileName":"611232558.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        unordered_map<int,vector<int>> pos;\n        for(int i=0;i<n;i++){\n            pos[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(auto q:queries){\n            int x=nums[q];\n            int d=INT_MAX;\n            if(q!=pos[x].back()){\n                d=min(d,q+n-pos[x].back());\n            }\n            if(q!=pos[x][0]){\n                d=min(d,pos[x][0]+n-q);\n            }\n            auto l=lower_bound(pos[x].begin(),pos[x].end(),q);\n            if(l!=pos[x].begin()){\n                l--;\n                d=min(d,q-(*l));\n                \n            }\n            auto r=upper_bound(pos[x].begin(),pos[x].end(),q);\n            if(r!=pos[x].end()){\n                d=min(d,(*r)-q);\n            }\n            if(d==INT_MAX){\n                ans.push_back(-1);\n            }else{\n                ans.push_back(d);\n            }\n        }\n        return ans;\n    }\n};","author":"nihonge","submissionId":"611232558"},[]]},{"1417":[{"id":"1417","fileName":"611232626.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        int n = nums.size();\n        int m = queries.size();\n        vector<int> ans(m);\n        \n        for (int i = 0; i < n; ++i) {\n            int x = nums[i];\n            mp[x].push_back(i);\n        }\n        vector<int> a(n);\n        for (auto [_, v] : mp) {\n            int k = v.size();\n            \n            for (int i = 0; i < k; ++i) {\n                int pre = v[(i - 1 + k) % k];\n                int cur = v[i];\n                int next = v[(i + 1) % k];\n                int d1 = abs(cur - pre);\n                int d2 = abs(next - cur);\n                a[cur] = min(min(d1, n - d1), min(d2, n - d2));\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            int q = queries[i];\n            if (a[q] == 0) {\n                ans[i] = -1;\n            } else {\n                ans[i] = a[q];\n            }\n        }\n        return ans;\n    }\n};","author":"discipline","submissionId":"611232626"},[]]},{"1418":[{"id":"1418","fileName":"611232648.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = defaultdict(list)\n        for i, x in enumerate(nums):\n            d[x].append(i)\n        n = len(nums)\n        ans = [-1] * len(queries)\n        for i, x in enumerate(queries):\n            y = nums[x]\n            n1 = len(d[y])\n            if n1 == 1:\n                continue\n            idx = bisect_left(d[y], x)\n            i1 = (idx - 1) % n1\n            i2 = (idx + 1) % n1\n            c1 = min(abs(d[y][i1] - d[y][idx]), n - abs(d[y][i1] - d[y][idx]))\n            c2 = min(abs(d[y][i2] - d[y][idx]), n - abs(d[y][i2] - d[y][idx]))\n            # print(i, x, ans)\n            ans[i] = min(c1, c2)\n        return ans","author":"Upbeat ShamirgfO","submissionId":"611232648"},[]]},{"1419":[{"id":"1419","fileName":"611232712.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        a = collections.defaultdict(list)\n        n = len(nums)\n        for i in range(len(nums)):\n            a[nums[i]].append(i)\n        res = []\n        for q in queries:\n            v = nums[q]\n            if len(a[v]) == 1:\n                res.append(-1)\n                continue\n            o = bisect.bisect_left(a[v], q)\n            if o > 0:\n                x = q - a[v][o - 1]\n            else:\n                x = n + q - a[v][-1]\n            if o + 1 < len(a[v]):\n                x = min(x, a[v][o + 1] - q)\n            else:\n                x = min(x, n + a[v][0] - q)\n            res.append(x)\n        return res\n","author":"thuczh","submissionId":"611232712"},[]]},{"1420":[{"id":"1420","fileName":"611232753.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], qs: List[int]) -> List[int]:\n        pos = defaultdict(list)\n        for i, j in enumerate(nums):\n            pos[j].append(i)\n        res = []\n        n = len(nums)\n        def dist(a, b):\n            if a > b:\n                a, b = b, a\n            return min(b - a, (n + a - b))\n        \n        for q in qs:\n            u = nums[q]\n            it = bisect_left(pos[u], q)\n            m = len(pos[u])\n            if m == 1:\n                res.append(-1)\n            else:\n                res.append(min(dist(pos[u][(it-1)%m], q), dist(pos[u][(it+1)%m], q)))\n        return res\n            \n            \n        ","author":"Misaka Mikoto","submissionId":"611232753"},[]]},{"1421":[{"id":"1421","fileName":"611232598.txt","sourceCode":"class Solution:\n\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n\n        d = defaultdict(list)\n        for i, n in enumerate(nums):\n            d[n].append(i)\n\n        ans = list()\n        solved = dict()\n        n = len(nums)\n        for qi in queries:\n            if qi in solved:\n                ans.append(solved[qi])\n                continue\n            qv = nums[qi]\n            idxs = d[qv]\n            if len(idxs) == 1:\n                ans.append(-1)\n                solved[qi] = -1\n                continue\n            pos = bisect_left(idxs, qi)\n            left = idxs[pos - 1]\n            right = idxs[(pos + 1) % len(idxs)]\n            dis = inf\n            dis = min(dis, abs(qi - left), n - abs(qi - left))\n            dis = min(dis, abs(qi - right), n - abs(qi - right))\n            # print(\"qi: {}, qv: {}, left: {}, right: {}\".format(qi, qv, left, right))\n            ans.append(dis)\n            solved[qi] = dis\n\n        return ans\n\n","author":"喜乐","submissionId":"611232598"},[]]},{"1422":[{"id":"1422","fileName":"611232640.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> hmp;\n        for (int i = 0; i < n; ++i) {\n            hmp[nums[i]].emplace_back(i);\n        }\n\n        vector<int> ans(queries.size(), -1);\n        for (int i = 0; i < queries.size(); ++i) {\n            int index = queries[i];\n            int val = nums[index];\n\n            auto& arr = hmp[val];\n            if (arr.size() == 1)\n                continue;\n\n            int pos = lower_bound(arr.begin(), arr.end(), index) - arr.begin();\n            int mind = INT_MAX;\n            if (pos > 0)\n                mind = min(mind, arr[pos] - arr[pos - 1]);\n            else\n                mind = min(mind, arr[pos] + n - arr.back());\n\n            if (pos + 1 < arr.size())\n                mind = min(mind, arr[pos + 1] - arr[pos]);\n            else\n                mind = min(mind, arr[0] + n - arr[pos]);\n\n            ans[i] = mind;\n        }\n\n        return ans;\n    }\n};","author":"Cactus","submissionId":"611232640"},[]]},{"1423":[{"id":"1423","fileName":"611232659.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> mp;\n        int n = nums.size();\n        for(int i = 0;i<n;++i){\n            auto &x = nums[i];\n            mp[x].push_back(i);\n        }\n        vector<int> ans;\n        for(auto &index:queries){\n            auto &x = nums[index];\n            if(mp[x].size()<2){\n                ans.push_back(-1);\n                continue;\n            }\n            \n            auto nxtit = upper_bound(mp[x].begin(),mp[x].end(),index);\n            if(nxtit==mp[x].end()) nxtit = mp[x].begin();\n            auto preit = lower_bound(mp[x].begin(),mp[x].end(),index);\n            if(preit==mp[x].begin()) preit = mp[x].end()-1;\n            else preit--;\n\n            ans.push_back(min(((*nxtit)-index+n)%n,(index-(*preit)+n)%n));\n        }\n        \n        return ans;\n    }\n};","author":"ascend","submissionId":"611232659"},[]]},{"1425":[{"id":"1425","fileName":"611232584.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    int INF = Integer.MAX_VALUE / 2;\n\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        int[] d = new int[2 * n];\n        Arrays.fill(d, INF);\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < 2 * n; i++) {\n            if (map.containsKey(nums[i % n])) {\n                d[i] = Math.min(d[i], i - map.get(nums[i % n]));\n            }\n            map.put(nums[i % n], i);\n        }\n        map.clear();\n        for (int i = 2 * n - 1; i >= 0; i--) {\n            if (map.containsKey(nums[i % n])) {\n                d[i] = Math.min(d[i], map.get(nums[i % n]) - i);\n            }\n            map.put(nums[i % n], i);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int i : queries) {\n            int res = min(d[i], d[n + i]);\n            if (res < n) {\n                ans.add(res);\n            } else {\n                ans.add(-1);\n            }\n        }\n        return ans;\n    }\n\n    int min(int... a) {\n        int res = INF;\n        for (int x : a) {\n            res = Math.min(res, x);\n        }\n        return res;\n    }\n}","author":"Itsuki","submissionId":"611232584"},[]]},{"1426":[{"id":"1426","fileName":"611232811.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        Map<Integer, Integer> prev = new HashMap(n);\n        Map<Integer, Integer> next = new HashMap(n);\n        int[] prevIndex = new int[n];\n        int[] nextIndex = new int[n];\n        for(int i = 0; i < 2 * n; i++) {\n            if(i >= n) {\n                prevIndex[i % n] = prev.get(nums[i % n]);\n            }\n            prev.put(nums[i % n], i);\n        }\n        for(int i = 2 * n - 1; i >= 0; i--) {\n            if(i < n) {\n                nextIndex[i] = next.get(nums[i]);\n            }\n            next.put(nums[i % n], i);\n        }\n        List<Integer> ans = new ArrayList();\n        boolean debug = false;\n        if(debug) {\n            System.out.println(Arrays.toString(prevIndex));\n            System.out.println(Arrays.toString(nextIndex));\n        }\n        for(int q : queries) {\n            int dist = Math.min(q + n - prevIndex[q], nextIndex[q] - q);\n            if(dist == n) {\n                dist = -1;\n            }\n            ans.add(dist);\n        }\n        return ans;\n    }\n}","author":"天塘","submissionId":"611232811"},[]]},{"1427":[{"id":"1427","fileName":"611232844.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        positions = {}\n        ans = []\n        for i, value in enumerate(nums * 3):\n            # print(i, value, positions, ans)\n            if value in positions:\n                last_i = positions[value]\n                new_ans = i - last_i\n                ans.append(new_ans)\n                ans[last_i] = min(ans[last_i], new_ans)\n            else:\n                ans.append(inf)\n            positions[value] = i\n        # print(positions, ans)\n\n        result = []\n        offset = len(nums)\n        for i in queries:\n            a = ans[i + offset]\n            if a == offset:\n                a = -1\n            result.append(a)\n        return result","author":"Sad FaradayTFr","submissionId":"611232844"},[]]},{"1428":[{"id":"1428","fileName":"611232785.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        HashMap<Integer, Integer> pos = new HashMap<>();\n        for(int i=0;i<n;++i){\n            pos.put(nums[i], i);\n        }\n\n        List<Integer> res = new ArrayList<Integer>();\n\n        for(int i=0;i<n;++i){\n            int idx = n + i;\n            if(pos.containsKey(nums[i]) && pos.get(nums[i])>i){\n                res.add(idx - pos.get(nums[i]));\n            }else{\n                res.add(-1);\n            }\n            pos.put(nums[i], idx);\n        }\n\n        pos = new HashMap<>();\n        for(int i=n-1;i>=0;--i){\n            pos.put(nums[i], n+i);\n        }\n\n        for(int i=n-1;i>=0;--i){\n            if(pos.containsKey(nums[i]) && pos.get(nums[i])<n+i){\n                int t = pos.get(nums[i]) - i;\n                if(t < res.get(i)){\n                    res.set(i, t);\n                }\n            }\n            pos.put(nums[i], i);\n        }\n\n        List<Integer> ret = new ArrayList<>();\n        for(int i=0;i<queries.length;++i){\n            ret.add(res.get(queries[i]));\n        }\n        \n        return ret;\n    }\n}","author":"youyouyou","submissionId":"611232785"},[]]},{"1429":[{"id":"1429","fileName":"611232905.txt","sourceCode":"/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\n\nint nxt[200005], pre[200005] ;\nint last[1000005] ;\n\nint min(int a, int b)\n{\n    return a < b ? a : b ;\n}\n\nint* solveQueries(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize) {\n    for(int i = 0; i < numsSize; ++ i) last[i] = -1, nxt[i] = pre[i] = numsSize ;\n    for(int i = 0; i < numsSize * 2; ++ i)\n    {\n        if(last[nums[i % numsSize]] != -1) pre[i % numsSize] = i - last[nums[i % numsSize]] ;\n        last[nums[i % numsSize]] = i ;\n    }\n\n    for(int i = 0; i < numsSize; ++ i) last[nums[i]] = -1 ;\n    for(int i = numsSize * 2 - 1; i >= 0; -- i)\n    {\n        if(last[nums[i % numsSize]] != -1) nxt[i % numsSize] = last[nums[i % numsSize]] - i ;\n        last[nums[i % numsSize]] = i ;\n    }\n\n    int *ans = (int *)malloc(sizeof(int) * queriesSize) ;\n    for(int i = 0; i < queriesSize; ++ i)\n    {\n        int pos = queries[i] ;\n        int val = min(pre[pos], nxt[pos]) ;\n        ans[i] = val == numsSize ? -1 : val ;\n    }\n\n    *returnSize = queriesSize ;\n    return ans ; \n}","author":"半城烟沙","submissionId":"611232905"},[]]},{"1431":[{"id":"1431","fileName":"611233011.txt","sourceCode":"class Solution:\n    def solveQueries(self, a: List[int], queries: List[int]) -> List[int]:\n        n = len(a)\n        dd = defaultdict(list)\n        for i, x in enumerate(a):\n            dd[x].append(i)\n        res = []\n        for q in queries:\n            x = a[q]\n            qn = len(dd[x])\n            if qn == 1:\n                res.append(-1)\n                continue\n            mn = inf\n            qn\n            i = bisect_left(dd[x], q)\n            if i:\n                mn = min(mn, q - dd[x][(i - 1) % qn])\n            else:\n                mn = min(mn, q + n - dd[x][(i - 1) % qn])\n            if i < qn - 1:\n                mn = min(mn, dd[x][(i + 1) % qn] - q)\n            else:\n                mn = min(mn, dd[x][(i + 1) % qn] + n - q)\n            res.append(mn)\n        return res","author":"cheng-liang-yu","submissionId":"611233011"},[]]},{"1432":[{"id":"1432","fileName":"611232912.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        nums = nums[:] + nums[:]\n        m = len(queries)\n        left = [float('inf')] * (2 * n)\n        right = [float('inf')] * (2 * n)\n        lookup = {nums[0]:0}\n        for i in range(1, 2 * n):\n            if nums[i] in lookup:\n                curr = i - lookup[nums[i]]\n                if curr < n:\n                    left[i] = curr\n            lookup[nums[i]] = i\n        \n        lookup = {nums[-1]:2 * n-1}\n        for i in range(2 * n -2, -1, -1):\n            if nums[i] in lookup:\n                curr = lookup[nums[i]] - i\n                if curr < n:\n                    right[i] = curr\n            lookup[nums[i]] = i\n\n        ans = [-1] * m\n        for j, i in enumerate(queries):\n            tmp = min(left[n + i], right[i])\n            ans[j] = tmp if tmp < float('inf') else -1\n        return ans\n        ","author":"🍪🍪🍪","submissionId":"611232912"},[]]},{"1433":[{"id":"1433","fileName":"611232833.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> hash;\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            hash[nums[i]].push_back(i);\n        }\n        for (auto& [key, pos] : hash) {\n            sort(pos.begin(), pos.end());\n        }\n        vector<int> ans;\n        for (int q : queries) {\n            int x = nums[q];\n            auto& pos = hash[x];\n            if (pos.size() <= 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            int m = pos.size();\n            auto it = upper_bound(pos.begin(), pos.end(), q);\n            int pre_idx;\n            if (it == pos.begin()) {\n                pre_idx = m - 1;\n            } else {\n                pre_idx = (it - pos.begin() - 1) % m;\n            }\n            int pre = pos[pre_idx];\n            int pre_prev = pos[(pre_idx - 1 + m) % m];\n            int suc_idx;\n            if (it == pos.end()) {\n                suc_idx = 0;\n            } else {\n                suc_idx = it - pos.begin();\n            }\n            int suc = pos[suc_idx];\n            int suc_next = pos[(suc_idx + 1) % m];\n            unordered_set<int> can;\n            can.insert(pre);\n            can.insert(pre_prev);\n            can.insert(suc);\n            can.insert(suc_next);\n            int min_dist = INT_MAX;\n            for (int p : can) {\n                if (p == q) continue;\n                int dist = min(abs(p - q), n - abs(p - q));\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n            if (min_dist == INT_MAX) {\n                ans.push_back(-1);\n            } else {\n                ans.push_back(min_dist);\n            }\n        }\n        return ans;\n    }\n};","author":"Hungry Ishizaka4ZT","submissionId":"611232833"},[{"id":"1807","similarity":1.0,"totOverlap":260,"longestOverlap":130}]],"1807":[{"id":"1807","fileName":"611243665.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& b) {\n        map<int, vector<int>> c;\n        int n = a.size();\n        for (int i = 0; i < n; ++i) {\n            c[a[i]].push_back(i);\n        }\n        for (auto& [d, e] : c) {\n            sort(e.begin(), e.end());\n        }\n        vector<int> f;\n        for (int g : b) {\n            int h = a[g];\n            auto& e = c[h];\n            if (e.size() <= 1) {\n                f.push_back(-1);\n                continue;\n            }\n            int m = e.size();\n            auto it = upper_bound(e.begin(), e.end(), g);\n            int i;\n            if (it == e.begin()) {\n                i = m - 1;\n            } else {\n                i = (it - e.begin() - 1) % m;\n            }\n            int j = e[i];\n            int k = e[(i - 1 + m) % m];\n            int l;\n            if (it == e.end()) {\n                l = 0;\n            } else {\n                l = it - e.begin();\n            }\n            int p = e[l];\n            int q = e[(l + 1) % m];\n            set<int> r;\n            r.insert(j);r.insert(k);r.insert(p);r.insert(q);\n            int s = INT_MAX;\n            for (int t : r) {\n                if (t == g) continue;\n                int u = min(abs(t - g), n - abs(t - g));\n                if (u < s) {\n                    s = u;\n                }\n            }\n            if (s == INT_MAX) {\n                f.push_back(-1);\n            } else {\n                f.push_back(s);\n            }\n        }\n        return f;\n    }\n};\n","author":"程序猴","submissionId":"611243665"},[{"id":"1433","similarity":1.0,"totOverlap":260,"longestOverlap":130}]]},{"1435":[{"id":"1435","fileName":"611233161.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        dic = defaultdict(list)\n        for i, a in enumerate(nums):\n            dic[a].append(i)\n            dic[a].append(i + n)\n            dic[a].append(i - n)\n        for k in dic:\n            dic[k].sort()\n        ans = []\n        for i in queries:\n            a = nums[i]\n            if len(dic[a]) == 3:\n                ans.append(-1)\n            else:\n                idx = bisect_left(dic[a], i)\n                tmp = inf\n                if idx > 0:\n                    tmp = min(tmp, i - dic[a][idx - 1], (dic[a][idx - 1] - i) % n)\n                if idx < len(dic[a]) - 1:\n                    tmp = min(tmp, dic[a][idx + 1] - i, (i - dic[a][idx + 1]) % n)\n                ans.append(tmp)\n        return ans","author":"silvertint10","submissionId":"611233161"},[]]},{"1436":[{"id":"1436","fileName":"611233088.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        idxs = defaultdict(list)\n        \n        for k in range(5):\n            for i,x in enumerate(nums, start=k*n):\n                idxs[x].append(i)\n        \n        cntr = Counter(nums)\n        res = []\n        for i in queries:\n            \n            val = nums[i]\n            if cntr[val] == 1:\n                res.append(-1)\n                continue\n            \n            idx = 2*n + i\n            # a = bisect.bisect_left(idxs[val], idx - 2)\n            # b = bisect.bisect_left(idxs[val], idx - 1)\n            c = bisect.bisect_left(idxs[val], idx)\n            # d = bisect.bisect_left(idxs[val], idx + 1)\n            # e = bisect.bisect_left(idxs[val], idx + 2)\n            \n            lst = [\n                idxs[val][c-2],\n                idxs[val][c-1],\n                idxs[val][c],\n                idxs[val][c+1],\n                idxs[val][c+2],\n            ]\n            \n            mindist = n\n            for x in lst:\n                if x%n == i:\n                    continue\n                dist = abs(x - idx)\n                mindist = min(mindist, dist)\n            # print(val, idx, idxs[val], lst, mindist)\n            res.append(mindist)\n        \n        # print()\n        return res\n            \n            \n            \n            ","author":"涂汇康","submissionId":"611233088"},[]]},{"1437":[{"id":"1437","fileName":"611233001.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& n, vector<int>& q) {\n        int sz=n.size();\n        unordered_map<int,vector<int>> ump;\n        for (int add=-sz;add<=sz;add+=sz) {\n            for (int j=0;j<sz;j++) {\n                int v=n.at(j);\n                ump[v].push_back(j+add);\n            }\n        }\n        vector<int> ans;\n        for (int &i:q) {\n            int v=n.at(i);\n            const vector<int> &vec=ump.at(v);\n            auto p=lower_bound(vec.begin(),vec.end(),i);\n            int res=sz;\n            auto a=prev(p);\n            auto b=next(p);\n            res=min(res,(*p)-(*a));\n            res=min(res,(*b)-(*p));\n            ans.push_back(res==sz ? -1 : res);\n        }\n        return ans;\n    }\n};","author":"Yves","submissionId":"611233001"},[]]},{"1438":[{"id":"1438","fileName":"611233185.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        map<int, vector<int>> mp;\n        vector<int> res(m, -1);\n        for(int i = 0; i < n; i++){\n            mp[nums[i]].push_back(i);\n        }\n        for(int i = 0; i < m; i++){\n            auto &v = mp[nums[queries[i]]];\n            if(v.size() > 1){\n                int idx = lower_bound(v.begin(), v.end(), queries[i]) - v.begin();\n                int nexidx = (idx + 1 + v.size()) % v.size();\n                int preidx = (idx - 1 + v.size()) % v.size();\n                int t1 = abs(v[idx] - v[nexidx]), t2 = abs(v[idx] - v[preidx]);\n                t1 = min(t1, n - t1), t2 = min(t2, n - t2);\n                res[i] = min(t1, t2);\n            }\n        }\n        return res;\n    }\n};","author":"ベ断桥烟雨ミ","submissionId":"611233185"},[]]},{"1440":[{"id":"1440","fileName":"611233269.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        m = len(queries)\n        d = defaultdict(list)\n        ans = [-1] * m\n        for i, x in enumerate(nums):\n            d[x].append(i)\n        for i, x in enumerate(queries):\n            y = nums[x]\n            if len(d[y]) <= 1:\n                continue\n            idx = bisect_left(d[y], x)\n            if idx == 0:\n                a = n - d[y][-1] + x\n            else:\n                a = x - d[y][idx - 1]\n            if idx == len(d[y]) - 1:\n                b = n - x + d[y][0]\n            else:\n                b = d[y][idx + 1] - x\n            ans[i] = min(a, b)\n        return ans","author":"小爱仙尊","submissionId":"611233269"},[]]},{"1441":[{"id":"1441","fileName":"611232787.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = {}\n        n = len(nums)\n        for i, num in enumerate(nums):\n            if num not in d:\n                d[num] = SortedList()\n            d[num].add(i)\n        \n        rst = []\n        for q in queries:\n            num = nums[q]\n            # print(q, num, d, len(d[num]))\n            if len(d[num]) == 1:\n                rst.append(-1)\n            else:\n                idx = d[num].bisect_left(q)\n                r = float('inf')\n                if idx == 0:\n                    r = min(n + d[num][0] - d[num][-1], d[num][1] - d[num][0])\n                elif idx == len(d[num]) - 1:\n                    r = min(d[num][-1] - d[num][-2], d[num][0] + n - d[num][-1])\n                else:\n                    r = min(d[num][idx] - d[num][idx - 1], d[num][idx + 1] - d[num][idx])\n                rst.append(r)\n        return rst\n","author":"好想喝羊肉汤啊","submissionId":"611232787"},[]]},{"1442":[{"id":"1442","fileName":"611233225.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        pos = defaultdict(list)\n        for i, x in enumerate(nums):\n            pos[x].append(i)\n        ans = []\n        for q in queries:\n            x = nums[q]\n            arr = pos[x]\n            if len(arr) == 1:\n                ans.append(-1)\n            else:\n                idx = bisect_left(arr, q)\n                ans.append(min((q-arr[(idx-1)%len(arr)]) % n, \n                                (arr[(idx+1)%len(arr)]-q) % n))\n        return ans","author":"FatalError","submissionId":"611233225"},[]]},{"1443":[{"id":"1443","fileName":"611233365.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n#define all(a) a.begin(), a.end()\nvoid print() { cout << 'n'; }\ntemplate <typename T, typename...Args>\nvoid print(T t, Args...args) { cout << t << ' '; print(args...); }\nusing ll = long long;\nconst int N = 1e5 + 5;\n\nint dir[4][2] = {\n    {1, 0}, {0, 1}, {-1, 0}, {0, -1}\n};\n\ntemplate <typename T> bool chmax(T &x, T y) { if (y > x) { x = y; return true; } return false; }\ntemplate <typename T> bool chmin(T &x, T y) { if (y < x) { x = y; return true; } return false; }\n\ntemplate <typename T = int>\nvector<T> readVector(int n) {\n    vector<T> a(n);\n    for(T &x: a) cin >> x;\n    return a;\n} \n\ntemplate <typename T = int>\nstruct Map {\n\tMap(const vector<int>& u): v(u) {}\n\n    vector<T> v;\n    \n    void build () {\n        sort(all(v));\n        v.erase(unique(all(v)), v.end());\n    }\n    \n    void insert (T x) {\n        v.push_back(x);\n    }\n    \n    int get (T x) {\n        return lower_bound(all(v), x) - v.begin();\n    }\n    \n    int size () {\n        return v.size();\n    }\n    \n    T operator [] (int p) {\n        return v[p];\n    }\n};\n\nclass Solution {\npublic:\n\tvector<int> solveQueries(vector<int>& a, vector<int>& que) {\n\t\tint n = a.size();\n\t\tint m = que.size();\n\t\tvector<int> ans(m, -1);\n\n\t\tauto dis = [&](int i, int j) {\n\t\t\tif (i > j) {\n\t\t\t\tswap(i, j);\n\t\t\t}\n\t\t\treturn min(j - i, i - j + n);\n\t\t};\n\n\t\tauto norm = [&](int x, int n) {\n\t\t\tx %= n;\n\t\t\tif (x < 0) {\n\t\t\t\tx += n;\n\t\t\t}\n\t\t\treturn x;\n\t\t};\n\t\t\n\t\tMap<int> mp(a);\n\t\tmp.build();\n\t\tvector<vector<int>> pos(mp.size());\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\ta[i] = mp.get(a[i]);\n\t\t\tpos[a[i]].push_back(i);\n\t\t}\n\n\t\tfor (int k = 0; k < m; k ++) {\n\t\t\tint i = que[k];\n\t\t\tint v = a[i];\n\t\t\tint siz = pos[v].size();\n\t\t\tif (siz == 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint idx = ranges::lower_bound(pos[v], i) - pos[v].begin();\n\t\t\tans[k] = min(dis(i, pos[v][norm(idx + 1, siz)]), dis(i, pos[v][norm(idx - 1, siz)]));\n\t\t}\n\n\t\treturn ans;\n\t}\n};","author":"hhhhyf","submissionId":"611233365"},[]]},{"1444":[{"id":"1444","fileName":"611233066.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> indexesByNum;\n        int n = nums.size();\n        vector<int> res;\n        for (int i = 0; i < n; i++) {\n            indexesByNum[nums[i]].emplace_back(i);\n        }\n        for (int query : queries) {\n            auto& indexes = indexesByNum[nums[query]];\n            int m = indexes.size();\n            if (m == 1) res.push_back(-1);\n            else {\n                auto idx = lower_bound(indexes.begin(), indexes.end(), query) - indexes.begin();\n                int left = (idx > 0) ? indexes[idx] - indexes[idx-1] : n + (indexes[idx] - indexes[m-1]);\n                int right = (idx < m - 1) ? indexes[idx+1] - indexes[idx] : n + (indexes[0] - indexes[idx]);\n                // cout << \"query=\" << query << \",left=\" << left << \",right=\" << right << endl;\n                res.push_back(min(left, right));\n            }\n        }\n        return res;\n    }\n};","author":"Huayu Zhang","submissionId":"611233066"},[]]},{"1445":[{"id":"1445","fileName":"611233409.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer,TreeSet<Integer>> hm = new HashMap<>();\n        int n = nums.length;\n        for(int i=0;i<n;i++) {\n            hm.putIfAbsent(nums[i],new TreeSet<>());\n            hm.get(nums[i]).add(i);\n            hm.get(nums[i]).add(i+n);\n        }\n        List<Integer> res = new ArrayList<>();\n        for(int v:queries) {\n            TreeSet<Integer> ts = hm.get(nums[v]);\n            if(ts.size()==2) {\n                res.add(-1);\n                continue;\n            }\n            Integer p = ts.higher(v);\n            int d = p-v;\n            p = ts.lower(v);\n            if(p != null) {\n                d = Math.min(d,v-p);\n            }\n            p = ts.lower(v+n);\n            d = Math.min(d,v+n-p);\n            res.add(d);\n        }\n        return res;\n    }\n}","author":"Knarf","submissionId":"611233409"},[]]},{"1447":[{"id":"1447","fileName":"611233573.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n=len(nums)\n        nums=nums+nums+nums\n        pre=[-inf]*(n*3)\n        suf=[inf]*(n*3)\n        last={}\n        for i in range(n*3):\n            if nums[i] in last:\n                pre[i]=last[nums[i]]\n            last[nums[i]]=i\n        last={}\n        for i in range(n*3-1,-1,-1):\n            if nums[i] in last:\n                suf[i]=last[nums[i]]\n            last[nums[i]]=i\n        res=[]\n        for i in queries:\n            v=min(i+n-pre[i+n],suf[i+n]-i-n)\n            res.append(-1 if v>=n else v)\n        return res\n                ","author":"nnl","submissionId":"611233573"},[]]},{"1448":[{"id":"1448","fileName":"611233556.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n      int n = nums.size();\n      map<int, set<int>> M;\n      for (int i = 0; i < n; i++) M[nums[i]].insert(i);\n      vector<int> ans;\n      for (int i: queries) {\n        if (M[nums[i]].size() == 1) ans.push_back(-1);\n        else {\n          auto it = M[nums[i]].find(i);\n          int res = 0x3f3f3f3f;\n          vector<int> tmp;\n          if (it != M[nums[i]].begin()) tmp.push_back(*prev(it));\n          if (next(it) != M[nums[i]].end()) tmp.push_back(*next(it));\n          tmp.push_back(*M[nums[i]].begin());\n          tmp.push_back(*M[nums[i]].rbegin());\n          //for (auto x: tmp) cout << x << \" \"; cout << endl;\n          for (auto j: tmp) if (j != i) res = min({res, abs(j-i), n-abs(j-i)});\n          ans.push_back(res);\n        }\n      }\n      return ans;\n    }\n};","author":"Darren Hp","submissionId":"611233556"},[]]},{"1449":[{"id":"1449","fileName":"611233332.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        std::unordered_map<int, std::set<int>> dict;\n        for (int i = 0; i < nums.size(); i++) {\n            dict[nums[i]].insert(i);\n        }\n        std::vector<int> res;\n        for (const auto& query : queries) {\n            if (dict[nums[query]].size() == 1) {\n                res.push_back(-1);\n                continue;\n            }\n            auto iter = dict[nums[query]].find(query);\n            int len = 1e9;\n            if (iter == dict[nums[query]].begin()) {\n                len = std::min(len, (int)nums.size() - (int)*(dict[nums[query]].rbegin()) + (int)*iter);\n            } else {\n                int val = *iter;\n                iter--;\n                len = min(val - *iter, len);\n            }\n            iter = dict[nums[query]].find(query);\n            int val = *iter;\n            iter++;\n            if (iter == dict[nums[query]].end()) {\n                len = min(len, (int)*(dict[nums[query]].begin()) + (int)nums.size() - val);\n            } else {\n                len = min(*iter - val, len);\n            }\n            res.push_back(len);\n        }\n        return res;\n    }\n};","author":"cjy","submissionId":"611233332"},[]]},{"1450":[{"id":"1450","fileName":"611233609.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        map<int,vector<int>> mvi;\n        for(int i=0;i<n;++i)\n        {\n            mvi[nums[i]].push_back(i);\n        }\n        for(int &q:queries)\n        {\n            vector<int> &vi=mvi[nums[q]];\n            if(vi.size()<=1U)\n            {\n                q=-1;\n                continue;\n            }\n            int ni=vi.size();\n            int i=lower_bound(vi.begin(),vi.end(),q)-vi.begin();\n            int d1=(i==0 ? vi[i]+n-vi.back() : vi[i]-vi[i-1]);\n            int d2=(i==ni-1 ? vi[0]+n-vi[i] : vi[i+1]-vi[i]);\n            q=min(d1,d2);\n        }\n        return queries;\n    }\n};","author":"周周","submissionId":"611233609"},[]]},{"1451":[{"id":"1451","fileName":"611233639.txt","sourceCode":"class Solution:\n    def solveQueries(self, A: List[int], queries: List[int]) -> List[int]:\n        pos = defaultdict(list)\n        for i,a in enumerate(A):\n            pos[a].append(i)\n        res = []\n        n = len(A)\n        for i in queries:\n            B = pos[A[i]]\n            j = bisect_left(B, i)\n            m = len(B)\n            d1 = (B[j] - B[j - 1]) % n\n            d2 = (B[(j + 1) % m] - B[j]) % n\n            d = min(d1, d2)\n            res.append(d if 0 < d < n else -1)\n        return res","author":"Han3000","submissionId":"611233639"},[]]},{"1453":[{"id":"1453","fileName":"611233671.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        mid = defaultdict(list)\n        for idx, num in enumerate(nums):\n            mid[num].append(idx)\n         \n        for num in mid:\n            mid[num].sort()\n        \n        res = []\n        for q in queries:\n            x = nums[q]\n            indices = mid.get(x, [])\n            if len(indices) <= 1:\n                res.append(-1)\n                continue\n             \n            pos = bisect.bisect_left(indices, q) \n            assert indices[pos] == q\n             \n            candidates = [] \n            if pos > 0:\n                candidates.append(indices[pos-1])\n            else: \n                candidates.append(indices[-1]) \n            if pos < len(indices) - 1:\n                candidates.append(indices[pos+1])\n            else: \n                candidates.append(indices[0]) \n            candidates.append(indices[0])\n            candidates.append(indices[-1])\n             \n            valid = [c for c in candidates if c != q]\n            if not valid:\n                res.append(-1)\n                continue\n             \n            min_dist = float('inf')\n            for c in valid:\n                d = abs(c - q)\n                circular_d = n - d\n                current_min = min(d, circular_d)\n                if current_min < min_dist:\n                    min_dist = current_min\n            \n            res.append(min_dist if min_dist != float('inf') else -1)\n        \n        return res","author":"|_・)","submissionId":"611233671"},[]]},{"1455":[{"id":"1455","fileName":"611233695.txt","sourceCode":"from bisect import bisect_left\ndef fmin(x, y):\n    if x < y:\n        return x\n    return y\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        indices = defaultdict(list)\n        n = len(nums)\n        for idx, num in  enumerate(nums):\n            indices[num].append(idx)\n        ans = []\n        for i in queries:\n            num = nums[i]\n            indice = indices[num]\n            if len(indice) == 1:\n                ans.append(-1)\n            else:\n                k = len(indice)\n                rdx = bisect_left(indice, i)\n                left = (rdx - 1) % k\n                right = (rdx + 1) % k\n                l = abs(indice[left] - i) % n\n                r = abs(indice[right] - i) % n\n                a = fmin(fmin(l, n - l), fmin(r, n - r))\n                ans.append(a)\n        return ans","author":"ikun","submissionId":"611233695"},[]]},{"1456":[{"id":"1456","fileName":"611233779.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[]} queries\n * @return {number[]}\n */\nvar solveQueries = function(nums, queries) {\n    let dic=new Map();\n    nums.forEach((u,i)=>{\n        if(dic.has(u)){\n            dic.get(u).push(i);\n        }else{\n            dic.set(u,[i]);\n        }\n    });\n    function f(a,s,e,t){\n        let i=parseInt((s+e)/2);\n        if(a[i]==t)\n            return i;\n        return a[i]<t?f(a,i+1,e,t):f(a,s,i-1,t);\n    }\n    return queries.map(i=>{\n        let a=dic.get(nums[i]);\n        if(a.length==1)\n            return -1;\n        let index=f(a,0,a.length-1,i);\n        let d=Math.min(index!=0?a[index]-a[index-1]:a[index]+nums.length-a[a.length-1],index==a.length-1?a[0]+nums.length-a[index]:a[index+1]-a[index]);\n        return d;\n    });\n};","author":"wangzi","submissionId":"611233779"},[]]},{"1457":[{"id":"1457","fileName":"611233832.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> numIndices = new HashMap<Integer, List<Integer>>();\n        int length = nums.length;\n        for (int i = 0; i < length; i++) {\n            numIndices.putIfAbsent(nums[i], new ArrayList<Integer>());\n            numIndices.get(nums[i]).add(i);\n        }\n        Map<Integer, List<Integer>> numCircularIndices = new HashMap<Integer, List<Integer>>();\n        Set<Map.Entry<Integer, List<Integer>>> entries = numIndices.entrySet();\n        for (Map.Entry<Integer, List<Integer>> entry : entries) {\n            numCircularIndices.put(entry.getKey(), getCircularIndices(entry.getValue(), length));\n        }\n        List<Integer> answer = new ArrayList<Integer>();\n        for (int query : queries) {\n            List<Integer> circularIndices = numCircularIndices.get(nums[query]);\n            int size = circularIndices.size();\n            int position = binarySearch(circularIndices, query);\n            int distanceLeft = position > 0 ? circularIndices.get(position) - circularIndices.get(position - 1) : Integer.MAX_VALUE;\n            if (distanceLeft == length) {\n                distanceLeft = Integer.MAX_VALUE;\n            }\n            int distanceRight = position < size - 1 ? circularIndices.get(position + 1) - circularIndices.get(position) : Integer.MAX_VALUE;\n            if (distanceRight == length) {\n                distanceRight = Integer.MAX_VALUE;\n            }\n            int distance = Math.min(distanceLeft, distanceRight);\n            answer.add(distance != Integer.MAX_VALUE ? distance : -1);\n        }\n        return answer;\n    }\n\n    public List<Integer> getCircularIndices(List<Integer> indices, int length) {\n        List<Integer> circularIndices = new ArrayList<Integer>();\n        for (int index : indices) {\n            circularIndices.add(index - length);\n        }\n        for (int index : indices) {\n            circularIndices.add(index);\n        }\n        for (int index : indices) {\n            circularIndices.add(index + length);\n        }\n        return circularIndices;\n    }\n\n    public int binarySearch(List<Integer> circularIndices, int target) {\n        int low = 0, high = circularIndices.size() - 1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (circularIndices.get(mid) == target) {\n                return mid;\n            } else if (circularIndices.get(mid) > target) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return -1;\n    }\n}","author":"冰淇淋","submissionId":"611233832"},[]]},{"1458":[{"id":"1458","fileName":"611233962.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        vector<int> ans;\n        unordered_map<int, vector<int>> m;\n        for(int i=0;i<n;++i) m[nums[i]].emplace_back(i);\n        for(auto &i:queries){\n            auto &t=m[nums[i]];\n            if(t.size()==1){\n                ans.emplace_back(-1);\n                continue;\n            }\n            auto k=lower_bound(t.begin(), t.end(), i)-t.begin();\n            int l=k?t[k-1]:t.back(), r=(k+1==t.size()?t[0]:t[k+1]);\n            l=abs(i-l), r=abs(i-r);\n            l=min(l, n-l), r=min(r, n-r);\n            ans.emplace_back(min(l, r));\n        }\n        return ans;\n    }\n};","author":"大愚若智","submissionId":"611233962"},[]]},{"1459":[{"id":"1459","fileName":"611233620.txt","sourceCode":"\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& Qu) {\n        int n = a.size();\n        std::vector<int> nums;\n        for(int i = 0; i < n; i ++){\n            a[i] --;\n            a.push_back(a[i]);\n            nums.push_back(a[i]);\n        }\n        \n        std::sort(nums.begin(), nums.end());\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\n        const int inf = 1e9;\n        std::vector<std::vector<int> > G(nums.size());         \n        for(int i = 0; i < n * 2; i ++){\n            G[lower_bound(nums.begin(), nums.end(), a[i]) - nums.begin()].push_back(i);\n        }\n        \n        std::vector<int> ans(n * 2, inf);\n        \n        for(int i = 0; i < nums.size(); i ++){\n            if(G[i].size() > 2){\n                int last = -1;\n                for(auto t : G[i]){\n                    if(last == -1) last = t;\n                    else{\n                        ans[last] = std::min(ans[last], t - last);\n                        ans[t] = std::min(ans[t], t - last);\n                        last = t;\n                    }\n                }\n            }\n        }\n        \n        for(int i = 0; i < n; i ++) ans[i] = std::min(ans[i], ans[i + n]);\n        std::vector<int> res;\n        for(auto q : Qu) {\n            res.push_back(ans[q] == inf ? -1 : ans[q]);\n        }\n        return res;\n    }\n};","author":"WUHUQIFEI123","submissionId":"611233620"},[]]},{"1460":[{"id":"1460","fileName":"611233966.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], Q: List[int]) -> List[int]:\n        \n        def dis(x, y, n):\n            x, y = min(x, y), max(x, y)\n            return min(y - x, x + n - y)\n        \n        d = defaultdict(list)\n        for i, a in enumerate(nums):\n            d[a].append(i)\n        res = [-1] * len(Q)\n        for i in range(len(Q)):\n            a = nums[Q[i]]\n            if len(d[a]) == 1:\n                continue\n            arr = d[a]\n            idx = bisect.bisect_left(arr, Q[i])\n            # print(i, arr, idx)\n            n = len(arr)\n            prev = (idx - 1 + n) % n\n            nxt = (idx + 1) % n\n            # print(prev, nxt)\n            res[i] = min(dis(Q[i], arr[prev], len(nums)), dis(Q[i], arr[nxt], len(nums)))\n        return res\n        ","author":"Doudle","submissionId":"611233966"},[]]},{"1461":[{"id":"1461","fileName":"611233824.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        pos = defaultdict(list)\n        for i, num in enumerate(nums):\n            pos[num].append(i)\n        ans = [-1] * n\n        for num, indices in pos.items():\n            if len(indices) == 1:\n                continue\n            indices.sort()\n            k = len(indices)\n            for i, cur in enumerate(indices):\n                if i == 0:\n                    prev_dist = cur + n - indices[-1]\n                else:\n                    prev_dist = cur - indices[i-1]\n                if i == k - 1:\n                    next_dist = indices[0] + n - cur\n                else:\n                    next_dist = indices[i+1] - cur\n                ans[cur] = min(prev_dist, next_dist)\n        return [ans[q] for q in queries]\n","author":"mywaythere","submissionId":"611233824"},[]]},{"1462":[{"id":"1462","fileName":"611234032.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size(),m=queries.size();\n        int the_max=*max_element(nums.begin(),nums.end());\n        vector<vector<int>> arr(the_max+1);\n        for (int i=0;i<n;i++){\n            arr[nums[i]].push_back(i);\n        }\n        vector<int> ans(m);\n        for (int i=0;i<m;i++){\n            int q=queries[i],x=nums[q];\n            if (arr[x].size()<=1) ans[i]=-1;\n            else{\n                int it=lower_bound(arr[x].begin(),arr[x].end(),q)-arr[x].begin();\n                int temp=INT_MAX,len=arr[x].size();\n                if (it>=1){\n                    temp=min({temp,q-arr[x][it-1],n-q+arr[x][it-1]});\n                    if (it==len-1) temp=min(temp,n-q+arr[x][0]);\n                }\n                if (it<len-1){\n                    temp=min({temp,arr[x][it+1]-q,n-arr[x][it+1]+q});\n                    if (it==0) temp=min(temp,q+n-arr[x][len-1]);\n                }\n                ans[i]=temp;\n            }\n        }\n        return ans;\n    }\n};","author":"Edward","submissionId":"611234032"},[]]},{"1463":[{"id":"1463","fileName":"611234007.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        d = defaultdict(list)\n        \n        for i in range(n):\n            d[nums[i]].append(i)\n            \n        for l in d.values():\n            l.sort()\n            \n        ans = []\n        \n        for i in queries:\n            l = d[nums[i]]\n            if len(l)==1:\n                ans.append(-1)\n                continue\n            tmp = 10**15\n            idx = bisect_left(l, i)\n            tmp = min(tmp, min((l[(idx+1)%len(l)]-i)%n, (-l[(idx+1)%len(l)]+i)%n))\n            tmp = min(tmp, min((i-l[(idx-1)%len(l)])%n, (-i+l[(idx-1)%len(l)])%n))\n            ans.append(tmp)\n        \n        return ans\n                \n            \n        \n        ","author":"Perlman","submissionId":"611234007"},[]]},{"1464":[{"id":"1464","fileName":"611234069.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        cnt = defaultdict(list)\n        n = len(nums)\n        ans = []\n        for i, x in enumerate(nums):\n            cnt[x].append(i)\n        for q in queries:\n            \n            c = cnt[nums[q]]\n            if len(c)==1:\n                ans.append(-1)\n                continue\n            pos1 = bisect_right(c, q)\n            pos2 = bisect_left(c, q)-1\n            if pos1==len(c):\n                x=n-(q-c[0])\n            else:\n                x=c[pos1]-q\n            if pos2==-1:\n                y=n-(c[-1]-q)\n            else:\n                y=q-c[pos2]\n            ans.append(min(x,y))\n        return ans\n    \n","author":"Smile","submissionId":"611234069"},[]]},{"1465":[{"id":"1465","fileName":"611234063.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        al = dict()\n        for i, num in enumerate(nums):\n            if num not in al:\n                al[num] = []\n            al[num].append(i)\n        ret = []\n        for q in queries:\n            target = nums[q]\n            if len(al[target]) == 1:\n                ret.append(-1)\n            else:\n                \n                index = bisect_left(al[target], q)\n                l, r = index - 1, index + 1\n                if index == 0:\n                    l = len(al[target]) - 1\n                if index == len(al[target]) - 1:\n                    r = 0\n\n                t = min(abs(q - al[target][l]), n - abs(q - al[target][l]), abs(q - al[target][r]), n - abs(q - al[target][r]))\n                ret.append(t)\n        return ret","author":"下次认真取名","submissionId":"611234063"},[]]},{"1466":[{"id":"1466","fileName":"611234103.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> result = new ArrayList<>();\n        \n        HashMap<Integer, List<Integer>> map = new HashMap<>();\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            map.putIfAbsent(nums[i], new ArrayList<Integer>());\n            List<Integer> temp = map.get(nums[i]);\n            \n            temp.add(i);\n        }\n        \n        for (int query: queries) {\n            int value = nums[query];\n            List<Integer> list = map.get(value);\n            int distance = getDistance(n, list, query);\n            result.add(distance);\n        }\n        \n        return result;\n    }\n    \n    private int getDistance(int n, List<Integer> list, int value) {\n        if (list.size() == 1) {\n            return -1;\n        }\n        \n        int pos = bs(list, value);\n        int size = list.size();\n        int left = (pos - 1 + size) % size;\n        int right = (pos + 1) % size;\n        \n        int disl = (value - list.get(left) + n) % n;\n        int disr = (list.get(right) - value + n) % n;\n        \n        return Math.min(disl, disr);\n    } \n    \n    private int bs(List<Integer> list, int value) {\n        int n = list.size();\n        \n        int l = 0;\n        int r = n - 1;\n        while (r >= l) {\n            int m = l + (r - l) / 2;\n            if (list.get(m) == value) {\n                return m;\n            }\n            if (list.get(m) > value) {\n                r = m - 1;\n            } else {\n                l = m + 1;\n            }\n        }\n        return -1;\n    }\n    \n    \n}","author":"Astric","submissionId":"611234103"},[]]},{"1467":[{"id":"1467","fileName":"611234174.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n = nums.size(), m = q.size();\n        vector<int> ans(m, -1);\n        map<int, vector<int>> mp;\n        for(int i = 0; i < n; i++) mp[nums[i]].push_back(i);\n        vector<int> f(n+5, -1);\n        for(auto [x, vec]: mp) {\n            if(vec.size() == 1) f[vec[0]] = -1;\n            else {\n                int len = vec.size();\n                for(int j = 1; j < len - 1; j++) {\n                    int mi = min(vec[j + 1] - vec[j], vec[j] - vec[j - 1]);\n                    f[vec[j]] = mi;\n                }\n                f[vec[0]] = min(vec[1] - vec[0], vec[0] + n - vec[len - 1]);\n                f[vec[len - 1]] = min(vec[len - 1] - vec[len - 2], vec[0] + n - vec[len - 1]);\n            }\n        }\n        for(int i = 0; i < m; i++) {\n            ans[i] = f[q[i]];\n        }\n        return ans;\n    }\n};","author":"lin1314_fan","submissionId":"611234174"},[]]},{"1468":[{"id":"1468","fileName":"611234176.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        d = [-1] * n\n        c = defaultdict(int)\n        v = defaultdict(int)\n        for i,x in enumerate(nums):\n\n            if x not in c:\n                c[x] = i\n                v[x] = i\n                continue\n            if d[i] == -1:\n                d[i] = (i - c[x])\n                if x in v:\n                    d[i] = min(d[i],n - (i - v[x]))\n            else:\n                if x in v:\n                    d[i] = min(d[i],n - (i - v[x]))\n                d[i] = min(d[i],i - c[x])\n            c[x] = i\n\n        c = defaultdict(int)\n        v = defaultdict(int)\n        for i in range(n - 1,-1,-1):\n            x = nums[i]\n            if x not in c:\n                c[x] = i\n                v[x] = i\n                continue\n            if d[i] == -1:\n                d[i] = c[x] - i\n                if x in v:\n                    d[i] = min(d[i],n - (v[x] - i))\n            else:\n                d[i] = min(d[i],c[x] - i)\n                if x in v:\n                    d[i] = min(d[i],n - (v[x] - i))\n            c[x] = i\n\n        ans = []\n        for x in queries:\n            ans.append(d[x])\n        return ans\n","author":"__yyn__","submissionId":"611234176"},[]]},{"1469":[{"id":"1469","fileName":"611234226.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), q = queries.size();\n        map<int, vector<int>> pos;\n        for(int i = 0; i < n; i++) {\n            pos[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(int i = 0; i < q; i++) {\n            int x = queries[i];\n            int num = nums[x];\n            vector<int> &npos = pos[num];\n            if(npos.size() == 1) {\n                ans.push_back(-1);\n            } else {\n                auto p = lower_bound(npos.begin(), npos.end(), x);\n                if(next(p) == npos.end()) {\n                    ans.push_back(min(*p - *prev(p), (npos[0] - *p + n)));\n                } else if(p == npos.begin()) {\n                    ans.push_back(min(*next(p) - *p, (*p - npos.back() + n)));\n                } else {\n                    ans.push_back(min(*p - *prev(p), *next(p) - *p));\n                }\n            }\n        }\n        return ans;\n    }\n};","author":"Khoray","submissionId":"611234226"},[]]},{"1470":[{"id":"1470","fileName":"611233933.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dic = {}\n        n = len(nums)\n        for i, c in enumerate(nums):\n            if c not in dic:\n                dic[c] = []\n            dic[c].append(i)\n        ans = []\n        for i in range(len(queries)):\n            ind = queries[i]\n            num = nums[ind]\n            if len(dic[num]) == 1:\n                ans.append(-1)\n                continue\n            indind = bisect.bisect_left(dic[num], ind)\n            tot = len(dic[num])\n            if indind == 0:\n                indleft = tot - 1\n            else:\n                indleft = indind - 1\n            if indind == tot - 1:\n                indright = 0\n            else:\n                indright = indind + 1\n            disleft = min(abs(ind - dic[num][indleft]), n - abs(ind - dic[num][indleft]))\n            disright = min(abs(ind - dic[num][indright]), n - abs(ind - dic[num][indright]))\n            ans.append(min(disleft, disright))\n        return ans\n            ","author":"叶刃","submissionId":"611233933"},[]]},{"1471":[{"id":"1471","fileName":"611234236.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>> idxs;\n        for(int i=0;i<nums.size();++i){\n            idxs[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        auto calc_dis=[&](int a,int b){\n            if(a<b){\n                swap(a,b);\n            }\n            return min(a-b, b+(int)nums.size()-a);\n        };\n        for(int q:queries){\n            if(idxs[nums[q]].size()==1){\n                ans.push_back(-1);\n            }else{\n                auto &idx=idxs[nums[q]];\n                int l=0,r=idx.size();\n                while(l<r){\n                    int m=l+(r-l)/2;\n                    if(idx[m]>=q){\n                        r=m;\n                    }else{\n                        l=m+1;\n                    }\n                }\n                int dis=INT_MAX, n=idx.size();\n                dis=min(dis, calc_dis(idx[l],idx[(l+n-1)%n]));\n                dis=min(dis, calc_dis(idx[(l+n+1)%n],idx[l]));\n                ans.push_back(dis);\n            }\n        }\n        return ans;\n    }\n};","author":"无名棋脚","submissionId":"611234236"},[]]},{"1472":[{"id":"1472","fileName":"611234258.txt","sourceCode":"function solveQueries(u: number[], q: number[]): number[] {\n  const n = u.length;\n  const r = new Array(n).fill(0);\n  const m = new Map<number, number>();\n  const f = new Map<number, number>();\n\n  for (let i = 0; i < n; i++) {\n    const v = u[i];\n\n    if (!f.has(v)) {\n      f.set(v, i);\n      m.set(v, i);\n      r[i] = -1;\n    } else {\n      const mi = m.get(v)!;\n      const fi = f.get(v)!;\n\n      r[i] = Math.min(i - mi, fi + n - i);\n\n      if (r[fi] === -1 || r[fi] > fi + n - i) {\n        r[fi] = fi + n - i;\n      }\n\n      if (r[mi] === -1 || r[mi] > i - mi) {\n        r[mi] = i - mi;\n      }\n\n      m.set(v, i);\n    }\n  }\n\n  return q.map((i) => r[i]);\n}\n","author":"Noah","submissionId":"611234258"},[]]},{"1473":[{"id":"1473","fileName":"611234267.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        mp, idxs = defaultdict(list), [0]*len(nums)\n        for i in range(len(nums)):\n            mp[nums[i]].append(i)\n            idxs[i] = len(mp[nums[i]])-1\n        ans = []\n        for i in queries:\n            cl, ci = mp[nums[i]], idxs[i]\n            if len(cl) == 1:\n                ans.append(-1)\n            else:\n                cv = min(len(nums)-cl[ci]+cl[0], cl[ci]+len(nums)-cl[-1])\n                if ci+1 < len(cl):\n                    cv = min(cv, cl[ci+1]-cl[ci])\n                if ci-1 >= 0:\n                    cv = min(cv, cl[ci]-cl[ci-1])\n                ans.append(cv)\n        return ans","author":"速冻小鹿包","submissionId":"611234267"},[]]},{"1474":[{"id":"1474","fileName":"611233971.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, set<int>> v2p;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            v2p[nums[i]].insert(i);\n        }\n        \n        auto calc = [&](const set<int> &ps, int nowPos) -> int {\n            if (ps.size() <= 1) return -1;\n            \n            int pre = findPre(ps, nowPos);\n            int next = findNext(ps, nowPos);\n            return min(\n                ((pre < nowPos) ? nowPos - pre : nowPos + n - pre),\n                ((nowPos < next) ? next - nowPos : next + n - nowPos)\n            );\n        };\n        \n        vector<int> ans;\n        for (auto qi : queries) {\n            int qv = nums[qi];\n            ans.push_back(calc(v2p[qv], qi));\n        }\n        return ans;\n    }\n    int findPre(const set<int> &ps, int nowPos) {\n        auto ite = ps.find(nowPos);\n        if (ite == ps.begin()) return *--ps.end();\n        else return *--ite;\n    }\n    int findNext(const set<int> &ps, int nowPos) {\n        auto ite = ps.find(nowPos);\n        ++ite;\n        if (ite == ps.end()) return *ps.begin();\n        else return *ite;\n    }\n};","author":"seedjyh","submissionId":"611233971"},[]]},{"1476":[{"id":"1476","fileName":"611234321.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int, int> cnt;\n        for(int i = 0; i < n; i++) {\n            nums.push_back(nums[i]);\n            cnt[nums[i]] += 1;\n        }\n        for(int i = 0; i < n; i++) {\n            nums.push_back(nums[i]);\n        }\n\n        vector<int> lt1(1e6 + 5, -1), pos1(3 * n, 1e9);\n        vector lt2 = lt1, pos2 = pos1;\n        for(int i = 0; i < 3 * n; i++) {\n            int val = nums[i];\n            if(lt1[val] != -1) {\n                pos1[i] = i - lt1[val];\n            }\n            lt1[val] = i;\n        }\n\n        for(int i = 3 * n - 1; i >= 0; i--) {\n            int val = nums[i];\n            if(lt2[val] != -1) {\n                pos2[i] = lt2[val] - i;\n            }\n            lt2[val] = i;\n        }\n\n        \n        vector<int> ans;\n        for(int i : queries) {\n            int x = i + n;\n            if(cnt[nums[i]] == 1) {\n                ans.push_back(-1);\n            }\n            else {\n                ans.push_back(min(pos1[x], pos2[x]));\n            }\n        }\n        return ans;\n    }\n};","author":"snowy2002","submissionId":"611234321"},[]]},{"1477":[{"id":"1477","fileName":"611234295.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int find(List<Integer> vs, int v) {\n        int l = 0;\n        int r = vs.size() - 1;\n        while (l < r) {\n            int mid = (l + r) / 2;\n            if (vs.get(mid) >= v) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> res = new ArrayList<>();\n        Map<Integer, List<Integer>> pos = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            pos.computeIfAbsent(nums[i], l -> new ArrayList<>()).add(i);\n        }\n        for (int k : pos.keySet()) {\n            Collections.sort(pos.get(k));\n        }\n        int n = nums.length;\n        for (int q : queries) {\n            int v = nums[q];\n            List<Integer> cur = pos.get(v);\n            if (cur.size() == 1) {\n                res.add(-1);\n            } else {\n                int t = find(cur, q);\n                if (t == 0) {\n                    int a = Math.min(cur.get(t + 1) - cur.get(t), n - (cur.get(t + 1) - cur.get(t)));\n                    int b = Math.min(cur.get(cur.size() - 1) - cur.get(0), n - (cur.get(cur.size() - 1) - cur.get(0)));\n                    res.add(Math.min(a, b));\n                } else if (t == cur.size() - 1) {\n                    int a = Math.min(cur.get(t) - cur.get(0), n - (cur.get(t) - cur.get(0)));\n                    int b = Math.min(cur.get(t) - cur.get(t - 1), n - (cur.get(t) - cur.get(t - 1)));\n                    res.add(Math.min(a, b));\n                } else {\n                    int a = Math.min(cur.get(t + 1) - cur.get(t), n - (cur.get(t + 1) - cur.get(t)));\n                    int b = Math.min(cur.get(t) - cur.get(t - 1), n - (cur.get(t) - cur.get(t - 1)));\n                    res.add(Math.min(a, b));\n                }\n            }\n        }\n        return res;\n    }\n}","author":"acvv_Nickdd","submissionId":"611234295"},[]]},{"1479":[{"id":"1479","fileName":"611234366.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> ret = new ArrayList<>();\n        int n = nums.length;\n        Map<Integer, List<Integer>> hash = new HashMap<>();\n        for (int i = 0; i < n ; ++i)   {\n            int x = nums[i];\n            if (!hash.containsKey(x)) {\n                hash.put(x, new ArrayList<>());\n            }\n            hash.get(x).add(i);\n        }\n        int m = queries.length;        \n        for (int i = 0; i < m ; ++i) {\n            int x = queries[i];\n            int v = nums[x];\n            if (hash.get(v).size() == 1) {\n                ret.add(-1);\n            } else {\n                List<Integer> cur = hash.get(v);\n                int lo = 0, hi = cur.size() - 1;\n                while (lo < hi) {\n                    int mid = lo + hi >> 1;\n                    if (cur.get(mid) >= x) {\n                        hi = mid;\n                    } else {\n                        lo = mid + 1;\n                    }\n                }\n                int size = cur.size();\n                if (lo == 0) {\n                    int c = Math.min(cur.get(lo + 1) - cur.get(lo),\n                                     cur.get(lo) - cur.get(size - 1) + n);       \n                    ret.add(c);\n                    \n                } else if (lo == cur.size() - 1) {\n                    int c = Math.min(cur.get(lo) - cur.get(lo - 1),\n                                      cur.get(0) - cur.get(lo) + n);\n                    ret.add(c);\n                                    \n                } else {\n                    int c = Math.min(cur.get(lo) - cur.get(lo - 1),\n                                     cur.get(lo + 1) - cur.get(lo));\n                    ret.add(c);\n                }\n            }\n        }\n        return ret;\n        \n    }\n}","author":"Scott","submissionId":"611234366"},[]]},{"1480":[{"id":"1480","fileName":"611234395.txt","sourceCode":"class Solution {\n  public:\n    vector<int> solveQueries(vector<int> &nums, vector<int> &queries) {\n        int n = (int)nums.size(), m = (int)queries.size();\n\n        unordered_map<int, int> v;\n        vector<int> ans(n, -1);\n\n        for (int i = 0; i < n; i++) {\n            if (v.contains(nums[i])) {\n                auto idx = v[nums[i]];\n\n                ans[i] = i - idx;\n                ans[idx] = ans[idx] == -1 ? i - idx : min(ans[idx], i - idx);\n            }\n            v[nums[i]] = i;\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (v.contains(nums[i])) {\n                auto idx = v[nums[i]];\n                if (idx == i) {\n                    continue;\n                }\n\n                ans[i] = min((i - idx + n) % n, ans[i]);\n                ans[idx] = ans[idx] == -1 ? (i - idx + n) % n\n                                          : min(ans[idx], (i - idx + n) % n);\n            }\n            v[nums[i]] = i;\n        }\n\n        vector<int> res(m);\n        for (int i = 0; i < m; i++) {\n            res[i] = ans[queries[i]];\n        }\n        return res;\n    }\n};","author":"丁真今天写什么","submissionId":"611234395"},[]]},{"1481":[{"id":"1481","fileName":"611234421.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, TreeSet<Integer>> locs = new HashMap<>();\n        int n = nums.length;\n\n        for (int i = 0; i < n; i++) {\n            TreeSet<Integer> ts = locs.getOrDefault(nums[i], new TreeSet<Integer>());\n            ts.add(i);\n            locs.put(nums[i], ts);\n        }\n\n        // int[] ans = new int[queries.length];\n        List<Integer> ans = new ArrayList<>();\n        for (int i = 0; i < queries.length; i++) {\n            int idx = queries[i];\n            int x = nums[idx];\n            int mn = n + 1;\n            TreeSet<Integer> ts = locs.get(x);\n            if (ts.higher(idx) != null) {\n                mn = Math.min(mn, ts.higher(idx) - idx);\n            }\n            if (ts.lower(idx) != null) {\n                mn = Math.min(mn, idx - ts.lower(idx));\n            }\n            if (ts.first() != idx) {\n                mn = Math.min(mn, n - idx + ts.first());\n            }\n            if (ts.last() != idx) {\n                mn = Math.min(mn, n - ts.last() + idx);\n            }\n\n            ans.add(mn == n + 1 ? -1 : mn);\n        }\n\n        return ans;\n    }\n}","author":"Nanmor","submissionId":"611234421"},[]]},{"1482":[{"id":"1482","fileName":"611234452.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        const int N = nums.size();\n        const int Q = queries.size();\n        map<int, int> prev;\n        vector<int> minDist(N, INT_MAX);\n        for (int i = 0; i < N; i++) {\n            if (prev.count(nums[i])) {\n                auto dist = min(i - prev[nums[i]], N + prev[nums[i]] - i);\n                minDist[i] = min(minDist[i], dist);\n                minDist[prev[nums[i]]] = min(minDist[prev[nums[i]]], dist);\n            }\n            prev[nums[i]] = i;\n        }\n        for (int i = 0; i < N; i++) {\n            if (prev[nums[i]] != i) {\n                auto dist = prev[nums[i]] > i ? min(prev[nums[i]] - i, N + i - prev[nums[i]]) : min(i - prev[nums[i]], N + prev[nums[i]] - i);\n                minDist[i] = min(minDist[i], dist);\n                minDist[prev[nums[i]]] = min(minDist[prev[nums[i]]], dist);\n            }\n            prev[nums[i]] = i;\n        }\n        vector<int> ans;\n        for (int q : queries) {\n            if (minDist[q] == INT_MAX) {\n                ans.push_back(-1);\n            } else {\n                ans.push_back(minDist[q]);\n            }\n        }\n        return ans;\n    }\n};","author":"HamsiK","submissionId":"611234452"},[]]},{"1483":[{"id":"1483","fileName":"611234397.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], qu: List[int]) -> List[int]:\n        \n        f = {i:[] for i in set(nums)}\n        for i,v in enumerate(nums):\n            f[v].append(i)\n\n        n = len(qu)\n        m = len(nums)\n        ans = [0]*n\n        def dis(x,y):\n            x,y = max(x,y),min(x,y)\n            return min(abs(x-y),abs(y+m-x))\n        for i in range(n):\n            res = 99999999999999\n            t = nums[qu[i]]\n            j = bisect_left(f[t],qu[i])\n            # print(j,f[t])\n            res = min(res,dis(f[t][(j-1)%len(f[t])],qu[i]))\n            res = min(res,dis(f[t][(j+1)%len(f[t])],qu[i]))\n            ans[i] = res if res<1e6 and res!=0 else -1\n        return ans\n        ","author":"乾杯 []~（￣▽￣）~*","submissionId":"611234397"},[]]},{"1484":[{"id":"1484","fileName":"611234568.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, set<int>> ma;\n\n        int n = nums.size();\n        int p = queries.size();\n        vector<int> res(p, INT_MAX);\n        for(int i=0;i<n;i++) {\n            ma[nums[i]].insert(i);\n            ma[nums[i]].insert(n + i);\n            ma[nums[i]].insert(2 * n + i);\n        }\n\n        for(int i=0;i<p;i++) {\n            int q = queries[i] + n;\n            int num = nums[q - n];\n            set<int>& vis = ma[num];\n\n            if(vis.size() == 3) {\n                res[i] = -1;\n                continue;\n            }\n\n            auto upper = vis.upper_bound(q);\n            if(upper != vis.end()) {\n                res[i] = min(res[i], *upper - q);\n            }\n\n            auto lower = vis.lower_bound(q);\n            if(lower != vis.begin()) {\n                res[i] = min(res[i], q - *prev(lower));\n            }\n        }\n\n        return res;\n    }\n};","author":"陈小斌","submissionId":"611234568"},[]]},{"1485":[{"id":"1485","fileName":"611234455.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp; vector<int> ret;\n        for(int i=0; i<nums.size(); i++) {\n            mp[nums[i]].push_back(i);\n        }\n        int n = nums.size();\n        for(int x : queries) {\n            int val = nums[x];\n            if(mp[val].size() == 1) ret.push_back(-1);\n            else {\n                auto it = lower_bound(mp[val].begin(), mp[val].end(), x); int ans = 1e9;\n                if(it != mp[val].begin()) {\n                    int xx = *it - *prev(it);\n                    ans = min(ans, min(xx, n - xx));\n                } else if (*it != *mp[val].rbegin()) {\n                    int xx = *mp[val].rbegin() - *it;\n                    ans = min(ans, min(xx, n - xx));\n                }\n                if(next(it) != mp[val].end()) {\n                    int xx = *next(it) - *it;\n                    ans = min(ans, min(xx, n - xx));\n                } else if (it != mp[val].begin()) {\n                    int xx = *it - *mp[val].begin();\n                    ans = min(ans, min(xx, n - xx));\n                }\n                ret.push_back(ans);\n            }\n        }\n        return ret;\n    }\n};","author":"nnKoala","submissionId":"611234455"},[]]},{"1486":[{"id":"1486","fileName":"611234692.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        auto get = [&](int x, int y) {\n            int t = abs(x - y);\n            return min(t, n - t);\n        };\n        for (auto &x : queries) {\n            auto it = lower_bound(mp[nums[x]].begin(), mp[nums[x]].end(), x);\n            int t = n;\n            if (it != mp[nums[x]].begin()) t = min(t, get(*it, *prev(it)));\n            else t = min(t, get(*it, mp[nums[x]].back()));\n            if (next(it) != mp[nums[x]].end()) t = min(t, get(*it, *next(it)));\n            else t = min(t, get(*it, mp[nums[x]][0]));\n            ans.push_back(t ? t : -1);\n        }\n        return ans;\n    }\n};","author":"onlyblues","submissionId":"611234692"},[]]},{"1487":[{"id":"1487","fileName":"611234473.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        nums = nums+nums\n        def check(nums):\n            dic = {}\n            ans = [n]*n\n            for i,x in enumerate(nums):\n                if x in dic:\n                    ans[i%n] = min(ans[i%n],abs(i-dic[x]))\n                dic[x] = i\n            return ans\n        ans1 = check(nums)\n        ans2 = check(nums[::-1])[::-1]\n        res = []\n        for i in queries:\n            d = min(ans1[i],ans2[i])\n            if d>n-1:\n                d = -1\n            res.append(d)\n        return res\n        \n            \n        ","author":"又不会写了","submissionId":"611234473"},[{"id":"1879","similarity":1.0,"totOverlap":102,"longestOverlap":51}]],"1879":[{"id":"1879","fileName":"611247905.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        nums = nums+nums\n        def check(nums):\n            dic = {}\n            ans = [n]*n\n            for i,x in enumerate(nums):\n                if x in dic:\n                    ans[i%n] = min(ans[i%n],abs(i-dic[x]))\n                dic[x] = i\n            return ans\n        ans1 = check(nums)\n        ans2 = check(nums[::-1])[::-1]\n        res = []\n        for i in queries:\n            d = min(ans1[i],ans2[i])\n            if d>n-1:\n                d = -1\n            res.append(d)\n        return res\n        \n            \n        ","author":"只会暴力","submissionId":"611247905"},[{"id":"1487","similarity":1.0,"totOverlap":102,"longestOverlap":51}]]},{"1489":[{"id":"1489","fileName":"611234725.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n2 = len(nums)\n        mp = defaultdict(list)\n        for i, x in enumerate(nums):\n            mp[x].append(i)\n        ans = []\n        for q in queries:\n            if len(mp[nums[q]]) == 1:\n                ans.append(-1)\n            else:\n                arr = mp[nums[q]]\n                idx = bisect_left(arr, q)\n                n = len(arr)\n                left = arr[(idx - 1) % n]\n                right = arr[(idx + 1) % n]\n                ans.append(min(\n                    abs(q - left),\n                    abs(q + n2 - left),\n                    abs(right - q),\n                    abs(right + n2 - q)\n                ))\n        return ans\n","author":"stargazy","submissionId":"611234725"},[]]},{"1491":[{"id":"1491","fileName":"611234783.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>> m;\n        int n=nums.size();\n        for(int i=0;i<n;i++)\n            m[nums[i]].emplace_back(i);\n        vector<int> res;\n        res.reserve(queries.size());\n        for(auto q:queries){\n            int val=nums[q];\n            if(m[val].size()==1)\n                res.emplace_back(-1);\n            else{\n                int id=lower_bound(m[val].begin(),m[val].end(),q)-m[val].begin();\n                int len=m[val].size();\n                // res.emplace_back(m[val][id]);\n                res.emplace_back(min((m[val][(id+1)%len]-m[val][id]+n)%n,(-m[val][(id-1+len)%len]+m[val][id]+n)%n));\n            }\n        }\n        return res;\n    }\n};","author":"Bold NoyceaZ0","submissionId":"611234783"},[]]},{"1492":[{"id":"1492","fileName":"611234541.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        pos = collections.defaultdict(list)\n        for i, num in enumerate(nums):\n            pos[num].append(i)\n        # print(pos)\n        ans = []\n        for q in queries:\n            sames = pos[nums[q]]\n            if len(sames) == 1:\n                ans.append(-1)\n                continue\n            idx = bisect.bisect_left(sames, q)\n            res = len(nums)\n            if idx > 0:\n                res = min(res, sames[idx] - sames[idx-1])\n                res = min(res, len(nums) - sames[idx] + sames[idx-1])\n            if idx == 0:\n                res = min(res, len(nums) - sames[-1] + sames[idx])\n            if idx + 1 < len(sames):\n                res = min(res, sames[idx+1] - sames[idx])\n                res = min(res, len(nums) - sames[idx+1] + sames[idx])\n            if idx == len(sames) - 1:\n                res = min(res, len(nums) - sames[idx] + sames[0])\n            \n            ans.append(res)\n        return ans\n                ","author":"brilliant_o","submissionId":"611234541"},[]]},{"1494":[{"id":"1494","fileName":"611234786.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            mp[nums[i]].push_back(i);\n        }\n        int m = queries.size();\n        vector<int> ans(m);\n        for (int i = 0; i < m; ++i) {\n            int num = nums[queries[i]];\n            if (mp[num].size() == 1) ans[i] = -1;\n            else {\n                auto it = lower_bound(mp[num].begin(), mp[num].end(), queries[i]);\n                int d1 = INT_MAX, d2 = INT_MAX;\n                int p, q;\n                if (it != mp[num].begin()) p = *prev(it), d1 = min(queries[i] - p, n - queries[i] + p);\n                else p = *prev(mp[num].end()), d1 = min(p - queries[i], n - p + queries[i]);\n                if (next(it) != mp[num].end()) q = *next(it), d2 = min(q - queries[i], n - q + queries[i]);\n                else q = *mp[num].begin(), d2 = min(queries[i] - q, n - queries[i] + q);\n                ans[i] = min(d1, d2);\n            }\n        }\n        return ans;\n    }\n};","author":"mistluo","submissionId":"611234786"},[]]},{"1495":[{"id":"1495","fileName":"611234818.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        a={}\n        for b,c in enumerate(nums):\n            if c not in a:\n                a[c]=[]\n            a[c].append(b)\n        n=len(nums)\n        d=[]\n        for e in queries:\n            f=nums[e]\n            if f not in a:\n                d.append(-1)\n                continue\n            g=a[f]\n            h=len(g)\n            if h==0:\n                d.append(-1)\n                continue\n            if h==1:\n                if g[0]==e:\n                    d.append(-1)\n                else:\n                    i=min(abs(g[0]-e),n-abs(g[0]-e))\n                    d.append(i)\n                continue\n            j=bisect.bisect_left(g,e)\n            if j<h and g[j] == e:\n                k=g[(j-1)%h]\n                l=g[(j+1)%h]\n            else:\n                k=g[(j-1)%h]\n                l=g[j%h]\n            i=min(abs(k-e),n-abs(k-e))\n            o=min(abs(l-e),n-abs(l-e))\n            d.append(min(i,o))\n        return d","author":"琉璃丶","submissionId":"611234818"},[]]},{"1496":[{"id":"1496","fileName":"611234860.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n=len(nums)\n        pos=defaultdict(list)\n        pos1=[-1]*n\n        lens=defaultdict(int)\n        for i in range(n):\n            pos[nums[i]].append(i)\n            lens[nums[i]]+=1\n            pos1[i]=lens[nums[i]]-1\n        ans=[]\n        for q in queries:\n            if lens[nums[q]]==1:\n                ans.append(-1)\n                continue\n            tmp=inf\n            idx=pos1[q]\n            tmp=(q-pos[nums[q]][idx-1]+n)%n\n            if idx<lens[nums[q]]-1:\n                tmp=min(tmp,pos[nums[q]][idx+1]-q)\n            else:\n                tmp=min(tmp,pos[nums[q]][0]-q+n)\n            # print(idx,pos1[q],lens[nums[q]],pos[nums[q]])\n            ans.append(tmp)\n        return ans","author":"hajiao3","submissionId":"611234860"},[]]},{"1497":[{"id":"1497","fileName":"611234915.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> M;\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            M[nums[i]].emplace_back(i);\n        }\n        vector<int> ans;\n        for(int q:queries){\n            int val=nums[q], res=1E9;\n            int pos = lower_bound(M[val].begin(),M[val].end(),q)-M[val].begin();\n            if(pos){\n                res=q-M[val][pos-1];\n            }\n            else if(pos==0&&M[val].size()>1){\n                res=n-(M[val][M[val].size()-1]-q);\n            }\n            if(pos+1<M[val].size()){\n                res=min(res,-q+M[val][pos+1]);\n            }\n            else if(M[val].size()>1){\n                res=min(res,n-(q-M[val][0]));\n            }\n            ans.emplace_back(res==1E9?-1:res);\n        }\n        return ans;\n    }\n};","author":"Max.D.","submissionId":"611234915"},[]]},{"1498":[{"id":"1498","fileName":"611234833.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int m = queries.size();\n        vector<int> ans;\n        unordered_map<int, vector<int>> maps;\n        for (int i = 0; i < nums.size() ;i++)\n            maps[nums[i]].push_back(i);\n        for (int i = 0; i < m ;i++)\n            {\n                int v = nums[queries[i]];\n                if (maps[v].size() == 1)\n                {\n                    ans.push_back(-1);\n                } else\n                {\n                    vector<int> &p = maps[v];\n                    int tmp = INT_MAX;\n                    auto it = upper_bound(p.begin(), p.end(), queries[i]);\n                    if (it != p.end())\n                    {\n                        tmp = min(tmp, *it - queries[i]);\n                        tmp = min(tmp, queries[i] + (int)nums.size() - *it);\n                    }\n                        \n                    it = lower_bound(p.begin(), p.end(), queries[i]);\n                    if (it != p.begin())\n                    {\n                        --it;\n                        tmp = min(tmp, queries[i] - *it);\n                        tmp = min(tmp, *it + (int)nums.size() - queries[i]);\n                    }\n                    int start = *p.begin();\n                    if (start != queries[i])\n                    {\n                        tmp = min(tmp, start + (int)nums.size() - queries[i]);\n                    }\n                    int end = p.back();\n                    if (end != queries[i])\n                    {\n                        tmp = min(tmp, queries[i] + (int)nums.size() - end);\n                    }\n                    ans.push_back(tmp);\n                }\n            }\n        return ans;\n    }\n};","author":"Sweet HaibtEqa","submissionId":"611234833"},[]]},{"1499":[{"id":"1499","fileName":"611234966.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& que) {\n        unordered_map<int,vector<int>> ump;\n        int n = nums.size(),m = que.size();\n        for(int i=0;i<n;++i) nums.push_back(nums[i]);\n        for(int i=0;i<2*n;++i){\n            ump[nums[i]].push_back(i);\n        }\n\n        vector<int> ans(m,INT_MAX);\n        for(int i=0;i<m;++i){\n            int qi= que[i];\n            auto& idx = ump[nums[qi]];\n            int j1 = lower_bound(idx.begin(),idx.end(),qi) - idx.begin();\n            int j2 = lower_bound(idx.begin(),idx.end(),qi+n) - idx.begin();\n            ans[i] = min(idx[j1+1]-idx[j1],idx[j2]-idx[j2-1]);\n            if(ans[i]==n) ans[i] = -1;\n        }\n        return ans;\n    }\n};","author":"JoyHuan","submissionId":"611234966"},[]]},{"1500":[{"id":"1500","fileName":"611234902.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = defaultdict(list)\n        for i, x in enumerate(nums):\n            d[x].append(i)\n        d2 = defaultdict(int)\n        n = len(nums)\n        for _, arr in d.items():\n            if len(arr) == 1:\n                d2[arr[0]] = -1\n            else:\n                m = len(arr)\n                for i, index in enumerate(arr):\n                    d2[index] = min((arr[(i + 1) % m] - index) % n, (index - arr[(i - 1) % m]) % n)\n        ans = []\n        for q in queries:\n            ans.append(d2[q])\n        return ans","author":"DBaker","submissionId":"611234902"},[]]},{"1501":[{"id":"1501","fileName":"611234959.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>> s;\n        int n=nums.size();\n        for(int i=0;i<n;++i){\n            s[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(auto &q:queries){\n            int v=nums[q];\n            if(s[v].size()<2){\n                ans.push_back(-1);\n                continue;\n            }\n            // for(auto &si:s[v]) cout<<si<<' ';cout<<'n';\n            auto iter=lower_bound(s[v].begin(),s[v].end(),q)-s[v].begin();\n            auto &si=s[v];\n            auto nn=si.size();\n            // cout<<iter<<\"n\";\n            int pp=min(abs(si[iter]-si[(iter-1+nn)%nn]),abs(si[(iter+1+nn)%nn]-si[iter]));\n            int pp1=min(abs(si[iter]+n-si[(iter-1+nn)%nn]),abs(si[(iter+1+nn)%nn]+n-si[iter]));\n            ans.push_back(min(pp,pp1));\n        }\n        return ans;\n    }\n};","author":"jillscat","submissionId":"611234959"},[]]},{"1502":[{"id":"1502","fileName":"611234820.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> left(n, -1);\n        vector<int> right(n, -1);\n        unordered_map<int,int> mp1;\n        for(int i=0;i<n;i++){\n            if(mp1.count(nums[i])) left[i] = mp1[nums[i]];\n            mp1[nums[i]] = i;\n        }\n        unordered_map<int,int> mp2;\n        for(int i=n-1;i>=0;i--){\n            if(mp2.count(nums[i])) right[i] = mp2[nums[i]];\n            mp2[nums[i]] = i;\n        }\n        int m = queries.size();\n        vector<int> res(m, -1);\n        for(int i=0;i<m;i++){\n            int x = queries[i];\n            int l = left[x];\n            int r = right[x];\n            int t1 = INT_MAX;\n            int t2 = INT_MAX;\n            if(l == -1 && r == -1) continue;\n            if(l != -1) t1 = min(t1, x-l);\n            else t1 = min(t1, n - mp1[nums[x]] + x);\n            \n            if(r != -1) t2 = min(t2, r - x);\n            else t2 = min(t2, n - x + mp2[nums[x]]);\n            res[i] = min(t1, t2);\n        }\n        return res;\n    }\n};","author":"红桃A士","submissionId":"611234820"},[]]},{"1503":[{"id":"1503","fileName":"611234993.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        map<int, vector<int>> m;\n        int n = a.size();\n        vector<int> res;\n        for(int i = 0; i < n; i++) {\n            m[a[i]].push_back(i);\n        }\n        for(auto &i: q) {\n            int v = a[i];\n            if(m[v].size() < 2) {\n                res.push_back(-1);\n                continue;\n            }\n            \n            vector<int> &t = m[v];\n            int l = n, s = t.size();\n            auto it = lower_bound(t.begin(), t.end(), i) - t.begin();\n            \n            if(it == 0) {\n                l = min(t[1] - t[0], t[0] + n - t.back());\n            } else if(it == s - 1){\n                l = min(t[it] - t[it - 1], t[0] + n - t[it]);\n            } else {\n                l = min(t[it + 1] - t[it], t[it] - t[it - 1]);\n            }\n            res.push_back(l);\n        }\n        return res;\n    }\n};","author":"后青春期的YXY","submissionId":"611234993"},[]]},{"1504":[{"id":"1504","fileName":"611235056.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> ret;\n        ret.reserve(queries.size());\n\n        int n = nums.size();\n        vector<int> min_dis(n, n);\n        std::unordered_map<int, std::vector<int>> max_indexs;\n        for (int i = 0; i < n; i++) {\n            if (max_indexs.count(nums[i])) {\n                int left = *max_indexs[nums[i]].begin(), right = max_indexs[nums[i]].back();\n                min_dis[i] = std::min({min_dis[i], n + left - i, i - left, n + right - i, i - right});\n                min_dis[left] = std::min({min_dis[left], n + left - i, i - left});\n                min_dis[right] = std::min({min_dis[right], n + right - i, i - right});\n            }\n            max_indexs[nums[i]].push_back(i);\n        }\n        for (int x : queries) {\n            ret.push_back(min_dis[x] == n ? -1 : min_dis[x]);\n        }\n        return ret;\n    }\n};","author":"D_D","submissionId":"611235056"},[]]},{"1505":[{"id":"1505","fileName":"611235076.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = defaultdict(list)\n        n = len(nums)\n        for i , num in enumerate(nums):\n            d[num].append(i)\n        ans = []\n        for x in queries:\n            idx = bisect.bisect_left(d[nums[x]],x)\n            ret = inf\n            if idx - 1 >= 0:\n                ret = min(ret,abs(x-d[nums[x]][idx-1]),abs(n-x+d[nums[x]][idx-1]))\n            elif len(d[nums[x]]) > 1:\n                ret = min(ret,n - d[nums[x]][-1] + d[nums[x]][0])\n            if idx + 1 < len(d[nums[x]]):\n                ret = min(ret,abs(x-d[nums[x]][idx+1]),abs(n-d[nums[x]][idx+1]+x))\n            elif len(d[nums[x]]) > 1:\n                ret = min(ret,n - d[nums[x]][idx] + d[nums[x]][0])\n            if ret == inf:\n                ans.append(-1)\n            else:\n                ans.append(ret)\n        return ans","author":"风痕依旧","submissionId":"611235076"},[]]},{"1506":[{"id":"1506","fileName":"611234779.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            indices[num].append(i)\n        ans = []\n        for q in queries:\n            idx = indices[nums[q]]\n            if len(idx) == 1:\n                ans.append(-1)\n                continue\n            pos = bisect_left(idx, q)\n            mn = inf\n            if pos == 0:\n                mn = min(n - idx[-1] + idx[0], idx[1] - idx[0])\n            elif pos == len(idx) - 1:\n                mn = min(idx[pos] - idx[pos - 1], n - idx[pos] + idx[0])\n            else:\n                mn = min(idx[pos] - idx[pos - 1], n - idx[pos] + idx[pos - 1], idx[pos + 1] - idx[pos], n - idx[pos + 1] + idx[pos])\n            ans.append(mn)\n        return ans\n            \n        ","author":"刘蛋蛋","submissionId":"611234779"},[]]},{"1507":[{"id":"1507","fileName":"611235226.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& qr) {\n        int n = a.size();\n        vector<int> b(n * 3);\n        for(int i = 0; i < n; ++i) b[i] = b[i + n] = b[i + n * 2] = a[i];\n        unordered_map<int, int> mp;\n        int m = n * 3;\n        vector<int> res(n, -1);\n        for(int i = 0; i < m; ++i) {\n            int x = b[i];\n            if(i >= n && i < n << 1) {\n                if(mp.count(x)) res[i - n] = i - mp[x];\n            } mp[x] = i;\n        }\n        {\n            unordered_map<int, int> mp;\n            for(int i = m - 1; ~i; --i) {\n                int x = b[i];\n                if(i >= n && i < n << 1) {\n                    if(mp.count(x)) {\n                        if(~res[i - n]) res[i - n] = min(res[i - n], mp[x] - i);\n                        else res[i - n] = mp[x] - i;\n                    }\n                } mp[x] = i;\n            }\n        }\n        vector<int> ans(qr.size());\n        for(int i = 0; i < qr.size(); ++i) {\n            ans[i] = res[qr[i]] == n ? -1 : res[qr[i]];\n        }\n        return ans;\n    }\n};","author":"0xffffffff","submissionId":"611235226"},[]]},{"1508":[{"id":"1508","fileName":"611235149.txt","sourceCode":"from collections import defaultdict\nimport bisect\nclass Solution:\n    def solveQueries(self, a: List[int], queries: List[int]) -> List[int]:\n        n = len(a)\n        s = defaultdict(list)\n        for i in range(n):\n            s[a[i]].append(i)\n\n        def find(b, x):\n            return bisect.bisect_left(b, x)\n\n        def get_d(x, y):\n            if x > y: x, y = y, x\n            return min(y-x, n-(y-x))\n\n        def calc(b, x):\n            if len(b) == 1:\n                return -1\n            m = len(b)\n            return min(get_d(b[x], b[x-1]), get_d(b[x], b[(x+1)%m]))\n        \n        # print(s)\n        r = []\n        for x in queries:\n            idx = find(s[a[x]], x)\n            r.append(calc(s[a[x]], idx))\n        return r","author":"summerdaway","submissionId":"611235149"},[]]},{"1509":[{"id":"1509","fileName":"611235229.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        mp = defaultdict(list)\n        for i, x in enumerate(nums):\n            mp[x].append(i)\n\n        n = len(nums)\n        ans = [-1] * len(queries)\n        for i, q in enumerate(queries):\n            x = nums[q]\n            if len(mp[x]) <= 1:\n                continue\n            idx = mp[x]\n            pos = bisect.bisect_left(idx, q)\n            if pos == 0:\n                # ans[i] = idx[pos + 1] if idx[pos + 1] - q <= len(nums) - idx[-1] else index()\n                ans[i] = min(idx[pos + 1] - q, q + n - idx[-1])\n            elif pos == len(idx) - 1:\n                ans[i] = min(q - idx[pos - 1], idx[0] + n - q)\n            else:\n                ans[i] = min(q - idx[pos - 1], idx[pos + 1] - q)\n        return ans\n        ","author":"西山对寂寥","submissionId":"611235229"},[]]},{"1510":[{"id":"1510","fileName":"611235176.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> m;\n        for(int i = 0; i < nums.size(); ++i) {\n            m[nums[i]].push_back(i);\n        }\n        for(int i = 0; i < nums.size(); ++i) {\n            m[nums[i]].push_back(i+nums.size());\n        }\n        for(int i = 0; i < nums.size(); ++i) {\n            m[nums[i]].push_back(i+2*nums.size());\n        }\n        vector<int> ret(queries.size());\n        for(int i = 0; i < queries.size(); ++i) {\n            int x = nums[queries[i]];\n            auto it = m.find(x);\n            int n = it->second.size();\n            if(n == 3) {\n                ret[i] = -1;\n            } else {\n                auto it2 = lower_bound(it->second.begin(), it->second.end(), queries[i] + nums.size());\n                int idx = it2 - it->second.begin();\n                ret[i] = 1e9;\n                ret[i] = min(ret[i], it->second[idx] - it->second[idx-1]);\n                ret[i] = min(ret[i], it->second[idx + 1] - it->second[idx]);\n            }\n        }\n        return ret;\n    }\n};","author":"newhar","submissionId":"611235176"},[]]},{"1511":[{"id":"1511","fileName":"611235268.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n    pos := map[int][]int {}\n\n    n := len(nums)\n    \n    for i := range nums {\n        pos[nums[i]] = append(pos[nums[i]],i)\n    }\n\n    for k,v := range pos {\n        sort.Slice(v,func(i,j int)bool{\n            return v[i] < v[j]\n        })\n        pos[k] = v\n    }\n    \n    m := len(queries)\n    ans := make([]int,m)\n\n    for i:=0; i<m; i++ {\n        ans[i] = -1\n        idx := queries[i]\n        num := nums[idx]\n\n        if tmp,ok := pos[num]; !ok || len(tmp) == 1 {\n            continue\n        }\n        \n        arr := pos[num]\n        l,r := 0,len(arr)\n        for l<r {\n            mid := (l+r)>>1\n            if arr[mid] >= idx {\n                r = mid\n            } else {\n                l = mid + 1\n            }\n        }\n\n        ans[i] = n\n        t := len(arr)\n        ans[i] = min(ans[i],((arr[l]-arr[(l-1+t)%t])+n)%n)\n        ans[i] = min(ans[i],(arr[(l+1)%t]-arr[l]+n)%n)\n        \n    }\n    \n    return ans\n}","author":"归来还当保安","submissionId":"611235268"},[]]},{"1512":[{"id":"1512","fileName":"611235249.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int> &nums, vector<int> &queries)\n    {\n        unordered_map<int, int> m1;\n        unordered_map<int, vector<int>> m2;\n        for (int i = 0; i < nums.size();i++){\n            m1[nums[i]]++;\n            m2[nums[i]].push_back(i);\n        }\n        vector<int> s1(nums.size());\n        for (auto &[k, v] : m2){\n            if(v.size() == 1){\n                continue;\n            }\n            for (int i = 0; i < v.size();i++){\n                if(i == 0){\n                    s1[v[i]] = min(v[i + 1] - v[i], v[i] + (int)nums.size() - (int)v.back());\n                }\n                else if(i == v.size() - 1){\n                    s1[v[i]] = min(v[i] - v[i - 1], -v[i] + (int)nums.size() + (int)v[0]);\n                }\n                else{\n                    s1[v[i]] = min(v[i] - v[i - 1], v[i + 1] - v[i]);\n                }\n            }\n        }\n        vector<int> ans(queries.size());\n        for (int i = 0; i < queries.size();i++){\n            if(m1[nums[queries[i]]] == 1){\n                ans[i] = -1;\n            }\n            else{\n                ans[i] = s1[queries[i]];\n            }\n        }\n        return ans;\n    }\n};","author":"yhwputin","submissionId":"611235249"},[]]},{"1513":[{"id":"1513","fileName":"611235277.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        d = defaultdict(list)\n        for i in range(n):\n            d[nums[i]].append(i)\n        \n        answer = []\n        for idx in queries:\n            num = nums[idx]\n            m = len(d[num])\n            if m == 1:\n                answer.append(-1)\n                continue\n            pos = bisect_left(d[num], idx)\n            \n            res = inf\n            if pos > 0:\n                res = min(idx - d[num][pos - 1], res)\n            if pos < m - 1:\n                res = min(d[num][pos + 1] - idx, res)\n            if pos == 0:\n                res = min(idx + n - d[num][-1], res)\n            if pos == m - 1:\n                res = min(n - idx + d[num][0], res)\n            answer.append(res)\n        return answer","author":"Practical Edisony6X","submissionId":"611235277"},[]]},{"1514":[{"id":"1514","fileName":"611235026.txt","sourceCode":"vector<int> buckets[1000000 + 10];\nint idxa[1000000 + 10];\n\nclass Solution {\n   public:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        for (int i = 0; i <= 1000000; i++) buckets[i].clear();\n        for (int i = 0; i < nums.size(); i++) {\n            idxa[i] = buckets[nums[i]].size();\n            buckets[nums[i]].push_back(i);\n        }\n        vector<int> ansv;\n        for (int x : queries) {\n            auto& vec = buckets[nums[x]];\n            int idx = idxa[x];\n            if (vec.size() == 1) {\n                ansv.push_back(-1);\n            } else {\n                int n = nums.size();\n                int ans = n;\n                if (idx == 0)\n                    ans = min(ans, n - (vec.back() - x));\n                else\n                    ans = min(ans, x - vec[idx - 1]);\n                if (idx == vec.size() - 1)\n                    ans = min(ans, n - (x - vec[0]));\n                else\n                    ans = min(ans, vec[idx + 1] - x);\n                ansv.push_back(ans);\n            }\n        }\n        return ansv;\n    }\n};","author":"sdcgvhgj","submissionId":"611235026"},[]]},{"1515":[{"id":"1515","fileName":"611235289.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        ht=defaultdict(list)\n        n=len(nums)\n        k=[]\n        for i,x in enumerate(nums):\n            k.append(len(ht[x]))\n            ht[x].append(i)\n        ans=[]\n        for i in queries:\n            x=nums[i]\n            j=k[i]\n            l=len(ht[x])\n            if len(ht[x])>1:\n                a=abs(i-ht[x][(j+1)%len(ht[x])])\n                b=abs(i-ht[x][(j-1)%len(ht[x])])\n                ans.append(min(n-a,a,n-b,b))\n            else:\n                ans.append(-1)\n        return ans","author":"团","submissionId":"611235289"},[]]},{"1516":[{"id":"1516","fileName":"611235287.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = defaultdict(list)\n        for i, num in enumerate(nums):\n            d[num].append(i)\n        \n        n = len(nums)\n        ans = [-1] * len(queries)\n        \n        for i, q in enumerate(queries):\n            lst = d[nums[q]]\n            if (m := len(lst)) == 1:\n                continue\n            \n            pos = bisect_left(lst, q)\n            val = lst[0] + n - lst[-1]\n            \n            ans[i] = min(\n                lst[pos + 1] - q if pos + 1 < m else val, \n                q - lst[pos - 1] if pos > 0 else val\n            )\n        \n        return ans\n","author":"...","submissionId":"611235287"},[]]},{"1517":[{"id":"1517","fileName":"611235393.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& Q) {\n        \n        const int m = Q.size();\n        const int n = a.size();\n        std::vector<int>res(m, -1);\n\n        std::map<int, vector<int>>P;\n        for(int i = 0;i < a.size();i++) {\n            P[a[i]].push_back(i);\n        }\n\n        for(int i = 0;i < m;i++) {\n            const auto& b = P[a[Q[i]]];\n            int pos = Q[i];\n            if(b.size() > 1) {\n                auto j = std::lower_bound(b.begin(), b.end(), Q[i]) - b.begin();\n                int ans = 1000000;\n                if(j > 0) {\n                    ans = std::min(ans, std::abs(b[j] - b[j - 1]));\n                    ans = std::min(ans, n - abs(b[j] - b[0]));\n                } \n                if(j + 1 < b.size()) {\n                    ans = std::min(ans, std::abs(b[j] - b[j + 1]));\n                    ans = std::min(ans, n - abs(b[j] - b.back()));\n                }\n                res[i] = ans;\n            }\n        }\n\n        return res;\n    }\n};","author":"spj","submissionId":"611235393"},[]]},{"1518":[{"id":"1518","fileName":"611235213.txt","sourceCode":"class Solution\n{\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries)\n    {\n        unordered_map<int, vector<int>> indexMap;\n        int n = nums.size();\n        for (int i = 0; i < n; i++)\n        {\n            indexMap[nums[i]].emplace_back(i);\n        }\n        vector<int> ans;\n        ans.reserve(queries.size());\n        for (auto query: queries)\n        {\n            auto& index = indexMap[nums[query]];\n            if (index.size() == 1)\n            {\n                ans.emplace_back(-1);\n                continue;\n            }\n            auto it = lower_bound(index.begin(), index.end(), query);\n            if (it == index.begin())\n            {\n                auto dis1 = *(it + 1) - *it;\n                auto dis2 = *it - index.back() + n;\n                ans.emplace_back(min(dis1, dis2));\n            }\n            else if (*it == index.back())\n            {\n                auto dis1 = *it - *(it - 1);\n                auto dis2 = index.front() - *it + n;\n                ans.emplace_back(min(dis1, dis2));\n            }\n            else\n            {\n                auto dis1 = *it - *(it - 1);\n                auto dis2 = *(it + 1) - *it;\n                ans.emplace_back(min(dis1, dis2));\n            }\n        }\n        return ans;\n    }\n};","author":"maruser","submissionId":"611235213"},[]]},{"1520":[{"id":"1520","fileName":"611235428.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n\tres := make([]int, len(queries))\n\tm := map[int][]int{}\n\tn := len(nums)\n\tfor i := range nums {\n\t\tm[nums[i]] = append(m[nums[i]], i)\n\t}\n\n\tfor i := range queries {\n\t\tt := m[nums[queries[i]]]\n\t\tif len(t) == 1 {\n\t\t\tres[i] = -1\n            continue\n\t\t}\n\t\tl := len(t)\n\t\ta := sort.SearchInts(t, queries[i])\n\t\tb := (a - 1 + l) % l\n\t\tc := (a + 1 + l) % l\n\t\tx := abs(t[a] - t[b])\n\t\ty := abs(t[c] - t[a])\n\t\tx = min(x, n-x)\n\t\ty = min(y, n-y)\n\t\tres[i] = min(x, y)\n\t}\n\n\treturn res\n}\n\nfunc abs(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}","author":"手塚国光","submissionId":"611235428"},[]]},{"1521":[{"id":"1521","fileName":"611235477.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, int> firstIdx;\n        unordered_map<int, int> lastIdx;\n        vector<int> dist(n, INT_MAX);\n        for (int i = 0; i < n; i++) {\n            auto it = lastIdx.find(nums[i]);\n            if (it == lastIdx.end()) {\n                firstIdx.emplace(nums[i], i);\n                lastIdx.emplace(nums[i], i);\n            } else {\n                int j = it->second;\n                it->second = i;\n                dist[i] = min(dist[i], i - j);\n                dist[j] = min(dist[j], i - j);\n\n                j = firstIdx.find(nums[i])->second;\n                dist[i] = min(dist[i], j + n - i);\n                dist[j] = min(dist[j], j + n - i);\n            }\n        }\n\n        vector<int> ans;\n        for (int q : queries) {\n            ans.push_back(dist[q] == INT_MAX ? -1 : dist[q]);\n        }\n        return ans;\n    }\n};\n\n","author":"许秀","submissionId":"611235477"},[]]},{"1522":[{"id":"1522","fileName":"611235457.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        arr = nums * 2\n        lt = [-1] * (2 * n)\n        rt = [-1] * (2 * n)\n        seen = dict()\n        for i in range(2*n):\n            a = arr[i]\n            if a in seen and (i - seen[a]) < n:\n                lt[i] = i - seen[a]\n            seen[a] = i\n        \n        seen = dict()\n        for i in range(2*n - 1, -1, -1):\n            a = arr[i]\n            if a in seen and (seen[a] - i) < n:\n                rt[i] = seen[a] - i\n            seen[a] = i\n        # print(lt)\n        # print(rt)\n        return [min(lt[n+i], rt[i]) for i in queries]","author":"ali","submissionId":"611235457"},[]]},{"1523":[{"id":"1523","fileName":"611235508.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = defaultdict(list) \n        n = len(nums) \n        for i,num in enumerate(nums):\n            d[num].append(i) \n        ans = [] \n        for q in queries:\n            curnum = nums[q]\n            p = bisect_left(d[curnum],q)\n            if len(d[curnum]) == 1:\n                cur = -1 \n            else:\n                if p == len(d[curnum])-1:\n                    cur = min(d[curnum][0]+1+n-1-q,q-d[curnum][p-1])\n                elif not p:\n                    cur = min(q+1+n-1-d[curnum][-1],d[curnum][p+1]-q)\n                else:\n                    if len(d[curnum]) == 2:cur = d[curnum][p+1]-q\n                    else:cur = min(d[curnum][p+1]-q,q-d[curnum][p-1])\n            ans.append(cur) \n        return ans ","author":"好朋友","submissionId":"611235508"},[]]},{"1524":[{"id":"1524","fileName":"611235554.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        f = defaultdict(list)\n        n = len(nums)\n        for i in range(n):\n            f[nums[i]].append(i)\n        ans = [-1] * len(queries)\n        for i in range(len(queries)):\n            q = queries[i]\n            t = f[nums[q]]\n            sn = len(t)\n            if sn == 1:\n                continue\n            j = bisect_left(t, q)\n            if j == 0:\n                ans[i] = min(t[1] - t[j], n - (t[sn - 1] - t[j]))\n            elif j == sn - 1:\n                ans[i] = min(t[j] - t[j - 1], n - (t[j] - t[0]))\n            else:\n                ans[i] = min(t[j] - t[j - 1], t[j + 1] - t[j])\n        return ans\n","author":"瞌睡菇","submissionId":"611235554"},[]]},{"1525":[{"id":"1525","fileName":"611235537.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        map<int, set<int>> m;\n        for (int i = 0; i < nums.size(); i++) {\n            m[nums[i]].emplace(i);\n        }\n        vector<int> res;\n        for (int i = 0; i < q.size(); i++) {\n            set<int>& s = m[nums[q[i]]];\n            auto iter = s.find(q[i]);\n            auto l = iter == s.begin() ? prev(s.end()) : prev(iter);\n            auto r = iter == prev(s.end()) ? s.begin() : next(iter);\n            int f = iter == l ? -1 : (*iter - *l + nums.size()) % nums.size();\n            int b = iter == r ? -1 : (*r - *iter + nums.size()) % nums.size();\n            if (f == -1) {\n                res.emplace_back(b);\n            } else if (b == -1) {\n                res.emplace_back(f);\n            } else {\n                res.emplace_back(min(f, b));\n            }\n        }\n        return res;\n    }\n};","author":"Jepe","submissionId":"611235537"},[]]},{"1526":[{"id":"1526","fileName":"611235454.txt","sourceCode":"class Solution {\npublic:\n    int find(vector<int>&a,int x){\n        int left=0;\n        int right=a.size()-1;\n        while(left<=right){\n            int mid=(left+right)/2;\n            if(a[mid]==x){\n                return mid;\n            }else if(a[mid]>x){\n                right=mid-1;\n            }else{\n                left=mid+1;\n            }\n        }\n        return -1;\n    }\n    int cal(int x,int y,int n){\n        int mn=min(x,y);\n        int mx=max(x,y);\n        return min(mx-mn,n-mx+mn);\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>>ump;\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            ump[nums[i]].push_back(i);\n        }\n        vector<int>ans;\n        for(auto& y:queries){\n            vector<int>&v=ump[nums[y]];\n            int len=v.size();\n            if(len==1){\n                ans.push_back(-1);\n            }else{\n                 int pos=find(v,y);\n                ans.push_back(min(cal(v[(pos+1)%len],v[pos],n),cal(v[pos],v[(pos-1+len)%len],n)));   \n            }\n        }\n        return ans;\n    }\n};","author":"yuanhao","submissionId":"611235454"},[]]},{"1527":[{"id":"1527","fileName":"611235521.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dic = defaultdict(list)\n        for i,a in enumerate(nums):\n            dic[a].append(i)\n        n = len(nums)\n        for k,v in dic.items():\n            v1 = [-n+ v[-1]] + v + [v[0] +n]\n            dic[k] =v1\n        ret =[-1]*len(queries)\n        \n        for i,a in enumerate(queries):\n            k = bisect_left(dic[nums[a]],a)\n            if len(dic[nums[a]]) ==3:\n                continue\n            re = 10**6\n            #print(a,k,dic[nums[a]])\n\n            re =min(re,dic[nums[a]][k+1]-a, n-(dic[nums[a]][k+1]-a))\n\n\n            re=  min(re,a-dic[nums[a]][k-1],n-(a-dic[nums[a]][k-1]))\n            ret[i] = re\n        return ret","author":"Tao Zhou","submissionId":"611235521"},[]]},{"1528":[{"id":"1528","fileName":"611235518.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        std::unordered_map<int, std::vector<int>> record;\n        int n = nums.size();\n        for (int i = 0; i < nums.size(); ++i) {\n            record[nums[i]].push_back(i);\n        }\n        std::vector<int> res;\n        for (auto que : queries) {\n            int num = nums[que];\n            if (record[num].size() == 1) {\n                res.emplace_back(-1);\n            } else {\n                int index = std::lower_bound(record[num].begin(), record[num].end(), que) - record[num].begin();\n                int leftLen = index == 0 ? (*record[num].begin() + n - record[num].back()): (record[num][index] - record[num][index - 1]);\n                int rightLen = index == record[num].size() - 1 ?  (*record[num].begin() + n - record[num].back()): (record[num][index + 1] - record[num][index]);\n                if (leftLen < rightLen) {\n                    res.emplace_back(leftLen);\n                } else {\n                    res.emplace_back(rightLen);\n                }\n            }\n        }\n        return res;\n    }\n};","author":"Chenchen","submissionId":"611235518"},[]]},{"1529":[{"id":"1529","fileName":"611235571.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>>mp;\n        int n = nums.size();\n        for(int i=0;i<nums.size();++i)\n            {\n                mp[nums[i]].emplace_back(i);\n            }\n        vector<int>res(queries.size());\n        int i =  -1;\n        for(int &q:queries)\n            {\n                ++i;\n                vector<int>&v = mp[nums[q]];\n                if(v.size()==1)\n                {\n                    res[i] = -1;\n                }\n                else\n                {\n                    auto it = upper_bound(v.begin(),v.end(),q);\n                    int tmp = INT_MAX;\n                    if(it!=v.end())\n                    {\n                        tmp = min(tmp,min(*it-q,q+n-*it));\n                    }\n                    if(it - v.begin()>=2)\n                    {\n                        tmp = min(tmp,min(q-*(it-2),*(it-2)+n-q));\n                    }\n                    if(q == v.back())\n                        {\n                        tmp = min(tmp,n+v[0]-q);\n                        }\n                    if(q==v[0])\n                    {\n                        tmp  = min(tmp , q+n-v.back());\n                    }\n                    res[i] = tmp;\n                }\n            }\n        return res;\n    }\n};","author":"Mafa","submissionId":"611235571"},[]]},{"1530":[{"id":"1530","fileName":"611235589.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        nums_list = defaultdict(list)\n        for i,v in enumerate(nums):\n            nums_list[v].append(i)\n        ans = []\n        for q in queries:\n            v = nums[q]\n            ins = nums_list[v]\n            if len(ins) <= 1:\n                ans.append(-1)\n            else:\n                i = bisect_left(ins,q)\n                # print(ins,i,q)\n                left = abs(ins[i-1]-q)\n                right = abs(ins[(i+1)%len(ins)]-q)\n                left = min(left,len(nums)-left)\n                right = min(right,len(nums)-right)\n                ans.append(min(left,right))\n        return ans\n        ","author":"widespeed","submissionId":"611235589"},[]]},{"1531":[{"id":"1531","fileName":"611235687.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> ans;\n        unordered_map<int, vector<int>> table;\n        for (int i = 0; i < n; ++i) {\n            table[nums[i]].push_back(i);\n        }\n        auto helper = [&](int x, int y) {\n            if (x > y) swap(x, y);\n            return min(y - x, n - y + x);\n        };\n        for (auto q : queries) {\n            vector<int> &v = table[nums[q]];\n            if (v.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            int cur = ranges::lower_bound(v, q) - v.begin();\n            int r = cur - 1 < 0 ? v.size() - 1 : cur - 1;\n            int l = cur + 1 >= v.size() ? 0 : cur + 1;\n            int x = min(helper(v[cur], v[r]), helper(v[cur], v[l]));\n            ans.push_back(x);\n        }\n        return ans;\n    }\n};","author":"沅筱","submissionId":"611235687"},[]]},{"1532":[{"id":"1532","fileName":"611235493.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            num_indices[num].append(i)\n        n = len(nums)\n\n        ans = []\n        for q in queries:\n            num = nums[q]\n            a = num_indices[num]\n            eq_idx = bisect_left(a, q)\n            an = len(a)\n            if an == 1:\n                ans.append(-1)\n            else:\n                left, right = a[(eq_idx - 1) % an], a[(eq_idx + 1) % an]\n                ans.append(min(abs(q - left), abs(q - right), n - abs(q - left), n - abs(q - right)))\n        return ans\n        ","author":"milan","submissionId":"611235493"},[]]},{"1533":[{"id":"1533","fileName":"611235732.txt","sourceCode":"#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> PII;\ntypedef unsigned long long ull;\n\n    \nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& b) {\n        int n = a.size(), q = b.size();\n        vector<int> ans(q);\n        map<int,set<int>> mp;\n        for(int i = 0; i < n; i++) {\n            mp[a[i]].insert(i);\n        }\n        for(int i = 0; i < q; i++) {\n            int x = a[b[i]];\n            auto &st = mp[x];\n            auto it = st.lower_bound(b[i]);\n            int cur = 1000000000;\n            if(it != st.begin()) {\n                cur = min({cur, b[i] - *st.begin(), n - b[i] + *st.begin()});\n            }\n            if(*it != *st.rbegin()) {\n                cur = min({cur, *st.rbegin() - b[i], b[i] + n - *st.rbegin()});\n            }\n            it++;\n            if(it != st.end()) {\n                cur = min(cur, *it - b[i]);\n            }\n            it--;\n            if(it != st.begin()) {\n                it--;\n                cur = min(cur, b[i] - *it);\n            }\n            \n            ans[i] = cur;\n            if(cur == 1000000000) {\n                ans[i] = -1;\n            }\n        }\n        return ans;\n    }\n};","author":"Dr_Zhang","submissionId":"611235732"},[]]},{"1534":[{"id":"1534","fileName":"611235603.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int[] q = new int[nums.length];\n        for(int i = 0; i < nums.length ;i++){\n            q[i] = -1;\n        }\n        \n        int n = nums.length;\n        Map<Integer,List<Integer>> m = new HashMap<>();\n        for(int i = 0; i < nums.length ;i++){\n            if(!m.containsKey(nums[i])){\n                List<Integer> v = new ArrayList<>();\n                v.add(i);\n                m.put(nums[i],v);\n                continue;\n            }\n            \n            List<Integer> v= m.get(nums[i]);\n            int min = i-v.get(v.size()-1);\n            if(q[v.get(v.size()-1)] == -1 || q[v.get(v.size()-1)]>min){\n                q[v.get(v.size()-1)] = min;\n            }\n            if(v.get(0)+n-i<min){\n                min = v.get(0)+n-i;\n            }\n            if(q[v.get(0)] == -1 || q[v.get(0)]>v.get(0)+n-i){\n                q[v.get(0)] = v.get(0)+n-i;\n            }\n            q[i] = min;\n\n            v.add(i);\n            m.put(nums[i],v);\n        }\n        \n        List<Integer> res = new ArrayList<>();\n        for(int qu:queries){\n            res.add(q[qu]);\n        }\n        return res;\n    }\n}","author":"秋雨田风","submissionId":"611235603"},[]]},{"1536":[{"id":"1536","fileName":"611235867.txt","sourceCode":"\nimport java.util.*;\n\n\n\npublic  class Solution{\n\n    public static void main(String[] args) {\n\n        Solution solution = new Solution();\n        System.out.println(solution.solveQueries(new int[]{14,14,4,2,19,19,14,19,14}, new int[]{8}));\n    }\n    public int maxSum(int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        if(nums[n - 1] < 0) return nums[n - 1];\n        Set<Integer> set = new HashSet<>();\n        for(int t : nums) set.add(t);\n        int ans = 0;\n        for(int t : set) {\n            if(t > 0) ans += t;\n        }\n        return ans;\n    }\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, TreeSet<Integer>> map = new HashMap<>();\n        int  n = nums.length;\n        for (int i = 0; i < n; i++) {\n            map.computeIfAbsent(nums[i], k->new TreeSet<>()).add(i);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for(int t : queries){\n            TreeSet<Integer> treeSet = map.get(nums[t]);\n            Integer lower = treeSet.lower(t);\n            Integer higher = treeSet.higher(t);\n            int cur = -1;\n            if(lower != null) cur = Math.min(t - lower, n  - t + lower);\n            if(higher != null ){\n                int d = Math.min(higher - t, n - higher + t);\n                if(cur == -1 || d < cur) cur = d;\n            }\n            Integer first = treeSet.first();\n            if(first != t && n  - t + first < cur){\n                cur = n  - t + first;\n            }\n            Integer last = treeSet.last();\n            if(last != t &&  n - last + t < cur){\n                cur = n - last + t;\n            }\n            ans.add(cur);\n        }\n        return ans;\n    }\n\n}\n","author":"9527","submissionId":"611235867"},[]]},{"1537":[{"id":"1537","fileName":"611235606.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        g = defaultdict(list)\n        for i, x in enumerate(nums):\n            g[x].append(i)\n\n        n = len(nums)\n\n        ans = []\n        for q in queries:\n            x = nums[q]\n\n            lst = g[x]\n            if len(lst) == 1:\n                ans.append(-1)\n                continue\n\n            j = bisect_left(lst, q)\n            if 0 < j < len(lst) - 1:\n                left = j - 1\n                right = j + 1\n                ans.append(min(lst[j] - lst[left], lst[right] - lst[j]))\n            else:\n                if j == 0:\n                    left = -1\n                    right = j + 1\n                    ans.append(min(n - lst[left] + lst[j], lst[right] - lst[j]))\n                elif j == len(lst) - 1:\n                    left = j - 1\n                    right = 0\n                    ans.append(min(lst[j] - lst[left], n - lst[j] + lst[right]))\n\n        return ans","author":"硕风点点","submissionId":"611235606"},[]]},{"1538":[{"id":"1538","fileName":"611235580.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        m = defaultdict(list)\n        for i, n in enumerate(nums):\n            m[n].append(i)\n        ans = []\n        for q in queries:\n            idxL = m[nums[q]]\n            length = len(idxL)\n            if length == 1:\n                ans.append(-1)\n            else:\n                loc = bisect.bisect_left(idxL, q)\n                ans.append(min((idxL[loc] - idxL[(loc-1)%length])%len(nums), (idxL[(loc+1)%length] - idxL[loc])%len(nums)))\n        return ans\n","author":"idiot","submissionId":"611235580"},[]]},{"1539":[{"id":"1539","fileName":"611235921.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d=defaultdict(list)\n        for i,x in enumerate(nums):\n            d[x].append(i)\n        n=len(nums)\n        ans=[]\n        for x in queries:\n            # print(d[nums[x]])\n            k=bisect_left(d[nums[x]],x)\n            # print(k)\n            res=inf\n            if len(d[nums[x]])>1:\n                if k+1<len(d[nums[x]]):\n                    res=d[nums[x]][k+1]-x\n                else:\n                    res=min(res,x-d[nums[x]][0],n-x+d[nums[x]][0])\n                if k-1>=0:\n                    res=min(res,x-d[nums[x]][k-1])\n                else:\n                    res=min(res,d[nums[x]][-1]-x,n+x-d[nums[x]][-1])\n            ans.append(res if res<inf else -1)\n        return ans","author":"月耑","submissionId":"611235921"},[]]},{"1540":[{"id":"1540","fileName":"611236046.txt","sourceCode":"#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#define ALL(v) v.begin(),v.end()\n#define For(i,_) for(int i=0,i##end=_;i<i##end;++i) // [0,_)\n#define FOR(i,_,__) for(int i=_,i##end=__;i<i##end;++i) // [_,__)\n#define Rep(i,_) for(int i=(_)-1;i>=0;--i) // [0,_)\n#define REP(i,_,__) for(int i=(__)-1,i##end=_;i>=i##end;--i) // [_,__)\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define V vector\n#define pb push_back\n#define pf push_front\n#define qb pop_back\n#define qf pop_front\n#define eb emplace_back\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\n#define fi first\n#define se second\nconst int dir[4][2]={{-1,0},{0,1},{1,0},{0,-1}},inf=0x3f3f3f3f,mod=1e9+7;\nconst ll infl=0x3f3f3f3f3f3f3f3fll;\ntemplate<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,1:0;}\nint init=[](){return cin.tie(nullptr)->sync_with_stdio(false),0;}();\ntemplate<class T>\nstruct disc{\n\t// 0-indexed\n\tvector<T>d;\n\tinline disc(){}\n\tinline void insert(const T &x){d.pb(x);}\n\tinline void insert(const V<T> &v){d.insert(d.end(),ALL(v));}\n\tinline void init(){sort(ALL(d));d.erase(unique(ALL(d)),d.end());}\n\tinline disc(const vector<T> &v){d=move(v);init();}\n\tinline int query(const T &x){return lower_bound(ALL(d),x)-d.begin();}\n\tinline int size(){return d.size();}\n};\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        disc<int>d(nums);\n        for(int &i:nums)i=d.query(i);\n        int n=nums.size();\n        V<V<int>>pos(d.size());\n        For(i,n)pos[nums[i]].pb(i);\n        For(i,n)pos[nums[i]].pb(n+i);\n        For(i,n)pos[nums[i]].pb(2*n+i);\n        V<int>ret;\n        for(int i:q){\n            auto it=lower_bound(ALL(pos[nums[i]]),n+i);\n            int mn=n;\n            ckmin(mn,n+i-*prev(it));\n            ckmin(mn,*next(it)-n-i);\n            ret.pb(mn<n?mn:-1);\n        }\n        return ret;\n    }\n};","author":"drizzlo","submissionId":"611236046"},[]]},{"1541":[{"id":"1541","fileName":"611235593.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = defaultdict(list)\n        for i, x in enumerate(nums):\n            d[x].append(i)\n        n = len(nums)\n        ans = [-1] * len(queries)\n        for ii, i in enumerate(queries):\n            x = nums[i]\n            a = d[x]\n            if len(a) == 1:\n                continue\n            i = bisect_left(a, i)\n            l = a[i] - a[i - 1] if i else n - (a[-1] - a[0])\n            r = a[i + 1] - a[i] if i + 1 < len(a) else n - (a[-1] - a[0])\n            ans[ii] = min(l, r)\n        return ans","author":"lsf","submissionId":"611235593"},[]]},{"1542":[{"id":"1542","fileName":"611236143.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<int> ans(m, 0x7fffffff / 2);\n        unordered_map<int, vector<int>> umap;\n        for(int i = 0; i < n; ++i) {\n            umap[nums[i]].push_back(i);\n        }\n        for(int i = 0; i < m; ++i) {\n            int x = queries[i];\n            vector<int> &s = umap[nums[x]];\n            int p = s.size();\n            if(p == 1) {\n                ans[i] = -1;\n                continue;\n            }\n            int l = 0, r = p - 1;\n            int xx = -1;\n            while(l <= r) {\n                int mid = (l + r) >> 1;\n                if(s[mid] > x) {\n                    r = mid - 1;\n                }\n                else if(s[mid] < x) {\n                    l = mid + 1;\n                }\n                else {\n                    xx = mid;\n                    break;\n                }\n            }\n            if(xx == p - 1) {\n                ans[i] = min(s[xx] - s[xx - 1], s[0] + n - s[xx]);\n            }\n            else if(xx == 0){\n                ans[i] = min(s[1] - s[0], s[0] + n - s[p - 1]);\n            }\n            else {\n                ans[i] = min(s[xx + 1] - s[xx], s[xx] - s[xx - 1]);\n            }\n        }\n        return ans;  \n    }\n};","author":"梦见月瑞希","submissionId":"611236143"},[]]},{"1543":[{"id":"1543","fileName":"611236138.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int N = nums.length;\n        int[] dis = new int[N];\n        Arrays.fill(dis, 0x3f3f3f3f);\n        Map<Integer, Integer> map = new HashMap<>();\n        Map<Integer, Integer> max = new HashMap<>();\n        Map<Integer, Integer> min = new HashMap<>();\n        for(int i = 0; i < N; i++) {\n            max.put(nums[i], i);\n        }\n        for(int i = N - 1; i >= 0; i--) {\n            min.put(nums[i], i);\n        }\n        for(int i = 0; i < N; i++) {\n            int t = map.getOrDefault(nums[i], -1);\n            if(t >= 0) {\n                dis[i] = Math.min(dis[i], i - t);\n            }\n            t = min.getOrDefault(nums[i], -1);\n            if(t >= 0 && t < i) {\n                dis[i] = Math.min(dis[i], N - i - 1 + t + 1);\n            }\n            map.put(nums[i], i);\n        }\n        map = new HashMap<>();\n        for(int i = N - 1; i >= 0; i--) {\n            int t = map.getOrDefault(nums[i], -1);\n            if(t >= 0) {\n                dis[i] = Math.min(dis[i],t - i);\n            }\n            t = max.getOrDefault(nums[i], -1);\n            if(t > i) {\n                dis[i] = Math.min(dis[i], N - 1 - t + i + 1);\n            }\n            map.put(nums[i], i);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for(int i = 0; i < queries.length; i++) {\n            int q = queries[i];\n            if(dis[q] > N) {\n                ans.add(-1);\n            } else {\n                ans.add(dis[q]);\n            }\n        }\n        return ans;\n    }\n}","author":"朝花夕拾","submissionId":"611236138"},[]]},{"1544":[{"id":"1544","fileName":"611236177.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.putIfAbsent(nums[i], new ArrayList<>());\n            map.get(nums[i]).add(i);\n        }\n        List<Integer> ret = new ArrayList<>();\n        for (int i = 0; i < queries.length; i++) {\n            List<Integer> list = map.get(nums[queries[i]]);\n            if (list.size() == 1) {\n                ret.add(-1);\n                continue;\n            }\n            int l = 0;\n            int r = list.size() - 1;\n            while (l <= r) {\n                int mid = (l + r) / 2;\n                if (list.get(mid) < queries[i]) {\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n            int dis = 10000000;\n            if (l > 0) {\n                int d = queries[i] - list.get(l - 1);\n                dis = Math.min(d, nums.length - d);\n            } else {\n                int d = list.get(list.size() - 1) - queries[i];\n                dis = Math.min(d, nums.length - d);\n            }\n            if (l < list.size() - 1) {\n                int d = list.get(l + 1) - queries[i];\n                dis = Math.min(Math.min(d, nums.length - d), dis);\n            } else {\n                int d = queries[i] - list.get(0);\n                dis = Math.min(Math.min(d, nums.length - d), dis);\n            }\n            ret.add(dis);\n        }\n        return ret;\n    }\n}","author":"elarov","submissionId":"611236177"},[]]},{"1546":[{"id":"1546","fileName":"611236264.txt","sourceCode":"import bisect\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        l = len(nums)\n        pos_set = {}\n        ans = []\n        for i in range(len(nums)):\n            if nums[i] not in pos_set:\n                pos_set[nums[i]] = []\n            pos_set[nums[i]].append(i)\n        #print(pos_set)\n        for q in queries:\n            query_num = nums[q]\n            #print(pos_set[nums[q]])\n            if len(pos_set[nums[q]])==1:\n                ans.append(-1)\n            else:\n                index = bisect.bisect_left(pos_set[nums[q]], q)\n                left, right = 9999999999, 9999999999\n                if index>0:\n                    left = pos_set[nums[q]][index] - pos_set[nums[q]][index-1]\n                else:\n                    left = pos_set[nums[q]][index] + l - pos_set[nums[q]][-1]\n                if index<len(pos_set[nums[q]])-1:\n                    right = pos_set[nums[q]][index+1] - pos_set[nums[q]][index]\n                else:\n                    right = l - pos_set[nums[q]][-1] + pos_set[nums[q]][0]\n                ans.append(min(left, right))\n        return ans","author":"PaulKKK","submissionId":"611236264"},[]]},{"1548":[{"id":"1548","fileName":"611236277.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer,Integer> m = new HashMap<>();\n        int n=nums.length;\n        int[] res = new int[n];\n        for(int i=0;i<n;++i)res[i]=n;\n        for(int i=0;i<n;++i){\n            if(m.containsKey(nums[i]) && m.get(nums[i])!=i){\n                res[i]=Math.min(res[i],Math.abs(i-m.get(nums[i])));\n                res[i]=Math.min(res[i],Math.abs(m.get(nums[i])+n-i));\n                res[i]=Math.min(res[i],Math.abs(-m.get(nums[i])+n+i));\n            }\n            m.put(nums[i],i);\n        }\n        for(int i=0;i<n;++i){\n            if(m.containsKey(nums[i]) && m.get(nums[i])!=i){\n                res[i]=Math.min(res[i],Math.abs(i-m.get(nums[i])));\n                res[i]=Math.min(res[i],Math.abs(m.get(nums[i])+n-i));\n                res[i]=Math.min(res[i],Math.abs(-m.get(nums[i])+n+i));\n            }\n            m.put(nums[i],i);\n        }\n        m = new HashMap<>();\n        for(int i=n-1;i>=0;--i){\n            if(m.containsKey(nums[i]) && m.get(nums[i])!=i){\n                res[i]=Math.min(res[i],Math.abs(i-m.get(nums[i])));\n                res[i]=Math.min(res[i],Math.abs(m.get(nums[i])+n-i));\n                res[i]=Math.min(res[i],Math.abs(-m.get(nums[i])+n+i));\n            }\n            m.put(nums[i],i);\n        }\n        for(int i=n-1;i>=0;--i){\n            if(m.containsKey(nums[i]) && m.get(nums[i])!=i){\n                res[i]=Math.min(res[i],Math.abs(i-m.get(nums[i])));\n                res[i]=Math.min(res[i],Math.abs(m.get(nums[i])+n-i));\n                res[i]=Math.min(res[i],Math.abs(-m.get(nums[i])+n+i));\n            }\n            m.put(nums[i],i);\n        }\n        List<Integer> result = new ArrayList<>();\n        for(int i:queries){\n            if(res[i]<n) result.add(res[i]);\n            else result.add(-1);\n        }\n        return result;\n    }\n}","author":"delideliBird","submissionId":"611236277"},[]]},{"1550":[{"id":"1550","fileName":"611236336.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size(),ma=*max_element(nums.begin(),nums.end());\n        int m=queries.size();\n        vector<vector<int>>e(ma+1);\n        for(int i=0;i<n;++i) e[nums[i]].push_back(i);\n        vector<int>res(m,n);\n        for(int i=0;i<m;++i){\n            int cur=queries[i]%n;\n            int sz=e[nums[cur]].size();\n            if(sz==1) continue;\n            int t=lower_bound(e[nums[cur]].begin(),e[nums[cur]].end(),cur)-e[nums[cur]].begin();\n            res[i]=min(res[i],(e[nums[cur]][t]-e[nums[cur]][(t-1+sz)%sz]+n)%n);\n            res[i]=min(res[i],(e[nums[cur]][(t+1)%sz]-e[nums[cur]][t]+n)%n);\n        }\n        for(auto &i:res) if(i==n) i=-1;\n        return res;\n    }\n};","author":"Glow.","submissionId":"611236336"},[]]},{"1551":[{"id":"1551","fileName":"611236326.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n                Map<Integer,Integer> mapfi=new HashMap<>();\n        Map<Integer,Integer> mappre=new HashMap<>();\n        int[] v=new int[nums.length];\n        Arrays.fill(v,Integer.MAX_VALUE);\n        for (int i=0;i<nums.length;i++){\n            int a=nums[i];\n            int s=mapfi.getOrDefault(a,-1);\n            if(s==-1){\n                mapfi.put(a,i);\n            }else {\n                int pre=mappre.get(a);\n                v[pre]=Math.min(v[pre],i-pre);\n                v[i]=i-pre;\n            }\n            mappre.put(a,i);\n        }\n        for (int a:mappre.keySet()){\n            int c=mapfi.get(a);\n            int b=mappre.get(a);\n            if(c!=b){\n                v[c]=Math.min(v[c],c+nums.length-b);\n                v[b]=Math.min(v[b],c+nums.length-b);\n            }\n        }\n        List<Integer> re=new ArrayList<>();\n        for (int i=0;i<queries.length;i++){\n            int a=queries[i];\n            if(v[a]!=Integer.MAX_VALUE){\n                re.add(v[a]);\n            }else re.add(-1);\n        }\n        return re;\n    }\n}","author":"Recursing MeitnerIJ2","submissionId":"611236326"},[]]},{"1552":[{"id":"1552","fileName":"611236309.txt","sourceCode":"class Solution {\npublic:\n    int diff(int a,int b,int n){\n        //cout << a << \" \" << b << \" \" << n << endl;\n        return min((a - b + n) % n,(b - a + n) % n);\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        unordered_map<int,vector<int>> mmp;\n        for(int i = 0;i < nums.size();i++){\n            mmp[nums[i]].push_back(i);\n        }\n        int n = nums.size();\n        vector<int> ans(q.size(),-1);\n        for(int i = 0;i < q.size();i++){\n            vector<int> &a = mmp[nums[q[i]]];\n            int m = a.size();\n            if(m == 1)continue;\n            \n            int idx = lower_bound(a.begin(),a.end(),q[i]) - a.begin();\n            if(m == 2){\n                ans[i] = diff(a[0],a[1],n);\n            }else{\n                int l = (idx - 1 + m) % m;\n                int r = (idx + 1) % m;\n                ans[i] = min(diff(a[idx],a[l],n),diff(a[idx],a[r],n));\n                //cout << \"i = \" << i << \" \" << idx << \" \" << l << \" \" << r << endl;\n            }\n        }\n        return ans;\n    }\n};","author":"小刀刺大熊","submissionId":"611236309"},[]]},{"1553":[{"id":"1553","fileName":"611236369.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        const int INF=1e9;\n        int i,x,l,r,mid,ans;\n        unordered_map<int,vector<int>>a;\n        vector<int>b;\n        for(i=0;i<nums.size();i++)\n        a[nums[i]].push_back(i);\n        for(i=0;i<queries.size();i++)\n            {\n                x=nums[queries[i]];\n                if(a[x].size()==1)b.push_back(-1);\n                else\n                {\n                    l=0; r=a[x].size()-1; ans=INF;\n                    while(l<=r)\n                        {\n                            mid=(l+r)/2;\n                            if(a[x][mid]==queries[i])break;\n                            else if(a[x][mid]<queries[i])l=mid+1;\n                            else if(a[x][mid]>queries[i])r=mid-1;\n                        }\n                    cout<<mid<<endl;\n                    if(mid==0)ans=min(ans,min(a[x][mid+1]-a[x][mid],a[x][mid]+(int)nums.size()-a[x].back()));\n                    else if(mid==a[x].size()-1)ans=min(ans,min(a[x][mid]-a[x][mid-1],a[x][0]+(int)nums.size()-a[x][mid]));\n                    else ans=min(ans,min(a[x][mid]-a[x][mid-1],a[x][mid+1]-a[x][mid]));\n                    b.push_back(ans);\n                }\n            }\n        return b;\n    }\n};","author":"er🌪","submissionId":"611236369"},[]]},{"1554":[{"id":"1554","fileName":"611236355.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        m = {}\n        n = len(nums)\n        res = [inf]*n\n        def dis(a,b):\n            if a == b:\n                return inf\n            return min(abs(a-b), n-abs(a-b))\n        for i,v in enumerate(nums):\n            if v in m:\n                res[i] = min(res[i], dis(m[v], i))\n            m[v] = i\n        for i,v in enumerate(nums):\n            #print('two',i,v,m[v],dis(m[v], i))\n            if m[v] == i:\n                continue\n            res[i] = min(res[i], dis(m[v], i))\n        \n        m = {}\n        for i in range(n-1,-1,-1):\n            v = nums[i]\n            if v in m:\n                res[i] = min(res[i], dis(m[v], i))\n            m[v] = i\n        for i in range(n-1,-1,-1):\n            v = nums[i]\n            #print('back two',i,v,m[v],dis(m[v], i))\n            if m[v] == i:\n                continue\n            res[i] = min(res[i], dis(m[v], i))\n        #print('res',res)\n        qs = []\n        for i in queries:\n            qs.append(-1 if res[i] == inf else res[i])\n        return qs","author":"cpp20","submissionId":"611236355"},[]]},{"1555":[{"id":"1555","fileName":"611236394.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], q: List[int]) -> List[int]:\n        n = len(q)\n        k = len(nums)\n        ans = [-1] * n\n        m = defaultdict(list)\n        for i,x in enumerate(nums):\n            m[x].append(i)\n        for i, x in enumerate(q):\n            l = m[nums[x]]\n            if len(l) == 1: continue\n            j = bisect.bisect_left(l, x)\n            o = len(l)\n            ans[i] = min(abs(l[j] - l[(j+1)%o]), abs(l[j]- l[(j-1+o)%o]),\n                k-abs(l[j] - l[(j+1)%o]), k-abs(l[j] - l[(j-1+o)%o]))\n\n        return ans","author":"啦咘啦哆警长","submissionId":"611236394"},[]]},{"1556":[{"id":"1556","fileName":"611236461.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& qs) {\n        int n = a.size(), m = qs.size();\n\n        unordered_map<int, int> cnt;\n        for (auto& e : a) cnt[e]++;\n\n        auto b = a;\n        b.insert(b.end(), a.begin(), a.end());\n        // for (auto& e : b) cout << e << \" \"; cout << \"n\";\n        \n        vector<int> L(n * 2), R(n * 2);\n        vector<int> last(1e6 + 1, -1);\n        for (int i = 0; i < n * 2; i++) {\n            int x = b[i];\n            L[i] = last[x];\n            last[x] = i;\n        }\n\n        last.assign(1e6 + 1, -1);\n        for (int i = 2 * n - 1; i >= 0; i--) {\n            int x = b[i];\n            R[i] = last[x];\n            last[x] = i;\n        }\n\n        vector<int> res;\n        for (auto& q : qs) {\n            if (cnt[a[q]] == 1) {\n                res.push_back(-1);\n                continue;\n            }\n            int dist = INT_MAX;\n            if (L[q] != -1) {\n                dist = min(dist, q - L[q]);\n            }\n            if (L[n + q] != -1) {\n                dist = min(dist, n + q - L[n + q]);\n            }\n            if (R[q] != -1) {\n                dist = min(dist, R[q] - q);\n            }\n            if (R[n + q] != -1) {\n                dist = min(dist, R[n + q] - (n + q) );\n            }\n            if (dist == INT_MAX) {\n                dist = -1;\n            }\n            res.push_back(dist);\n        }\n        return res;\n    }\n};","author":"另一个我","submissionId":"611236461"},[]]},{"1557":[{"id":"1557","fileName":"611236407.txt","sourceCode":"class Solution {\npublic:\n    int dis(int x,int y,int sz){\n        return min(abs(x-y),sz-abs(x-y));\n    }\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        unordered_map<int,vector<int>> pos;\n        vector<int> ans;\n        int n=a.size(),m=q.size();\n        for(int i=0;i<n;i++){\n            pos[a[i]].push_back(i);\n        }\n        for(int i:q){\n            int sz=pos[a[i]].size();\n            if(sz<2){\n                ans.push_back(-1);\n            }else{\n                int j=lower_bound(pos[a[i]].begin(),pos[a[i]].end(),i)-pos[a[i]].begin();\n                int l=pos[a[i]][(j-1+sz)%sz],r=pos[a[i]][(j+1)%sz];\n                ans.push_back(min(dis(i,l,n),dis(i,r,n)));\n            }\n        }\n        return ans;\n    }\n};","author":"Romantic I3assiw5k","submissionId":"611236407"},[]]},{"1558":[{"id":"1558","fileName":"611236431.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> pos;\n        int a,b,c,d,e,f,g,h,j;\n        a=nums.size();\n        for(b=0;b<a;b++)\n            {\n                pos[nums[b]].push_back(b);\n            }\n        b=queries.size();\n        vector<int> ans(b,-1);\n        for(c=0;c<b;c++)\n            {\n                d=pos[nums[queries[c]]].size();\n                if(d==1)\n                    continue;\n                if(pos[nums[queries[c]]][0]==queries[c])\n                {\n                    ans[c]=min(pos[nums[queries[c]]][1]-pos[nums[queries[c]]][0],a-pos[nums[queries[c]]][d-1]+pos[nums[queries[c]]][0]);\n                }\n                else if(pos[nums[queries[c]]][d-1]==queries[c])\n                {\n                    ans[c]=min(pos[nums[queries[c]]][d-1]-pos[nums[queries[c]]][d-2],a-pos[nums[queries[c]]][d-1]+pos[nums[queries[c]]][0]);\n                }\n                else\n                {\n                    int l,r,mid;\n                    l=0;\n                    r=d-1;\n                    while(l<=r)\n                        {\n                            mid=(l+r)/2;\n                            if(pos[nums[queries[c]]][mid]==queries[c])\n                                    break;\n                            if(pos[nums[queries[c]]][mid]>queries[c])\n                                    r=mid-1;\n                            else\n                                    l=mid+1;\n                        }\n                    ans[c]=min(queries[c]-pos[nums[queries[c]]][mid-1],pos[nums[queries[c]]][mid+1]-queries[c]);\n                }\n            }\n        return ans;\n    }\n};","author":"Wilbert","submissionId":"611236431"},[]]},{"1559":[{"id":"1559","fileName":"611236475.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>> mp;\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            mp[nums[i]].emplace_back(i);\n        }\n        function<int(int)> check=[&](int x){\n            if(!mp.count(nums[x]))return -1;\n            auto& idxs=mp[nums[x]];\n            if(idxs.size()==1)return -1;\n            int m=idxs.size();\n            int k=(lower_bound(idxs.begin(),idxs.end(),x)-idxs.begin())%m;\n            int r=(k+1+m)%m;\n            int l=(k-1+m)%m;\n            r=abs(idxs[r]-x);\n            l=abs(idxs[l]-x);\n            return min({r,n-r,l,n-l});\n        };\n        vector<int> res;\n        for(int& q:queries){\n            res.emplace_back(check(q));\n        }\n        return res;\n    }\n};","author":"贺茂建角身神","submissionId":"611236475"},[]]},{"1560":[{"id":"1560","fileName":"611236474.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        res = []\n        l = len(nums)\n        sort_d = {}\n\n        for i,n in enumerate(nums):\n            if n not in sort_d:\n                sort_d[n] = SortedList([i])\n            else:\n                sort_d[n].add(i)\n\n\n        for q in queries:\n            to_q_num = nums[q]\n            if len(sort_d[to_q_num]) == 1:\n                res.append(-1)\n                continue\n\n            idx = sort_d[to_q_num].bisect_left(q)\n\n            if idx == 0:\n                near_right_idx = sort_d[to_q_num][1]\n                near_left_idx = sort_d[to_q_num][-1]\n\n            elif idx == len(sort_d[to_q_num]) - 1:\n                near_right_idx = sort_d[to_q_num][0]\n                near_left_idx = sort_d[to_q_num][idx-1]\n                # res.append(min(l - abs(q - near_right_idx), abs(q - near_left_idx)))\n            else:\n                near_right_idx = sort_d[to_q_num][idx + 1]\n                near_left_idx = sort_d[to_q_num][idx - 1]\n                # res.append(min(abs(q-near_right_idx), abs(q-near_left_idx)))\n\n            res.append(min(abs(q - near_right_idx),\n                           l - abs(q - near_right_idx),\n                           l - abs(q - near_left_idx),\n                           abs(q - near_left_idx)))\n\n        return res","author":"黄XC","submissionId":"611236474"},[]]},{"1561":[{"id":"1561","fileName":"611236482.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        auto getQ = [&](int i)->int {\n            int num = nums[i];\n            vector<int>& idxs = mp[num];\n            int iR = upper_bound(idxs.begin(), idxs.end(), i) - idxs.begin();\n            int iL = lower_bound(idxs.begin(), idxs.end(), i) - idxs.begin() - 1;\n            if (iL == -1 && idxs.size() > 1) iL = idxs.size() - 1;\n            if (iR == idxs.size() && idxs.size() > 1) iR = 0;\n            if (iL == -1 && iR == idxs.size()) return -1;\n            int ans = n - 1;\n            if (iL != -1) {\n                int mn = abs(idxs[iL] - i);\n                ans = min({ ans,mn,n - mn });\n            }\n            if (iR != idxs.size()) {\n                int mn = abs(idxs[iR] - i);\n                ans = min({ ans,mn,n - mn });\n            }\n            return ans;\n        };\n        vector<int> res;\n        for (int& idx : queries) res.push_back(getQ(idx));\n        return res;\n    }\n\n};","author":"Cranky Hermann8Yl","submissionId":"611236482"},[]]},{"1562":[{"id":"1562","fileName":"611236506.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        auto max_v = *max_element(nums.begin(), nums.end());\n        vector<set<int>> sets(max_v + 1);\n\n        int n = nums.size();\n        for (int i = 0; i < n; i++)\n            sets[nums[i]].insert(i);\n\n        int m = queries.size();\n        vector<int> ans(m, 0);\n        int idx = 0;\n        for (auto q: queries)\n        {\n            int v = nums[q];\n            auto it = sets[v].find(q);\n\n            auto last_it = it, next_it = it;\n            next_it++;\n\n            if (it == sets[v].begin()) \n            {\n                last_it = sets[v].end();\n            }\n            last_it--;\n\n            if (next_it == sets[v].end()) next_it = sets[v].begin();\n\n            auto last_v = *last_it, next_v = *next_it;\n            // cout << q << ' ' << nums[q] << ' ' << last_v << ' ' << next_v << endl;\n\n            ans[idx] = 1e9;\n            if (last_v != q) \n            {\n                auto step = abs(q - last_v);\n                step = min(step, n - step);\n                ans[idx] = min(ans[idx], step);\n            }\n            if (next_v != q)\n            {\n                auto step = abs(q - next_v);\n                step = min(step, n - step);\n                ans[idx] = min(ans[idx], step);\n            }\n\n            idx++;\n        }\n\n        for (auto &v : ans)\n            if (v == 1e9) v = -1;\n\n        return ans;\n    }\n};","author":"Lozical","submissionId":"611236506"},[]]},{"1563":[{"id":"1563","fileName":"611236566.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n=len(nums)\n        occur=[[] for _ in range(max(nums)+1)]\n        for i in range(n):\n            occur[nums[i]].append(i)\n        for j in range(len(queries)):\n            ind=queries[j]\n            cur=occur[nums[ind]]\n            if len(cur)==1:queries[j]=-1\n            else:\n                if ind==cur[0]:queries[j]=min(n-cur[-1]+ind,cur[1]-ind)\n                elif ind==cur[-1]:queries[j]=min(n-ind+cur[0],ind-cur[-2])\n                else:\n                    i=bisect_left(cur,ind)\n                    queries[j]=min(ind-cur[i-1],cur[i+1]-ind)\n        return queries","author":"Hyperalgebra","submissionId":"611236566"},[]]},{"1564":[{"id":"1564","fileName":"611236507.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\nint n=nums.size();\n        vector<int> left(n,n+1),right(n,n+1);\n        map<int,int> mp,mpFirst;\n        for(int i=0;i<n;i++)\n            {\n                if(mp.count(nums[i]))\n                {\n                    left[i]=i-mp[nums[i]];\n                }\n                if(!mpFirst.count(nums[i]))\n                {\n                    mpFirst[nums[i]]=i;\n                }\n                mp[nums[i]]=i;\n            }\n        map<int,int> mp2,mp2First;\n        for(int i=n-1;i>=0;i--)\n            {\n                if(mp2.count(nums[i]))\n                {\n                    right[i]=mp2[nums[i]]-i;\n                }\n                if(!mp2First.count(nums[i]))\n                {\n                    mp2First[nums[i]]=i;\n                }\n                mp2[nums[i]]=i;\n            }\n        for(int i=0;i<n;i++)\n            {\n                if(mpFirst.count(nums[i])&&mpFirst[nums[i]]!=i)\n                {\n                    right[i]=min(right[i],mpFirst[nums[i]]+n-i);\n                }\n                if(mp2First.count(nums[i])&&mp2First[nums[i]]!=i)\n                {\n                    left[i]=min(left[i],n-mp2First[nums[i]]+i);\n                }\n            }\n        vector<int> res;\n        for(auto c:queries)\n            {\n                int ans=min(left[c],right[c]);\n                if(ans==n+1)\n                {\n                    res.push_back(-1);\n                }\n                else\n                {\n                    res.push_back(ans);\n                }\n            }\n        return res;\n    }\n};","author":"姚舟","submissionId":"611236507"},[]]},{"1565":[{"id":"1565","fileName":"611236498.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int m = nums.size(), n = queries.size();\n        vector<int>ans(n,-1);\n        map<int,vector<int>>mp;\n        for (int i = 0; i < m; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        \n        for (int i = 0; i < n; i++) {\n            int x = nums[queries[i]];\n            int mi = 1e9;\n            int p = lower_bound(mp[x].begin(),mp[x].end(),queries[i]) - mp[x].begin();\n            if (p - 1 >= 0) {\n                int t = mp[x][p] - mp[x][p - 1];\n                int ret = mp[x][p] - mp[x][0];\n                int res = mp[x].back() - mp[x][p];\n                mi = min(mi,min({t,m - t,m - ret,m - res}));\n            }\n            if (p + 1 < mp[x].size()) {\n                int t = mp[x][p + 1] - mp[x][p];\n                int ret = mp[x][p] - mp[x][0];\n                int res = mp[x].back() - mp[x][p];\n                mi = min(mi,min({t,m - t,m - ret,m - res}));\n            }\n            if (mi != 1e9) ans[i] = mi;\n        }\n        return ans;\n    }\n};","author":"Amazing EuclidB0n","submissionId":"611236498"},[]]},{"1566":[{"id":"1566","fileName":"611236647.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        ArrayList<Integer> res = new ArrayList<>();\n        int n = nums.length;\n        int[][] pre = new int[n][2];\n        Map<Integer, Integer> p = new HashMap<>();\n        Map<Integer, Integer> f = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            if (p.get(nums[i]) == null) {\n                pre[i][0] = -1;\n            } else {\n                pre[i][0] = p.get(nums[i]);\n            }\n            p.put(nums[i], i);\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            if (f.get(nums[i]) == null) {\n                pre[i][1] = n;\n            } else {\n                pre[i][1] = f.get(nums[i]);\n            }\n            f.put(nums[i], i);\n        }\n        // System.out.println(Arrays.deepToString(pre));\n        for (int q : queries) {\n            int a = pre[q][0] == -1 ? (p.get(nums[q]) != null ? ((n - p.get(nums[q]) + q) == n ? -1 : (n - p.get(nums[q]) + q)) : -1) : Math.min(q - pre[q][0], n - q + pre[q][0]);\n            int b = pre[q][1] == n ? (f.get(nums[q]) != null ? ((n - q + f.get(nums[q])) == n ? -1 : (n - q + f.get(nums[q]))) : -1) : Math.min(pre[q][1] - q, n - pre[q][1] + q);\n            res.add(a == -1 && b == -1 ? -1 : Math.min(a, b));\n        }\n        return res;\n    }\n}","author":"waters_man","submissionId":"611236647"},[]]},{"1567":[{"id":"1567","fileName":"611236658.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int> > mp;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for (int q : queries) {\n            auto& v = mp[nums[q]];\n            int i = lower_bound(v.begin(), v.end(), q) - v.begin();\n            if (i != 0 && i != v.size() - 1) {\n                ans.push_back(min(v[i + 1] - q, q - v[i - 1]));\n            } else if (i != 0) { // 最后一个\n                ans.push_back(min(q - v[i - 1], n - (q - v[0])));\n            } else if (i != v.size() - 1) { // 第一个\n                ans.push_back(min(v[i + 1] - q, n - (v.back() - q)));\n            } else {\n                ans.push_back(-1);\n            }\n        }\n        return move(ans);\n    }\n};","author":"XYukari","submissionId":"611236658"},[]]},{"1569":[{"id":"1569","fileName":"611236689.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries)\n    {\n    \tnums.insert(nums.end(), nums.begin(), nums.end());\n    \tint                     n = nums.size();\n    \tvector<int>             pre(n, -1);\n    \tvector<int>             suf(n, -1);\n    \tunordered_map<int, int> mp;\n    \n    \tfor (int i = 0; i < n; i++)\n    \t{\n    \t\tif (mp.count(nums[i])) pre[i] = mp[nums[i]];\n    \t\tmp[nums[i]] = i;\n    \t}\n    \tmp.clear();\n    \tfor (int i = n - 1; i >= 0; i--)\n    \t{\n    \t\tif (mp.count(nums[i])) suf[i] = mp[nums[i]];\n    \t\tmp[nums[i]] = i;\n    \t}\n    \n    \tvector<int> ans;\n    \tfor (auto t : queries)\n    \t{\n    \t\tint res = 0x3f3f3f3f;\n    \t\tif (pre[t] != -1)\n    \t\t{\n    \t\t\tres = min({res, t - pre[t], n - t + pre[t]});\n    \t\t}\n    \t\tif (suf[t] != -1)\n    \t\t{\n    \t\t\tres = min({res, suf[t] - t, n - suf[t] + t});\n    \t\t}\n    \t\tt += n / 2;\n    \t\tif (pre[t] != -1)\n    \t\t{\n    \t\t\tres = min({res, t - pre[t], n - t + pre[t]});\n    \t\t}\n    \t\tif (suf[t] != -1)\n    \t\t{\n    \t\t\tres = min({res, suf[t] - t, n - suf[t] + t});\n    \t\t}\n    \t\tif (res >= n/2)\n    \t\t\tans.push_back(-1);\n    \t\telse\n    \t\t\tans.push_back(res);\n    \t}\n    \treturn ans;\n    }\n};","author":"OVOAutoMaton","submissionId":"611236689"},[]]},{"1570":[{"id":"1570","fileName":"611236600.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n    vector<int>f(n);\n    unordered_map<int,vector<int>>mp;\n    for(int i=0;i<n;i++){\n        mp[nums[i]].push_back(i-n);\n    }\n    for(int i=0;i<n;i++){\n        mp[nums[i]].push_back(i);\n    }\n    for(int i=n;i<n*2;i++){\n        mp[nums[i-n]].push_back(i);\n    }\n    vector<int>ans(queries.size());\n    for(int i=0;i<queries.size();i++){\n        int a=nums[queries[i]];\n        if(mp[a].size()==1){\n            ans[i]=-1;\n        }else{\n            int sum=1e9;\n            auto it=lower_bound(mp[a].begin(),mp[a].end(),queries[i]);\n            if(it!=mp[a].begin()){\n                sum=min(queries[i]-*prev(it),sum);\n            }\n            if(it!=mp[a].end()&&next(it) != mp[a].end()){\n                sum=min(*next(it)-queries[i],sum);\n            }\n            if(sum>=n){\n                ans[i]=-1;\n            }else{\n                ans[i]=sum;\n            }\n            \n        }\n    }\n    return ans;\n    }\n};","author":"anyiling","submissionId":"611236600"},[]]},{"1571":[{"id":"1571","fileName":"611236686.txt","sourceCode":"class Solution {\npublic:\n  vector<int> solveQueries(vector<int> &nums, vector<int> &queries) {\n    const int n = nums.size(), m = queries.size();\n    vector<int> ret(m);\n    unordered_map<int, vector<int>> mp;\n    for (int i = 0; i < n; ++i) {\n      mp[nums[i]].emplace_back(i);\n    }\n    for (int i = 0; i < m; ++i) {\n      int idx = queries[i];\n      auto itr = lower_bound(mp[nums[idx]].begin(), mp[nums[idx]].end(), idx);\n      if (itr == mp[nums[idx]].begin() && itr + 1 == mp[nums[idx]].end()) {\n        ret[i] = -1;\n        continue;\n      }\n      if (itr == mp[nums[idx]].begin()) {\n        auto itr2 = itr + 1;\n        auto itr3 = mp[nums[idx]].end() - 1;\n        ret[i] = min(*itr2 - *itr, n - (*itr3 - *itr));\n      } else if (itr + 1 == mp[nums[idx]].end()) {\n        auto itr2 = itr - 1;\n        auto itr3 = mp[nums[idx]].begin();\n        ret[i] = min(*itr - *itr2, n - (*itr - *itr3));\n      } else {\n        auto itr2 = itr - 1;\n        auto itr3 = itr + 1;\n        ret[i] = min(*itr - *itr2, *itr3 - *itr);\n      }\n    }\n    return ret;\n  }\n};","author":"TwinklerG","submissionId":"611236686"},[]]},{"1572":[{"id":"1572","fileName":"611236759.txt","sourceCode":"\nfunc solveQueries(nums []int, queries []int) []int {\n\tans := make([]int, len(queries))\n\tn := len(nums)\n\tpos := map[int][]int{}\n\tfor i, v := range nums {\n\t\tpos[v] = append(pos[v], i)\n\t}\n\tcal := func(u, v int) int {\n\t\tif u > v {\n\t\t\tu, v = v, u\n\t\t}\n\t\treturn min(v-u, n-v+u)\n\t}\n\tfor i, q := range queries {\n\t\tv := nums[q]\n\t\tif len(pos[v]) == 1 {\n\t\t\tans[i] = -1\n\t\t\tcontinue\n\t\t}\n\t\tj := sort.SearchInts(pos[v], q)\n\t\tm := len(pos[v])\n\t\tl, r := pos[v][(j-1+m)%m], pos[v][(j+1)%m]\n\t\tans[i] = min(cal(l, q), cal(r, q))\n\t}\n\treturn ans\n}\n","author":"djzzwx","submissionId":"611236759"},[]]},{"1573":[{"id":"1573","fileName":"611236862.txt","sourceCode":"\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        m = defaultdict(list)\n        for i, x in enumerate(nums):\n            m[x].append(i)\n        n = len(nums)\n\n        ans = []\n        for x in queries:\n            idx = bisect_left(m[nums[x]], x)\n            t = inf\n            if len(m[nums[x]]) > 1 and idx:\n                t = n - m[nums[x]][idx] + m[nums[x]][0]\n            if len(m[nums[x]]) > 1 and idx < len(m[nums[x]]) - 1:\n                t = min(t, m[nums[x]][idx] + n - m[nums[x]][-1])\n            if idx:\n                t = min(t, m[nums[x]][idx] - m[nums[x]][idx - 1])\n            if idx < len(m[nums[x]]) - 1:\n                t = min(t, m[nums[x]][idx + 1] - m[nums[x]][idx])\n            ans.append(t if t < inf else -1)\n        return ans\n","author":"ABCoder","submissionId":"611236862"},[]]},{"1574":[{"id":"1574","fileName":"611236888.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> ans(queries.size());\n        vector<int> arr(nums.size());\n        map<int, vector<int>> haxi;\n        for (int i = 0; i < nums.size(); i++) {\n            arr[i] = haxi[nums[i]].size();\n            haxi[nums[i]].push_back(i);\n        }\n        for (int i = 0; i < ans.size(); i++) {\n            int index = queries[i];\n            auto& temp = haxi[nums[index]];\n            size_t n = -1;\n            if (arr[index])\n                n = min<size_t>(n, temp[arr[index]] - temp[arr[index] - 1]);\n            else if (temp.size() != 1)\n                n = min<size_t>(n, temp[0] + nums.size() - temp.back());\n\n            if (arr[index] != temp.size() - 1)\n                n = min<size_t>(n, temp[arr[index] + 1] - temp[arr[index]]);\n            else if (temp.size() != 1)\n                n = min<size_t>(n, temp[0] + nums.size() - temp.back());\n\n            ans[i] = n;\n        }\n        return ans;\n    }\n};","author":"Elaina","submissionId":"611236888"},[]]},{"1575":[{"id":"1575","fileName":"611236866.txt","sourceCode":"import java.util.*;\nimport java.util.function.*;\n\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n\n        // val : indexList\n        HashMap<Integer, List<Integer>> valMap = new HashMap<Integer,List<Integer>>();\n        for (int i = 0; i < n; i++) {\n            int val = nums[i];\n            valMap.computeIfAbsent(val,(k)->(new ArrayList<>())).add(i);\n        }\n\n        List<Integer> ansList = new ArrayList<Integer>(queries.length);\n        for (int index : queries) {\n            List<Integer> indexList = valMap.get(nums[index]);\n            if (indexList.size() == 1) {\n                ansList.add(-1);\n                continue;\n            }\n\n            int rank = BinarySearch.search(0,indexList.size(),(k)->(indexList.get(k) >= index));\n            int minDiff = n;\n            for (int change = -1; change <= 1; change+=2) {\n                int anotherRank = (rank+change+indexList.size())%indexList.size();\n                int indexDiff = Math.abs(index - indexList.get(anotherRank));\n                minDiff = Math.min(minDiff,Math.min(indexDiff,n-indexDiff));\n            }\n            ansList.add(minDiff);\n        }\n\n        return ansList;\n    }\n}\n\nclass BinarySearch{\n\n    static int search(int left,int right,IntFunction<Boolean> checkFunction) {\n        \n        while(left < right){\n            int mid = (left + right)/2;\n            if (checkFunction.apply(mid)) {\n                right = mid;\n            }\n            else{\n                left = mid+1;\n            }\n        }\n\n        return left;\n    }\n\n}\n\n\n// class Test{\n//     public static void main(String[] args) {\n//         Solution solution = new Solution();\n//         solution.xorQueries(new int[]{1,3,4,8},new int[][]{{0,1},{1,2},{0,3},{3,3}});\n//     }\n// }","author":"355515","submissionId":"611236866"},[]]},{"1576":[{"id":"1576","fileName":"611237020.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<int> ans(m, 0);\n        map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(n + i);\n        }\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(2 * n + i);\n        }\n        for (int i = 0; i < m; i++) {\n            int idx = queries[i];\n            int val = nums[idx];\n            int pos = lower_bound(mp[val].begin(), mp[val].end(), idx + n) - mp[val].begin();\n            if (mp[val].size() == 3) ans[i] = -1;\n            else {\n                ans[i] = min(mp[val][pos] - mp[val][pos - 1], mp[val][pos + 1] - mp[val][pos]);\n            }\n        }\n        return ans;\n    }\n};","author":"北棂","submissionId":"611237020"},[]]},{"1577":[{"id":"1577","fileName":"611236762.txt","sourceCode":"#define pb push_back\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> a(nums);\n        int n = nums.size();\n        for (auto v : nums) a.pb(v);\n        vector<int> dis(n, 0x3f3f3f3f);\n        vector<int> pos(1000001, 0x3f3f3f3f);\n        for (int i = 0; i < 2 * n; i++) {\n            if (i >= n) {\n                if (pos[a[i]] != 0x3f3f3f3f) dis[i-n] = i - pos[a[i]];\n            }\n            pos[a[i]] = i;\n        }\n        fill(pos.begin(), pos.end(), 0x3f3f3f3f);\n        for (int i = 2 * n - 1; i >= 0; i--) {\n            if (i < n) {\n                if (pos[a[i]] != 0x3f3f3f3f)\n                    dis[i] = min(dis[i], pos[a[i]] - i);\n            }\n            pos[a[i]] = i;\n        }\n        vector<int> ans;\n        for (auto id : queries) {\n            if (dis[id] == n) ans.push_back(-1);\n            else ans.push_back(dis[id]);\n        }\n        return ans;\n    }\n};","author":"猎捕一切优质河狸","submissionId":"611236762"},[]]},{"1578":[{"id":"1578","fileName":"611236835.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = queries.size();\n        int m = nums.size();\n        vector<int> res;\n        unordered_map<int, vector<int>> h;\n        for (int i = 0; i < m; ++ i) {\n            auto& v = h[nums[i]];\n            v.emplace_back(i);\n        }\n        for (int i = 0; i < n; ++ i) {\n            int pos = queries[i];\n            auto& v = h[nums[pos]];\n            if (v.size() == 1) {\n                res.push_back(-1);\n            } else {\n                int right = upper_bound(v.begin(), v.end(), pos) - v.begin();\n                int left = lower_bound(v.begin(), v.end(), pos) - v.begin() - 1;\n                if (right == v.size()) {\n                    res.push_back(min(pos - v[right - 2], m - (pos - v[0])));\n                } else if (left == -1) {\n                    res.push_back(min(m - (v[v.size() - 1] - v[0]), v[1] - pos));\n                } else {\n                    res.push_back(min(v[right] - pos, pos - v[left]));\n                }\n            }\n        }\n        return res;\n    }\n};","author":"1！+1！=2！","submissionId":"611236835"},[]]},{"1579":[{"id":"1579","fileName":"611237046.txt","sourceCode":"class Solution\n{\npublic:\n    vector<int> solveQueries(vector<int> &nums, vector<int> &queries)\n    {\n        int n = nums.size();\n        unordered_map<int, int> m; // 上一个的位置\n        vector<pair<int, int>> n_idxs(\n            n, {-1,n}); // idx的最近idx\n        auto update = [&](int i)\n        {\n            int num = nums[i];\n            if (m.count(num))\n            {\n                int lstIdx = m[num];\n                if(lstIdx == i) return;\n                int mx = max(lstIdx, i), mi = min(lstIdx, i);\n                int dis = min(mx - mi, n + mi - mx);\n                // 更新自己\n                if (dis < n_idxs[i].second)\n                {\n                    n_idxs[i] = {lstIdx, dis};\n                }\n                // 更新上一个\n                if (dis < n_idxs[lstIdx].second)\n                {\n                    n_idxs[lstIdx] = {i, dis};\n                }\n            }\n            else\n            {\n                n_idxs[i].first = -1;\n            }\n            m[num] = i;\n        };\n        for(int i = 0; i < n; ++i){\n            update(i);\n        }\n        for(int i = 0; i < n; ++i){\n            update(i);\n        }\n        // for(auto &[i,d]:n_idxs){\n        //     cout << i << \" \" << d << endl;\n        // }\n        vector<int> ans;\n        for(auto q:queries){\n            ans.push_back(n_idxs[q].second == n ? -1 : n_idxs[q].second);\n        }\n        // cout << endl;\n        return ans;\n    }\n};","author":"幸存者","submissionId":"611237046"},[]]},{"1580":[{"id":"1580","fileName":"611237038.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        pos = defaultdict(list)\n        for i, val in enumerate(nums):\n            pos[val].append(i)\n        q = [-1] * n\n        for val in pos:\n            if len(pos[val]) > 1:\n                for i, p in enumerate(pos[val]):\n                    if i == 0:\n                        mindist = min(p + n - pos[val][-1], pos[val][i + 1] - p)\n                    elif i == len(pos[val]) - 1:\n                        mindist = min(pos[val][0] + n - p, p - pos[val][i - 1])\n                    else:\n                        mindist = min(pos[val][i + 1] - p, p - pos[val][i - 1])\n                    q[p] = mindist\n        res = []\n        for qu in queries:\n            res.append(q[qu])\n        return res\n            \n                    \n                \n            \n            \n        ","author":"目目","submissionId":"611237038"},[]]},{"1581":[{"id":"1581","fileName":"611237025.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        m = len(queries)\n        hash_num = defaultdict(list)\n        ans = [0] * m\n        for i in range(n):\n            hash_num[nums[i]].append(i)\n\n        for i in range(m):\n            num = nums[queries[i]]\n            pos_list = hash_num[num]\n            length = len(pos_list)\n            if length == 1:\n                ans[i] = -1\n            else:\n                pos = bisect_left(pos_list, queries[i])\n                if pos == 0:\n                    ans[i] = min(pos_list[1] - pos_list[0], n - pos_list[-1] + pos_list[0])\n                elif pos == length - 1:\n                    ans[i] = min(n - pos_list[length-1] + pos_list[0], pos_list[length-1] - pos_list[length-2])\n                else:\n                    ans[i] = min(pos_list[pos] - pos_list[pos - 1], pos_list[pos+1] - pos_list[pos])\n\n        return ans","author":"skdky","submissionId":"611237025"},[]]},{"1582":[{"id":"1582","fileName":"611237070.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int num = nums[i];\n            map.putIfAbsent(num, new ArrayList<>());\n            map.get(num).add(i);\n        }\n        for (List<Integer> list : map.values()) {\n            Collections.sort(list);\n        }\n        \n        List<Integer> answer = new ArrayList<>();\n        int n = nums.length;\n        \n        for (int q : queries) {\n            int v = nums[q];\n            List<Integer> s = map.get(v);\n            if (s == null || s.size() <= 1) {\n                answer.add(-1);\n                continue;\n            }\n            \n            int i = bisectRight(s, q);\n            int preIndex = i - 1;\n            int pre = -1;\n            // Find predecessor\n            while (preIndex >= 0 && s.get(preIndex) == q) {\n                preIndex--;\n            }\n            if (preIndex >= 0) {\n                pre = s.get(preIndex);\n            } else {\n                preIndex = s.size() - 1;\n                while (preIndex >= 0 && s.get(preIndex) == q) {\n                    preIndex--;\n                }\n                if (preIndex >= 0) {\n                    pre = s.get(preIndex);\n                }\n            }\n            \n            int succIndex = i % s.size();\n            int succ = -1;\n            while (succIndex < s.size() && s.get(succIndex) == q) {\n                succIndex++;\n            }\n            if (succIndex < s.size()) {\n                succ = s.get(succIndex);\n            } else {\n                succIndex = 0;\n                while (succIndex < s.size() && s.get(succIndex) == q) {\n                    succIndex++;\n                }\n                if (succIndex < s.size()) {\n                    succ = s.get(succIndex);\n                }\n            }\n            \n            int minDist = Integer.MAX_VALUE;\n            if (pre != -1) {\n                int dist = Math.min(Math.abs(pre - q), n - Math.abs(pre - q));\n                minDist = Math.min(minDist, dist);\n            }\n            if (succ != -1) {\n                int dist = Math.min(Math.abs(succ - q), n - Math.abs(succ - q));\n                minDist = Math.min(minDist, dist);\n            }\n            \n            if (minDist == Integer.MAX_VALUE) {\n                answer.add(-1);\n            } else {\n                answer.add(minDist);\n            }\n        }\n        \n        return answer;\n    }\n    \n    private int bisectRight(List<Integer> s, int q) {\n        int left = 0;\n        int right = s.size();\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (s.get(mid) <= q) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n}","author":"Jishen Yin","submissionId":"611237070"},[]]},{"1583":[{"id":"1583","fileName":"611236934.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> mp;\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        int n = nums.size();\n        for(int i=0;i<queries.size();i++){\n            int val = nums[queries[i]], id = queries[i];\n            int len = mp[val].size();\n            if(len == 1){\n                ans.push_back(-1);\n                continue;\n            }\n            auto w = lower_bound(mp[val].begin(),mp[val].end(),id) - mp[val].begin();\n            int p = -1, minn = 1e8;\n            if(w > 0) {\n                int x = mp[val][w-1];\n                if(minn > id - x) minn = id - x, p = x;\n                if(minn > n - (id - x)) minn = n - id + x, p = x;\n            }\n            else{\n                int x = mp[val].back();\n                if(minn > x - id) minn = x - id, p = x;\n                if(minn > n - x + id) minn = n - x + id, p = x;\n            }\n            if(w + 1 < mp[val].size()){\n                int x = mp[val][w+1];\n                if(minn > x - id) minn = x - id, p = x;\n            }\n            else{\n                int x = mp[val].front();\n                if(minn > id -  x) minn = id - x, p = x;\n                if(minn > n - id + x) minn = n - id + x, p = x;\n            }\n            ans.push_back(minn);\n        }\n        return ans;\n    }\n};","author":"bright_ml","submissionId":"611236934"},[]]},{"1584":[{"id":"1584","fileName":"611237162.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, set<int>> mp;\n        for (int i = 0; i < nums.size(); ++i) {\n            auto iter = mp.find(nums[i]);\n            if (iter == mp.end()) {\n                mp[nums[i]] = {i};\n            } else {\n                iter->second.insert(i);\n            }\n        }\n        vector<int> ret;\n        ret.reserve(queries.size());\n        for (auto q : queries) {\n            int n = nums[q];\n            auto iter = mp.find(n);\n            if (iter->second.size() == 1) {\n                ret.push_back(-1);\n                continue;\n            }\n            auto iter_pos = iter->second.find(q);\n            int l, r;\n            if (iter_pos != iter->second.begin()) {\n                --iter_pos;\n                l = *iter_pos;\n                ++iter_pos;\n            } else {\n                l = *(iter->second.rbegin());\n            }\n            int res = abs(q - l);\n            res = min(res, static_cast<int>(nums.size()) - res);\n            ++iter_pos;\n            if (iter_pos != iter->second.end()) {\n                r = *iter_pos;\n            } else {\n                r = *(iter->second.begin());\n            }\n            --iter_pos;\n            int resr = abs(q - r);\n            resr = min(resr, static_cast<int>(nums.size()) - resr);\n            ret.push_back(min(res, resr));\n        }\n        return ret;\n    }\n};","author":"ctong","submissionId":"611237162"},[]]},{"1586":[{"id":"1586","fileName":"611237113.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[]} queries\n * @return {number[]}\n */\nvar solveQueries = function (nums, queries) {\n\n  const mp = new Map()\n\n  for (let i = 0; i < nums.length; i++) {\n    const v = nums[i]\n    if (!mp.has(v)) {\n      mp.set(v, [])\n    }\n    mp.get(v).push(i)\n  }\n  const N = nums.length\n\n  // 找到等于的的索引，左右索引相减\n  const search = (arr, target) => {\n    // 不存在重复元素\n    if (arr.length === 1) return -1\n    let l = 0, r = arr.length - 1\n    const n = arr.length\n    while (l <= r) {\n      const mid = Math.floor((l + r) / 2)\n      if (arr[mid] === target) {\n        // 返回左右距离最近的\n        // const a =  ? arr[mid - 1] : -Infinity\n        // const b = mid + 1 < arr.length ? arr[mid + 1] : Infinity\n        let result = Infinity\n        const a = arr[(mid - 1 + n) % n]\n        const b = arr[(mid + 1 + n) % n]\n        if (a > target) {\n          result = Math.min(result, a - target, target - a + N)\n        } else {\n          result = Math.min(result, target - a, a - target + N)\n        }\n        if (b > target) {\n          result = Math.min(result, b - target, target - b + N)\n        } else {\n          result = Math.min(result, target - b, b - target + N)\n        }\n        return result\n      } else if (arr[mid] > target) {\n        r = mid - 1\n      } else {\n        l = mid + 1\n      }\n    }\n  } \n  \n  const ans = []\n  for (let i = 0; i < queries.length; i++) {\n    const idx = queries[i]\n    const v = nums[idx]\n    const arr = mp.get(v)\n    const result = search(arr, idx)\n    // console.log(idx,v, result)\n    ans.push(result)\n  }\n  return ans\n};\n","author":"lihaoze","submissionId":"611237113"},[]]},{"1587":[{"id":"1587","fileName":"611237173.txt","sourceCode":"public class Solution {\n    public IList<int> SolveQueries(int[] nums, int[] queries) {\n        Dictionary<int, List<int>> dic = new();\n        int n = nums.Length;\n        for(int i =0;i<n;i++)\n        {\n            dic.TryAdd(nums[i], new List<int>());\n            dic[nums[i]].Add(i);\n        }\n        List<int> res = new();\n        int m = queries.Length;\n        for(int i = 0;i< m;i++)\n        {\n            int vId = queries[i];\n            int v = nums[vId];\n            if(dic[v].Count == 1)\n            {\n                res.Add(-1);\n            }\n            else\n            {\n                var list = dic[v]; int lc = list.Count;\n                int l = 0; int r = lc -1;\n                while(l<=r)\n                {\n                    int mid = (l+r)>>>1;\n                    if(list[mid] > vId) r = mid -1;\n                    else if (list[mid] < vId) l = mid + 1;\n                    else\n                    {\n                        l = mid;\n                        break;\n                    }\n                }\n                int id1 = list[(lc+ l -1) % lc];\n                int id2 = list[(l +1) % lc];\n                if(id1 != id2)\n                {\n                    res.Add(Math.Min(Find(vId, id1, n), Find(vId, id2, n)));\n                }\n                else\n                {\n                    res.Add(Find(vId, id1, n));\n                }\n            }\n        }\n\n        return res;\n    }\n    public int Find(int i, int j,int n)\n    {\n        if(i<j)\n        {\n            return Math.Min(j -i , i+ n - j);\n        }\n        else\n        {\n            return Math.Min(i -j, n - i + j);\n        }\n    }\n}","author":"小麦Komugi","submissionId":"611237173"},[]]},{"1588":[{"id":"1588","fileName":"611237178.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        nums += nums\n        dis = []\n        buf = {}\n        \n        for i, j in enumerate(nums):\n            if j in buf:\n                x = i - buf[j]\n                d = min(n-x,x)\n                if d == 0:\n                    d = inf\n                dis[buf[j]] = min(dis[buf[j]], d)\n                dis.append(d)\n            else:\n                dis.append(inf)\n            buf[j] = i\n        for i in range(n):\n            dis[i] = min(dis[i], dis[i+n])\n        ans = []\n        for i in queries:\n            if dis[i] != inf:\n                ans.append(dis[i])\n            else:\n                ans.append(-1)\n        return ans","author":"yyyying","submissionId":"611237178"},[]]},{"1589":[{"id":"1589","fileName":"611237174.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = queries.size();\n        int nn = nums.size();\n        vector<int> ans(n,-1);\n        unordered_map<int,vector<int>> pos;\n        for(int i = 0;i < nums.size();++i)\n            {\n                pos[nums[i]].push_back(i);\n            }\n        for(int i = 0;i < n;++i)\n        {\n            int id = queries[i];\n            if(pos[nums[id]].size() == 1)continue;\n            ans[i] = 1e9;\n            int cur = lower_bound(pos[nums[id]].begin(),pos[nums[id]].end(),id) - pos[nums[id]].begin();\n            if(cur)\n            {\n                int len = id - pos[nums[id]][cur - 1];\n                ans[i] = min(ans[i],min(len,nn - len));\n            }else\n            {\n                int len = -id + pos[nums[id]].back();\n                ans[i] = min(ans[i],min(len,nn - len));\n            }\n            if(cur + 1 < pos[nums[id]].size())\n            {\n                int len = -id + pos[nums[id]][cur + 1];\n                ans[i] = min(ans[i],min(len,nn - len));\n            }else\n            {\n                 int len = id - pos[nums[id]].front();\n                    ans[i] = min(ans[i],min(len,nn - len));\n            }\n        }\n        return ans;\n    } \n};","author":"Camellia_y","submissionId":"611237174"},[]]},{"1590":[{"id":"1590","fileName":"611237199.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        map<int, set<int>> inds;\n        for (int i = 0; i < n; i++) {\n            inds[nums[i]].insert(i);\n        }\n        vector<int> ans;\n        for (int i : queries) {\n            int k = nums[i];\n            if (inds[k].size() <= 1) {\n                ans.push_back(-1);\n                continue ;\n            }\n            auto it = inds[k].lower_bound(i);\n            int a = -1, d = 0, x = 0;\n            if (it != inds[k].begin()) {\n                --it;\n                x = *it;\n            } else {\n                x = *inds[k].rbegin();\n            }\n            d = abs(i - x);\n            a = min(d, n - d);\n\n            \n            it = inds[k].lower_bound(i);\n            ++it;\n            if (it != inds[k].end()) {\n                x = *it;\n            } else {\n                x = *inds[k].begin();\n            }\n            d = abs(i - x);\n            a = min(a, min(d, n - d));\n            ans.push_back(a);\n        }\n        return ans;\n    }\n};","author":"山风土豆","submissionId":"611237199"},[]]},{"1591":[{"id":"1591","fileName":"611237243.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = defaultdict(list)\n        for i, num in enumerate(nums):\n            d[num].append(i)\n        ans = [-1] * len(queries)\n        n = len(nums)\n        for i, j in enumerate(queries):\n            num = nums[j]\n            sq = d[num]\n            if len(sq) == 1:\n                continue\n            k = bisect_left(sq, j)\n            t = n\n            if k < len(sq) - 1:\n                t = sq[k + 1] - sq[k]\n            if k > 0:\n                t = min(t, sq[k] - sq[k - 1])\n            if k == 0:\n                t = min(t, sq[k] + n - sq[-1])\n            if k == len(sq) - 1:\n                t = min(t, sq[0] + n - sq[k])\n            ans[i] = t\n        return ans","author":"王小豆","submissionId":"611237243"},[]]},{"1592":[{"id":"1592","fileName":"611237198.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[]} queries\n * @return {number[]}\n */\nvar solveQueries = function(nums, queries) {\n    const map = {}\n    nums.forEach((v, i) => {\n        if (!map[v]) map[v] = {idx: 0, arr: []}\n        map[v].arr.push(i)\n    })\n    const ans = new Array(queries.length).fill(-1)\n    const ansMap = {}\n    queries.forEach((_v, i) => {\n        ansMap[_v] = i\n    })\n    for (let i = 0; i < nums.length; i += 1) {\n        const v = nums[i]\n        if (ansMap[i] !== undefined) {\n            let dis = Infinity\n            if (map[v].idx > 0) {\n                dis = i - map[v].arr[map[v].idx - 1]\n            } else if (map[v].arr.length > 1) {\n                dis = nums.length - map[v].arr[map[v].arr.length - 1] + map[v].arr[map[v].idx]\n            }\n            if (map[v].idx < map[v].arr.length - 1) {\n                dis = Math.min(dis, map[v].arr[map[v].idx + 1] - i)\n            } else if (map[v].arr.length > 1) {\n                dis = Math.min(dis, nums.length - map[v].arr[map[v].arr.length - 1] + map[v].arr[0])\n            }\n            if (dis !== Infinity) ans[ansMap[i]] = dis\n        }\n        map[v].idx += 1\n    }\n    return ans\n};","author":"capybara","submissionId":"611237198"},[]]},{"1593":[{"id":"1593","fileName":"611237284.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        rec, ans = [-1] * (max(nums) + 1), [-1] * len(nums)\n        for i, num in enumerate(nums):\n            # 前一个相同数的索引值\n            if rec[num] != -1:\n                dis = min(i - rec[num], len(nums) - i + rec[num])\n                ans[i] = dis\n                # 更新前面的ans\n                ans[rec[num]] = dis if ans[rec[num]] == -1 else min(ans[rec[num]], dis)\n            rec[num] = i\n        for i, num in enumerate(nums):\n            # 前一个相同数的索引值\n            if rec[num] != -1 and rec[num] != i:\n                # 只用考虑循环\n                if rec[num] > i:\n                    dis = len(nums) - rec[num] + i\n                # 更新两个ans\n                ans[i] = dis if ans[i] == -1 else min(ans[i], dis)\n                ans[rec[num]] = dis if ans[rec[num]] == -1 else min(ans[rec[num]], dis)\n        re = []\n        for query in queries:\n            re.append(ans[query])\n        return re","author":"海狗","submissionId":"611237284"},[]]},{"1594":[{"id":"1594","fileName":"611237455.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        \n        num_to_idxs = defaultdict(list)\n        for i, num in enumerate(nums):\n            num_to_idxs[num].append(i)\n\n        ans = []\n        for query in queries:\n            tmp = num_to_idxs[nums[query]]\n            m = len(tmp)\n\n            if m == 1:\n                ans.append(-1)\n                continue\n            \n            idx = bisect_left(tmp, query)\n            d = inf\n            d = min(d, abs(query - tmp[(idx - 1 + m) % m]), n - abs(query - tmp[(idx - 1 + m) % m]))\n            d = min(d, abs(tmp[(idx + 1) % m] - query), n - abs(tmp[(idx + 1) % m] - query))\n\n            ans.append(-1 if d == inf else d)\n\n        return ans\n        ","author":"明子","submissionId":"611237455"},[]]},{"1595":[{"id":"1595","fileName":"611237358.txt","sourceCode":"class Solution {\npublic:\n    int find_val(vector<int> &v,int k){\n        int l = 0, r = v.size()-1;\n        while(l<=r){\n            int mid = l + (r-l)/2;\n            if(v[mid] > k){\n                r = mid-1;\n            }else{\n                l = mid+1;\n            }\n        }\n        return r;\n    }\n    \n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int lq = queries.size();\n        vector<int> ans(lq,-1);\n        map<int,vector<int>> m;\n        int len = nums.size();\n        for(int i = 0;i<len;i++){\n            m[nums[i]].push_back(i);\n        }\n        for(int i = 0;i<lq;i++){\n            int val = nums[queries[i]];\n            if(m[val].size() != 1){\n                int idx = find_val(m[val],queries[i]);\n                ans[i] = len - (m[val].back() - m[val].front());\n                if(idx == 0){\n                    ans[i] = min(ans[i],m[val][idx+1] - m[val][idx]);\n                }else if(idx == m[val].size()-1){\n                    ans[i] = min(ans[i],m[val][idx] - m[val][idx-1]);\n                }else{\n                    ans[i] = min(m[val][idx+1] - m[val][idx],m[val][idx] - m[val][idx-1]);\n                }\n            }\n        }\n        return ans;\n    }\n};","author":"pan","submissionId":"611237358"},[]]},{"1596":[{"id":"1596","fileName":"611237423.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        mp = defaultdict(list)\n        for i, v in enumerate(nums):\n            mp[v].append(i)\n        n, m = len(nums), len(queries)\n        ans = [-1] * m\n        for i in range(m):\n            q = nums[queries[i]]\n            if len(mp[q]) <= 1:\n                continue\n            pos = bisect.bisect_right(mp[q], queries[i])\n            if pos == len(mp[q]):\n                ans[i] = min(queries[i] - mp[q][-2], mp[q][0] + n - queries[i])\n            elif pos == 1:\n                ans[i] = min(mp[q][pos] - queries[i], n - mp[q][-1] + queries[i])\n            else:\n                ans[i] = min(mp[q][pos] - queries[i], queries[i] - mp[q][pos - 2])\n        return ans\n","author":"OverclockedIvan","submissionId":"611237423"},[]]},{"1600":[{"id":"1600","fileName":"611237545.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n\ttype Pair struct{ idx, q int }\n\tpairs := make([]Pair, 0)\n\tret := make([]int, len(queries))\n\tfor i := 0; i < len(ret); i++ {\n\t\tret[i] = -1\n\t}\n\tfor i, q := range queries {\n\t\tpairs = append(pairs, Pair{i, q})\n\t}\n\tsort.Slice(pairs, func(i, j int) bool {\n\t\treturn pairs[i].q < pairs[j].q\n\t})\n\tmp := map[int]int{}\n\tmp1 := map[int]int{}\n\tqi := 0\n\tfor i, num := range nums {\n\t\tif pairs[qi].q == i {\n\t\t\t// fmt.Println(pairs[qi], i, mp, num)\n\t\t\tif v, ok := mp[num]; ok {\n\t\t\t\tret[pairs[qi].idx] = min(Dis(v, i, len(nums)), Dis(mp1[num], i, len(nums)))\n\t\t\t}\n\t\t\tqi++\n\t\t}\n\t\tif qi == len(pairs) {\n\t\t\tbreak\n\t\t}\n\t\tmp[num] = i\n\t\tif _, ok := mp1[num]; !ok {\n\t\t\tmp1[num] = i\n\t\t}\n\t}\n\tmp = map[int]int{}\n\tmp1 = map[int]int{}\n\tqi = len(pairs) - 1\n\tfor i := len(nums) - 1; i >= 0; i-- {\n\t\tnum := nums[i]\n\t\tif pairs[qi].q == i {\n\t\t\tif v, ok := mp[num]; ok {\n\t\t\t\tif ret[pairs[qi].idx] == -1 {\n\t\t\t\t\tret[pairs[qi].idx] = min(Dis(v, i, len(nums)), Dis(mp1[num], i, len(nums)))\n\t\t\t\t} else {\n\t\t\t\t\tret[pairs[qi].idx] = min(min(Dis(v, i, len(nums)), Dis(mp1[num], i, len(nums))), ret[pairs[qi].idx])\n\t\t\t\t}\n\t\t\t}\n\t\t\tqi--\n\t\t}\n\t\tif qi < 0 {\n\t\t\tbreak\n\t\t}\n\t\tmp[num] = i\n\t\tif _, ok := mp1[num]; !ok {\n\t\t\tmp1[num] = i\n\t\t}\n\t}\n\treturn ret\n}\n\nfunc Dis(i, j, n int) int {\n\tif i < j {\n\t\ti, j = j, i\n\t}\n\treturn min(i-j, j-i+n)\n}","author":"慎微","submissionId":"611237545"},[]]},{"1601":[{"id":"1601","fileName":"611237583.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        pre = [inf] * n\n        d = {}\n        t = {}\n        for i in range(n):\n            if t.get(nums[i], -1) == -1:\n                t[nums[i]] = i\n            if d.get(nums[i], -1) >= 0:\n                pre[d[nums[i]]] = min(pre[d[nums[i]]], i - d[nums[i]])\n                pre[i] = min(i - d[nums[i]], n - (i - t[nums[i]]))\n                pre[t[nums[i]]]=min(pre[t[nums[i]]],n - (i - t[nums[i]]))\n            d[nums[i]] = i\n        res = []\n        for i in queries:\n            res.append(pre[i] if not isinf(pre[i]) else -1)\n        return res","author":"刘鑫","submissionId":"611237583"},[]]},{"1604":[{"id":"1604","fileName":"611237806.txt","sourceCode":"/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint id[1000010] ;\nint fst[1000010] ;\nint ed[1000010] ;\n\nconst int inf = 1e9 + 10 ;\nint min(int a , int b) {\n    if(a < b) return a ;\n    return b ; \n}\nint* solveQueries(int* nums, int n, int* queries, int m, int* returnSize) {\n    int* pre = (int*)malloc(sizeof(int) * (n + 10)) ;\n    int* lst = (int*)malloc(sizeof(int) * (n + 10)) ;\n    for(int i = 0 ; i < n ; i ++){\n        if(id[nums[i]]){\n            pre[i] = id[nums[i]] - 1 ; \n        }else {\n            pre[i] = -inf ; \n        }\n        id[nums[i]] = i + 1 ;\n        ed[nums[i]] = i ; \n    }\n    for(int i = 0 ; i < n ; i ++){\n        id[nums[i]] = 0 ; \n    }\n    for(int i = n - 1 ; i >= 0 ; i --){\n        if(id[nums[i]]){\n            lst[i] = id[nums[i]] - 1 ; \n        }else {\n            lst[i] = inf ; \n        }\n        id[nums[i]] = i + 1 ;\n        fst[nums[i]] = i ; \n    }\n    for(int i = 0 ; i < n ; i ++){\n        id[nums[i]] = 0 ; \n    }\n    int* ans = (int*)malloc(sizeof(int) * m) ;\n    for(int i = 0 ; i < m ; i ++){\n        int t = queries[i] ;\n        ans[i] = inf ; \n        if(t - pre[t] < 1000000) ans[i] = min(ans[i] , min(t - pre[t] , n - t + pre[t])) ;\n        if(lst[t] - t < 1000000) ans[i] = min(ans[i] , min(lst[t] - t , n - lst[t] + t)) ;\n        // printf(\"%d %dn\" , fst[t] , ed[t]) ;\n        // t = nums[t] ; \n        if(fst[nums[t]] != t){\n            int r = fabs(t - fst[nums[t]]) ;\n            ans[i] = min(ans[i] , min(r , n - r)) ;\n        }\n        if(ed[nums[t]] != t){\n            int r = fabs(t - ed[nums[t]]) ;\n            ans[i] = min(ans[i] , min(r , n - r)) ;\n        }\n        // ans[i] = min(t - pre[t] , lst[t] - t) ; \n        // printf(\"%d %d %dn\" , t - pre[t] , lst[t] - t , ans) ;\n        if(ans[i] > 1000000) ans[i] = -1; \n    }\n    for(int i = 0 ; i < n ; i ++){\n        fst[nums[i]] = ed[nums[i]] = 0 ; \n    }\n    *returnSize = m ; \n    return ans ; \n}","author":"罚时大师月色","submissionId":"611237806"},[]]},{"1605":[{"id":"1605","fileName":"611237739.txt","sourceCode":"\n#ifdef USACO_LOCAL_JUDGE\n#include <bits/stdc++.h>\n\n#include \"base.h\"\nusing namespace std;\n#endif\n\nint debug = 1;\n#define MyPrintf(...)               \n  do {                              \n    if (debug) printf(__VA_ARGS__); \n  } while (0)\n\n#define MyDebug(...) fprintf(stderr, __VA_ARGS__);\n\ntypedef long long ll;\nclass Solution {\n public:\n  vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n    int n = nums.size();\n    unordered_map<int, vector<int>> group;\n    for (int i = 0; i < n; i++) {\n      group[nums[i]].push_back(i);\n    }\n\n    auto Dis = [n](int a, int b) {  //\n      if (a < b) swap(a, b);\n      return min(abs(a - b), abs(b + n - a));\n    };\n\n    int m = queries.size();\n    vector<int> ans(m, -1);\n    for (int i = 0; i < m; i++) {\n      int j = queries[i];\n      int v = nums[j];\n      const auto& vec = group[v];\n      int len = vec.size();\n      // printf(\"i=%d j=%d v=%d len=%dn\", i, j, v, len);\n      if (len == 1) {\n        continue;\n      }\n\n      auto it = lower_bound(vec.begin(), vec.end(), j);\n      ans[i] = INT_MAX;\n\n      auto nextIt = it;\n      nextIt++;\n      if (nextIt != vec.end()) {  // 下一个\n        ans[i] = min(ans[i], Dis(j, *nextIt));\n      } else {\n        ans[i] = min(ans[i], Dis(j, vec.front()));\n      }\n\n      if (it != vec.begin()) {  // 上一个\n        auto preIt = it;\n        preIt--;\n        ans[i] = min(ans[i], Dis(j, *preIt));\n      } else {\n        ans[i] = min(ans[i], Dis(j, vec.back()));\n      }\n    }\n\n    return ans;\n  }\n};\n\n#ifdef USACO_LOCAL_JUDGE\n\nint main() {  //\n  return 0;\n}\n\n#endif","author":"tiankonguse-天空柚子","submissionId":"611237739"},[]]},{"1606":[{"id":"1606","fileName":"611237678.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n\n    private int cal(int a, int b, int n) {\n        return Math.min(Math.abs(a - b), n - Math.abs(a - b));\n    }\n\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> pos = new HashMap<>();\n        for (int i = 0;i < nums.length;i++) {\n            int x = nums[i];\n            if (!pos.containsKey(x)) {\n                pos.put(x, new ArrayList<>());\n            }\n            pos.get(x).add(i);\n        }\n\n        List<Integer> ret = new ArrayList<>();\n\n        for (int query: queries) {\n            int x = nums[query];\n            List<Integer> posList = pos.get(x);\n            int index = Collections.binarySearch(posList, query);\n            int minDist = Integer.MAX_VALUE;\n            if (posList.size() == 0 || posList.size() == 1) {\n                minDist = -1;\n            } else {\n                minDist = Math.min(minDist, cal(posList.get(index), posList.get((index - 1 + posList.size()) % posList.size()), nums.length));\n                minDist = Math.min(minDist, cal(posList.get((index + 1) % posList.size()), posList.get(index), nums.length));\n                if (minDist == Integer.MAX_VALUE) {\n                    minDist = -1;\n                }\n            }\n            ret.add(minDist);\n        }\n\n        return ret;\n    }\n}","author":"小白二号","submissionId":"611237678"},[]]},{"1607":[{"id":"1607","fileName":"611237654.txt","sourceCode":"struct cmp {\n    bool operator()(pair<int, int>& a, pair<int, int>& b) {\n        return a.first < b.first;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<int> ans(m, -1);\n        unordered_map<int, int> left;\n        unordered_map<int, int> left2;\n        unordered_map<int, int> right;\n        unordered_map<int, int> right2;\n        vector<pair<int,int>> q;\n        for(int i = 0; i < m; i++) {\n            q.push_back(make_pair(queries[i], i));\n        }\n        sort(q.begin(), q.end(), cmp());\n        int idx = 0;\n        for(int i = 0; i < m; i++) {\n            int query = q[i].first;\n            int pos = q[i].second;\n            // cout << query << \" \" << pos << endl;\n            while(idx < query) {\n                left[nums[idx]] = idx;\n                if(!left2.count(nums[idx])) left2[nums[idx]] = idx;\n                idx++;\n            }\n            if(left.count(nums[query])){\n                ans[pos] = min(abs(query - left[nums[query]]), abs(n - abs(query - left2[nums[query]])));\n                // cout << query << \" \" << left[nums[query]] << \" \" <<  ans[pos] << endl;\n            }\n        }\n        idx = n - 1;\n        for(int i = m - 1; i >= 0; i--) {\n            int query = q[i].first;\n            int pos = q[i].second;\n            while(idx > query) {\n                right[nums[idx]] = idx;\n                if(!right2.count(nums[idx])) right2[nums[idx]] = idx;\n                idx--;\n            }\n            if(right.count(nums[query])) {\n                int k = min(abs(query - right[nums[query]]), abs(n - abs(query - right2[nums[query]])));\n                if(ans[pos] == -1) ans[pos] = k;\n                else ans[pos] = min(ans[pos], k);\n            }\n        }\n        return ans;\n    }\n};","author":"Zeet","submissionId":"611237654"},[]]},{"1608":[{"id":"1608","fileName":"611237883.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\n#define x first\n#define y second\n#define pb push_back\n#define eb emplace_back\n#define v vector\n#define printv(a, x) for (int i = x; i < a.size(); i ++ ) \n                      cout << a[i] << \" n\"[i == (int)a.size() - 1]\n#define printvv(a, x) for (int i = x; i < a.size(); i ++ ) \n                      for (int j = x; j < a[i].size(); j ++ ) \n                        cout << a[i][j] << \" n\"[j == (int)a[i].size() - 1]\n#define all(x) (x).begin(), (x).end()\n#define readv(a, n, x) for (int i = x; i < n + x; i ++ ) \n                          cin >> a[i]\n#define readvv(a, n, m, x) for (int i = x; i < n + x; i ++ ) \n                            for (int j = x; j < m + x; j ++ ) \n                              cin >> a[i][j]\n#define gt greater\n#define pq priority_queue\n#define umap unordered_map\n#define uset unordered_set\n#define lbound(a, l, r, x) lower_bound(a.begin() + l, a.begin() + r + 1, x) - a.begin()\n#define ubound(a, l, r, x) upper_bound(a.begin() + l, a.begin() + r + 1, x) - a.begin()\ntemplate <typename T>\nvoid base_dbg(const std::string& key, const T& value) {\n  std::cerr << key << \" = \" << value;\n}\ntemplate <typename... Args>\nvoid dbg_args(const std::string& keys, Args... args) {\n  size_t pos{ 0 }; ((base_dbg(keys.substr(pos, keys.find(',', pos) - pos), args),\n                     pos = keys.find(',', pos) + 1), ...);\n}\n#define dbg(...) { \n    std::cerr << \"\"; \n    dbg_args(#__VA_ARGS__, __VA_ARGS__); \n    std::cerr << 'n'; \n}\ntemplate <typename T>\nvoid base_print(const T& value) {\n  std::cout << value << ' ';\n}\ntemplate <typename... Args>\nvoid print_args(Args... args) {\n  size_t pos{ 0 }; ((base_print(args)), ...);\n}\n#define print(...) { \n    std::cout << \"\"; \n    print_args(__VA_ARGS__); \n    std::cout << 'n'; \n}\n\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef __int128 i128;\ntypedef pair<int, int> pII;\ntypedef tuple<int, int, int> pIII;\n\nstd::mt19937 rnd(std::chrono::steady_clock().now().time_since_epoch().count());\n\nconst int N = 2e5 + 10, M = 1e6 + 10, mod7 = 1e9 + 7, mod9 = 998244353,\n          inf = 2e9, base = 131;\nint t, n, m, q, k, p;\nint dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};\n\nstruct PII {\n  int x, y, z;\n  bool operator< (const PII &tmp) const {\n    return x < tmp.x;\n  }\n};\n\nclass Solution {\npublic:\n  vector<int> solveQueries(vector<int>& a, vector<int>& b) {\n    int n = a.size(), m = b.size();\n    umap<int, v<int>> p;\n    for (int i = 0; i < n; i ++ )\n      p[a[i]].pb(i);\n    v<int> res;\n    for (int i = 0; i < m; i ++ ) {\n      int w = a[b[i]];\n      int ans = inf;\n      int pos1 = ubound(p[w], 0, p[w].size() - 1, b[i]);\n      int pos2 = lbound(p[w], 0, p[w].size() - 1, b[i]) - 1;\n      if (pos1 >= 0 && pos1 < p[w].size()) {\n        ans = min(ans, p[w][pos1] - b[i]);\n        ans = min(ans, b[i] + n - p[w][pos1]);\n      }\n      if (pos2 >= 0) {\n        ans = min(ans, b[i] - p[w][pos2]);\n        ans = min(ans, p[w][pos2] + n - b[i]);\n      }\n      if (p[w].size() > 1) {\n        if (p[w][0] != b[i])\n          ans = min(ans, p[w][0] + n - b[i]);\n        if (p[w][p[w].size() - 1] != b[i])\n          ans = min(ans, b[i] + n - p[w][p[w].size() - 1]);\n      }\n\n      if (ans == inf) ans = -1;\n      res.pb(ans);\n    }\n    return res;\n  }\n};","author":"一枕眠秋雨","submissionId":"611237883"},[]]},{"1609":[{"id":"1609","fileName":"611237848.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size(),val1,val2;\n        unordered_map<int,vector<int>> rec;\n        vector<int> res;\n        for (int i=0; i<n; i++)\n            rec[nums[i]].push_back(i);\n        for (int &i:queries){\n            int m=rec[nums[i]].size();\n            if (m==1)\n                res.push_back(-1);\n            else{\n                int p=lower_bound(rec[nums[i]].begin(),rec[nums[i]].end(),i)-rec[nums[i]].begin();\n                if (p==m-1){\n                    val1=n-rec[nums[i]][p]+rec[nums[i]][0];\n                    val2=rec[nums[i]][p]-rec[nums[i]][p-1];\n                }\n                else if (!p){\n                    val1=n-rec[nums[i]][m-1]+rec[nums[i]][0];\n                    val2=rec[nums[i]][p+1]-rec[nums[i]][p];\n                }\n                else{\n                    val1=rec[nums[i]][p]-rec[nums[i]][p-1];\n                    val2=rec[nums[i]][p+1]-rec[nums[i]][p];\n                }\n                res.push_back(min(val1,val2));\n            }\n        }\n        return res;\n    }\n};","author":"Demon3","submissionId":"611237848"},[]]},{"1610":[{"id":"1610","fileName":"611237941.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n\tpreMp := make(map[int]int)\n\tvec := make([]int, len(nums))\n\tn := len(nums)\n\tnums = append(nums, nums[:len(nums)/2+1]...)\n\tfor i, v := range nums {\n\t\tif i < n {\n\t\t\tvec[i] = math.MaxInt32\n\t\t}\n\t\tif _, ok := preMp[v]; !ok {\n\t\t\tpreMp[v] = i\n\t\t} else {\n\t\t\tif preMp[v] != i%n {\n\t\t\t\tdif := i - preMp[v]\n\t\t\t\tdif = min(dif, len(nums)-dif)\n\t\t\t\tvec[preMp[v]%n] = min(vec[preMp[v]%n], dif)\n\t\t\t\tvec[i%n] = min(dif, vec[i%n])\n\t\t\t\tpreMp[v] = i\n\t\t\t}\n\t\t}\n\t}\n\tans := []int{}\n\tfor _, v := range queries {\n\t\tif vec[v] == math.MaxInt32 {\n\t\t\tans = append(ans, -1)\n\t\t} else {\n\t\t\tans = append(ans, vec[v])\n\t\t}\n\n\t}\n\treturn ans\n}","author":"北歌","submissionId":"611237941"},[]]},{"1611":[{"id":"1611","fileName":"611238002.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, List<Integer>> map = new HashMap<Integer, List<Integer>>();\n        for(int i=0;i<nums.length;i++){\n            List<Integer> idxs= map.computeIfAbsent(nums[i], key -> new ArrayList<>());\n            idxs.add(i);\n        }\n        List<Integer> list = new ArrayList<>();\n        int n=nums.length;\n        for(int i=0;i<queries.length;i++){\n            List<Integer> idxs = map.get(nums[queries[i]]);\n            if(idxs.size()==1){\n                list.add(-1);\n                continue;\n            }\n            int pos = Collections.binarySearch(idxs, queries[i]);\n            int d1=Math.abs(idxs.get((pos+1)%idxs.size())-idxs.get(pos));\n            int d2=Math.abs(idxs.get(((pos-1)%idxs.size()+idxs.size())%idxs.size())-idxs.get(pos));\n            int temp=Math.min(\n              Math.min(d1,n-d1),\n              Math.min(d2,n-d2)\n            );\n            list.add(temp);\n        }\n        return list;\n    }\n}","author":"辛世纪","submissionId":"611238002"},[]]},{"1612":[{"id":"1612","fileName":"611238013.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        from bisect import bisect_left\n        idx = defaultdict(list)\n        for i, x in enumerate(nums):\n            idx[x].append(i)\n        ans = [-1] * len(queries)\n        for k, q in enumerate(queries):\n            x = nums[q]\n            if len(idx[x]) == 1:\n                continue\n            i = bisect_left(idx[x], q)\n            left = (len(idx[x]) - 1) if i == 0 else (i - 1) \n            right = 0 if i == len(idx[x]) - 1 else (i + 1)\n            dis1 = min(abs(idx[x][left] - q), len(nums) - abs(idx[x][left] - q))\n            dis2 = min(abs(idx[x][right] - q), len(nums) - abs(idx[x][right] - q))\n            if dis1 <= dis2:\n                ans[k] = dis1\n            else:\n                ans[k] = dis2\n        return ans","author":"江上闲人","submissionId":"611238013"},[]]},{"1613":[{"id":"1613","fileName":"611238021.txt","sourceCode":"class Solution {\npublic:\n    int p[100010];\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        unordered_map<int, int> map, first;\n        int n = nums.size(), m = q.size();\n        for (int i = 0; i < n; i++) p[i] = 1e6;\n        \n        for (int i = 0; i < n; i++) {\n            if (map.find(nums[i]) != map.end()) {\n                int pre = map[nums[i]];\n                p[i] = min(p[i], i - pre);\n                p[pre] = min(p[pre], i - pre);\n            }\n            else {\n                first[nums[i]] = i;\n            }\n            map[nums[i]] = i;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if (i != map[nums[i]]) p[i] = min(p[i], n - map[nums[i]] + i);\n            if (i != first[nums[i]]) p[i] = min(p[i], n - i + first[nums[i]]);\n        }\n        \n        vector<int> ans;\n        for (int i = 0; i < m; i++) {\n            int v = p[q[i]];\n            if (v == 1e6) ans.emplace_back(-1);\n            else ans.emplace_back(v);\n        }\n        return ans;\n    }\n};","author":"tkw","submissionId":"611238021"},[]]},{"1614":[{"id":"1614","fileName":"611238028.txt","sourceCode":"class Solution {\npublic:\n    int distance(int n, int x, int y){\n        int t = abs(x-y);\n        return t <= (n>>1)? t : n-t;\n    }\n    \n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>> m;\n        int n = nums.size();\n        for(int i=0;i<n;i++){\n            m[nums[i]].emplace_back(i);\n        }\n        \n        vector<int> ans;\n        \n        for(int &i : queries){\n            auto &v = m[nums[i]];\n            int it = ranges::lower_bound(v, i) - v.begin();\n            int t = -1;\n            int pre = (it==0)? (v.size()-1):(it-1);\n            int suc = (it == v.size()-1) ? 0:(it+1);\n            if(v.size() > 1){\n                t = min(distance(n, v[pre], v[it]), distance(n, v[it], v[suc]));\n            }\n            ans.emplace_back(t);\n        }\n        return ans;\n    }\n};","author":"阿白","submissionId":"611238028"},[]]},{"1615":[{"id":"1615","fileName":"611237899.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,int> hash;\n        unordered_map<int,int> minHash;\n        vector<int> minLen(nums.size(),INT_MAX);\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            if(hash.find(nums[i])==hash.end()){\n                minHash[nums[i]]=i;\n            }else{\n                int firstI= minHash[nums[i]];\n                minLen[firstI] = min({minLen[firstI],i-firstI,n-(i-firstI)});\n                int minL=min({minLen[i],i-hash[nums[i]]});\n                minLen[i]=min({minLen[i],minL,n-(i-firstI)});\n                minLen[hash[nums[i]]]=min(minLen[hash[nums[i]]],minL);\n            }\n            hash[nums[i]]=i;\n        }\n        \n        for(int i=0;i<queries.size();i++){\n            queries[i]=((minLen[queries[i]]==INT_MAX)?-1:minLen[queries[i]]);\n        }\n        return queries;\n    }\n};","author":"SkyLimit","submissionId":"611237899"},[]]},{"1616":[{"id":"1616","fileName":"611238056.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mymap;\n        for (int i = 0; i < nums.size(); ++i) {\n            mymap[nums[i]].push_back(i);\n        }\n        int m = nums.size();\n        vector<int> ans;\n        for (auto& query : queries) {\n            int x = nums[query];\n            if (mymap[x].size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            auto iter = lower_bound(mymap[x].begin(), mymap[x].end(), query);\n            int tmp;\n            if (iter != mymap[x].begin()) {\n                tmp = query - *(iter - 1);\n            }\n            else {\n                tmp = query + m - mymap[x].back();\n            }\n            if (iter + 1 != mymap[x].end()) {\n                tmp = min(tmp, *(iter + 1) - query);\n            }\n            else {\n                tmp = min(tmp, mymap[x][0] + m - query);\n            }\n            ans.push_back(tmp);\n        }\n        return ans;\n    }\n\n};","author":"ddmike","submissionId":"611238056"},[]]},{"1617":[{"id":"1617","fileName":"611238054.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> idxs;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            idxs[nums[i]].push_back(i);\n        }\n        int m = queries.size();\n        vector<int> ans(m);\n        for (int i = 0; i < m; i++) {\n            int j = queries[i];\n            int v = nums[j];\n            if (idxs[v].size() == 1)\n                ans[i] = -1;\n            else {\n                auto& vec = idxs[v];\n                auto it = upper_bound(vec.begin(), vec.end(), j);\n                int dis = INT_MAX;\n                if (it != vec.end()) {\n                    dis = *it - j;\n                    dis = min(dis, n-dis);\n                } else if (vec[0] != j) {\n                    dis = min(j - vec[0], n - j + vec[0]);\n                }\n                auto it2 = lower_bound(vec.begin(), vec.end(), j);\n                if (it2 != vec.begin()) {\n                    int dis2 = j - *(--it2);\n                    dis2 = min(dis2, n - dis2);\n                    dis = min(dis, dis2);\n                } else if (vec.back() != j) {\n                    int dis2 = min(vec.back() - j, n - vec.back() + j);\n                    dis = min(dis2, dis);\n                }\n                ans[i] = dis;\n            }\n        }\n        return ans;\n    }\n};","author":"umiGen","submissionId":"611238054"},[]]},{"1618":[{"id":"1618","fileName":"611238078.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> val2indexs;\n        const int n = nums.size();\n        const int m = queries.size();\n        for(int i = 0; i < n; i ++ ) {\n            const int& num = nums[i];\n            val2indexs[num].push_back(i);\n        }\n        vector<int> ans(m, -1);\n        for(int i = 0; i < m; i ++ ) {\n            const int& q = queries[i];\n            const vector<int>& indexs = val2indexs[nums[q]];\n            if(indexs.size() == 1) {\n                continue;\n            }\n            const int pos = lower_bound(indexs.begin(), indexs.end(), q) - indexs.begin();\n            const int len = indexs.size();\n\n            // cout << i << \" \" << pos << \" \" << indexs[0] << endl;\n            int right = abs(q - indexs[(pos + 1) % len]);\n            int left = abs(q - indexs[(pos - 1 + len) % len]);\n            ans[i] = min(\n                min(right, n - right),\n                min(left, n - left)\n            );\n        }\n\n        return ans;\n    }\n};","author":"latstars","submissionId":"611238078"},[]]},{"1619":[{"id":"1619","fileName":"611238182.txt","sourceCode":"class Solution {\npublic:\nvector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n    unordered_map<int, vector<int>>h;\n    for(int i=0;i<nums.size();++i){\n        h[nums[i]].push_back(i);\n    }\n    vector<int>res;\n    int len=nums.size();\n    for(auto v:queries){\n        vector<int>&tmp=h[nums[v]];\n        if(tmp.size()<=1){\n            res.push_back(-1);\n        }else{\n            int t=INT_MAX;\n            int index=lower_bound(tmp.begin(), tmp.end(), v)-tmp.begin();\n            if(index!=0){\n                t=min(t,abs(v-tmp[index-1]));\n            }\n            if(index<tmp.size()-1){\n                t=min(t,abs(v-tmp[index+1]));\n            }\n            if(index==tmp.size()-1){\n                t=min(t,abs(len-v+tmp[0]));\n            }\n            if(index==0){\n                t=min(t,abs(len-tmp.back()+tmp[index]));\n            }\n            res.push_back(t);\n        }\n    }\n    return res;\n}\n\n};","author":"light","submissionId":"611238182"},[]]},{"1620":[{"id":"1620","fileName":"611238191.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, set<int>> index;\n        for (int i = 0; i < nums.size(); ++i) {\n            index[nums[i]].emplace(i);\n        }\n        vector<int> ans (queries.size());\n        for (int i = 0; i < queries.size(); ++i) {\n            auto num = nums[queries[i]];\n            if (index[nums[queries[i]]].size() == 1) {\n                ans[i] = -1;\n                continue;\n            }\n            auto iter = index[nums[queries[i]]].find(queries[i]);\n            if (iter == index[nums[queries[i]]].end()) {\n                ans[i] = -1;\n                continue;\n            }\n            auto preIter = iter;\n            int preIdx = 0;\n            if (iter == index[nums[queries[i]]].begin()) {\n                preIter = index[nums[queries[i]]].end();\n                --preIter;\n                preIdx = *preIter - nums.size();\n            } else {\n                --preIter;\n                preIdx = *preIter;\n            }\n\n            auto nextIter = iter;\n            int nextIdx = 0;\n            ++nextIter;\n\n            if (nextIter == index[nums[queries[i]]].end()) {\n                nextIter = index[nums[queries[i]]].begin();\n                nextIdx = *nextIter + nums.size();\n            } else {\n                nextIdx = *nextIter;\n            }\n            // std::cout << preIdx << \" \" << i << \" \" << nextIdx << std::endl;\n            ans[i] = min(queries[i] - preIdx, nextIdx - queries[i]);\n        }\n        return ans;\n    }\n};","author":"C_Learner","submissionId":"611238191"},[]]},{"1621":[{"id":"1621","fileName":"611238134.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        pos = {}\n        orin = len(nums)\n        nwnums = nums + nums\n        n = len(nwnums)\n        nxt = [n] * n\n        lst = [-1] * n\n        for i , num in enumerate(nwnums):\n            if num in pos:\n                lst[i] = pos[num]\n            pos[num] = i\n\n        for i in range(n):\n            if(lst[i] != -1):\n                nxt[lst[i]] = i\n        ans = []\n        for item in queries:\n            if item < orin // 2:\n                item += orin\n            ans1 = -1 if lst[item] == -1 else item - lst[item]\n            ans2 = -1 if nxt[item] == n else nxt[item] - item\n            if (ans1 == -1 or ans1 >= n // 2) and (ans2 == -1 or ans2 >= n // 2):\n                ans.append(-1)\n            elif (ans1 == -1 or ans1 >= n // 2):\n                ans.append(ans2)\n            elif (ans2 == -1 or ans2 >= n // 2):\n                ans.append(ans1)\n            else:\n                ans.append(min(ans1,ans2))\n        return ans","author":"伏波落木","submissionId":"611238134"},[]]},{"1622":[{"id":"1622","fileName":"611238317.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n=len(nums)\n        numIndex={}\n        ans=[float('inf') for i in range(n)]\n        for i in range(n):\n            if nums[i] not in numIndex:\n                numIndex[nums[i]]=[i]\n            else:\n                ans[i]=min([ans[i],n-(i-numIndex[nums[i]][0]),i-numIndex[nums[i]][-1]])\n                ans[numIndex[nums[i]][0]]=min(n-(i-numIndex[nums[i]][0]),ans[numIndex[nums[i]][0]])\n                ans[numIndex[nums[i]][-1]]=min(i-numIndex[nums[i]][-1],ans[numIndex[nums[i]][-1]])\n                numIndex[nums[i]].append(i)\n        for i in range(len(queries)):\n            if ans[queries[i]]==float('inf'):\n                queries[i]=-1\n            else:\n                queries[i]=ans[queries[i]]\n        return queries","author":"不要名字","submissionId":"611238317"},[]]},{"1623":[{"id":"1623","fileName":"611238213.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        nums = nums+nums\n        n = len(nums)\n        r = [0]*n\n        index = defaultdict(lambda: -1)\n        for i, num in enumerate(nums):\n            if index[num] == -1:\n                r[i] = -1\n            else:\n                r[i] = i-index[num]\n                if r[index[num]] != -1:\n                    r[index[num]] = min(r[index[num]], r[i])\n                else:\n                    r[index[num]] = r[i]\n            index[num] = i\n        ans = [0]*(len(queries))\n        for i in range(len(queries)):\n            if r[queries[i]] == n//2:\n                ans[i] = -1\n            else:\n                ans[i] = min(r[queries[i]], r[queries[i]+n//2])\n        return ans\n            ","author":"flower","submissionId":"611238213"},[]]},{"1624":[{"id":"1624","fileName":"611238287.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& A, vector<int>& queries) {\n        const int inf = 1e9;\n        \n        map <int,vector<int>> mps;\n        int n = A.size();\n        for (int i = 0; i < n; ++ i){\n            mps[A[i]].push_back(i);\n        }\n        for (int i = 0; i < n; ++ i){\n            mps[A[i]].push_back(i+n);\n        }\n        for (int i = 0; i < n; ++ i){\n            mps[A[i]].push_back(i+2*n);\n        }\n\n        vector <int> ans;\n        for (auto &i : queries){\n            auto &vec = mps[A[i]];\n            i += n;\n            if (vec.size() == 3){\n                ans.push_back(-1);\n                continue;\n            }\n            int j = upper_bound(vec.begin(), vec.end(), i) - vec.begin();\n            int x = -inf, y = inf;\n            if (j != vec.size()) y = vec[j];\n            if (j-2 >= 0) x = vec[j-2];\n            \n            if (i-x <= y-i) ans.push_back(i-x);\n            else ans.push_back(y-i);\n        }\n\n        return ans;\n    }\n};","author":"lambour","submissionId":"611238287"},[]]},{"1625":[{"id":"1625","fileName":"611238201.txt","sourceCode":"#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<string> VS;\ntypedef vector<vector<string>> VVS;\ntypedef vector<bool> VB;\ntypedef vector<vector<bool>> VVB;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntemplate <class T>\nusing pq = priority_queue<T>;\ntemplate <class T>\nusing pqg = priority_queue<T, vector<T>, greater<T>>;\n\nconst int INF = 0x3f3f3f3f, MOD = 1e9 + 7, MOD1 = 998'244'353;\nconst ll INFL = 0x3f3f3f3f'3f3f3f3f;\nconst double eps = 1e-8;\nconst int dir[8][2] = {\n    {0, 1}, {0, -1}, {1, 0}, {-1, 0}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1},\n};\nmt19937_64 _m_gen64;\n\nconst ull Pr = 131, Pr1 = 13331;\n\n#define For(i, a, b) for (int i = int(a); i < int(b); ++i)\n#define Rof(i, a, b) for (int i = int(b) - 1; i >= int(a); --i)\n#define For1(i, a, b) for (int i = int(a); i <= int(b); ++i)\n#define Rof1(i, a, b) for (int i = int(b); i >= int(a); --i)\n#define ForE(i, j) for (int i = h[j]; i != -1; i = ne[i])\n\n#define f1 first\n#define f2 second\n#define pb push_back\n#define has(a, x) (a.find(x) != a.end())\n#define nemp(a) (!a.empty())\n#define all(a) (a).begin(), (a).end()\n#define all1(a, len) (a + 1), (a + 1 + len)\n#define SZ(a) int((a).size())\n#define NL cout << 'n';\n\ntemplate <class T>\nbool ckmin(T &a, const T &b) {\n  return b < a ? a = b, 1 : 0;\n}\ntemplate <class T>\nbool ckmax(T &a, const T &b) {\n  return a < b ? a = b, 1 : 0;\n}\n\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &a) {\n  int n = int(a.size()) - 1;\n  for (int i = 1; i <= n; ++i) {\n    os << a[i] << \" n\"[i == n];\n  }\n  return os;\n}\n\ntemplate <class T>\nistream &operator>>(istream &is, vector<T> &a) {\n  int n = int(a.size()) - 1;\n  for (int i = 1; i <= n; ++i) {\n    is >> a[i];\n  }\n  return is;\n}\n\n#ifdef _DEBUG\n#include \"debug.h\"\n#else\n#define dbg(x...)\n#define dbgi(x)\n#define dbgln()\n#define dbgr(x...)\n#endif\n\n// For LeetCode\n#define LN ListNode\n#define LNP ListNode *\n#define TN TreeNode\n#define TNP TreeNode *\n\n#ifdef _DEBUG\nstruct ListNode {\n  int val;\n  ListNode *next;\n  ListNode() : val(0), next(nullptr) {}\n  ListNode(int val) : val(val), next(nullptr) {}\n  ListNode(int val, ListNode *next) : val(val), next(next) {}\n};\n\nstruct TreeNode {\n  int val;\n  TreeNode *left;\n  TreeNode *right;\n  TreeNode() : val(0), left(nullptr), right(nullptr) {}\n  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n  TreeNode(int x, TreeNode *left, TreeNode *right)\n      : val(x), left(left), right(right) {}\n};\n\nvoid PrePrintLCTree(TNP root) {\n  if (!root) return;\n  dbgi(root->val);\n  PrePrintLCTree(root->left);\n  PrePrintLCTree(root->right);\n}\n\nclass LCCodec {\n public:\n  // Encodes a tree to a single string.\n  string serialize(TreeNode *root) {\n    if (!root) return \"\";\n\n    vector<TNP> a;\n    a.pb(root);\n    string ans;\n\n    while (nemp(a)) {\n      vector<TNP> b;\n\n      string tmp;\n      for (auto x : a) {\n        if (nemp(ans)) {\n          ans += ',';\n        }\n\n        if (x)\n          ans += to_string(x->val);\n        else\n          ans += \"null\";\n      }\n\n      bool ok{false};\n      for (auto x : a) {\n        if (x) {\n          b.pb(x->left);\n          b.pb(x->right);\n\n          if (x->left || x->right) {\n            ok = true;\n          }\n        }\n      }\n\n      if (ok)\n        a = std::move(b);\n      else\n        a = {};\n    }\n\n    return ans;\n  }\n\n  // Decodes your encoded data to tree.\n  TreeNode *deserialize(string data) {\n    vector<TNP> a;\n    int n = SZ(data);\n    vector<string> b;\n\n    if (!n) return nullptr;\n\n    string t;\n    for (auto x : data) {\n      if (x == ',') {\n        b.pb(t);\n        t = \"\";\n      } else\n        t += x;\n    }\n    b.pb(t);\n\n    for (auto x : b) {\n      if (x == \"null\")\n        a.pb(nullptr);\n      else\n        a.pb(new TN(stoi(x)));\n    }\n\n    int m = SZ(a);\n    int i = 0, j = 1;\n\n    while (i < m) {\n      while (i < m && !a[i]) ++i;\n      if (i >= n) break;\n\n      if (j < m) a[i]->left = a[j++];\n      if (j < m) a[i]->right = a[j++];\n      ++i;\n    }\n\n    return a[0];\n  }\n};\n\nLNP CreateList(VI &a) {\n  LN *du{new LN(0)}, *cur{}, *pre{du};\n\n  for (auto x : a) {\n    cur = new LN(x);\n    pre->next = cur;\n    pre = cur;\n  }\n\n  auto res = du->next;\n  delete du;\n  return res;\n}\n\nvoid PrintList(LNP head) {\n  while (head) {\n    dbgi(head->val);\n    head = head->next;\n  }\n  dbgln();\n}\n\n#endif\n// End of LeetCode\nclass Solution {\n public:\n  vector<int> solveQueries(vector<int> &nums, vector<int> &queries) {\n    int n{SZ(nums)}, n2 = n * 2;\n    VI a(n * 2 + 10);\n\n    For(i, 0, n) { a[i + 1] = a[i + 1 + n] = nums[i]; }\n\n    map<int, set<int>> mp;\n    For1(i, 1, n2) { mp[a[i]].insert(i); }\n\n    VI ans;\n    for (auto x : queries) {\n      x++;\n      int res = INF;\n\n      auto check = [&](int pos) {\n        int val = a[pos];\n\n        auto &s = mp[val];\n        auto it1 = s.lower_bound(pos);\n\n        if (it1 != s.begin()) {\n          auto it2 = prev(it1);\n          dbg(pos, *it2);\n          ckmin(res, pos - *it2);\n        }\n\n        it1 = s.upper_bound(pos);\n        if (it1 != s.end()) {\n          dbg(*it1, pos);\n          ckmin(res, *it1 - pos);\n        }\n      };\n\n      check(x);\n      check(x + n);\n\n      if (res == INF || res >= n) res = -1;\n      ans.pb(res);\n    }\n    dbgln();\n    return ans;\n  }\n};\n#ifdef _DEBUG\n\nint main(void) {\n  freopen(\"input.txt\", \"r\", stdin);\n  std::ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  _m_gen64.seed(Pr);\n\n  Solution a;\n  int n, m;\n  while (cin >> n) {\n    VI ve1(n);\n    for (auto &x : ve1) cin >> x;\n\n    cin >> m;\n    VI ve2(m);\n    for (auto &x : ve2) cin >> x;\n\n    auto res = a.solveQueries(ve1, ve2);\n    dbg(res);\n  }\n\n  return 0;\n}\n\n#endif","author":"太阳骑士","submissionId":"611238201"},[]]},{"1626":[{"id":"1626","fileName":"611238326.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n,m = len(nums),len(queries)\n        def d(a,b):\n            if a > b :\n                a,b = b,a\n            return min(b-a,a-b+n)\n        cnt = dict()\n        left = [inf] * n\n        for i,v in enumerate(nums):\n            if v in cnt: left[i] = i - cnt[v]\n            cnt[v] = i\n        for i,v in enumerate(left):\n            if v == inf and cnt[nums[i]] != i:\n                left[i] = i - cnt[nums[i]] + n\n        \n        cnt = dict()\n        right = [inf] * n\n        for i in range(n-1,-1,-1):\n            v = nums[i]\n            if v in cnt:\n                right[i] = cnt[v] - i\n            cnt[v] = i\n        for i,v in enumerate(right):\n            if v == inf and cnt[nums[i]] != i:\n                right[i] = cnt[nums[i]] - i + n\n        \n        ans = [-1]*m\n        for i,q in enumerate(queries):\n            v = min(left[q],right[q])\n            ans[i] = v if v != inf else -1\n        return ans","author":"Vibrant FermatrS1","submissionId":"611238326"},[{"id":"1627","similarity":1.0,"totOverlap":178,"longestOverlap":89}]],"1627":[{"id":"1627","fileName":"611238369.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n,m = len(nums),len(queries)\n        def d(a,b):\n            if a > b :\n                a,b = b,a\n            return min(b-a,a-b+n)\n        cnt = dict()\n        left = [inf] * n\n        for i,v in enumerate(nums):\n            if v in cnt: left[i] = i - cnt[v]\n            cnt[v] = i\n        for i,v in enumerate(left):\n            if v == inf and cnt[nums[i]] != i:\n                left[i] = i - cnt[nums[i]] + n\n        \n        cnt = dict()\n        right = [inf] * n\n        for i in range(n-1,-1,-1):\n            v = nums[i]\n            if v in cnt:\n                right[i] = cnt[v] - i\n            cnt[v] = i\n        for i,v in enumerate(right):\n            if v == inf and cnt[nums[i]] != i:\n                right[i] = cnt[nums[i]] - i + n\n        \n        ans = [-1]*m\n        for i,q in enumerate(queries):\n            v = min(left[q],right[q])\n            ans[i] = v if v != inf else -1\n        return ans","author":"我想要看你笑","submissionId":"611238369"},[{"id":"1626","similarity":1.0,"totOverlap":178,"longestOverlap":89}]]},{"1628":[{"id":"1628","fileName":"611238424.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>> mp;\n        int n = nums.size();\n        for(int i=0;i<n;++i){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(int &e : queries){\n            int m = mp[nums[e]].size();\n            auto &p = mp[nums[e]];\n            if(m==1){\n                ans.push_back(-1);continue;\n            }\n            int l = -1,r = m;\n            while(l+1<r){\n                int mid = (l+r)/2;\n                if(p[mid]<e) l = mid;\n                else r = mid;\n            }\n            int index = r;\n            int temp = INT_MAX;\n            if(index>0) temp = p[index] - p[index-1];\n            if(index<m-1) temp = min(temp,p[index+1]-p[index]);\n            if(index==m-1||index==0) temp = min(temp,n-p[m-1]+p[0]);\n            // if(index==0) temp = min(temp,n-p[m-1]+p[0]);\n            ans.push_back(temp);\n        }\n        return ans;\n    }\n};","author":"eleven-mile","submissionId":"611238424"},[]]},{"1629":[{"id":"1629","fileName":"611238486.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& b) {\n        unordered_map<int,vector<int>>mp;\n        int n=a.size();\n        for(int i=0;i<n;i++) a.push_back(a[i]);\n        for(int i=0;i<n;i++) a.push_back(a[i]);\n        for(int i=0;i<a.size();i++) {\n            mp[a[i]].push_back(i);\n        }\n        vector<int>av;\n        for(int i=0;i<b.size();i++) {\n            b[i]+=n;\n            auto& v=mp[a[b[i]]];\n            int in=lower_bound(v.begin(),v.end(),b[i])-v.begin();\n            int ans=a.size();\n            if(in>0) {\n                ans=min(ans,v[in]-v[in-1]);\n            }\n            if(in+1<v.size()) {\n                ans=min(ans,v[in+1]-v[in]);\n            }\n            if(ans==n||ans==0) ans=-1;\n            av.push_back(ans);\n        }\n        return av;\n    }\n};","author":"Kwords","submissionId":"611238486"},[]]},{"1630":[{"id":"1630","fileName":"611238459.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n    nn := len(nums)\n    tmp := make(map[int][]int)\n    for i, c := range nums {\n        if len(tmp[c]) == 0 {\n            tmp[c] = make([]int, 0)\n        }\n        tmp[c] = append(tmp[c], i)\n    }\n    n := len(queries)\n    res := make([]int, n)\n    for i := 0; i < n; i++ {\n        v := nums[queries[i]]\n        cur := tmp[v]\n        if len(cur) <= 1 {\n            res[i] = -1\n            continue\n        }\n\n        l, r := 0, len(cur)-1\n        for l < r {\n            mid := l+(r-l)/2\n            if cur[mid] == queries[i] {\n                l = mid\n                break\n            } else if cur[mid] < queries[i] {\n                l = mid+1\n            } else {\n                r = mid-1\n            }\n        }\n        \n        ls, rs := 0, 0\n        if l == 0 {\n            ls = nn-cur[len(cur)-1]+cur[l]\n        } else {\n            ls = cur[l]-cur[l-1]\n        }\n        if l == len(cur)-1 {            \n            rs = nn-cur[l]+cur[0]\n        } else {\n            rs = cur[l+1]-cur[l]\n        }\n\n        res[i] = min(ls, rs)\n    }\n\n    return res\n}","author":"IPRintf","submissionId":"611238459"},[]]},{"1631":[{"id":"1631","fileName":"611238551.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> hash;\n        for(int i = 0; i < nums.size(); i++){\n            if(hash.count(nums[i])) hash[nums[i]].push_back(i);\n            else hash[nums[i]] = vector<int>(1, i);\n        }\n        // for(auto [num, i] : hash){\n            // cout << \"Num :\" << num << endl;\n            // for(auto e : i) cout << e << ' '; cout << endl;\n        // }\n\n        vector<int> ret(queries.size());\n        int i_r = 0;\n        for(auto q : queries){\n            int n = nums[q];\n            auto& v = hash[n];\n            if(v.size() == 1) ret[i_r] = -1;\n            else{\n                auto it = lower_bound(v.begin(), v.end(), q);\n                // cout << \"*it = \" << *it << endl;\n                int cur = *it;\n                int l = (it == v.begin()) ? v.back() : *(it-1);\n                int r = (it == v.end() - 1) ? v.front() : *(it+1);\n                // cout << \"l = \" << l << endl;\n                // cout << \"r = \" << r << endl;\n                // cout << \"cur = \" << cur << endl;\n                int tol, tor;\n                if(l < cur) tol = cur - l;\n                else tol = cur + nums.size() - l;\n\n                if(cur < r) tor = r - cur;\n                else tor = r + nums.size() - cur;\n\n                ret[i_r] = min(tol, tor);\n            }\n            i_r++;\n            \n        }\n        \n        return ret;\n    }\n};","author":"夜泉","submissionId":"611238551"},[]]},{"1632":[{"id":"1632","fileName":"611238441.txt","sourceCode":"import bisect\nclass Solution:\n    def circularDistance(self, i: int, j: int, n: int) -> int:\n        diff = abs(i - j)\n        return min(diff, n - diff)\n\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        pos_map = {}\n        for i, num in enumerate(nums):\n            pos_map.setdefault(num, []).append(i)\n            \n        for num in pos_map:\n            pos_map[num].sort()\n            \n        ans = []\n        for q in queries:\n            val = nums[q]\n            positions = pos_map[val]\n            if len(positions) == 1:\n                ans.append(-1)\n                continue\n\n            k = bisect.bisect_left(positions, q)\n            m = len(positions)\n            left_neighbor = positions[(k - 1) % m]\n            right_neighbor = positions[(k + 1) % m]\n            d_left = self.circularDistance(q, left_neighbor, n)\n            d_right = self.circularDistance(q, right_neighbor, n)\n            ans.append(min(d_left, d_right))\n        return ans","author":"Matisse","submissionId":"611238441"},[]]},{"1633":[{"id":"1633","fileName":"611238631.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>>mp;\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int>ans;\n        for(auto x:queries){\n            if(mp[nums[x]].size()==1){\n                ans.push_back(-1);\n                continue;\n            }\n            else {\n                int pos = lower_bound(mp[nums[x]].begin(),mp[nums[x]].end(),x)-mp[nums[x]].begin();\n                int mn=1e7;\n                if(pos!=0)mn=min({mn,mp[nums[x]][pos]-mp[nums[x]][pos-1],(int)nums.size()-mp[nums[x]][pos]+mp[nums[x]][pos-1]});\n                if(pos==0)mn=min(mn,(int)nums.size()-mp[nums[x]][(int)mp[nums[x]].size()-1]+mp[nums[x]][pos]);\n                if(pos!=mp[nums[x]].size()-1)mn=min({mn,mp[nums[x]][pos+1]-mp[nums[x]][pos],(int)nums.size()-mp[nums[x]][pos+1]+mp[nums[x]][pos]});\n                if(pos==(int)mp[nums[x]].size()-1)\n                    mn=min(mn,(int)nums.size()-mp[nums[x]][pos]+mp[nums[x]][0]);\n                ans.push_back(mn);\n            }\n        }\n        return ans;\n    }\n};","author":"Nostalgic I3oothXUN","submissionId":"611238631"},[]]},{"1634":[{"id":"1634","fileName":"611238557.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        loc = defaultdict(list)\n        for i, a in enumerate(nums):\n            loc[a].append(i)\n\n        ans = [-1] * len(queries)\n        for i, q in enumerate(queries):\n            arr = loc[nums[q]]\n            m = len(arr)\n            # 该元素唯一\n            if m == 1:\n                continue\n            \n            idx = bisect_left(arr, q)\n            a = arr[idx] - arr[(idx - 1) % m]\n            b = arr[(idx + 1) % m] - arr[idx]\n            ans[i] = min(a % n, (-a) % n, b % n, (-b) % n)\n        return ans","author":"JeremyZhang96","submissionId":"611238557"},[]]},{"1635":[{"id":"1635","fileName":"611238510.txt","sourceCode":"use std::collections::HashMap;\n\nimpl Solution {\n    pub fn solve_queries(v: Vec<i32>, q: Vec<i32>) -> Vec<i32> {\n        let n0 = v.len();\n        let mut m: HashMap<i32, Vec<usize>> = HashMap::new();\n        for (i, x) in v.iter().enumerate() {\n            let p = m.entry(*x).or_default();\n            p.push(i);\n        }\n\n        q.into_iter()\n            .map(|q| {\n                let q = q as usize;\n                let p = m.get(&v[q]).unwrap();\n                let n1 = p.len();\n                let i = p.binary_search(&q).unwrap();\n\n                if i == 0 {\n                    if n1 == 1 {\n                        -1\n                    } else {\n                        let a = *p.get(1).unwrap() - q;\n                        let b = n0 + q - *p.get(1).unwrap();\n                        let c = n0 + q - *p.get(n1 - 1).unwrap();\n                        a.min(b).min(c) as i32\n                    }\n                } else if i == n1 - 1 {\n                    if n1 == 1 {\n                        -1\n                    } else {\n                        let a = q - *p.get(i - 1).unwrap();\n                        let b = n0 + *p.get(i - 1).unwrap() - q;\n                        let c = n0 + *p.get(0).unwrap() - q;\n                        a.min(b).min(c) as i32\n                    }\n                } else {\n                    let a = q - *p.get(i - 1).unwrap();\n                    let b = *p.get(i + 1).unwrap() - q;\n                    let c = n0 + *p.get(i - 1).unwrap() - q;\n                    let d = n0 + q - *p.get(i + 1).unwrap();\n                    a.min(b).min(c).min(d) as i32\n                }\n            })\n            .collect()\n    }\n}","author":"Somnia1337x","submissionId":"611238510"},[]]},{"1636":[{"id":"1636","fileName":"611238633.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = queries.size(), m = nums.size();\n        vector<int> arr(2 * m, INT_MAX);\n        unordered_map<int,int> map;\n        for(int i = 0; i < 2 * m; i++){\n            int x = nums[i % m];\n            if(map.find(x) == map.end()){\n                map[x] = i;\n            }else{\n                arr[i] = i - map[x];\n                map[x] = i;\n            }\n        }\n        map.clear();\n        for(int i = 2 * m - 1; i >= 0; i--){\n            int x = nums[i % m];\n            if(map.find(x) == map.end()){\n                map[x] = i;\n            }else{\n                arr[i] = min(map[x] - i, arr[i]);\n                map[x] = i;\n            }\n        }\n        vector<int> ans;\n        for(int& x : queries){\n            if(arr[x] >= m && arr[m + x] >= m)\n                arr[x] = -1;\n            ans.push_back(min(arr[m + x], arr[x]));\n        }\n        return ans;\n    }\n};","author":"Amu","submissionId":"611238633"},[]]},{"1638":[{"id":"1638","fileName":"611238716.txt","sourceCode":"class Solution {\npublic:\n    set<int> numloc[100005];\n    vector<int> ans;\n    int n,len;\n    const int inf=1e9;\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        n=nums.size();\n        len=queries.size();\n        ans.resize(len,-1);\n        int i,j,k;\n        for(i=0;i<n;i++)\n        {\n            numloc[nums[i]].insert(i);//值为nums[i]的元素的位置们        \n        }\n        for(i=0;i<len;i++)\n        {\n            int loc=queries[i];\n            int tmp=nums[loc];\n            auto it=numloc[tmp].find(loc);\n            \n            int pre=-1,next=-1;\n            if(it==numloc[tmp].end())\n            {\n                ans[i]=-1;\n                continue;\n            }\n            ans[i]=inf;\n            if(it!=numloc[tmp].begin())\n            {\n                it--;\n                pre=*it;\n                ans[i]=min(ans[i],loc-pre);\n                auto help=numloc[tmp].begin();\n                ans[i]=min(ans[i],*help+n-loc);\n                it++;\n            }\n            it++;\n            if(it!=numloc[tmp].end())\n            {\n                next=*it;\n                ans[i]=min(ans[i],next-loc);\n            }\n\n            auto back=numloc[tmp].end();\n            back--;\n            if(*back!=loc)\n            {\n                ans[i]=min(ans[i],loc+n-*back);\n            }\n            \n            if(ans[i]>=inf)\n            ans[i]=-1;\n        }\n        return ans;\n    }\n};","author":"野望","submissionId":"611238716"},[]]},{"1639":[{"id":"1639","fileName":"611238565.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        nums_idx: dict = defaultdict(list)\n        for i in range(len(nums)):\n            nums_idx[nums[i]].append(i)\n        # print(nums_idx)\n\n        nums_len = len(nums)\n        dist = [-1 for _ in range(len(nums))]\n        for num_idx in nums_idx.values():\n            if len(num_idx) <= 1:\n                continue\n            if len(num_idx) == 2:\n                d = min(num_idx[1] - num_idx[0], num_idx[0] + nums_len - num_idx[1])\n                dist[num_idx[0]] = d\n                dist[num_idx[1]] = d\n                continue\n            dist[num_idx[0]] = min(num_idx[1] - num_idx[0], num_idx[0] + nums_len - num_idx[-1])\n            dist[num_idx[-1]] = min(num_idx[0] + nums_len - num_idx[-1], num_idx[-1] - num_idx[-2])\n            for i in range(1, len(num_idx)-1):\n                dist[num_idx[i]] = min(num_idx[i] - num_idx[i-1], num_idx[i+1] - num_idx[i])\n        # print(dist)\n\n        return [dist[q] for q in queries]","author":"g00dm0rning","submissionId":"611238565"},[]]},{"1640":[{"id":"1640","fileName":"611238629.txt","sourceCode":"from collections import defaultdict\n\nclass Solution(object):\n    def solveQueries(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def binary(List,l,target):\n            # print(List)\n            i=0\n            j=l-1\n            while i<=j:\n                mid=(i+j)//2\n                # print(mid)\n                if List[mid]==target:\n                    return mid\n                elif List[mid]>target:\n                    j=mid-1\n                else:\n                    i=mid+1\n            return -1\n        \n        nums_dict=defaultdict(list)\n        n=len(nums)\n        for i in range(n):\n            nums_dict[nums[i]].append(i)\n        ans=[]\n        for i in queries:\n            num=nums[i]\n            num_indexs=nums_dict[num]\n            l=len(num_indexs)\n            if l==1:\n                ans.append(-1)\n                continue\n            ind=binary(num_indexs,l,i)\n            # print(ind)\n            if ind==l-1:\n                ans.append(min(i-num_indexs[ind-1],n-i+num_indexs[0]))\n                continue\n            if ind==0:\n                ans.append(min(num_indexs[ind+1]-i,n-num_indexs[-1]+i))\n                continue\n            ans.append(min(num_indexs[ind+1]-i,i-num_indexs[ind-1]))\n        return ans","author":"迷路的小朋友","submissionId":"611238629"},[]]},{"1641":[{"id":"1641","fileName":"611238717.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> m;\n        for (int i = 0; i < nums.size(); ++i) {\n            m[nums[i]].push_back(i);\n        }\n        const int n = queries.size();\n        vector<int> ret(n, -1);\n        for (int i = 0; i < n; ++i) {\n            const int j = queries[i];\n            const auto& v = m[nums[j]];\n            // cout << i << \" \" << j << \" \" << nums[j] << \" \" << v.size() << endl;\n            if (v.size() == 1) {\n                // ret[i] = -1;\n                continue;\n            }\n            const int pos = lower_bound(v.begin(), v.end(), j) - v.begin();\n            // cout << pos << \" \" << v[pos] << endl;\n            if (pos == 0) {\n                ret[i] = min(v[pos + 1] - v[pos], v[pos] + (int)nums.size() - v.back());\n                // cout << \"[a]\" << i << \" \" << v[pos + 1] - v[pos] << \"?\" << v[pos] + n - v.back() << endl;\n            } else if (pos + 1 == v.size()) {\n                ret[i] = min(v.front() + (int)nums.size() - v[pos], v[pos] - v[pos - 1]);  \n                // cout << \"[b]\" << i << \" \" << ret[i] << endl;  \n            } else {\n                ret[i] = min(v[pos + 1] - v[pos], v[pos] - v[pos - 1]);   \n                // cout << \"[c]\" << i << \" \" << ret[i] << endl; \n            }\n        }\n        return ret;\n    }\n};","author":"梁震甲","submissionId":"611238717"},[]]},{"1642":[{"id":"1642","fileName":"611238721.txt","sourceCode":"class Solution {\npublic:\n    static vector<int> solveQueries(const vector<int> &nums, vector<int> &queries) {\n        const int n = static_cast<int>(nums.size());\n        unordered_map<int, vector<int>> numPos;\n        for (int i = 0; i < n; ++i) numPos[nums[i]].push_back(i);\n        for (int &i: queries) {\n            if (const vector<int> &pos = numPos[nums[i]]; pos.size() == 1) i = -1;\n            else if (i == pos[0]) i = min(pos[1] - i, n - pos.back() + i);\n            else if (i == pos.back()) i = min(n - i + pos[0], i - pos[pos.size() - 2]);\n            else {\n                const auto it = ranges::lower_bound(pos, i);\n                i = min(*next(it) - i, i - *prev(it));\n            }\n        }\n        return move(queries);\n    }\n};","author":"trdtrdsd","submissionId":"611238721"},[]]},{"1643":[{"id":"1643","fileName":"611238722.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        for (int i = 0; i < n; ++i){\n            nums.push_back(nums[i]);\n        }\n        int h = n;\n        n *= 2;\n        vector<int> v(n, -1);\n        unordered_map<int, int> mp;\n        for (int i = 0; i < n; ++i){\n            if (mp.count(nums[i])){\n                int k = i % h;\n                v[k] = i - mp[nums[i]];\n                if (v[k] >= h){\n                    v[k] = -1;\n                }\n            }\n            mp[nums[i]] = i;\n        }\n        mp.clear();\n        for (int i = n - 1; i >= 0; --i){\n            if (mp.count(nums[i])){\n                int k = i % h;\n                int g = mp[nums[i]] - i;\n                if (v[k] == -1 || g < v[i]){\n                    v[k] = g;\n                    if (v[k] >= h){\n                        v[k] = -1;\n                    }\n                }\n            }\n            mp[nums[i]] = i;\n        }\n        int m = queries.size();\n        vector<int> ans(m);\n        for (int i = 0; i < m; ++i){\n            ans[i] = v[queries[i]];\n        }\n        return ans;\n    }\n};","author":"lart1n","submissionId":"611238722"},[]]},{"1644":[{"id":"1644","fileName":"611238477.txt","sourceCode":"#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int> &nums, vector<int> &queries) {\n        int n = nums.size(), m = queries.size();\n        vector<int> res(m, -1);\n        unordered_map<int, vector<int>> map;\n        for (int i = 0; i < n; i++) {\n            map[nums[i]].push_back(i);\n        }\n        for (int i = 0; i < m; i++) {\n            int q = queries[i];\n            if (map[nums[q]].size() < 2) continue;\n            auto &v = map[nums[q]];\n            int p = lower_bound(v.begin(), v.end(), q) - v.begin();\n            int size = v.size();\n            res[i] = 1e9;\n            if (p > 0) res[i] = v[p] - v[p - 1];\n            if (p + 1 < size) res[i] = min(res[i], v[p + 1] - v[p]);\n            if (p == 0) {\n                res[i] = min(res[i], v[0] + n - v[size - 1]);\n            }\n            if (p == size - 1) {\n                res[i] = min(res[i], n - v[p] + v[0]);\n            }\n           // cout << p << ' ' << v[p] << endl;\n            //for (int x: v) cout << x << \" \";\n           // cout <<endl;\n        }\n        return res;\n    }\n};\n","author":"Pomme","submissionId":"611238477"},[]]},{"1645":[{"id":"1645","fileName":"611238760.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<int> res(m);\n        int mx = ranges::max(nums);\n        vector<vector<int>> dd(mx+1);\n        for(int i = 0, x; i < n; ++i){\n            x = nums[i];\n            dd[x].push_back(i);\n        }\n        int x, y, t, ans;\n        for(int i = 0; i < m; ++i){\n            x = queries[i];\n            y = nums[x];\n            t = lower_bound(dd[y].begin(), dd[y].end(), x) - dd[y].begin();\n            ans = n;\n            if(dd[y].size() > 1){\n                ans = min(ans, dd[y][0] + n - x);\n                ans = min(ans, x + n - dd[y].back());\n            }\n            if(t + 1 < dd[y].size()){\n                ans = min(ans, dd[y][t+1] - x);\n            }\n            if(t > 0){\n                ans = min(ans, x - dd[y][t-1]);\n            }\n            res[i] = ans == n ? -1 : ans;\n        }\n        return res;\n    }\n};","author":"13579","submissionId":"611238760"},[]]},{"1646":[{"id":"1646","fileName":"611238774.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> v2i;\n        int n = nums.size();\n        for (int i = 0; int& x : nums) v2i[x].emplace_back(i++);\n        vector<int> retVal(queries.size(), -1);\n        for (int i = 0; int& x : queries) {\n            auto& idx = v2i[nums[x]];\n            int sz = idx.size();\n            if (sz == 1) {\n                ++i;\n                continue;\n            }\n            int cur = lower_bound(idx.begin(), idx.end(), x) - idx.begin();\n            retVal[i] = min((idx[(cur + 1) % sz] - x + n) % n, (x -idx[(cur - 1 + sz) % sz] + n) % n);\n            ++i;\n        }\n        return retVal;\n    }\n};","author":"ming","submissionId":"611238774"},[]]},{"1648":[{"id":"1648","fileName":"611238755.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        nums = nums * 2\n        ans = [-1] * (2 * n)\n        cnt = defaultdict(int)\n        for i in range(1,n):\n            if nums[i] == nums[0]:\n                ans[0] = i\n                ans[i] = i\n                break\n        for i,x in enumerate(nums):\n            if cnt[x] != 0:\n                if i - cnt[x] == n:\n                    continue\n                if ans[cnt[x] % n] == -1:\n                    ans[cnt[x] % n] = i - cnt[x]\n                else:\n                    ans[cnt[x] % n] = min(ans[cnt[x] % n],i - cnt[x])\n                if ans[i % n] == -1:\n                    ans[i % n] = i - cnt[x]\n                else:\n                    ans[i % n] = min(ans[i % n],i - cnt[x])\n            cnt[x] = i\n        return [ans[i] for i in queries]","author":"一只真昼","submissionId":"611238755"},[]]},{"1649":[{"id":"1649","fileName":"611238895.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[]} queries\n * @return {number[]}\n */\nvar solveQueries = function(nums, queries) {\n        function get(source, target, r) {\n        let t_i = target;\n        if (t_i < 0) {\n            t_i = r.length - 1;\n        } else if (t_i >= r.length) {\n            t_i = 0;\n        }\n        const t = r[t_i];\n        if (source >= t) {\n            const t_1 = Math.abs(source - t);\n            const t_2 = nums.length - source + t;\n            return Math.min(t_1, t_2);\n        } else {\n            const t_1 = Math.abs(source - t);\n            const t_2 = nums.length - t + source;\n            return Math.min(t_1, t_2);\n        }\n\n    }\n    const map = new Map();\n    const t_map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        if (!map.has(nums[i])) {\n            map.set(nums[i], []);\n        }\n        const r = map.get(nums[i]);\n        t_map.set(i, r.length);\n        r.push(i);\n    }\n    const rt = Array.from({ length: queries.length }, () => -1);\n    for (let i = 0; i < queries.length; i++) {\n        const q_i = queries[i];\n        const t = nums[q_i];\n        const r = map.get(t);\n        if (r.length === 1) {\n            continue;\n        }\n        const t_r_i = t_map.get(q_i);\n        const bf_t = get(q_i, t_r_i - 1, r);\n        const next_t = get(q_i, t_r_i + 1, r);\n        rt[i] = Math.min(bf_t, next_t);\n    }\n    return rt;\n};","author":"peepeepoopoo","submissionId":"611238895"},[]]},{"1650":[{"id":"1650","fileName":"611238920.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        ans, store, n = [], defaultdict(list), len(nums)\n        for i, num in enumerate(nums):\n            store[num].append(i)\n        for q in queries:\n            if len(store[nums[q]]) == 1:\n                ans.append(-1)\n            else:\n                temp = inf\n                r = bisect_right(store[nums[q]], q)\n                # print(n, q, r, store[nums[q]])\n                if r < len(store[nums[q]]):\n                    temp = store[nums[q]][r]-q\n                    temp = min(temp, n-temp)\n                else:\n                    temp = q - store[nums[q]][0]\n                    temp = min(temp, n-temp)\n                if r > 1:\n                    temp = min(temp, q-store[nums[q]][r-2])\n                    temp = min(temp, n-temp)\n                else:\n                    a = store[nums[q]][-1] - q\n                    temp = min(temp, a, n-a)\n                ans.append(temp)\n        return ans","author":"怳","submissionId":"611238920"},[]]},{"1651":[{"id":"1651","fileName":"611238745.txt","sourceCode":"class Solution {\npublic:\n   vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        unordered_map<int, int> line;\n        for (int i = 0; i < nums.size(); i++) {\n            line[i] = mp[nums[i]].size();\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> res;\n        for (int i = 0; i < queries.size(); i++) {\n            int index = queries[i];\n            int num = nums[index];\n            int curindex = line[index];\n            vector<int>& vt = mp[num];\n            if (vt.size() == 1) {\n                res.push_back(-1);\n            } else {\n                int minDist;\n                if (curindex == 0) {\n                    minDist = min(vt[curindex + 1] - vt[curindex], (int)nums.size() - (vt[vt.size() - 1] - vt[0]));\n                } else if (curindex == vt.size() - 1) {\n                    minDist = min(vt[curindex] - vt[curindex - 1], (int)nums.size() - (vt[vt.size() - 1] - vt[0]));\n                } else {\n                    minDist = min(vt[curindex] - vt[curindex - 1], vt[curindex + 1] - vt[curindex]);\n                }\n                res.push_back(minDist);\n            }\n        }\n        return res;\n    }\n};","author":"Patronum","submissionId":"611238745"},[]]},{"1652":[{"id":"1652","fileName":"611238939.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n\tindices := make(map[int][]int)\n\tfor i, num := range nums {\n\t\tindices[num] = append(indices[num], i)\n\t}\n\tans := make([]int, len(queries))\n\tfor i, q := range queries {\n\t\tt := indices[nums[q]]\n\t\tif len(t) == 1 {\n\t\t\tans[i] = -1\n\t\t\tcontinue\n\t\t}\n\t\tpos, _ := slices.BinarySearch(t, q)\n\t\tans[i] = min(diff(t[pos], t[(pos+len(t)-1)%len(t)], len(nums)), diff(t[(pos+1)%len(t)], t[pos], len(nums)))\n\t}\n\treturn ans\n}\n\nfunc diff(a, b, mod int) int { return (a + mod - b) % mod }","author":"Leon","submissionId":"611238939"},[]]},{"1653":[{"id":"1653","fileName":"611238984.txt","sourceCode":"class Solution {\npublic:\n    int fi[1000010],pr[1000010],ne[1000010],en[1000010];\n    vector<int>solveQueries(vector<int>& nums, vector<int>& queries) {\n        for(auto &t:nums) {\n            fi[t] = -1;\n            pr[t] = -1;\n            ne[t] = -1;\n            en[t] = -1;\n        }\n        int n = nums.size();\n        vector<int>ans(n,-1);\n        for(int i = 0; i < n; i++) {\n            int x = nums[i];\n            if(pr[x] != -1) {\n                ans[i] = i - pr[x];\n            }\n            pr[x] = i;\n            if(fi[x] == -1) {\n                fi[x] = i;\n            }\n        }\n        for(int i = n - 1; i >= 0; i--) {\n            int x = nums[i];\n            if(ne[x] != -1) {\n                if(ans[i] == -1) ans[i] = ne[x] - i;\n                else ans[i] = min(ans[i], ne[x] - i);\n            }\n            ne[x] = i;\n            if(en[x] == -1) {\n                en[x] = i;\n            }\n        }\n        for(int i = 0; i < n; i++) {\n            int x = nums[i];\n            if(fi[x] != i) {\n                // 5 7 1\n                if(ans[i] == -1) ans[i] = n - i + fi[x];\n                else ans[i] = min(ans[i], n - i + fi[x]);\n            }\n        }\n        for(int i = n - 1; i >= 0; i--) {\n            int x = nums[i];\n            if(en[x] != i) {\n                if(ans[i] == -1) ans[i] = i + n - en[x];\n                else ans[i] = min(ans[i], i + n - en[x]);\n            }\n        }\n        vector<int>res(queries.size());\n        for(int i = 0; i < queries.size(); i++) {\n            res[i] = ans[queries[i]];\n        }\n        return res;\n    }\n};","author":"acception","submissionId":"611238984"},[]]},{"1656":[{"id":"1656","fileName":"611239065.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        nums*=2\n        ans= [-1]*n\n        mp = {}\n        for i,num in enumerate(nums):\n            if mp.get(num,-1)==-1:\n                mp[num]=i          #记录最左侧出现的下标\n            else:\n                ans[i%n] = i-mp[num]    #距离\n                mp[num]=i\n\n        mp.clear()\n        for i in range(len(nums)-1,-1,-1):\n            num = nums[i]\n            if mp.get(num,-1)==-1:\n                mp[num]=i          #记录最右侧出现的下标\n            else:\n                ans[i%n] = min(ans[i%n],mp[num]-i)    #距离\n                mp[num]=i\n\n        for i in range(n):\n            if ans[i]==n:\n                ans[i]=-1\n        m = len(queries)\n        ret = []\n        for x in queries:\n            ret.append(ans[x])\n        return ret","author":"Elasxible","submissionId":"611239065"},[]]},{"1657":[{"id":"1657","fileName":"611238972.txt","sourceCode":"from bisect import bisect_left\n\ndef bin_search(a, x):\n    l, r = 0, len(a) - 1\n    while l <= r:\n        m = (l + r) // 2\n        if a[m] == x:\n            return m\n        if a[m] < x:\n            l = m + 1\n        else:\n            r = m - 1\n    return -1\n\ndef seg_tree(a):\n    n = len(a)\n    s = 1\n    while s < n:\n        s *= 2\n    t = [0] * (2 * s)\n    for i in range(n):\n        t[s + i] = a[i]\n    for i in range(s - 1, 0, -1):\n        t[i] = t[2 * i] + t[2 * i + 1]\n    def qry(l, r):\n        l += s\n        r += s\n        tot = 0\n        while l <= r:\n            if l & 1:\n                tot += t[l]\n                l += 1\n            if not r & 1:\n                tot += t[r]\n                r -= 1\n            l //= 2\n            r //= 2\n        return tot\n    return t, qry\n\nclass Solution:\n    def solveQueries(self, nums: List[int], qs: List[int]) -> List[int]:\n        n = len(nums)\n        d = {}\n        for i, v in enumerate(nums):\n            d.setdefault(v, []).append(i)\n        for k in d:\n            d[k].sort()\n        res = []\n        for q in qs:\n            v = nums[q]\n            a = d[v]\n            if len(a) < 2:\n                res.append(-1)\n                continue\n            i = bisect_left(a, q)\n            dl = q + n - a[-1] if i == 0 else q - a[i - 1]\n            dr = a[0] + n - q if i == len(a) - 1 else a[i + 1] - q\n            res.append(min(dl, dr))\n        return res\n","author":"Cranky 6agarinizJ","submissionId":"611238972"},[]]},{"1658":[{"id":"1658","fileName":"611239012.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        last = {}\n        front = {}\n        left = [-1] * n\n        right = [-1] * n\n        l1, r1 = {}, {}\n        for i, x in enumerate(nums):\n            if x in last:\n                left[i] = last[x]\n            else:\n                l1[x] = i\n            last[x] = i\n\n        for i in range(n-1, -1, -1):\n            x = nums[i]\n            if x in front:\n                right[i] = front[x]\n            else:\n                r1[x] = i\n            front[x] = i\n\n        ans = []\n        \n        for q in queries:\n            x = nums[q]\n            if left[q] == -1 and right[q] == -1:\n                ans.append(-1)\n                continue\n            ld = -1\n            rd = -1\n            if left[q] != -1:\n                ld = q-left[q]\n            else:\n                ld = n+q-r1[x]\n            if right[q] != -1:\n                rd = right[q]-q\n            else:\n                rd = n-q+l1[x]\n            ans.append(min(ld, rd))\n\n        return ans","author":"XIAO TUO","submissionId":"611239012"},[]]},{"1659":[{"id":"1659","fileName":"611239109.txt","sourceCode":"class Solution {\npublic:\n  vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n    map<int, vector<int>> mp;\n    for (int i = 0; i < nums.size(); i++) {\n      mp[nums[i]].push_back(i);\n    }\n    vector<int> ret(queries.size());\n    for (int i = 0; i < queries.size(); i++) {\n      int q = queries[i];\n      auto& ll = mp[nums[q]];\n      if (ll.size() == 1) {\n        ret[i] = -1;\n        continue;\n      }\n      int idx = lower_bound(ll.begin(), ll.end(), q) - ll.begin();\n      int idxL = idx - 1, idxR = idx + 1;\n      if (idxL == -1) idxL = ll.size() - 1;\n      if (idxR == ll.size()) idxR = 0;\n      // cout << nums[q] << \" \" << ll[idx] << \" \" << ll[idxL] << \" \" << ll[idxR] << endl;\n\n      ret[i] = 10000000;\n      ret[i] = min(ret[i], abs(ll[idx] - ll[idxL]));\n      ret[i] = min(ret[i], abs(ll[idx] - ll[idxR]));\n      ret[i] = min(ret[i], (int)nums.size() - abs(ll[idx] - ll[idxL]));\n      ret[i] = min(ret[i], (int)nums.size() - abs(ll[idx] - ll[idxR]));\n    }\n    return ret;\n  }\n};","author":"9caiji","submissionId":"611239109"},[]]},{"1660":[{"id":"1660","fileName":"611239164.txt","sourceCode":"func solveQueries(nums []int, queries []int) (res []int) {\n    n := len(nums)\n    indices := make(map[int][]int)\n    for i, num := range nums {\n        indices[num] = append(indices[num], i)\n    }\n    for _, query := range queries {\n        num := nums[query]\n        indice := indices[num]\n        if len(indice) == 1 {\n            res = append(res, -1)\n            continue\n        }\n        i := sort.SearchInts(indice, query)\n        left, right := 0, 0\n        if i == len(indice)-1 {\n            right = indice[0]+n\n        }  else {\n            right = indice[i+1]\n        }\n        if i == 0 {\n            left = indice[len(indice)-1]-n\n        } else {\n            left = indice[i-1]\n        }\n        res = append(res, min(query-left, right-query))\n    }\n    return\n}","author":"zhangliangpeng","submissionId":"611239164"},[]]},{"1661":[{"id":"1661","fileName":"611239090.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, int> q;\n        for(auto i : nums) q[i] = -1;\n        vector<int> dis(nums.size() + 1, nums.size() + 1);\n        for(int i = 0; i < nums.size() * 2; ++i) {\n            int j = i % nums.size();\n            if(q[nums[j]] == -1 || q[nums[j]] == j) {\n                dis[j] = nums.size() + 1;\n            } else {\n                int dist = (j - q[nums[j]] + nums.size()) % nums.size();\n                dis[j] = min(dis[j], dist);\n                dis[q[nums[j]]] = min(dis[q[nums[j]]], dist);\n                // cout << j << ' ' << q[nums[j]] << 'n';\n            }\n            q[nums[j]] = j;\n        }\n\n        vector<int> ans;\n        for(auto i : queries) {\n            if(dis[i] == nums.size() + 1) ans.push_back(-1);\n            else ans.push_back(dis[i]);\n        }\n\n        return ans;\n    }\n};","author":"路人乙","submissionId":"611239090"},[]]},{"1662":[{"id":"1662","fileName":"611239269.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        book = {}\n        for i,v in enumerate(nums):\n            if v not in book :\n                book[v] = []\n            book[v].append(i)\n\n        answer  = [] \n        for q in queries :\n            k = nums[q]\n            if len(book[k] ) <=1 :\n                answer.append(-1 )\n            else :\n                idx = bisect.bisect_right(book[k], q ) -1 \n                # idx = book[k].index(q)\n                left_idx = (idx -1 + len(book[k]) ) % len(book[k])\n                right_idx = (idx+1 ) % len(book[k] )\n                l = book[k][left_idx]\n                r = book[k][right_idx]\n                answer.append(min((q-l+len(nums)) % len(nums) ,  (r-q +len(nums) )%len(nums) ))\n                \n        return answer ","author":"spx","submissionId":"611239269"},[]]},{"1663":[{"id":"1663","fileName":"611239320.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        ans = []\n        d = defaultdict(list)\n        for i, p in enumerate(nums):\n            d[p].append(i)\n        for i in queries:\n            if len(d[nums[i]]) == 1:\n                ans.append(-1)\n            else:\n                ii = bisect.bisect_left(d[nums[i]], i)\n                \n                t1 = d[nums[i]][ii]-d[nums[i]][ii-1]\n                if t1 < 0:\n                    t1 += len(nums)\n                \n                t2 = d[nums[i]][(ii+1)%len(d[nums[i]])]-d[nums[i]][ii]\n                if t2 < 0:\n                    t2 += len(nums)\n                # print(t1, t2, i)\n                ans.append(min(t1, t2))\n        return ans\n            \n                \n            \n        ","author":"Clared","submissionId":"611239320"},[]]},{"1664":[{"id":"1664","fileName":"611239218.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n=len(nums)\n        d={}\n        ans=[inf]*n\n        arr=nums+nums\n        for i,x in enumerate(arr):\n            if x in d:\n                ans[i%n]=min(ans[i%n],i-d[x])\n            d[x]=i\n        d.clear()\n        for j in range(len(arr)-1,-1,-1):\n            x=arr[j]\n            if x in d:\n                ans[j%n]=min(ans[j%n],d[x]-j)\n            d[x]=j\n        \n        res=[-1]*len(queries)\n        for i,x in enumerate(queries):\n            if ans[x]!=inf and ans[x]!=n:\n                res[i]=ans[x]\n        return res\n            ","author":"龙战于野-其血玄黄","submissionId":"611239218"},[]]},{"1665":[{"id":"1665","fileName":"611239398.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dd = defaultdict(list)\n\n        for index, num in enumerate(nums):\n            dd[num].append(index)\n\n\n        res = [-1]*len(queries)\n        for ii,q in enumerate(queries):\n            temp = -1\n            indexs = dd[nums[q]]\n            if len(indexs)<=1:\n                continue\n\n            hit = bisect_left(indexs,q)\n\n            if hit==0:\n                temp=min(indexs[1]-indexs[0],len(nums)-indexs[-1]+indexs[0])\n\n            elif hit==len(indexs)-1:\n                temp = min(indexs[-1]-indexs[-2],len(nums)-indexs[-1]+indexs[0])\n            else:\n                temp=min(indexs[hit]-indexs[hit-1],indexs[hit+1]-indexs[hit])\n\n            res[ii] = temp\n\n        return res\n            \n            \n\n        \n        ","author":"mottc","submissionId":"611239398"},[]]},{"1666":[{"id":"1666","fileName":"611239249.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector <int> G[100010];\n        int n = nums.size();\n        for (int i=0;i<n;i++){\n            G[nums[i]].push_back(i);\n        }\n        vector <int> ans;\n        for (int k=0;k<queries.size();k++){\n            int q = queries[k];\n            if (G[nums[q]].size()==1){\n                ans.push_back(-1); continue;\n            }\n            int pos = lower_bound(G[nums[q]].begin(), G[nums[q]].end(), q)- G[nums[q]].begin();\n            // cout<<pos<<endl;\n            int Min = 1e7;\n            if (pos<G[nums[q]].size()-1) Min = min(Min, G[nums[q]][pos+1]-q);\n            if (pos>0) Min = min(Min, q-G[nums[q]][pos-1]);\n            if (pos==0) Min = min(Min, q+n-G[nums[q]][G[nums[q]].size()-1]);\n            if (pos==G[nums[q]].size()-1) Min = min(Min, n-q+G[nums[q]][0]);\n            ans.push_back(Min);\n        }\n        return ans;\n    }\n};","author":"SYForever","submissionId":"611239249"},[]]},{"1667":[{"id":"1667","fileName":"611239340.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dis = [inf] * len(nums)\n        last_pos = defaultdict(lambda: -inf)\n        for i, n in enumerate(nums + nums):\n            j = last_pos[n]\n            if j >= 0:\n                dis[j % len(nums)] = min(dis[j % len(nums)], i - j)\n            dis[i % len(nums)] = min(dis[i % len(nums)], i - j)\n            last_pos[n] = i\n        \n        return [dis[q] if dis[q] < len(nums) else -1 for q in queries]","author":"kcrimson","submissionId":"611239340"},[]]},{"1668":[{"id":"1668","fileName":"611239336.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int sz = nums.size();\n        unordered_map<int,int> firstp, lastp;\n        vector<int> mindis(sz,INT_MAX);\n        for(int i = 0;i<sz;i++){\n            int cur = nums[i];\n            if(lastp.count(cur) == 0){\n                lastp[cur] = i;\n                firstp[cur] = i;\n            }\n            else{\n                mindis[lastp[cur]] = min(mindis[lastp[cur]], i - lastp[cur]);\n                mindis[i] = min(i - lastp[cur], sz-i + firstp[cur]);\n                lastp[cur] = i;\n            }\n        }\n\n        for(auto [nums,pos] : firstp){\n            if(lastp[nums]!=pos)\n                mindis[pos] = min(mindis[pos], sz - lastp[nums] + pos);\n        }\n        vector<int> ret;\n        for(auto it:queries){\n            if(mindis[it] == INT_MAX)\n                ret.emplace_back(-1);\n            else\n                ret.emplace_back(mindis[it]);\n        }\n        return ret;\n    }\n};","author":"府艾山茶灵","submissionId":"611239336"},[]]},{"1669":[{"id":"1669","fileName":"611239462.txt","sourceCode":"#include<bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> num_vec;\n        int n = nums.size();\n        vector<int> ans;\n        for (int i = 0; i < n; i++) {\n            int x = nums[i];\n            num_vec[x].push_back(i);\n        }\n        for (auto& q : queries) {\n            int dis = INT_MAX;\n            auto& vec = num_vec[nums[q]];\n            auto pos = lower_bound(vec.begin(), vec.end(), q);\n\n            // 前\n            int index = pos - vec.begin();\n            auto tmp = pos + 1;\n            if (index == 0) {\n                if (tmp != vec.end()) {\n                    dis = min(vec.back() - vec[index], n - (vec.back() - vec[index]));\n                }\n            }\n            else if (index > 0) {\n                dis = min(vec[index] - vec[index - 1], n - (vec[index] - vec[index - 1]));\n            }\n\n            // 后\n            if (tmp != vec.end()) {\n                if (dis > (vec[index + 1] - vec[index])) {\n                    dis = min({ vec[index + 1] - vec[index], n - (vec[index + 1] - vec[index]) ,dis });\n                }\n            }\n            else {\n                if (pos != vec.begin()) {\n                    dis = min({ vec[index] - *vec.begin(), n - (vec[index] - *vec.begin()) ,dis });\n                }\n            }\n            if (dis == INT_MAX)dis = -1;\n            ans.push_back(dis);\n        }\n        return ans;\n    }\n}; \n","author":"MR_LZ","submissionId":"611239462"},[]]},{"1671":[{"id":"1671","fileName":"611239583.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>> mp;\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        for(auto q:queries){\n            auto &vt = mp[nums[q]];\n            auto iter = lower_bound(vt.begin(),vt.end(),q);\n            int mindis=-1;\n            if(iter!=vt.begin()){\n                auto last=iter-1;\n                mindis = q-*last;\n                int tmp=vt[0];\n                mindis = min(mindis,int(nums.size()-q+tmp));\n            }else if(vt.size()>1){\n                auto lastp = *(vt.end()-1);\n                mindis = nums.size()-lastp+q;\n            }\n            auto next=iter+1;\n            if(next!=vt.end()){\n                if(mindis==-1){\n                    mindis=*next-q;\n                }else{\n                    mindis=min(mindis,*next-q);\n                }\n                \n            }\n            ans.push_back(mindis);\n        }\n        return ans;\n    }\n};","author":"apocalypse","submissionId":"611239583"},[]]},{"1672":[{"id":"1672","fileName":"611239605.txt","sourceCode":"class Solution {\nmap<int, int> hash;\nint suf[200005];\nint pre[200005];\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n = nums.size();\n        int m = q.size();\n        vector<int> ans(m, -1);\n        for(int i = 2 * (n - 1); i >= 0; i--)\n            {\n                if(hash.count(nums[i % n]) && i + n != hash[nums[i % n]])\n                    suf[i] = hash[nums[i % n]];\n                else suf[i] = -1;\n                // if(i == 0) cout << hash[nums[0]] << \" \" << suf[0];\n                hash[nums[i % n]] = i;\n            }\n        for(int i = 0; i < m; i++)\n            if(suf[q[i]] != -1)\n            ans[i] = suf[q[i]] - q[i];\n        hash.clear();\n        for(int i = 0; i < 2 * n; i++)\n            {\n                if(hash.count(nums[i % n]) && i - n != hash[nums[i % n]])\n                    pre[i] = hash[nums[i % n]];\n                else pre[i] = -1;\n                hash[nums[i % n]] = i;\n            }\n        // cout << pre[7];\n        for(int i = 0; i < m; i++)\n            if(pre[q[i] + n] != -1)\n            {\n                if(ans[i] == -1)\n                    ans[i] = q[i] + n - pre[q[i]+ n];\n                else\n                    ans[i] = min(ans[i], q[i] + n - pre[q[i]+ n]);\n            }\n        return ans;\n    }\n};","author":"White","submissionId":"611239605"},[]]},{"1673":[{"id":"1673","fileName":"611239640.txt","sourceCode":"from collections import defaultdict\nfrom bisect import bisect_left\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        table = defaultdict(list)\n        answer = []\n        for index,num in enumerate(nums):\n            table[num].append(index)\n\n        for q in queries:\n            num_q = nums[q]\n            index_q = table[num_q]\n    \n            if len(index_q) < 2:\n                answer.append(-1)\n            else:\n                length = float('inf')\n                iq = bisect_left(index_q, q)\n                for i in [index_q[iq-1], index_q[(iq+1) % len(index_q)]]:\n                    length = min(length, abs(i - q))\n                    length = min(length, n - abs(i - q))\n                answer.append(length)\n        return answer\n            \n        \n        ","author":"fanxing","submissionId":"611239640"},[]]},{"1674":[{"id":"1674","fileName":"611239662.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = {}\n        ans = []\n        for i,v in enumerate(nums):\n            if v in d:\n                d[v].append(i)\n            else:\n                d[v] = [i]\n        # print(d)\n        for i in queries:\n            v = nums[i]\n            if len(d[v])==1:\n                ans.append(-1)\n                continue\n            x = d[v]\n            l,r = -1,len(x)\n            while l +1 <r:\n                m = (l+r)//2\n                if x[m]<=i:\n                    l = m\n                else:\n                    r = m\n            if l == len(x)-1:\n                ans.append(min(len(nums)-x[-1]+x[0],x[-1]-x[-2]))\n            elif l == 0:\n                ans.append(min(x[0]+len(nums)-x[-1],x[1]-x[0]))\n            else:\n                ans.append(min(x[l]-x[l-1],x[l+1]-x[l]))\n        return ans","author":"NCU_jack","submissionId":"611239662"},[]]},{"1675":[{"id":"1675","fileName":"611239730.txt","sourceCode":"class Solution {\npublic:\n    map<int, vector<int>> mp;\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        for(int i = 0; i < 2*n; ++i){\n            mp[nums[i%n]].emplace_back(i);\n        }\n        vector<int> ans;\n        for(const auto& x: queries){\n            if(mp[nums[x]].size() == 2){\n                ans.emplace_back(-1);\n            }else{\n                int y = (x==0?n: x);                \n                auto iter = std::lower_bound(mp[nums[x]].begin(), mp[nums[x]].end(), y);\n                int id =iter-mp[nums[x]].begin();\n                if(id == 0){\n                    auto iter = std::lower_bound(mp[nums[x]].begin(), mp[nums[x]].end(), y+n);\n                    id = iter-mp[nums[x]].begin();\n                }\n               int k = nums[x];\n              \n                int a = abs(mp[k][id] - mp[k][id-1]);\n                int b = abs(mp[k][id+1] -mp[k][id]);\n                ans.emplace_back(min(a,b));\n            }\n        }\n        return ans;\n    }\n};","author":"Monad","submissionId":"611239730"},[]]},{"1677":[{"id":"1677","fileName":"611239828.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> ans = new ArrayList<>();\n        Map<Integer , TreeSet<Integer>> map = new TreeMap<>();\n        for(int i = 0 ; i < nums.length ; i++){\n            TreeSet<Integer> ts = map.getOrDefault(nums[i] , new TreeSet<>());\n            ts.add(i);\n            map.put(nums[i] , ts);\n        }\n        for(int q : queries){\n            int x = nums[q];\n            TreeSet<Integer> ts = map.getOrDefault(x , new TreeSet<>());\n            if(ts.size() == 1){\n                ans.add(-1);\n                continue;\n            }else{\n                Integer less = ts.floor(q - 1) , more = ts.ceiling(q + 1);\n                if(more == null){\n                    more = ts.first() + nums.length;\n                }\n                if(less == null){\n                    less = - nums.length + ts.last();\n                }\n                int a = Integer.MAX_VALUE / 2 , b = Integer.MAX_VALUE / 2;\n                int dist = Integer.MAX_VALUE / 2;\n                if(less != null){\n                    \n                    a = Math.min(q - less , less + nums.length - q);\n                    dist = Math.min(dist , a);\n                }\n                if(more != null){\n                    b = Math.min(more - q , q + nums.length - more);\n                    dist = Math.min(dist , b);\n                }\n                // ans.add(a > b ? more : less);\n                ans.add(dist);\n            }\n        }\n        return ans;\n    }\n}","author":"spalatendooo","submissionId":"611239828"},[]]},{"1679":[{"id":"1679","fileName":"611239800.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int mx = nums[0], n = nums.size(), m = queries.size();\n        for(int v: nums) mx = max(v, mx);\n        vector<int> v2idx(mx + 1, -1);\n        vector<int> first_v2idx(mx + 1, -1);\n        \n        vector<int> nearest(n, -1);\n        for(int i = 0, j; i < n; ++i){\n            j = v2idx[nums[i]];\n            if(j != -1){\n                int k = first_v2idx[nums[i]];\n                nearest[i] = min(i - j, k + n - i);\n                nearest[j] = nearest[j] == -1 ? min(i - j, j + n - i): min(nearest[j], min(i - j, j + n - i));\n                nearest[k] = min(nearest[k], k + n - i);\n            }\n            else first_v2idx[nums[i]] = i;\n            v2idx[nums[i]] = i;\n        }\n        vector<int> ans(m, -1);\n        for(int i = 0; i < m; ++i){\n            ans[i] = nearest[queries[i]]; \n        }\n        return ans;\n    }\n};","author":"IN0vation","submissionId":"611239800"},[]]},{"1680":[{"id":"1680","fileName":"611239858.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n\trecords := make(map[int][]int)\n\tl := len(nums)\n\tans := make([]int, len(queries))\n\tfor i, num := range nums {\n\t\trecords[num] = append(records[num], i)\n\t}\n\tfor i, query := range queries {\n\t\trecord := records[nums[query]]\n\t\tn := len(record)\n\t\tindex := 0\n\t\tif n == 1 {\n\t\t\tans[i] = -1\n\t\t\tcontinue\n\t\t}\n\t\tfor record[index] != query {\n\t\t\tindex++\n\t\t}\n\t\tif index == n-1 {\n\t\t\t//fmt.Println(query-record[n-2], n-query+record[0])\n\t\t\tans[i] = min(query-record[n-2], l-query+record[0])\n\t\t} else if index == 0 {\n\t\t\t//fmt.Println(record)\n\t\t\t//fmt.Println(index,query,record[1]-query, query+l-record[n-1])\n\t\t\tans[i] = min(record[1]-query, query+l-record[n-1])\n\t\t} else {\n\t\t\t//fmt.Println(query-record[index-1], record[index+1]-query)\n\t\t\tans[i] = min(query-record[index-1], record[index+1]-query)\n\t\t}\n\n\t}\n\treturn ans\n}\n","author":"something  for   nothing","submissionId":"611239858"},[]]},{"1681":[{"id":"1681","fileName":"611239823.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int> >  List;\n        int n = nums.size();\n        for(int i=0; i<nums.size(); i++)\n            List[ nums[i] ].push_back(i);\n\n        vector<int> ans;\n        for(int query : queries){\n            int tgt = nums[query];\n            if(List[tgt].size()==1)\n                ans.push_back(-1);\n            else{\n                auto it= lower_bound(List[tgt].begin(), List[tgt].end(), query);\n                int dist = 0x3f3f3f3f;\n                if(it+1 != List[tgt].end())\n                    dist = min(dist, abs(query - *(it+1)));\n                else dist = min(dist, abs(List[tgt].front()+n-query));\n\n                if(it != List[tgt].begin())\n                    dist = min(dist, abs(query - *(it-1)));\n                else dist = min(dist, abs(query+n-List[tgt].back()));\n\n                ans.push_back(dist);\n            }\n        }\n        return ans;\n    }\n};","author":"pointedpoints","submissionId":"611239823"},[]]},{"1682":[{"id":"1682","fileName":"611239852.txt","sourceCode":"class Solution {\n    int left(List<Integer> list,int l,int r,int t){\n        int res = -1;\n        while(l<=r){\n            int m = (l + r) /2;\n            int idx = list.get(m);\n            if(idx < t){\n                res = idx;\n                l = m + 1;\n            }else{\n                r = m - 1;\n            }\n        }\n        return res;\n    }\n    int right(List<Integer> list,int l,int r,int t){\n        int res = -1;\n        while(l<=r){\n            int m = (l + r) /2;\n            int idx = list.get(m);\n            if(idx > t){\n                res = idx;\n                r = m - 1;\n            }else{\n                l = m + 1;\n            }\n        }\n        return res;\n    }\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> ans = new ArrayList<>();\n        int n = nums.length;\n        Map<Integer,List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int num = nums[i];\n            List<Integer> list = map.getOrDefault(num,new ArrayList<>());\n            list.add(i);\n            map.put(num,list);\n        }\n        for(int idx : queries){\n            int num = nums[idx];\n            List<Integer> list = map.get(num);\n            int size = list.size();\n            if(size == 1){\n                ans.add(-1);\n            }else{\n                int l = left(list,0,size-1,idx);\n                int mn = 10000000;\n                if(l !=-1){\n                    mn = Math.min(mn,Math.min(idx - l,n - idx + l));\n                }else{\n                    if(list.get(size - 1) != idx){\n                        int r = list.get(size - 1);\n                        mn = Math.min(mn,Math.min(r - idx,n + idx - r));\n                    }\n                }\n                int r = right(list,0,size-1,idx);\n                if(r !=-1){\n                    mn = Math.min(mn,Math.min(r - idx,n + idx - r));\n                }else{\n                    if(list.get(0) != idx){\n                        l = list.get(0);\n                        mn = Math.min(mn,Math.min(idx - l,n - idx + l));\n                    }\n                }\n                ans.add(mn);\n            }\n        }\n        return ans;\n    }\n}","author":"yangwei","submissionId":"611239852"},[]]},{"1683":[{"id":"1683","fileName":"611240058.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        int n = a.size(), inf = 1e9, m = n << 1;\n        for (int i = 0; i < n; i++) a.push_back(a[i]);\n        \n        vector<int> f(n, inf);\n        unordered_map<int, int> h;\n        for (int i = 0, j = 0; i < m; i++) {\n            if (h.count(a[i])) f[i % n] = min({f[i % n], i - h[a[i]], n - i + h[a[i]]});\n            \n            h[a[i]] = i;\n            if (i >= n && h[a[j]] == j) h.erase(a[j++]);\n        }\n\n        h.clear();\n        for (int i = m - 1, j = m - 1; ~i; i--) {\n            if (h.count(a[i])) f[i % n] = min({f[i % n], h[a[i]] - i, n - h[a[i]] + i});\n            h[a[i]] = i;\n            if (i < n && h[a[j]] == j) h.erase(a[j++]);\n        }\n\n        vector<int> ans;\n        for (int &x : q) ans.push_back(!f[x] ? -1 : f[x]);\n        return ans;\n    }\n};","author":"神秘人3hd","submissionId":"611240058"},[]]},{"1684":[{"id":"1684","fileName":"611240035.txt","sourceCode":"\nclass Solution {\npublic:\nmap<int,vector<int>>mp;\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        for(int i = 0;i < nums.size();i++){\n            mp[nums[i]].push_back(i);\n        }\n        int n = nums.size();\n        int qn = queries.size();\n        vector<int>ans(qn);\n        int i = 0;\n        for(int q : queries){\n            int id = nums[q];\n            int mn = mp[id].size();\n            int mi = lower_bound(mp[id].begin(),mp[id].end(),q) - mp[id].begin();\n            if(mn == 1)ans[i] = -1;\n            else {\n                ans[i] = min(abs(q - mp[id][(mi + 1) % mn]),\n                    abs(q - mp[id][(mi - 1 + mn) % mn]));\n                ans[i] = min(mp[id][0] + n - q,ans[i]);\n                ans[i] = min(q + n - mp[id].back(),ans[i]);\n            }\n                i++;\n        }\n        return ans;\n    }\n};","author":"千数","submissionId":"611240035"},[]]},{"1686":[{"id":"1686","fileName":"611240070.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> list;\n        unordered_map<int, int> pos;\n\n        for (int i = 0; i < nums.size(); i++) {\n            pos[i]=list[nums[i]].size();\n            list[nums[i]].push_back(i);\n        }\n        int n = nums.size();\n        vector<int> ans;\n        for (auto q : queries) {\n            int p = pos[q], v = nums[q];\n            auto &l = list[v];\n            if (l.size() <= 1) ans.push_back(-1);\n            else {\n                int cd = l[0] + n - l.back();\n                int fp = !p ? cd : l[p] - l[p - 1];\n                int bp = p == l.size() - 1 ? cd : l[p + 1] - l[p];\n                ans.push_back(min(fp, bp));\n            }\n        }\n        return ans;\n    }\n};","author":"ssayzx","submissionId":"611240070"},[]]},{"1687":[{"id":"1687","fileName":"611240060.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dict = {}\n        for i,n in enumerate(nums):\n            if n in dict:\n                dict[n].append(i)\n            else:\n                dict.update({n: [i]})\n\n        ans = [inf] * len(nums)\n        l2 = len(nums)\n        for k, v in dict.items():\n            l = len(v)\n            for i in range(1, l):\n                x, y = v[i] , v[i-1]\n                delta = min(x - y, l2 + y - x)\n                ans[x] = min(ans[x], delta)\n                ans[y] = min(ans[y], delta)\n                # print(v, delta,i, ans)\n            if l > 1:\n                x, y =  v[-1],v[0]\n                delta = min(x - y, l2 + y - x)\n                ans[x] = min(ans[x], delta)\n                ans[y] = min(ans[y], delta)\n\n        return [ans[q] if ans[q] < inf else -1 for q in queries]\n                \n            ","author":"程俊宏","submissionId":"611240060"},[]]},{"1688":[{"id":"1688","fileName":"611240186.txt","sourceCode":"function solveQueries(nums: number[], queries: number[]): number[] {\n  const map = new Map();\n  const n = nums.length;\n  for (let i = 0; i < n; ++i) {\n    if (!map.has(nums[i])) {\n      map.set(nums[i], []);\n    }\n    map.get(nums[i]).push(i);\n  }\n  return queries.map((query) => {\n    const target = nums[query];\n    const idxList = map.get(target);\n    if (idxList.length === 1) {\n      return -1;\n    }\n    // 二分法找到 idxList 中 query 的位置\n    let i = binarySearch(idxList, query);\n    const leftIdx = i > 0 ? idxList[i - 1] : idxList[idxList.length - 1];\n    const rightIdx = i < idxList.length - 1 ? idxList[i + 1] : idxList[0];\n    return Math.min((query - leftIdx + n) % n, (rightIdx - query + n) % n);\n  });\n}\n\nfunction binarySearch(list: number[], target: number) {\n  let left = 0;\n  let right = list.length - 1;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (list[mid] === target) {\n      return mid;\n    }\n    if (list[mid] > target) {\n      right = mid - 1;\n    } else {\n      left = mid + 1;\n    }\n  }\n  return -1;\n}\n","author":"BvVeMRGl","submissionId":"611240186"},[]]},{"1689":[{"id":"1689","fileName":"611239864.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[]} queries\n * @return {number[]}\n */\nvar solveQueries = function(nums, queries) {\n    let n = nums.length\n    let map = new Map()\n    let ans = new Array(n).fill(-1)\n    for(let i = 0; i < n; i++) {\n        let num = nums[i]\n        if(map.has(num)) {\n            let [first, last] = map.get(num)\n            let dis = i - last\n            \n            ans[i] = Math.min(dis, n - i + first)\n            \n\n            if(ans[last] === -1) {\n                ans[last] = dis\n            } else {\n                ans[last] = Math.min(ans[last], dis)\n            }\n\n            ans[first] = Math.min(ans[first], n - i + first)\n        } else {\n            map.set(num, [i, i])\n        }\n\n        map.get(num)[1] = i\n    }\n\n    let m = queries.length\n    let res = new Array(m).fill(-1)\n    for(let i = 0; i < m; i++) {\n        let idx = queries[i]\n        res[i] = ans[idx]\n    }\n\n    return res\n};","author":"Xuelong","submissionId":"611239864"},[]]},{"1690":[{"id":"1690","fileName":"611240212.txt","sourceCode":"/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* solveQueries(int* nums, int numsSize, int* queries, int queriesSize,\n                  int* returnSize) {\n    int* ans = (int*)malloc(sizeof(int) * queriesSize);\n    int hash[1000005] = {0};\n    memset(hash,-1,sizeof(int));\n    int pre_sum[100005] = {0}, rear[100005] = {0};\n    int* arr = (int*)malloc(sizeof(int) * numsSize * 2);\n    for (int i = 0, j = 0; i < numsSize * 2; i++) {\n        arr[i] = nums[j++];\n        if (j == numsSize)\n            j = 0;\n    }\n    for(int i=0;i<numsSize*2;i++)\n    {\n        if(hash[arr[i]]==-1)pre_sum[i%numsSize]=numsSize;\n        else pre_sum[i%numsSize]=abs(i-hash[arr[i]]);\n        hash[arr[i]]=i;\n    }\n     memset(hash,-1,sizeof(int));\n     for(int i=numsSize*2-1;i>=0;i--)\n    {\n        if(hash[arr[i]]==-1)rear[i%numsSize]=numsSize;\n        else rear[i%numsSize]=abs(i-hash[arr[i]]);\n        hash[arr[i]]=i;\n    }\n    *returnSize = queriesSize;\n    for (int i = 0; i < queriesSize; i++) {\n        ans[i]=fmin(pre_sum[queries[i]],rear[queries[i]])==numsSize?-1:fmin(pre_sum[queries[i]],rear[queries[i]]);\n    }\n    return ans;\n}","author":"别看了我在打游戏","submissionId":"611240212"},[]]},{"1691":[{"id":"1691","fileName":"611240340.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n=len(nums)\n        m=len(queries)\n        mp=defaultdict(list)\n        mp2={}\n        for i in range(n):\n            mp[nums[i]].append(i)\n            mp2[i]=len(mp[nums[i]])-1\n        res=[float('inf')]*m\n        for i in range(m):\n            x=queries[i]\n            index=mp2[x]\n            y=nums[x]\n            if len(mp[y])==1:\n                res[i]=-1\n                continue\n            l=len(mp[y])\n            a=len(mp[y])-1 if index==0 else index-1\n            b=0 if index==len(mp[y])-1 else index+1\n            if a!=index:res[i]=min(res[i],abs(mp[y][a]-mp[y][index]),n-abs(mp[y][a]-mp[y][index]))\n            if b!=index:res[i]=min(res[i],abs(mp[y][b]-mp[y][index]),n-abs(mp[y][b]-mp[y][index]))\n        return res","author":"郑涵予","submissionId":"611240340"},[]]},{"1692":[{"id":"1692","fileName":"611240386.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        pos=defaultdict(list)\n        for i,x in enumerate(nums):\n            pos[x].append(i)\n        n=len(nums)\n        ans=[]\n        for i,x in enumerate(queries):\n            ii=x\n            x=nums[x]\n            dis=inf\n            idx=bisect_left(pos[x],ii)\n            \n            if idx+1<len(pos[x]):\n                j=pos[x][idx+1]\n                dis=min(dis,min(j-ii,ii+(n-pos[x][-1]))) \n            if idx-1>=0:\n                j=pos[x][idx-1]\n                dis=min(dis,min(ii-j,n-ii+pos[x][0]))\n            ans.append(dis if dis!=inf else -1)\n            \n        return ans ","author":"Optimistic SutherlandOg9","submissionId":"611240386"},[]]},{"1693":[{"id":"1693","fileName":"611240350.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& n, vector<int>& q) {\n        int sz = n.size(); vector<int> ans(q.size());\n        vector<int> cp(n.begin(), n.end());\n        sort(cp.begin(), cp.end());\n        cp.erase(unique(cp.begin(), cp.end()), cp.end());\n        auto get = [&](int x) -> int {\n            return lower_bound(cp.begin(), cp.end(), x) - cp.begin();  \n        };\n        vector<int> mp[cp.size()];\n        for (int i = 0; i < sz; ++ i) {\n            mp[get(n[i])].emplace_back(i);\n        }\n        for (int i = 0; i < q.size(); ++ i) {\n            int loc = get(n[q[i]]);\n            vector<int> &v = mp[loc];\n            if (v.size() == 1) {\n                ans[i] = -1;\n                continue;\n            }\n            auto it = lower_bound(v.begin(), v.end(), q[i]) - v.begin();\n            int left = it > 0 ? v[it] - v[it - 1] : sz - v.back() + v[it];\n            int right = it + 1 < v.size() ? v[it + 1] - v[it] : sz - v[it] + v.front();\n            ans[i] = min(left, right);\n        }\n        return ans;\n    }\n};","author":"恣睢","submissionId":"611240350"},[]]},{"1694":[{"id":"1694","fileName":"611240458.txt","sourceCode":"/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\n#define LEN 100002\n#define VOL 1000002\nint* solveQueries(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize) {\n    int* ans = (int*)malloc(sizeof(int) * queriesSize);\n    *returnSize = queriesSize;\n\n    // bucket[i]: the last index of element i shows.\n    int bucket[VOL];\n    memset(bucket, -1, sizeof(int) * VOL);\n\n    int rec[numsSize];\n    int newNums[2 * numsSize];\n    for(int i = 0;i < numsSize; i++){\n        newNums[i] = newNums[i + numsSize] = nums[i];\n        rec[i] = -1;\n    }\n\n    for(int i = 0;i < 2 * numsSize; i++){\n        int ind = bucket[newNums[i]];\n        if(ind >= numsSize) continue;\n        if(ind != -1 && i - ind < numsSize){\n            rec[ind] = i - ind;\n        }\n        bucket[newNums[i]] = i;\n    }\n\n    memset(bucket, -1, sizeof(int) * VOL);\n\n    for(int i = 2 * numsSize - 1; i >= 0; i--){\n        int ind = bucket[newNums[i]];\n        if(ind != -1 && ind - i < numsSize){\n            rec[ind % numsSize] = fmin(rec[ind % numsSize],  ind - i);\n        }\n        bucket[newNums[i]] = i;\n    }\n\n    for(int i = 0;i < queriesSize; i++){\n        ans[i] = rec[queries[i]];\n    }\n    return ans;\n}","author":"MuJue","submissionId":"611240458"},[]]},{"1696":[{"id":"1696","fileName":"611240448.txt","sourceCode":"class Solution {\n public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer,List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n        }\n        int n = nums.length;\n        List<Integer> ans = new ArrayList<>();\n        for (int i = 0; i < queries.length; i++) {\n            if (!map.containsKey(nums[queries[i]])) {\n                ans.add(-1);\n                continue;\n            }\n            int t = nums[queries[i]];\n            int x = queries[i];\n            List<Integer> list = map.get(t);\n            if (list.size() == 1){\n                ans.add(-1);\n                continue;\n            }\n            int sz = list.size();\n            int y = lowerBound(list, x);\n            int tmp = Integer.MAX_VALUE;\n            int next = (y + 1) % sz;\n            int pre = (y - 1 + sz) % sz;\n            // 比较距离哪个更近，注意是循环数组\n            tmp = Math.min(tmp,(x - list.get(next) + n) % n);\n            tmp = Math.min(tmp,(list.get(next) - x + n) % n);\n            tmp = Math.min(tmp,(x - list.get(pre) + n) % n);\n            tmp = Math.min(tmp,(list.get(pre) - x + n) % n);\n\n            ans.add(tmp);\n        }\n        return ans;\n    }\n\n    private int lowerBound(List<Integer> list,int t){\n        int l = 0,r = list.size() - 1;\n        while( l<=r){\n            int m = l + r >>> 1;\n            if (list.get(m) >= t) r = m - 1;\n            else l = m + 1;\n        }\n        return l;\n    }\n}","author":"酷到没脾气","submissionId":"611240448"},[]]},{"1697":[{"id":"1697","fileName":"611240263.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int  n=nums.size();\n        unordered_map<int,vector<int>>   rem;\n        for(int i=0;i<n;i++){\n            rem[nums[i]].push_back(i);\n        }\n        vector<int>  res;\n        for(int   qq:queries){\n            int  val=nums[qq];\n            if(rem[val].size()==1){\n                res.push_back(-1);\n            }else{\n                vector<int>  &cur=rem[val];\n                auto item=lower_bound(cur.begin(),cur.end(),qq);\n                auto nxt=next(item);\n                int minStep=INT_MAX;\n                if(nxt==cur.end()){\n                    nxt=cur.begin();\n                    auto pre=prev(item);\n                    minStep=min(n+*nxt-qq,qq-*pre);\n                }else if(item==cur.begin()){\n                    auto pre=cur.rbegin();\n                    minStep=min(*nxt-qq,n-*pre+qq);\n                }else{\n                    auto pre=prev(item);\n                    minStep=min(qq-*pre,*nxt-qq);\n                }\n                res.push_back(minStep);\n            }\n        }\n        return  res;\n        \n    }\n};","author":"Dong","submissionId":"611240263"},[]]},{"1698":[{"id":"1698","fileName":"611240476.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> left(n * 3, -1), right(n * 3, -1);\n        for (int i = 0; i < n; i++) {\n            nums.push_back(nums[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            nums.push_back(nums[i]);\n        }\n        unordered_map<int, int> mp;\n        mp[nums[0]] = 0;\n        for (int i = 1; i < n * 3; i++) {\n            if (mp.count(nums[i])) {\n                left[i] = mp[nums[i]];\n            }\n            mp[nums[i]] = i;\n        }\n        mp.clear();\n        mp[nums[n * 3 - 1]] = n * 3 - 1;\n        for (int i = n * 3 - 2; i >= 0; i--) {\n            if (mp.count(nums[i])) {\n                right[i] = mp[nums[i]];\n            }\n            mp[nums[i]] = i;\n        }\n        int m = queries.size();\n        vector<int> ans(m, INT_MAX);\n        for (int i = 0; i < m; i++) {\n            int x = queries[i];\n            if (left[x + n] == -1 && right[x + n] == -1) {\n                ans[i] == -1;\n            }\n            if (left[x + n] != -1) {\n                ans[i] = min(ans[i], x + n - left[x + n]);\n            }\n            if (right[x + n] != -1) {\n                ans[i] = min(ans[i], right[x + n] - x - n);\n            }\n            if (ans[i] == n) {\n                ans[i] = -1;\n            }\n        }\n        return ans;\n    }\n};","author":"pumpkin","submissionId":"611240476"},[]]},{"1699":[{"id":"1699","fileName":"611240489.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n=len(nums)\n        ans=[-1]*n\n        gra=defaultdict(list)\n        for i, num in enumerate(nums):\n            gra[num].append(i)\n        for a in gra.values():\n            if len(a)<2:\n                continue \n            a.sort()\n            sz=len(a)\n            for j in range(sz):\n                cur=a[j]\n                if j==0:\n                    l=a[0]+n-a[sz-1]\n                    r=a[1]-a[0]\n                elif j==sz - 1:\n                    l=a[sz-1]-a[sz-2]\n                    r=a[0]+n-a[sz-1]\n                else:\n                    l=a[j]-a[j-1]\n                    r=a[j+1]-a[j]\n                ans[cur]=min(l,r)\n        return [ans[i] for i in queries]","author":"情初","submissionId":"611240489"},[]]},{"660":[{"id":"660","fileName":"1575121996.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        int[] minDis = new int[n];\n        Arrays.fill(minDis, Integer.MAX_VALUE);\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < n * 2; i++) {\n            int num = nums[i % n];\n            if (map.containsKey(num)) {\n                int lastIdx = map.get(num);\n                if (lastIdx >= n || i - lastIdx >= n) {\n                    continue;\n                }\n                minDis[lastIdx] = Math.min(minDis[lastIdx], i - lastIdx);\n                minDis[i % n] = Math.min(minDis[i % n], i - lastIdx);\n            }\n            map.put(num, i);\n        }\n        List<Integer> res = new ArrayList<>();\n        for (int i = 0; i < queries.length; i++) {\n            res.add(minDis[queries[i]] == Integer.MAX_VALUE ? -1 : minDis[queries[i]]);\n        }\n        return res;\n    }\n}","author":"zheruilin","submissionId":"1575121996"},[{"id":"660","similarity":0.7581699346405228,"totOverlap":116,"longestOverlap":23}]],"1700":[{"id":"1700","fileName":"611240478.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        //记录最小距离\n        int[] minD = new int[n];\n        Arrays.fill(minD, Integer.MAX_VALUE);\n        //上一次出现的位置\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < n * 2 - 1; i++){\n            int j = i % n;\n            //离得最近的，当前下标是j，需要找与j相同的下标\n            int idx = map.getOrDefault(nums[j], -1);\n            if (idx != -1 && (idx % n) != j){\n                minD[j] = Math.min(minD[j], Math.abs(idx - i));\n                minD[idx % n] = Math.min(minD[idx % n], Math.abs(idx - i));\n            }\n            map.put(nums[j], i);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int i = 0; i < queries.length; i++){\n            ans.add(minD[queries[i]] == Integer.MAX_VALUE ? -1 : minD[queries[i]]);\n        }\n        return ans;\n    }\n}","author":"藏","submissionId":"611240478"},[{"id":"1758","similarity":0.7262569832402235,"totOverlap":130,"longestOverlap":14},{"id":"1700","similarity":0.7581699346405228,"totOverlap":116,"longestOverlap":23}]],"1758":[{"id":"1758","fileName":"611242026.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> res = new ArrayList<>();\n        int n = nums.length;\n        int[] arr = new int[n];\n        Arrays.fill(arr, Integer.MAX_VALUE);\n        Map<Integer, Integer> first = new HashMap<>();\n        Map<Integer, Integer> pre = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int num = nums[i];\n            if (!first.containsKey(num)) {\n                first.put(num, i);\n                pre.put(num, i);\n            } else {\n                int preN = pre.get(num);\n                int firstN = first.get(num);\n\n                int p = i - preN;\n                int f = (firstN + n) - i;\n\n                arr[preN] = Math.min(arr[preN], p);\n                arr[i] = Math.min(arr[i], p);\n                arr[firstN] = Math.min(arr[firstN], f);\n                arr[i] = Math.min(arr[i], f);\n\n                pre.put(num, i);\n            }\n        }\n\n        for (int i = 0; i < queries.length; i++) {\n            res.add(arr[queries[i]] == Integer.MAX_VALUE ? -1 : arr[queries[i]]);\n        }\n        return res;\n    }\n}","author":"wsw","submissionId":"611242026"},[{"id":"1700","similarity":0.7262569832402235,"totOverlap":130,"longestOverlap":14}]]},{"969":[{"id":"969","fileName":"1575129761.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int m = queries.size();\n        int n = nums.size();\n        vector<int> ans(m, n);\n\n        unordered_map<int, vector<int>> mp;\n        for(int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        int x = 0;\n\n        for(int i:queries) {\n            if(mp[nums[i]].size() == 1) {\n                ans[x] = -1;\n                x++;\n                continue;\n            }\n            auto it = lower_bound(mp[nums[i]].begin(), mp[nums[i]].end(), i);\n            auto next = it;\n            next++;\n            if(next != mp[nums[i]].end()) ans[x] = min(ans[x], *next - i);\n            if(it != mp[nums[i]].begin()) {\n                it--;\n                ans[x] = min(ans[x], i - *it);\n            }\n            if(mp[nums[i]].back() != i)\n            {\n                ans[x] = min(ans[x], i + n - 1 - mp[nums[i]].back() + 1);\n            }\n            if(mp[nums[i]][0] != i)\n            {\n                ans[x] = min(ans[x], mp[nums[i]][0] + n - 1 - i + 1);\n            }\n            x++;\n        }\n        return ans;\n    }\n};","author":"curious_04","submissionId":"1575129761"},[{"id":"969","similarity":0.7115384615384616,"totOverlap":185,"longestOverlap":12}]],"1701":[{"id":"1701","fileName":"611240528.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        int n = a.size();\n        map<int, vector<int> > pos;\n        for(int i = 0; i < n; i++) {\n            pos[a[i]].push_back(i);\n        }\n        for(int i = 0; i < n; i++) {\n            pos[a[i]].push_back(i + n);\n        }\n        int m = q.size();\n        vector<int> ans(m, 1e6);\n        for(int i = 0; i < m; i++) {\n            int p = q[i];\n            if(pos[a[p]].size() == 2) {\n                ans[i] = -1;\n                continue;\n            }\n            auto it_l = lower_bound(pos[a[p]].begin(), pos[a[p]].end(), p);\n            if(it_l != pos[a[p]].begin()) {\n                it_l--;\n                ans[i] = min(ans[i], p - *it_l);\n                //ans[i] = min(ans[i], n - p + *it_l);\n            }\n            auto it_r = upper_bound(pos[a[p]].begin(), pos[a[p]].end(), p);\n            if(it_r != pos[a[p]].end()) {\n                ans[i] = min(ans[i], *it_r - p);\n                //ans[i] = min(ans[i], n - *it_r + p);\n            }\n            it_l = lower_bound(pos[a[p]].begin(), pos[a[p]].end(), p + n);\n            if(it_l != pos[a[p]].begin()) {\n                it_l--;\n                ans[i] = min(ans[i], p + n - *it_l);\n                //ans[i] = min(ans[i], n - p + *it_l);\n            }\n            it_r = upper_bound(pos[a[p]].begin(), pos[a[p]].end(), p+n);\n            if(it_r != pos[a[p]].end()) {\n                ans[i] = min(ans[i], *it_r - (p+n));\n                //ans[i] = min(ans[i], n - *it_r + p);\n            }\n        }\n        return ans;\n    }\n};","author":"shi_logic","submissionId":"611240528"},[{"id":"1892","similarity":0.7298245614035088,"totOverlap":208,"longestOverlap":23},{"id":"1701","similarity":0.7115384615384616,"totOverlap":185,"longestOverlap":12}]],"1892":[{"id":"1892","fileName":"611248640.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> m;\n        for(int i = 0; i < n; ++i){\n            m[nums[i]].push_back(i);\n        }\n        unordered_map<int, int> m2;\n        for(auto& [num, v] : m){\n            int tmp = INT_MAX;\n            for(int i = 1; i < v.size(); ++i){\n                tmp = min(tmp, v[i] - v[i - 1]);\n            }\n            if(v.size() > 1){\n                tmp = min(tmp, v[0] + (n - v.back()));\n            }\n            m2[num] = tmp;\n        }\n        vector<int> ans(queries.size(), INT_MAX);\n        for(int i = 0; i < queries.size(); ++i){\n        \n            int index = queries[i];\n            if(m[nums[index]].size() < 2){\n                ans[i] = -1;\n            }\n            auto it = lower_bound(m[nums[index]].begin(), m[nums[index]].end(), index);\n            auto it2 = upper_bound(m[nums[index]].begin(), m[nums[index]].end(), index);\n            if(it2 != m[nums[index]].end()){\n                ans[i] = *it2 - *it;\n            }\n            if(it != m[nums[index]].begin()){\n                ans[i] = min(ans[i], *it - *(it - 1));\n                // cout << i << \" \" << *(it - 1)<< endl;\n            \n            }\n            if(it == m[nums[index]].begin() || it2 == m[nums[index]].end()){\n                // cout << \"a\" << endl;\n                ans[i] = min(ans[i], m[nums[index]][0] + (n - m[nums[index]].back()));\n            }\n            \n        }\n        return ans;\n    }\n};","author":"橙猫猫","submissionId":"611248640"},[{"id":"1701","similarity":0.7298245614035088,"totOverlap":208,"longestOverlap":23}]]},{"1702":[{"id":"1702","fileName":"611240556.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(queries)\n        m = len(nums)\n        ans = [-1] * n\n        cnt = defaultdict(list)\n        for i, x in enumerate(nums):\n            cnt[x].append(i)\n        for i, x in enumerate(queries):\n            num = nums[x]\n            l = len(cnt[num])\n            if l == 2:\n                idx = bisect_left(cnt[num], x)\n                another = (idx + 1) % l\n                another = cnt[num][another]\n                ans[i] = min(abs(another - x), m - abs(another - x))\n            elif l >= 3:\n                idx = bisect_left(cnt[num], x)\n                left = (idx - 1 + l) % l\n                right = (idx + 1) % l\n                left = cnt[num][left]\n                right = cnt[num][right]\n                left_dx = min(abs(left - x), m - abs(left - x))\n                right_dx = min(abs(right - x), m - abs(right - x))\n                ans[i] = min(left_dx, right_dx)\n        return ans","author":"沐浴阳光","submissionId":"611240556"},[]]},{"1703":[{"id":"1703","fileName":"611240306.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n = nums.size(), m = q.size();\n        unordered_map<int, set<int>> mp;\n        for(int i=0; i<n; i++) {\n            mp[nums[i]].insert(i);\n        }\n        vector<int> ret(m);\n        for(int i=0; i<m; i++) {\n            int x = q[i];\n            int y = nums[q[i]];\n            if(mp.find(y)==mp.end()) {\n                ret[i] = -1;\n                continue;\n            }\n            {\n                auto &v = mp[y];\n                if(v.size()<=1) ret[i] = -1;\n                else {\n                    int d = 1e8;\n                    auto it = v.lower_bound(x);\n                    int pre, next;\n                    auto it2 = it;\n                    if(it!=v.begin()) {\n                        pre = *(--it2);\n                    } else {\n                        pre = *v.rbegin() - n;\n                    }\n                    it2 = it;\n                    //cout << \"111 \" << *it2 << endl;\n                    ++it2;\n                    if(it2!=v.end()) {\n                        next = *(++it);\n                    } else {\n                        next = *v.begin() + n;\n                    }\n                    //cout << \" xxx \" << pre << \" \" << next << endl;\n                    int cur = min(abs(next-x), abs(pre-x));\n                    if(cur>0) ret[i] = cur;\n                    else ret[i] = -1;\n                }\n            }\n        }\n        return ret;\n    }\n};","author":"元春灵秀","submissionId":"611240306"},[]]},{"1704":[{"id":"1704","fileName":"611240594.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dic = defaultdict(list)\n        n = len(nums)\n        for i, v in enumerate(nums):\n            dic[v].append(i)\n        from bisect import bisect_left\n        for i, v in enumerate(queries):\n            if len(dic[nums[v]]) == 1:\n                queries[i] = -1\n            else:\n                ind = bisect_left(dic[nums[v]], v)\n                l = len(dic[nums[v]])\n                a, b = dic[nums[v]][(ind+l-1) % l], dic[nums[v]][(ind+1) % l]\n                queries[i] = min(abs(v-a), abs(v-b), n-abs(v-a), n-abs(v-b))\n        return queries","author":"shimmery_firefly","submissionId":"611240594"},[]]},{"1705":[{"id":"1705","fileName":"611240573.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length, m = queries.length;\n        int u = 0;\n        for (int x : nums) {\n            u = Math.max(u, x);\n        }\n        List<Integer>[] idx = new List[u + 1];\n        Arrays.setAll(idx, i -> new ArrayList<>());\n        for (int i = 0; i < n; i++) {\n            idx[nums[i]].add(i);\n        }\n        List<Integer> ans = new ArrayList<>(m);\n        for (int i = 0; i < m; i++) {\n            List<Integer> list = idx[nums[queries[i]]];\n            if (list.size() < 2) {\n                ans.add(-1);\n            } else {\n                int j = lowerBound(list, queries[i]);\n                int d = n;\n                if (j == 0) {\n                    d = Math.min(list.get(j + 1) - queries[i], n - list.get(list.size() - 1) + list.get(0));\n                } else if (j == list.size() - 1) {\n                    d = Math.min(queries[i] - list.get(j - 1), n - list.get(list.size() - 1) + list.get(0));\n                } else {\n                    d = Math.min(queries[i] - list.get(j - 1), list.get(j + 1) - queries[i]);\n                }\n                ans.add(d);\n            }\n        }\n        return ans;\n\t}\n    private int lowerBound(List<Integer> list, int query) {\n        int l = 0, r = list.size();\n        while (l < r) {\n            int mid = l + (r - l >> 1);\n            if (list.get(mid) < query) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        }\n        return l;\n    }\n}","author":"Holden","submissionId":"611240573"},[]]},{"1706":[{"id":"1706","fileName":"611240572.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        h = {}\n        mind = [-1 for _ in range(len(nums))]\n        for idx, n in enumerate(nums):\n            if n not in h:\n                h[n] = [idx]\n            else:\n                h[n].append(idx)\n        for n, idxs in h.items():\n            if len(idxs) == 1:\n                mind[idxs[0]] = -1\n            else:\n                for i, idx in enumerate(idxs):\n                    if i == 0:\n                        mind[idx] = min(idxs[1]-idx, len(nums)-idxs[-1]+idx)\n                    elif i == len(idxs) - 1:\n                        mind[idx] = min(idx-idxs[-2], len(nums)-idx+idxs[0])\n                    else:\n                        mind[idx] = min(idx - idxs[i-1], idxs[i+1] - idx)\n        answer = []\n        for q in queries:\n            answer.append(mind[q])\n        return answer","author":"芦荟","submissionId":"611240572"},[]]},{"1707":[{"id":"1707","fileName":"611240620.txt","sourceCode":"package main\n\nimport \"sort\"\n\n// https://space.bilibili.com/206214\nfunc solveQueries(a []int, qs []int) (ans []int) {\n\tpos := map[int][]int{}\n\tfor i, v := range a {\n\t\tpos[v] = append(pos[v], i)\n\t}\n\tfor _, q := range qs {\n\t\tv := a[q]\n\t\tps := pos[v]\n\t\tif len(ps) == 1 {\n\t\t\tans = append(ans, -1)\n\t\t\tcontinue\n\t\t}\n\t\tres := int(1e9)\n\t\tj := sort.SearchInts(ps, q+1)\n\t\tif j < len(ps) {\n\t\t\tres = ps[j] - q\n\t\t} else {\n\t\t\tres = len(a) - q + ps[0]\n\t\t}\n\t\tj = sort.SearchInts(ps, q) - 1\n\t\tif j >= 0 {\n\t\t\tres = min(res, q-ps[j])\n\t\t} else {\n\t\t\tres = min(res, len(a)-ps[len(ps)-1]+q)\n\t\t}\n\t\tif res == 1e9 {\n\t\t\tres = -1\n\t\t}\n\t\tans = append(ans, res)\n\t}\n\treturn\n}\n","author":"灵茶山艾府","submissionId":"611240620"},[]]},{"1708":[{"id":"1708","fileName":"611240655.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> m;\n        map<int, int> rm;\n        for (int i = 0; i < nums.size(); i++) {\n            if (m.find(nums[i]) == m.end()) {\n                m[nums[i]] = vector<int>();\n            }\n            m[nums[i]].emplace_back(i);\n            rm[i] = m[nums[i]].size() - 1;\n        }\n        vector<int> ans;\n        for (int i : queries) {\n            int idx = rm[i];\n            int to = nums[i];\n            int sz = m[to].size();\n            int msz = nums.size();\n            if (sz == 1) ans.emplace_back(-1);\n            else if (idx == 0) {\n                ans.emplace_back(min((m[to][idx + 1] - m[to][idx]), (msz - (m[to][sz - 1] - m[to][idx]))));\n            }\n            else if (idx == sz - 1) ans.emplace_back(min((m[to][idx] - m[to][idx - 1]), (msz - (m[to][idx] - m[to][0]))));\n            else {\n                ans.emplace_back(min(m[to][idx] - m[to][idx - 1], m[to][idx + 1] - m[to][idx]));\n            }\n        }\n        return ans;\n    }\n};","author":"漆黑之牙约修亚","submissionId":"611240655"},[]]},{"1709":[{"id":"1709","fileName":"611240589.txt","sourceCode":"from collections import defaultdict\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        record = defaultdict(list)\n        for i,num in enumerate(nums):\n            record[num].append(i)\n\n        ans = [-1 for _ in range(len(queries))]\n        for i,q in enumerate(queries):\n            val = nums[q]\n            choice = record[val]\n            if len(choice) == 1:\n                continue\n            else:\n                index = self.bis_find(q, choice)\n                \n                left_index = choice[(index - 1 + len(choice)) % len(choice)]\n                right_index = choice[(index + 1 + len(choice)) % len(choice)]\n                \n      \n                gap = min((q-left_index+len(nums)) % len(nums), (right_index- q + len(nums)) % len(nums))\n                # print(q, choice, q, left_index, right_index,gap)\n                ans[i] = gap\n        return ans\n\n    def bis_find(self, target , nums):\n        left,right = 0 , len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] > target:\n                right = mid - 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                return mid\n        return -1\n        \n        ","author":"liuyang","submissionId":"611240589"},[]]},{"1710":[{"id":"1710","fileName":"611240693.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dicts=defaultdict(list)\n        for i in range(len(nums)):\n            dicts[nums[i]].append(i)\n        res=[]\n        for q in queries:\n            ans=len(nums)\n            if len(dicts[nums[q]])==1:\n                ans=-1\n            else:\n                l=0\n                r=len(dicts[nums[q]])-1\n                n=len(dicts[nums[q]])\n                while l<=r:\n                    mid=(l+r)//2\n                    if dicts[nums[q]][mid]<q:\n                        l=mid+1\n                    else:\n                        r=mid-1\n                left=dicts[nums[q]][(l+1)%n]\n                right=dicts[nums[q]][(l-1)]\n                ans=min(abs(q-right),abs(q-left),abs((right+len(nums))-q),abs(left-len(nums)-q),abs((left+len(nums))-q),abs(right-len(nums)-q))\n            res.append(ans)\n        return res","author":"凕雨","submissionId":"611240693"},[]]},{"1711":[{"id":"1711","fileName":"611240688.txt","sourceCode":"#include<bits/stdc++.h>\nusing namespace std;\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> num;\n        for(int i = 0; i < 2 * nums.size(); i ++) {\n            if(i < nums.size()) {\n                num.push_back(nums[i]);\n            } else {\n                num.push_back(nums[i - nums.size()]);\n            }\n        }\n        map<int, vector<int>> mp;\n        for(int i = 0; i < 2 * nums.size(); i ++) {\n            mp[num[i]].push_back(i);\n        }\n\n        vector<int> ans;\n        int len = nums.size();\n        for(auto i : queries) {\n            if(mp[nums[i]].size() == 2) {\n                ans.push_back(-1);\n            } else {\n                int l = 0, r = mp[nums[i]].size();\n                while(l < r) {\n                    int mid = (l + r) >> 1;\n                    if(mp[nums[i]][mid] >= i) r = mid;\n                    else l = mid + 1;\n                }\n                if(l != 0) ans.push_back(min(i - mp[nums[i]][l - 1], mp[nums[i]][l + 1] - i));\n                else {\n                    ans.push_back(min(mp[nums[i]][l + 1] - i, ((i - *mp[nums[i]].rbegin()) % len + len) % len));\n                }\n            }\n        }\n\n        return ans;\n    }\n};","author":"逆熵","submissionId":"611240688"},[]]},{"1712":[{"id":"1712","fileName":"611240906.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        M = len(queries)\n        N = len(nums)\n        ans = [-1 for _ in range(M)]\n        helpNum = [[nums[i], i] for i in range(N)]\n        helpNum.sort(key=cmp_to_key(lambda x1, x2: x1[0] - x2[0] if x1[0] != x2[0] else x1[1] - x2[1]))\n        for i in range(M):\n            num = nums[queries[i]]\n            index1, index2 = self.bs1(helpNum, num), self.bs2(helpNum, num)\n            index = self.bs(helpNum, index1, index2, queries[i])\n            # print(i, num, index1, index2, index)\n            if index1 != index2:\n                if index == index1:\n                    ans[i] = min(helpNum[index1 + 1][1] - helpNum[index1][1], N - (helpNum[index2][1] - helpNum[index1][1]))\n                elif index == index2:\n                    ans[i] = min(helpNum[index2][1] - helpNum[index2 - 1][1], N - (helpNum[index2][1] - helpNum[index1][1]))\n                else:\n                    ans[i] = min(helpNum[index][1] - helpNum[index - 1][1], helpNum[index + 1][1] - helpNum[index][1])\n        return ans\n\n    def bs(self, helpNum, index1, index2, index):\n        l, r = index1, index2\n        while l < r:\n            mid = l + ((r - l) >> 1)\n            if helpNum[mid][1] < index:\n                l = mid + 1\n            elif helpNum[mid][1] > index:\n                r = mid - 1\n            else:\n                return mid\n        return l\n    \n    def bs1(self, helpNum, num):\n        l, r = 0, len(helpNum) - 1\n        while l < r:\n            mid = l + ((r - l) >> 1)\n            if helpNum[mid][0] < num:\n                l = mid + 1\n            else:\n                r = mid\n        return l\n\n    def bs2(self, helpNum, num):\n        l, r = 0, len(helpNum) - 1\n        while l < r:\n            mid = l + ((r - l + 1) >> 1)\n            if helpNum[mid][0] > num:\n                r = mid - 1\n            else:\n                l = mid\n        return l","author":"稽函数","submissionId":"611240906"},[]]},{"1713":[{"id":"1713","fileName":"611240802.txt","sourceCode":"/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\ntypedef struct hash\n{\n    int index;\n    int size;\n    int num;\n    int *arr;\n    UT_hash_handle hh;\n}hash;\nint* solveQueries(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize) {\n    hash *h=NULL;\n    int *r=malloc(sizeof(int)*queriesSize);\n    *returnSize=queriesSize;\n    for(int i=0;i<numsSize;i++)\n    {\n        hash *t;\n        HASH_FIND_INT(h,nums+i,t);\n        if(t==NULL)\n        {\n            t=malloc(sizeof(hash));\n            t->index=nums[i];\n            t->size=5;\n            t->num=1;\n            t->arr=malloc(sizeof(int)*t->size);\n            t->arr[0]=i;\n            HASH_ADD_INT(h,index,t);\n        }\n        else\n        {\n            if(t->num>=t->size)\n            {\n                t->size*=2;\n                t->arr=realloc(t->arr,sizeof(int)*t->size);\n            }\n            t->arr[t->num]=i;\n            t->num++;\n        }\n    }\n    for(int i=0;i<queriesSize;i++)\n    {\n        hash *t;\n        HASH_FIND_INT(h,nums+queries[i],t);\n        \n        if(t==NULL) r[i]=-1;\n        else if(t->num==1) r[i]=-1;\n        else\n        {\n            if(t->arr[t->num-1]==queries[i])\n            {\n                r[i]=numsSize-queries[i]+t->arr[0];\n                if(r[i]>queries[i]-t->arr[t->num-2]) r[i]=queries[i]-t->arr[t->num-2];\n            }\n            else if(t->arr[0]==queries[i])\n            {\n                r[i]=numsSize+queries[i]-t->arr[t->num-1];\n                if(r[i]>t->arr[1]-queries[i]) r[i]=t->arr[1]-queries[i];\n            }\n            else\n            {\n                int min=0,max=t->num-1,s;\n                while(min<max-1)\n                {\n                    s=(min+max)/2;\n                    if(t->arr[s]<=queries[i]) min=s;\n                    else max=s;\n                }\n                r[i]=queries[i]-t->arr[min-1];\n                if(r[i]>t->arr[min+1]-queries[i]) r[i]=t->arr[min+1]-queries[i];\n            }\n        }\n    }\n    return r;\n}","author":"Caihw","submissionId":"611240802"},[]]},{"1714":[{"id":"1714","fileName":"611240955.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int,vector<int>> m;\n        for(int i = 0;i < n;i++) m[nums[i]].push_back(i);\n        auto query = [&](int v) -> int {\n            int x = nums[v];\n            int l = m[x].size();\n            auto i = lower_bound(m[x].begin(),m[x].end(),v)-m[x].begin();\n            int res = INT_MAX;\n            if(l == 1) return -1;\n            else if(l == 2) {\n                int j = (i+1)%l;\n                if(j < i) {\n                    res = min(abs(v-m[x][j]), abs(m[x][j]+n-v));\n                } else {\n                    res = min(abs(m[x][j]-v), abs(v+n-m[x][j]));\n                }\n            } else {\n                int pre = (i+l-1)%l, next = (i+1+l)%l;\n                if(pre > next) swap(pre, next);\n                res = min(res, min(abs(v-m[x][pre]),abs(m[x][pre]+n-v)));\n                res = min(res, min(abs(m[x][next]-v), abs(v+n-m[x][next])));\n            }\n            return res;\n        };\n        vector<int> ans;\n        for(auto q:queries) ans.push_back(query(q));\n        return ans;\n    }\n};","author":"vinson","submissionId":"611240955"},[]]},{"1715":[{"id":"1715","fileName":"611240926.txt","sourceCode":"package main\n\nfunc solveQueries(nums []int, queries []int) []int {\n\tb := len(nums)\n\tnums = append(nums, nums...)\n\tbuf := map[int]int{}\n\tn := len(nums)\n\tmaxVal := 1000000000\n\tans := make([]int, b)\n\tfor i := range ans {\n\t\tans[i] = maxVal\n\t}\n\tfor i, v := range nums {\n\t\tidx, ok := buf[v]\n\t\tif ok {\n\t\t\tdelete(buf, v)\n\t\t\tdist := min(i-idx, b-i+idx)\n\t\t\tans[i%b] = min(ans[i%b],dist)\n\t\t\tans[idx%b] = min(ans[idx%b], dist)\n\t\t\t//fmt.Printf(\"i:%v idx:%v dist:%v ans:%vn\",i,idx,dist,ans[idx%b])\n\t\t}\n\t\tbuf[v] = i\n       // fmt.Printf(\"put v:%v i:%vn\",v,i)\n\t}\n\t//fmt.Println(ans)\n\tfor i, v := range ans {\n\t\tif v >= n {\n\t\t\tans[i] = -1\n\t\t}\n\t}\n\tres := make([]int, len(queries))\n\tfor i, v := range queries {\n\t\tres[i] = ans[v]\n\t\tif res[i] >= b || res[i] == 0 {\n\t\t\tres[i] = -1\n\t\t}\n\t}\n\treturn res\n}\n","author":"nullmoon","submissionId":"611240926"},[]]},{"1716":[{"id":"1716","fileName":"611240983.txt","sourceCode":"impl Solution {\n    pub fn solve_queries(nums: Vec<i32>, queries: Vec<i32>) -> Vec<i32> {\n        let n = nums.len() as i32;\n        let mut res = vec![];\n\n        let mut value_to_indices = std::collections::HashMap::new();\n        for (i, &num) in nums.iter().enumerate() {\n            value_to_indices.entry(num).or_insert(vec![]).push(i as i32);\n        }\n\n        for indices in value_to_indices.values_mut() {\n            indices.sort();\n        }\n\n        for &q in &queries {\n            let target = nums[q as usize];\n            if let Some(indices) = value_to_indices.get(&target) {\n                if indices.len() == 1 {\n                    res.push(-1);\n                    continue;\n                }\n\n                let pos = match indices.binary_search(&q) {\n                    Ok(pos) => pos,\n                    Err(pos) => pos,\n                };\n\n                let mut min_dist = i32::MAX;\n\n                if pos < indices.len() - 1 {\n                    let next = indices[pos + 1];\n                    let dist = (next - q).abs().min(n - (next - q).abs());\n                    min_dist = min_dist.min(dist);\n                }\n\n                if pos > 0 {\n                    let prev = indices[pos - 1];\n                    let dist = (prev - q).abs().min(n - (prev - q).abs());\n                    min_dist = min_dist.min(dist);\n                }\n\n                let first = indices[0];\n                let last = indices.last().unwrap();\n                let circle_dist = if first != q {\n                    (first - q).abs().min(n - (first - q).abs())\n                } else {\n                    i32::MAX\n                }\n                .min(if last != &q {\n                    (last - q).abs().min(n - (last - q).abs())\n                } else {\n                    i32::MAX\n                });\n\n                min_dist = min_dist.min(circle_dist);\n\n                res.push(if min_dist == i32::MAX { -1 } else { min_dist });\n            } else {\n                res.push(-1);\n            }\n        }\n        res\n    }\n}","author":"夏侯","submissionId":"611240983"},[]]},{"1717":[{"id":"1717","fileName":"611241011.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> ans = new ArrayList<>(queries.length);\n\n        Map<Integer, List<Integer>> num2IdxList = new HashMap();\n        for (int i = 0; i < nums.length; ++i) {\n            List<Integer> idxList = num2IdxList.computeIfAbsent(nums[i], v -> new ArrayList<>());\n            idxList.add(i);\n        }\n\n        int numsLen = nums.length;\n        for (int qi : queries) {\n            int num = nums[qi];\n            List<Integer> idxList = num2IdxList.get(num);\n            if (idxList.size() == 1) {\n                ans.add(-1);\n                continue;\n            }\n\n            int l = 0, r = idxList.size(), i = 0;\n            while (l < r) {\n                int m = (l + r) / 2, idx = idxList.get(m);\n                if (idx == qi) {\n                    i = m;\n                    break;\n                }\n                if (idx < qi) {\n                    l = m + 1;\n                } else {\n                    r = m;\n                }\n            }\n\n            int len = idxList.size();\n            int li = idxList.get((i - 1 + len) % len), ri = idxList.get((i + 1) % len);\n            ans.add(Math.min((qi + numsLen - li) % numsLen, (ri + numsLen - qi) % numsLen));\n        }\n        return ans;\n    }\n}","author":"TrackNNN","submissionId":"611241011"},[]]},{"1718":[{"id":"1718","fileName":"611241092.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> hash;\n        for (int i = 0; i < n; ++i)\n            hash[nums[i]].push_back(i);\n        vector<int> res;\n        for (auto& q : queries) {\n            int num = nums[q];\n            int m = hash[num].size();\n            if (m == 1) {\n                res.push_back(-1);\n            } else {\n                auto pos = lower_bound(hash[num].begin(), hash[num].end(), q);\n                int index = pos - hash[num].begin();\n                int pre = index == 0 ? n - hash[num].back() + q: q - hash[num][index-1];\n                int post = index == m - 1 ? hash[num][0] + n - q : hash[num][index+1] - q;\n                res.push_back(min(pre, post));\n            }\n        }\n        return res;\n    }\n};","author":"潜龙","submissionId":"611241092"},[]]},{"1719":[{"id":"1719","fileName":"611240783.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        cnt=defaultdict(list)\n        for i,x in enumerate(nums):\n            cnt[x].append(i)\n        n=len(queries)\n        m=len(nums)\n        ans=[-1]*n\n        for i,x in enumerate(queries):\n            if len(cnt[nums[x]])==1:\n                continue\n            j=bisect_left(cnt[nums[x]],x)\n            k=bisect_right(cnt[nums[x]],x)\n            mx=inf\n            if j>0:\n                pos1=cnt[nums[x]][j-1]\n                pos2=cnt[nums[x]][0]\n                mx=min(mx,abs(x-pos1),m-x+pos2)\n            if k<len(cnt[nums[x]]):\n                pos1=cnt[nums[x]][k]\n                pos2=cnt[nums[x]][-1]\n                mx=min(mx,abs(pos1-x),m-pos2+x)\n            ans[i]=mx\n        return ans","author":"Alx","submissionId":"611240783"},[]]},{"1720":[{"id":"1720","fileName":"611241074.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n    n:=len(nums)\n    l:=make([]int,n)\n    r:=make([]int,n)\n    fpos:=make(map[int]int)\n    lapos:=make(map[int]int)\n    lpos:=make(map[int]int)\n    rpos:=make(map[int]int)\n    for i:=0;i<n;i++{\n        if _,ok:=fpos[nums[i]];!ok{\n            fpos[nums[i]]=i\n        }\n        lapos[nums[i]]=i\n        if val,ok:=lpos[nums[i]];ok{\n            l[i]=val\n        }else{\n            l[i]=-1\n        }\n        lpos[nums[i]]=i\n    }\n    for i:=n-1;i>=0;i--{\n        if val,ok:=rpos[nums[i]];ok{\n            r[i]=val\n        }else{\n            r[i]=-1\n        }\n        rpos[nums[i]]=i\n    }\n    // fmt.Println(l)\n    // fmt.Println(r)\n    m:=len(queries)\n    res:=make([]int,m)\n    for i:=0;i<m;i++{\n        index:=queries[i]\n        lindex:=l[index]\n        rindex:=r[index]\n        if lindex==-1 && rindex==-1{\n            res[i]=-1\n        }else{\n            if lindex==-1{\n                if rindex-index<n-lapos[nums[index]]+queries[i]{\n                    res[i]=rindex-index        \n                }else{\n                    res[i]=n-lpos[nums[index]]+queries[i]\n                }\n            }else if rindex==-1{\n                if index-lindex<n-queries[i]+fpos[nums[index]]{\n                    res[i]=index-lindex\n                }else{\n                    res[i]=n-queries[i]+fpos[nums[index]]\n                }\n            }else{\n                if rindex-index<index-lindex{\n                    res[i]=rindex-index\n                }else{\n                    res[i]=index-lindex\n                }\n            }\n        }\n    }\n    return res\n}","author":"cpkqxpgg","submissionId":"611241074"},[]]},{"1721":[{"id":"1721","fileName":"611241115.txt","sourceCode":"from typing import List, Tuple, Dict, Set\nfrom sortedcontainers import SortedList, SortedSet, SortedDict\nfrom collections import defaultdict, deque, Counter\nfrom math import inf, sqrt, pi\nfrom functools import cache\nfrom itertools import accumulate, pairwise\nfrom bisect import bisect_left, bisect_right\nfrom heapq import heapify, heappop, heappush, heappushpop, heapreplace\n\nfrom typing import List, Tuple, Dict, Set\nfrom sortedcontainers import SortedList, SortedSet, SortedDict\nfrom collections import defaultdict, deque, Counter\nfrom math import inf, sqrt, pi\nfrom functools import cache\nfrom itertools import accumulate, pairwise\nfrom bisect import bisect_left, bisect_right\nfrom heapq import heapify, heappop, heappush, heappushpop, heapreplace\n\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        st = Counter(nums)\n        cur = nums[:]\n        nums += cur\n        nums += cur\n        ans = [-1] * len(queries)\n        d = defaultdict(list)\n        for i, v in enumerate(nums):\n            d[v].append(i)\n\n        for i, idx in enumerate(queries):\n            v = nums[idx]\n            idx += n\n            if st[v] == 1:\n                continue\n            q = d[v]\n            r = bisect_right(q, idx)\n            l = bisect_left(q, idx) - 1\n            t = inf\n            t = min(t, q[r] - idx)\n\n            t = min(t, idx - q[l])\n            ans[i] = (-1 if t == inf else t)\n\n        return ans\n\n\n","author":"时间的音符","submissionId":"611241115"},[]]},{"1722":[{"id":"1722","fileName":"611241164.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        map<int, set<int>> rbt;\n        for (int i = 0; i < n; i++) {\n            rbt[nums[i]].insert(i);\n        }\n\n        vector<int> res;\n        for (int q : queries) {\n            int x = nums[q];\n            auto it = rbt[x].find(q);\n            int tmp = 1e7;\n            if (rbt[x].size() == 1) {\n                tmp = -1;\n            } else if (it == rbt[x].begin()) {\n                tmp = min(tmp, *++it - q);\n                tmp = min(tmp, q + n - *rbt[x].rbegin());\n            } else if (it == prev(rbt[x].end())) {\n                tmp = min(tmp, q - *--it);\n                tmp = min(tmp, *rbt[x].begin() + n - q);\n            } else {\n                tmp = min(tmp, *++it - q);\n                --it;\n                tmp = min(tmp, q - *--it);\n            }\n            res.push_back(tmp);\n        }\n        return res;\n    }\n};","author":"手写","submissionId":"611241164"},[]]},{"1723":[{"id":"1723","fileName":"611241215.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] a, int[] q) {\n        int n = a.length;\n        int[] aa = new int[2 * n];\n        for(int i = 0; i < n; i ++){\n            aa[i] = aa[n + i] = a[i];\n        }\n        int[] ans = new int[2 * n];\n        Arrays.fill(ans, (int)1e9);\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i < 2 * n; i ++){\n            if(map.containsKey(aa[i])){\n                ans[i] = Math.min(ans[i], i - map.get(aa[i]));\n                ans[map.get(aa[i])] = Math.min(ans[map.get(aa[i])], i - map.get(aa[i]));\n            }\n            map.put(aa[i], i);\n        }\n        List<Integer> l = new ArrayList<>();\n        for(int x : q){\n            int t = Math.min(ans[x], ans[x + n]);\n            l.add(t == a.length ? -1 : t);\n        }\n        // System.out.print(Arrays.toString(ans));\n        return l;\n    }\n}","author":"zazhi","submissionId":"611241215"},[]]},{"1724":[{"id":"1724","fileName":"611241203.txt","sourceCode":"class Solution {\n        static int inf = 0x3ffffff;\n    public List<Integer> solveQueries(int[] a, int[] q) {\n        Map<Integer,List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < a.length; i++) {\n            List<Integer> ids = map.getOrDefault(a[i],new ArrayList<Integer>());\n            ids.add(i);\n            if(ids.size()==1){\n                map.put(a[i],ids);\n            }\n        }\n        List<Integer> ans = new ArrayList<>();\n        int n = a.length;\n        for (int i = 0; i < q.length; i++) {\n            List<Integer> ids = map.getOrDefault(a[q[i]], new ArrayList<Integer>());\n            if(ids.size() <= 1) {\n                ans.add(-1);\n            }else{\n                int l = 0,r = ids.size() - 1;\n                int x = q[i];\n                for(;l <= r;) {\n                    int mid = l + ((r - l )>> 1);\n                    if(ids.get(mid) >= x){\n                        r = mid - 1;\n                    }else{\n                        l = mid + 1;\n                    }\n                }\n                int dis = inf;\n                dis = Math.min(dis,get(n,ids,q[i],l - 1));\n                dis = Math.min(dis,get(n,ids,q[i],l + 1));\n                ans.add(dis);\n            }\n        }\n        return ans;\n    }\n\n\n    public static int get(int n,List<Integer> ids,int cur,int pos) {\n        if(!(0 <= pos && pos < ids.size())) {\n            return inf;\n        }\n        int p = ids.get(pos);\n        int dis = Math.abs(cur - p);\n        int first = ids.get(0);\n        int last = ids.get(ids.size() - 1);\n        int ans = inf;\n        ans = Math.min(n - dis,dis);\n        if(first != cur && first != p){\n            ans = Math.min(ans,Math.min(n - Math.abs(cur - first),Math.abs(cur - first)));\n        }\n        if(last != cur && last != p){\n            ans = Math.min(ans,Math.min(n - Math.abs(cur - last),Math.abs(cur - last)));\n        }\n        return ans;\n    }\n\n}","author":"一堵墙一扇窗","submissionId":"611241203"},[]]},{"1725":[{"id":"1725","fileName":"611241154.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int size = nums.size();\n        unordered_map<int, vector<int>> numToIndexMap;\n\n        for (int i = 0; i < size; i ++) {\n            int num = nums[i];\n            numToIndexMap[num].emplace_back(i);\n        }\n        \n        function<int(int, vector<int>&)> binarySearch = [&](int target, vector<int>& arr) -> int {\n            int left = 0, right = arr.size() - 1;\n            \n            while (left <= right) {\n                int mid = left + (right - left) / 2;\n                if (arr[mid] == target) {\n                    return mid;\n                } else if (arr[mid] < target) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n            \n            return -1;\n        };\n\n        vector<int> ans;\n        for (const auto&q : queries) {\n            int num = nums[q];\n            vector<int> &toLookUp = numToIndexMap[num];\n            if (toLookUp.size() == 1) {\n                ans.emplace_back(-1);\n            } else {\n                int idx = binarySearch(q, toLookUp);\n                int temp;\n                if (idx == 0) {\n                    temp = toLookUp[idx] + size - toLookUp[toLookUp.size() - 1];\n                } else {\n                    temp = toLookUp[idx] - toLookUp[idx - 1];\n                }\n                \n                if (idx == toLookUp.size() - 1) {\n                    temp = min(temp, toLookUp[0] + size - toLookUp[idx]);\n                } else {\n                    temp = min(temp, toLookUp[idx + 1] - toLookUp[idx]);\n                }\n                \n                ans.emplace_back(temp);\n            }\n        }\n        \n        return ans;\n    }\n};","author":"paulyu12","submissionId":"611241154"},[]]},{"1726":[{"id":"1726","fileName":"611241017.txt","sourceCode":"import bisect\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        from collections import defaultdict\n\n        num_to_indices = defaultdict(list)\n        for idx, num in enumerate(nums):\n            num_to_indices[num].append(idx)\n    \n        n = len(nums)\n        answer = []\n    \n        for q in queries:\n            target_num = nums[q]\n            indices = num_to_indices[target_num]\n            m=len(indices)\n            if len(indices) < 2:\n                answer.append(-1)\n                continue\n            elif len(indices)==2:\n                min_dist = min(abs(indices[0] - indices[1]), n - abs(indices[0] - indices[1]))\n            else:\n                \n            # min_dist = float('inf')\n            # for p in indices:\n            #     if p == q:\n            #         continue\n            #     dist = min(abs(q - p), n - abs(q - p))\n            #     if dist < min_dist:\n            #         min_dist = dist\n                pos = bisect.bisect_left(indices, q)\n                # 前驱和后继的索引（循环处理）\n                prev_idx = (pos - 1) % m\n                next_idx = (pos + 1) % m\n                min_dist=min(\n                    min(abs(indices[pos] - indices[prev_idx]), n - abs(indices[pos] - indices[prev_idx])),\n                    min(abs(indices[pos] - indices[next_idx]), n - abs(indices[pos] - indices[next_idx]))\n                )\n            \n            if min_dist == float('inf'):\n                answer.append(-1)\n            else:\n                answer.append(min_dist)\n    \n        return answer","author":"kimoji","submissionId":"611241017"},[]]},{"1727":[{"id":"1727","fileName":"611241302.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = queries.size();\n        auto maxIter = max_element(nums.begin(), nums.end());\n        int maxEle = *maxIter;\n        vector<vector<int>> memo(maxEle+1);\n        int numSize = nums.size();\n        for (int i = 0; i< numSize; ++i)\n        {\n            memo[nums[i]].emplace_back(i);\n        }\n\n        vector<int> ans(n, -1);\n        for (int i = 0; i < n; ++i)\n        {\n            int curIndex = queries[i];\n            int curNum = nums[curIndex];\n            auto& indexArray = memo[curNum];\n            if (indexArray.size() == 1)\n            {\n                continue;\n            }\n\n            auto upperBoundIter = upper_bound(indexArray.begin(), indexArray.end(), curIndex);\n            auto lowerBoundIter = lower_bound(indexArray.begin(), indexArray.end(), curIndex);\n            int minDistance = numSize;\n            if (upperBoundIter == indexArray.end())\n            {\n                minDistance = min(numSize - curIndex + indexArray[0], minDistance);\n            }\n            else\n            {\n                minDistance = min(*upperBoundIter - curIndex, minDistance);\n            }\n\n            if (lowerBoundIter != indexArray.begin())\n            {\n                --lowerBoundIter;\n                minDistance = min(curIndex - *lowerBoundIter, minDistance);\n            }\n            else\n            {\n                minDistance = min(numSize - indexArray[indexArray.size()-1] + curIndex, minDistance);\n            }\n\n            ans[i] = minDistance;\n        }\n\n        return ans;\n        \n    }\n};","author":"Vulpix","submissionId":"611241302"},[]]},{"1728":[{"id":"1728","fileName":"611241373.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int nn = 3 * n;\n        vector<int> res;\n        vector<int> dist(nn, INT32_MAX);\n        unordered_map<int, int> umap;\n        \n        if(queries.size() == 0) return res;\n            \n        for(int i = 0; i < n; i++){\n            nums.push_back(nums[i]);\n        }\n        for(int i = 0; i < n; i++){\n            nums.push_back(nums[i]);\n        }\n        \n        for(int i = 1; i < nn; i++){\n            int num = nums[i];\n            if(umap.find(num) != umap.end()){\n                dist[i] = min(dist[i], i - umap[num]); \n                umap[num] = i;\n            }else{\n                umap[num] = i;\n            }\n        }\n        umap.clear();\n        for(int i = nn - 1; i >= 0; i--){\n            int num = nums[i];\n            if(umap.find(num) != umap.end()){\n                dist[i] = min(dist[i], umap[num] - i); \n                umap[num] = i;\n            }else{\n                umap[num] = i;\n            }\n        }\n        for(auto index : queries){\n            int d = dist[index + n];\n            if(d == n || d == INT32_MAX) res.push_back(-1);\n            else res.push_back(d);\n        }\n        return res;\n    }\n};","author":"Nifty NobelkDu","submissionId":"611241373"},[]]},{"1729":[{"id":"1729","fileName":"611241313.txt","sourceCode":"import bisect\nimport collections\nfrom typing import List\n\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        maps = collections.defaultdict(list)\n\n        for i, num in enumerate(nums):\n            maps[num].append(i)\n        answers = [-1] * (len(queries))\n\n        for i, index in enumerate(queries):\n            num = nums[index]\n            line = maps[num]\n            if line:\n                curI = bisect.bisect_left(line, index)\n                pre = curI - 1\n                nexts = curI + 1\n                if pre >= 0 and nexts < len(line):\n                    answers[i] = min(line[nexts] - line[curI], line[curI] - line[pre])\n                    # answers[i] = line[nexts] - line[curI]\n                elif pre >= 0:\n                    answers[i] = min((len(nums) - line[curI]) + line[0], line[curI] - line[pre])\n\n                elif nexts < len(line):\n                    answers[i] = min(line[nexts] - line[curI], line[curI] + len(nums) - line[-1])\n\n        return answers\n\n","author":"Jarvan","submissionId":"611241313"},[]]},{"1730":[{"id":"1730","fileName":"611241388.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] qs) {\n        List<Integer> res=new ArrayList();\n        int n=nums.length;\n\n        Map<Integer,TreeSet<Integer>> map=new HashMap();\n        for(int i=0;i<n;i++){\n            if(!map.containsKey(nums[i])){\n                map.put(nums[i],new TreeSet());\n            }\n            map.get(nums[i]).add(i);\n        }\n\n        for(int idx:qs){\n            TreeSet<Integer> ts=map.get(nums[idx]);\n            if(ts.size()==1) {\n                res.add(-1);\n                continue;\n            }\n            //ts.remove(idx);\n            Integer v1=ts.lower(idx),v2=ts.higher(idx);\n            if(v2==null){\n                v2=ts.first();\n            }\n            if(v1==null){\n                v1=ts.last();\n            }\n            int cur=n+1;\n            if(v1!=null){\n                if(idx>v1.intValue()){\n                    cur=Math.min(cur,Math.min(idx-v1.intValue(),v1.intValue()+n-idx));\n                }else{\n                    cur=Math.min(cur,Math.min(v1.intValue()-idx,idx+n-v1.intValue()));\n                }\n                    \n            }\n            if(v2!=null){\n                if(v2.intValue()>idx){\n                    cur=Math.min(cur,Math.min(v2.intValue()-idx,idx+n-v2.intValue()));\n                }else{\n                    cur=Math.min(cur,Math.min(idx-v2.intValue(),v2.intValue()+n-idx));\n                }\n                    \n            }\n            res.add(cur==n+1?-1:cur);\n            //ts.add(idx);    \n        }\n\n        return res;\n    }\n}","author":"luojh","submissionId":"611241388"},[]]},{"1731":[{"id":"1731","fileName":"611241439.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>>m;\n        int n = nums.size();\n        for(int i =0;i<n;i++){\n            if(m.find(nums[i])==m.end()){\n                m[nums[i]] = vector<int>();\n            }\n            m[nums[i]].push_back(i);\n        }\n        n = queries.size();\n        vector<int>res(n,-1);\n        for(int i= 0;i<n;i++){\n            if(m[nums[queries[i]]].size()==1){\n                continue;\n            }\n            vector<int>&vec=m[nums[queries[i]]];\n            int id=lower_bound(vec.begin(),vec.end(),queries[i])-vec.begin();\n            int val=0x3f3f3f3f;\n            if(id-1>=0){\n                val = min(val,vec[id]-vec[id-1]);\n            }\n            else{\n                val = min(val,(int)(vec[id]-0+nums.size()-1-vec[vec.size()-1]+1));\n            }\n            if(id+1<vec.size()){\n                val = min(val,vec[id+1]-vec[id]);\n            }\n            else{\n                val = min(val,(int)(vec[0]-0+nums.size()-1-vec[id]+1));\n            }\n            res[i]=val;\n        }\n        return res;\n    }\n};","author":"zsc","submissionId":"611241439"},[]]},{"539":[{"id":"539","fileName":"1575118429.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int,vector<int>> vp(n);\n        for(int i = 0; i < n; i++){\n            vp[nums[i]].push_back(i);\n        }\n        vector<int> ans(queries.size());\n        for(int i = 0; i < queries.size(); i++) {\n            int ind = queries[i]; \n            int v = lower_bound(vp[nums[ind]].begin(), vp[nums[ind]].end(), ind) - vp[nums[ind]].begin();\n            if(vp[nums[ind]].size() == 1){\n                ans[i] = -1;\n                continue;\n            }\n            int sz = vp[nums[ind]].size();\n            int upind = vp[nums[ind]][(v + 1) % sz];\n            int downind = vp[nums[ind]][(v + sz - 1) % sz];\n            int downcost = downind < ind ? ind - downind : n - (downind - ind);\n            // cout << ind << \" \" << upind << \" \" << downind << endl;\n            ans[i] = min((upind - ind + n) % n, downcost);\n        }\n\n        return ans;\n    }\n};","author":"Divyansh Tripathi","submissionId":"1575118429"},[{"id":"539","similarity":0.7048192771084337,"totOverlap":117,"longestOverlap":14}]],"1732":[{"id":"1732","fileName":"611241477.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<int> res(m);\n        unordered_map<int, vector<int>> indices;\n        for (int i = 0; i < n; i++)\n            indices[nums[i]].push_back(i);\n        for (int i = 0; i < m; i++) {\n            int idx = queries[i];\n            // [1, 5]\n            int j = lower_bound(indices[nums[idx]].begin(), indices[nums[idx]].end(), idx) - indices[nums[idx]].begin();\n            int sz = indices[nums[idx]].size();\n            if (sz == 1) {\n                res[i] = -1;\n            } else {\n                int pre_j = indices[nums[idx]][(j-1+sz)%sz];\n                int d1 = pre_j < idx ? idx - pre_j : n - pre_j + idx;\n                int next_j = indices[nums[idx]][(j+1)%sz];\n                int d2 = idx < next_j ? next_j - idx : n - idx + next_j;\n                res[i] = min(d1, d2);\n            }\n        }\n        return res;\n    }\n};","author":"ransom_sword","submissionId":"611241477"},[{"id":"1769","similarity":0.7108433734939759,"totOverlap":118,"longestOverlap":24},{"id":"1732","similarity":0.7048192771084337,"totOverlap":117,"longestOverlap":14}]],"1769":[{"id":"1769","fileName":"611242395.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<int> ans(m);\n        unordered_map<int, vector<int>> index;\n        for(int i = 0; i < n; ++i){\n            index[nums[i]].push_back(i);\n        }\n        for(int i = 0; i < m; ++i){\n            int idx = queries[i];\n            int l = index[nums[idx]].size();\n            if(l == 1){\n                ans[i] = -1;\n                continue;\n            }\n            int cur_idx = lower_bound(index[nums[idx]].begin(), index[nums[idx]].end(), idx) - index[nums[idx]].begin();\n            int a = abs(index[nums[idx]][(cur_idx + 1) % l] - idx), b = abs(index[nums[idx]][(cur_idx - 1 + l) % l] - idx);\n            ans[i] = min(min(a, n - a), min(b, n - b));\n        }\n        \n        return ans;\n    }\n};","author":"歌者","submissionId":"611242395"},[{"id":"1732","similarity":0.7108433734939759,"totOverlap":118,"longestOverlap":24}]]},{"1734":[{"id":"1734","fileName":"611241414.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        def min_distance(idx, idy):\n            dif = abs(idx-idy)\n            return min(dif, n-dif)\n            \n        def find_nearest(num, ls):\n            length = len(ls)\n            left, right = 0, len(ls)-1\n            while left < right:\n                mid = (left + right) >> 1\n                if ls[mid] < num:\n                    left = mid + 1\n                else:\n                    right = mid\n            # print(\"tar_idx\",left)\n            if length == 1:\n                return -1\n            idx = left\n            left_idx = (idx + length - 1)%length\n            right_idx = (idx + 1)%length\n            # print(\"l, mid, r\", (left_idx, idx, right_idx))\n            min_dis = min_distance(ls[idx], ls[left_idx])\n            min_dis = min(min_dis, min_distance(ls[idx], ls[right_idx]))\n            return min_dis\n            \n        n = len(nums)\n        rec = defaultdict(list)\n        for idx, num in enumerate(nums):\n            rec[num].append(idx)\n\n        ans = []\n        for idx in queries:\n            num = nums[idx]\n            # print(\"idx, num, ls\", idx, num, rec[num])\n            distance = find_nearest(idx, rec[num])\n            ans.append(distance)\n        return ans","author":"Charming Jones0uZ","submissionId":"611241414"},[]]},{"1735":[{"id":"1735","fileName":"611241595.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        unordered_map<int, int> vis;\n        for (auto &q : queries) vis[nums[q]] = 1;\n        unordered_map<int, vector<int>> h;\n        for (int i = 0; i < n; ++i) {\n            if (vis[nums[i]] == 1) h[nums[i]].emplace_back(i - n);\n        }\n        for (int i = 0; i < n; ++i) {\n            if (vis[nums[i]] == 1) h[nums[i]].emplace_back(i);\n        }\n        for (int i = 0; i < n; ++i) {\n            if (vis[nums[i]] == 1) h[nums[i]].emplace_back(i + n);\n        }\n        vector<int> ans(m, -1);\n        for (int i = 0; i < m; ++i) {\n            auto it = upper_bound(h[nums[queries[i]]].begin(), h[nums[queries[i]]].end(), queries[i]);\n            int id = it - h[nums[queries[i]]].begin();\n            if (h[nums[queries[i]]][id] != queries[i] + n) {\n                ans[i] = h[nums[queries[i]]][id] - queries[i];\n                if (id >= 2) ans[i] = min(ans[i], abs(h[nums[queries[i]]][id - 2] - queries[i]));\n            }\n        }\n        return ans;\n    }\n};","author":"陌旭c","submissionId":"611241595"},[]]},{"1736":[{"id":"1736","fileName":"611241543.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, Integer> map = new HashMap<>();\n        int n = nums.length;\n        int[] dis = new int[n];\n        Arrays.fill(dis, -1);\n        for (int i = 0; i < 2 * n ; i++) {\n            int j = i % n;\n            if (map.containsKey(nums[j]) ) {\n                if (i >= n && map.get(nums[j]) == i - n) {\n                    continue;\n                }\n                int p = map.get(nums[j]) % n;\n                int a = i - map.get(nums[j]);\n                dis[j] = dis[j] == -1 ? a : Math.min(a, dis[j]);\n                dis[p] = dis[p] == -1 ? a : Math.min(a, dis[p]);\n            }\n            map.put(nums[j], i);\n        }\n        map = new HashMap<>();\n        for (int i = n - 1; i >=0; i--) {\n            int j = i % n;\n            if (map.containsKey(nums[j])) {\n                int p = map.get(nums[j]) % n;\n                int a = map.get(nums[j]) - i;\n                dis[j] = dis[j] == -1 ? a : Math.min(a, dis[j]);\n                dis[p] = dis[p] == -1 ? a : Math.min(a, dis[p]);\n            }\n            map.put(nums[j], i);\n        }\n        List<Integer> ret = new ArrayList<>();\n        for (int q : queries) {\n            ret.add(dis[q]);\n        }\n        return ret;\n    }\n}","author":"刘子豪","submissionId":"611241543"},[]]},{"1737":[{"id":"1737","fileName":"611241603.txt","sourceCode":"class Solution {\n        public List<Integer> solveQueries(int[] nums, int[] queries) {\n            int numLen = nums.length;\n            HashMap<Integer, Integer> preNumIdx = new HashMap<>(numLen*2);\n            int[] nextIdxArr = new int[numLen];\n            int[] preIdxArr = new int[numLen];\n            Arrays.fill(nextIdxArr,-1);\n            Arrays.fill(preIdxArr,-1);\n\n            for (int i = 0; i < numLen; i++) {\n                int num = nums[i];\n                if(preNumIdx.containsKey(num)){\n                    int preIdx = preNumIdx.get(num);\n                    preIdxArr[i] = preIdx;\n                    nextIdxArr[preIdx] = i;\n                }\n                preNumIdx.put(num,i);\n            }\n            // 第二轮循环\n            for (int i = 0; i < numLen; i++) {\n                int num = nums[i];\n                if(preNumIdx.containsKey(num)){\n                    int preIdx = preNumIdx.get(num);\n                    preIdxArr[i] = preIdx;\n                    nextIdxArr[preIdx] = i;\n                }\n                preNumIdx.put(num,i);\n            }\n            List<Integer> result = new ArrayList<>(queries.length);\n            for (int i=0;i<queries.length;++i){\n                int idx = queries[i];\n                int l = preIdxArr[idx];\n                int r = nextIdxArr[idx];\n                if(l==r && l==idx){\n                    result.add(-1);\n                    continue;\n                }\n                int lLen = idx-l;\n                if(lLen<0) lLen+= numLen;\n                int rLen = r-idx;\n                if(rLen<0) rLen+=numLen;\n                result.add(Math.min(lLen,rLen));\n            }\n            return result;\n        }\n    }","author":"molquark","submissionId":"611241603"},[]]},{"1738":[{"id":"1738","fileName":"611241609.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer,Integer> map = new HashMap<>();\n        int n = nums.length;\n        int[] dis = new int[n];\n        int[] douNums = new int[n*2];\n        for(int i=0;i<n;++i){\n            douNums[i] = nums[i];\n            douNums[i+n] = nums[i];\n        }\n        for(int i=0;i<n*2;++i){\n            int num = douNums[i];\n            if(!map.containsKey(num)){\n                dis[i%n] = Integer.MAX_VALUE;\n            }else{\n                int d = i-map.get(num);\n                if(d>=n) continue;\n                else dis[i%n] = i-map.get(num);\n            }\n            map.put(num,i);\n            \n        }\n        map.clear();\n        for(int i=n*2-1;i>=0;--i){\n            int num = douNums[i];\n            if(!map.containsKey(num)){\n                dis[i%n] = Math.min(Integer.MAX_VALUE,dis[i%n]);\n            }else{\n                int d = map.get(num)-i;\n                if(d>=n) continue;\n                else dis[i%n] = Math.min(dis[i%n],map.get(num)-i);\n            }\n            map.put(num,i);\n        }\n        List<Integer> ans = new ArrayList<>();\n        for(int q:queries){\n            if(dis[q]==Integer.MAX_VALUE) dis[q] = -1;\n            ans.add(dis[q]);\n        }\n        return ans;\n    } \n}\n\n\n\n\n","author":"无名","submissionId":"611241609"},[]]},{"1739":[{"id":"1739","fileName":"611241694.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n=nums.size();\n        unordered_map<int,vector<int>>mp;\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        for(int i=0;i<n;i++)    mp[nums[i]].push_back(i+n);\n        \n        int nq=q.size(),INF=1e9;\n        vector<int>ans(nq);\n        for(int i=0;i<nq;i++){\n            int x=nums[q[i]];\n            auto &v=mp[x];\n            int res=INF;\n            \n            // auto it=upper_bound(v.begin(),v.end(),q[i]);\n            // auto it2=lower_bound(v.begin(),v.end(),q[i]);\n            // if(it!=v.end()){\n            //     res=min({res,*it-q[i],n-*it+q[i]});\n            // }\n            // if(it2!=v.begin()) res=min({res,q[i]-*prev(it2),n-q[i]+*prev(it2)});\n            \n            auto it=upper_bound(v.begin(),v.end(),q[i]);\n            auto it2=lower_bound(v.begin(),v.end(),q[i]);\n            if(it!=v.end()){\n                res=min(res,*it-q[i]);\n            }\n            if(it2!=v.begin()) res=min(res,q[i]-*prev(it2));\n            \n            auto it3=upper_bound(v.begin(),v.end(),q[i]+n);\n            auto it4=lower_bound(v.begin(),v.end(),q[i]+n);\n            if(it3!=v.end()){\n                res=min(res,*it3-q[i]-n);\n            }\n            if(it4!=v.begin()) res=min(res,q[i]+n-*prev(it4));\n            \n            if(res>=n) res=-1;\n            ans[i]=res;\n        }\n        \n        return ans;\n        \n    }\n};\n\n/*\n[14,14,4,2,19,19,14,19,14]\n[2,4,8,6,3]\n[6,12,17,9,16,7,6]\n[5,6,0,4]\n\n[-1,1,1,2,-1]\n[-1,1,1,-1]\n*/","author":"hover","submissionId":"611241694"},[]]},{"1740":[{"id":"1740","fileName":"611241707.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        int n = a.size(), m = q.size();\n        std::map<int, std::vector<int>> f;\n        for (int i = 0; i < n; i++) {\n            f[a[i]].push_back(i);\n        }\n        auto g = [&](int x, int y) {\n            auto& v = f[x];\n            if (v.size() == 1) {\n                return -1;\n            } else if (v.size() == 2) {\n                return std::min(v[1] - v[0], v[0] + n - v[1]);\n            }\n            int idx = *std::lower_bound(v.begin(), v.end(), y);\n            auto r = std::upper_bound(v.begin(), v.end(), y);\n            auto l = std::lower_bound(v.begin(), v.end(), y);\n            int ans = 1e9;\n            if (r != v.end()) {\n                ans = std::min(ans, std::abs(n - idx + (*r)));\n                ans = std::min(ans, std::abs((*r) - idx));\n            } else {\n                r = v.begin();\n                ans = std::min(ans, std::abs(n - idx + (*r)));\n                ans = std::min(ans, std::abs((*r) - idx));\n            }\n            // std::cout << ans << \"n\";\n            if (l == v.begin()) {\n                l = v.end();\n                l--;\n                ans = std::min(ans, std::abs(idx - (*l)));\n                ans = std::min(ans, std::abs(idx + n - 1 - v.back() + 1));\n            } else {\n                l--;\n                ans = std::min(ans, std::abs(idx - (*l)));\n                ans = std::min(ans, std::abs(-idx + n - 1 + (*l) + 1));\n            }\n            // std::cout << x << \" \" << ans << \"n\";\n            return ans;\n        };\n        std::vector<int> ans(m);\n        for (int i = 0; i < m; i++) {\n            ans[i] = g(a[q[i]], q[i]);\n        }\n        return ans;\n    }\n};","author":"纯金是单质","submissionId":"611241707"},[]]},{"1741":[{"id":"1741","fileName":"611241706.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            if (map.containsKey(nums[i])) {\n                map.get(nums[i]).add(i);\n            } else {\n                map.put(nums[i], new ArrayList<Integer>());\n                map.get(nums[i]).add(i);\n            }\n        }\n        Iterator<Map.Entry<Integer, List<Integer>>> it = map.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<Integer, List<Integer>> entry = it.next();\n            int idx = entry.getKey();\n            List<Integer> value = entry.getValue();\n            if (value.size() > 1) {\n                for (int i = 0; i < value.size(); i++) {\n                    int t = value.get(i);\n                    int l = value.get((value.size() + i - 1) % value.size());\n                    int r = value.get((value.size() + i + 1) % value.size());\n                    int ld = Math.min(Math.abs(t - l), n - Math.abs(t - l));\n                    int rd = Math.min(Math.abs(t - r), n - Math.abs(t - r));\n                    nums[t] = Math.min(ld, rd);\n                }\n            }\n            else{\n                nums[value.get(0)] = -1;\n            }\n        }\n        List<Integer> res = new ArrayList<Integer>();\n        int m = queries.length;\n        for(int i = 0; i < m; i ++){\n            res.add(nums[queries[i]]);\n        }\n        return res;\n    }\n}","author":"熹熹想吃草莓","submissionId":"611241706"},[]]},{"1742":[{"id":"1742","fileName":"611241786.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries)\n    {\n        int i, k;\n        int m = queries.size();\n        int n = nums.size();\n        int dist;\n        vector<int> ans(m);\n        unordered_map<int, set<int>> idx1;\n        unordered_map<int, set<int, greater<>>> idx2;\n        for (i = 0; i < n; i++) {\n            idx1[nums[i]].emplace(i);\n            idx2[nums[i]].emplace(i);\n        }\n        for (k = 0; k < m; k++) {\n            if (idx1[nums[queries[k]]].size() == 1) {\n                ans[k] = -1;\n                continue;\n            }\n            dist = 0x3f3f3f3f;\n            auto it = idx1[nums[queries[k]]].upper_bound(queries[k]);\n            if (it != idx1[nums[queries[k]]].end()) {\n                dist = min(*it - queries[k], (queries[k] + n - *it) % n);\n            } else {\n                dist = *idx1[nums[queries[k]]].begin() + n - queries[k];\n            }\n            it = idx2[nums[queries[k]]].upper_bound(queries[k]);\n            if (it != idx2[nums[queries[k]]].end()) {\n                // cout << *it << \" \" << queries[k] << endl;\n                dist = min({dist, abs(*it - queries[k]), (*it + n - queries[k]) % n});\n            } else {\n                dist = min(dist, queries[k] + n - *idx2[nums[queries[k]]].begin());\n            }\n            ans[k] = dist;\n        }\n        return ans;\n    }\n};","author":"圣手书生","submissionId":"611241786"},[]]},{"1743":[{"id":"1743","fileName":"611241833.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,int> vis;\n        int cnt = 0;\n        vector<vector<int>> pos(nums.size() + 10);\n        for (int i = 0;i<nums.size();i++){\n            if (!vis[nums[i]]){\n                vis[nums[i]] = ++cnt;\n            }\n            pos[vis[nums[i]]].push_back(i);\n        }\n\n        vector<int> ans(nums.size());\n\n        for (int i = 1;i<=cnt;i++){\n            for (int j = 0;j<pos[i].size();j++){\n                int l = (j - 1 + pos[i].size()) % pos[i].size();\n                int r = (j + 1) % pos[i].size();\n                if (l == j){\n                    ans[pos[i][j]] = -1;\n                }else{\n                    int L = abs(pos[i][l] - pos[i][j]);\n                    L = min(L,int(nums.size() - L));\n                    int R = abs(pos[i][r] - pos[i][j]);\n                    R = min(R,int(nums.size() - R));\n                    ans[pos[i][j]] = min(L,R);\n                }\n            }\n        }\n\n        vector<int> ANS;\n\n        for (int i = 0;i<queries.size();i++){\n            ANS.push_back(ans[queries[i]]);\n        }\n\n        return ANS;\n    }\n};","author":"羧基碱","submissionId":"611241833"},[]]},{"1744":[{"id":"1744","fileName":"611241742.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        map<int,vector<int>> f;\n        int n = a.size();\n        for(int i = 0;i < a.size();i ++)\n            {\n                f[a[i]].push_back(i);\n            }\n        vector<int> ans;\n        for(auto x : q)\n            {\n                int now = a[x];\n                auto &F = f[a[x]];\n                auto st = lower_bound(f[a[x]].begin(),f[a[x]].end(),x) - f[a[x]].begin();\n                if(f[a[x]].size() == 1)\n                {\n                    ans.push_back(-1);continue;\n                }\n                int siz = f[a[x]].size();\n                int l = (st + 1) % siz,r = (st - 1 + siz) % siz;\n                int res = min(min(abs(F[l] - F[st]),n - abs(F[l] - F[st])),min(abs(F[r] - F[st]),n - abs(F[r] - F[st])));\n                ans.push_back(res);\n            }\n\n        return ans;\n    }\n};","author":"chhh31","submissionId":"611241742"},[]]},{"1745":[{"id":"1745","fileName":"611241875.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        from collections import defaultdict\n        def solve(nums):\n            left=defaultdict(lambda :-1)\n            ans=[1e9]*len(nums)\n            for i in range(len(nums)):\n                if left[nums[i]]!=-1:\n                    ans[i]=min(ans[i],abs(left[nums[i]]-i))\n                left[nums[i]]=i\n            return ans\n        first=defaultdict(lambda :-1)\n        last=defaultdict(lambda :-1)\n        for i in range(len(nums)):\n            if first[nums[i]]==-1:\n                first[nums[i]]=i \n            last[nums[i]]=i\n        ans1=solve(nums)\n        ans2=solve(nums[::-1])[::-1]\n        for i in range(len(ans1)):\n            if ans1[i]!=-1:\n                if first[nums[i]]!=i:\n                    ans1[i]=min(ans1[i],first[nums[i]]-i+len(nums))\n        for i in range(len(ans2)):\n            if ans2[i]!=-1:\n                if last[nums[i]]!=i:\n                    ans2[i]=min(ans2[i],i-last[nums[i]]+len(nums))\n        ans=[min(i,j)for i,j in zip(ans1,ans2)]\n        ans=[i if i<1e9 else -1 for i in ans]\n        return [ans[i] for i in queries]","author":"wyf","submissionId":"611241875"},[]]},{"1746":[{"id":"1746","fileName":"611241866.txt","sourceCode":"class Solution {\n    fun solveQueries(nums: IntArray, queries: IntArray): List<Int> {\n        val n = nums.size\n        val indexMap = HashMap<Int, TreeSet<Int>>()\n\n        for (i in nums.indices) {\n            indexMap.computeIfAbsent(nums[i]) { TreeSet() }.add(i)\n        }\n\n        val ans = ArrayList<Int>()\n        for (i in queries.indices) {\n            val q = queries[i]\n            val target = nums[q]\n\n            val left = indexMap[target]!!.lower(q)\n            val right = indexMap[target]!!.higher(q)\n            val min = indexMap[target]!!.first()!!\n            val max = indexMap[target]!!.last()!!\n\n            // println(\"$q: $target with $left $right $min $max\")\n\n            var dis = Int.MAX_VALUE\n            if (left != null) {\n                dis = minOf(dis, minOf(q - left), minOf(n - (q - left)))\n            }\n            if (right != null) {\n                dis = minOf(dis, minOf(right - q, n - (right - q)))\n            }\n            if (min != q) {\n                dis = minOf(dis, minOf(q - min), minOf(n - (q - min)))\n            }\n            if (max != q) {\n                dis = minOf(dis, minOf(max - q, n - (max - q)))\n            }\n            if (dis == Int.MAX_VALUE) {\n                dis = -1\n            }\n            ans.add(dis)\n        }\n        return ans\n    }\n}","author":"HaKu","submissionId":"611241866"},[]]},{"1747":[{"id":"1747","fileName":"611241752.txt","sourceCode":"class Solution {\npublic:\n    std::vector<int> solveQueries(std::vector<int>& nums, std::vector<int>& queries) {\n        int n=nums.size();\n        for(int i=0;i<n;++i){\n            nums.emplace_back(nums[i]);\n        }\n        std::vector<int> vClose(n,std::numeric_limits<int>::max()/2);\n        std::unordered_map<int,std::vector<int>> map;\n        for(int i=0;i<nums.size();++i){\n            auto &tv=map[nums[i]];\n            if (i>=n&&tv.size()==1){ continue;}\n            tv.emplace_back(i);\n            if (tv.size()>1){\n                vClose[tv.back()%n]=std::min(vClose[tv.back()%n],std::abs(i-tv[tv.size()-2]));\n                vClose[tv[tv.size()-2]%n]=std::min(vClose[tv[tv.size()-2]%n],std::abs(i-tv[tv.size()-2]));\n            }\n        }\n        std::vector<int> ans;\n        for(auto&e:queries){\n            ans.emplace_back((vClose[e]==std::numeric_limits<int>::max()/2?-1:vClose[e]));\n        }\n        return ans;\n    }\n};","author":"Master Ender","submissionId":"611241752"},[]]},{"1748":[{"id":"1748","fileName":"611241792.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> dict;\n        int n = nums.size();\n        for(int i = 0; i < n; ++i){\n            dict[nums[i]].push_back(i);\n        }\n        int m = queries.size();\n        vector<int> ans(m);\n        for(int i = 0; i < m; ++i){\n            const vector<int>& v = dict[nums[queries[i]]];\n            int len = v.size();\n            if(len == 1) {\n                ans[i] = -1;\n                continue;\n            }\n            \n            int index = lower_bound(v.begin(), v.end(), queries[i]) - v.begin();\n            if(index == 0) ans[i] = min(v[1] - v[0], n - v.back() + v[0]);\n            else if(index == len - 1) ans[i] = min(n - v.back() + v[0], v.back() - v[len - 2]);\n            else ans[i] = min(v[index] - v[index - 1], v[index + 1] - v[index]);\n        }\n        return ans;\n    }\n};","author":"板鸭鸭R某","submissionId":"611241792"},[]]},{"1749":[{"id":"1749","fileName":"611241857.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> groupsMap = new HashMap<>();\n        int[] posList = new int[nums.length];\n\n        for(int i=0; i<nums.length; i++){\n            groupsMap.putIfAbsent(nums[i], new ArrayList<>());\n            groupsMap.get(nums[i]).add(i);\n            posList[i] = groupsMap.get(nums[i]).size()-1;\n        }\n\n        List<Integer> res = new ArrayList<>();\n        for(int i=0; i<queries.length; i++){\n            res.add(getDist(groupsMap.get(nums[queries[i]]), posList[queries[i]], nums.length));\n        }\n\n        return res;\n    }\n\n    public int getDist(List<Integer> group, int pos, int len){\n        if(group.size()<=1) return -1;\n        \n        int pre, post;\n        if(pos==0){\n            pre = len + group.get(pos) - group.get(group.size()-1);\n            post = group.get(pos+1) - group.get(pos);\n        }\n        else if(pos==group.size()-1){\n            pre = group.get(pos) - group.get(pos-1);\n            post = len + group.get(0) - group.get(pos);\n        }\n        else{\n            pre = group.get(pos) - group.get(pos-1);\n            post = group.get(pos+1) - group.get(pos);\n        }\n\n        return Math.min(pre, post);\n    }\n}","author":"Naughty DijkstraMYR","submissionId":"611241857"},[]]},{"1750":[{"id":"1750","fileName":"611241890.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n=nums.size();\n        map<int,int>pp;\n        vector<int>a(2*n+1);\n        for(int i=1;i<=n;i++) a[i]=nums[i-1],pp[a[i]]++;\n        for(int i=n+1;i<=2*n;i++) a[i]=a[i-n];\n\n        vector<int>r(n+1);\n        map<int,int>p;\n        for(int i=2*n;i>=1;i--){\n            if(i>n) p[a[i]]=i;\n            else{\n                if(p[a[i]]==0) r[i]=-1,p[a[i]]=i;\n                else r[i]=p[a[i]],p[a[i]]=i;\n            }\n        }\n        vector<int>l(2*n+1);\n        map<int,int>qq;\n        for(int i=1;i<=2*n;i++){\n            if(i<=n) qq[a[i]]=i;\n            else{\n                if(qq[a[i]]==0) l[i]=-1,qq[a[i]]=i;\n                else l[i]=qq[a[i]],qq[a[i]]=i;\n            }\n        }\n        // cout<<l[n]<<endl;\n\n        vector<int>ans;\n        int m=q.size();\n        for(int i=0;i<m;i++){\n            int x=q[i]+1;\n            // cout<<a[x]<<endl;\n            x%=n;\n            if(x==0) x=n;\n            // cout<<x<<endl;\n            if(pp[a[x]]==1) ans.push_back(-1);\n            else if(l[x+n]==-1&&r[x]==-1) ans.push_back(-1);\n            else if(r[x]==-1) ans.push_back(x+n-l[x+n]);\n            else if(l[x+n]==-1) ans.push_back(r[x]-x);\n            else ans.push_back(min(r[x]-x,x+n-l[x+n]));\n        }\n        return ans;\n    }\n};","author":"20岁有志青年","submissionId":"611241890"},[]]},{"1752":[{"id":"1752","fileName":"611241928.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int[] mins = new int[nums.length];\n        Arrays.fill(mins, -1);\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            Integer preIndex = map.put(nums[i], i);\n            if (preIndex != null) {\n                int dest = Math.min(i - preIndex, nums.length - i + preIndex);\n                mins[preIndex] = mins[preIndex] > 0 ? Math.min(mins[preIndex], dest) : dest;\n                mins[i] = dest;\n            }\n        }\n        for (int i = 0; i < nums.length; i++) {\n            Integer lastIndex = map.get(nums[i]);\n            if (lastIndex != null && lastIndex != i) {\n                int dest = Math.min(lastIndex - i, nums.length - lastIndex + i);\n                mins[lastIndex] = Math.min(mins[lastIndex], dest);\n                mins[i] = Math.min(mins[i], dest);\n            }\n        }\n        List<Integer> result = new ArrayList<>(queries.length);\n        for (int i = 0; i < queries.length; i++) {\n            result.add(mins[queries[i]]);\n        }\n        return result;\n    }\n}","author":"Sylze","submissionId":"611241928"},[]]},{"1753":[{"id":"1753","fileName":"611241905.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        cnt = defaultdict(list)\n        n = len(nums)\n        for i, num in enumerate(nums):\n            cnt[num].append(i)\n        for num in cnt:\n            cnt[num].sort()\n\n        res = []\n        for q in queries:\n            ids = cnt.get(nums[q], [])\n            m = len(ids)\n            if m < 2:\n                res.append(-1)\n                continue\n            pos = bisect.bisect_left(ids, q)\n\n            if pos < m and ids[pos] == q:\n                pre = ids[(pos - 1) % m]\n                post = ids[(pos + 1) % m]\n                cur = [pre, post]\n                cur = [j for j in cur if j != q]\n            else:\n                pre = ids[(pos - 1) % m]\n                post = ids[pos % m]\n                cur = [pre, post]\n            if not cur:\n                res.append(-1)\n            else:\n                res.append(min(min(abs(j - q), n - abs(j - q)) for j in cur))\n        return res","author":"Li Yixin","submissionId":"611241905"},[]]},{"1754":[{"id":"1754","fileName":"611241935.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        // ---------------------------------------------\n        set<int> allNumbers;\n        for (auto& num : nums) {\n            allNumbers.insert(num);\n        }\n        unordered_map<int, int> val;\n        unordered_map<int, int> rev;\n        int idx = 0;\n        for (int x: allNumbers) {\n            val[x] = idx;\n            rev[idx] = x;\n            ++idx;\n        }\n        // ---------------------------------------------\n        vector<int> ans;\n        vector<vector<int>> rank(idx);\n        vector<int> vlen(idx);\n        int ln = nums.size();\n        for (int i = 0; i < ln; ++i) {\n            int tv = val[nums[i]];\n            rank[tv].emplace_back(i);\n            ++vlen[tv];\n        }\n        for (int i = 0; i < idx; ++i) {\n            sort(rank[i].begin(), rank[i].end());\n        }\n        for (auto& q : queries) {\n            int tv = val[nums[q]];\n            if (vlen[tv] == 1) {\n                ans.emplace_back(-1);\n                continue;\n            }\n            int idx = lower_bound(rank[tv].begin(), rank[tv].end(), q) - rank[tv].begin();\n            int tans = ln;\n            if (idx != 0) {\n                tans = min(tans, rank[tv][idx] - rank[tv][idx - 1]);\n            } else {\n                tans = min(tans, rank[tv][idx] + ln - rank[tv][vlen[tv] - 1]);\n            }\n            if (idx != vlen[tv] - 1) {\n                tans = min(tans, rank[tv][idx + 1] - rank[tv][idx]);\n            } else {\n                tans = min(tans, ln - rank[tv][idx] + rank[tv][0]);\n            }\n            ans.emplace_back(tans);\n        }\n        return ans;\n    }\n};","author":"签到题高手_mmm","submissionId":"611241935"},[]]},{"1755":[{"id":"1755","fileName":"611241993.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& qu) {\n        int n = nums.size(),m = qu.size();\n        vector<int> res(m);\n        unordered_map<int,vector<int>> hash;\n        for(int i = 0;i<n;i++){\n            hash[nums[i]].push_back(i);\n        }\n        for(auto& i : hash){\n            sort(i.second.begin(),i.second.end());\n        }\n        for(int i = 0;i<m;i++){\n            if(hash[nums[qu[i]]].size() == 1){\n                res[i] = -1;\n                continue;\n            }\n            int cur = INT_MAX;\n            auto it = lower_bound(hash[nums[qu[i]]].begin(),hash[nums[qu[i]]].end(),qu[i]);\n            if(hash[nums[qu[i]]].back() != qu[i]){\n                int a = hash[nums[qu[i]]].back();\n                cur = min(cur,min((qu[i] - a + n) % n,(a - qu[i] + n) % n));\n            }\n            if(hash[nums[qu[i]]][0] != qu[i]){\n                int a = hash[nums[qu[i]]][0];\n                cur = min(cur,min((qu[i] - a + n) % n,(a - qu[i] + n) % n));\n            }\n            if(it != hash[nums[qu[i]]].begin()){\n                int a = *(it - 1);\n                cur = min(cur,min((qu[i] - a + n) % n,(a - qu[i] + n) % n));\n            }\n            while(it != hash[nums[qu[i]]].end() && *it == qu[i]){\n                it++;\n            }\n            if(it != hash[nums[qu[i]]].end()){\n                int a = *(it);\n                cur = min(cur,min((qu[i] - a + n) % n,(a - qu[i] + n) % n));\n            }\n            res[i] = cur;\n        }\n        return res;\n    }\n};","author":"爱写代码的木更","submissionId":"611241993"},[]]},{"1756":[{"id":"1756","fileName":"611242002.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int kai=0;\n        for(int i=0;i<nums.size();i++){\n            kai=max(kai,nums[i]);\n        }\n       set<int>xx[kai+2];\n       map<int,int>maxx;\n        map<int,int>minn;\n        for(int i=0;i<nums.size();i++){\n            xx[nums[i]].insert(i);\n            maxx[nums[i]]=max(maxx[nums[i]],i);\n            if(minn[nums[i]]==0&&nums[0]!=nums[i]){\n                minn[nums[i]]=i;\n            }\n            minn[nums[i]]=min(minn[nums[i]],i);\n            xx[nums[i]].insert(-10000000);\n             xx[nums[i]].insert(80000000);\n        }\n        vector<int>ans;\n        for(auto it:queries){\n            int xv=nums[it];\n            int l=*--xx[xv].lower_bound(it);\n            \n            int r=*xx[xv].upper_bound(it);\n            int shou=minn[nums[it]];\n            int wei=maxx[nums[it]];\n           \n            int jv=it-l;\n            \n            jv=min(jv,r-it);\n        //  cout<<shou<<endl;\n            if(shou!=it){\n                int zhi=(nums.size()-1-it)+shou+1;\n                jv=min(jv,zhi);\n            }\n           // cout<<jv<<endl;\n            if(wei!=it){\n                int cc=it+(nums.size()-1-wei+1);\n                jv=min(jv,cc);\n            }\n            if(jv>nums.size()+2){\n                ans.push_back(-1);\n            }else ans.push_back(jv);\n        }\n        return ans;\n    }\n};","author":"该进厂打螺丝了","submissionId":"611242002"},[]]},{"1757":[{"id":"1757","fileName":"611241940.txt","sourceCode":"class Solution {\n   \n\n\tpublic List<Integer> solveQueries(int[] nums, int[] queries) {\n\t\tint n = nums.length;\n\t\tint qn = queries.length;\n\t\tMap<Integer, List<Integer>> map = new HashMap<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = nums[i];\n\t\t\tList<Integer> list = map.getOrDefault(x, new ArrayList<>());\n\t\t\tlist.add(i);\n\t\t\tmap.put(x, list);\n\t\t}\n\t\tList<Integer> res = new ArrayList<>(qn);\n\t\tfor (int i = 0; i < qn; i++) {\n\t\t\tint ti = queries[i];\n\t\t\tint tx = nums[ti];\n\t\t\tList<Integer> list = map.getOrDefault(tx, new ArrayList<>());\n\t\t\tint ln = list.size();\n\t\t\tif (ln < 2) {\n\t\t\t\tres.add(-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres.add(getValue(list, nums.length, ti));\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate Integer getValue(List<Integer> list, int n, int ti) {\n\t\tint index = getIndex(list, ti);\n\t\tint ln = list.size();\n\t\tint a = list.get((ln + index - 1) % ln);\n\t\tint ar;\n\t\tif (a < ti) {\n\t\t\tar = ti - a;\n\t\t} else {\n\t\t\tar = n - a + ti;\n\t\t}\n\t\tint b = list.get((ln + index + 1) % ln);\n\t\tint br;\n\t\tif (b > ti) {\n\t\t\tbr = b - ti;\n\t\t} else {\n\t\t\tbr = n - ti + b;\n\t\t}\n\t\treturn Math.min(ar, br);\n\t}\n\n\tprivate static int getIndex(List<Integer> list, int t) {\n\t\tint left = 0;\n\t\tint right = list.size() - 1;\n\t\twhile (left <= right) {\n\t\t\tint mid = (left + right) >> 1;\n\t\t\tif (t < list.get(mid)) {\n\t\t\t\tright = mid - 1;\n\t\t\t} else {\n\t\t\t\tleft = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn right;\n\t}\n}","author":"小灰熊","submissionId":"611241940"},[]]},{"1759":[{"id":"1759","fileName":"611242154.txt","sourceCode":"from bisect import bisect_left\nfrom collections import defaultdict\nfrom typing import List\n\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        cache = defaultdict(list)\n        for i, num in enumerate(nums):\n            cache[num].append(i)\n        for key in cache.keys():\n            cache[key].append(cache[key][0] + n)\n        res = []\n        for query in queries:\n            index_list = cache[nums[query]]\n            index = bisect_left(index_list, query)\n            min_dist = n\n            if index != 0:\n                min_dist = min(min_dist, index_list[index] - index_list[index - 1],\n                               index_list[index + 1] - index_list[index])\n            else:\n                min_dist = min(min_dist, index_list[1] - index_list[0], index_list[-1] - index_list[-2])\n            if min_dist == n:\n                min_dist = -1\n            res.append(min_dist)\n        return res\n","author":"Lewis.Finch","submissionId":"611242154"},[]]},{"1760":[{"id":"1760","fileName":"611242167.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        dic = dict()\n        suf = [-1] * n\n        pre = [-1] * n\n        for i, x in enumerate(nums):\n        # for i in range(n-1, -1, -1):\n            if x in dic:\n                suf[i] = dic[x]\n                pre[dic[x]] = i\n            dic[x] = i\n        for i, x in enumerate(nums):\n        # for i in range(n-1, -1, -1):\n            if x in dic:\n                suf[i] = dic[x]\n                pre[dic[x]] = i\n            dic[x] = i\n        # print(pre)\n        # print(suf)\n        a = sorted(enumerate(queries), key=lambda p : p[1])\n        m = len(a)\n        j = 0\n        ans = [-1] * m\n        for i, x in enumerate(nums):\n            while j < m and a[j][1] == i:\n                if pre[i] == i:\n                    ans[a[j][0]] = -1\n                else:\n                    ans[a[j][0]] = min((i - suf[i] + n) % n, (pre[i] - i + n) % n)\n                j += 1\n        return ans","author":"wormchaos","submissionId":"611242167"},[]]},{"1761":[{"id":"1761","fileName":"611242032.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>> mp;\n        int n=nums.size();\n        for(int j=n-1;j>=0;j--)\n            {\n                mp[nums[j]].push_back(j);\n            }\n        for(auto it=mp.begin();it!=mp.end();it++)\n            {\n                sort(it->second.begin(),it->second.end());\n            }\n        int m=queries.size();\n        vector<int> ans(m);\n        for(int i=0;i<m;i++)\n            {\n                int num=nums[queries[i]];\n                if(mp[num].size()<=1)\n                {\n                    ans[i]=-1;\n                }\n                else\n                {\n                    auto it=lower_bound(mp[num].begin(),mp[num].end(),queries[i])-mp[num].begin();\n                    if(it==0)\n                    {\n                        ans[i]=min(mp[num][1]-queries[i],n-(mp[num].back()-queries[i]));\n                    }\n                    \n                    else if(it==mp[num].size()-1)\n                    {\n                        ans[i]=min(queries[i]-mp[num][mp[num].size()-2],n-(queries[i]-mp[num][0]));\n                    }\n                        \n                    else\n                    {\n                        int num1=mp[num][it+1]-queries[i];\n                        num1=min(num1,n-num1);\n                        int num2=queries[i]-mp[num][it-1];\n                        num2=min(num2,n-num2);\n                        ans[i]=min(num1,num2);\n                    }\n                }\n            }\n        return ans;\n    }\n};","author":"胡冻僵","submissionId":"611242032"},[]]},{"1762":[{"id":"1762","fileName":"611242170.txt","sourceCode":"class Solution\n{\npublic:\n    vector<int> solveQueries(vector<int> const &nums, vector<int> const &queries)\n    {\n        unordered_map<int, vector<int>> mp;\n        int const n = nums.size();\n        for (int i = 0; i != n; ++i)\n            mp[nums[i]].push_back(i);\n        for (auto &[num, positions] : mp)\n            sort(positions.begin(), positions.end());\n        vector<int> ans;\n        ans.reserve(queries.size());\n        for (int const pos : queries)\n        {\n            vector<int> const &positions = mp[nums[pos]];\n            if (positions.size() == 1)\n            {\n                ans.push_back(-1);\n                continue;\n            }\n            static auto constexpr compute_distance = [](int const lhs, int const rhs, int const n) -> int\n            {\n                if (lhs < rhs) return min(rhs - lhs, n - rhs + lhs);\n                else return min(lhs - rhs, n - lhs + rhs);\n            };\n            int const m = positions.size();\n            int const idx = lower_bound(positions.cbegin(), positions.cend(), pos) - positions.cbegin();\n            int const prev_pos = positions[(idx + m - 1) % m];\n            int const prev_dis = compute_distance(prev_pos, pos, n);\n            int const next_pos = positions[(idx + m + 1) % m];\n            int const next_dis = compute_distance(pos, next_pos, n);\n            ans.push_back(min(prev_dis, next_dis));\n        }\n        return ans;\n    }\n};","author":"heartunderblade","submissionId":"611242170"},[]]},{"1763":[{"id":"1763","fileName":"611242215.txt","sourceCode":"class Solution {\npublic:\n    inline int dis(int x, int y, int n){\n        return x<y?min(y-x, n-y+x):min(x-y, n-x+y);\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int m = queries.size(), n = nums.size();\n        vector<int> ans(m);\n        unordered_map<int,vector<int>> mp;\n        vector<int> rec(n, n);\n        for(int i=0;i<n;++i){\n            rec[i] = min(rec[i], (mp.count(nums[i])?min(dis(mp[nums[i]][0], i, n), dis(mp[nums[i]].back(), i, n)):n));\n            mp[nums[i]].emplace_back(i);\n        }\n        \n        mp.clear();\n        for(int i=n-1;i>=0;--i){\n            rec[i] = min(rec[i], (mp.count(nums[i])?min(dis(mp[nums[i]][0], i, n), dis(mp[nums[i]].back(), i, n)):n));\n            mp[nums[i]].emplace_back(i);\n        }\n        \n        for(int i=0;i<m;++i){\n            ans[i] = rec[queries[i]]==n?-1:rec[queries[i]];\n        }\n        return ans;      \n    }\n};","author":"烈焰的冰玫瑰","submissionId":"611242215"},[]]},{"1764":[{"id":"1764","fileName":"611242168.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> mp;\n        int n=nums.size();\n        for(int i=0;i<n;i++) mp[nums[i]].emplace_back(i);\n        vector<int> ans;\n        for(auto x:queries)\n        {\n            auto &v=mp[nums[x]];\n            if(v.size()==1) ans.emplace_back(-1);\n            else if(v.size()==2)\n            {\n                int x=v.front(),y=v.back();\n                int res=min((x-y+n)%n,(y-x+n)%n);\n                ans.emplace_back(res);\n            }\n            else\n            {\n                int pos=lower_bound(v.begin(),v.end(),x)-v.begin();\n                int val=v[pos];\n                int nxt,pre;\n                if(pos==v.size()-1) nxt=v.front();\n                else nxt=v[pos+1];\n                if(pos==0) pre=v.back();\n                else pre=v[pos-1];\n                int res=1e9;\n                res = min((pre-val+n)%n,(val-pre+n)%n);\n                res = min(res,min((nxt-val+n)%n,(val-nxt+n)%n));\n                ans.emplace_back(res);\n            }\n        }\n        return ans;\n    }\n};","author":"unak","submissionId":"611242168"},[]]},{"1765":[{"id":"1765","fileName":"611242328.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>> mp;\n        vector<int> res;\n        int n = nums.size();\n        for (int i = 0; i < nums.size(); i++) {\n            mp[nums[i]].push_back(i);\n        }\n        for (auto& [k,v]: mp){\n            sort(v.begin(), v.end());\n        }\n        for (int i = 0; i < queries.size(); i++) {\n            int value = nums[queries[i]];\n            int index = lower_bound(mp[value].begin(),mp[value].end(),queries[i]) - mp[value].begin();\n            if (mp[value].size() == 1)res.push_back(-1);\n            else {\n                if (index ==  mp[value].size() - 1)res.push_back(min(mp[value][index] - mp[value][index - 1], (mp[value][0] - mp[value][index] + n)%n));\n                else if (index == 0)res.push_back(min(mp[value][index + 1] - mp[value][index],(mp[value][index] - mp[value][mp[value].size() -1]+n)%n));\n                else res.push_back(min(mp[value][index + 1] - mp[value][index],mp[value][index] - mp[value][index - 1]));\n            }\n        }\n        return res;\n    }\n};","author":"一行代码敲一天","submissionId":"611242328"},[]]},{"1766":[{"id":"1766","fileName":"611242268.txt","sourceCode":"import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int len = nums.length;\n        int[] newnums= new int[nums.length*3];\n        for (int i = 0; i < newnums.length; i++) {\n            newnums[i]=nums[i%(nums.length)];\n        }\n        int[] left = new int[(int)1e6+1];\n        int[] ans = new int[newnums.length];\n        for (int i = 0; i < newnums.length; i++) {\n            if(left[newnums[i]]>0) ans[i]=(1+i-left[newnums[i]]);\n            left[newnums[i]]=i+1;\n        }\n        for (int i = newnums.length-1; i > 0; i--) {\n            if(left[newnums[i]]>(i+1)) ans[i]=Math.min(ans[i],(left[newnums[i]]-i-1));\n            left[newnums[i]]=i+1;\n        }\n        List<Integer> myans = new ArrayList<>();\n        for (int i = 0; i < queries.length; i++) {\n            if(ans[queries[i]+len]>=len) myans.add(-1);\n            else myans.add(ans[queries[i]+len]);\n        }\n        return myans;\n    }\n}","author":"Run","submissionId":"611242268"},[]]},{"1768":[{"id":"1768","fileName":"611242334.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int  n = nums.length;\n        int[] vv = new int[1000001];\n        int[] pos = new int[n];\n        Arrays.fill(vv, -1);\n\n        int len = n * 2;\n        for (int i = 0; i < n; ++ i) {\n            pos[i] = 0x3ffffff;\n        }\n        \n        for (int i = 0; i < len; ++ i) {\n            int idx = i;\n            if (idx >= n) {\n                idx -= n;\n            }\n\n            if (vv[nums[idx]] == idx) {\n                vv[nums[idx]] = -1;\n            }\n            if (vv[nums[idx]] >= 0) {\n                pos[idx] = i - vv[nums[idx]];\n            }\n            vv[nums[idx]] = i;\n        }\n\n        //         for (int po : pos) {\n        //     System.out.print(po + \" \");\n        // }\n        // System.out.println();\n\n        Arrays.fill(vv, -1);\n        for (int i = len - 1; i >= 0; -- i) {\n            int idx = i;\n            if (idx >= n) {\n                idx -= n;\n            }\n\n            if (vv[nums[idx]] == idx + n) {\n                vv[nums[idx]] = -1;\n            }\n            if (vv[nums[idx]] >= 0) {\n                pos[idx] = Math.min(vv[nums[idx]] - i, pos[idx]);\n            }\n            vv[nums[idx]] = i;\n        }\n\n        //         for (int po : pos) {\n        //     System.out.print(po + \" \");\n        // }\n        // System.out.println();\n\n        List<Integer> ans = new ArrayList<>();\n        for (int query : queries) {\n            if (pos[query] == 0x3ffffff) {\n                pos[query] = -1;\n            }\n            ans.add(pos[query]);\n        }\n        return ans;\n    }\n}","author":"造假不好","submissionId":"611242334"},[]]},{"1770":[{"id":"1770","fileName":"611242475.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        ans = []\n        record = defaultdict(list)\n        for i, num in enumerate(nums):\n            record[num].append(i)\n        n = len(nums)\n        for idx in queries:\n            val = nums[idx]\n            if len(record[val]) == 1: \n                ans.append(-1)\n                continue\n            j = bisect_right(record[val], idx)\n            j2 = bisect_left(record[val], idx)\n            if j2 == 0: res = record[val][0] + n - record[val][-1]\n            else: res = record[val][0] + n - record[val][j2]\n            if j < len(record[val]):\n                res = min(res, record[val][j] - idx)\n            if j2 > 0:\n                res = min(res, idx - record[val][j2 - 1])\n            ans.append(res)\n        return ans","author":"sdl","submissionId":"611242475"},[]]},{"1771":[{"id":"1771","fileName":"611242548.txt","sourceCode":"#include<unordered_map>\n#include<vector>\n#include<algorithm>\n#include<iostream>\nusing namespace std;\n\n\nclass Solution {\n    unordered_map<int, vector<int>> mp;\n    vector<int> next, prev;\n    public:\n        vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n            for (int i = 0; i < nums.size(); ++i) {\n                mp[nums[i]].push_back(i);\n            }\n            next.reserve(nums.size());\n            prev.reserve(nums.size());\n\n            for (auto &p : mp) {\n                auto &v = p.second;\n                for (int i = 0; i < v.size(); ++i) {\n                    if (i) prev[v[i]] = v[i - 1];\n                    else prev[v[i]] = v[v.size() - 1] - nums.size();\n                    if (i + 1 < v.size()) next[v[i]] = v[i + 1];\n                    else next[v[i]] = v[0] + nums.size();\n                }\n            }\n\n            vector<int> ans;\n            for (int q : queries) {\n                ans.push_back(mp[nums[q]].size() < 2 ? -1 : min(next[q] - q, q - prev[q]));\n            } return ans;\n        }\n    };\n\n// int main() {\n//     Solution s;\n//     vector<int> nums = {1, 2, 1, 4, 5};\n//     vector<int> queries = {0, 1, 2, 3, 4};\n//     vector<int> ans = s.solveQueries(nums, queries);\n//     for (int i : ans) {\n//         cout << i << \" \";\n//     }\n//     cout << endl;\n//     return 0;\n// }","author":"译言丁真","submissionId":"611242548"},[]]},{"1772":[{"id":"1772","fileName":"611242380.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n = nums.size();\n        unordered_map<int,vector<int>> mp;\n        for(int i = 0; i < n; i++){\n            mp[nums[i]].push_back(i);\n        }\n        int m = q.size();\n        vector<int> ans(m);\n        for(int i = 0; i < m; i++){\n            auto& v = mp[nums[q[i]]];\n            int sz = v.size();\n            int j = ranges::lower_bound(v, q[i]) - v.begin();\n            // cout << j << \" \";\n            int dist = INT_MAX;\n            if(j){\n                dist = min(dist, v[j] - v[j-1]);\n            }else{\n                if(v.back() != q[i]){\n                    dist = min(dist, n - (v.back() - v[j]));\n                }\n            }\n            if(j < sz - 1){\n                dist = min(dist, v[j+1] - v[j]);\n            }else{\n                if(v[0] != q[i]){\n                    dist = min(dist, n - (v[j] - v[0]));\n                }\n            }\n            ans[i] = dist == INT_MAX ? -1 : dist;\n        }\n        return ans;\n    }\n};","author":"竹下为生","submissionId":"611242380"},[]]},{"1773":[{"id":"1773","fileName":"611242577.txt","sourceCode":"class Solution {\npublic:\n\tint process(vector<int>&arr,int num,int m)\n\t{\n\t\tint n=arr.size();\n\t\tif(n==1) return -1;\n\t\tint res=INT_MAX;\n\t\tint i=lower_bound(arr.begin(),arr.end(),num)-arr.begin();\n\t\tint t=arr[(i-1+n)%n];\n\t\tres=min(res,min(abs(num-t),m-abs(num-t)));\n\t\tt=arr[(i+1+n)%n];\n\t\tres=min(res,min(abs(num-t),m-abs(num-t)));\n//\t\tif(i-1>=0) res=min(res,min(abs(num-arr[i-1]),n-abs(num-arr[i-1])));\n//\t\tif(i+1<n)  res=min(res,min(abs(num-arr[i+1]),n-abs(num-arr[i+1])));\n\t\treturn res;\n\t}\n\tvector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n\t\tint n=nums.size();\n\t\tint m=queries.size();\n\t\tvector<int> res(m);\n\t\tunordered_map<int,vector<int>> hash;\n\t\tfor(int i=0;i<n;i++){\n\t\t\thash[nums[i]].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tres[i]=process(hash[nums[queries[i]]],queries[i],n);\n\t\t}\n\t\treturn res;\n\t}\n};","author":"ACM种子选手","submissionId":"611242577"},[]]},{"1774":[{"id":"1774","fileName":"611242481.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        idx_map = defaultdict(list)\n        for i, x in enumerate(nums):\n            idx_map[x].append(i)\n        n = len(nums)\n        ans = [0] * len(queries)\n        for i, q in enumerate(queries):\n            x = nums[q]\n            idx_list = idx_map[x]\n\n            if len(idx_list) == 1:\n                ans[i] = -1\n                continue\n\n            pos = bisect.bisect_left(idx_list, q)\n            left_idx = idx_list[-1] if pos == 0 else idx_list[pos - 1]\n            right_idx = idx_list[0] if pos == len(idx_list) - 1 else idx_list[pos + 1]\n            l_d = (q + n - left_idx) if pos == 0 else (q - left_idx)\n            r_d = (n - q + right_idx) if pos == len(idx_list) - 1 else (right_idx - q)\n            ans[i] = min(l_d, r_d)\n        return ans","author":"TonyDon","submissionId":"611242481"},[]]},{"1775":[{"id":"1775","fileName":"611242591.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n\tindexMap := make(map[int][]int)\n\n\tfor i, num := range nums {\n\t\tindexMap[num] = append(indexMap[num], i)\n\t}\n\n\tanswer := make([]int, len(queries))\n\tfor idx, q := range queries {\n\t\tv := nums[q]\n\t\tindices := indexMap[v]\n\t\t// 没有其他相同元素的情况\n\t\tif len(indices) <= 1 {\n\t\t\tanswer[idx] = -1\n\t\t\tcontinue\n\t\t}\n\n\t\t// indices 里面记录了相同元素的位置\n\t\tx := sort.SearchInts(indices, q)\n        //fmt.Println(\"search\",q, indices, x)\n\t\t// 取x-1 和 x+1\n\t\td1 := indices[(x-1+len(indices))%len(indices)]\n\t\td2 := indices[(x+1+len(indices))%len(indices)]\n        // 有两个方向可以选择\n        minDist := len(nums)\n        if d1<q {\n            minDist = min(minDist, q-d1)\n            minDist = min(minDist, d1+len(nums)-q)\n        } else {\n            minDist = min(minDist, d1-q)\n            minDist = min(minDist, q+len(nums)-d1)\n        }\n        if d2<q {\n            minDist = min(minDist, q-d2)\n            minDist = min(minDist, d2+len(nums)-q)\n        } else {\n            minDist = min(minDist, d2-q)\n            minDist = min(minDist, q+len(nums)-d2)\n        }\n        answer[idx] = minDist\n\t}\n\treturn answer\n}\n\nfunc abs(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}\n","author":"Elated HugleydP","submissionId":"611242591"},[]]},{"1776":[{"id":"1776","fileName":"611242647.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> ans=new ArrayList<>();\n        Map<Integer,List<Integer>> idx=new HashMap<>();\n        int n=nums.length;\n        for(int i=0;i<n;i++){\n            if(!idx.containsKey(nums[i])){\n                idx.put(nums[i],new ArrayList<>());\n            }\n            idx.get(nums[i]).add(i);\n        }\n        for(int i=0;i<queries.length;i++){\n            int val=nums[queries[i]],len=idx.get(val).size();\n            if(len==1){\n                ans.add(-1);\n                continue;\n            }\n            int l=0,r=len-1;\n            while(l<r){\n                int mid=(l+r)/2;\n                if(idx.get(val).get(mid)>=queries[i])r=mid;\n                else l=mid+1;\n            }\n            int res=n;\n            if(l<len-1){\n                res=Math.min(res,idx.get(val).get(l+1)-idx.get(val).get(l));\n            }else{\n                res=Math.min(res,n-idx.get(val).get(l)+idx.get(val).get(0));\n            }\n            if(l>0){\n                res=Math.min(res,idx.get(val).get(l)-idx.get(val).get(l-1));\n            }else{\n                res=Math.min(res,idx.get(val).get(l)+n-idx.get(val).get(len-1));\n            }\n            ans.add(res);\n        }\n        return ans;\n    }\n}","author":"鼠一鼠二的five","submissionId":"611242647"},[]]},{"1779":[{"id":"1779","fileName":"611242745.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        vector<int> ret;\n        int n = a.size();\n        vector<int> b(2 * n);\n        for (int i = 0; i < n; i++) {\n            b[i] = a[i];\n            b[i + n] = a[i];\n        }\n        vector<int> flag(1e6 + 5, -1);\n        for (int i = 2 * n - 1; i >= 0; i--) {\n            if (flag[b[i]] == -1) {\n                int t = b[i];\n                b[i] = -1;\n                flag[t] = i;\n            }\n            else {\n                int t = b[i];\n                b[i] = flag[b[i]];\n                flag[t] = i;\n            }\n        }\n        \n        vector<int> c(2 * n);\n        for (int i = 0; i < n; i++) {\n            c[i] = a[i];\n            c[i + n] = a[i];\n        }\n        vector<int> flag1(1e6 + 5, -1);\n        for (int i = 0; i < 2 * n; i++) {\n            if (flag1[c[i]] == -1) {\n                int t = c[i];\n                c[i] = -1;\n                flag1[t] = i;\n            }\n            else {\n                int t = c[i];\n                c[i] = flag1[c[i]];\n                flag1[t] = i;\n            }\n        }\n        \n        for (int x : q) {\n            int num = min(x + n - c[x + n], b[x] - x);\n            if (num >= n) ret.push_back(-1);\n            else ret.push_back(num);\n        }\n        return ret;\n    }\n};","author":"William","submissionId":"611242745"},[]]},{"1780":[{"id":"1780","fileName":"611242654.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], qu: List[int]) -> List[int]:\n        dit=defaultdict(list)\n        n=len(nums)\n        for i in range(n):\n            dit[nums[i]].append(i)\n        m=len(qu)\n        st=[-1]*m\n        for x in range(m):\n            i=qu[x]\n            ss=dit[nums[i]]\n            k=len(ss)\n            if k>1:\n                l,r=bisect_left(ss,i),bisect_right(ss,i)\n                l=(l-1)%k\n                r%=k\n                a,b=ss[l],ss[r]\n                x1,x2=max(a,i),min(a,i)\n                y1,y2=max(b,i),min(b,i)\n                st[x]=min(abs(x1-x2),abs(n-x1+x2),abs(y1-y2),abs(n-y1+y2))\n        return st\n        ","author":"书语","submissionId":"611242654"},[]]},{"1781":[{"id":"1781","fileName":"611242783.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        st = defaultdict(list)\n        for i, x in enumerate(nums):\n            st[x].append(i)\n        ans = [-1] * len(queries)\n        n = len(nums)\n        for i, q in enumerate(queries):\n            x = nums[q]\n            if len(st[x]) == 1: continue\n            index = bisect_left(st[x], q)\n            tn = len(st[x])\n            left = (st[x][index] - st[x][index - 1] + n) % n\n            right = (st[x][(index + 1) % tn] - st[x][index] + n) %n\n            ans[i] = (min(left, right))\n        return ans","author":"远空","submissionId":"611242783"},[]]},{"1782":[{"id":"1782","fileName":"611242758.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        num2idxes = defaultdict(list)\n        for idx, n in enumerate(nums):\n            num2idxes[n].append(idx)\n        ans = [-1 for _ in range(len(queries))]\n        n = len(nums)\n        for i, q in enumerate(queries):\n            target = nums[q]\n            if len(num2idxes[target]) == 1:\n                continue\n            idxes = num2idxes[target]\n            # 找到q在idxes中的位置，然后看左右的索引\n            nidxes = len(idxes)\n            targetidx = bisect.bisect_left(idxes, q)\n            if 0 < targetidx <= nidxes - 2:\n                ans[i] = min(q - idxes[targetidx - 1], idxes[targetidx + 1] - q)\n                continue\n            # 看循环数组\n            if targetidx == 0:\n                ans[i] = min(abs(q - idxes[1]), abs((n - idxes[-1]) + q))\n                continue\n            else:\n                ans[i] = min(abs((n - q) + idxes[0]), abs(idxes[-2] - q))\n                continue\n        return ans","author":"ycq","submissionId":"611242758"},[]]},{"1783":[{"id":"1783","fileName":"611242980.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& que) {\n        unordered_map<int, vector<int>> mp;\n\n        int n = a.size();\n        for ( int i = 0; i < n; i++ ) mp[a[i]].push_back(i - n);\n        for ( int i = 0; i < n; i++ ) mp[a[i]].push_back(i);\n        for ( int i = 0; i < n; i++ ) mp[a[i]].push_back(i + n);\n\n        vector<int> ans;\n        for ( int q : que ){\n            auto& vec = mp[a[q]];\n            int m = vec.size();\n            if ( m == 3 ){\n                ans.push_back(-1);\n                continue;\n            }\n            int p = lower_bound(vec.begin(), vec.end(), q) - vec.begin();\n            int l = -1e9, r = 1e9;\n            if ( p - 1 >= 0 ) l = vec[p - 1];\n            if ( p + 1 < m ) r = vec[p + 1];\n            int d1 = 1e9, d2 = 1e9;\n            if ( l != -1e9 ) d1 = min(q - l, (l - q + n) % n);\n            if ( r != 1e9 ) d2 = min(r - q, (q - r + n) % n);\n            ans.push_back(min(d1, d2));\n        }\n\n        return ans;\n    }\n};","author":"TeddyDUDU","submissionId":"611242980"},[]]},{"1785":[{"id":"1785","fileName":"611242949.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> res = new LinkedList<>();\n        int qn = queries.length;\n        int n = nums.length;\n        Map<Integer, TreeSet<Integer>> map = new HashMap<>();\n        for(int i = 0; i < n; i++){\n            int num = nums[i];\n            map.putIfAbsent(num, new TreeSet<>());\n            map.get(num).add(i);\n        }\n        for(int q: queries){\n            int num = nums[q];\n            if(!map.containsKey(num)) res.add(-1);\n            else{\n                Integer high = map.get(num).higher(q);\n                Integer low = map.get(num).lower(q);\n                Integer first = map.get(num).first();\n                Integer last = map.get(num).last();\n                if(high == null && low == null) res.add(-1);\n                else if(high == null){\n                    if(q - low <= n - q + first) res.add(q - low);\n                    else res.add(n - q + first);\n                }\n                else if(low == null){\n                    if(high - q <= q + n - last) res.add(high - q);\n                    else res.add(q + n - last);\n                }\n                else{\n                    int candh = last;\n                    int dist = q + n - last;\n                    if(high - q <= q + n - last){\n                        candh = high;\n                        dist = high - q;\n                    }\n                    int candl = first;\n                    int distl = n - q + first;\n                    if(q - low <= n - q + first){\n                        candl = low;\n                        distl = q - low;\n                    }\n                    int cand;\n                    if(dist > distl) dist = distl;\n                    //else cand = candl;\n                    res.add(dist);\n                }\n            }\n        }\n        return(res);\n        \n    }\n}","author":"Jovial TorvaldsDzi","submissionId":"611242949"},[]]},{"1786":[{"id":"1786","fileName":"611242943.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        nums.resize(3 * n);\n\n        // 扩大成为三重数组，我们将中间的数组视为原数组\n        for(int i = 1; i <= 2; i++){\n           for(int j = 0; j < n; j++){\n               nums[i * n + j] = nums[j];\n           } \n        }\n\n        unordered_map<int, int>indexToDistance;\n        unordered_map<int, int>valToIndex;\n\n        for(int i = 0; i < 3 * n; i++){\n            if(valToIndex.contains(nums[i])){\n                //如果已经出现过该数字\n                int lastIndex = valToIndex[nums[i]];\n                int distanceNow = i - lastIndex;\n                if(indexToDistance.contains(lastIndex)){\n                    //如果该数字已经是第三次或以上出现\n                    indexToDistance[lastIndex] = min(distanceNow, indexToDistance[lastIndex]);\n                }\n                else{\n                    indexToDistance[lastIndex] = distanceNow;\n                }\n                indexToDistance[i] = distanceNow;\n            }\n            valToIndex[nums[i]] = i; \n        }\n\n        int m = queries.size();\n        vector<int>answer(m, -1);\n        for(int i = 0; i < m; i++){\n            int index = queries[i];\n            answer[i] = indexToDistance[index + n] == n? -1 : indexToDistance[index + n];\n        }\n        return answer;\n    }\n};","author":"WWWeeds","submissionId":"611242943"},[]]},{"1787":[{"id":"1787","fileName":"611242881.txt","sourceCode":"class Solution {\n\tpublic:\n\t\tint ans[1000001];\n\t\tint arr[3000001];\n\t\tvector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n\t\t\tmap<int,int> m;\n\t\t\tint n=nums.size();\n\t\t\tfor(int z=0; z<3; ++z) {\n\t\t\t\tfor(int i=0; i<n; ++i) {\n\t\t\t\t\tarr[i+z*n]=nums[i];\n\t\t\t\t}\n\t\t\t}\n            // for(int i=0;i<3*n;++i){\n            //     cout<<arr[i]<<\" \";\n            // }\n            // cout<<endl;\n\t\t\tfill(ans,ans+n,n);\n\t\t\tfor(int i=0; i<n; ++i) {\n\t\t\t\tm[arr[i]]=i;\n\t\t\t}\n\t\t\tfor(int i=n; i<2*n; ++i) {\n\t\t\t\tans[i-n]=i-m[arr[i]];\n\t\t\t\tm[arr[i]]=i;\n\t\t\t}\n            // for(int i=0;i<n;++i){\n            //     cout<<ans[i]<<\" \";\n            // }\n            // cout<<endl;\n\t\t\tm.clear();\n\t\t\tfor(int i=3*n-1; i>=2*n; --i) {\n\t\t\t\tm[arr[i]]=i;\n\t\t\t}\n\t\t\tfor(int i=2*n-1; i>=n; --i) {\n\t\t\t\tans[i-n]=min(ans[i-n],m[arr[i]]-i);\n\t\t\t\tm[arr[i]]=i;\n\t\t\t}\n\n\t\t\tvector<int> an(queries.size());\n\t\t\tfor(int i=0; i<queries.size(); ++i) {\n\t\t\t\tan[i]=ans[queries[i]]==n?-1:ans[queries[i]];\n\t\t\t}\n\t\t\treturn an;\n\t\t}\n};","author":"无敌java大王","submissionId":"611242881"},[]]},{"1789":[{"id":"1789","fileName":"611243167.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,int> index,first;\n        int n=nums.size(),q=queries.size();\n        vector<int> dir(n,n+1);\n        for(int i=0;i<n;i++){\n            int a=nums[i];\n            if(index.find(a)==index.end()){\n                index[a]=i;\n                first[a]=i;\n            }\n            else{\n                dir[index[a]]=min(dir[index[a]],i-index[a]);\n                dir[i]=i-index[a];\n                index[a]=i;\n            }\n        }\n        for(int i=0;i<q;i++){\n            int x=queries[i],a=nums[queries[i]];\n            queries[i]=dir[x];\n            if(queries[i]==n+1)queries[i]=-1;\n            else if(x==first[a]||x==index[a])\n                queries[i]=min(queries[i],n+first[a]-index[a]);\n        }\n        return queries;\n    }\n};","author":"Ch7k","submissionId":"611243167"},[]]},{"1790":[{"id":"1790","fileName":"611243082.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        int[] leftPtr = new int[n];\n        int[] rightPtr = new int[n];\n        Map<Integer, Integer> preMap = new HashMap<>();\n\n        Arrays.fill(leftPtr, -1);\n        for (int ptr = 0; ptr < 2 * n; ptr++) {\n            int actualPtr = ptr % n;\n            Integer prePtr = preMap.getOrDefault(nums[actualPtr], actualPtr);\n            if (prePtr != actualPtr) {\n                leftPtr[actualPtr] = prePtr;\n            }\n            preMap.put(nums[actualPtr], actualPtr);\n        }\n\n        preMap.clear();\n        Arrays.fill(rightPtr, -1);\n        for (int ptr = (2 * n - 1); ptr >= 0; ptr--) {\n            int actualPtr = ptr % n;\n            Integer prePtr = preMap.getOrDefault(nums[actualPtr], actualPtr);\n            if (prePtr != actualPtr) {\n                rightPtr[actualPtr] = prePtr;\n            }\n            preMap.put(nums[actualPtr], actualPtr);\n        }\n\n        List<Integer> ans = new ArrayList<>();\n        for (int query : queries) {\n            int left = leftPtr[query];\n            int right = rightPtr[query];\n            if (left != -1 && right != -1) {\n                int leftDistance = (query + n - left) % n;\n                int rightDistance = (right + n - query) % n;\n                ans.add(Math.min(leftDistance, rightDistance));\n            } else if (left == -1 && right == -1) {\n                ans.add(-1);\n            } else if (left != -1) {\n                ans.add((query + n - left) % n);\n            } else {\n                ans.add((right + n - query) % n);\n            }\n        }\n\n        return ans;\n    }\n}","author":"随缘","submissionId":"611243082"},[]]},{"1791":[{"id":"1791","fileName":"611243017.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        # 数字到索引的列表\n        num2idx_list = {}\n        for idx, num in enumerate(nums):\n            if num not in num2idx_list:\n                num2idx_list[num] = []\n            num2idx_list[num].append(idx)\n\n        # 开始查找\n        res = []\n        for query in queries:\n            res.append(self.nearest_dist(nums, num2idx_list, query))\n        \n        return res\n\n        \n    def nearest_dist(self, nums, num2idx_list, q_idx):\n        # 找到对应索引列表\n        q_num = nums[q_idx]\n        if len(num2idx_list[q_num]) == 1:\n            return -1\n\n        # 找到索引所在的位置，之后和前后索引比较\n        idx_list = num2idx_list[q_num]\n        target = q_idx\n        left, right = 0, len(idx_list) - 1\n        target_pos = None\n        while left <= right:\n            mid = left + (right - left) // 2\n            if idx_list[mid] == target:\n                target_pos = mid\n                break\n            elif idx_list[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        # target_pos是q_idx所在的位置，需要计算q_idx和它附近元素的距离\n        n = len(nums)\n        def cal_dist(idx_1, idx_2):\n            return min(idx_2 - idx_1, idx_1 + n - idx_2)\n\n        left_dist = cal_dist(idx_list[target_pos-1], target) if target_pos > 0 else cal_dist(target, idx_list[-1])\n        right_dist = cal_dist(target, idx_list[target_pos+1]) if target_pos < len(idx_list) - 1 else cal_dist(idx_list[0], target)\n\n        return min(left_dist, right_dist)\n\n        ","author":"rran2023","submissionId":"611243017"},[]]},{"1793":[{"id":"1793","fileName":"611243210.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        mp = defaultdict(list)\n        for i, num in enumerate(nums):\n            mp[num].append(i)\n        m = len(nums)\n        res = []\n        for q in queries:\n            num = nums[q]\n            if len(mp[num]) == 1:\n                res.append(-1)\n                continue\n            else:\n                l = bisect.bisect_left(mp[num], q)\n                n = len(mp[num])\n                pre = l - 1 if l > 0 else n-1\n                sub = l + 1 if l < n-1 else 0\n                dis = min(abs(mp[num][l] - mp[num][pre]), abs(mp[num][l] - mp[num][sub]))\n                if l == 0:\n                    # print(n, mp[num][pre], mp[num][l])\n                    dis = min(dis, m-mp[num][pre] + mp[num][l])\n                elif l == n-1:\n                    dis = min(dis, m-mp[num][l] + mp[num][sub])\n                res.append(dis)\n        return res\n            ","author":"wither","submissionId":"611243210"},[]]},{"1794":[{"id":"1794","fileName":"611243160.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        // 本题思路二分查找\n        unordered_map<int, vector<int>> indexes;\n        int n = nums.size();\n        int m = queries.size();\n        vector<int> ans(m, -1);\n        for (int i = 0; i < n; i++) {\n            indexes[nums[i]].push_back(i);\n        }\n        for (int i = 0; i < m; i++) {\n            int q = queries[i];\n            int val = nums[q];\n            vector<int>& idxes = indexes[val]; // 存储下标\n            if (idxes.size() >= 2) {\n            int res = INT_MAX;\n            auto iter = lower_bound(idxes.begin(), idxes.end(), q); // 找到下标的迭代器\n            // 找到前一个下标\n            if (iter == idxes.begin()) {\n                res = min(res, n - (*(idxes.end()-1) - *iter));\n            } else {\n                res = min(res, (*iter - *(iter - 1)));\n            }\n            // 找到后一个下标\n            if (iter == idxes.end() - 1) {\n                res = min(res, n - abs(*idxes.begin() - *iter));\n            } else {\n                res = min(res, (*(iter + 1) - *iter));\n            }\n            ans[i] = res;\n            }\n        }\n        return ans;\n    }\n};","author":"cheningfrank","submissionId":"611243160"},[]]},{"1795":[{"id":"1795","fileName":"611243112.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, array<int,2>> mp;\n        int n = nums.size();\n        vector<int> ans(n, INT_MAX);\n        for(int i=0; i<n; i++) {\n            int x = nums[i];\n            if(mp.contains(x)) {\n                ans[i] = min({ans[i], i-mp[x][1], n+mp[x][0]-i});\n                mp[x][1] = i;\n            } else {\n                mp[x] = {i,i};\n            }\n        }\n        mp.clear();\n        for(int i=n-1; i>=0; i--) {\n            int x = nums[i];\n            if(mp.contains(x)) {\n                ans[i] = min({ans[i], mp[x][0]-i, n-mp[x][1]+i});\n                mp[x][0] = i;\n            } else {\n                mp[x] = {i, i};\n            }\n        }\n        for(int i=0; i<n; i++)\n            if(ans[i] == INT_MAX) ans[i] = -1;\n        vector<int> res;\n        for(int x : queries) {\n            res.push_back(ans[x]);\n        }\n        return res;\n    }\n};","author":"OHNO","submissionId":"611243112"},[]]},{"1796":[{"id":"1796","fileName":"611243330.txt","sourceCode":"const int INF = 0x3f3f3f3f;\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> ans;\n        int mx = 0;\n        for(int i = 0;i<nums.size();i++){\n            mx = max(mx,nums[i]);\n        }\n        vector<vector<int> > v(mx+1);\n        for(int i = 0;i<nums.size();i++){\n            v[nums[i]].push_back(i);\n        }\n        for(int i= 0;i<queries.size();i++){\n            int u = queries[i];\n            int st = lower_bound(v[nums[u]].begin(),v[nums[u]].end(),u)-v[nums[u]].begin();\n            int res = INF;\n            if(st!=0){\n                res = min(res,u-v[nums[u]][st-1]);\n                // if(u == 9){\n                //     cout<<res<<endl;\n                // }\n            }\n            if(st == 0 && v[nums[u]].size() != 1){\n                if(u == 9){\n                    cout<<res<<endl;\n                }\n                res = min(res,v[nums[u]][st]+(int)nums.size()-v[nums[u]].back());\n            }\n            if(st<v[nums[u]].size()-1){\n                if(u == 9){\n                    cout<<res<<endl;\n                }\n                res = min(res,v[nums[u]][st+1]-u);\n                if(u == 9){\n                    cout<<v[nums[u]][st+1]<<\" \"<<u<<endl;\n                    cout<<res<<endl;\n                }\n            }\n                \n            \n            if(st == v[nums[u]].size()-1 && v[nums[u]].size()!= 1){\n                res = min(res,v[nums[u]][0]+(int)nums.size()-u);\n            }\n            if(res  == INF)ans.push_back(-1);\n            else ans.push_back(res);\n        }\n        return ans;\n    }\n};","author":"loliconsk","submissionId":"611243330"},[]]},{"1797":[{"id":"1797","fileName":"611243218.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n\tn := len(nums)\n\tposMap := make(map[int][]int)\n\tfor i, num := range nums {\n\t\tposMap[num] = append(posMap[num], i)\n\t}\n\tfor num := range posMap {\n\t\tsort.Ints(posMap[num])\n\t}\n\n\tres := make([]int, len(queries))\n\tfor qi, idx := range queries {\n\t\tx := nums[idx]\n\t\tindices := posMap[x]\n\t\tif len(indices) < 2 {\n\t\t\tres[qi] = -1\n\t\t\tcontinue\n\t\t}\n\t\tpos := sort.Search(len(indices), func(i int) bool {\n\t\t\treturn indices[i] >= idx\n\t\t})\n\t\tvar prev, next int\n\t\tif pos == 0 {\n\t\t\tprev = indices[len(indices)-1]\n\t\t} else {\n\t\t\tprev = indices[pos-1]\n\t\t}\n\t\tif pos == len(indices)-1 {\n\t\t\tnext = indices[0]\n\t\t} else {\n\t\t\tnext = indices[pos+1]\n\t\t}\n\n\t\td1 := distance(idx, prev, n)\n\t\td2 := distance(idx, next, n)\n\t\tres[qi] = min(d1, d2)\n\t}\n\treturn res\n}\n\nfunc distance(i, j, n int) int {\n\tdiff := abs(i - j)\n\tif diff > n-diff {\n\t\treturn n - diff\n\t}\n\treturn diff\n}\n\nfunc abs(a int) int {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}","author":"汪星银","submissionId":"611243218"},[]]},{"1798":[{"id":"1798","fileName":"611243365.txt","sourceCode":"#include <bits/stdc++.h>\n#define debug(a) cout<<#a<<\"=\"<<a<<\"n\"\n#define EPS 1e-8\n#define IOS ios::sync_with_stdio(0),cin.tie(0)\n#define all(v) v.begin(),v.end()\nusing namespace std;\nusing i64 = long long;\nusing ull = unsigned long long;\nusing pi = pair<int,int>;\nusing pl = pair<long long,long long>;\nstatic constexpr int ALPHABET_SIZE = 26;\nstatic constexpr i64 N = 1000000 + 5;\nstatic constexpr int MOD = 998244353;\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        //预处理下标\n        map<int, vector<int>> m;\n        int n = nums.size(), q = queries.size();\n        for (int i = 0; i < n; i++) {\n            int cur = nums[i];\n            m[cur].emplace_back(i);\n        }\n        vector<int> res;\n        //处于开始和结尾的需要特判\n        for (int i = 0; i < q; i++) {\n            int curIdx = queries[i];\n            int cur = nums[curIdx];\n            if (m[cur].size() == 1) {\n                res.emplace_back(-1);\n            } else {\n                int dis = INT_MAX;\n                int p = m[cur].size();\n                const auto & v = m[cur];\n                if (curIdx == v[p - 1]) {\n                    int d1 = n - v[p - 1] + v[0];\n                    int d2 = v[p - 1] - v[p - 2];\n                    dis = min({dis, d1, d2});\n                }\n                else if (curIdx == v[0]) {\n                    int d1 = v[1] - v[0];\n                    int d2 = n - v[p - 1] + v[0];\n                    dis = min({dis, d1, d2});\n                } else {\n                    //二分一下\n                    int idx1 = upper_bound(all(v), curIdx) - v.begin();\n                    int idx2 = idx1 - 2;\n                    int d1 = v[idx1] - curIdx;\n                    int d2 = curIdx - v[idx2];\n                    dis = min({dis, d1, d2});\n                }\n                res.emplace_back(dis);\n            }\n        }\n        return res;\n    }\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n","author":"千早爱音","submissionId":"611243365"},[]]},{"1799":[{"id":"1799","fileName":"611243599.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        vector<int> l(n,-1);\n        vector<int> r(n,-1);\n        vector<int> res;\n        unordered_map<int,int> mp,first,last;\n        for(int i=0;i<n;i++){\n            if(mp.find(nums[i])!=mp.end()){\n                l[i]=mp[nums[i]];\n            }\n            else{\n                first[nums[i]]=i;\n            }\n            mp[nums[i]]=i;\n        }\n        mp.clear();\n        for(int i=n-1;i>=0;i--){\n            if(mp.find(nums[i])!=mp.end()){\n                r[i]=mp[nums[i]];\n            }\n            else{\n                last[nums[i]]=i;\n            }\n            mp[nums[i]]=i;\n        }\n        for(int i=0;i<queries.size();i++){\n            int j=queries[i];\n            int lstep,rstep;\n            if(l[j]==-1 && r[j]==-1){\n                res.push_back(-1);\n                continue;\n            }\n            if(l[j]!=-1){\n                lstep=j-l[j];\n            }\n            else{\n                lstep=j+n-last[nums[j]];\n            }\n            if(r[j]!=-1){\n                rstep=r[j]-j;\n            }\n            else{\n                rstep=n-j+first[nums[j]];\n            }\n            res.push_back(min(lstep,rstep));\n        }\n        return res;\n    }\n};","author":"xxz","submissionId":"611243599"},[]]},{"1801":[{"id":"1801","fileName":"611243487.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int, vector<int>> ma;\n        for (int i = 0;i < nums.size();i++) {\n            ma[nums[i]].push_back(i);\n        }\n        int n = nums.size();\n        vector<int> ans;\n        for (int x : queries) {\n            int t = nums[x];\n            if (!ma.count(t)) {\n                ans.push_back(-1);\n                continue;\n            }\n            auto a = std::lower_bound(ma[t].begin(), ma[t].end(), x);\n            int dis = 1e9;\n            if (a != ma[t].begin()) {\n                dis = min(x - *prev(a), dis);\n            }\n            else {\n                dis = min(n - *ma[t].rbegin() + x, dis);\n            }\n            ++a;\n            if (a != ma[t].end()) {\n                dis = min(*(a)-x, dis);\n            }\n            else {\n                dis = min(n - x + *ma[t].begin(), dis);\n            }\n\n            dis = dis >= n ? -1 : dis;\n            ans.push_back(dis);\n        }\n        return ans;\n    }\n};","author":"Violet","submissionId":"611243487"},[]]},{"1802":[{"id":"1802","fileName":"611243689.txt","sourceCode":"public class Solution {\n    public IList<int> SolveQueries(int[] nums, int[] queries)\n    {\n        List<int> list = new List<int>();\n        Dictionary<int, List<int>> dict = new Dictionary<int, List<int>>();\n        for (int i = 0; i < nums.Length; ++i)\n        {\n            if (dict.ContainsKey(nums[i]))\n            {\n                dict[nums[i]].Add(i);\n            }\n            else\n            {\n                dict[nums[i]] = new List<int>() { i };\n            }\n        }\n        for (int i = 0; i < queries.Length; ++i)\n        {\n            list.Add(Qf(dict[nums[queries[i]]], queries[i], nums.Length));\n        }\n        return list;\n    }\n\n    public int Qf(List<int> list, int idx, int count)\n    {\n        if (list.Count <= 1) return -1;\n        int left = -1, right = list.Count;\n        while (left + 1 < right)\n        {\n            int mid = (left + right) / 2;\n            if (list[mid] <= idx) left = mid;\n            else right = mid;\n        }\n        int t2 = (left + 1) % list.Count, t1 = (left + list.Count - 1) % list.Count;\n        return Math.Min(GetMinDis(list[t1], list[left], count), GetMinDis(list[left], list[t2], count));\n    }\n\n    public int GetMinDis(int x1, int x2, int len)\n    {\n        return Math.Min(Math.Abs(x1 - x2), Math.Min(x1 + len - x2, x2 + len - x1));\n    }\n}","author":"dyx0727","submissionId":"611243689"},[]]},{"1803":[{"id":"1803","fileName":"611243409.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> res;\n        std::unordered_map<int, vector<int>> n2idx;\n        for (int i = 0; i < nums.size(); ++ i) {\n            n2idx[nums[i]].push_back(i);\n        }\n        for (auto q : queries) {\n            int x = nums[q];\n            if (n2idx[x].size() == 1) {\n                res.push_back(-1);\n            } else {\n                auto& v = n2idx[x];\n                int low = 0;\n                int high = v.size() - 1;\n                while (low <= high) {\n                    int mid = (low + high) >> 1;\n                    if (v[mid] <= q) {\n                        low = mid + 1;\n                    } else {\n                        high = mid - 1;\n                    }\n                }\n                int cur = high;\n                int tmp = -1;\n                int n = nums.size();\n                if (cur == 0) {\n                    tmp = std::min(v[cur + 1] - q, n - (*v.rbegin() - v[cur]));\n                } else if (cur == v.size() - 1) {\n                    tmp = std::min(q - v[cur - 1], n - (v[cur] - *v.begin()));\n                } else {\n                    tmp = std::min(q - v[cur - 1], v[cur + 1] -q );\n                    \n                }\n                res.push_back(tmp);\n            }\n        }\n        return res;\n        \n    }\n};","author":"是个小号","submissionId":"611243409"},[]]},{"1804":[{"id":"1804","fileName":"611243756.txt","sourceCode":"int pre[100005],tai[100005];\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,int>mp;\n        map<int,int>mf;\n        int n=nums.size(),m=queries.size();\n        //for(int i=0;i<n;i++)nums.push_back(nums[i]);\n        //n*=2;\n        for(int i=0;i<=n;i++)pre[i]=tai[i]=-1e9;\n        for(int i=1;i<=n;i++){\n           int x=nums[i-1];\n            if(mp[x]!=0){\n                pre[i]=mp[x];\n                tai[mp[x]]=i;\n            }else{\n                mf[x]=i;\n            }\n            mp[x]=i;\n        }\n        for(auto p:mf){\n            int x=nums[p.second-1];\n            if(mp[x]!=mf[x]){\n                tai[mp[x]]=n+mf[x];\n                pre[mf[x]]=0-(n-mp[x]);\n            }\n        }\n        vector<int>ans(m,-1);\n        for(int i=0;i<m;i++){\n            int id=queries[i]+1;\n            int t=1e9;\n            if(pre[id]!=-1e9)t=min(id-pre[id],n-(id-pre[id]));\n            if(tai[id]!=-1e9)t=min(t,min(tai[id]-id,n-(tai[id]-id)));\n            if(t!=1e9)ans[i]=t;\n        }\n        return ans;\n    }\n};","author":"Infallible FeynmanBTV","submissionId":"611243756"},[]]},{"1805":[{"id":"1805","fileName":"611244003.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        vector<int> pos(nums.size());\n        for (int i = 0; i < nums.size(); i++) {\n            mp[nums[i]].push_back(i);\n            pos[i] = mp[nums[i]].size()-1;\n        }\n        vector<int> ans;\n        for (auto index: queries) {\n            vector<int> &arr = mp[nums[index]];\n            if (arr.size() == 1) {\n                ans.push_back(-1);\n                continue;\n            }\n            int n = arr.size();\n            int l = arr[(pos[index]+n-1)%n];\n            int r = arr[(pos[index]+1)%n];\n            ans.push_back(min(min((int)nums.size()-abs(index-l), abs(index-l)),\n                min((int)nums.size()-abs(index-r), abs(index-r))));\n        }\n        return ans;\n    }\n};","author":"lovely","submissionId":"611244003"},[]]},{"1806":[{"id":"1806","fileName":"611243824.txt","sourceCode":"class Solution {\n    fun solveQueries(nums: IntArray, queries: IntArray): List<Int> {\n        // nums 循环 数组 《- 应该就是两端可以互通的意思？距离\n        //     0 1 2 .. a .. b .. n - 1 .. n(0)\n        //     d = b - a or d = a + n - b\n        // 存在 nums[j] == nums[queries[i]]，queries[i] 和 j\n        //     则 为 j，且取最小\n        // 要取相同元素，可以 map 存 list，但是最小要怎么取？指左右，这样可以 O(1),\n        //     左右但只有 list 不够用，需要快速从 list 中找出下标，二分吗？毕竟有序\n        // 1 <= nums[i] <= 106\n        // n=10 7 时间复杂度最多O(n)\n        // n=10 5 时间复杂度最多O(nlogn)\n        // 证明尽量要 O(n)\n        // 不存在则 -1\n\n        val map = HashMap<Int, MutableList<Int>>() // value to indexlist\n        nums.forEachIndexed { index, num ->\n            if (num !in map) {\n                map[num] = mutableListOf<Int>()\n            }\n            map[num]!!.add(index)\n        }\n        val res = mutableListOf<Int>()\n        val n = nums.size\n        queries.forEachIndexed { index, query ->\n            val list = map[nums[query]]!!\n            if (list.size == 1) {\n                res.add(-1)\n            } else if (list.size == 2) {\n                res.add(d(list[0], list[1], n))\n            } else {\n                // 多个元素，取左右即可？\n                val queryIndexInlist = binarySearch(list, query)\n                var left = queryIndexInlist - 1\n                if (left == -1)\n                    left = list.size - 1\n                var right = queryIndexInlist + 1\n                if (right == list.size)\n                    right = 0\n                val d1 = d(query, list[left], n)\n                val d2 = d(query, list[right], n)\n                res.add(min(d1, d2))\n            }\n        }\n        return res\n    }\n\n    fun d(a: Int, b: Int, n: Int): Int {\n        if (a > b)\n            return d(b, a, n)\n        return min(b - a, a + n - b)\n    }\n\n    fun binarySearch(arr: List<Int>, target: Int): Int {\n        var left = 0\n        var right = arr.size - 1\n    \n        while (left <= right) {\n            val mid = left + (right - left) / 2  // 防止溢出\n    \n            if (arr[mid] == target) {\n                return mid  // 找到目标值，返回索引\n            } else if (arr[mid] < target) {\n                left = mid + 1  // 目标值在右侧\n            } else {\n                right = mid - 1  // 目标值在左侧\n            }\n        }\n    \n        return -1  // 如果没有找到目标值，返回 -1\n    }\n}","author":"Loving Merkle","submissionId":"611243824"},[]]},{"1809":[{"id":"1809","fileName":"611244180.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        int n = nums.size();\n        vector<int> ans(queries.size(), -1);\n\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n\n        for (int i = 0; i < queries.size(); i++) {\n            int q = queries[i];\n            if (mp[nums[q]].size() == 1) continue;\n            \n            auto &a = mp[nums[q]]; \n            int m = a.size();\n            int idx = lower_bound(a.begin(), a.end(), q) - a.begin();\n            int res = INT_MAX;\n\n\n            if (idx > 0) {\n                res = min(res, a[idx] - a[idx - 1]);\n            } else {\n                res = min(res, n + a[idx] - a[m - 1]);\n            }\n\n            if (idx < m - 1) {\n                res = min(res, a[idx + 1] - a[idx]);\n            } else {\n                res = min(res, n + a[0] - a[idx]);\n            }\n\n            ans[i] = res; \n        }\n\n        return ans;\n    }\n};\n","author":"๑古月ღ","submissionId":"611244180"},[]]},{"1810":[{"id":"1810","fileName":"611244191.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n=nums.length;\n        int m=queries.length;\n        HashMap<Integer,List<Integer>> map=new HashMap<>(n);\n        for(int i=0;i<n;i++){\n            map.computeIfAbsent(nums[i],k->new ArrayList<>()).add(i);\n        }\n        for(Map.Entry<Integer,List<Integer>> entry:map.entrySet()){\n            Collections.sort(entry.getValue());\n        }\n        List<Integer> ans=new ArrayList<>(m);\n        for(int q:queries){\n            List<Integer> idxs=map.get(nums[q]);\n            if(idxs.size()==1){\n                ans.add(-1);\n                continue;\n            }\n            int idx=lb(idxs,q);//索引的下标\n            int k=idxs.size();\n            int pidx=idxs.get((idx-1+k)%k);\n            int nidx=idxs.get((idx+1+k)%k);\n            int minl=Math.min((q-pidx+n)%n,(nidx-q+n)%n);\n            ans.add(minl);\n        }\n        return ans;\n    }\n    private int lb(List<Integer> idxs,int target){\n        int l=0,r=idxs.size()-1;\n        while(l<=r){\n            int m=(l+r)>>1;\n            if(idxs.get(m)<target)l=m+1;\n            else r=m-1;\n        }\n        return l;\n    }\n}","author":"111","submissionId":"611244191"},[]]},{"1811":[{"id":"1811","fileName":"611244352.txt","sourceCode":"public class Solution {\n        public IList<int> SolveQueries(int[] nums, int[] queries)\n        {\n            IList<int> ans = new List<int>(queries.Length);\n            int[] before = new int[nums.Length];\n            int[] next = new int[nums.Length];\n            Array.Fill(before, -1);\n            Array.Fill(next, -1);\n            int max = nums.Max();\n            int[] indexs = new int[max + 1];\n            int[] firsts = new int[max + 1];\n            int[] lasts = new int[max + 1];\n            Array.Fill(indexs, -1);\n            Array.Fill(firsts, -1);\n            Array.Fill(lasts, -1);\n            for (int i = 0; i < nums.Length; i++)\n            {\n                int val = nums[i];\n                if (indexs[val] != -1)\n                {\n                    before[i] = indexs[val];\n                    next[before[i]] = i;\n                }\n                indexs[val] = i;\n                if (firsts[val] == -1)\n                {\n                    firsts[val] = i;\n                }\n                lasts[val] = i;\n            }\n            for (int i = 0; i < queries.Length; i++)\n            {\n                int index = queries[i];\n                int val = nums[index];\n                int minLength = int.MaxValue;\n                bool isOne = firsts[val] == lasts[val];\n                if (before[index] != -1)\n                {\n                    minLength = Math.Abs(before[index] - index);\n                }\n                else if (lasts[val] != -1 && !isOne)\n                {\n                    int len = index + (nums.Length - lasts[val]);\n                    minLength = Math.Min(minLength, len);\n                }\n                if (next[index] != -1)\n                {\n                    minLength = Math.Min(minLength, Math.Abs(next[index] - index));\n                }\n                else if (firsts[val] != -1 && !isOne)\n                {\n                    int len = firsts[val] + (nums.Length - index);\n                    minLength = Math.Min(minLength, len);\n                }\n                if (minLength == int.MaxValue)\n                    minLength = -1;\n                ans.Add(minLength);\n            }\n            return ans;\n        }\n\n\n\n\n\n}","author":"nine","submissionId":"611244352"},[]]},{"1812":[{"id":"1812","fileName":"611244071.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, TreeSet<Integer>> map = new HashMap<>();\n        int n = nums.length;\n        for (int i = 0; i < n; ++i) {\n            map.computeIfAbsent(nums[i], k -> new TreeSet<>()).add(i);\n        }\n        int m = queries.length;\n        List<Integer> ans = new ArrayList<>();\n        for (int i = 0; i < m; ++i) {\n            TreeSet<Integer> set = map.get(nums[queries[i]]);\n            if (set.size() == 1) {\n                ans.add(-1);\n            } else {\n                Integer l = set.lower(queries[i]);\n                if (l == null) {\n                    l = set.last();\n                }\n                Integer r = set.higher(queries[i]);\n                if (r == null) {\n                    r = set.first();\n                }\n                if (Math.min(Math.abs(l - queries[i]), n - Math.abs(l - queries[i])) <\n                   Math.min(Math.abs(r - queries[i]), n - Math.abs(r - queries[i]))) {\n                    ans.add(Math.min(Math.abs(l - queries[i]), n - Math.abs(l - queries[i])));\n                   } else {\n                    ans.add(Math.min(Math.abs(r - queries[i]), n - Math.abs(r - queries[i])));\n                   }\n            }\n        }\n        return ans;\n    }\n}","author":"zzl","submissionId":"611244071"},[]]},{"1813":[{"id":"1813","fileName":"611244347.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dic=dict()\n        dic1=dict()\n        arr=[[len(nums),len(nums)] for _ in range(len(nums))]\n        for k,v in enumerate(nums):\n            if v in dic:\n                pre=dic[v]\n                arr[pre][1]=min(k-pre,len(nums)-k+pre)\n                arr[k][0]=min(k-pre,len(nums)-k+pre)\n                arr[k][1]=len(nums)-k+dic1[v]\n                arr[dic1[v]][0]=len(nums)-k+dic1[v]\n            else:\n                dic1[v]=k\n            dic[v]=k\n        ans=[0]*len(queries)\n        for i in range(len(queries)):\n            op=arr[queries[i]]\n            if op[0]==len(nums):\n                ans[i]=-1\n            else:\n                ans[i]=min(op)\n        return ans\n            \n        \n        ","author":"锦衣夜行0425","submissionId":"611244347"},[]]},{"1814":[{"id":"1814","fileName":"611244412.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> ans;\n        unordered_map<int, vector<int>> is;\n        for (int i = 0; i < n; i++) {\n            is[nums[i]].push_back(i);\n        }\n        for (int& q : queries) {\n            vector<int>& find = is[nums[q]];\n            if (find.size() == 1) ans.push_back(-1);\n            else {\n                int j = lower_bound(find.begin(), find.end(), q) - find.begin();\n                if (j == 0) ans.push_back(min(find[1] - find[0], n - find.back() + find[0]));\n                else if (j == find.size() - 1) ans.push_back(min(n - find.back() + find[0], find.back() - find[find.size() - 2]));\n                else ans.push_back(min(find[j + 1] - find[j], find[j] - find[j - 1]));\n            }\n        }\n        return ans;\n    }\n};","author":"LICDAK","submissionId":"611244412"},[]]},{"1815":[{"id":"1815","fileName":"611244276.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n, m = len(nums), len(queries)\n        mp = defaultdict(list)\n        for i, x in enumerate(nums):\n            mp[x].append(i)\n        resIndex = [-1] * n\n        for k, v in mp.items():\n            if len(v) < 2:\n                continue\n            for i, x in enumerate(v):\n                if i == 0:\n                    pre = n - (v[-1] - v[0])\n                    resIndex[x] = min(v[i + 1] - v[i], pre)\n                elif i == len(v) - 1:\n                    las = n - (v[-1] - v[0])\n                    resIndex[x] = min(v[i] - v[i - 1], las)\n                else:\n                    resIndex[x] = min(v[i] - v[i - 1], v[i + 1] - v[i])\n\n        return [resIndex[x] for x in queries]","author":"Qeesun","submissionId":"611244276"},[]]},{"1816":[{"id":"1816","fileName":"611244264.txt","sourceCode":"class Solution {\n    fun solveQueries(nums: IntArray, queries: IntArray): List<Int> {\n        val res = IntArray(queries.size).toMutableList()\n        val map = HashMap<Int, ArrayList<Int>>()\n        val m2 = IntArray(nums.size) { Int.MAX_VALUE / 4 }\n        for (i in nums.indices) {\n            if (map[nums[i]] == null) { map[nums[i]] = arrayListOf() }\n            var x = -1\n            if (map[nums[i]]!!.isNotEmpty()) {\n               \n                val last = map[nums[i]]!!.last()\n                // if (i == 6) println(\"sssssss$i, $last, ${m2[last]}\")\n                m2[last] = Math.min(m2[last], i - last)\n                m2[i] = i - last\n                x = m2[last]\n                \n            } \n            map[nums[i]]!!.add(i)\n            // if (x != -1) m2[i] = \n            \n            // println(m2.joinToString())\n        }\n        \n        // println(\"sss: ${map[14]}\")\n        \n        map.forEach {\n            if (it.value != null && it.value!!.size != 1) {\n                val first = it.value!![0]\n                val last = it.value!!.last()\n                val x = nums.size - last + first\n                m2[first] = Math.min(m2[first], x)\n                m2[last] = Math.min(m2[last], x)\n            }\n        }\n        \n        // println(m2.joinToString())\n        \n        for (i in queries.indices) {\n            res[i] = if (m2[queries[i]] == Int.MAX_VALUE / 4) -1 else m2[queries[i]]\n        }\n        \n        return res\n    }\n}\n//[14,14,4,2,19,19,14,19,14]\n//[2,4,8,6,3]","author":"兴禾","submissionId":"611244264"},[]]},{"1817":[{"id":"1817","fileName":"611244417.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        # 记录每个元素左侧最近相等下标和右侧最近相等下标\n        nlen = len(nums)\n        qlen = len(queries)\n        \n        leftLast = [0] * nlen\n        d1 = {}\n        for i,num in enumerate(nums):\n            leftLast[i] = d1.get(num,-1)\n            d1[num] = i\n        # d1存放最后一次出现下标\n        \n        rightLast = [0] * nlen\n        d2 = {}\n        for i in range(nlen - 1,-1,-1):\n            rightLast[i] = d2.get(nums[i],-1)\n            d2[nums[i]] = i\n        # d2存放第一次出现下标\n        \n        ans = [0] * qlen\n        for i,pos in enumerate(queries):\n            if leftLast[pos] == -1 and rightLast[pos] == -1:\n                ans[i] = -1\n                continue\n            \n            if leftLast[pos] != -1:\n                leftAns = pos - leftLast[pos]\n            else:\n                leftAns = pos + nlen - d1[nums[pos]]  # 绕一圈\n            \n            if rightLast[pos] != -1:\n                rightAns = rightLast[pos] - pos\n            else:\n                rightAns = d2[nums[pos]] + nlen - pos\n                \n            ans[i] = min(leftAns,rightAns)\n        return ans\n        ","author":"谨岌洽","submissionId":"611244417"},[]]},{"1818":[{"id":"1818","fileName":"611244541.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            int x = nums[i];\n            if (!map.containsKey(x)) {\n                List<Integer> lst = new ArrayList<>();\n                lst.add(i);\n                map.put(x, lst);\n            } else {\n                map.get(x).add(i);\n            }\n        }\n\n        List<Integer> ans = new ArrayList<>();\n        for (int query : queries) {\n            int x = nums[query];\n            if (!map.containsKey(x)) {\n                ans.add(-1);\n                continue;\n            }\n            List<Integer> lst = map.get(x);\n            if (lst.size() == 1) {\n                ans.add(-1);\n                continue;\n            }\n            int i = lowerBound(lst, query);\n            \n            if (i == lst.size() - 1) {\n                ans.add(Math.min(query - lst.get(i - 1), lst.get(0) + n - query));\n            } else if (i == 0) {\n                ans.add(Math.min(lst.get(i + 1) - query, n - lst.get(lst.size() - 1) + query));\n            } else {\n                ans.add(Math.min(lst.get(i + 1) - query, query - lst.get(i - 1)));\n            }\n        }\n\n        return ans;\n    }\n\n    private int lowerBound(List<Integer> nums, int target) {\n        int left = -1, right = nums.size();\n        while (left + 1 < right) {\n            int mid = left + (right - left) / 2;\n            if (nums.get(mid) < target) left = mid;\n            else right = mid;\n        }\n        return right;\n    }\n}","author":"Yoke","submissionId":"611244541"},[]]},{"1819":[{"id":"1819","fileName":"611244387.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& query) {\n          int n=nums.size();\n   int m=query.size();\n   vector<int>ans(m);\n   map<int,vector<int>>mp;\n   for(int i=0;i<n;i++){\n    mp[nums[i]].push_back(i);\n   }\n   for(int i=0;i<m;i++){\n     int id=query[i];\n     if(mp[nums[id]].size()==1){\n        ans[i]=-1;\n     }else {\n        int t=0;\n        int x=nums[id];\n      //   cout << \"ID \"<< id << \" \" << nums[id] << 'n';\n        int sz=mp[nums[id]].size();\n        int idx=lower_bound(mp[nums[id]].begin(),mp[nums[id]].end(),id)-mp[nums[id]].begin();\n      //   cout << \"OO \" << idx << \" \" << sz  << 'n';\n        if(idx==0){\n            int k1=abs(mp[x][idx+1]-mp[x][idx]);\n                int k2=abs(n-mp[x][sz-1]+mp[x][idx]);\n          t=min(k1,k2);\n         //  cout << \"LL1 \" << k1 << \" \" << k2 << \" \" << x << 'n';\n        }else if(idx ==(sz-1)){\n            int k1=abs(mp[x][idx-1]-mp[x][idx]);\n            int k2=abs(n-mp[x][idx]+mp[x][0]);\n           t=min(k1,k2);\n          //  cout << \"LL2 \" << k1 << \" \" << k2 << \" \" << x << 'n';\n        }else {\n            int k1=abs(mp[x][idx+1]-mp[x][idx]);\n            int k2=abs(mp[x][idx-1]-mp[x][idx]);\n           t=min(k1,k2);\n         //    cout << \"LL3 \" << k1 << \" \" << k2 << \" \" << x << 'n';\n        }\n        ans[i]=t;\n     }\n   }\n        return ans;\n    }\n};","author":"Zhouzw","submissionId":"611244387"},[]]},{"1820":[{"id":"1820","fileName":"611244478.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& ns, vector<int>& qs) {\n        int n=ns.size(),m=qs.size();\n        map<int,vector<int>> mp;\n        map<int,int> vis;\n        for(int i=0;i<n;i++){\n            int v=ns[i];\n            mp[v].push_back(i);\n            vis[i]=mp[v].size()-1;\n        }\n        vector<int> ans;\n        for(int i=0;i<m;i++){\n            int now=qs[i];\n            int mn=mp[ns[now]].size();\n            if(mn==1){\n                ans.push_back(-1);\n                continue;\n            }\n            int idx=vis[now];\n            int res=1e6;\n            int ridx=(idx+1)%(mn);\n            int lidx=(idx-1+mn)%mn;\n            res=min(abs(now-mp[ns[now]][lidx]),abs(now-(mp[ns[now]][lidx]+n)));\n            res=min(res,abs(now+n-mp[ns[now]][lidx]));\n            res=min(res,abs(now+n-mp[ns[now]][ridx]));\n            res=min(res,abs(now-n-mp[ns[now]][ridx]));\n            res=min(res,abs(now-mp[ns[now]][ridx]));\n            ans.push_back(res);\n        }\n        return ans;\n    }\n};","author":"youk","submissionId":"611244478"},[]]},{"1821":[{"id":"1821","fileName":"611244727.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n\n        unordered_map<int, vector<int>> um;\n        for(int i=0;i<2*n;++i) {\n            um[nums[i%n]].push_back(i);\n        }\n\n        vector<int> min_dis(n, -1);\n        for(auto&& [val, vec] : um) {\n            int ss = vec.size()/2;\n            if (ss == 1) continue;\n            \n            for(int i=0;i<=ss;++i) {\n                int mm = INT_MAX;\n                if (i+1 < vec.size()) {\n                    mm = min(mm, vec[i+1]-vec[i]);\n                    //cout<<val<<\" \"<<vec[i+1]<<\" \"<<vec[i]<<endl;\n                }\n                if (i-1 >= 0) {\n                    mm = min(mm, vec[i]-vec[i-1]);\n                    //cout<<val<<\" \"<<vec[i-1]<<\" \"<<vec[i]<<endl;\n                }\n\n                min_dis[vec[i]%n] = mm == INT_MAX ? -1 : mm;\n            }\n        }\n\n        vector<int> ans(m);\n        for(int i=0;i<m;++i) {\n            int q = queries[i];\n            ans[i] = min_dis[q];\n        }\n\n        return ans;\n    }\n};","author":"Hunter","submissionId":"611244727"},[]]},{"1822":[{"id":"1822","fileName":"611244932.txt","sourceCode":"#define all(v) begin(v),end(v)\n#define nline 'n'\n#define SZ(v) (int) v.size()\n\n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define debug(...)\n#endif\n\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        map<int, vector<int>> h;\n        for (int i = 0; i < a.size(); i++) {\n            h[a[i]].push_back(i);\n        }\n        vector<int> ans;\n        auto find = [&](int x, int i)->int{\n            auto &v = h[x];\n            if(v.size()==1) return -1;\n            auto t=lower_bound(all(v),i);\n            auto t1=t;\n            t1++;\n            int ans=1e9;\n            if(t1==v.end()){\n                ans=min(ans,int(*v.begin()-i+a.size()));\n            }else{\n                ans=min(ans,int(*t1-i));\n            }\n            t1=t;\n            t1--;\n            if(t==v.begin()){\n                ans=min(ans,int(*v.begin()-*v.rbegin()+a.size()));\n            }else{\n                ans=min(ans,int(i-*t1));\n            }\n            return ans;\n\n        };\n        for (auto i : q) {\n            int x = a[i];\n            ans.push_back(find(x, i));\n        }\n        return ans;\n    }\n};","author":"Allergy","submissionId":"611244932"},[]]},{"1823":[{"id":"1823","fileName":"611244854.txt","sourceCode":"class Solution {\npublic:\n    int clen(int x,int y,int n)\n    {\n        if(x>y)swap(x,y);\n        return min(y-x,x+n-y);\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map <int, set <int>> m;\n        int id=0;\n        int n=nums.size();\n        for(vector <int> :: iterator it=nums.begin();it!=nums.end();++it)\n            {\n                m[*it].insert(id);\n                id++;\n            }\n        vector <int> answer;\n        for(vector <int> :: iterator it=queries.begin();it!=queries.end();++it)\n            {\n                int v=nums[*it];\n                //printf(\"q %d ,v=%dn\",*it,v);\n                if(m[v].size()==1)answer.push_back(-1);\n                else \n                {\n                    set <int> :: iterator sit = m[v].find(*it);\n                    set <int> :: iterator sit2=sit;\n                    set <int> :: iterator sit3=sit;\n                    int res=0x3f3f3f3f;\n                    if(sit!=m[v].begin())\n                    {\n                        --sit2;\n                    }\n                    else\n                    {\n                        sit2=m[v].end();\n                        --sit2;\n                    }\n                    res=min(res,clen(*sit2,*sit,n));\n                    sit3++;\n                    if(sit3!=m[v].end())\n                    {\n                        ;\n                    }\n                    else \n                    {\n                        sit3=m[v].begin();\n                    }\n                    res=min(res,clen(*sit3,*sit,n));\n                    answer.push_back(res);\n                }\n            }\n        return answer;\n    }\n};","author":"Shadowice1984","submissionId":"611244854"},[]]},{"1824":[{"id":"1824","fileName":"611244837.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries)\n    {\n        unordered_map<int,vector<int>> Hash;\n        int n=nums.size();\n        vector<int> dist(n,n);\n        for(int i=0;i<nums.size();i++)\n        {\n            Hash[nums[i]].push_back(i);\n            auto& vec=Hash[nums[i]];\n            if (vec.size()>1)\n            {\n                int m=vec.size();\n                //最后一个\n                dist[vec[m-1]]=min(dist[vec[m-1]],vec[m-1]-vec[m-2]);\n                dist[vec[m-1]]=min(dist[vec[m-1]],n-vec[m-1]+vec[0]);\n                //倒数第二个\n                dist[vec[m-2]]=min(dist[vec[m-2]],vec[m-1]-vec[m-2]);\n                //第一个\n                dist[vec[0]]=min(dist[vec[0]],n-vec[m-1]+vec[0]);\n            }\n        }\n\n        vector<int> res;\n        for (auto p:queries)\n        {\n            if (dist[p]==n) dist[p]=-1;\n            res.push_back(dist[p]);\n        }\n\n        return res;\n    }\n};","author":"Aurora°","submissionId":"611244837"},[]]},{"1825":[{"id":"1825","fileName":"611244960.txt","sourceCode":"import collections\nimport bisect\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        counter_dict = collections.defaultdict(list)\n        for i in range(len(nums)):\n            num = nums[i]\n            counter_dict[num].append(i)\n\n        ans = []\n        for i in range(len(queries)):\n            query = queries[i]\n            num = nums[query]\n            value_list = counter_dict[num]\n            if len(value_list) == 1:\n                ans.append(-1)\n                continue\n            else:\n                left = bisect.bisect_left(value_list, query)\n                right = bisect.bisect_right(value_list, query)\n                # print(\"left, \", left, \", right, \", right)\n                # print(value_list)\n                if left == 0:\n                    right_num = value_list[right] - query\n                    left_num = len(nums) - (value_list[-1] - query)\n                    ans.append(min(left_num, right_num))\n                elif right == len(value_list):\n                    left -= 1\n                    left_num = query - value_list[left]\n                    right_num = len(nums) - (query -value_list[0])\n                    # print(left_num, right_num)\n                    ans.append(min(left_num, right_num))\n                else:\n                    left -= 1\n                    left_num = query - value_list[left]\n                    right_num = value_list[right] - query\n                    ans.append(min(left_num, right_num))\n\n        return ans","author":"一起学算法","submissionId":"611244960"},[]]},{"1826":[{"id":"1826","fileName":"611244528.txt","sourceCode":"// \n// 注意这还是一个循环数组，所以比较麻烦\nfunc solveQueries(nums []int, queries []int) []int {\n    m := len(queries)\n    ans := make([]int, m)\n    for i := range ans {\n        ans[i] = -1\n    }\n    num2slice := make(map[int][]int)\n    for i, u := range nums {\n        num2slice[u] = append(num2slice[u], i)\n    }\n\n    for i, q := range queries {\n        u := nums[q]   // the num\n        arr := num2slice[u]\n        if len(arr) == 1 {\n            // 只有一个值直接不用考虑了\n            continue\n        }\n        // 二分找到对应的位置\n        var p int\n        {\n            // 二分找到对应的位置\n            l, r := 0, len(arr) - 1\n            for l < r {\n                mid := (l + r) >> 1\n                if arr[mid] < q {\n                    l = mid + 1\n                } else if arr[mid] >= q {\n                    r = mid\n                }\n            }\n            p = l\n        }\n\n        // 根据所在的位置记录结果\n        // 注意这里可以是循环的数组\n        // fmt.Println(i, u, q, p, arr)\n        if p == 0 {\n            ans[i] = min(arr[p + 1] - arr[p], len(nums) + arr[0] - arr[len(arr) - 1])\n        } else if p == len(arr) - 1 {\n            ans[i] = min(arr[p] - arr[p - 1], len(nums) + arr[0] - arr[p])\n        } else {\n            ans[i] = min(arr[p + 1] - arr[p], arr[p] - arr[p - 1])\n        }\n    }\n    \n    return ans\n}","author":"Serendipity","submissionId":"611244528"},[]]},{"1827":[{"id":"1827","fileName":"611245018.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> m;\n        for (int i{}; i < n; ++i) {\n            m[nums[i]].emplace_back(i);\n        }\n        vector<int> re;\n        for (auto i : q) {\n            int cnt = INT_MAX;\n            auto& v = m[nums[i]];\n            if (v.size() < 2) {\n                re.emplace_back(-1);\n                continue;\n            }\n\n            int pos = lower_bound(v.begin(), v.end(), i) - v.begin();\n            int md = n;\n            if (pos > 0) {\n                int j = v[pos - 1];\n                md = min({md, abs(i - j), n - abs(i - j)});\n            } else {\n                int j = v.back();\n                md = min({md, abs(i - j), n - abs(i - j)});\n            }\n\n            if (pos < v.size() - 1) {\n                int j = v[pos + 1];\n                md = min({md, abs(i - j), n - abs(i - j)});\n            } else {\n                int j = v.front();\n                md = min({md, abs(i - j), n - abs(i - j)});\n            }\n            re.emplace_back(md);\n        }\n        return re;\n    }\n};","author":"hanser_no_neko","submissionId":"611245018"},[]]},{"1828":[{"id":"1828","fileName":"611245022.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, int> left, right, idx, lest, rest;\n        int n = nums.size();\n        for (int i = 0; i < n; i ++ ) {\n            int j = nums[i];\n            if (lest.count(j)) continue;\n            lest[j] = i;\n        }\n        for (int i = n - 1; i >= 0; i -- ) {\n            int j = nums[i];\n            if (rest.count(j)) continue;\n            rest[j] = i;\n        }\n        for (int i = 0; i < n; i ++ ) {\n            int j = nums[i];\n            if (idx.count(j)) {\n                left[i] = idx[j];\n            } else left[i] = -1;\n            idx[j] = i;\n        }\n        idx = unordered_map<int, int>();\n        for (int i = n - 1; i >= 0; i -- ) {\n            int j = nums[i];\n            if (idx.count(j)) {\n                right[i] = idx[j];\n            } else right[i] = -1;\n            idx[j] = i;\n        }\n\n        int m = queries.size();\n        vector<int> res(m, -1);\n        int inf = 1'000'000;\n        for (int i = 0; i < m; i ++ ) {\n            int j = nums[queries[i]];\n            int t = queries[i];\n            // printf(\"t = %d, j == %d, left = %d, right = %dn\", t, j, left[t], right[t]);\n            int d = inf;\n            if (~left[t]) d = min(d, t - left[t]);\n            if (~right[t]) d = min(d, right[t] - t);\n            if (lest[j] != t) d = min(lest[j] + n - t, d);\n            if (rest[j] != t) d = min(t + n - rest[j], d);\n            res[i] = d == inf ? -1 : d;\n        }\n        return res;\n    }\n};","author":"Lambda","submissionId":"611245022"},[]]},{"1830":[{"id":"1830","fileName":"611245031.txt","sourceCode":"class Solution\n{\npublic:\n    vector<int> solveQueries(vector<int> &nums, vector<int> &queries)\n    {\n        unordered_map<int, vector<int>> valIndexs;\n        int n = nums.size();\n        vector<int> distance(n, -1);\n        for (int i = 0; i < n; ++i)\n        {\n            if (valIndexs.count(nums[i]))\n            {\n                int j = valIndexs[nums[i]].back();\n                int j1 = valIndexs[nums[i]][0];\n                distance[i] = min(i - j, j1 + n - i);\n                distance[j] = distance[j] >= 0 ? min(distance[j], i - j) : i - j;\n                distance[j1] = distance[j1] >= 0 ? min(distance[j1], j1 + n - i) : j1 + n - i;\n            }\n            valIndexs[nums[i]].push_back(i);\n        }\n        int m = queries.size();\n        vector<int> ans(m);\n        for (int i = 0; i < m; ++i)\n        {\n            ans[i] = distance[queries[i]];\n        }\n        return ans;\n    }\n};","author":"物联黄同学","submissionId":"611245031"},[]]},{"1831":[{"id":"1831","fileName":"611245228.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>>m;\n        int n1=nums.size();\n        for(int i=0;i<n1;i++){\n            m[nums[i]].push_back(i);\n        }\n        vector<int>ans;\n        for(int i:queries){\n            int x=nums[i];\n            int n=m[x].size();\n            if(n==1){\n                ans.push_back(-1);\n                continue;\n            }\n            int l=0,r=n-1;\n            while(l<=r){\n                int mid=(r-l)/2+l;\n                if(m[x][mid]>=i)r=mid-1;\n                else l=mid+1;\n            }\n            int a=m[x][(l-1+n)%n],b=m[x][(l+1)%n];\n            ans.push_back(min({abs(a-i),abs(b-i),n1-(abs(a-i)),n1-(abs(b-i))}));\n        }\n        return ans;\n    }\n};","author":"ぼっち","submissionId":"611245228"},[]]},{"604":[{"id":"604","fileName":"1575120604.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<int> temp(n, -1);\n        map<int, vector<int>> mp;\n        for(int i=0;i<n;i++)\n        {\n            mp[nums[i]].push_back(i);\n        }\n        for(auto it = mp.begin(); it != mp.end(); it++)\n        {\n            vector<int> rem = it-> second;\n            int size = rem.size();\n            if(size >= 2)\n            {\n                sort(rem.begin(), rem.end());\n                rem.push_back(rem[0] + n);\n    \n                temp[rem[0]] = min((rem[1] - rem[0]), (rem[0] + n - rem[size - 1]));\n                for(int i=1;i<size;i++) temp[rem[i]] = min(rem[i] - rem[i - 1], (rem[i + 1] - rem[i]));\n            }\n        }\n        vector<int> ans(m, -1);\n        for(int i=0;i<m;i++) ans[i] = temp[queries[i]];\n        return ans;\n    }\n};","author":"Mohit Budhlakoti","submissionId":"1575120604"},[{"id":"604","similarity":0.7135922330097088,"totOverlap":147,"longestOverlap":27}]],"1800":[{"id":"1800","fileName":"611243719.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size(),m=queries.size();\n        unordered_map<int,vector<int>> mp;\n        vector<int> res(n,-1);\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        for(auto it=mp.begin();it!=mp.end();it++){\n            vector<int> a=it->second;\n            int sz=a.size();\n            if(sz==1) continue;\n            res[a[0]]=min(n-a[sz-1]+a[0],a[1]-a[0]);\n            res[a[sz-1]]=min(a[sz-1]-a[sz-2],n+a[0]-a[sz-1]);\n            for(int i=1;i<sz-1;i++){\n                res[a[i]]=min(a[i+1]-a[i],a[i]-a[i-1]);\n            }\n        }\n        vector<int> ans(m,-1);\n        for(int i=0;i<m;i++){\n            ans[i]=res[queries[i]];\n        }\n        return ans;\n    }\n};","author":"zero","submissionId":"611243719"},[{"id":"1800","similarity":0.7047619047619048,"totOverlap":148,"longestOverlap":12}]],"1834":[{"id":"1834","fileName":"611245445.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n\n        unordered_map<int, vector<int>> hash;\n        for (int i = 0; i < nums.size(); i++) {\n            hash[nums[i]].push_back(i);\n        }\n\n        vector<int> mindis(nums.size());\n        int n = nums.size();\n        for (const auto& [value, indexs] : hash) {\n            int m = indexs.size();\n            if (m == 1) {\n                mindis[indexs[0]] = -1;\n            } else {\n                mindis[indexs[0]] =\n                    min(indexs[1] - indexs[0], indexs[0] + n - indexs[m - 1]);\n\n                for (int i = 1; i < m - 1; i++) {\n                    mindis[indexs[i]] = min(indexs[i] - indexs[i - 1],\n                                            indexs[i + 1] - indexs[i]);\n                }\n                mindis[indexs[m - 1]] = min(indexs[m - 1] - indexs[m - 2],\n                                            indexs[0] + n - indexs[m - 1]);\n            }\n        }\n\n        n = queries.size();\n        vector<int> ans(n);\n        for (int i = 0; i < n; i++) {\n            ans[i] = mindis[queries[i]];\n        }\n        return ans;\n    }\n};","author":"anshanzi","submissionId":"611245445"},[{"id":"1836","similarity":0.7246376811594203,"totOverlap":150,"longestOverlap":19},{"id":"1834","similarity":0.7047619047619048,"totOverlap":148,"longestOverlap":12},{"id":"1800","similarity":0.7135922330097088,"totOverlap":147,"longestOverlap":27},{"id":"1959","similarity":0.7142857142857143,"totOverlap":140,"longestOverlap":18}]],"1836":[{"id":"1836","fileName":"611245458.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<int> ans(m, -1);\n        vector<int> pos(n, -1);\n        unordered_map<int, vector<int>> p;\n        for (int i = 0; i < n; ++i) p[nums[i]].emplace_back(i);\n        for (auto& [_, v] : p) {\n            int len = v.size();\n            for (int i = 1; i < len - 1; ++i) {\n                pos[v[i]] = min(v[i] - v[i - 1], v[i + 1] - v[i]);\n            }\n            if (len > 1) pos[v[0]] = min(v[1] - v[0], v[0] + n - v.back()), pos[v[len - 1]] = min(v[len - 1] - v[len - 2], v[0] + n - v.back());\n        }\n        for (int i = 0; i < m; ++i) {\n            int id = queries[i];\n            ans[i] = pos[id];\n        }\n        return ans;\n    }\n};","author":"RnFreno","submissionId":"611245458"},[{"id":"1834","similarity":0.7246376811594203,"totOverlap":150,"longestOverlap":19}]],"1959":[{"id":"1959","fileName":"611258921.txt","sourceCode":"class Solution {\npublic:\nvector<int> solveQueries(vector<int>& a, vector<int>& q) {\n  int n = a.size();\n  unordered_map<int, vector<int>> um;\n  for (int i = 0; i < n; ++i) {\n    um[a[i]].push_back(i);\n  }\n  vector<int> b(n, -1);\n  for (auto& [k, v] : um) {\n    int nv = v.size();\n    if (nv == 1) {\n      b[v[0]] = -1;\n      continue;\n    }\n    int ft = v.front(), bk = v.back();\n    v.insert(v.begin(), bk);\n    v.push_back(ft);\n    for (int i = 1; i <= nv; ++i) {\n      b[v[i]] = min((v[i] - v[i - 1] + n) % n, (v[i + 1] - v[i] + n) % n);\n    }\n  }\n  n = q.size();\n  vector<int> ans(n);\n  for (int i = 0; i < n; ++i) {\n    ans[i] = b[q[i]];\n  }\n  return ans;\n}\n};","author":"兜大宝","submissionId":"611258921"},[{"id":"1834","similarity":0.7142857142857143,"totOverlap":140,"longestOverlap":18}]]},{"1835":[{"id":"1835","fileName":"611245494.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> map;\n        for(int i = 0; i < nums.size(); i++){\n            map[nums[i]].push_back(i);\n        }\n        vector<int> res;\n        for(auto query: queries){\n            if(map[nums[query]].size()==1){\n                res.push_back(-1);\n                continue;\n            }\n            int ind = biSearch(map[nums[query]], query, 0, map[nums[query]].size()-1);\n            cout << query << \" \" << ind << endl;\n            res.push_back(findDist(map[nums[query]], ind, nums.size()));\n        }\n        return res;\n    }\n    int biSearch(vector<int>& nums, int key, int low ,int high){\n        if(low>high) return low;\n        int mid = (low+high)/2;\n        if(nums[mid]==key) return mid;\n        if(nums[mid]>key) return biSearch(nums, key, low, mid-1);\n        return biSearch(nums, key, mid+1, high);\n    }\n    int findDist(vector<int>& nums, int ind, int n){\n        int leftInd = (ind+nums.size()-1)%nums.size();\n        int rightInd = (ind+1)%nums.size();\n        cout << \"l:r \"<< leftInd << \" \" << rightInd << endl;\n        int res = min(abs(nums[ind]-nums[leftInd]), abs(nums[ind]-nums[rightInd]));\n        res = min(res, abs(nums[leftInd]+n-nums[ind]));\n        res = min(res, abs(nums[rightInd]+n-nums[ind]));\n        res = min(res, abs(nums[ind]+n-nums[rightInd]));\n        res = min(res, abs(nums[ind]+n-nums[leftInd]));\n        return res;\n    }\n};","author":"helenjing","submissionId":"611245494"},[]]},{"1837":[{"id":"1837","fileName":"611245281.txt","sourceCode":"class Solution {\npublic:\n    // unordered_map<int,pair<int,int>>ump;\n    \n    // int calc(vector<int>& nums, int i, int j){\n    //     return min(i-ump[nums[i]].second, n-(i-ump[nums[i]].first));\n    // }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,pair<int,int>>ump;\n        int n=nums.size();\n        vector<int>res(n, INT_MAX);\n        for(int i=0; i<n; i++){\n            if(ump.count(nums[i])){\n                int dis1 = min(i-ump[nums[i]].second, n-(i-ump[nums[i]].second));\n                int dis2 = min(i-ump[nums[i]].first, n-(i-ump[nums[i]].first));\n                // cout<<i<<' '<<dis1<<' '<<dis2<<endl;\n                // cout<<\"ump\"<<' '<<ump[nums[i]].first<<' '<<ump[nums[i]].second<<endl;\n                \n                res[ump[nums[i]].first] = min(dis2, res[ump[nums[i]].first]);\n                res[ump[nums[i]].second] = min(dis1, res[ump[nums[i]].second]);\n                res[i] = min(dis1, dis2);\n                ump[nums[i]].second = i;\n                \n            }\n            else{\n                ump[nums[i]]={i,i};\n            }\n            \n        }\n        int qn=queries.size();\n        vector<int>ret(qn, 0);\n        for(int i=0; i<qn; i++){\n            ret[i] = res[queries[i]]==INT_MAX? -1:res[queries[i]];\n        }\n        return ret;\n    }\n};","author":"Zhang-Jiahui","submissionId":"611245281"},[]]},{"1838":[{"id":"1838","fileName":"611245507.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> pos;\n        int n = nums.size();\n        int m = queries.size();\n        for (int i = 0; i < n; ++ i) {\n            pos[nums[i]].push_back(i);\n        }\n        vector<int> ans(m);\n        for (int i = 0; i < m; ++ i) {\n            int q = queries[i];\n            int x = nums[q];\n            // if (x == 18) {\n            //     cout << pos[x].size() << endl;\n            // }\n            if (pos[x].size() <= 1) {\n                ans[i] = -1;\n                // cout << i << ' ' << ans[i] << endl;\n                continue;\n            }\n            // int len = pos[x].size();\n            int it = lower_bound(pos[x].begin(), pos[x].end(), q) - pos[x].begin();\n            // if (q == 8) {\n            //     cout << it << endl;\n            // }\n            int res = INT_MAX;\n            if (it == 0) {\n                // if (it != pos[x].size() - 1) {\n                // }\n                res = min(res, abs(pos[x][it + 1] - pos[x][it]));\n                res = min(res, n - abs(pos[x][it] - pos[x].back()));\n            } else if (it == pos[x].size() - 1) {\n                // if (it != 0) {\n                // }\n                res = min(res, abs(pos[x][it - 1] - pos[x][it]));\n                res = min(res, n - abs(pos[x][it] - pos[x][0]));\n            } else {\n                res = min({res, abs(pos[x][it - 1] - pos[x][it]), abs(pos[x][it + 1] - pos[x][it])});\n            }\n            ans[i] = res;\n        }\n        return ans;\n    }\n};","author":"心里没点AC数","submissionId":"611245507"},[]]},{"1839":[{"id":"1839","fileName":"611245533.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int, int> MR, ML;\n        const int inf = 1e6;\n        vector<int> l(n, inf), r(n, inf);\n        for(int i = 0; i < n; i++){\n            if(!MR.count(nums[i])) MR[nums[i]] = i;\n            else{\n                l[i] = MR[nums[i]];\n                MR[nums[i]] = i;\n            }\n        }\n        for(int i = n - 1; i >= 0; i--){\n            if(!ML.count(nums[i])) ML[nums[i]] = i;\n            else{\n                r[i] = ML[nums[i]];\n                ML[nums[i]] = i;\n            }\n        }\n        vector<int> ans;\n        for(int &i : queries){\n            // 处理左距离\n            int left_dis = inf;\n            if(l[i] != inf) left_dis = i - l[i];\n            else if(MR[nums[i]] != i) left_dis = n - MR[nums[i]] + i;\n            int right_dis = inf;\n            if(r[i] != inf) right_dis = r[i] - i;\n            else if(ML[nums[i]] != i) right_dis = n - i + ML[nums[i]];\n            int dis = min(left_dis, right_dis);\n            ans.emplace_back(dis == inf ? -1 : dis);\n        }\n        return ans;\n    }\n};","author":"Ged_Relay","submissionId":"611245533"},[]]},{"1840":[{"id":"1840","fileName":"611245560.txt","sourceCode":"class Solution {\npublic:\n   vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n    int inf = 1e9 + 7;\n    unordered_map<int, int>prel, prer;\n    int left[200100], right[200100];\n    int n = nums.size();\n    for (int t = 0;t < 2*n;t++) {\n        int i = t % n;\n        if (prel.find(nums[i]) == prel.end())left[t] = inf;\n        else left[t] = t - prel[nums[i]];\n        prel[nums[i]] = t;\n    }\n    for (int t = 2*n-1;t >= 0;t--) {\n        int i = t % n;\n        if (prer.find(nums[i]) == prer.end())right[t] = inf;\n        else right[t] = prer[nums[i]] - t;\n        prer[nums[i]] = t;\n    }\n    vector<int>ans;\n    for (int t : queries) {\n        int res = min({ right[t], left[t],left[t+n],right[t+n]});\n        if ( res>=n)ans.push_back(-1);\n        else ans.push_back(res);\n    }\n\n    return ans;\n}\n\n};","author":"Fanciorange","submissionId":"611245560"},[]]},{"1841":[{"id":"1841","fileName":"611245583.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> vec;\n        unordered_map<int, vector<int>> pos;\n        for (int i = 0; i != n; ++i)\n            pos[nums[i]].push_back(i);\n        for (int val : queries)\n        {\n            auto &v = pos[nums[val]];\n            if (v.size() == 1)\n            {\n                vec.push_back(-1);\n                continue;\n            }\n            int i = lower_bound(v.begin(), v.end(), val) - v.begin();\n            int prev = i == 0 ? min(v.back() - val, n - v.back() + val) : val - v[i - 1];\n            int next = i == v.size() - 1 ? min(val - v[0], n - val + v[0]) : v[i + 1] - val;\n            vec.push_back(min(prev, next));\n        }\n        return vec;\n    }\n};","author":"LNR3","submissionId":"611245583"},[]]},{"1842":[{"id":"1842","fileName":"611245690.txt","sourceCode":"class Solution {\npublic List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n\n        Map<Integer, Integer> lastMap = new HashMap<>();\n        int[] lately = new int[n];\n        Arrays.fill(lately, -1);\n        for (int i = 0; i < n; i++) {\n            Integer last = lastMap.get(nums[i]);\n            if (last != null) {\n                lately[i] = i - last;\n            }\n            lastMap.put(nums[i], i);\n        }\n        Map<Integer, Integer> nextMap = new HashMap<>();\n        for (int i = n - 1; i > -1; i--) {\n            Integer nextIndex = nextMap.get(nums[i]);\n            if (nextIndex != null) {\n                if (lately[i] == -1 || lately[i] > nextIndex - i) {\n                    lately[i] = nextIndex - i;\n                }\n            }\n            nextMap.put(nums[i], i);\n        }\n        \n        for (Map.Entry<Integer, Integer> lastEntry : lastMap.entrySet()) {\n            int end = lastEntry.getValue();\n            int first = nextMap.get(lastEntry.getKey());\n            if (end == first) {\n                continue;\n            }\n            int distance = first + n - end;\n            if (distance < lately[first]) {\n                lately[first] = distance;\n            }\n            if (distance < lately[end]) {\n                lately[end] = distance;\n            }\n        }\n        \n        List<Integer> ans = new ArrayList<>(queries.length);\n        for (int query : queries) {\n            ans.add(lately[query]);\n        }\n        return ans;\n    }\n}","author":"JIAN","submissionId":"611245690"},[]]},{"1843":[{"id":"1843","fileName":"611245486.txt","sourceCode":"\n# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, DefaultDict\nfrom collections import deque, Counter\nfrom queue import PriorityQueue\nimport math\nfrom functools import lru_cache\nfrom sortedcontainers import SortedDict, SortedSet\nimport random\nimport copy\nimport sys\n\nMOD = 10**9 + 7\n\n\nINF = 0x7f7f7f7f7f7f7f7\n\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n\n        n = len(nums)\n        c = Counter(nums)\n\n        mm = {}\n        for i in range(n):\n            v = nums[i]\n            if v not in mm:\n                mm[v] = []\n            mm[v].append(i)\n\n\n\n        ret = []\n        for i in queries:\n            v = nums[i]\n            if c[v] == 1:\n                ret.append(-1)\n                continue\n\n\n            p = None\n            arr = mm[v]\n            k = len(arr)\n            l, r = 0, k-1\n            while l <= r:\n                mid = (l+r) >> 1\n\n                if arr[mid] > i:\n                    r = mid-1\n                else:\n                    p = mid\n                    l = mid+1\n\n            ans = INF\n\n            if p != 0:\n                ans = min(ans, abs(arr[p]-arr[p-1]))\n            else:\n                ans = min(ans, n - abs(arr[-1]-arr[p]))\n\n            if p != k-1:\n                ans = min(ans, abs(arr[p]-arr[p+1]))\n            else:\n                ans = min(ans, n - abs(arr[p]-arr[0]))\n\n            ret.append(ans)\n\n        return ret","author":"皓首不倦.GRH","submissionId":"611245486"},[]]},{"1844":[{"id":"1844","fileName":"611245840.txt","sourceCode":"# from sortedcontainers import SortedList\nfrom bisect import bisect_left\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        ans = [0]*len(queries)\n        numpos = defaultdict(list)\n        for i, num in enumerate(nums):\n            numpos[num].append(i)\n            \n        for j, query in enumerate(queries):\n            trgt = nums[query]\n            if len(numpos[trgt]) == 1:\n                ans[j] = -1\n            else:\n                pos = bisect_left(numpos[trgt], query)\n                if pos!=0 and pos!=len(numpos[trgt])-1:\n                    ans[j] = min(query-numpos[trgt][pos-1], numpos[trgt][pos+1]-query)\n                elif pos==0:\n                    ans[j] = min(numpos[trgt][1]-query, query+n-numpos[trgt][-1])\n                else:\n                    ans[j] = min(query-numpos[trgt][pos-1], numpos[trgt][0]+n-query)\n            \n        return ans\n        ","author":"lafYY","submissionId":"611245840"},[]]},{"1845":[{"id":"1845","fileName":"611245960.txt","sourceCode":"class Solution {\npublic:\n    struct dn{\n        int idx;\n        dn* l,*r;\n        dn(int index,dn* left, dn* right):idx(index),l(left),r(right){}\n    };\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<dn*>n2p(nums.size(),nullptr);\n        unordered_map<int,vector<dn*>>mp;\n        for(int i=0;i<nums.size();i++){\n            auto cnt=new dn(i,nullptr,nullptr);\n            int num=nums[i];\n            if(mp.count(num)){\n                cnt->l=mp[num][mp[num].size()-1];\n                mp[num][mp[num].size()-1]->r=cnt;\n            }\n            mp[num].emplace_back(cnt);\n            n2p[i]=cnt;\n        }\n        vector<int>ans(queries.size(),-1);\n        for(int i=0;i<queries.size();i++){\n            int index=queries[i],tmp=INT_MAX;\n            auto cnt=n2p[index];\n            if(cnt->l!=nullptr) tmp=min(tmp,abs(index-cnt->l->idx));\n            else if(mp[nums[index]].size()>1) tmp=min(tmp,abs((int)nums.size()-mp[nums[index]][mp[nums[index]].size()-1]->idx+cnt->idx));\n            if(cnt->r!=nullptr) tmp=min(tmp,abs(index-cnt->r->idx));\n            else if(mp[nums[index]].size()>1){\n                tmp=min(tmp,abs((int)nums.size()+mp[nums[index]][0]->idx-cnt->idx));\n            }\n            if(tmp!=INT_MAX) ans[i]=tmp;\n        }\n        return ans;\n    }\n\n};","author":"杏山和纱酱","submissionId":"611245960"},[]]},{"1846":[{"id":"1846","fileName":"611245944.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        idxs = [+inf] * n\n        pre_mp = dict()\n        first_mp = dict()\n        last_mp = dict()\n        for i, x in enumerate(nums):\n            if x not in first_mp:\n                first_mp[x] = i\n        for i in range(n):\n            x = nums[n - 1 - i]\n            if x not in last_mp:\n                last_mp[x] = n - 1 - i\n\n            \n        before_mp = dict()\n        after_mp = dict()\n        \n        pre_mp = dict()\n        for i, x in enumerate(nums):\n            after_mp[i] = first_mp[x]\n            if x not in pre_mp:\n                before_mp[i] = last_mp[x]\n            else:\n                j = pre_mp[x]\n                before_mp[i] = pre_mp[x]\n                after_mp[j] = i\n            pre_mp[x] = i\n            \n            \n        ans = []\n        for q in queries:\n            t = +inf\n            before = before_mp[q]\n            after = after_mp[q]\n            if before != q:\n                t = min(t, q - before if before < q else n - before + q)\n            if after != q:\n                t = min(t, after_mp[q] - q if after_mp[q] > q else n - q + after)\n            ans.append(-1 if t == +inf else t)\n        return ans\n                \n                \n        ","author":"koy33","submissionId":"611245944"},[]]},{"1847":[{"id":"1847","fileName":"611246168.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        mp = defaultdict(list)\n        for i, x in enumerate(nums):\n            mp[x].append(i)\n        for x in mp:\n            mp[x] =  list(map(lambda y: y - n, mp[x])) + mp[x] + list(map(lambda y: y + n, mp[x]))\n        ans = []\n        for q in queries:\n            p = mp[nums[q]]\n            if len(p) == 3:\n                ans.append(-1)\n                continue\n            i = bisect_left(p, q)\n            y = inf\n            if i - 1 >= 0:\n                y = min(y, p[i] - p[i-1])\n            if i + 1 < len(p):\n                y = min(y, p[i+1] - p[i])\n            ans.append(y)\n        return ans\n","author":"沐风","submissionId":"611246168"},[]]},{"1848":[{"id":"1848","fileName":"611246044.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n\ttheMap := map[int][]int{}\n\ttype Pair struct {\n\t\tv, index int\n\t}\n\n\tarr := make([]Pair, 0, len(nums))\n\tfor i, v := range nums {\n\t\ttmp := theMap[v]\n\t\tif tmp == nil {\n\t\t\ttmp = []int{}\n\t\t}\n\t\ttmp = append(tmp, i)\n\t\tarr = append(arr, Pair{v, len(tmp) - 1})\n\t\ttheMap[v] = tmp\n\t}\n\n\ttheRes := make([]int, 0, len(queries))\n\tfor _, q := range queries {\n\t\tp := arr[q]\n\t\ttmp := theMap[p.v]\n\t\tindex := p.index\n\t\tif len(tmp) == 1 {\n\t\t\ttheRes = append(theRes, -1)\n\t\t} else {\n\t\t\tinow := tmp[index]\n\t\t\til := tmp[(len(tmp)+index-1)%len(tmp)]\n\t\t\tir := tmp[(len(tmp)+index+1)%len(tmp)]\n\n\t\t\tv1 := 0\n\t\t\tif inow > il {\n\t\t\t\tv1 = inow - il\n\t\t\t} else {\n\t\t\t\tv1 = inow + len(nums) - il\n\t\t\t}\n\n\t\t\tv2 := 0\n\t\t\tif inow < ir {\n\t\t\t\tv2 = ir - inow\n\t\t\t} else {\n\t\t\t\tv2 = ir + len(nums) - inow\n\t\t\t}\n\n\t\t\ttheRes = append(theRes, min(v1, v2))\n\t\t}\n\t}\n\n\treturn theRes\n}\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\nfunc abs(a int) int {\n\tif a > 0 {\n\t\treturn a\n\t}\n\treturn -a\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}","author":"cyldsyp1","submissionId":"611246044"},[]]},{"1849":[{"id":"1849","fileName":"611245649.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size();\n        int m=queries.size();\n        unordered_map<int,vector<int>> posRec;\n        for(int i=0;i<n;i++){\n            posRec[nums[i]].push_back(i);\n        }\n        vector<int> ans(m);\n        for(int i=0;i<m;i++){\n            int pos=queries[i];\n            int rePos=0;\n            int curLen=posRec[nums[pos]].size();\n            if(curLen==1){\n                ans[i]=-1;\n                continue;\n            }\n            int l=0,r=curLen-1;\n            while(l<=r){\n                int mid=(l+r)>>1;\n                if(posRec[nums[pos]][mid]<=pos){\n                    rePos=mid;\n                    l=mid+1;\n                }\n                else{\n                    r=mid-1;\n                }\n            }\n            // for(int i:posRec[nums[pos]]){\n            //     cout<<i<<endl;\n            // }\n            \n            int suf=posRec[nums[pos]][(rePos+1)%curLen];\n            int pre=posRec[nums[pos]][rePos-1<0?curLen-1:rePos-1];\n            //cout<<pos<<' '<<rePos<<' '<<pre<<' '<<suf<<endl;\n            int len1=(pos-pre+n)%n;\n            int len2=(suf-pos+n)%n;\n            ans[i]=min(len1,len2);\n        }\n        return ans;\n    }\n};","author":"Juross","submissionId":"611245649"},[]]},{"1851":[{"id":"1851","fileName":"611246265.txt","sourceCode":"class Solution {\npublic:\n    unordered_map<int, vector<int>> distance_map;\n    unordered_map<int, int> index_map;\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        for (int i = 0; i < n;i++) {\n            int num = nums[i];\n            index_map[i] = distance_map[num].size();\n            distance_map[num].push_back(i);\n        }\n        vector<int> ans;\n        ans.reserve(queries.size());\n        for (auto q : queries) {\n            if (distance_map[nums[q]].size() == 1) {\n                ans.push_back(-1);\n            }\n            else {\n                int id = index_map[q];\n                auto& vec = distance_map[nums[q]];\n                int vecn = vec.size();\n                if (id == 0) {\n                    ans.push_back(min(vec[1] - vec[id], min(vec[vecn - 1] - vec[id], n - vec[vecn - 1] + vec[id])));\n                }\n                else if (id == vecn - 1) {\n                    ans.push_back(min(min(vec[id] - vec[0], n - vec[id] + vec[0]), vec[id] - vec[vecn - 2]));\n                }\n                else {\n                    ans.push_back(min(abs(vec[id] - vec[id - 1]), abs(vec[id + 1] - vec[id])));\n                }\n            }\n        }\n        return ans;\n    }\n};","author":"原","submissionId":"611246265"},[]]},{"1852":[{"id":"1852","fileName":"611246270.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        pos = defaultdict(list)\n        n = len(nums)\n        for i, x in enumerate(nums):\n            pos[x].append(i)\n        ans = [-1] * len(queries)\n        for i, q in enumerate(queries):\n            p_list = pos[nums[q]]\n            if len(p_list) >= 2:\n                # print(p_list)\n                pp = bisect_left(p_list, q)\n                # print(\"pp\", pp)\n                if pp == 0:\n                    d = min(p_list[1] - p_list[0], n - p_list[1] + p_list[0],  n - (p_list[-1] - p_list[0]))\n                elif pp == len(p_list) - 1:\n                    d = min(p_list[pp] - p_list[pp-1], n - p_list[pp] + p_list[pp-1], n - (p_list[pp] - p_list[0]))\n                else:\n                    d = min(p_list[pp] - p_list[pp - 1], p_list[pp + 1] - p_list[pp], n - (p_list[pp] - p_list[pp - 1]), n - (p_list[pp+1] - p_list[pp]))\n                ans[i] = d\n        return ans","author":"stupefy","submissionId":"611246270"},[]]},{"1853":[{"id":"1853","fileName":"611246238.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        new_num=sorted(zip(nums,range(len(nums))))\n        n=len(nums)\n        ans=[]\n        def check(mid,target,i):\n            if new_num[mid][0]<target:\n                return False\n            elif new_num[mid][0]==target and new_num[mid][1]<i:\n                return False\n            return True\n        def min_l(i,j,n):\n            return min(abs(i-j),abs(i+n-j),abs(j+n-i))\n            \n        for i in range(len(queries)):\n            target=nums[queries[i]]\n\n            l=0\n            r=n\n            while l<r:\n                mid=(l+r)//2\n                if check(mid,target,queries[i]):\n                    r=mid\n                else:\n                    l=mid+1\n            min_len=1e7\n            if l>0 and new_num[l-1][0]==target:\n                min_len=min_l(new_num[l-1][1],queries[i],n)\n            if l<n-1 and new_num[l+1][0]==target:\n                min_len=min(min_l(new_num[l+1][1],queries[i],n),min_len)\n            l=0\n            r=n\n            while l<r:\n                mid=(l+r)//2\n                if new_num[mid][0]>=target:\n                    r=mid\n                else:\n                    l=mid+1\n            if new_num[l][1]!=queries[i]:\n                min_len=min(min_l(new_num[l][1],queries[i],n),min_len)\n                \n            l=0\n            r=n\n            while l<r:\n                mid=(l+r)//2\n                if new_num[mid][0]>target:\n                    r=mid\n                else:\n                    l=mid+1\n            if new_num[l-1][1]!=queries[i] and new_num[l-1][0]==target:\n                min_len=min(min_l(new_num[l-1][1],queries[i],n),min_len)\n                \n            \n            if min_len!=1e7:\n                ans.append(min_len)\n            else:\n                ans.append(-1)\n        return ans","author":"...","submissionId":"611246238"},[]]},{"1854":[{"id":"1854","fileName":"611246414.txt","sourceCode":"class Solution {\npublic:\n  \n    int find(vector<int> &v,int x){\n        int l=0,r=v.size();\n        while(l<r){\n            int mid = l+r>>1;\n            if(v[mid]<x) l=mid+1;\n            else r=mid;\n            \n        }\n        return l;\n    }\n    \n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int mx=0;\n        for(int i=0;i<nums.size();i++){\n            mx=max(mx,nums[i]);\n        }\n        \n        vector<int> f[mx+1];\n        for(int i=0;i<nums.size();i++){\n            f[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        int n=nums.size();\n        auto cacl=[&](int x){\n            auto it = find(f[nums[x]],x);\n           \n            if(f[nums[x]].size()==1) return -1;\n            int ret=n+1;\n            if(it!=0){\n                 int tp=abs(f[nums[x]][it-1]-x);\n                 ret= min(tp,n-tp);\n            }\n            \n            if(it+1!=f[nums[x]].size()){\n                int tp = abs(f[nums[x]][it+1]-x);\n               ret=min(ret, min(tp,n-tp));\n            }\n            if(it==0||it+1==f[nums[x]].size()){\n                int a = f[nums[x]][0];\n                int b = f[nums[x]].back();\n                ret=min(ret,n-b+a);\n            }\n            \n            return ret;\n            \n        };\n        for(int i=0;i<queries.size();i++){\n            ans.push_back(cacl(queries[i]));\n            \n        }\n        return ans;\n        \n    }\n};","author":"冲","submissionId":"611246414"},[]]},{"1855":[{"id":"1855","fileName":"611246597.txt","sourceCode":"class Solution {\n   public:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> dp;\n        for (int i = 0; i < nums.size(); i++) {\n            dp[nums[i]].emplace_back(i);\n        }\n\n        vector<int> res(queries.size());\n        for (int i = 0; i < queries.size(); i++) {\n            int idx = queries[i];\n            int t = nums[idx];\n\n            auto& c = dp[t];\n            if (c.size() == 1) {\n                res[i] = -1;\n                continue;\n            }\n\n            auto m = lower_bound(c.begin(), c.end(), idx);\n            int l = 0, r = 0;\n            if (m == c.begin()) {\n                l = idx + nums.size() - c.back();\n            } else {\n                l = idx - *(m - 1);\n            }\n\n            if (m + 1 == c.end()) {\n                r = c[0] + nums.size() - idx;\n            } else {\n                r = *(m + 1) - idx;\n            }\n\n            res[i] = min(l, r);\n        }\n\n        return res;\n    }\n};","author":"hui","submissionId":"611246597"},[]]},{"1856":[{"id":"1856","fileName":"611246522.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int len = nums.size();\n        // nums.insert(nums.end(),nums.begin(),nums.end());\n        unordered_map<int,vector<int>> hash;\n        for(int i=0;i<nums.size();i++){\n            hash[nums[i]].push_back(i);\n        }\n        for(auto &[c1,c2]:hash){\n            c2.push_back(c2.front()+len);\n        }\n        int L = queries.size();\n        vector<int> res;\n        for(int i=0;i<L;i++){\n            int id = queries[i];\n            if(hash[nums[id]].size() == 2) {\n                res.push_back(-1);\n                continue;\n            }else{\n                auto it = lower_bound(hash[nums[id]].begin(),hash[nums[id]].end(), id);\n                int pre, nxt;\n                if(it == hash[nums[id]].begin()){\n                    pre = hash[nums[id]][0] - hash[nums[id]][hash[nums[id]].size()-2] + len;\n                    nxt = hash[nums[id]][1] - hash[nums[id]][0];\n                    \n                }else{\n                    pre = *it - *prev(it);\n                    // cout<<pre<<endl;\n                    nxt = *next(it) - *it;\n                    // cout<<hash[nums[id]].size()<<endl;\n                }\n                res.push_back(min(pre,nxt));\n            }\n        }\n        return res;\n    }\n};","author":"我也不想c+v呀","submissionId":"611246522"},[]]},{"1859":[{"id":"1859","fileName":"611246782.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<int> ans(n, INT_MAX);\n        unordered_map<int, pair<int, int>> window;\n        for (int i = 0; i < n; i++) {\n            if (window.find(nums[i]) == window.end()){\n                window[nums[i]].first = window[nums[i]].second = i;\n                ans[i] = INT_MAX;\n            }\n            else {\n                ans[i] = min(i - window[nums[i]].second,\n                             window[nums[i]].first + n - i);\n                ans[window[nums[i]].first] = min(ans[window[nums[i]].first],\n                                                 window[nums[i]].first + n - i);\n                ans[window[nums[i]].first] =\n                    min(ans[window[nums[i]].first],\n                        i - window[nums[i]].first);\n                \n                ans[window[nums[i]].second] = min(\n                    ans[window[nums[i]].second],i - window[nums[i]].second);\n                window[nums[i]].second = i;\n            }\n        }\n        // for (int i = 0; i < n; i++) {\n        //     cout << ans[i] << ' ';\n        // }\n        vector<int> ans2(m, -1);\n        for (int i = 0; i < m; i++) {\n            ans2[i] = ans[queries[i]];\n            if (ans2[i] == INT_MAX) {\n                ans2[i] = -1;\n            }\n        }\n        return ans2;\n    }\n};","author":"苏丹.奥古斯都","submissionId":"611246782"},[]]},{"1860":[{"id":"1860","fileName":"611246619.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n\n        n = len(queries)\n        m = len(nums)\n        ans = [-1] * n\n        # ans_maps = defaultdict(set)\n        ans_maps = defaultdict(list)\n        cnt = Counter(nums)\n        dis_array = [-1] * m\n        for i, num in enumerate(nums):\n            # ans_maps[num].add(i)\n            ans_maps[num].append(i)\n        for i, num in enumerate(nums):\n            if cnt[num] == 1:\n                continue\n            # cand = ans_maps[num] - set([i])\n            # tmp = 2*m\n            # for val in cand:\n            #     tmp = min(tmp, abs(val - i), abs(val+m-i), abs(i+m-val))\n            tmp = 2*m\n            array = ans_maps[num]\n            cand = bisect_left(array, i)\n            # print(cand, array, i)\n            tmp = min(tmp, abs(i+m-array[cand-1]), abs(i-array[cand-1]), abs(i-array[(cand+1)%len(array)]), abs(array[(cand+1)%len(array)]+m-i))\n            dis_array[i] = tmp\n        # print(queries, dis_array)\n        for i, q in enumerate(queries):\n            ans[i] = dis_array[q]\n\n        return ans\n            \n        ","author":"raphael","submissionId":"611246619"},[]]},{"1861":[{"id":"1861","fileName":"611246899.txt","sourceCode":"function solveQueries(nums: number[], queries: number[]): number[] {\n    const len = nums.length;\n    const map = new Map();\n    for (let i = 0; i < len; i++) {\n        if (!map.has(nums[i])) map.set(nums[i], []);\n        map.get(nums[i]).push(i);\n    }\n\n    return queries.map((i) => {\n        const arr = map.get(nums[i]);\n        const length = arr.length;\n        const j = arr.findIndex((j) => j == i);\n        if (length === 1) return -1;\n        else if (j === 0)\n            return Math.min(\n                arr[j + 1] - arr[j],\n                len - 1 - arr[length - 1] + arr[j] + 1\n            );\n        else if (j === length - 1)\n            return Math.min(arr[j] - arr[j - 1], len - 1 - arr[j] + arr[0] + 1);\n        else return Math.min(arr[j] - arr[j - 1], arr[j + 1] - arr[j]);\n    });\n}\n","author":"30°Nのdestiny","submissionId":"611246899"},[]]},{"1862":[{"id":"1862","fileName":"611246632.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dic = {}\n        ans = [10**9]*len(queries)\n        for index in range(len(nums)):\n            dic[nums[index]] = dic.get(nums[index],SortedList())\n            dic[nums[index]].add(index)\n            dic[nums[index]].add(index+len(nums))\n            dic[nums[index]].add(index-len(nums))\n\n        index = 0\n        for q in queries:\n            if nums[q] in dic:\n                lis = dic[nums[q]]\n                p_i = lis.bisect_right(q)\n                p_ans = []\n                if p_i < len(lis):\n                    p_ans.append(lis[p_i])\n                if p_i - 2 >= 0:\n                    p_ans.append(lis[p_i-2])\n                for p in p_ans:\n                    leng = abs(p-q) if abs(p-q) != len(nums) and p!=q else 10**9\n                    ans[index] = min(ans[index],leng)\n            index += 1\n        ans = [-1 if a == 10**9 else a for a in ans]\n        return ans","author":"taoria","submissionId":"611246632"},[]]},{"1863":[{"id":"1863","fileName":"611246809.txt","sourceCode":"class Solution {\npublic:\n    int find2(vector<int> &v,int value) {\n        int l=0,r=v.size()-1;\n        while(l<=r) {\n            int mid=(l+r)/2;\n            if(v[mid]<value)  l=mid+1;\n            else if(v[mid]>value) r=mid-1;\n            else return mid;\n        }\n        return -1;\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> res;\n        unordered_map<int,vector<int>> map;\n        for(int i=0;i<nums.size();i++) {\n            map[nums[i]].push_back(i);\n        }\n        for(auto &temp:map) {\n            sort(temp.second.begin(),temp.second.end());\n        }\n        for(int i:queries) {\n            if(map.find(nums[i])==map.end()) res.push_back(-1);\n            else {\n                vector<int> &v=map[nums[i]];\n                if(v.size()==1) {res.push_back(-1);continue;}\n                int index=find2(v,i);\n                if(index==0) res.push_back(min(v[index+1]-v[index],v[index]+(int)nums.size()-v.back()));  \n                else if(index==v.size()-1) res.push_back(min(v[index]-v[index-1],v[0]+(int)nums.size()-v.back()));\n                else res.push_back(min(v[index+1]-v[index],v[index]-v[index-1]));\n            }\n        }\n        return res;\n    }\n};","author":"yu15030","submissionId":"611246809"},[]]},{"1864":[{"id":"1864","fileName":"611247077.txt","sourceCode":"class Solution {\npublic:\n    int minidistance(int size, int index1, int index2){\n        int ans1 = index2 - index1;\n        int ans2 = size + index1 - index2;\n        return min(ans1, ans2);\n    }\n\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int,vector<int>> index;\n        unordered_map<int,int> m;\n        vector<int> answer;\n        for(int i=0; i<nums.size(); i++){\n            if(index.find(nums[i]) == index.end()){\n                index[nums[i]] = {i};\n                m[i] = 0;\n            }\n            else{\n                index[nums[i]].push_back(i);\n                m[i] = index[nums[i]].size()-1;\n            }\n        }\n        for(auto i : queries){\n            int num = nums[i];\n            int size = index[num].size();\n            int ans1, ans2;\n            if(index[num].size() == 1){\n                answer.push_back(-1);\n                continue;\n            }\n            if(index[num][0] == i){\n                ans1 = minidistance(nums.size(), index[num][0], index[num][1]);\n                ans2 = minidistance(nums.size(), index[num][0], index[num][size-1]);\n                answer.push_back(min(ans1, ans2));\n                continue;\n            }\n            if(index[num][size-1] == i){\n                ans1 = minidistance(nums.size(), index[num][0], index[num][size-1]);\n                ans2 = minidistance(nums.size(), index[num][size-2], index[num][size-1]);\n                answer.push_back(min(ans1, ans2));\n                continue;\n            }\n            int n = m[i];\n            ans1 = minidistance(nums.size(), index[num][n], index[num][n+1]);\n            ans2 = minidistance(nums.size(), index[num][n-1], index[num][n]);\n            answer.push_back(min(ans1, ans2));\n        }\n\n        return answer;\n    }\n};","author":"Mathews","submissionId":"611247077"},[]]},{"1865":[{"id":"1865","fileName":"611247170.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        vector<int> pre(n, -1), nxt(n, -1);\n        unordered_map<int, int> first, last; // 每个元素第一次出现的下标和最后一次出现的下标\n        unordered_map<int, int> mp;\n        for(int i = 0; i < n; i++) {\n            int temp = nums[i];\n            if(first.find(temp) == first.end()) first[temp] = i;\n            if(mp.find(temp) == mp.end()) pre[i] = -1;\n            else pre[i] = mp[temp];\n            mp[temp] = i;\n        }\n        mp.clear();\n        for(int i = n - 1; i >= 0; i--) {\n            int temp = nums[i];\n            if(last.find(temp) == last.end()) last[temp] = i;\n            if(mp.find(temp) == mp.end()) nxt[i] = -1;\n            else nxt[i] = mp[temp];\n            mp[temp] = i;\n        }\n\n        vector<int> ans(q);\n        for(int i = 0; i < q; i++) {\n            int idx = queries[i];\n            int ret = INT_MAX;\n            if(pre[idx] != -1) ret = min(abs(pre[idx] - idx), ret);\n            if(pre[idx] == -1 && last[nums[idx]] != idx) ret = min(min(abs(last[nums[idx]] - idx), n - abs(last[nums[idx]] - idx)), ret);\n            if(nxt[idx] != -1) ret = min(abs(nxt[idx] - idx), ret);\n            if(nxt[idx] == -1 && first[nums[idx]] != idx) ret = min(min(abs(first[nums[idx]] - idx), n - abs(first[nums[idx]] - idx)), ret);\n            ans[i] = ret == INT_MAX ? -1 : ret;\n        }\n        return ans;\n    }\n};","author":"原味鸡","submissionId":"611247170"},[]]},{"1867":[{"id":"1867","fileName":"611247256.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        List<Integer> ans = new ArrayList<>();\n        Map<Integer, int[]> map = new HashMap<>();\n        int[][] memo = new int[n][2]; \n        for (int i = 0; i < n; i++) {\n            if (map.containsKey(nums[i])) {\n                int[] x = map.get(nums[i]);\n                memo[i][0] = i - x[1];\n                memo[x[1]][1] = i - x[1];\n                x[1] = i;\n                map.put(nums[i], x);\n            } else {\n                memo[i][0] = i;\n                map.put(nums[i], new int[]{i, i});\n            }\n        }\n        for (int k : map.keySet()) {\n            int[] v = map.get(k);\n            if (v[0] == v[1]) {\n                memo[v[0]][0] = -1; \n                memo[v[0]][1] = -1; \n            } else {\n                memo[v[0]][0] += n - v[1];\n                memo[v[1]][1] =  memo[v[0]][0];\n            }\n        }\n        for (int q : queries) {\n            ans.add(Math.min(memo[q][0], memo[q][1]));\n        }\n        return ans;\n    }\n}","author":"白菜小丸子","submissionId":"611247256"},[]]},{"1868":[{"id":"1868","fileName":"611247011.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n    ans := make([]int, len(queries))\n    for i := range ans {\n        ans[i] = -1\n    }\n\n    mp := map[int][]int{}\n    for i, x := range nums {\n        mp[x] = append(mp[x], i)\n    }\n\n    n := len(nums)\n    for i, q := range queries {\n        if _, has := mp[nums[q]]; !has {\n            continue\n        }\n\n        a := mp[nums[q]]\n        if len(a) == 1 {\n            continue\n        }\n        \n        j, found := slices.BinarySearch(a, q)\n        if !found {\n            continue\n        }\n\n        if j == len(a) - 1 {\n            ans[i] = min(a[j] - a[j-1], n-(a[j] - a[0]))\n        } else if j == 0 {\n            ans[i] = min(a[j+1]-a[0], n-(a[len(a)-1]-a[0]))\n        } else {\n            ans[i] = min(a[j]-a[j-1], a[j+1]-a[j])\n        }\n    }\n    \n    return ans\n}","author":"tyrantzhao","submissionId":"611247011"},[]]},{"1869":[{"id":"1869","fileName":"611247062.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        int n = a.size();\n        vector<int> res;\n        unordered_map<int, vector<int>> idx;\n        \n        // vector<int> s(1e6 + 10, 0);\n        for (int i = 0; i < n; i ++) {\n            int cnt = 0;\n            idx[a[i]].push_back(i);\n        }\n        /*for (auto [x, c ] : ma) {\n            for (auto [y, k] : c) {\n                cout << y << ' ' << k << endl;\n            }\n        }*/\n        \n        for (int i = 0; i < q.size(); i ++) {\n            int x = a[q[i]];\n            if (idx[x].size() == 1) {\n                res.push_back(-1);\n                continue;\n            }\n            \n            auto& id = idx[x];\n            \n            auto it = lower_bound(id.begin(), id.end(), q[i]);\n            int c = it - id.begin();\n            \n            int w = 1e9;\n            int l = (c - 1 + id.size()) % id.size();\n            int d1 = abs(q[i] - id[l]);\n            w = min(w, min(d1, n - d1));\n            \n            int r = (c + 1) % id.size();\n            int d2 = abs(q[i] - id[r]);\n            w = min(w, min(d2, n - d2));\n            \n            res.push_back(w);\n        }\n        return res;\n    }\n};\n// nums = [1,3,1,4,1,3,2], queries = [0,3,5]","author":"surpass-w","submissionId":"611247062"},[]]},{"1870":[{"id":"1870","fileName":"611247276.txt","sourceCode":"   class Solution {\n        public List<Integer> solveQueries(int[] nums, int[] queries) {\n            Map<Integer, List<Integer>> nums2IndexListMap = new HashMap<>();\n            for (int i = 0; i < nums.length; i++) {\n                int num = nums[i];\n                List<Integer> list = nums2IndexListMap.getOrDefault(num, new ArrayList<>());\n                list.add(i);\n                nums2IndexListMap.put(num, list);\n            }\n            Map<Integer, Integer[]>   nums2IndexArrMap = new HashMap<>();\n            for (Map.Entry<Integer, List<Integer>> integerListEntry : nums2IndexListMap.entrySet()) {\n                nums2IndexArrMap.put(integerListEntry.getKey(),integerListEntry.getValue().toArray(new Integer[0]));\n            }\n            int[] ans = new int[queries.length];\n            for (int i = 0; i < queries.length; i++) {\n                int query = queries[i];\n                int num = nums[query];\n                Integer[] list = nums2IndexArrMap.get(nums[query]);\n                if (list.length <= 1) {\n                    ans[i] = -1;\n                } else {\n                    int indexListSize = list.length;\n                    int index = Arrays.binarySearch(list, query);\n                    int now = Integer.MAX_VALUE;\n                    if (index != 0 && index != indexListSize - 1) {\n                        now = Math.min(list[index + 1] - query, query - list[index - 1]);\n                    } else if (index == 0) {\n                        Integer beforeIndex = list[indexListSize - 1];\n                        now = Math.min(list[index + 1] - query, query + nums.length - beforeIndex);\n                    } else if (index == indexListSize - 1) {\n                        Integer afterIndex = list[0];\n                        now = Math.min(query - list[index - 1], nums.length  - query + afterIndex);\n                    }\n                    ans[i] = now;\n                }\n            }\n            ArrayList<Integer> integers = new ArrayList<>();\n            for (int an : ans) {\n                integers.add(an);\n            }\n            return integers;\n        }\n    }","author":"Sherlocked","submissionId":"611247276"},[]]},{"1871":[{"id":"1871","fileName":"611247636.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        m = len(nums)\n        res = [m] * m\n        pre = {}\n        for i in range(m*2):\n            n = nums[i%m]\n            if n in pre:\n                j = pre[n]\n\n                res[i%m] = min(res[i%m], i-j)\n                res[j%m] = min(res[j%m], i-j)\n            pre[n] = i\n\n        return [res[x] if res[x]<m else -1 for x in queries]","author":"BlueZ","submissionId":"611247636"},[]]},{"1872":[{"id":"1872","fileName":"611247506.txt","sourceCode":"class Solution {\n\tMap<Integer, TreeSet<Integer>> numMap;\n\n\tpublic List<Integer> solveQueries(int[] nums, int[] queries) {\n\t\tnumMap = new HashMap<>();\n\t\tfor (int i = 0 ; i < nums.length ; i++) {\n\t\t\tint num = nums[i];\n\t\t\tTreeSet<Integer> curSet = numMap.getOrDefault(num, new TreeSet<>());\n\t\t\tnumMap.put(num, curSet);\n\t\t\tcurSet.add(i);\n\t\t}\n\n\t\tList<Integer> ansList = new ArrayList<>();\n\t\tfor (int i = 0 ; i < queries.length ; i++) {\n\t\t\tint qPos = queries[i];\n\t\t\tint qNum = nums[qPos];\n\t\t\tTreeSet<Integer> curSet = numMap.get(qNum);\n\t\t\tif (curSet.size() == 1) {\n\t\t\t\tansList.add(-1);\n\t\t\t} else {\n\t\t\t\tint minDist = -1;\n\t\t\t\tInteger distLeft = curSet.lower(qPos);\n\t\t\t\tif (distLeft != null) {\n\t\t\t\t\tint curDist = qPos - distLeft;\n\t\t\t\t\tif ((minDist == -1) || (minDist > curDist)) {\n\t\t\t\t\t\tminDist = curDist;\n\t\t\t\t\t}\n\t\t\t\t\tcurDist = nums.length - (qPos - distLeft);\n\t\t\t\t\tif ((minDist == -1) || (minDist > curDist)) {\n\t\t\t\t\t\tminDist = curDist;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdistLeft = curSet.last();\n\t\t\t\tif (distLeft != qPos) {\n\t\t\t\t\tint curDist = nums.length - distLeft + qPos;\n\t\t\t\t\tif ((minDist == -1) || (minDist > curDist)) {\n\t\t\t\t\t\tminDist = curDist;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tInteger distRight = curSet.higher(qPos);\n\t\t\t\tif (distRight != null) {\n\t\t\t\t\tint curDist = distRight - qPos;\n\t\t\t\t\tif ((minDist == -1) || (minDist > curDist)) {\n\t\t\t\t\t\tminDist = curDist;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdistRight = curSet.first();\n\t\t\t\tif (distRight != qPos) {\n\t\t\t\t\tint curDist = nums.length - qPos + distRight;\n\t\t\t\t\tif ((minDist == -1) || (minDist > curDist)) {\n\t\t\t\t\t\tminDist = curDist;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tansList.add(minDist);\n\t\t\t}\n\t\t}\n\t\treturn ansList;\n\t}\n}","author":"xish","submissionId":"611247506"},[]]},{"1873":[{"id":"1873","fileName":"611247593.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        nums_map = defaultdict(list)\n        for i in range(n):\n            nums_map[nums[i]].append(i)\n            nums_map[nums[i]].append(i + n)\n            nums_map[nums[i]].append(i - n)\n        for k, v in nums_map.items():\n            nums_map[k].sort()\n        res = []\n        for q in queries:\n            x = nums[q]\n            if x not in nums_map or len(nums_map[x]) <= 3:\n                res.append(-1)\n                continue\n            # 二分查找 nums_map[x] 中第一个大于 q 的位置\n            less = bisect.bisect_left(nums_map[x], q) - 1\n            # 二分查找 nums_map[x] 中第一个小于 q 的位置\n            greater = bisect.bisect_right(nums_map[x], q)\n            ans = min(abs(nums_map[x][less] - q), abs(nums_map[x][greater] - q))\n            if ans >= n:\n                res.append(-1)\n            else:\n                res.append(ans)\n        return res","author":"鸭梨","submissionId":"611247593"},[]]},{"1874":[{"id":"1874","fileName":"611247703.txt","sourceCode":"from bisect import *\nclass Solution:\n    def solveQueries(self, nums: list[int], queries: list[int]) -> list[int]:\n        dic={}\n        for i in range(len(nums)):\n            if nums[i] not in dic:\n                dic[nums[i]]=[i]\n            else:\n                dic[nums[i]].append(i)\n        ans=[-1]*len(queries)\n        for i in range(len(queries)):\n            array=dic[nums[queries[i]]]\n            length=len(array)\n            if length==1:\n                continue\n            else:\n                index=bisect_left(array,queries[i])\n                if index==0:\n                    ans[i]=min(array[1]-array[0],array[0]+len(nums)-array[-1])\n                elif index==length-1:\n                    ans[i]=min(array[-1]-array[-2],array[0]+len(nums)-array[-1])\n                else:\n                    ans[i]=min(array[index+1]-array[index],array[index]-array[index-1])\n        return ans","author":"无名氏","submissionId":"611247703"},[]]},{"1875":[{"id":"1875","fileName":"611247790.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size(),m=queries.size();\n        unordered_map<int,vector<int>>mp,idx;\n        vector<int>ans(queries.size(),-1);\n        for(int i=0;i<n;i++){\n            mp[nums[i]].emplace_back(i);\n        }\n        for(int i=0;i<m;i++){\n            idx[queries[i]].emplace_back(i);\n        }\n        for(auto&[x,a]:mp){\n            int num=a.size();\n            if(num<2)continue;\n            for(int j=0;j<num;j++){\n                int mn=1e9;\n                if(j-1>=0)mn=min(mn,a[j]-a[j-1]);\n                if(j+1<num)mn=min(mn,a[j+1]-a[j]);\n                if(j==0||j==num-1)\n                    mn=min(mn,(a[0]-a[num-1]+n)%n);\n                if(mn==1e9)continue;\n                for(auto&id:idx[a[j]]){\n                    ans[id]=mn;\n                }\n            }\n        }\n        return ans;\n    }\n};","author":"烯落","submissionId":"611247790"},[]]},{"1876":[{"id":"1876","fileName":"611247799.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> indexs;\n        for (int i = 0; i < nums.size(); ++i) {\n            indexs[nums[i]].emplace_back(i);\n        }\n        vector<int> ans;\n        for (auto x : queries) {\n            auto& pos_vec = indexs[nums[x]];\n            if (pos_vec.size() == 1) {\n                ans.emplace_back(-1);\n                continue;\n            }\n            int minnum = 1000000;\n            int index = lower_bound(pos_vec.begin(),pos_vec.end(), x)-pos_vec.begin();\n            if (index != 0 && pos_vec[index]-pos_vec[index-1] < minnum) {\n                minnum = pos_vec[index]-pos_vec[index-1];\n            }\n            if ((index != pos_vec.size()-1) && (pos_vec[index+1]-pos_vec[index] < minnum)) {\n                minnum = pos_vec[index+1]-pos_vec[index];\n            }\n            if (index == pos_vec.size() -1 && nums.size()-pos_vec[index] + pos_vec[0] < minnum) {\n                minnum = nums.size()-pos_vec[index] + pos_vec[0];\n            }\n            if (index == 0 && nums.size()-pos_vec[pos_vec.size()-1] + pos_vec[0] < minnum) {\n                minnum = nums.size()-pos_vec[pos_vec.size()-1] + pos_vec[0];\n            }\n            ans.emplace_back(minnum);\n        }\n        return ans;\n    }\n};","author":"躺平选手","submissionId":"611247799"},[]]},{"1877":[{"id":"1877","fileName":"611247711.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n\tmp := make(map[int][]int)\n\n\tfor i := 0; i < len(nums); i++ {\n\t\t_, ok := mp[nums[i]]\n\t\tif ok {\n\t\t\tmp[nums[i]] = append(mp[nums[i]], i)\n\t\t} else {\n\t\t\tmp[nums[i]] = []int{}\n\t\t\tmp[nums[i]] = append(mp[nums[i]], i)\n\t\t}\n\t}\n\n\t// for k, v := range mp {\n\t// \tfmt.Println(k)\n\t// \tfmt.Println(v)\n\t// }\n\n\tans := make([]int, len(queries))\n\tfor i := 0; i < len(queries); i++ {\n\t\ttarget := nums[queries[i]]\n\t\t// fmt.Println(target)\n\n\t\tif len(mp[target]) == 1 {\n\t\t\tans[i] = -1\n\t\t\tcontinue\n\t\t}\n\n\t\t// 找q[i]的位置\n\t\tl, r := 0, len(mp[target])-1\n\t\tfor l <= r {\n\t\t\tmid := (l + r) >> 1\n\t\t\tif mp[target][mid] > queries[i] {\n\t\t\t\tr = mid - 1\n\t\t\t} else {\n\t\t\t\tl = mid + 1\n\t\t\t}\n\t\t}\n\t\t// r位置\n\t\t// fmt.Println(i, r)\n\t\tans[i] = math.MaxInt\n\t\tif r-1 >= 0 {\n\t\t\tans[i] = min(mp[target][r]-mp[target][r-1], ans[i])\n\t\t\tans[i] = min(len(nums)-mp[target][r]+mp[target][r-1], ans[i])\n\t\t} else {\n\t\t\tpos := len(mp[target]) - 1\n\t\t\tans[i] = min(mp[target][pos]-mp[target][r], ans[i])\n\t\t\tans[i] = min(len(nums)-mp[target][pos]+mp[target][r], ans[i])\n\t\t}\n\n\t\tif r+1 < len(mp[target]) {\n\t\t\tans[i] = min(mp[target][r+1]-mp[target][r], ans[i])\n\t\t\tans[i] = min(len(nums)-mp[target][r+1]+mp[target][r], ans[i])\n\t\t} else {\n\t\t\tpos := 0\n\t\t\tans[i] = min(mp[target][r]-mp[target][pos], ans[i])\n\t\t\tans[i] = min(len(nums)-mp[target][r]+mp[target][pos], ans[i])\n\t\t}\n\t}\n\treturn ans\n}\n","author":"回家","submissionId":"611247711"},[]]},{"1878":[{"id":"1878","fileName":"611247120.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        q = defaultdict(list)\n        mx = len(nums)\n        for i, x in enumerate(nums):\n            q[x].append(i)\n\n\n        ans = [0] * len(queries)\n        for i, idx in enumerate(queries):\n            x = nums[idx]\n            if len(q[x]) == 1:\n                ans[i] = -1\n                continue\n            n = len(q[x])\n            ii = bisect_left(q[x], idx)\n            tmp_mi = min(abs(q[x][ii] - q[x][(ii-1) % n]), abs(q[x][(ii+1) % n] - q[x][ii]))\n            tmp_mx = max(abs(q[x][ii] - q[x][(ii-1) % n]), abs(q[x][(ii+1) % n] - q[x][ii]))\n            ans[i] = min(tmp_mi, mx - tmp_mx)\n        return ans\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n        ","author":"Beautiful Shawsfr","submissionId":"611247120"},[]]},{"1880":[{"id":"1880","fileName":"611247881.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> hash;\n        for(int i = 0; i < nums.size(); i ++){\n            hash[nums[i]].push_back(i);\n        }\n        vector<int> ans;\n        int len = nums.size();\n        for(int i = 0;i < queries.size(); i ++){\n            auto &vec = hash[nums[queries[i]]];\n            auto it = std::lower_bound(vec.begin(), vec.end(), queries[i] + 1);\n            // int num = queries[i];\n            auto it_rev = std::lower_bound(vec.begin(), vec.end(), queries[i]);\n               int res = -1;\n            if(it_rev != vec.begin()){\n               it_rev = std::prev(it_rev);\n                int temp = queries[i] - *it_rev;\n                temp = min(temp,abs(len - temp));\n                if(res != -1) res = min(res, temp );\n                else res  = temp;\n            } else {\n                auto it_rev2 =  vec.rbegin();\n                if(*it_rev2 != queries[i]){\n                    int temp = *it_rev2 - queries[i];\n                    temp = min(temp,abs(len - temp));\n                    if(res != -1) res = min(res,  temp ); \n                    else res = temp;\n\n                }\n            }\n            if(it != vec.end()){\n                int temp =*it -queries[i];\n                temp = min(temp,abs(len - temp));\n                if(res != -1) res = min(res, temp ); \n                else res = temp ;\n            } else {\n                it = vec.begin();\n                if(*it != queries[i]){\n                    int temp = queries[i] - *it;\n                    temp = min(temp,abs(len - temp));\n                    if(res != -1) res = min(res, temp ); \n                    else res =  temp ;\n                    // res = min(res,abs(len - res));\n                }\n            \n            }\n            \n            ans.push_back(res);\n        }\n        return ans;\n    }\n};","author":"vector","submissionId":"611247881"},[]]},{"1881":[{"id":"1881","fileName":"611247884.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dic = defaultdict(list)\n        for i, val in enumerate(nums):\n            dic[val].append(i)\n        \n        ans = []\n        for i in queries:\n            l = dic[nums[i]]\n            j = bisect_left(l, i)\n            n = len(nums)\n            if len(l) == 1:\n                ans.append(-1)\n                continue\n            tmp = inf\n            if j == 0:\n                tmp = min(tmp, n - (l[-1] - l[0]))\n            else:\n                tmp = min(tmp, l[j] - l[j - 1])\n            if j == len(l) - 1:\n                tmp = min(tmp, n - (l[-1] - l[0]))\n            else:\n                tmp = min(tmp, l[j + 1] - l[j])\n                \n            ans.append(tmp)\n        return ans","author":"Charles_H","submissionId":"611247884"},[]]},{"1882":[{"id":"1882","fileName":"611247992.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        answered = {}\n        search = defaultdict(list)\n        for i, v in enumerate(nums):\n            search[v].append(i)\n        lst = [inf] * n\n        for k, v in search.items():\n            for i in range(1, len(v)):\n                lst[v[i-1]] = min(v[i]-v[i-1], lst[v[i-1]])\n                lst[v[i]] = v[i]-v[i-1]\n            if v[0] != v[-1]:\n                lst[v[0]] = min(lst[v[0]], n-v[-1]+v[0])\n                lst[v[-1]] = min(lst[v[-1]], n-v[-1]+v[0])\n        ans = []\n        for i in queries:\n            if lst[i] == inf:\n                ans.append(-1)\n            else:\n                ans.append(lst[i])\n        return ans","author":"aden1350","submissionId":"611247992"},[]]},{"1883":[{"id":"1883","fileName":"611248154.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int size = nums.size();\n        int qsize = queries.size();\n        vector<int> mindists(size,100001);\n        unordered_map<int,int> mp;\n        unordered_map<int,int> first_time;\n        for(int i=0;i<size;++i){\n            if(mp.find(nums[i]) != mp.end()){\n                mindists[i] = min(mindists[i],i - mp[nums[i]]);\n                //cout << mindists[i] << \" \" << i << endl;\n                mp[nums[i]] = i;\n            }else{\n                mp[nums[i]] = i;\n                first_time[nums[i]] = i;\n            }\n        }\n        \n        //cout << endl;\n        \n        for(auto item : first_time)\n        {\n            //cout << mindists[item.second] << endl;\n            if(item.second != mp[item.first]){\n                mindists[item.second] = min(mindists[item.second],min(mp[item.first] - item.second,item.second + size - mp[item.first]));\n            }\n            //cout << mindists[item.second] << \" \" << item.second << \" \" << mp[item.first]  << \" \" << item.first << endl;\n        }\n        \n        //cout << endl;\n        \n        mp.clear();\n        first_time.clear();\n        for(int i=size-1;i>=0;--i){\n            if(mp.find(nums[i]) != mp.end()){\n                mindists[i] = min(mindists[i],mp[nums[i]] - i);\n                //cout << mindists[i] << \" \" << i << endl;\n                mp[nums[i]] = i;\n            }else{\n                mp[nums[i]] = i;\n                first_time[nums[i]] = i;\n            }\n        }\n        \n       // cout << endl;\n        \n        for(auto item : first_time)\n        {\n            //cout << mindists[item.second] << endl;\n            if(item.second != mp[item.first]){\n                mindists[item.second] = min(mindists[item.second],min(item.second - mp[item.first],mp[item.first] + size - item.second));\n            }\n            //cout << mindists[item.second] << \" \" << item.second << \" \" << mp[item.first]  << \" \" << item.first << endl;\n        }\n        vector<int> ret;\n        for(int i=0;i<qsize;++i){\n            ret.push_back(mindists[queries[i]] == 100001 ? -1 : mindists[queries[i]]);\n        }return ret;\n    }\n};","author":"Sparky","submissionId":"611248154"},[]]},{"1884":[{"id":"1884","fileName":"611248078.txt","sourceCode":"typedef struct {\n    int val;\n    int idx;\n} Pair;\n\nint cmpPair(const void* a, const void* b) {\n    Pair *pa = (Pair*)a, *pb = (Pair*)b;\n    if (pa->val == pb->val)\n        return pa->idx - pb->idx;\n    return pa->val - pb->val;\n}\n\nint* solveQueries(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize) {\n    int *ans = (int*)malloc(sizeof(int) * queriesSize);\n    int *minDist = (int*)malloc(sizeof(int) * numsSize);\n    Pair *pairs = (Pair*)malloc(sizeof(Pair) * numsSize);\n    for (int i = 0; i < numsSize; i++) {\n        pairs[i].val = nums[i];\n        pairs[i].idx = i;\n    }\n    qsort(pairs, numsSize, sizeof(Pair), cmpPair);\n    for (int i = 0; i < numsSize;) {\n        int j = i;\n        while (j < numsSize && pairs[j].val == pairs[i].val)\n            j++;\n        int cnt = j - i;\n        if (cnt == 1) {\n            minDist[pairs[i].idx] = -1;\n        } else {\n            for (int k = i; k < j; k++) {\n                int cur = pairs[k].idx;\n                int prev = pairs[(k == i ? j - 1 : k - 1)].idx;\n                int next = pairs[(k == j - 1 ? i : k + 1)].idx;\n                int d1 = (cur >= prev ? cur - prev : cur + numsSize - prev);\n                int d2 = (next >= cur ? next - cur : next + numsSize - cur);\n                minDist[cur] = d1 < d2 ? d1 : d2;\n            }\n        }\n        i = j;\n    }\n    for (int i = 0; i < queriesSize; i++) {\n        ans[i] = minDist[queries[i]];\n    }\n    *returnSize = queriesSize;\n    free(pairs);\n    free(minDist);\n    return ans;\n}","author":"sinkDink","submissionId":"611248078"},[]]},{"1885":[{"id":"1885","fileName":"611248357.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& qs) {\n        unordered_map<int, vector<int>> ms;\n        int n = nums.size();\n        for(int i = 0; i < n; ++i){\n            int x = nums[i];\n            ms[x].push_back(i);\n        }\n        vector<int> a = qs;\n        for(int i = 0; i < qs.size(); ++i){\n            int ai = -1;\n            int qi = qs[i], v = nums[qi];\n            auto &vs = ms[v];\n            auto l = vs.size();\n            if(l < 2){\n                a[i] = ai;\n                continue;\n            }\n            auto id = std::lower_bound(vs.begin(), vs.end(), qi) - vs.begin();\n            // cout << qi << \" \" << v << \" \" << id << endl;\n            if(id == 0){\n                ai = min(vs[id+1] - vs[id], vs[0] + n - vs.back());\n            }else if(id == l - 1){\n                ai = min(vs[id] - vs[id-1], vs[0] + n - vs.back());\n            }else{\n                ai = min(vs[id] - vs[id-1], vs[id+1] - vs[id]);\n            }\n            a[i] = ai;\n        }\n        return a;\n    }\n};","author":"zhangwenyao","submissionId":"611248357"},[]]},{"1886":[{"id":"1886","fileName":"611248147.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        unordered_map<int,vector<int>> hmap;\n        vector<int> n_idx(n);\n        for(int i = 0;i<n;++i){\n            hmap[nums[i]].push_back(i);\n            n_idx[i] = hmap[nums[i]].size()-1;\n        }\n        vector<int> ans;\n        for(const int q:queries){\n            int idx = n_idx[q];\n            int val = nums[q];\n            if(hmap[val].size() == 1){\n                ans.push_back(-1);\n            }else{\n                int size = hmap[val].size();\n                if(idx == 0){\n                    int l = hmap[val][1],r = hmap[val][size-1];\n                    int ln = min(l-q,n+q-l),rn = min(r-q,n+q-r);\n                    ans.push_back(min(ln,rn));\n                }else if(idx == size-1){\n                    int l = hmap[val][idx-1],r = hmap[val][0];\n                    int ln = min(q-l,n+l-q),rn = min(q-r,n+r-q);\n                    ans.push_back(min(ln,rn));\n                }else{\n                    int l = hmap[val][idx-1],r = hmap[val][idx+1];\n                    int ln = min(q-l,n+l-q),rn = min(r-q,n+q-r);\n                    ans.push_back(min(ln,rn));\n                }\n            }\n        }\n        return ans;\n    }\n};","author":"Yhc8Lx5g9O","submissionId":"611248147"},[]]},{"1887":[{"id":"1887","fileName":"611248213.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer, List<Integer>> indexMap = new HashMap();\n\n        for(int i = 0; i < nums.length; i++) {\n            List<Integer> value = indexMap.get(nums[i]);\n            if(value == null) {\n                value = new ArrayList<>();\n                indexMap.put(nums[i], value);\n            }\n            value.add(i);\n        }\n\n        List<Integer> res = new ArrayList<>();\n        for(int i = 0; i < queries.length; i++) {\n            List<Integer> value = indexMap.get(nums[queries[i]]);\n            int min = 0;\n            if(value == null || value.size() == 1) {\n                res.add(-1);\n            } else{\n                int mid = erFen(value, queries[i]);\n                if(mid == 0) {\n                    res.add(Math.min(value.get(1) - queries[i], queries[i] + nums.length - value.get(value.size() - 1)));\n                } else if(mid == value.size() - 1) {\n                    res.add(Math.min(queries[i] - value.get(value.size() - 2), value.get(0) + nums.length - queries[i]));\n                } else {\n                    res.add(Math.min(value.get(mid + 1) - queries[i], queries[i] - value.get(mid - 1)));\n                }\n            }\n        }\n        return res;\n    }\n    // 二分\n    private int erFen(List<Integer> value, int querie) {\n        int left = 0;\n        int right = value.size() - 1;\n        while(left <= right) {\n            int mid = (right - left) / 2 + left;\n            int index = value.get(mid);\n            if(index == querie) {\n                return mid;\n            } else if(index > querie) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return -1;\n    }\n}","author":"名字","submissionId":"611248213"},[]]},{"1888":[{"id":"1888","fileName":"611248362.txt","sourceCode":"import collections\n\n\nclass Solution:\n    def solveQueries(self, nums, queries):\n        q=[]\n        n=len(queries)\n        for index,value in enumerate(queries):\n            q.append((value,index))\n        q.sort()\n        ret=[-1]*n\n        dic=collections.defaultdict(collections.deque)\n        m=len(nums)\n        for i in range(m-1,-1,-1):\n            dic[nums[i]].append(i)\n        left=0\n        for i in range(n):\n            value,index=q[i]\n            while left<value:\n                dic[nums[left]].appendleft(dic[nums[left]].pop())\n                left+=1\n            a=dic[nums[left]].pop()\n            # print(dic)\n            # print(dic,value)\n            temp=0x3f3f3f3f\n            if dic[nums[value]]:\n                temp=min(temp,abs(dic[nums[value]][-1]-value),m-abs(dic[nums[value]][-1]-value),abs(dic[nums[value]][0]-value),m-abs(dic[nums[value]][0]-value))\n            if temp==0x3f3f3f3f:temp=-1\n            ret[index]=temp\n            dic[nums[left]].appendleft(a)\n            left += 1\n        print(ret)\n        return ret","author":"broshen","submissionId":"611248362"},[]]},{"1891":[{"id":"1891","fileName":"611248469.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n, m = len(nums), len(queries)\n        if n == 1:\n            return [-1]*m\n        left, right = [-1]*n*2, [-1]*n*2\n        # if nums[0]==nums[-1]:\n        #     left[0] = 1\n        #     right[-1] = 1\n        ans = []\n        dcleft,dcright = defaultdict(int), defaultdict(int)\n        dcleft[nums[0]] = 0\n        dcright[nums[-1]] = 2*n - 1\n        newnums = nums+nums\n        for i in range(1,2*n):\n            cur1 = newnums[i]\n            if cur1 in dcleft:\n                left[i] = i - dcleft[cur1]\n            dcleft[cur1] = i\n            cur2 = newnums[2*n-1-i]\n            if cur2 in dcright:\n                right[2*n-i-1] = dcright[cur2] - (2*n-i-1)\n            dcright[cur2] = 2*n-i-1\n        # print(left)\n        # print(right)\n        for q in queries:\n            # tar = nums[q]\n            # inds = index_map[tar]\n            # if len(inds) < 2:\n            #     ans.append(-1)\n            #     continue\n            # tmp = n\n            # for idx in inds:\n            #     if idx == q:\n            #         continue\n            #     dist = min(abs(q - idx), n - abs(q - idx))\n            #     if dist < tmp:\n            #         tmp = dist\n            # ans.append(tmp)\n            prob = [left[q],right[q],left[q+n],right[q+n]]\n            prob = [i for i in prob if i != -1]\n            tmp = min(prob)\n            ans.append(tmp if tmp!=n else -1)\n        return ans","author":"Barcelona","submissionId":"611248469"},[]]},{"1893":[{"id":"1893","fileName":"611248792.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> ans(queries.size());\n        unordered_map<int, vector<int>> hash;\n        int n = nums.size();\n        for(int i = 0; i < nums.size(); i ++) hash[nums[i]].push_back(i);\n        for(int i = 0; i < queries.size(); i ++) {\n            int idx = queries[i];\n            int target = nums[idx];\n            auto& t = hash[target];\n            if(t.size() == 1) {\n                ans[i] = -1;\n                continue;\n            }\n            int l = 0, r = t.size() - 1;\n            while(l < r) {\n                int mid = l + r >> 1;\n                if(t[mid] >= idx) r = mid;\n                else l = mid + 1;\n            }\n            int pos = l;\n            int m = t.size();\n            int res = INT_MAX;\n            int next_pos = t[(pos - 1 + m) % m], last_pos = t[(pos + 1) % m];\n            //cout << pos << \" \" << next_pos << \" \" << last_pos << endl;\n            if(t[pos] > next_pos) {\n                res = min(res, abs(t[pos] - next_pos));\n                res = min(res, (next_pos - t[pos] + n) % n);\n            } else {\n                res = min(res, abs(t[pos] - next_pos));\n                res = min(res, (t[pos] - next_pos + n) % n);\n            }\n            \n            if(t[pos] > last_pos) {\n                res = min(res, abs(t[pos] - last_pos));\n                res = min(res, (last_pos - t[pos] + n) % n);\n            } else {\n                res = min(res, abs(t[pos] - last_pos));\n                res = min(res, (t[pos] - last_pos + n) % n);\n            }\n            ans[i] = res;\n        }\n        return ans;\n    }\n};","author":"已延毕，勿扰","submissionId":"611248792"},[]]},{"1894":[{"id":"1894","fileName":"611249029.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d=defaultdict(list)\n        n=len(nums)\n        for i in range(n):\n            d[nums[i]].append(i)\n        ans=[]\n        def bfind(a,val):\n            l=0\n            r=len(a)-1\n            while l<=r:\n                mid=(l+r)//2\n                if a[mid]<val:\n                    l=mid+1    \n                elif a[mid]>val:\n                    r=mid-1\n                else:\n                    return mid\n            return -1\n            \n        for pos in queries:\n            val=nums[pos]\n            if len(d[val])==1:\n                ans.append(-1)\n            else:\n                index=bfind(d[val],pos)\n                x=len(d[val])\n                               #  ans.append(min(abs(pos-d[val][(index-1+x)%x]),abs(d[val][(index+1)%x]-pos)))\n\n                # ans.append(min((abs(pos-d[val][(index+x-1)%x]+n)%n),(abs(d[val][(index+x-1)%x]-pos+n)%n)))\n                temp=10e7\n                # if index-1>=0:\n                temp=(pos+n-d[val][(index-1+x)%x])%n\n                # else:\n                #     temp=n+pos-d[val][index-1]\n              \n                temp=min(temp,(d[val][(index+1)%x]+n-pos)%n)\n                ans.append(temp)\n        return ans\n            \n        ","author":"炼红心","submissionId":"611249029"},[]]},{"1895":[{"id":"1895","fileName":"611249465.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] que) {\n        HashMap<Integer,ArrayList<Integer>> hash=new HashMap<>();\n        int n=nums.length,m=que.length;\n        for(int i=0;i<n;i++){\n            if(!hash.containsKey(nums[i]))\n                hash.put(nums[i],new ArrayList<>());\n            hash.get(nums[i]).add(i);\n        }\n        List<Integer> ans=new ArrayList<>();\n        for(int i=0;i<m;i++){\n            int p=que[i];\n            ArrayList<Integer> list=hash.get(nums[p]);\n            int sum=list.size();\n            if(sum==1){\n                ans.add(-1);\n                continue;\n            }\n            int x=f1(list,p);\n            if(x==list.size()-1){\n                ans.add(Math.min(p-list.get(x-1),list.get(0)+n-p));\n            }else if(x==0){\n                ans.add(Math.min(list.get(x+1)-p,p+n-list.get(sum-1)));\n            }else{\n                ans.add(Math.min(list.get(x+1)-p,p-list.get(x-1)));\n            }\n        }\n        return ans;\n    }\n    public int f1(ArrayList<Integer> list,int p){\n        int left=0,right=list.size()-1;\n        while(left<right){\n            int mid=(left+right)>>1;\n            if(list.get(mid)>=p){\n                right=mid;\n            }else{\n                left=mid+1;\n            }\n        }\n        return left;\n    }\n}","author":"黄彬","submissionId":"611249465"},[]]},{"1896":[{"id":"1896","fileName":"611248635.txt","sourceCode":"class Solution {\n    public static void main(String[] args) {\n\n        Solution solution = new Solution();\n        System.out.println(solution.solveQueries(new int[]{1, 3, 1, 4, 1, 3, 2}, new int[]{0, 3, 5}));\n    }\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer,Integer> map=new HashMap<>();\n        int[] tt=new int[nums.length];\n        Map<Integer,List<Integer>> map2=new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int t=map.getOrDefault(nums[i],-1)+1;\n            List<Integer> list = map2.getOrDefault(nums[i], new ArrayList<>());\n            list.add(i);\n            map2.put(nums[i],list);\n            map.put(nums[i],t);\n            tt[i]=t;\n        }\n        List<Integer> res=new ArrayList<>();\n        for (int query : queries) {\n            int t=nums[query];\n            List<Integer> list=map2.get(t);\n            if(list.size()==1){\n                res.add(-1);\n                continue;\n            }\n            int i=tt[query];\n            int r=list.get((i+list.size()+1)%list.size());\n            int l=list.get((i-1+list.size())%list.size());\n            res.add(Math.min(demo(r,query,nums.length),demo(l,query,nums.length)));\n        }\n        return res;\n    }\n    private int demo(int a,int b,int n){\n        return Math.min(Math.abs(a-b+n)%n,Math.abs(b-a+n)%n);\n    }\n}","author":"阳光大男孩","submissionId":"611248635"},[]]},{"1898":[{"id":"1898","fileName":"611249601.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<pair<int, int>> arr, qq;\n        for (auto q : queries){\n            qq.emplace_back(nums[q], q);\n        }\n        for (int i = 0; i < nums.size(); ++ i){\n            arr.emplace_back(nums[i], i);\n        }\n        sort(arr.begin(), arr.end());\n        vector<int> res;\n        int n = arr.size();\n        for (auto &q : qq){\n            pair<int, int> mi = {q.first, 0}, mx = {q.first, INT_MAX / 2};\n            int left = lower_bound(arr.begin(), arr.end(), mi) - arr.begin();\n            int right = upper_bound(arr.begin(), arr.end(), mx) - arr.begin();\n            int val = INT_MAX;\n            if (right != left + 1){\n                int pos = lower_bound(arr.begin() + left, arr.begin() + right, q) - arr.begin();\n                int nn = right - left;\n                int l = (pos - left - 1 + nn) % nn + left;\n                int r = (pos - left + 1) % nn + left;\n                int t1 = min(abs(arr[l].second - arr[pos].second), n - abs(arr[l].second - arr[pos].second));\n                int t2 = min(abs(arr[r].second - arr[pos].second), n - abs(arr[r].second - arr[pos].second));\n                val = min({val, t1, t2});\n            }\n          \n            // if (left - 1 >= 0 && arr[left - 1].first == q.first){\n            //     int delta = q.second - arr[left - 1].second;\n            //     int tmp = min(delta, n - delta);\n            //     cur = min(cur, tmp);\n            // }\n            // if (right < n && arr[right].first == q.first){\n            //     int delta = arr[right].second - q.second;\n            //     int tmp = min(delta, n - delta);\n            //     cur = min(cur, tmp);\n            // }\n            val = (val == INT_MAX) ? -1 : val;\n            res.emplace_back(val);\n            \n        }\n        return res;\n    }\n};","author":"淂帥","submissionId":"611249601"},[]]},{"1899":[{"id":"1899","fileName":"611249649.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=queries.size();\n        vector<int>res(n,-1);\n        unordered_map<int,vector<int>>mp;\n        vector<int>index(nums.size(),0);\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]].push_back(i);\n            index[i]=mp[nums[i]].size()-1;\n        }\n        int m=nums.size();\n        for(int i=0;i<n;i++){\n            int t=nums[queries[i]];\n            int ans=INT_MAX;\n            if(mp[t].size()==1) continue;\n            if(index[queries[i]]!=0) ans=min(ans,queries[i]-mp[t][index[queries[i]]-1]);\n            else ans=min(ans,m-mp[t].back()+queries[i]);\n            if(index[queries[i]]!=mp[t].size()-1) ans=min(ans,mp[t][index[queries[i]]+1]-queries[i]);\n            else ans=min(ans,m-queries[i]+mp[t][0]);\n            if(ans!=INT_MAX) res[i]=ans;\n        }\n        return res;\n    }\n};","author":"迷鹿","submissionId":"611249649"},[]]},{"1900":[{"id":"1900","fileName":"611249799.txt","sourceCode":"class Solution {\npublic:\n    int n;\n    int check(int x, int y){\n        if (x>y) swap(x,y);\n        return min(y-x, x+n-y);\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int i,j,ij,x,y,k,k1;\n        n=nums.size();\n        map<int, set<int>> mp;\n        \n        vector<int> ans;\n        for(i=0;i<n;++i) {\n            mp[nums[i]].insert(i);\n        }\n       \n        for(i=0;i<queries.size();++i){\n            j=queries[i];x = nums[j];\n            auto it = mp[x].lower_bound(j);\n            auto it1 = it;\n            ++it1;\n            if (it1==mp[x].end()) it1 = mp[x].begin();\n            ij = *it1;\n            k=-1;\n            if (ij!=j) k= check(j,ij);\n            if (it==mp[x].begin()) {\n                it1 = mp[x].end();--it1;\n            }else{\n                it1=it;--it1;\n            }\n            ij = *it1;\n            k1 = -1;\n            if (ij!=j) {\n                k1= check(j,ij);\n                if (k==-1 || k>k1) k=k1;\n            }\n        \n            ans.push_back(k);\n        }\n        \n       return ans; \n    }\n};","author":"算法笔试","submissionId":"611249799"},[]]},{"1901":[{"id":"1901","fileName":"611249516.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> last(n, -1);\n        vector<int> nxt(n, -1);\n        unordered_map<int, int> cur;\n        for (int i = 0; i < n; i++) {\n            auto [it, bo] = cur.insert({nums[i], i});\n            if (!bo) {\n                last[i] = it->second;\n                nxt[it->second] = i;\n                it->second = i;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            auto [it, bo] = cur.insert({nums[i], i});\n            if (!bo && i != it->second) {\n                last[i] = it->second;\n                nxt[it->second] = i;\n                it->second = i;\n            }\n        }\n        vector<int> ans;\n        for (const auto& q : queries) {\n            int res = INT_MAX;\n            if (last[q] != -1) {\n                res = min(res, (q + n - last[q]) % n);\n            }\n            if (nxt[q] != -1) {\n                res = min(res, (n + nxt[q] - q) % n);\n            }\n            if (res == INT_MAX) {\n                res = -1;\n            }\n            ans.push_back(res);\n        }\n        return ans;\n    }\n};","author":"Hack_Others","submissionId":"611249516"},[]]},{"1902":[{"id":"1902","fileName":"611249973.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        \n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n\n        int m = queries.size();\n        vector<int> ans(m, -1);\n        for (int i = 0; i < m; i++) {\n            int x = queries[i];\n            int val = nums[x];\n            \n            vector<int>& f = mp[val];\n            int fn = f.size();\n            \n            if (fn == 1) {\n                continue;\n            }\n            \n            if (f[0] == x) {\n                ans[i] = min(f[1] - f[0], n - f[fn - 1] + f[0]);\n                continue;\n            }\n            if (f[fn - 1] == x) {\n                ans[i] = min(f[fn - 1] - f[fn - 2], n - f[fn - 1] + f[0]);\n                continue;\n            }\n            \n            int pos = lower_bound(f.begin(), f.end(), x) - f.begin();\n            ans[i] = min(f[pos + 1] - f[pos], f[pos] - f[pos - 1]);\n        }\n        return ans;\n    }\n};","author":"Epic Noether5mF","submissionId":"611249973"},[]]},{"1904":[{"id":"1904","fileName":"611250132.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, set<int> > mp;\n        int n=nums.size();\n        for(int i=0; i<n; ++i){\n            mp[nums[i]].insert(i);\n        }\n\n        int mq = queries.size();\n        vector<int> ans(mq,-1);\n        for(int i=0; i<mq; ++i){\n            int num = nums[queries[i]];\n            auto &st = mp[num];\n            // cout << \"i: \" << i << \" \" << num << \" \" << st.size() << endl;\n            // for_each(st.begin(), st.end(), [](const auto& elem) {\n            //     cout << elem << \" \";\n            // });\n            // cout << \";stn\";\n\n            if(st.size()<=1){\n                continue;\n            }\n            auto it=st.find(queries[i]);\n\n            int mn=INT_MAX;\n            if(it!=st.end()){\n                // cout << *it << \" \" << (it==st.begin()) << \" \" << (next(it)==st.end()) << endl;\n                if(it!=st.begin()){\n                    int dis = *(it) - *prev(it);\n                    mn = min(mn, dis );\n                    mn = min(mn, n - dis );\n                }else{\n                    int dis = *prev(st.end()) - *(it);\n                    mn = min(mn, dis );\n                    mn = min(mn, n - dis );\n                }\n                if(next(it)!=st.end()){\n                    int dis = *next(it) - *(it);\n                    mn = min(mn, dis );\n                    mn = min(mn, n - dis );\n                }else{\n                    int dis = *(it) - *(st.begin());\n                    mn = min(mn, dis );\n                    mn = min(mn, n - dis );\n                }\n                ans[i] = mn;\n            }\n        }\n        return ans;\n    }\n};","author":"junw59","submissionId":"611250132"},[]]},{"1906":[{"id":"1906","fileName":"611250213.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        dic = defaultdict(list)\n        for i, v in enumerate(nums):\n            dic[v].append(i)\n        \n        res = []\n        for idx in queries:\n            lst = dic[nums[idx]]\n            if len(lst) == 1:\n                res.append(-1)\n            else:\n                i = bisect.bisect_left(lst, idx)\n                x = len(lst)\n                l = (i+x-1)%x\n                r = (i+1)%x\n                lv = abs(idx - lst[l]) if lst[l] < idx else idx + n - lst[l]\n                rv = abs(lst[r] - idx) if idx < lst[r] else lst[r] + n - idx\n                res.append(lv if lv <= rv else rv)\n        return res\n            \n        ","author":"Rong","submissionId":"611250213"},[]]},{"1907":[{"id":"1907","fileName":"611250431.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> cache{};\n\n        int n = nums.size();\n        for (auto i = 0; i < n; ++i) {\n            cache[nums[i]].emplace_back(i);\n        }\n\n        vector<int> ans{};\n        ans.reserve(queries.size());\n        for (auto &q : queries) {\n            auto &pos = cache[nums[q]];\n            if (pos.size() == 1) {\n                ans.emplace_back(-1);\n                continue;\n            }\n\n            int idx = lower_bound(pos.begin(), pos.end(), q) - pos.begin();\n\n            if (idx == 0) {\n                int dist = pos[0] + n - pos.back();\n                ans.emplace_back(min(pos[1] - pos[0], dist));\n            } else if (idx == pos.size() - 1) {\n                int dist = pos[0] + n - pos.back();\n                ans.emplace_back(min(pos[idx] - pos[idx - 1], dist));\n            } else {\n                ans.emplace_back(min(pos[idx] - pos[idx - 1], pos[idx + 1] - pos[idx]));\n            }\n        }\n\n        return ans;\n    }\n};","author":"不到2000非好汉","submissionId":"611250431"},[]]},{"1908":[{"id":"1908","fileName":"611250293.txt","sourceCode":"class Solution {\n   public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        Map<Integer, List<Integer>> mp = new HashMap<>();\n        for(int i = 0; i < n; i++) {\n            List<Integer> tmp = mp.getOrDefault(nums[i],new ArrayList<Integer>());\n            tmp.add(i);\n            mp.put(nums[i],tmp);\n        }\n        Map<Integer,Integer> ans = new HashMap<>();\n        for(Integer key: mp.keySet()) {\n            List<Integer> tmp = mp.get(key);\n            int len = tmp.size();\n            if(len == 1) {\n                ans.put(tmp.get(0),-1);\n                continue;\n            }\n            tmp.add(tmp.get(0) + n);\n            for(int i = 0;i <= len; i++) {\n                int pos = tmp.get(i);\n                int res = ans.getOrDefault(pos, 0x3fffff);\n                if(i - 1 >= 0) res= Math.min(res, pos - tmp.get(i - 1));\n                if(i + 1 <= len) res= Math.min(res, tmp.get(i + 1) - pos);\n                if(i == len &&res < ans.get(pos - n)) ans.put(pos - n,res);\n                else ans.put(pos,res);\n            }\n        }\n        List<Integer> ret = new ArrayList<>();\n        for(int i= 0;i<m;i++) {\n            ret.add(ans.get(queries[i]));\n        }\n        return ret;\n    }\n}","author":"文明键盘侠","submissionId":"611250293"},[]]},{"1909":[{"id":"1909","fileName":"611250488.txt","sourceCode":"class Solution {\n    public:\n        vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n            int n = nums.size();\n            int m = queries.size();\n            unordered_map<int,vector<int>> mp;\n            for (int i = 0; i < n; i++)\n            {\n                mp[nums[i]].push_back(i);\n            }\n            vector<int> res(m,-1);\n            for (int i = 0; i < m; i++)\n            {\n                int que = nums[queries[i]];\n                int sz = mp[que].size();\n                if(sz==1)res[i] = -1;\n                else{\n                    auto j = lower_bound(mp[que].begin(),mp[que].end(),queries[i]);\n                    int a = distance(mp[que].begin(),j);\n                    int b = a-1;\n                    if(b<0) b = sz-1;\n                    int c = a+1;\n                    if(c>=sz) c = 0;\n                    cout<<a<<b<<c;\n                    int m1 = min(abs(mp[que][a]-mp[que][b]),min(n-mp[que][a]+mp[que][b],n+mp[que][a]-mp[que][b]));\n                    int m2 = min(abs(mp[que][a]-mp[que][c]),min(n-mp[que][a]+mp[que][c],n+mp[que][a]-mp[que][c]));\n                    res[i] = min(m1,m2);\n                }\n            }\n            return res;\n            \n        }\n    };","author":"AwakeFantasy","submissionId":"611250488"},[]]},{"1910":[{"id":"1910","fileName":"611249935.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n\n        hash = defaultdict(list)\n        n = len(nums)\n        loc = [0] * n\n\n        for i, x in enumerate(nums):\n            hash[x].append(i)\n            loc[i] = len(hash[x]) - 1\n\n        # print(hash)\n        for i, x in enumerate(queries):\n            j = nums[x]\n            ind = loc[x]\n            if len(hash[j]) == 1:\n                queries[i] = -1\n            else:\n                tmp = n\n                l = hash[j]\n                # print(hash[j], ind, tmp)\n                # if ind - 1 >= 0:\n                #     tmp = min(l[ind] - l[ind - 1], tmp, n - l[ind] + l[ind - 1])\n                #     print(tmp, l[ind] - l[ind - 1], n - l[ind] + l[ind - 1])\n                # if ind + 1 < len(l):\n                #     tmp = min(l[ind + 1] - l[ind], tmp, n - l[ind + 1] + l[ind])\n                #     print(tmp, l[ind + 1] - l[ind], n - l[ind + 1] - l[ind])\n\n                tmp = min(abs(l[ind] - l[ind - 1]), n - abs(l[ind] - l[ind - 1]), abs(l[(ind + 1)%len(l)] - l[ind]), n - abs(l[(ind + 1)%len(l)] - l[ind]))\n                \n                queries[i] = tmp\n\n        return queries\n                \n                \n        ","author":"盛骓","submissionId":"611249935"},[]]},{"1911":[{"id":"1911","fileName":"611251056.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], q: List[int]) -> List[int]:\n        nums+=nums\n        st=defaultdict(list)\n        for index,e in enumerate(nums):\n            st[e].append(index)\n        res=[]\n        for i in q:\n            e=nums[i]\n            if len(st[e])==2:\n                res.append(-1)\n                continue\n            temp=bisect_right(st[e],i)-1\n            res.append(min(abs(st[e][temp+len(st[e])//2]-st[e][temp-1+len(st[e])//2]),abs(st[e][(temp+1)]-st[e][temp])))\n        return res","author":"audience","submissionId":"611251056"},[]]},{"1912":[{"id":"1912","fileName":"611250790.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int xMax = ranges::max(nums);\n        vector<vector<int>>arr(xMax+1);\n        vector<int> ans;\n        for (int i = 0; i < nums.size(); i++) {\n            arr[nums[i]].push_back(i);\n        }\n        for (int i = 0; i < queries.size(); i++) {\n            int index = lower_bound(arr[nums[queries[i]]].begin(), arr[nums[queries[i]]].end(), queries[i])-arr[nums[queries[i]]].begin();\n            int tmp_ans=-1;\n            if (index!=0) {\n                int dis=arr[nums[queries[i]]][index]-arr[nums[queries[i]]][index-1];\n                tmp_ans=min(dis,(int)nums.size()-dis);\n            }else if (arr[nums[queries[i]]].size()>1){\n                int dis=arr[nums[queries[i]]].back()-arr[nums[queries[i]]][index];\n                tmp_ans=min(dis,(int)nums.size()-dis);\n            }\n            if (index!=arr[nums[queries[i]]].size()-1) {\n                int dis=arr[nums[queries[i]]][index+1]-arr[nums[queries[i]]][index];\n                dis=min(dis,(int)nums.size()-dis);\n                if (tmp_ans!=-1) {\n                    tmp_ans=min(tmp_ans,dis);\n                }else {\n                    tmp_ans=dis;\n                }\n            }else if (arr[nums[queries[i]]].size()>1){\n                int dis=arr[nums[queries[i]]].back()-arr[nums[queries[i]]].front();\n                dis=min(dis,(int)nums.size()-dis);\n                if (tmp_ans!=-1) {\n                    tmp_ans=min(tmp_ans,dis);\n                }else {\n                    tmp_ans=dis;\n                }\n            }\n            \n            ans.push_back(tmp_ans);\n        }\n        return ans;\n    }\n};\n","author":"摆渡人","submissionId":"611250790"},[]]},{"1913":[{"id":"1913","fileName":"611250775.txt","sourceCode":"\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        // 计算0~10的6次方每个数的位置\n        HashMap<Integer, TreeSet<Integer>> val2idxs = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            val2idxs.putIfAbsent(nums[i], new TreeSet<>());\n            val2idxs.get(nums[i]).add(i);\n        }\n        List<Integer> ret = new ArrayList<>(queries.length);\n        for (int i = 0; i < queries.length; i++) {\n            Integer tmp = Integer.MAX_VALUE;\n            Integer tmp1 = val2idxs.get(nums[queries[i]]).higher(queries[i]);\n            if (tmp1 == null) {\n                tmp1 = val2idxs.get(nums[queries[i]]).first();\n            }\n            Integer tmp2 = val2idxs.get(nums[queries[i]]).lower(queries[i]);\n            if (tmp2 == null) {\n                tmp2 = val2idxs.get(nums[queries[i]]).last();\n            }\n            if (tmp1 != queries[i]) {\n                tmp = Math.min(tmp, Math.min((queries[i] - tmp1 + nums.length) % nums.length, (tmp1 - queries[i] + nums.length) % nums.length));\n            }\n            if (tmp2 != queries[i]) {\n                tmp = Math.min(tmp, Math.min((queries[i] - tmp2 + nums.length) % nums.length, (tmp2 - queries[i] + nums.length) % nums.length));\n            }\n            ret.add(tmp == Integer.MAX_VALUE ? -1 : tmp);\n        }\n        return ret;\n    }\n}","author":"抽烟喝酒打麻将","submissionId":"611250775"},[]]},{"1914":[{"id":"1914","fileName":"611251306.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        pos = defaultdict(list)\n        n = len(nums)\n        nums *= 2\n        for i,num in enumerate(nums):\n            pos[num].append(i)\n        res = []\n        for i in queries:\n            num = nums[i]\n            if len(pos[num]) == 2:\n                res.append(-1)\n                continue\n\n            p = bisect_left(pos[num],i)\n\n            d = inf\n            if p + 1 < len(pos[num]):\n                if pos[num][p+1] - pos[num][p] < d:\n                    d = pos[num][p+1] - pos[num][p]\n\n            if p - 1 >= 0:\n                if pos[num][p] - pos[num][p-1] < d:\n                    d = pos[num][p] - pos[num][p-1]\n\n            p += len(pos[num]) // 2\n            if p + 1 < len(pos[num]):\n                if pos[num][p+1] - pos[num][p] < d:\n                    d = pos[num][p+1] - pos[num][p]\n\n            if p - 1 >= 0:\n                if pos[num][p] - pos[num][p-1] < d:\n                    d = pos[num][p] - pos[num][p-1]\n                    \n            # print(pos[num],p)\n            res.append(d)\n\n        return res\n        ","author":"mipha","submissionId":"611251306"},[]]},{"1915":[{"id":"1915","fileName":"611251494.txt","sourceCode":"const int N = 1e5 + 5;\nclass Solution {\npublic:\n    int cal(vector<int> &v, int i){\n        if(v.size() == 2){\n            return -1;\n        }\n        int pos = lower_bound(v.begin(), v.end(), i) - v.begin();\n        int ans = N;\n        if(pos){\n            ans = i - v[pos - 1];\n        }\n        if(pos + 1 != v.size()){\n            ans = min(ans, v[pos + 1] - i);\n        }\n        return ans;\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> v[N], t;\n        for(auto e : nums){\n            t.push_back(e);\n        }\n        sort(t.begin(), t.end());\n        t.erase(unique(t.begin(), t.end()), t.end());\n        for(int i = 0; i < n; i++){\n            nums[i] = lower_bound(t.begin(), t.end(), nums[i]) - t.begin() + 1;\n        }\n        for(int i = 0; i < n; i++){\n            v[nums[i]].push_back(i);\n        }\n        for(int i = n; i < n * 2; i++){\n            v[nums[i - n]].push_back(i);\n        }\n        vector<int> rs;\n        for(auto e : queries){\n            int ans1 = cal(v[nums[e]], e);\n            int ans2 = cal(v[nums[e]], e + n);\n            int ans = -1;\n            if(ans1 != -1){\n                ans = ans1;\n            }\n            if(ans2 != -1){\n                ans = (ans == -1) ? ans2 : min(ans, ans2);\n            }\n            rs.push_back(ans);\n        }\n        return rs;\n    }\n};","author":"SuperDY","submissionId":"611251494"},[{"id":"1922","similarity":0.9201520912547528,"totOverlap":242,"longestOverlap":56},{"id":"1954","similarity":0.8849206349206349,"totOverlap":223,"longestOverlap":50}]],"1922":[{"id":"1922","fileName":"611252704.txt","sourceCode":"const int N = 1e5 + 5;\nclass Solution {\npublic:\n    vector<int> v[N], t;\n    int cal(vector<int>& v, int i) {\n        if (v.size() == 2) {\n            return -1;\n        }\n        int pos = lower_bound(v.begin(), v.end(), i) - v.begin();\n        int ans = N;\n        if (pos) {\n            ans = i - v[pos - 1];\n        }\n        if (pos + 1 != v.size()) {\n            ans = min(ans, v[pos + 1] - i);\n        }\n        return ans;\n    }\n    void init(vector<int>& nums) {\n         for (auto e : nums) {\n            t.push_back(e);\n        }\n        sort(t.begin(), t.end());\n        t.erase(unique(t.begin(), t.end()), t.end());\n    }\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        init(nums);\n        for (int i = 0; i < n; i++) {\n            nums[i] = lower_bound(t.begin(), t.end(), nums[i]) - t.begin() + 1;\n        }\n        for (int i = 0; i < n; i++) {\n            v[nums[i]].push_back(i);\n        }\n        for (int i = n; i < n * 2; i++) {\n            v[nums[i - n]].push_back(i);\n        }\n        vector<int> rs;\n        for (auto e : queries) {\n            int ans1 = cal(v[nums[e]], e);\n            int ans2 = cal(v[nums[e]], e + n);\n            int ans = -1;\n            if (ans1 != -1) {\n                ans = ans1;\n            }\n            if (ans2 != -1) {\n                ans = (ans == -1) ? ans2 : min(ans, ans2);\n            }\n            rs.push_back(ans);\n        }\n        return rs;\n    }\n};\n","author":"很晚才睡","submissionId":"611252704"},[{"id":"1915","similarity":0.9201520912547528,"totOverlap":242,"longestOverlap":56}]],"1954":[{"id":"1954","fileName":"611258188.txt","sourceCode":"class Solution {\n    int aaa(vector<int>& v, int i) {\n        if (v.size() == 2) {\n            return -1;\n        }\n        int pos = lower_bound(v.begin(), v.end(), i) - v.begin();\n        int ans = 100005;\n        if (pos) {\n            ans = i - v[pos - 1];\n        }\n        if (pos + 1 != v.size()) {\n            ans = min(ans, v[pos + 1] - i);\n        }\n        return ans;\n    }\npublic:\n\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> v[100005], t;\n        for (auto e : nums) {\n            t.push_back(e);\n        }\n        sort(t.begin(), t.end());\n        t.erase(unique(t.begin(), t.end()), t.end());\n        for (int i = 0; i < n; i++) {\n            nums[i] = lower_bound(t.begin(), t.end(), nums[i]) - t.begin() + 1;\n        }\n        for (int i = 0; i < n; i++) {\n            v[nums[i]].push_back(i);\n        }\n        for (int i = n; i < n * 2; i++) {\n            v[nums[i - n]].push_back(i);\n        }\n        vector<int> res;\n        for (auto &e : queries) {\n            int ans2 = aaa(v[nums[e]], e + n);\n            int ans1 = aaa(v[nums[e]], e);\n            int ans = -1;\n            if (ans1 != -1) {\n                ans = ans1;\n            }\n            if (ans2 != -1) {\n                ans = (ans == -1) ? ans2 : min(ans, ans2);\n            }\n            res.push_back(ans);\n        }\n        return res;\n    }\n};\n","author":"TA很酷","submissionId":"611258188"},[{"id":"1915","similarity":0.8849206349206349,"totOverlap":223,"longestOverlap":50}]]},{"1916":[{"id":"1916","fileName":"611251355.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        Map<Integer,Integer> map = new HashMap<>();\n        Map<Integer,Integer> leftMap = new HashMap<>();\n        Map<Integer,Integer> rightMap = new HashMap<>();\n        int[] d1 = new int[nums.length];\n        int[] d2 = new int[nums.length];\n        Arrays.fill(d1,Integer.MAX_VALUE);\n        Arrays.fill(d2,Integer.MAX_VALUE);\n        for(int i = 0;i < nums.length;i++){\n            if(!leftMap.containsKey(nums[i])){\n                leftMap.put(nums[i],i);\n                d1[i] = -1;\n            }\n            else\n            {\n                int leftLastPos = leftMap.get(nums[i]);\n                d1[i] = Math.min(d1[i],(i - leftLastPos + nums.length)%nums.length);\n                leftMap.put(nums[i],i);\n            }\n        }\n        for(int i = 0;i < nums.length;i++){\n            if(!leftMap.containsKey(nums[i])){\n                leftMap.put(nums[i],i);\n                d1[i] = -1;\n            }\n            else\n            {\n                int leftLastPos = leftMap.get(nums[i]);\n                if(d1[i] == -1 && (i - leftLastPos + nums.length) % nums.length != 0)\n                {\n                    d1[i] = (i - leftLastPos + nums.length) % nums.length;\n                }\n                leftMap.put(nums[i],i);\n            }\n        }\n\n        for(int i = nums.length - 1;i >= 0;i--){\n            if(!rightMap.containsKey(nums[i])){\n                rightMap.put(nums[i],i);\n                d2[i] = -1;\n            }\n            else\n            {\n                int rightLastPos = rightMap.get(nums[i]);\n                d2[i] = (rightLastPos - i + nums.length) % nums.length;\n                rightMap.put(nums[i],i);\n            }\n        }\n\n        for(int i = nums.length - 1;i >= 0;i--){\n            if(!rightMap.containsKey(nums[i])){\n                rightMap.put(nums[i],i);\n                d2[i] = -1;\n            }\n            else\n            {\n                int rightLastPos = rightMap.get(nums[i]);\n                if(d2[i] == -1 && (rightLastPos - i + nums.length) % nums.length != 0)\n                {\n                    d2[i] = (rightLastPos - i + nums.length) % nums.length;\n                }\n                rightMap.put(nums[i],i);\n            }\n        }\n\n        List<Integer> res = new ArrayList<>();\n        for(int i = 0;i < queries.length;i++){\n            res.add(Math.min(d1[queries[i]],d2[queries[i]]));\n        }\n        return res;\n\n    }\n}","author":"香菜是魔鬼","submissionId":"611251355"},[]]},{"1919":[{"id":"1919","fileName":"611250158.txt","sourceCode":"class Solution {\npublic:\n  vector<int> solveQueries(vector<int> &nums, vector<int> &queries) {\n    // 用两个map分别记录: value对应的元素下标vector，和对于某一个value当前处理到的vector中的index\n    // 查询的时候就是index+1和index-1的最小值，同时考虑是一个循环数组\n    unordered_map<int, vector<int>> indexes;\n    vector<int> points(nums.size(), -1);\n    for (int i = 0; i < nums.size(); ++ i) {\n      int n = nums[i];\n      if (indexes.find(n) == indexes.end()) {\n        indexes[n] = {};\n      }\n      indexes[n].push_back(i);\n      points[i] = indexes[n].size() - 1;\n    }\n\n    vector<int> ans;\n    for (int i = 0; i < queries.size(); ++ i) {\n      int n = nums[queries[i]];\n      auto& vec = indexes[n];\n      if (vec.size() == 1) {\n        ans.push_back(-1);\n        continue;\n      }\n      int p = points[queries[i]];\n      int current_idx = vec[p];\n      int next_dist = (p + 1 == vec.size() ? vec[0] + nums.size() - current_idx : vec[p + 1] - current_idx);\n      int pre_dist = (p - 1 < 0 ? current_idx + nums.size() - vec[vec.size() - 1] : current_idx - vec[p - 1]);\n      ans.push_back(min(next_dist, pre_dist));\n    }\n\n    return ans;\n  }\n};","author":"gaojingm","submissionId":"611250158"},[]]},{"1920":[{"id":"1920","fileName":"611251544.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> pos;\n        int n = nums.size();\n        for(int i = 0; i < n; i++){\n            int x = nums[i];\n            pos[x].push_back(i);\n        }\n        vector<int> ans;\n        for(int&q: queries){ // q就是我要找的这个数的下标\n            auto& p = pos[nums[q]];\n            if(p.size() == 1){\n                ans.push_back(-1);\n                continue;\n            }\n            // 找到>=q的第一个位置 就是它自己在p中的位置\n            int idx = lower_bound(p.begin(), p.end(), q) - p.begin();\n            int dis = INT_MAX;\n            if(idx + 1 < p.size()) dis = min(p[idx + 1] - q, n - p[idx + 1] + q);\n            else dis = min(q - p[0], n - q + p[0]);\n            if(idx - 1 >= 0) dis = min({dis, q - p[idx - 1], n - q + p[idx - 1]});\n            else dis = min({dis, p[p.size() - 1] - q, n - p[p.size() - 1] + q});\n            ans.push_back(dis);\n        }\n        return ans;\n    }\n};","author":"a碟","submissionId":"611251544"},[]]},{"1921":[{"id":"1921","fileName":"611252098.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = defaultdict(list)\n        ans = []\n        for i,j in enumerate(nums):\n            d[j].append(i)\n        for i in queries:\n            num = nums[i]\n            if len(d[num]) == 1:\n                ans.append(-1)\n            elif len(d[num]) == 2:\n                if d[num][0] == i:\n                    ans.append(min(d[num][1]-i,len(nums)-d[num][1]+i))\n                else:\n                    ans.append(min(i-d[num][0],len(nums)-i+d[num][0]))\n            else:\n                l = bisect_left(d[num],i)\n                r = l+1\n                l -=1\n                \n                if l==-1:\n                    ans.append(min(d[num][r]-i,len(nums)-d[num][-1]+i))\n                elif r==len(d[num]):\n                    ans.append(min(len(nums)-i+d[num][0],i-d[num][l]))\n                else:\n                    ans.append(min(i-d[num][l],d[num][r]-i))\n        return ans\n            \n\n        ","author":"(￣▼￣)","submissionId":"611252098"},[]]},{"1923":[{"id":"1923","fileName":"611253134.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        vector<int> ret;\n        map<int, vector<int>> cache;\n        map<int, int> getpos;\n        for(int i=0;i<n;i++){\n            cache[nums[i]].push_back(i);\n            getpos[i] = cache[nums[i]].size()-1;\n        }\n        for(auto& q : queries){\n            ret.push_back(cal(n, nums[q], q, cache, getpos));\n        }\n        return ret;\n    }\n\n    int cal(int n, int x, int pos, map<int, vector<int>>& cache, map<int, int>& getpos){\n        int cpos = getpos[pos];\n        if(cache[x].size() == 1){\n            return -1;\n        }\n        int ldist = cpos == 0 ? pos + n - cache[x].back() : pos - cache[x][cpos-1];\n        int rdist = cpos == cache[x].size()-1 ? n - pos + cache[x].front() : cache[x][cpos+1] - pos;\n        return min(ldist, rdist);\n    }\n};","author":"A-SOUL_Official","submissionId":"611253134"},[]]},{"1924":[{"id":"1924","fileName":"611253308.txt","sourceCode":"import bisect\n\nclass Solution(object):\n    def solveQueries(self, nums, queries):\n        from collections import defaultdict\n        n = len(nums)\n        hash_map = defaultdict(list)\n        hash_map_extended = defaultdict(list)\n\n        # 预处理，记录每个元素的所有出现位置，并生成扩展列表\n        for idx, num in enumerate(nums):\n            hash_map[num].append(idx)\n\n        for num in hash_map:\n            positions = hash_map[num]\n            extended = []\n            for x in positions:\n                extended.extend([x - n, x, x + n])\n            extended_sorted = sorted(extended)\n            hash_map_extended[num] = extended_sorted\n\n        answer = []\n        for q in queries:\n            v = nums[q]\n            extended_list = hash_map_extended.get(v, [])\n            if not extended_list:\n                answer.append(-1)\n                continue\n\n            idx = bisect.bisect_left(extended_list, q)\n            candidates = set()\n            len_el = len(extended_list)\n\n            # 收集插入点附近及循环相邻的候选元素\n            for di in [-1, 0, 1]:\n                current_idx = idx + di\n                current_idx %= len_el\n                candidates.add(extended_list[current_idx])\n\n            min_dist = float('inf')\n            for x in candidates:\n                original_x = x % n\n                if original_x == q:\n                    continue\n                d = abs(original_x - q)\n                curr_dist = min(d, n - d)\n                if curr_dist < min_dist:\n                    min_dist = curr_dist\n\n            answer.append(min_dist if min_dist != float('inf') else -1)\n\n        return answer","author":"ۣۖิۣۖิۣۣۖۖ⃟刘","submissionId":"611253308"},[]]},{"1925":[{"id":"1925","fileName":"611253330.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        map<int,vector<int>> mp;\n        for(int i=0;i<n;i++) {\n            mp[nums[i]].push_back(i);\n        }\n        vector<int>ans;\n        for(int q:queries) {\n            int val = nums[q];\n            //cout <<\"q:\" << q <<\",val:\" <<val <<endl;\n            //找其pre和next\n            const vector<int>& vec = mp[val];\n            auto iter = lower_bound(vec.begin(),vec.end(),q); //找到0的下标\n            int tmp = INT_MAX;\n            auto iter1 = iter;\n            auto iter2 = iter;\n            // //cout <<\"*iter:\" << *iter <<endl;\n            if (iter != vec.begin()) {\n                iter1--;\n                //cout <<\"*iter:\" << *iter <<\",*iter1:\" <<*iter1 <<endl;\n                if (iter1 != iter) {\n                    int dis = min(*iter - *iter1, n- *iter + *iter1);\n                    tmp = min(tmp, dis);    \n                }\n            }\n            iter1 = iter;\n            if (iter == vec.begin()) {\n                iter1 = vec.end();\n                iter1--;\n                if (iter1 != iter) {\n                    int dis = min(*iter1 - *iter, n- *iter1 + *iter);\n                    tmp = min(tmp, dis);    \n                }\n            }\n            iter2 = iter;\n            iter2++;\n            if (iter2 != vec.end()) {\n                //cout <<\"*iter:\" << *iter <<\",*iter2:\" <<*iter2 <<endl;\n                if (iter2 != iter) {\n                    int dis = min(*iter2 - *iter, n- *iter2 + *iter);\n                    tmp = min(tmp, dis);    \n                }\n            }\n            \n            if (iter2 == vec.end()) {\n                iter2 = vec.begin();\n                if (iter2 != iter) {\n                     int dis = min(*iter - *iter2, n- *iter + *iter2);\n                     tmp = min(tmp, dis);\n                }\n            }\n            if (tmp == INT_MAX) {\n                ans.push_back(-1);\n            } else {\n                ans.push_back(tmp);\n            }\n        }\n        return ans;\n    }\n};","author":"faustrun","submissionId":"611253330"},[]]},{"1926":[{"id":"1926","fileName":"611251665.txt","sourceCode":"class Solution {\npublic:\n int l[1000006],r[1000006],lans[300005],rans[300005];\n    vector<int> solveQueries(vector<int>& a, vector<int>& q) {\n        vector<int>b=a;\n        a.insert(a.end(),b.begin(),b.end());\n        a.insert(a.end(),b.begin(),b.end());\n       \n        int n=a.size();\n        for(int i=0;i<n;i++)\n            cout<<a[i]<<\" \";\n        cout<<endl;\n        for(int i=0;i<n;i++){\n            lans[i+1]=l[a[i]];\n            l[a[i]]=i+1;\n        }\n        for(int i=n-1;i>=0;i--){\n            rans[i+1]=r[a[i]];\n            r[a[i]]=i+1;\n        }\n        int m=q.size();\n        vector<int>ans;\n        for(int i=0;i<m;i++){\n            q[i]+=n/3+1;\n            //cout<<lans[q[i]]<<\" \"<<rans[q[i]]<<endl;\n            int res=min(rans[q[i]]-q[i],q[i]-lans[q[i]]);\n            if(res>=n/3)\n                ans.push_back(-1);\n            else\n                ans.push_back(res);\n        }\n        return ans;\n    }\n};","author":"仲舟","submissionId":"611251665"},[]]},{"1928":[{"id":"1928","fileName":"611253961.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m =queries.size();\n        vector<int> pre(n, INT_MAX);\n\n        map<int, vector<int>> mp;//{首位，上一位， 此位}\n        for(int i = 0; i < n; i++){\n            if(mp.find(nums[i])==mp.end()){\n                mp[nums[i]] = {i, i, i};\n            }else{\n                int lstindex = mp[nums[i]][2];\n                pre[lstindex] = i-lstindex;\n                if(lstindex != mp[nums[i]][1])\n                pre[lstindex] = min(pre[lstindex], lstindex - mp[nums[i]][1]);\n                mp[nums[i]][1] = mp[nums[i]][2];\n                mp[nums[i]][2] = i;\n            }\n        }\n        for (const auto& entry : mp) {\n            auto& value = entry.second;\n            if(value[1] == value[2])pre[value[1]] = -1;\n            else{\n                pre[value[2]] = min(value[2]-value[1], n-value[2]+value[0]);\n                pre[value[0]] = min(pre[value[0]], n-value[2]+value[0]);\n                cout<<value[0]<<value[1]<<value[2]<<\"   \"<<pre[value[0]]<<\"   \"<<pre[value[2]]<<endl;\n            } \n        }\n        vector<int> ans(m,-1);\n        for(int i = 0; i<m; i++){\n            ans[i] = pre[queries[i]];\n        }\n        return ans;\n    }\n};","author":"Dumbo","submissionId":"611253961"},[]]},{"1929":[{"id":"1929","fileName":"611253792.txt","sourceCode":"class Solution {\nint N;\nint fun(vector<int> &V, int tgt) {\n    if (V.size() == 1) return -1;\n    int l = 0, r = V.size() - 1;\n    while (l < r) {\n        int mid = (l + r) / 2;\n        if (V[mid] == tgt) {\n            l = mid;\n            break;\n        }\n        else if (V[mid] > tgt) r = mid - 1;\n        else l = mid + 1;\n    }\n    int before, after;\n    if (l - 1 < 0) {\n        before = tgt + N - V.back();\n    }\n    else before = abs(tgt - V[l - 1]);\n    if (l + 1 >= V.size()) {\n        after = abs(tgt - N) + V[0];\n    }\n    else after = abs(tgt - V[l + 1]);\n    \n    return min(before, after);\n}\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n       // 哈希map + 二分\n        N = nums.size();\n        unordered_map<int, vector<int>> M;\n        for (int i = 0; i < nums.size(); ++i) {\n            M[nums[i]].push_back(i);\n        }\n        for (auto &q : queries) {\n            q = fun(M[nums[q]], q);\n        }\n        return queries;\n    }\n};","author":"","submissionId":"611253792"},[]]},{"1930":[{"id":"1930","fileName":"611254074.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        cnt={}\n        n=len(nums)\n        for i in range(0,n):\n            if nums[i] in cnt:\n                cnt[nums[i]].append(i)\n            else:\n                cnt[nums[i]]=[i]\n        answer={}\n        for key,value in cnt.items():\n            a=len(value)\n            if a>=2:\n                for i in range(0,a):\n                    answer[value[i]]=min((value[i]-value[i-1])%n,(value[(i+1)%a]-value[i])%n)\n        for i in range(0,len(queries)):\n            if queries[i] in answer:\n                queries[i]=answer[queries[i]]\n            else:\n                queries[i]=-1\n        return queries","author":"94664","submissionId":"611254074"},[]]},{"1931":[{"id":"1931","fileName":"611254288.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,set<int>>mp;\n        vector<int>ans;\n        int n=nums.size();\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]].insert(i);\n        }\n\n        for(auto i:queries){\n            int tar = nums[i];\n            if(mp[tar].size()==1){\n                ans.push_back(-1);\n            }\n            else{\n                int tmp=0x3f3f3f3f;\n                auto it = mp[tar].lower_bound(i);\n                auto it2=it;\n                if(it!= mp[tar].begin()){\n                    // cout<<i<<\" \"<<*prev(it)<<endl;\n                    // cout<<i-*prev(it)<<\" \"<<n+*prev(it)-i<<endl;\n                    // tmp = min(i-*prev(it),n+*prev(it)-i);\n                    it2 = prev(it);\n                    tmp = min({tmp,i-*it2,n+*it2-i});\n                    // cout<<\"_-- \"<<n-*it2+i<<endl;\n                }\n                else{\n                    it2 = prev(mp[tar].end());\n                    tmp = min({tmp,*it2-i,n-*it2+i});\n                }\n                \n                // cout<<tmp<<endl;\n                if(it!=mp[tar].end()){\n                    it2 = next(it);\n                    if(it2 == mp[tar].end()){\n                        it2 = mp[tar].begin();\n                        tmp = min({tmp,i-*it2,n+*it2-i});\n                    }\n                    else{\n                        tmp = min({tmp,*it2-i,n-*it2+i});\n                    }\n                    \n                }\n                // cout<<tmp<<endl;\n                assert(tmp!=0x3f3f3f3f);\n                ans.push_back(tmp);\n            }\n        }\n        return ans;\n\n    }\n};","author":"光球层上的黑子","submissionId":"611254288"},[]]},{"1932":[{"id":"1932","fileName":"611253853.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n    n, m := len(nums), len(queries)\n    n1 := 2*n\n    nums1 := make([]int, n1)\n    for i := 0; i < n; i++ { nums1[i], nums1[i+n] = nums[i], nums[i] }\n    f, g := make([]int, n1), make([]int, n1)\n    for i := 0; i < n1; i++ {\n        f[i] = -2*n1\n        g[i] = 2*n1\n    }\n    for i, preMap := 0, map[int]int{}; i < n1; i++ {\n        if _, ok := preMap[nums1[i]]; ok { f[i] = preMap[nums1[i]] }\n        preMap[nums1[i]] = i\n    }\n    for i, preMap := n1 - 1, map[int]int{}; i >= 0; i-- {\n        if _, ok := preMap[nums1[i]]; ok { g[i] = preMap[nums1[i]] }\n        preMap[nums1[i]] = i\n    }\n    // fmt.Println(f)\n    // fmt.Println(g)\n    rs := make([]int, m)\n    for j := 0; j < m; j++ {\n        i := queries[j]\n        rs[j] = n\n        rs[j] = min(min(i-f[i], i+n-f[i+n]), min(g[i]-i, g[i+n]-i-n))\n        if rs[j] >= n { rs[j] = -1 }\n    }\n    return rs    \n}","author":"我啊","submissionId":"611253853"},[]]},{"1933":[{"id":"1933","fileName":"611254414.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        \n        queries_by_num = defaultdict(list)\n        for query_idx, num_idx in enumerate(queries):\n            num = nums[num_idx]\n            queries_by_num[num].append((num_idx, query_idx))\n        \n        \n        pos_by_num = defaultdict(list)\n        for i, num in enumerate(nums):\n            if num in queries_by_num:\n                pos_by_num[num].append(i)\n        \n        ans = [-1] * len(queries)\n        \n        \n        for num, positions in pos_by_num.items():\n            if len(positions) < 2:\n               \n                continue\n           \n            for pos, query_idx in queries_by_num[num]:\n               \n                i = bisect.bisect_left(positions, pos)\n              \n                if i > 0:\n                    left_dist = pos - positions[i-1]\n                else:\n                    left_dist = pos + n - positions[-1]\n               \n                if i < len(positions) - 1:\n                    right_dist = positions[i+1] - pos\n                else:\n                    right_dist = positions[0] + n - pos\n               \n                ans[query_idx] = min(left_dist, right_dist)\n        return ans\n","author":"0907","submissionId":"611254414"},[]]},{"1935":[{"id":"1935","fileName":"611254058.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> res;\n        unordered_map<int, int> hash;unordered_map<int, int> hash1;\n        int n = nums.size(), m = queries.size();\n        vector<int> dis(n, INT_MAX);\n        for (int i = 1; i < n; i++) {\n            if (nums[0] == nums[i]) dis[i] = min(i, min(dis[i], n - i));\n            if (hash[nums[i]]) dis[i] = min({dis[i], i - hash[nums[i]], hash[-nums[i]] + n - i});\n            hash[nums[i]] = i;\n            if (hash[-nums[i]]);\n            else hash[-nums[i]] = i;\n            //cout << hash[-3];\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            if (hash1[nums[i]]) dis[i] = min(dis[i], min(hash1[nums[i]] - i, i + n - hash1[-nums[i]]));\n            hash1[nums[i]] = i;\n            if (hash1[-nums[i]]);\n            else hash1[-nums[i]] = i;\n        }\n        for (int &num : dis) if (num == INT_MAX) num = -1;\n        for (int i = 0; i < m; i++) {\n            res.push_back(dis[queries[i]]);\n        }\n        return res;\n    }\n};","author":"Frakkland","submissionId":"611254058"},[]]},{"1936":[{"id":"1936","fileName":"611254955.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        /*int n = queries.length;\n        int m = nums.length;\n        List<Integer> ans = new ArrayList<>();\n        Map<Integer,List<Integer>> map = new HashMap<>();\n        for(int i=0;i<m;i++){\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i); \n        }\n        \n        for(int i=0;i<n;i++){\n            int index = queries[i];\n            List<Integer> l = map.get(nums[index]);\n            if(l.size()==1){\n                ans.add(-1);        \n            }else{\n                int min = Integer.MAX_VALUE;\n                for(int j = 0;j<l.size();j++){\n                    if(index==l.get(j))\n                        continue;\n                    int c = Math.min(Math.abs(l.get(j)-index),m-Math.abs(l.get(j)-index));\n                    min = Math.min(min,c);\n                }\n                ans.add(min);\n            }\n        }\n        return ans;*/\n        int m = nums.length;\n        List<Integer> ans = new ArrayList<>();\n        Map<Integer, List<Integer>> valueIndices = new HashMap<>();\n        Map<Integer, List<Integer>> extendedIndices = new HashMap<>();\n\n        // 预处理：记录每个值的下标并排序\n        for (int i = 0; i < m; i++) {\n            int num = nums[i];\n            valueIndices.computeIfAbsent(num, k -> new ArrayList<>()).add(i);\n        }\n\n        // 生成扩展列表（包含i和i+m）并排序\n        for (Map.Entry<Integer, List<Integer>> entry : valueIndices.entrySet()) {\n            List<Integer> indices = entry.getValue();\n            Collections.sort(indices);\n            List<Integer> extended = new ArrayList<>();\n            for (int idx : indices) {\n                extended.add(idx);\n                extended.add(idx + m);\n            }\n            Collections.sort(extended);\n            extendedIndices.put(entry.getKey(), extended);\n        }\n\n        // 处理每个查询\n        for (int queryIndex : queries) {\n            int value = nums[queryIndex];\n            List<Integer> indices = valueIndices.get(value);\n\n            if (indices.size() <= 1) {\n                ans.add(-1);\n                continue;\n            }\n\n            List<Integer> extended = extendedIndices.get(value);\n            int j = queryIndex;\n            int pos = Collections.binarySearch(extended, j);\n            if (pos < 0) pos = -(pos + 1);\n\n            // 候选位置：pos-1, pos, pos+1（处理循环边界）\n            List<Integer> candidates = new ArrayList<>();\n            candidates.add((pos - 1 + extended.size()) % extended.size());\n            candidates.add(pos % extended.size());\n            candidates.add((pos + 1) % extended.size());\n\n            int minDistance = Integer.MAX_VALUE;\n            for (int candidatePos : candidates) {\n                int candidate = extended.get(candidatePos) % m;\n                if (candidate != j) {\n                    int dist = Math.min(Math.abs(candidate - j), m - Math.abs(candidate - j));\n                    minDistance = Math.min(minDistance, dist);\n                }\n            }\n\n            ans.add(minDistance == Integer.MAX_VALUE ? -1 : minDistance);\n        }\n\n        return ans;\n    }\n}","author":"空白","submissionId":"611254955"},[]]},{"1938":[{"id":"1938","fileName":"611255264.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        tmp = {}\n        dis = [inf] * len(nums)\n        for i, num in enumerate(nums):\n            if num in tmp:\n                dis[i] = min(i-tmp[num][1], len(nums)-i+tmp[num][0])\n                dis[tmp[num][0]] = min(dis[tmp[num][0]], len(nums)-i+tmp[num][0])\n                dis[tmp[num][1]] = min(dis[tmp[num][1]], i-tmp[num][1])\n            else:\n                tmp[num] = [i, i]\n            tmp[num][1] = i\n\n        for i in range(len(dis)):\n            if dis[i] == inf:\n                dis[i] = -1\n        return [dis[i] for i in queries]","author":"君影草","submissionId":"611255264"},[]]},{"1940":[{"id":"1940","fileName":"611255135.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        pos_map = defaultdict(list)\n        for i, num in enumerate(nums):\n            pos_map[num].append(i)\n\n        result = []\n        for q in queries:\n            x = nums[q]\n            pos = pos_map[x]\n            # print(n,q,pos)\n            if len(pos) == 1:\n                result.append(-1)\n                continue\n            mi = inf\n            i = bisect_left(pos, q)\n            if i:\n                mi = min(mi, pos[i] - pos[i - 1])\n            if i < len(pos) - 1:\n                mi = min(mi, pos[i + 1] - pos[i])\n            mi = min(mi, pos[i] + n - pos[-1], n - pos[i] + pos[0])\n            result.append(mi)\n        return result\n","author":"终不负少年游","submissionId":"611255135"},[]]},{"1941":[{"id":"1941","fileName":"611255921.txt","sourceCode":"class Solution {\n    // 顺时针，逆时针都扫描两圈，之后枚举就好了\n    // 又要对下标...\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        int n = nums.length;\n        int[] distance = new int[n];\n        Map<Integer, Integer> index = new HashMap<>();\n        for (int i = 0; i < n * 2; i++) {\n            int j = i % n;\n            int p = index.getOrDefault(nums[j], -1);\n            if (p != -1 && p != j) {\n                int d = p > j ? n - p + j : j - p;\n                distance[j] = d;\n            }\n            index.put(nums[j], j);\n        }\n        index = new HashMap<>();\n        for (int i = n * 2 - 1; i >= 0; i--) {\n            int j = i % n;\n            int p = index.getOrDefault(nums[j], -1);\n            if (p != -1 && p != j) {\n                int d = p > j ? p - j : n - j + p;\n                distance[j] = Math.min(distance[j], d);\n            }\n            index.put(nums[j], j);\n        }\n        List<Integer> ans = new ArrayList<>(queries.length);\n        for (int q : queries) {\n            ans.addLast(distance[q] == 0 ? -1 : distance[q]);\n        }\n        return ans;\n    }\n}","author":"CNH5","submissionId":"611255921"},[]]},{"1942":[{"id":"1942","fileName":"611255705.txt","sourceCode":"class Solution {\npublic:\n    // vector<int> v[1000005];\n    int P[100005];\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size(),m=queries.size();\n        map<int,vector<int>> v;\n        for(int i=0;i<n;i++){\n            P[i]=v[nums[i]].size();\n            v[nums[i]].push_back(i);\n        }\n        vector<int> ret;\n        for(int i=0;i<m;i++){\n            int q=queries[i];\n            int x=nums[q];\n            int sz=v[x].size();\n            if(sz==1){\n                ret.push_back(-1);\n                continue;\n            }\n            int pos=P[q];\n            \n            int l=pos-1,r=pos+1,ans=0;\n            if(l<0) l=sz-1;\n            if(r==sz) r=0;\n            \n            int y=q-v[x][l];\n            if(y<0) y=y+n;\n            ans=min(y,n-y);\n            \n            y=v[x][r]-q;\n            if(y<0) y=y+n;\n            ans=min(ans,min(y,n-y));\n\n            ret.push_back(ans);\n        }\n        return ret;\n    }\n};","author":"Boring NapierhcR","submissionId":"611255705"},[]]},{"1943":[{"id":"1943","fileName":"611255980.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n=nums.size(),m=queries.size();\n        map<int,vector<int> > point;\n        for(int i=0;i<n;i++){\n            point[nums[i]].push_back(i);\n        }\n        vector<int> ans(m,-1);\n        for(int i=0;i<m;i++){\n            int a=queries[i];\n            auto it=point.find(nums[a]);\n            if(it==point.end()) continue;\n            int t=nums[a],len=point[t].size();\n            if(len==1) continue;\n            else if(a==point[t][0]){\n                int j=point[t][1],k=point[t][len-1];\n                if(ans[i]==-1) ans[i]=min(abs(j-a),n-abs(j-a));\n                else ans[i]=min(ans[i],min(abs(j-a),n-abs(j-a)));\n                ans[i]=min(ans[i],min(abs(k-a),n-abs(k-a)));\n            }else if(a==point[t][len-1]){\n                int j=point[t][0],k=point[t][len-2];\n                if(ans[i]==-1) ans[i]=min(abs(j-a),n-abs(j-a));\n                else ans[i]=min(ans[i],min(abs(j-a),n-abs(j-a)));\n                ans[i]=min(ans[i],min(abs(k-a),n-abs(k-a)));\n            }else{\n                auto x=lower_bound(point[t].begin(),point[t].end(),a)-1;\n                auto y=upper_bound(point[t].begin(),point[t].end(),a);\n                int j=point[t][x-point[t].begin()],k=point[t][y-point[t].begin()];\n                if(ans[i]==-1) ans[i]=min(abs(j-a),n-abs(j-a));\n                else ans[i]=min(ans[i],min(abs(j-a),n-abs(j-a)));\n                ans[i]=min(ans[i],min(abs(k-a),n-abs(k-a)));\n                //if(a==6) ans[0]=k;\n            }\n        }\n        return ans;\n    }\n};","author":"捕鼠王汤姆","submissionId":"611255980"},[]]},{"1944":[{"id":"1944","fileName":"611255924.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        length = len(nums)\n        f = defaultdict(list)\n\n        for i, v in enumerate(nums):\n            f[v].append(i)\n\n        ans = [0] * len(queries)\n        for idx, q in enumerate(queries):\n            x = nums[q]\n            n = len(f[x])\n            if n == 1:\n                ans[idx] = -1\n                continue\n            i = bisect.bisect_left(f[x], q)\n            left, right = abs(f[x][(i - 1) % n] - q), abs(f[x][(i + 1) % n] - q)\n            ans[idx] = min(min(left, length - left), min(right, length - right))\n\n        return ans","author":"老麻子8号","submissionId":"611255924"},[]]},{"1946":[{"id":"1946","fileName":"611256862.txt","sourceCode":"#include <bits/stdc++.h>  \nusing namespace std;  \n\n#define INF (int)(1e9)\n#define LL_INF (long long)(1e14) \n#define mod (int)(1e9 + 7) \n\nlong long gcd(long long a, long long b) { \n    return b > 0 ? gcd(b, a % b) : a; \n}\n\nlong long lcm(long long a, long long b) { \n    return a / gcd(a, b) * b; \n}\n\nvoid _mod(int &a, int b) {\n    if (a > b) a -= b;\n    return ;\n}\n\ndouble myPow(double x, int N) {\n    double ans = 1.0;\n    long long n = N;\n\n    if (n < 0) {\n        n = -n;\n        x = 1/x;\n\t}\n\n    while (n) {\n        if (n & 1) {\n            ans *= x;\n        }\n\n        x *= x;\n        n >>= 1;\n    }\n\n    return ans;\n}\n\n\nstruct Matrix {  \n    long long a[26][26];\n\t\n\tMatrix () {\n        memset(a, 0, sizeof(a));\n    }  \n\n    void init() {  \n        for (int i = 0; i < 26; i++) {  \n            a[i][i] = 1;  \n        }  \n        return;  \n    }  \n\n    Matrix operator*(const Matrix& b) const {  \n        Matrix res;  \n        for (int i = 0; i < 26; i++) {  \n            for (int j = 0; j < 26; j++) {  \n                for (int k = 0; k < 26; k++) {  \n                    res.a[i][j] = (res.a[i][j] + a[i][k] * b.a[k][j]) % mod;  \n                }  \n            }  \n        }  \n        return res;  \n    }  \n};\n\n\nMatrix qpow(Matrix a, int n) {\n    Matrix res; res.init();\n    while (n) {\n        if (n & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        n >>= 1;\n    }\n    return res;\n}\n\n\nint dijstra(vector<vector<int>>& grid) {\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n    int n = grid.size(), m = grid[0].size();\n    vector<vector<int>> vis(n, vector<int>(m, INT_MAX));\n    int dxy[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    vis[0][0] = 0;\n    q.push({0, 0});\n    while (!q.empty()) {\n        auto [v, idx] = q.top(); q.pop();\n        int x = idx/m, y = idx % m;\n\n        for (int i = 0; i < 4; i++) {\n            int xx = x + dxy[i][0];\n            int yy = y + dxy[i][1];\n\n            if (xx < 0 || yy >= m || xx >= n || yy < 0) continue;\n            int mx = max(vis[x][y], grid[xx][yy]) + 1 + (x + y) % 2;\n            if (vis[xx][yy] > mx) {\n                vis[xx][yy] = mx;\n                q.push({vis[xx][yy], xx*m + yy});\n            }\n        }\n    }\n\n    return vis[n - 1][m - 1];\n}\n\nvector<vector<int>> floyd(int n, vector<vector<int>>& edges) {\n    vector<vector<int>> g(n, vector<int>(n, INT_MAX/2));\n    vector<vector<int>> dis(n + 1, vector<int>(n + 1));\n\n    for (auto &e : edges) {\n        g[e[0]][e[1]] = g[e[1]][e[0]] = e[2];\n    }\n\n    dis = g;\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dis[i][j] = fmin(dis[i][j], dis[i][k] + dis[k][j]);\n            }\n        }\n    }\n\n    return dis;\n}\n\n/*\nint isPrime[100001];\n//int prime[5000001];\n\nauto init_Prime = [] {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    vector<int> primes;\n    // memset(isPrime, 0, sizeof(isPrime));\n    isPrime[0] = isPrime[1] = 1;\n    for (int i = 2; i <= 100000; i++) {\n        if (isPrime[i] == 0) {\n            primes.push_back(i);\n        }\n\n        for (int j = 0; j < primes.size() && i * primes[j] <= 100000; j++) {\n            isPrime[i * primes[j]] = 1;\n            if (i % primes[j] == 0) {\n                break;\n            }\n        }\n    }\n\n//    for (int i = 1; i <= 100000; i++) {\n//        prime[i] = prime[i - 1];\n//        if (isPrime[i - 1] == 0) prime[i]++;\n//    }\n\n    return 0;\n}();\n*/\n\n\nstatic vector<int> getNext(const string& str) {\n    int n = (int)str.size();\n    vector<int> next(n);\n    int j = 0;\n    for (int i = 1; i < n; i++) {\n        while (j > 0 && str[i] != str[j]) {\n            j = next[j - 1];\n        }\n        if (str[i] == str[j]) {\n            j++;\n            next[i] = j;\n        }\n    }\n    return next;\n}\n\nstatic vector<int> kmp(const string& a, const string& b) {\n    if (a.size() < b.size()) {\n        return {};\n    }\n    int n = (int)a.size();\n    int m = (int)b.size();\n    vector<int> res;\n    vector<int> next = getNext(b);\n    for (int i = 0, j = 0; i < n; i++) {\n        while (j - 1 >= 0 && a[i] != b[j]) {\n            j = next[j - 1];\n        }\n        if (a[i] == b[j]) {\n            j++;\n        }\n        if (j == m) {\n            res.push_back(i - j + 1);\n            j = next[j - 1]; \n        }\n    }\n    return res;\n}\n\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst long long base1 = uniform_int_distribution<>(8e8, 9e8)(rng);\nconst long long base2 = uniform_int_distribution<>(8e8, 9e8)(rng);\n\nstruct stringhash {\n    string s;\n    long long mod1 = 1e9 + 7, mod2 = 998244353, n;\n//    long long  base1 = 131, base2 = 13131;\n    vector<long long> hash1;\n    vector<long long> hash2;\n    vector<long long> hash3;\n    vector<long long> hash4;\n    vector<long long> p1;\n    vector<long long> p2;\n    void init(string str){\n    \tios::sync_with_stdio(false);  \n\t\tcin.tie(0), cout.tie(0);\n        str = \" \" + str;\n        n = str.size() - 1;\n        hash1.resize(n + 1, 0);\n        hash2.resize(n + 1, 0);\n        hash3.resize(n + 2, 0);\n        hash4.resize(n + 2, 0);\n        p1.resize(n + 1, 0);\n        p2.resize(n + 1, 0);\n        s = str;\n        p1[0] = p2[0] = 1;\n        for(int i = 1; i <= n; i++){\n            p1[i] = p1[i - 1] * base1 % mod1;\n            p2[i] = p2[i - 1] * base2 % mod2;\n            hash1[i] = (hash1[i - 1] * base1 + (s[i] - 'a')) % mod1;\n            hash2[i] = (hash2[i - 1] * base2 + (s[i] - 'a')) % mod2;\n        }\n        for(int i = n; i >= 1; i--){\n            hash3[i] = (hash3[i + 1] * base1 + (s[i] - 'a')) % mod1;\n            hash4[i] = (hash4[i + 1] * base2 + (s[i] - 'a')) % mod2;\n        }\n    }\n    \n//    pair<long long, long long> getz(int l, int r){\n//        if(r < l){\n//            assert(0);\n//        }\n//        long long res1 = ((hash1[r] - hash1[l - 1] * p1[r - l + 1]) % mod1 + mod1) % mod1;\n//        long long res2 = ((hash2[r] - hash2[l - 1] * p2[r - l + 1]) % mod2 + mod2) % mod2;\n//        return {res1, res2};\n//    }\n//    pair<long long, long long> getf(int l, int r){\n//        if(r < l){\n//            assert(0);\n//        }\n//        long long res1 = ((hash3[l] - hash3[r + 1] * p1[r - l + 1]) % mod1 + mod1) % mod1;\n//        long long res2 = ((hash4[l] - hash4[r + 1] * p2[r - l + 1]) % mod2 + mod2) % mod2;\n//        return {res1, res2};\n//    }\n    \n    long long getz(int l, int r){\n        if(r < l){\n            assert(0);\n        }\n        long long res1 = ((hash1[r] - hash1[l - 1] * p1[r - l + 1]) % mod1 + mod1) % mod1;\n        long long res2 = ((hash2[r] - hash2[l - 1] * p2[r - l + 1]) % mod2 + mod2) % mod2;\n        long long res = ((res1 << 32) | res2);\n        return res;\n    }\n    long long getf(int l, int r){\n        if(r < l){\n            assert(0);\n        }\n        long long res1 = ((hash3[l] - hash3[r + 1] * p1[r - l + 1]) % mod1 + mod1) % mod1;\n        long long res2 = ((hash4[l] - hash4[r + 1] * p2[r - l + 1]) % mod2 + mod2) % mod2;\n        long long res = ((res1 << 32) | res2);\n        return res;\n    }\n};\n\nstruct Trie {\n\tbool isEnd;\n    Trie* children[26];\n    \n    Trie() {\n        isEnd = false;\n        memset(children, 0, sizeof(children));\n    }\n\n    void TrieInsert(const string &word) {\n        Trie* node = this;\n        for (char c : word) {\n            if (node->children[c - 'a'] == NULL) {\n                node->children[c - 'a'] = new Trie();\n            }\n            node = node->children[c - 'a'];\n        }\n\n        node->isEnd = true;\n        return;\n    }\n\n    bool TrieSearch(const string &word) {\n        Trie* node = this;\n        for (char c : word) {\n            if (node->children[c - 'a'] == NULL)\n                return false;\n            node = node->children[c - 'a'];\n        }\n\n        return node->isEnd;\n    }\n};\n\n\nclass FenwickTree {\n    vector<int> tree;\npublic :\n    FenwickTree(int n) : tree(n + 1) {}\n\n    void update(int i, int val) {\n        for (; i < tree.size(); i += i & -i) {\n            tree[i] += val;\n        }\n        return ;\n    } \n\n    int query(int i) {\n        int sum = 0;\n        for (; i > 0; i -= i & -i) {\n            sum += tree[i];\n        }\n        return sum;\n    }\n};\n\nint dfs_child_count(vector<vector<int>>& g, int x, int fa) {\n    int ret = 1;\n\n    for (int y : g[x]) {\n        if (y != fa) {\n            ret += dfs_child_count(g, y, x);\n        }\n    }\n\n    return ret;\n}\n\n\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> mp;\n        int n = nums.size();\n        vector<int> ans(queries.size(), -1);\n\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n\n        for (int i = 0; i < queries.size(); i++) {\n            int q = queries[i];\n            if (mp[nums[q]].size() == 1) continue;\n            \n            auto &a = mp[nums[q]]; \n            int m = a.size();\n            int idx = lower_bound(a.begin(), a.end(), q) - a.begin();\n            int res = INT_MAX;\n\n            if (idx > 0) {\n                res = min(res, a[idx] - a[idx - 1]);\n            } else {\n                res = min(res, n + a[idx] - a[m - 1]);\n            }\n\n            if (idx < m - 1) {\n                res = min(res, a[idx + 1] - a[idx]);\n            } else {\n                res = min(res, n + a[0] - a[idx]);\n            }\n\n            ans[i] = res; \n        }\n\n        return ans;\n    }\n};\n","author":"silent","submissionId":"611256862"},[]]},{"1947":[{"id":"1947","fileName":"611256031.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector <int> res;\n        int n = nums.size();\n        vector <int> alls;\n        for(int i = 0; i < nums.size(); i++){\n            alls.push_back(nums[i]);\n            //s[nums[i]].insert(i + n);\n        }\n        sort(alls.begin(), alls.end());\n        alls.erase(unique(alls.begin(), alls.end()), alls.end());\n        int sz = alls.size();\n        set <int> s[sz];\n        auto find = [&](int x)->int{\n            int l = 0, r = sz - 1;\n            while(l < r){\n                int mid = (l + r + 1) >> 1;\n                if(alls[mid] <= x) l = mid;\n                else r = mid - 1;\n            }\n            return l;\n        };\n        for(int i = 0; i < nums.size(); i++){\n            nums[i] = find(nums[i]);\n            s[nums[i]].insert(i);\n            //s[nums[i]].insert(i + n);\n        }\n        for(int i = 0; i < queries.size(); i++){\n            int q = queries[i];\n            s[nums[q]].erase(q);\n            //s[nums[q]].erase(q + n);\n            auto it = s[nums[q]].lower_bound(q);\n            int dis = 1e9;\n            if(it != s[nums[q]].end()){\n                //ans = *it - q;\n                //cout << q << \" \" << nums[q] << \" \" << *it << \"n\";\n                dis = min(q + n - *it, *it - q);\n            }else{\n                if(s[nums[q]].size() > 0){\n                    dis = min(dis, *s[nums[q]].begin() + n - q);\n                }\n            }\n            if(it != s[nums[q]].begin()){\n                it--;\n                dis = min(dis, min(q - *it, n - q + *it));\n            }else{\n                if(s[nums[q]].size() > 0){\n                    dis = min(dis, n - *s[nums[q]].rbegin() + q);\n                }\n            }\n            if(dis == 1e9) dis = -1;\n            res.push_back(dis);\n            s[nums[q]].insert(q);\n            //s[nums[q]].insert(q + n);\n        }\n        return res;\n    }\n};","author":"Pig312","submissionId":"611256031"},[]]},{"1948":[{"id":"1948","fileName":"611257649.txt","sourceCode":"#include <ranges>\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        vector<int> ans(queries.size());\n        unordered_map<int, vector<int>> ids;\n\n        for (int i = 0; i < nums.size(); i++) {\n            ids[nums[i]].push_back(i);\n        }\n\n        for (auto [i, q] : queries | views::enumerate) {\n            auto& id = ids[nums[q]];\n            auto it = ranges::lower_bound(id, q) - id.begin();\n            if (id.size() == 1)\n                ans[i] = -1;\n            else {\n                int a, b;\n\n                if (it == 0)\n                    a = id[it] + nums.size() - id.back();\n                else\n                    a = id[it] - id[it - 1];\n\n                if (it == id.size() - 1)\n                    b = id.front() + nums.size() - id[it];\n                else\n                    b = id[it + 1] - id[it];\n\n                ans[i] = min(a, b);\n            }\n        }\n\n        return ans;\n    }\n};","author":"zzz","submissionId":"611257649"},[]]},{"1949":[{"id":"1949","fileName":"611257881.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        mp = defaultdict(list)\n        res = []\n        for i, num in enumerate(nums):\n            mp[num].append(i)\n        for i, q in enumerate(queries):\n            if len(mp[nums[q]]) == 1:\n                res.append(-1)\n                continue\n            idx = bisect_left(mp[nums[q]], q)\n            if idx > 0:\n                pre = mp[nums[q]][idx - 1]\n            else:\n                pre = mp[nums[q]][-1]\n            if idx < len(mp[nums[q]]) - 1:\n                nxt = mp[nums[q]][idx + 1]\n            else:\n                nxt = mp[nums[q]][0]\n            d1 = min(abs(pre - q), len(nums) - abs(pre - q))\n            d2 = min(abs(nxt - q), len(nums) - abs(nxt - q))\n            res.append(min(d1, d2))\n        return res","author":"悖谬","submissionId":"611257881"},[]]},{"1950":[{"id":"1950","fileName":"611257887.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        dd = defaultdict(list)\n        for i, x in enumerate(nums):\n            dd[x].append(i)\n        n = len(nums)\n        ans = []\n        for i in queries:\n            x = nums[i]\n            p = bisect_left(dd[x], i)\n            l = len(dd[x])\n            if l == 1:\n                ans.append(-1)\n                continue\n            mn = inf\n            if p > 0:\n                mn = min(mn, i - dd[x][p - 1])\n            else:\n                mn = min(mn, i + n - dd[x][-1])\n            if p < l - 1:\n                mn = min(mn, dd[x][p + 1] - i)\n            else:\n                mn = min(mn, dd[x][0] + n - i)\n            ans.append(mn)\n        return ans\n        ","author":"Sun","submissionId":"611257887"},[]]},{"1951":[{"id":"1951","fileName":"611258055.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n    m := make(map[int][]int)\n    for i, num := range nums {\n        m[num] = append(m[num], i)\n    }\n    n := len(nums)\n    ans := make([]int, len(queries))\n    for i, query := range queries {\n        ans[i] = search(m[nums[query]], query, n)\n    }\n    return ans\n}\n\nfunc search(nums []int, target int, n int) int {\n    if len(nums) < 2 {\n        return -1\n    }\n    l, r := 0, len(nums) - 1\n    for l <= r {\n        m := l + (r - l) / 2\n        if nums[m] > target {\n            r = m - 1\n        } else if nums[m] < target {\n            l = m + 1\n        } else {\n            if m == 0 {\n                if len(nums) > 2 && n - nums[len(nums) - 1] + nums[m] < nums[m + 1] - nums[m] {\n                    return n - nums[len(nums) - 1] + nums[m]\n                }\n                return min(n - nums[m + 1] + nums[m], nums[m + 1] - nums[m])\n            }\n            if m == len(nums) - 1 {\n                if len(nums) > 2 && n - nums[m] + nums[0] < nums[m] - nums[m - 1] {\n                    return n - nums[m] + nums[0]\n                }\n                return min(n + nums[m - 1] - nums[m], nums[m] - nums[m - 1])\n            }\n            if nums[m + 1] - nums[m] > nums[m] - nums[m - 1] {\n                return nums[m] - nums[m - 1]\n            }\n            return nums[m + 1] - nums[m]\n        }\n    }\n    return -1\n}\n\nfunc abs(val int) int {\n    if val < 0 {\n        return -val\n    }\n    return val\n}","author":"二本吊车尾","submissionId":"611258055"},[]]},{"1955":[{"id":"1955","fileName":"611258115.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        \n        bool all = true;\n        map<int, vector<int>> pos;\n        for (int i = 0; i < n; i++) {\n            pos[nums[i]].emplace_back(i);\n            if (i > 0 && nums[i] != nums[0]) {\n                all = false;\n            }\n        }\n        \n        int m = queries.size();\n        if (all && n > 1) {\n            return vector<int>(m, 1);\n        }\n        vector<int> ans(m);\n        for (int i = 0; i < m; i++) {\n            int u = queries[i];\n            vector<int> s = pos[nums[u]];\n            if (s.size() == 1) {\n                ans[i] = -1;\n                continue;\n            }\n            int p = lower_bound(s.begin(), s.end(), u) - s.begin();\n            \n            //clock_t start = clock();\n            if (p == 0) {\n                ans[i] = min(s[p + 1] - u, (u - s[s.size() - 1] + n) % n);\n            } else if (p == s.size() - 1) {\n                ans[i] = min(u - s[p - 1], (s[0] - u + n) % n);\n            } else {\n                ans[i] = min(min(s[p + 1] - u, (u - s[s.size() - 1] + n) % n), min(u - s[p - 1], (s[0] - u + n) % n));\n            }\n            // clock_t end = clock();\n            // cout << \"cost: \" << static_cast<double>(end - start) << endl;\n        }\n        return ans;\n    }\n};","author":"muffin","submissionId":"611258115"},[]]},{"1956":[{"id":"1956","fileName":"611258734.txt","sourceCode":"func solveQueries(nums []int, queries []int) []int {\n    n := len(nums)\n    mp := make(map[int][]int)\n    for i, num := range nums {\n        mp[num] = append(mp[num], i)\n    }\n    \n    for num := range mp {\n        sort.Ints(mp[num])\n    }\n    \n    prevNext := make(map[int]struct{ prev, next int })\n    \n    for _, idxs := range mp {\n        l := len(idxs)\n        if l <= 1 {\n            continue\n        }\n        \n        for i := 0; i < l; i++ {\n            prevIdx := i - 1\n            if prevIdx < 0 {\n                prevIdx = l - 1\n            }\n            \n            nextIdx := i + 1\n            if nextIdx >= l {\n                nextIdx = 0\n            }\n            \n            prev, next := idxs[prevIdx], idxs[nextIdx]\n            prevNext[idxs[i]] = struct{ prev, next int}{prev, next}\n        }\n    }\n    \n    res := make([]int, 0, len(queries))\n    for _, q := range queries {\n        pos := q\n        num := nums[pos]\n        idxs := mp[num]\n        if len(idxs) <= 1 {\n            res = append(res, -1)\n            continue\n        }\n        \n        pn := prevNext[pos]\n        prev, next := pn.prev, pn.next\n        d1 := minDist(pos, prev, n)\n        d2 := minDist(pos, next, n)\n        res = append(res, min(d1, d2))\n    }\n    return res\n}\n\nfunc abs(a int) int {\n    if a < 0 {\n        return -a\n    }\n    return a\n}\n\nfunc minDist(a, b, n int) int {\n    d := abs(a - b)\n    if d < n-d {\n        return d\n    }\n    return n-d\n}","author":"无名客","submissionId":"611258734"},[]]},{"1957":[{"id":"1957","fileName":"611258590.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        posi = defaultdict(list)\n        for i,x in enumerate(nums):\n            posi[x].append(i)\n        n = len(nums)\n\n        res = []\n        for q in queries:\n            v = nums[q]\n            j = bisect_left(posi[v], q)\n            m = len(posi[v])\n            if m == 1:\n                res.append(-1)\n                continue\n            if j == 0:\n                l = n - posi[v][-1] + posi[v][j]\n            else:\n                l = posi[v][j] - posi[v][j-1]\n            if j == m-1:\n                r = posi[v][0] + n - posi[v][j]\n            else:\n                r = posi[v][j+1] - posi[v][j]\n            res.append(min(l,r))\n        return res","author":"活力喵饭","submissionId":"611258590"},[]]},{"1958":[{"id":"1958","fileName":"611258953.txt","sourceCode":"from collections import defaultdict\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        num_to_indices = defaultdict(list)\n        for idx, num in enumerate(nums):\n            num_to_indices[num].append(idx)\n        \n        result = []\n        for i in queries:\n            a = nums[i]\n            indices = num_to_indices[a]\n            if len(indices) == 1:\n                result.append(-1)\n            else:\n                pos = bisect.bisect_left(indices, i)\n                left = indices[pos - 1] if pos > 0 else indices[-1]\n                right = indices[pos + 1] if pos < len(indices) - 1 else indices[0]\n                dist_left = min(abs(i - left), len(nums) - abs(i - left))\n                dist_right = min(abs(i - right), len(nums) - abs(i - right))\n                result.append(min(dist_left, dist_right))\n        return result","author":"Cthva十十","submissionId":"611258953"},[]]},{"1960":[{"id":"1960","fileName":"611259791.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        int  n=nums.size(),m=q.size();\n        vector<int> res(m,INT_MAX);\n        vector<vector<int>> v(100001);\n        /* for(int i=0;i<n;i++)\n            {\n                nums.push_back(nums[i]);\n            }*/\n        for(int i=0;i<nums.size();i++)\n            {\n                v[nums[i]].push_back(i);\n            }\n       \n        \n        for(int i=0;i<m;i++)\n            {\n                int key=q[i];\n                int num=nums[key];\n                auto it=lower_bound(v[num].begin(),v[num].end(),key);\n                if(it!=v[num].begin())\n                {\n                    res[i]=min(v[num][0]+n-key,key-*(it-1));\n                }\n                if(it!=v[num].end()-1)\n                {\n                    res[i]=min(res[i],*(it+1)-key);\n                    res[i]=min(res[i],key+n-v[num].back());\n                }\n                if(res[i]==INT_MAX) res[i]=-1;\n            \n            }\n        return res;\n    }\n};","author":"Z🐔H","submissionId":"611259791"},[]]},{"1961":[{"id":"1961","fileName":"611259261.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& q) {\n        map<int, vector<int>> mp;\n        int n = nums.size(), m = q.size();\n        for (int i = 0; i < n; i++) {\n            mp[nums[i]].push_back(i);\n        }\n        vector<int> ans(m, -1);\n        for (int i = 0; i < m; ++i) {\n            int idx = q[i];\n            auto& arr = mp[nums[idx]];\n            if (arr.size() == 1)\n                continue;\n            int l = -1, r = arr.size();\n            while (l + 1 != r) {\n                int mid = (l + r)>> 1;\n                if (arr[mid] <= idx)\n                    l = mid;\n                else\n                    r = mid;\n            }\n            int ld = (l ==  0 ? (idx + n - arr.back()) : arr[l] - arr[l - 1]);\n            int rd = (l == arr.size() - 1 ? (n - idx + arr[0]) : arr[l + 1] - arr[l]);\n            ans[i] = min(ld, rd);\n        }\n        return ans;\n    }\n};","author":"赌怪","submissionId":"611259261"},[]]},{"1962":[{"id":"1962","fileName":"611259028.txt","sourceCode":"class Solution {\npublic:\nvector<int> solveQueries(vector<int> &nums, vector<int> &queries) {\n    int n = nums.size();\n    unordered_map<int, vector<int>> mp;\n    for (int i = 0; i < n; ++i) {\n        mp[nums[i]].push_back(i);\n    }\n    vector<int> ans;\n    for (int query:queries) {\n        int min_dis = INT_MAX;\n        int x = nums[query];\n        int pos = lower_bound(mp[x].begin(), mp[x].end(), query) - mp[x].begin();\n        int l = mp[x].size();\n        if (l != 1){\n            min_dis = min({min_dis, abs(mp[x][pos] - mp[x][(pos - 1 + l) % l]),\n                           (n - abs(mp[x][pos] - mp[x][(pos - 1 + l) % l])) % n});\n            min_dis = min({min_dis, abs(mp[x][pos] - mp[x][(pos + 1) % l]),\n                           (n - abs(mp[x][pos] - mp[x][(pos + 1) % l])) % n});\n        }\n        ans.push_back(min_dis == INT_MAX ? -1 : min_dis);\n    }\n    return ans;\n}\n};","author":"致命之足","submissionId":"611259028"},[]]},{"1963":[{"id":"1963","fileName":"611259883.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        unordered_map<int, vector<int>> umap;\n        vector<int> ans;\n        for (int i = 0; i < nums.size(); i++) {\n            umap[nums[i]].push_back(i);\n        }\n        for (int x : queries) {\n            if (umap[nums[x]].size() == 1) {\n                ans.push_back(-1);\n            } else {\n                int a = -1;\n                int b = -1;\n                int n = nums.size();\n                int mn = INT_MAX;\n                auto iter1 = lower_bound(umap[nums[x]].begin(), umap[nums[x]].end(), x);\n                if ((iter1 + 1) != umap[nums[x]].end()) {\n                    b = *(iter1 + 1);\n                }\n                if (iter1 != umap[nums[x]].begin()) {\n                    a = *(prev(iter1));\n                }\n                if (a != -1) {\n                    mn = min({mn, abs(x - a), n - abs(x - umap[nums[x]][0])});\n                }\n                if (b != -1) {\n                    mn = min({mn, abs(b - x), n - abs(x - *(umap[nums[x]].end() - 1))});\n                }\n                ans.push_back(mn);\n            }\n        }\n        return ans;\n    }\n};","author":"Stupefied 6aloisK4s","submissionId":"611259883"},[]]},{"1964":[{"id":"1964","fileName":"611259097.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        nums_to_index = defaultdict(list)\n        for i, num in enumerate(nums):\n            nums_to_index[num].append(i)\n            \n        ans = []\n\n        def f1(q, x):\n            indices = nums_to_index[x]\n            if len(indices) <= 1:\n                return -1\n            pos = bisect_left(indices, q)\n            st = []\n            if pos > 0:\n                st.append(indices[pos - 1])\n            if pos < len(indices) - 1:\n                st.append(indices[pos + 1])\n            if pos == 0:\n                st.append(indices[-1])\n            if pos == len(indices) - 1:\n                st.append(indices[0])\n\n            st = list(set(st))\n            st = [j for j in st if j != q]\n            md = float('inf')\n            for j in st:\n                diff = abs(j - q)\n                mn = min(diff, n - diff)\n                if mn < md:\n                    md = mn\n\n            return md\n        \n        for q in queries:\n            x = nums[q]\n            ans.append(f1(q, x))\n\n        return ans","author":"白夜暗星","submissionId":"611259097"},[]]},{"1965":[{"id":"1965","fileName":"611260324.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size(), w = 1e7;\n        map<int, int> mpp, mpn;\n        for(int i = 0; i < n; i ++) nums.push_back(nums[i]);\n        int len = 2 * n;\n        vector<int> pre(len + 1, -2*len), ne(len + 1, 2*len); \n        for(int i = 0; i < len; i ++) \n        {\n            int p = -w;\n            int x = nums[i];\n            if(mpp.count(x)) p = mpp[x];\n            pre[i] = p;\n            mpp[x] = i;\n        }\n        for(int i = len - 1; i >= 0; i --)\n        {\n            int p = w;\n            int x = nums[i];\n            if(mpn.count(x))  p = mpn[x];\n            ne[i] = p;\n            mpn[x] = i;\n        }\n        vector<int> ans(queries.size(), -1);\n        for(int i = 0; i < m; i ++)\n        {\n            int x = queries[i];\n            int pre_x = pre[x], ne_x = ne[x];\n            int res1 = min(x - pre_x, ne_x - x);\n            int y = x + n;\n            int pre_y = pre[y], ne_y = ne[y];\n            int res2 = min(y - pre_y, ne_y - y);\n            ans[i] = min(res1, res2);\n            if(ans[i] >= n) ans[i] = -1;\n        }\n        return ans;\n    }\n};","author":"肥工第一深情","submissionId":"611260324"},[]]},{"1967":[{"id":"1967","fileName":"611261758.txt","sourceCode":"class Solution {\n    int dist(int i, int j, int n) {\n        if (i > j) swap(i, j);\n        return min(j - i, i - j + n);\n    }\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<int> res(m, -1);\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < n; ++i) mp[nums[i]].push_back(i);\n        for (int j = 0; j < m; ++j) {\n            int idx = queries[j], val = nums[idx];\n            int k = mp[val].size();\n            if (k < 2) continue;\n            int i = lower_bound(mp[val].begin(), mp[val].end(), idx) - mp[val].begin();\n            int i1 = mp[val][(i+k-1) % k], i2 = mp[val][(i+1) % k];\n            res[j] = min(dist(i1, idx, n), dist(i2, idx, n));\n        }\n        return res;\n    }\n};","author":"abyss","submissionId":"611261758"},[]]},{"1968":[{"id":"1968","fileName":"611261843.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        num2idx = defaultdict(list)\n        for i, num in enumerate(nums):\n            num2idx[num].append(i)\n        \n        ans = []\n        for q in queries:\n            num = nums[q]\n            idx_list = num2idx[num]\n            l = len(idx_list)\n            if l == 1:\n                ans.append(-1)\n                continue\n            idx = bisect_left(idx_list, q)\n            ans.append(min((q - idx_list[idx-1] + len(nums))%len(nums), (idx_list[(idx+1)%l] - q)%len(nums)))\n            \n            \n        return ans","author":"","submissionId":"611261843"},[]]},{"1969":[{"id":"1969","fileName":"611259981.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        d = defaultdict(list)\n        for i, x in enumerate(nums):\n            d[x].append(i)\n\n        ans = [-1] * len(queries)\n        for i, q in enumerate(queries):\n            x = nums[q]\n            idx = bisect_left(d[x], q)\n            if len(d[x]) == 1:\n                continue\n\n            r = inf\n            pre = d[x][(idx-1)%(len(d[x]))]\n            if pre > q:\n                r = min(r, pre-q, len(nums)+q-pre)\n            elif pre < q:\n                r = min(r, q-pre, len(nums)+pre-q)\n            nxt = d[x][(idx+1)%(len(d[x]))]\n            if nxt > q:\n                r = min(r, nxt-q, len(nums)+q-nxt)\n            elif nxt < q:\n                r = min(r, q-nxt, len(nums)+nxt-q)\n\n            ans[i] = r\n        return ans","author":"magiccircle","submissionId":"611259981"},[]]},{"1970":[{"id":"1970","fileName":"611262608.txt","sourceCode":"import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n\t\tint n = nums.length;\n\t\tint[] data = new int[2*n];\n        init(nums, data);\n        int[] pre = new int[2*n], next = new int[2*n];\n        \n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for (int i = 0; i < 2*n; i++) {\n        \tint key = data[i];\n        \tpre[i] = map.getOrDefault(key, -1);\n        \tmap.put(key, i);\n        }\n        \n        map = new HashMap<Integer, Integer>();\n        for (int i = 2*n - 1; i >= 0; i--) {\n        \tint key = data[i];\n        \tnext[i] = map.getOrDefault(key, -1);\n        \tmap.put(key, i);\n        }\n        \n        List<Integer> ans = new ArrayList<Integer>();\n        for (int i = 0; i < queries.length; i++) {\n        \tint j1 = queries[i], j2 = j1+n;\n        \t\n        \tint tmp = -1;\n        \tif (pre[j2] != -1 && pre[j2] != j1) {\n        \t\ttmp = j2 - pre[j2];\n        \t}\n        \tif (next[j1] != -1 && next[j1] != j2) {\n        \t\ttmp = Math.min(tmp, next[j1] - j1);\n        \t}\n        \tans.add(tmp);\n        }\n        \n        return ans;\n    }\n\n\tprivate void init(int[] nums, int[] data) {\n\t\tint n = nums.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdata[i] = nums[i];\n\t\t\tdata[i+n] = nums[i];\n\t\t}\n\t}\n}","author":"成长- 追梦","submissionId":"611262608"},[]]},{"1971":[{"id":"1971","fileName":"611262862.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& a, vector<int>& queries) {\n        int n = a.size();\n        vector<pair<int, int>> b(n);\n        for (int i = 0; i < n; i++) {\n            b[i] = {a[i], i};\n        }\n        sort(b.begin(), b.end());\n        \n        vector<int> pre(n, -1), nxt(n, -1);\n        for (int i = 0; i < n; i++) {\n            int j = i;\n            while (j < n && b[j].first == b[i].first) {\n                j++;\n            }\n            j--;\n\n            for (int k = i; k <= j; k++) {\n                int x = b[k == i ? j : k - 1].second;\n                int y = b[k].second;\n                int z = b[k == j ? i : k + 1].second;\n                pre[y] = x;\n                nxt[y] = z;\n            }\n\n            \n            i = j;\n        }\n\n        auto dist = [&](int x, int y) -> int {\n            if (x == y) return 1e9;\n            if (x > y) swap(x, y);\n            return min({y - x, n - y + x});\n        };\n        \n        int m = queries.size();\n        vector<int> ans(m, 1e9);\n        for (int i = 0; i < m; i++) {\n            int idx = queries[i];\n            ans[i] = min({dist(idx, pre[idx]), dist(idx, nxt[idx])});\n            if (ans[i] == 1e9) {\n                ans[i] = -1;\n            }\n            \n        }\n        return ans;\n    }\n};","author":"Leesuhyun","submissionId":"611262862"},[]]},{"1972":[{"id":"1972","fileName":"611260317.txt","sourceCode":"#define repi(i, a, b) for (int i = (a), i##len = (b); i <= i##len; ++i)\n#define peri(i, a, b) for (int i = (a), i##len = (b); i >= i##len; --i)\n#define ll long long\n#define pii pair<int, int>\n#define x first\n#define y second\n#define vi vector<int>\n#define gi greater<int>\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define lowbit(t) ((t) & (-(t)))\nconstexpr const int MAXN = 1e5 + 5;\nconstexpr const int MOD = 1e9 + 7;\nconstexpr const int BASE = 233;\nconstexpr const int MOD2 = 998244353;\nconstexpr const int INF = 0x3f3f3f3f;\nint dx[] = {0, 0, -1, 1, -1, 1, 1, -1};\nint dy[] = {-1, 1, 0, 0, -1, -1, 1, 1};\ntemplate <class U, class T> void Max(U &x, T y) {\n  if (x < y)\n    x = y;\n}\ntemplate <class U, class T> void Min(U &x, T y) {\n  if (x > y)\n    x = y;\n}\ninline ll qpow(ll b, ll k, int MOD) {\n  ll ans = 1;\n  while (k) {\n    if (k & 1) {\n      (ans *= b) %= MOD;\n    }\n    (b *= b) %= MOD;\n    k >>= 1;\n  }\n  return ans;\n}\n\nint ans[MAXN];\nclass Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n      map<int,int> pos;\n      int n = nums.size();\n      memset(ans,INF,sizeof(ans));\n      repi(i,0,n*2-1){\n        auto it = pos.find(nums[i%n]);\n        if (it != pos.end()){\n          Min(ans[i%n], i - it->y);\n        }\n        pos[nums[i%n]] = i;\n      }\n      pos.clear();\n      peri(i,2*n-1,0){\n        auto it = pos.find(nums[i%n]);\n        if (it != pos.end()){\n          Min(ans[i%n],it->y - i);\n        }\n        pos[nums[i%n]] = i;\n      }\n      vi res;\n      for(auto q:queries) {\n        if (ans[q] == n) {\n          res.pb(-1);\n        } else {\n          res.pb(ans[q]);\n        }\n      }\n      return res;\n    }\n};","author":"carrot","submissionId":"611260317"},[]]},{"1973":[{"id":"1973","fileName":"611267011.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        map<int,vector<int>> store;\n        map<int,int> index1;\n        int m=nums.size();\n        for (int i=0;i<nums.size();++i){\n            store[nums[i]].push_back(i);\n            index1[i]=store[nums[i]].size()-1;\n        }\n        vector<int> res;\n        for (auto i:queries){\n            vector<int>& tem=store[nums[i]];\n            int index=index1[i],n=tem.size();\n            if (tem.size()==1){\n                res.push_back(-1);\n            }\n            else if (index==0){\n                res.push_back(min(tem[1]-tem[0],m-tem[n-1]+tem[0]));\n            }\n            else if (index==n-1){\n                res.push_back(min(tem[n-1]-tem[n-2],m-tem[n-1]+tem[0]));\n            }\n            else{\n                res.push_back(min(tem[index]-tem[index-1],tem[index+1]-tem[index]));\n            }\n        }\n        return res;\n    }\n};","author":"小小打凤凰","submissionId":"611267011"},[]]},{"1975":[{"id":"1975","fileName":"611268591.txt","sourceCode":"class Solution {\n    public List<Integer> solveQueries(int[] nums, int[] queries) {\n        List<Integer> ans = new ArrayList<>();\n        HashMap<Integer, List<Integer>> hash = new HashMap<>();\n        for (int i=0;i < nums.length;i++) {\n            if (hash.containsKey(nums[i])) {\n                hash.get(nums[i]).add(i);\n            } else {\n                hash.put(nums[i], new ArrayList<Integer>());\n                hash.get(nums[i]).add(i);\n            }\n        }\n\n        HashMap<Integer,Integer> h = new HashMap<>();\n        for (int i = 0; i < queries.length; i++) {\n            if (h.containsKey(queries[i])) {\n                ans.add(h.get(queries[i]));\n                continue;\n            }\n            int key = nums[queries[i]];\n            if (hash.get(key).size() == 1) {\n                ans.add(-1);\n                continue;\n            }\n\n            List<Integer> temp = hash.get(key);\n            int m = temp.size();\n            int pos = Collections.binarySearch(temp, queries[i]);\n            int path1 = Math.min(Math.abs(queries[i] - temp.get((pos-1+m)%m)), nums.length - Math.abs(queries[i] - temp.get((pos-1+m)%m)));\n            int path2 = Math.min(Math.abs(queries[i] - temp.get((pos+1)%m)), nums.length - Math.abs(queries[i] - temp.get((pos+1)%m)));\n            \n            h.put(queries[i], Math.min(path1, path2));\n            ans.add(Math.min(path1, path2));\n        }\n\n        return ans;\n    }\n}","author":"fms231","submissionId":"611268591"},[]]},{"1977":[{"id":"1977","fileName":"611267644.txt","sourceCode":"class Solution {\npublic:\n  vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n    map<int, vector<int>> mp;\n    int n = (int)nums.size();\n    for (int i = 0; i < n; i++) {\n      mp[nums[i]].push_back(i);\n    }\n    int q = (int)queries.size();\n    vector<int> ans(q);\n    for (int i = 0; i < q; i++) {\n      int x = nums[queries[i]];\n      vector<int> &lis = mp[x];\n      int sz = (int)lis.size();\n      if (sz == 1) ans[i] = -1;\n      else {\n        int p = lower_bound(lis.begin(), lis.end(), queries[i])-lis.begin();\n        int mn = 1e9;\n        if (p-1 >= 0) mn = min(mn, abs(queries[i]-lis[p-1]));\n        else mn = min(mn, n-abs(lis[sz-1]-queries[i]));\n        if (p+1 < sz) mn = min(mn, abs(queries[i]-lis[p+1]));\n        else mn = min(mn, n-abs(queries[i]-lis[0]));\n        ans[i] = mn;\n      }\n    }\n    return ans;\n  }\n};","author":"upk1_dwk2","submissionId":"611267644"},[]]},{"1978":[{"id":"1978","fileName":"611268995.txt","sourceCode":"#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint pre[1000010], hd[1000010];\nint val[100010];\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint* solveQueries(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize) {\n    int n = numsSize;\n    int q = queriesSize;\n    *returnSize = q;\n    int mx = nums[0];\n    for (int i = 1;i < n;i++) mx = max(mx, nums[i]);\n    const int N = mx + 2;\n    for (int i = 1;i < N;i++) {\n        pre[i] = hd[i] = -1;\n    }\n    int * ans = (int*) malloc(q * sizeof(int));\n    for (int i = 0;i < n;i++) {\n        int x = nums[i];\n        if (hd[x] == -1) {\n            hd[x] = pre[x] = i;\n            val[i] = -1;\n        } else {\n            int lst = pre[x];\n            val[i] = i - lst;\n            if (val[lst] != -1) val[lst] = min(val[lst], val[i]);\n            else val[lst] = val[i];\n            val[hd[x]] = min(val[hd[x]], hd[x] + n - i);\n            val[i] = min(val[i], hd[x] + n - i);\n            pre[x] = i;\n        }\n    }\n    for (int i = 0;i < q;i++) ans[i] = val[queries[i]];\n    return ans;\n}","author":"河城白露","submissionId":"611268995"},[]]},{"1981":[{"id":"1981","fileName":"611271195.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int m=queries.size();\n        int n=nums.size();\n        vector<int> ans(m,-1);\n        unordered_map<int,vector<int>> mp;\n        for(int i=0;i<n;i++){\n            mp[nums[i]].push_back(i);\n        }\n        for(int i=0;i<m;i++){\n            int q=queries[i];\n            vector<int> &temp=mp[nums[q]];\n            if(temp.size()==1)continue;\n            int l=0,r=temp.size();\n            while(l<r){\n                int mid=l+(r-l)/2;\n                if(temp[mid]>=q+1)r=mid;\n                else l=mid+1;\n            }\n            int t1=l==temp.size()?0:l;\n            l=0;r=temp.size();\n              while(l<r){\n                int mid=l+(r-l)/2;\n                if(temp[mid]>=q)r=mid;\n                else l=mid+1;\n            }\n            int t2=l==0?temp.size()-1:l-1;\n             int mi1=min(abs(q-temp[t1]),(n-abs(q-temp[t1])));\n             int mi2=min(abs(q-temp[t2]),(n-abs(q-temp[t2])));\n            if(temp[t1]==q)ans[i]=mi1;\n            else if(temp[t1]==q)ans[i]=mi2;\n            else ans[i]=min(mi1,mi2);\n        }\n        return ans;\n        \n    }\n};","author":"xiuxiu","submissionId":"611271195"},[]]},{"1982":[{"id":"1982","fileName":"611274032.txt","sourceCode":"class Solution {\npublic:\n    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<int> l(1e6 + 10, -1), r(1e6 + 10, -1), d(n + 1, 0x3f3f3f3f);\n        set<int> s;\n        for(int i = 0; i < n; i ++){\n            s.insert(nums[i]);\n            if(l[nums[i]] == -1){\n                l[nums[i]] = i;\n                r[nums[i]] = i;\n            }\n            else{\n                d[i] = min(d[i], i - r[nums[i]]);\n                d[r[nums[i]]] = min(d[r[nums[i]]], i - r[nums[i]]);\n                r[nums[i]] = i;\n            }\n        }\n        \n        for(auto i : s){\n            if(l[i] != r[i]){\n                d[l[i]] = min(d[l[i]], n - (r[i] - l[i]));\n                d[r[i]] = min(d[r[i]], n - (r[i] - l[i]));\n            }\n        }\n        \n        vector<int> res(m);\n        for(int i = 0; i < m; i ++){\n            if(d[queries[i]] != 0x3f3f3f3f)\n                res[i] = d[queries[i]];\n            else \n                res[i] = -1;\n        }\n        return res;\n    }\n};","author":"Upbeat HugleukS","submissionId":"611274032"},[]]},{"1983":[{"id":"1983","fileName":"611266332.txt","sourceCode":"import bisect\nfrom collections import defaultdict\n\nclass Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        # 预处理，构建每个数值对应的下标列表，并排序\n        num_indices = defaultdict(list)\n        for idx, num in enumerate(nums):\n            num_indices[num].append(idx)\n        for key in num_indices:\n            num_indices[key].sort()\n        \n        n = len(nums)\n        answer = []\n        for q in queries:\n            x = nums[q]\n            indices = num_indices[x]\n            if len(indices) <= 1:\n                answer.append(-1)\n                continue\n            # 找到当前查询下标在列表中的位置\n            pos = bisect.bisect_left(indices, q)\n            m = len(indices)\n            # 确定前驱和后继下标\n            if pos > 0:\n                predecessor = indices[pos-1]\n            else:\n                predecessor = indices[-1]\n            if pos < m - 1:\n                successor = indices[pos+1]\n            else:\n                successor = indices[0]\n            # 计算循环距离\n            d1 = abs(q - predecessor)\n            d1 = min(d1, n - d1)\n            d2 = abs(q - successor)\n            d2 = min(d2, n - d2)\n            min_dist = min(d1, d2)\n            answer.append(min_dist)\n        return answer","author":"leakey_py","submissionId":"611266332"},[]]},{"1984":[{"id":"1984","fileName":"611271357.txt","sourceCode":"class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n, m = len(nums), len(queries)\n        pos = defaultdict(list)\n        idx = [-1] * n\n        ans = []\n        for i, x in enumerate(nums):\n            pos[x].append(i)\n            idx[i] = len(pos[x]) - 1\n        for i in queries:\n            a = -1\n            li = pos[nums[i]]\n            p = idx[i]\n            if len(li) != 1:\n                if p == 0:\n                    a = min(abs(li[0] - li[1]), abs(li[0] + n - li[-1]))\n                elif p == len(li) - 1:\n                    a = min(abs(li[-1] - li[-2]), abs(li[0] + n - li[-1]))\n                else:\n                    a = min(abs(li[p] - li[p - 1]), abs(li[p] - li[p + 1]))\n            ans.append(a)\n        return ans","author":"星开祈灵","submissionId":"611271357"},[]]}]}