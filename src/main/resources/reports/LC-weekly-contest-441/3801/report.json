{"data":[{"0":[{"id":"0","fileName":"1575096516.txt","sourceCode":"#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAXN 400005\n\ntypedef struct {\n    int Shubh[MAXN], shub[MAXN];\n    int SHub;\n} Shubhra;\n\nvoid init(Shubhra *tree, int ShUb) {\n    tree->SHub = ShUb;\n    for (int i = 0; i < 4 * ShUb; i++) {\n        tree->Shubh[i] = 0;\n        tree->shub[i] = 0;\n    }\n}\n\nvoid build(Shubhra *tree, int *shubhr, int shubH, int shUbh, int shubh) {\n    if (shUbh == shubh) {\n        tree->Shubh[shubH] = shubhr[shUbh];\n        return;\n    }\n    int shUbH = (shUbh + shubh) / 2;\n    build(tree, shubhr, 2 * shubH + 1, shUbh, shUbH);\n    build(tree, shubhr, 2 * shubH + 2, shUbH + 1, shubh);\n    tree->Shubh[shubH] = tree->Shubh[2 * shubH + 1] + tree->Shubh[2 * shubH + 2];\n}\n\nvoid rangeUpdate(Shubhra *tree, int shubH, int shUbh, int shubh, int ShUbH, int shubHr, int SHubH) {\n    if (tree->shub[shubH] != 0) {\n        tree->Shubh[shubH] += (shubh - shUbh + 1) * tree->shub[shubH];\n        if (shUbh != shubh) {\n            tree->shub[2 * shubH + 1] += tree->shub[shubH];\n            tree->shub[2 * shubH + 2] += tree->shub[shubH];\n        }\n        tree->shub[shubH] = 0;\n    }\n    if (shUbh > shubHr || shubh < ShUbH)\n        return;\n    if (shUbh >= ShUbH && shubh <= shubHr) {\n        tree->Shubh[shubH] += (shubh - shUbh + 1) * SHubH;\n        if (shUbh != shubh) {\n            tree->shub[2 * shubH + 1] += SHubH;\n            tree->shub[2 * shubH + 2] += SHubH;\n        }\n        return;\n    }\n    int shUbH = (shUbh + shubh) / 2;\n    rangeUpdate(tree, 2 * shubH + 1, shUbh, shUbH, ShUbH, shubHr, SHubH);\n    rangeUpdate(tree, 2 * shubH + 2, shUbH + 1, shubh, ShUbH, shubHr, SHubH);\n    tree->Shubh[shubH] = tree->Shubh[2 * shubH + 1] + tree->Shubh[2 * shubH + 2];\n}\n\nlong long binExp(long long shubh, long long shubH, long long SHubH) {\n    long long shUb = 1;\n    while (shubH > 0) {\n        if (shubH & 1)\n            shUb = (shUb * shubh) % SHubH;\n        shubh = (shubh * shubh) % SHubH;\n        shubH >>= 1;\n    }\n    return shUb;\n}\n\nbool *sieve(int shubhr) {\n    bool *shUbH = (bool *)malloc((shubhr + 1) * sizeof(bool));\n    memset(shUbH, true, (shubhr + 1) * sizeof(bool));\n    shUbH[0] = shUbH[1] = false;\n    for (int shubh = 2; shubh * shubh <= shubhr; shubh++) {\n        if (shUbH[shubh]) {\n            for (int shubH = shubh * shubh; shubH <= shubhr; shubH += shubh) {\n                shUbH[shubH] = false;\n            }\n        }\n    }\n    return shUbH;\n}\n\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\n\n\n\nstatic char z[20];\nstatic int a;\nstatic long long b[131071], c[131071], d[131071];\n\nlong long p1 = 987654321;\nlong long p2[1000];\nlong long p3[50][50];\nlong long p4[500];\nlong long p5[300];\nlong long p6[200];\nlong long p7[100];\n\nstatic void q() {\n    memset(d, 0, sizeof(d));\n}\n\nstatic long long r(int e, int f, int g, int h, int i, int j) {\n    long long k = i;\n    k = k * 1000000000LL + j;\n    k = k * 100 + e;\n    k = k * 3 + f;\n    k = k * 3 + g;\n    k = k * 3 + h;\n    return k;\n}\n\nstatic long long s1(int e, int f, int g, int h, int i, int j) {\n    if (e == a) {\n        if (!g) return 0;\n        if (h) return 1;\n        return (j % i == 0) ? 1LL : 0LL;\n    }\n\n    long long k = r(e, f, g, h, i, j);\n    int m = (int)(k % 131071);\n    for (; d[m] && b[m] != k; m = (m + 1) % 131071);\n    if (d[m]) return c[m];\n\n    long long n = 0;\n    int o = (f ? z[e] - '0' : 9);\n    int p = 0;\n    while (p <= o) {\n        int q1 = (f && (p == o)) ? 1 : 0;\n        if (!g) {\n            n += (p == 0) ? s1(e + 1, q1, 0, 0, 0, 1) : s1(e + 1, q1, 1, 0, p, p);\n        } else {\n            int r1 = (j == 0 ? 0 : j * p);\n            n += (p == 0) ? s1(e + 1, q1, 1, 1, i, 0) : s1(e + 1, q1, 1, h, i + p, r1);\n        }\n        p++;\n    }\n\n    d[m] = 1;\n    b[m] = k;\n    c[m] = n;\n    return n;\n}\n\nstatic long long t(int u) {\n    if (u <= 0) return 0;\n    sprintf(z, \"%d\", u);\n    a = (int)strlen(z);\n    q();\n    return s1(0, 1, 0, 0, 0, 1);\n}\n\nint beautifulNumbers(int v, int w) {\n    long long x = t(w) - t(v - 1);\n    return (int)x;\n}\n","author":"Shubhra Awasthi","submissionId":"1575096516"},[]]},{"1":[{"id":"1","fileName":"1575094772.txt","sourceCode":"import sys\nsys.setrecursionlimit(10**7)\nfrom functools import lru_cache\n\nfactor_digit = []\ndef prime_factor_2_3_5_7(d):\n    c2 = c3 = c5 = c7 = 0\n    if d == 0:\n        return (0,0,0,0)\n    while d % 2 == 0:\n        c2 += 1\n        d //= 2\n    while d % 3 == 0:\n        c3 += 1\n        d //= 3\n    while d % 5 == 0:\n        c5 += 1\n        d //= 5\n    while d % 7 == 0:\n        c7 += 1\n        d //= 7\n    return (c2, c3, c5, c7)\n\nfor digit in range(10):\n    factor_digit.append(prime_factor_2_3_5_7(digit))\n\nMAX2, MAX3, MAX5, MAX7 = 6, 4, 2, 2\ndef clamp_ex2(x): return x if x <= MAX2 else MAX2\ndef clamp_ex3(x): return x if x <= MAX3 else MAX3\ndef clamp_ex5(x): return x if x <= MAX5 else MAX5\ndef clamp_ex7(x): return x if x <= MAX7 else MAX7\n\nsumFactor = [(-1, -1, -1, -1)] * 82\ndef factor_sum_in_2_3_5_7(s):\n    if s == 0:\n        return None\n    tmp = s\n    c2 = c3 = c5 = c7 = 0\n    for _ in range(100):\n        if tmp % 2 == 0:\n            c2 += 1\n            tmp //= 2\n        elif tmp % 3 == 0:\n            c3 += 1\n            tmp //= 3\n        elif tmp % 5 == 0:\n            c5 += 1\n            tmp //= 5\n        elif tmp % 7 == 0:\n            c7 += 1\n            tmp //= 7\n        else:\n            break\n    if tmp == 1:\n        return (c2, c3, c5, c7)\n    return None\n\ntmp_arr = []\nfor s in range(82):\n    if s == 0:\n        tmp_arr.append((-1, -1, -1, -1))\n    else:\n        fs = factor_sum_in_2_3_5_7(s)\n        if fs is None:\n            tmp_arr.append((-1, -1, -1, -1))\n        else:\n            tmp_arr.append(fs)\nsumFactor = tmp_arr\n\ndef getDigits(x: int) -> list:\n    return list(map(int, str(x)))\n\n@lru_cache(None)\ndef countNoZero_dp(digs, pos, isLimit, hasStarted):\n    if pos == len(digs):\n        return 1 if hasStarted else 0\n    limit = digs[pos] if isLimit else 9\n    total = 0\n    for d in range(limit+1):\n        if d == 0:\n            if hasStarted:\n                continue\n            total += countNoZero_dp(digs, pos+1, isLimit and (d == limit), False)\n        else:\n            total += countNoZero_dp(digs, pos+1, isLimit and (d == limit), True)\n    return total\n\ndef countNoZero(N: int) -> int:\n    if N < 1:\n        return 0\n    ds = getDigits(N)\n    return countNoZero_dp(tuple(ds), 0, True, False)\n\n@lru_cache(None)\ndef noZeroBeautiful_dp(digs, pos, ex2p, ex3p, ex5p, ex7p, sumVal, isLimit, hasStarted):\n    if pos == len(digs):\n        if hasStarted and sumVal > 0:\n            (sx2, sx3, sx5, sx7) = sumFactor[sumVal]\n            if sx2 == -1:\n                return 0\n            if (ex2p >= sx2) and (ex3p >= sx3) and (ex5p >= sx5) and (ex7p >= sx7):\n                return 1\n        return 0\n    limit = digs[pos] if isLimit else 9\n    total = 0\n    for d in range(limit+1):\n        if hasStarted:\n            if d == 0:\n                continue\n            f2, f3, f5, f7 = factor_digit[d]\n            new_ex2 = clamp_ex2(ex2p + f2)\n            new_ex3 = clamp_ex3(ex3p + f3)\n            new_ex5 = clamp_ex5(ex5p + f5)\n            new_ex7 = clamp_ex7(ex7p + f7)\n            new_sum = sumVal + d\n            if new_sum > 81:\n                break\n            total += noZeroBeautiful_dp(digs, pos+1, new_ex2, new_ex3, new_ex5, new_ex7,\n                                        new_sum, isLimit and (d == limit), True)\n        else:\n            if d == 0:\n                total += noZeroBeautiful_dp(digs, pos+1, ex2p, ex3p, ex5p, ex7p,\n                                            sumVal, isLimit and (d == limit), False)\n            else:\n                f2, f3, f5, f7 = factor_digit[d]\n                new_ex2 = clamp_ex2(ex2p + f2)\n                new_ex3 = clamp_ex3(ex3p + f3)\n                new_ex5 = clamp_ex5(ex5p + f5)\n                new_ex7 = clamp_ex7(ex7p + f7)\n                new_sum = sumVal + d\n                if new_sum > 81:\n                    break\n                total += noZeroBeautiful_dp(digs, pos+1, new_ex2, new_ex3, new_ex5, new_ex7,\n                                            new_sum, isLimit and (d == limit), True)\n    return total\n\ndef countNoZeroBeautiful(N: int) -> int:\n    if N < 1:\n        return 0\n    ds = getDigits(N)\n    return noZeroBeautiful_dp(tuple(ds), 0, 0, 0, 0, 0, 0, True, False)\n\ndef F(x: int) -> int:\n    if x < 1:\n        return 0\n    nozero_count = countNoZero(x)\n    nozero_beautiful_count = countNoZeroBeautiful(x)\n    return nozero_beautiful_count + (x - nozero_count)\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return F(r) - F(l-1)","author":"8iRTeedKTz","submissionId":"1575094772"},[]]},{"2":[{"id":"2","fileName":"1575090798.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, u: int, v: int) -> int:\n        def k(n):\n            if n < 1: return 0\n            d = list(map(int, str(n)))\n            m = len(d)\n            @lru_cache(maxsize=None)\n            def f(i, t, st, z, S, pr):\n                if i == m:\n                    if not st: return 0\n                    return 1 if z or (pr % S == 0) else 0\n                L = d[i] if t else 9\n                r_ = 0\n                for j in range(L + 1):\n                    nt = t and (j == L)\n                    if not st:\n                        if j == 0:\n                            r_ += f(i + 1, nt, False, False, 0, 1)\n                        else:\n                            r_ += f(i + 1, nt, True, False, j, j)\n                    else:\n                        if j == 0:\n                            r_ += f(i + 1, nt, True, True, S, 0)\n                        else:\n                            r_ += f(i + 1, nt, True, z, S + j, (0 if z else pr * j))\n                return r_\n            return f(0, True, False, False, 0, 1)\n        return k(v) - k(u - 1)","author":"G8QN4k9HON","submissionId":"1575090798"},[]]},{"3":[{"id":"3","fileName":"1575100494.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        from functools import cache\n        valid_sums = {}\n        for s in range(1, 82):\n            temp = s\n            cnt2 = cnt3 = cnt5 = cnt7 = 0\n            for p in (2, 3, 5, 7):\n                while temp % p == 0:\n                    if p == 2:\n                        cnt2 += 1\n                    elif p == 3:\n                        cnt3 += 1\n                    elif p == 5:\n                        cnt5 += 1\n                    else:\n                        cnt7 += 1\n                    temp //= p\n            if temp == 1:\n                valid_sums[s] = (cnt2, cnt3, cnt5, cnt7)\n        fac = {0: None, 1: (0, 0, 0, 0), 2: (1, 0, 0, 0), 3: (0, 1, 0, 0), 4: (2, 0, 0, 0), 5: (0, 0, 1, 0), 6: (1, 1, 0, 0), 7: (0, 0, 0, 1), 8: (3, 0, 0, 0), 9: (0, 2, 0, 0)}\n        def count(n):\n            s_n = str(n)\n            N = len(s_n)\n            @cache\n            def dp(pos, tight, started, zero_flag, s_val, a, b, c, d):\n                if pos == N:\n                    if not started or s_val == 0:\n                        return 0\n                    if zero_flag:\n                        return 1\n                    if s_val not in valid_sums:\n                        return 0\n                    r2, r3, r5, r7 = valid_sums[s_val]\n                    return 1 if (a >= r2 and b >= r3 and c >= r5 and d >= r7) else 0\n                res = 0\n                up = int(s_n[pos]) if tight else 9\n                for dig in range(up + 1):\n                    ntight = tight and (dig == up)\n                    if not started:\n                        if dig == 0:\n                            res += dp(pos + 1, ntight, False, False, 0, 0, 0, 0, 0)\n                        else:\n                            nf = fac[dig]\n                            res += dp(pos + 1, ntight, True, False, dig, nf[0], nf[1], nf[2], nf[3])\n                    else:\n                        ns = s_val + dig\n                        if zero_flag or dig == 0:\n                            res += dp(pos + 1, ntight, True, True, ns, 0, 0, 0, 0)\n                        else:\n                            nf = fac[dig]\n                            res += dp(pos + 1, ntight, True, False, ns, a + nf[0], b + nf[1], c + nf[2], d + nf[3])\n                return res\n            return dp(0, True, False, False, 0, 0, 0, 0, 0)\n        return count(r) - (count(l - 1) if l else 0)","author":"Abhishek Choudhary","submissionId":"1575100494"},[]]},{"4":[{"id":"4","fileName":"1575104412.txt","sourceCode":"\tclass Solution {\n\t\tpublic int beautifulNumbers(int l, int r) {\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1; i <= 81; i++) {\n\t\t\t\tans += countBy2D(r, i) - countBy2D(l - 1, i);\n\t\t\t}\n\t\t\treturn (int) ans;\n\t\t}\n\n\t\tpublic static long countBy2D(long n, int K) {\n\t\t\tn++;\n\t\t\tchar[] s = (\"\" + n).toCharArray();\n\t\t\tint m = s.length;\n\n\t\t\t// lim, initial edge, (current edge)\n\t\t\tint D0 = K, e0i = 1 % K, e0 = e0i; //\n\t\t\tint D1 = 82, e1i = 0, e1 = e1i; //\n\t\t\tlong[][] num = new long[D0][D1];\n\t\t\tIntBinaryOperator t0 = (x, d) -> x * d % K;\n\t\t\tIntBinaryOperator t1 = (x, d) -> x + d;\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint d = s[i] - '0';\n\t\t\t\tlong[][] nnum = new long[D0][D1];\n\t\t\t\tfor (int j = 0; j < D0; j++) {\n\t\t\t\t\tfor (int k = 0; k < D1; k++) {\n\t\t\t\t\t\tif (num[j][k] == 0) continue;\n\t\t\t\t\t\tfor (int l = 0; l < 10; l++) {\n\t\t\t\t\t\t\tint nj = t0.applyAsInt(j, l);\n\t\t\t\t\t\t\tint nk = t1.applyAsInt(k, l);\n\t\t\t\t\t\t\tnnum[nj][nk] += num[j][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tfor (int j = 1; j < d; j++) {\n\t\t\t\t\t\tint nj = t0.applyAsInt(e0i, j);\n\t\t\t\t\t\tint nk = t1.applyAsInt(e1i, j);\n\t\t\t\t\t\tnnum[nj][nk]++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (int j = 0; j < d; j++) {\n\t\t\t\t\t\tint nj = t0.applyAsInt(e0, j);\n\t\t\t\t\t\tint nk = t1.applyAsInt(e1, j);\n\t\t\t\t\t\tnnum[nj][nk]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = 1; j <= 9; j++) {\n\t\t\t\t\t\tint nj = t0.applyAsInt(e0i, j);\n\t\t\t\t\t\tint nk = t1.applyAsInt(e1i, j);\n\t\t\t\t\t\tnnum[nj][nk]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\te0 = t0.applyAsInt(e0, d);\n\t\t\t\te1 = t1.applyAsInt(e1, d);\n\t\t\t\tnum = nnum;\n\t\t\t}\n\t\t\t//\n\t\t\treturn num[0][K];\n\t\t}\n\t}\n","author":"uwi","submissionId":"1575104412"},[]]},{"5":[{"id":"5","fileName":"1575106621.txt","sourceCode":"from functools import lru_cache\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def cb(num: int) -> int:\n            ns = str(num)\n\n            @lru_cache(None)\n            def uc(rem: int, p: int, sm: int) -> int:\n                if rem == 0:\n                    return 1 if sm and p % sm == 0 else 0\n                tot = 0\n                for d in range(10):\n                    tot += uc(rem - 1, p * d, sm + d)\n                return tot\n\n            @lru_cache(None)\n            def cs(i: int, less: bool, p: int, sm: int) -> int:\n                if i == len(ns):\n                    return 1 if sm and p % sm == 0 else 0\n\n                if less:\n                    if sm == 0:\n                        tot = cs(i + 1, True, 0, 0)\n                        for d in range(1, 10):\n                            tot += uc(len(ns) - i - 1, d, d)\n                        return tot\n                    else:\n                        return uc(len(ns) - i, p, sm)\n\n                cur = int(ns[i])\n                np_val = cur if i == 0 else p * cur\n                tot = cs(i + 1, False, np_val, sm + cur)\n                for d in range(cur):\n                    np_val = d if i == 0 else p * d\n                    tot += cs(i + 1, True, np_val, sm + d)\n                return tot\n\n            return cs(0, False, 0, 0)\n\n        return cb(r) - cb(l - 1)","author":"All","submissionId":"1575106621"},[]]},{"6":[{"id":"6","fileName":"1575085194.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def g(x):\n            return list(map(int, str(x)))\n        from functools import lru_cache\n        def h(x):\n            d = g(x)\n            @lru_cache(maxsize=None)\n            def f(i, t, st):\n                if i == len(d): return 1 if st else 0\n                a = 0\n                m = d[i] if t else 9\n                for j in range(m + 1):\n                    nt = t and (j == m)\n                    if not st and j == 0:\n                        a += f(i + 1, nt, False)\n                    else:\n                        if j == 0: continue\n                        a += f(i + 1, nt, True)\n                return a\n            return f(0, True, False)\n        def k(x):\n            d = g(x)\n            @lru_cache(maxsize=None)\n            def f(i, t, st, s, p):\n                if i == len(d): return 1 if st and p % s == 0 else 0\n                a = 0\n                m = d[i] if t else 9\n                for j in range(m + 1):\n                    nt = t and (j == m)\n                    if not st and j == 0:\n                        a += f(i + 1, nt, False, s, p)\n                    else:\n                        if j == 0: continue\n                        a += f(i + 1, nt, True, s + j, p * j)\n                return a\n            return f(0, True, False, 0, 1)\n        def c(x):\n            if x <= 0: return 0\n            return x - h(x) + k(x)\n        return c(r) - c(l - 1)\n","author":"twitch_tv_patshelloworld","submissionId":"1575085194"},[]]},{"8":[{"id":"8","fileName":"1575108323.txt","sourceCode":"struct TupleHash {\n    template <typename... T>\n    size_t operator()(const std::tuple<T...>& tpl) const {\n        return std::apply([](auto&&... args) {\n            size_t hashValue = 0;\n            ((hashValue ^= std::hash<std::decay_t<decltype(args)>>{}(args) + 0x9e3779b9 + (hashValue << 6) + (hashValue >> 2)), ...);\n            return hashValue;\n        }, tpl);\n    }\n};\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        long long result = countUpToBound(r) - countUpToBound(l - 1);\n        return (int)result;\n    }\n    \nprivate:\n    string numStr;  \n    int len;        \n\n    unordered_map<tuple<int, int, int, int, int>, long long,TupleHash> dpCacheNonZero;\n    \n\n    long long dfsNonZeroBeautiful(int index, int restricted, int begun, int currentSum, int currentProduct) {\n        if (index == len) {\n            return (begun && currentSum != 0 && (currentProduct % currentSum == 0)) ? 1LL : 0LL;\n        }\n        auto state = make_tuple(index, restricted, begun, currentSum, currentProduct);\n        if (dpCacheNonZero.find(state) != dpCacheNonZero.end())\n            return dpCacheNonZero[state];\n        long long count = 0;\n        int maxDigit = restricted ? numStr[index] - '0' : 9;\n        for (int digit = 0; digit <= maxDigit; digit++) {\n            if (!begun) {\n\n                if (digit == 0) {\n                    count += dfsNonZeroBeautiful(index + 1, (restricted && digit == maxDigit), 0, currentSum, currentProduct);\n                } else {\n                    count += dfsNonZeroBeautiful(index + 1, (restricted && digit == maxDigit), 1, currentSum + digit, currentProduct * digit);\n                }\n            } else {\n\n                if (digit == 0) continue;\n                count += dfsNonZeroBeautiful(index + 1, (restricted && digit == maxDigit), 1, currentSum + digit, currentProduct * digit);\n            }\n        }\n        dpCacheNonZero[state] = count;\n        return count;\n    }\n    \n\n    unordered_map<tuple<int, int, int>, long long,TupleHash> dpCacheNoZero;\n    \n\n    long long dfsCountNoZero(int index, int restricted, int begun) {\n        if (index == len)\n            return (begun ? 1LL : 0LL);\n        auto state = make_tuple(index, restricted, begun);\n        if (dpCacheNoZero.find(state) != dpCacheNoZero.end())\n            return dpCacheNoZero[state];\n        long long count = 0;\n        int maxDigit = restricted ? numStr[index] - '0' : 9;\n        for (int digit = 0; digit <= maxDigit; digit++) {\n            if (!begun) {\n                if (digit == 0) {\n                    count += dfsCountNoZero(index + 1, (restricted && digit == maxDigit), 0);\n                } else {\n                    count += dfsCountNoZero(index + 1, (restricted && digit == maxDigit), 1);\n                }\n            } else {\n                if (digit == 0) continue;\n                count += dfsCountNoZero(index + 1, (restricted && digit == maxDigit), 1);\n            }\n        }\n        dpCacheNoZero[state] = count;\n        return count;\n    }\n    \n    long long countUpToBound(long long bound) {\n        if (bound <= 0) return 0;\n        numStr = to_string(bound);\n        len = numStr.size();\n        dpCacheNonZero.clear();\n        dpCacheNoZero.clear();\n        long long countNonZeroBeautiful = dfsNonZeroBeautiful(0, 1, 0, 0, 1);\n        long long countNoZero = dfsCountNoZero(0, 1, 0);\n        long long totalNumbers = bound;\n        return (totalNumbers - countNoZero) + countNonZeroBeautiful;\n    }\n};","author":"Keshav__2006","submissionId":"1575108323"},[]]},{"9":[{"id":"9","fileName":"1575108630.txt","sourceCode":"class Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        auto F = [&](int x) -> long long {\n            if(x < 1) return 0;\n            string s = to_string(x);\n            int n = s.size();\n \n            long long dp0[20][2][2][2] = {}; \n            for (int i = 0; i < 20; i++) for (int a = 0; a < 2; a++) for (int b = 0; b < 2; b++) for (int c = 0; c < 2; c++)\n                dp0[i][a][b][c] = -1;\n \n            function<long long(int,int,int,int)> f0 = [&](int pos, int tight, int started, int hasZero) -> long long {\n                if(pos == n) return (started && hasZero) ? 1LL : 0LL;\n                if(dp0[pos][tight][started][hasZero] != -1) return dp0[pos][tight][started][hasZero];\n                int limit = tight ? s[pos]-'0' : 9;\n                long long res = 0;\n                for (int d = 0; d <= limit; d++){\n                    int ntight = (tight && d==limit);\n                    int nstarted = started || (d > 0);\n                    int nhasZero = hasZero;\n                    if(nstarted && d==0) nhasZero = 1;\n                    res += f0(pos+1, ntight, nstarted, nhasZero);\n                }\n                dp0[pos][tight][started][hasZero] = res;\n                return res;\n            };\n \n            unordered_map<long long, long long> memo;\n            function<long long(int,int,int,int,int)> f1 = [&](int pos, int tight, int started, int sum, int prod) -> long long {\n                if(pos == n) {\n                    if(!started) return 0;\n                    return (sum != 0 && prod % sum == 0) ? 1LL : 0LL;\n                }\n                long long key = (((((long long)pos * 3 + tight)*3 + started)*100 + sum)*1000000LL + prod);\n                if(memo.count(key)) return memo[key];\n                int limit = tight ? s[pos]-'0' : 9;\n                long long res = 0;\n                for (int d = 0; d <= limit; d++){\n                    int ntight = (tight && d==limit);\n                    if(started){\n                        if(d==0) continue;\n                        res += f1(pos+1, ntight, 1, sum+d, prod*d);\n                    } else {\n                        if(d==0) {\n                            res += f1(pos+1, ntight, 0, 0, 1);\n                        } else {\n                            res += f1(pos+1, ntight, 1, d, d);\n                        }\n                    }\n                }\n                memo[key] = res;\n                return res;\n            };\n \n            long long countZero = f0(0,1,0,0);\n            memo.clear();\n            long long countNoZero = f1(0,1,0,0,1);\n            return countZero + countNoZero;\n        };\n \n        long long ans = F(r) - F(l - 1);\n        return (int)ans;\n    }\n};","author":"IronSpidy","submissionId":"1575108630"},[]]},{"10":[{"id":"10","fileName":"1575109943.txt","sourceCode":"class DigitDP:\n    def __init__(self, digits):\n        self.digits = digits\n        self.n = len(digits)\n        self.memo = {}\n    def dp(self, pos, tight, started, has_zero, s, p):\n        if pos == self.n:\n            if not started:\n                return 0\n            return 1 if (has_zero or (p % s == 0)) else 0\n        key = (pos, tight, started, has_zero, s, p)\n        if key in self.memo:\n            return self.memo[key]\n        res = 0\n        limit = self.digits[pos] if tight else 9\n        for d in range(limit + 1):\n            nt = tight and (d == limit)\n            ns = s\n            np = p\n            nstarted = started or (d != 0)\n            nhas_zero = has_zero\n            if not nstarted:\n                res += self.dp(pos + 1, nt, False, False, 0, 1)\n            else:\n                if d == 0:\n                    nhas_zero = True\n                    np = 0\n                else:\n                    if not nhas_zero:\n                        ns += d\n                        np *= d\n                res += self.dp(pos + 1, nt, True, nhas_zero, ns, np)\n        self.memo[key] = res\n        return res\n    def count(self):\n        return self.dp(0, True, False, False, 0, 1)\n\nclass BeautifulChecker:\n    def is_beautiful(self, s, p, has_zero):\n        return has_zero or (p % s == 0)\n\nclass BeautifulCounterDP:\n    def count_beautiful(self, n):\n        digs = list(map(int, str(n)))\n        dp_solver = DigitDP(digs)\n        return dp_solver.count()\n\nclass RangeCounter:\n    def count_range(self, l, r):\n        counter = BeautifulCounterDP()\n        return counter.count_beautiful(r) - (counter.count_beautiful(l - 1) if l > 1 else 0)\n\nclass Utility:\n    def to_int(self, s):\n        return int(s)\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        range_counter = RangeCounter()\n        return range_counter.count_range(l, r)\n","author":"Vivan Arora","submissionId":"1575109943"},[]]},{"11":[{"id":"11","fileName":"1575109717.txt","sourceCode":"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\n\npublic class Solution {\n    static PrintWriter out;\n    static int inf = (int) 1e9;\n    static int mod = (int) 1e9 + 7;\n\n    public static void main(String[] args) {\n        FastReader in = new FastReader();\n        out = new PrintWriter(System.out);\n        long t = in.nextInt();\n        long test = 1;\n        while (test <= t) {\n            // out.println(solve(in));\n//            solve(in);\n            test++;\n        }\n        out.close();\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------------------*/\n    /*--------------------------------------------------------------------------------------------------------------------------------*/\n//    private static long solve(FastReader in) {\n//\n//    }\n//    private static String solve(FastReader in) {\n//        String yes = \"YES\", no = \"NO\";\n//    }\n//    private static void solve(FastReader in) {\n//\n//    }\n\n    /*--------------------------------------------------------------------------------------------------------------------------------*/\n    /*--------------------------------------------------------------------------------------------------------------------------------*/\n    private static int gcd(int a, int b) {\n        return b == 0 ? a : (gcd(b, a % b));\n    }\n\n    static boolean[] sieveOfEratosthenes(int n) {\n        boolean[] prime = new boolean[n + 1];\n        Arrays.fill(prime, true);\n        prime[0] = prime[1] = false;\n        for (int p = 2; p * p <= n; p++) {\n            if (prime[p]) {\n                for (int i = p * p; i <= n; i += p)\n                    prime[i] = false;\n            }\n        }\n        return prime;\n    }\n\n    static void sort(int[] a) {\n        List<Integer> l = new ArrayList<>();\n        for (int i : a) l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < a.length; i++) a[i] = l.get(i);\n    }\n\n    static long modPow(long a, long b, long m) {\n        long res = 1;\n        a %= m;\n        while (b > 0) {\n            if ((b & 1) != 0) {\n                res = res * a;\n                res %= m;\n            }\n            b >>= 1;\n            a *= a;\n            a %= m;\n        }\n        return res;\n    }\n\n    private static class Pair implements Comparable<Pair> {\n        int ff, ss;\n\n        Pair(int x, int y) {\n            this.ff = x;\n            this.ss = y;\n        }\n\n        public int compareTo(Pair o) {\n            return this.ff == o.ff ? this.ss - o.ss : this.ff - o.ff;\n        }\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(\n                    new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    static int[][] sumreq = new int[82][4];\n    static boolean[] validsum = new boolean[82];\n\n    static {\n        for (int s = 1; s < 82; s++) {\n            int tmp = s;\n            int r2 = 0, r3 = 0, r5 = 0, r7 = 0;\n            int t = tmp;\n            while (t % 2 == 0) {\n                r2++;\n                t /= 2;\n            }\n            while (t % 3 == 0) {\n                r3++;\n                t /= 3;\n            }\n            while (t % 5 == 0) {\n                r5++;\n                t /= 5;\n            }\n            while (t % 7 == 0) {\n                r7++;\n                t /= 7;\n            }\n            validsum[s] = (t == 1);\n            sumreq[s][0] = r2;\n            sumreq[s][1] = r3;\n            sumreq[s][2] = r5;\n            sumreq[s][3] = r7;\n        }\n    }\n\n    static int[][] digitfac = new int[10][5];\n\n    static {\n        digitfac[0] = new int[]{0, 0, 0, 0, 0};\n        digitfac[1] = new int[]{0, 0, 0, 0, 1};\n        digitfac[2] = new int[]{1, 0, 0, 0, 2};\n        digitfac[3] = new int[]{0, 1, 0, 0, 3};\n        digitfac[4] = new int[]{2, 0, 0, 0, 4};\n        digitfac[5] = new int[]{0, 0, 1, 0, 5};\n        digitfac[6] = new int[]{1, 1, 0, 0, 6};\n        digitfac[7] = new int[]{0, 0, 0, 1, 7};\n        digitfac[8] = new int[]{3, 0, 0, 0, 8};\n        digitfac[9] = new int[]{0, 2, 0, 0, 9};\n    }\n\n    String sdig;\n    int nd;\n\n    Map<Integer, Long> memo_nz = new HashMap<>();\n    Map<Integer, Long> memo_b = new HashMap<>();\n\n    public int beautifulNumbers(int l, int r) {\n        long ans = cntB(r) - cntB(l - 1);\n        return (int) ans;\n    }\n\n    public long cntB(int N) {\n        if (N < 1) return 0;\n        long a = cntNZdp(Integer.toString(N));\n        long b = cntBdp(Integer.toString(N));\n        return (long) N - a + b;\n    }\n\n    public long cntNZdp(String s) {\n        sdig = s;\n        nd = sdig.length();\n        memo_nz.clear();\n        return dpnz(0, 1, 0);\n    }\n\n    private long dpnz(int pos, int tight, int st) {\n        if (pos == nd) {\n            return (st == 1) ? 1 : 0;\n        }\n        int key = (pos << 3) | (tight << 2) | st;\n        if (memo_nz.containsKey(key))\n            return memo_nz.get(key);\n        long res = 0;\n        int lim = (tight == 1) ? sdig.charAt(pos) - '0' : 9;\n        for (int d = 0; d <= lim; d++) {\n            int nt = (tight == 1 && d == lim) ? 1 : 0;\n            if (st == 0) {\n                if (d == 0)\n                    res += dpnz(pos + 1, nt, 0);\n                else\n                    res += dpnz(pos + 1, nt, 1);\n            } else {\n                if (d == 0) continue;\n                res += dpnz(pos + 1, nt, 1);\n            }\n        }\n        memo_nz.put(key, res);\n        return res;\n    }\n\n    public long cntBdp(String nstr) {\n        sdig = nstr;\n        nd = sdig.length();\n        memo_b.clear();\n        return dpb(0, 1, 0, 0, 0, 0, 0, 0);\n    }\n\n    private long dpb(int pos, int tight, int st, int sum, int a, int b, int c, int d) {\n        if (pos == nd) {\n            if (st == 0) return 0;\n            if (sum < 1) return 0;\n            if (!validsum[sum]) return 0;\n            int r2 = sumreq[sum][0];\n            int r3 = sumreq[sum][1];\n            int r5 = sumreq[sum][2];\n            int r7 = sumreq[sum][3];\n            return (a >= r2 && b >= r3 && c >= r5 && d >= r7) ? 1 : 0;\n        }\n        int key = pack(pos, tight, st, sum, a, b, c, d);\n        if (memo_b.containsKey(key))\n            return memo_b.get(key);\n        long res = 0;\n        int lim = (tight == 1) ? sdig.charAt(pos) - '0' : 9;\n        for (int dgt = 0; dgt <= lim; dgt++) {\n            int nt = (tight == 1 && dgt == lim) ? 1 : 0;\n            if (st == 0) {\n                if (dgt == 0)\n                    res += dpb(pos + 1, nt, 0, sum, a, b, c, d);\n                else {\n                    res = helper(pos, sum, a, b, c, d, res, dgt, nt);\n                }\n            } else {\n                if (dgt == 0) continue;\n                res = helper(pos, sum, a, b, c, d, res, dgt, nt);\n            }\n        }\n        memo_b.put(key, res);\n        return res;\n    }\n\n    private long helper(int pos, int sum, int a, int b, int c, int d, long res, int dgt, int nt) {\n        int ns = sum + dgt;\n        int na = a + digitfac[dgt][0];\n        int nb = b + digitfac[dgt][1];\n        int nc = c + digitfac[dgt][2];\n        int ndp = d + digitfac[dgt][3];\n        res += dpb(pos + 1, nt, 1, ns, na, nb, nc, ndp);\n        return res;\n    }\n\n    private int pack(int pos, int tight, int st, int sum, int a, int b, int c, int d) {\n        int key = pos;\n        key |= (tight << 5);\n        key |= (st << 6);\n        key |= (sum << 7);\n        key |= (a << 14);\n        key |= (b << 19);\n        key |= (c << 24);\n        key |= (d << 28);\n        return key;\n    }\n}","author":"mk17","submissionId":"1575109717"},[]]},{"12":[{"id":"12","fileName":"1575110707.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, n) for (lli i = (a); i < (n); ++i)\n#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define sz(a) ((int)a.size())\n#define YES cout << \"YES\" << endl;\n#define NO cout << \"NO\" << endl;\n// #define endl 'n'\n#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);\n#define pb push_back\n#define pp pop_back()\n#define fi first\n#define si second\n#define v(a) vector<int>(a)\n#define vv(a) vector<vector<int>>(a)\n#define present(c, x) ((c).find(x) != (c).end())\n#define set_bits __builtin_popcountll\n#define MOD 1000000007\n// #define int long long\n\ntypedef long long lli;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<lli, lli> pll;\ntypedef pair<int, int> pii;\ntypedef unordered_map<int, int> umpi;\ntypedef map<int, int> mpi;\ntypedef vector<pii> vp;\ntypedef vector<lli> vll;\ntypedef vector<vll> vvll;\n\nclass Solution {\n    int rec(string &s, int pos, bool tight, bool started, int prod, int sum) {\n        if (pos == s.size())\n            return (started && sum != 0 && prod % sum == 0) ? 1 : 0;\n        \n        string key = get(pos, tight, started, prod, sum);\n        if (memo.count(key)) return memo[key];\n        \n        int res = 0;\n        int limit = tight ? (s[pos] - '0') : 9;\n        for (int dig = 0; dig <= limit; dig++) {\n            bool n_tight = tight && (dig == limit);\n            bool n_started = started || (dig != 0);\n            int n_prod = n_started ? (started ? prod * dig : dig) : 1;\n            int n_sum = n_started ? (sum + dig) : 0;\n            res += rec(s, pos + 1, n_tight, n_started, n_prod, n_sum);\n        }\n        \n        memo[key] = res;\n        return res;\n    }\n    \n    int ff(int n) {\n        if(n) {\n        string s = to_string(n);\n        memo.clear();\n        return rec(s, 0, true, false, 1, 0);}\n        return 0;\n    }\n    \npublic:\n    int beautifulNumbers(int l, int r) {\n        return ff(r) - ff(l - 1);\n    }\n\nprivate:\nunordered_map<string, int> memo;\n    string get(int pos, bool tight, bool started, int prod, int sum) {\n        return to_string(pos) + \"_\" + to_string(tight) + \"_\" + to_string(started) + \"_\" + to_string(prod) + \"_\" + to_string(sum);\n    }\n};","author":"Aaryan Saraswat","submissionId":"1575110707"},[]]},{"14":[{"id":"14","fileName":"1575110469.txt","sourceCode":"class Solution {\n    fun beautifulNumbers(l: Int, r: Int): Int = countBeautiful(r) - countBeautiful(l - 1)\n\n    private fun dp(\n        digits: List<Int>, \n        state: State, \n        memo: MutableMap<State, Int>\n    ): Int =\n        memo.getOrPut(state) {\n            when {\n                state.pos == digits.size -> if (state.started && (state.zeroFound || state.product % state.sum == 0)) 1 else 0\n                else -> (0..if (state.tight) digits[state.pos] else 9).sumOf { digit ->\n                    val newTight = state.tight && (digit == digits[state.pos])\n                    if (!state.started && digit == 0)\n                        dp(digits, state.copy(pos = state.pos + 1, tight = newTight), memo)\n                    else {\n                        val hasZero = state.zeroFound || digit == 0\n                        dp(\n                            digits,\n                            state.copy(\n                                pos = state.pos + 1,\n                                tight = newTight,\n                                started = true,\n                                zeroFound = hasZero,\n                                sum = state.sum + digit,\n                                product = if (hasZero) 0 else state.product * digit\n                            ),\n                            memo\n                        )\n                    }\n                }\n            }\n        }\n    \n    private fun countBeautiful(x: Int): Int =\n        if (x <= 0) 0 else dp(\n            digits = x.toString().map { it - '0' },\n            state = State(\n                pos = 0,\n                tight = true,\n                started = false,\n                zeroFound = false,\n                sum = 0,\n                product = 1\n            ),\n            memo = mutableMapOf()\n        )\n    \n    data class State(\n        val pos: Int,\n        val tight: Boolean,\n        val started: Boolean,\n        val zeroFound: Boolean,\n        val sum: Int,\n        val product: Int\n    )\n}","author":"Mukhamed Issa","submissionId":"1575110469"},[]]},{"15":[{"id":"15","fileName":"1575113773.txt","sourceCode":"class Solution {\npublic:\n    int cal(int r){\n        char c[15];\n        sprintf(c,\"%d\",r);\n        int ans=0;\n        int n=strlen(c);\n        for(int mod = 1;mod<=81;mod++){\n            int dp[10][81][82];\n            memset(dp,0,sizeof(dp));\n            int pro=1,sum=0;\n            for(int i = 0;c[i]!=0;i++){\n                for(int j = 0;j<c[i]-'0';j++){\n                    if(i==0&&j==0)continue;\n                    dp[i][pro*j%mod][sum+j]++;\n                }\n                pro=pro*(c[i]-'0')%mod;\n                sum=sum+c[i]-'0';\n            }\n            for(int i = 1;c[i]!=0;i++){\n                for(int j = 1;j<=9;j++)\n                dp[i][j%mod][j]++;\n            }\n            for(int i = 0;c[i+1]!=0;i++){\n                for(int j = 0;j<=9;j++){\n                    for(int x=0;x<mod;x++){\n                        for(int y=0;y<=81;y++){\n                            if(dp[i][x][y]){\n                                dp[i+1][x*j%mod][y+j]+=dp[i][x][y];\n                            }\n                        }\n                    }\n                }\n            }\n            ans+=dp[n-1][0][mod];\n        }\n        return ans;\n    }\n    int beautifulNumbers(int l, int r) {\n        return cal(r+1)-cal(l);\n    }\n};","author":"hank55663","submissionId":"1575113773"},[]]},{"16":[{"id":"16","fileName":"1575105015.txt","sourceCode":"class Solution:\n    def count_beautiful(self, n: int) -> int:\n        if n < 1:\n            return 0\n        s = str(n)\n        digin = len(s)\n        from functools import lru_cache\n    \n        @lru_cache(maxsize=None)\n        def dp(pos: int, tight: bool, st: bool, c0: bool, ssum: int, prod: int) -> int:\n            if pos == digin:\n                if not st:\n                    return 0\n                if c0:\n                    return 1\n                return 1 if (prod % ssum == 0) else 0\n            \n            limit = int(s[pos]) if tight else 9\n            total = 0\n            for d in range(0, limit + 1):\n                ntight = tight and (d == limit)\n                if not st:\n                    if d == 0:\n                        total += dp(pos + 1, ntight, False, False, 0, 1)\n                    else:\n                        total += dp(pos + 1, ntight, True, False, d, d)\n                else:\n                    if c0:\n                        total += dp(pos + 1, ntight, True, True, 0, 0)\n                    else:\n                        if d == 0:\n                            total += dp(pos + 1, ntight, True, True, 0, 0)\n                        else:\n                            total += dp(pos + 1, ntight, True, False, ssum + d, prod * d)\n            return total\n    \n        return dp(0, True, False, False, 0, 1)\n    \n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return self.count_beautiful(r) - self.count_beautiful(l - 1)","author":"AlgoNExpl","submissionId":"1575105015"},[]]},{"17":[{"id":"17","fileName":"1575114716.txt","sourceCode":"class Solution {\n    public int beautifulNumbers(int l, int r) {\n        long ans = fo(r) - fo(l - 1);\n        return (int) ans;\n    }\n    public static long fo(int x) {\n        if (x < 0) return 0;\n        String s = Integer.toString(x);\n        int n = s.length();\n        int[] ar = new int[n];\n        for (int i = 0; i < n; i++) {\n            ar[i] = s.charAt(i) - '0';\n        }\n        HashMap<Long, Long> memo = new HashMap<>();\n        return recur(0, 1, 0, 0, 0, 1, ar, memo);\n    }\n\n    public static long recur(int pos, int tight, int s, int hasZero, int sum, int prod,\n                             int[] digits, HashMap<Long, Long> memo) {\n        int n = digits.length;\n        if (pos == n) {\n            if (s == 1) {\n                if (hasZero == 1) return 1;\n                else return (sum != 0 && prod % sum == 0) ? 1 : 0;\n            }\n            return 0;\n        }\n        \n        int y = digits[pos];\n        for (int i = 0; i < 100; i++) {\n            if (y % 2 == 0) {\n                y /= 2;\n            } else {\n                break;\n            }\n        }\n\n        if (s == 1 && hasZero == 1 && tight == 0) {\n            int remaining = n - pos;\n            long ways = 1;\n            for (int i = 0; i < remaining; i++) {\n                ways *= 10;\n            }\n            return ways;\n        }\n\n        long key = encodeState(pos, tight, s, hasZero, sum, prod);\n        if (memo.containsKey(key)) return memo.get(key);\n\n        long res = 0;\n        int limit = (tight == 1 ? digits[pos] : 9);\n        for (int d = 0; d <= limit; d++) {\n            int ntight = (tight == 1 && d == limit) ? 1 : 0;\n            int nstarted = s;\n            int nHasZero = hasZero;\n            int nSum = sum;\n            int nProd = prod;\n\n            if (s == 0) {\n                if (d == 0) {\n                    nstarted = 0;\n                } else {\n                    nstarted = 1;\n                    nSum = d;\n                    nProd = d;\n                }\n            } else {\n                if (d == 0) {\n                    nHasZero = 1;\n                    nProd = 0;\n                } else {\n                    nSum = sum + d;\n                    nProd = prod * d;\n                }\n            }\n            res += recur(pos + 1, ntight, nstarted, nHasZero, nSum, nProd, digits, memo);\n        }\n        memo.put(key, res);\n        return res;\n    }\n\n    public static long encodeState(int pos, int tight, int started, int hasZero, int sum, int prod) {\n        long key = pos;\n        key = key * 2 + tight;\n        key = key * 2 + started;\n        key = key * 2 + hasZero;\n        key = key * 100 + sum;\n        key = key * 1000000000L + prod;\n        return key;\n    }\n\n    public static boolean solve(int[] nums, int[][] mat, int k) {\n        for (int i = 0; i < nums.length; i++) {\n            int tar = nums[i];\n            boolean[] dp = new boolean[tar + 1];\n            dp[0] = true;\n            for (int j = 0; j < k; j++) {\n                if (mat[j][0] <= i && i <= mat[j][1]) {\n                    int val = mat[j][2];\n                    for (int s = tar; s >= val; s--) {\n                        dp[s] = dp[s] || dp[s - val];\n                    }\n                }\n            }\n            if (!dp[tar]) return false;\n        }\n        return true;\n    }\n\n    public static int searchInTheRotateSortedWithDuplicates(int[] nums, int target) {\n\n        int low = 0, high = nums.length - 1;\n\n        while (low <= high) {\n\n            int mid = low + (high - low) / 2;\n\n            if (nums[mid] == target) {\n                return mid;\n            }\n\n            if (nums[low] == nums[mid] && nums[mid] == nums[high]) {\n                low ++;\n                high --;\n            } else if (nums[low] <= nums[mid]) {\n                if (nums[low] <= target && target < nums[mid]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[high]) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            }\n        }\n        return -1;\n    }\n\n  \n    public static int min(int a, int b) {\n        return a < b ? a : b;\n    }\n    public static int max(int a, int b) {\n        return a > b ? a : b;\n    }\n}","author":"Good_wealth","submissionId":"1575114716"},[]]},{"18":[{"id":"18","fileName":"1575114649.txt","sourceCode":"class Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        return countNums(r) - countNums(l - 1);\n    }\n\nprivate:\n    using ll = long long;\n\n    ll countNums(int n) {\n        if (n <= 0) return 0;\n        vector<int> d;\n        while (n) d.push_back(n % 10), n /= 10;\n        reverse(d.begin(), d.end());\n\n        unordered_map<ll, ll> memo;\n        return dfs(0, 1, 0, 0, 1, d, memo);\n    }\n\n    ll dfs(int i, int t, int s0, int s, int p, \n           const vector<int>& d, unordered_map<ll, ll>& memo) {\n        if (i == d.size()) return s0 && s && (p % s == 0);\n        ll key = i | (t << 6) | (s0 << 7) | (s << 8) | ((ll)p << 16);\n        if (memo.count(key)) return memo[key];\n\n        ll res = 0, lim = t ? d[i] : 9;\n        for (int x = 0; x <= lim; x++) {\n            res += dfs(i + 1, t && (x == lim), s0 || x, s + x * (s0 || x), \n                       s0 ? p * x : x, d, memo);\n        }\n        return memo[key] = res;\n    }\n};","author":"Nimish","submissionId":"1575114649"},[]]},{"19":[{"id":"19","fileName":"1575117430.txt","sourceCode":"from functools import lru_cache\n\nclass Solution:\n    def solveFunc(self):\n        class FenwickTree:\n            def __init__(self, n):\n                self.farr = [0] * (n + 1)\n\n            def prefixSum(self, idx):\n                s = 0\n                while idx > 0:\n                    s += self.farr[idx]\n                    idx -= (idx & -idx)\n                return s\n\n            def update(self, idx, val):\n                while idx < len(self.farr):\n                    self.farr[idx] += val\n                    idx += (idx & -idx)\n\n            def find(self, k):\n                curr = 0\n                ans = 0\n                prevSum = 0\n                for i in range(log2(k), -1, -1):\n                    if self.farr[curr + (i << i)] + prevSum < k:\n                        curr += (1 << i)\n                        prevSum += self.farr[curr]\n                return curr + 1\n    \n    \n    def dx(self, ds):\n        m = len(ds)\n        \n        @lru_cache(maxsize=None)\n        def yf(i, t, s_flag, z_flag, s_val, p_val):\n            if i == m:\n                if not s_flag:\n                    return 0\n                return 1 if z_flag or (p_val % s_val == 0) else 0\n            lim = ds[i] if t else 9\n            tot = 0\n            for d in range(lim + 1):\n                nt = t and (d == lim)\n                if not s_flag:\n                    if d == 0:\n                        tot += yf(i + 1, nt, False, False, 0, 1)\n                    else:\n                        tot += yf(i + 1, nt, True, False, d, d)\n                else:\n                    if d == 0:\n                        tot += yf(i + 1, nt, True, True, s_val, 0)\n                    else:\n                        tot += yf(i + 1, nt, True, z_flag, s_val + d, (0 if z_flag else p_val * d))\n            return tot\n        return yf(0, True, False, False, 0, 1)\n    \n    def zFunction(self, patt, txt):\n        st = patt + \"#\" + txt\n        zArray = [0 for _ in range(len(st))]\n        l = 0\n        r = 0\n        for i in range(1, len(st)):\n            if r >= i:\n                zArray[i] = min(r - i + 1, zArray[i - l])\n            while i + zArray[i] < len(st) and st[zArray[i]] == st[zArray[i] + i]:\n                zArray[i] += 1\n            if zArray[i] + i - 1 > r:\n                l = i\n                r = i + zArray[i] - 1\n        return zArray.count(len(patt))\n\n    \n    def fq(self, n):\n        if n < 1:\n            return 0\n        return self.dx(self.oz(n))\n    \n    def beautifulNumbers(self, l, r):\n        return self.fq(r) - self.fq(l - 1)\n    \n    def oz(self, n):\n        return list(map(int, str(n)))\n    \n    def kmp(self, txt, patt):\n        newString = patt + '#' + txt\n        freqCount = 0\n        freqArray = [0 for _ in range(len(newString))]\n        i = 1\n        length = 0\n        while i < len(newString):\n            if newString[i] == newString[length]:\n                length += 1\n                freqArray[i] = length\n                i += 1\n            else:\n                if length > 0:\n                    length = freqArray[length - 1]\n                else:\n                    freqArray[i] = 0\n                    i += 1\n        for i in freqArray:\n            if i == len(patt):\n                freqCount += 1\n        return freqCount\n    \n    def countVisibleTowers(self, heights):\n        n = len(heights)\n        def nsr(arr):\n            ans = []\n            stack = []\n            for i in range(len(arr) - 1, -1, -1):\n                while stack and stack[-1][1] <= arr[i]:\n                    stack.pop()\n                if not stack:\n                    ans.append(len(arr))\n                else:\n                    ans.append(stack[-1][0])\n                stack.append([i, arr[i]])\n            return ans[::-1]\n        \n        def nsl(arr):\n            ans = []\n            stack = []\n            for i in range(len(arr)):\n                while stack and stack[-1][1] <= arr[i]:\n                    stack.pop()\n                if not stack:\n                    ans.append(-1)\n                else:\n                    ans.append(stack[-1][0])\n                stack.append([i, arr[i]])\n            return ans\n        \n        left = nsl(heights)\n        right = nsr(heights)\n        ans = []\n        for i in range(n):\n            val = i - left[i] - 1 + right[i] - i - 1\n            ans.append(val)\n        return ans\n","author":"4bP7qaO8Qi","submissionId":"1575117430"},[]]},{"20":[{"id":"20","fileName":"1575123967.txt","sourceCode":"class Solution:\n    def count(self, x):\n        digits = list(map(int, str(x)))\n        n, dp = len(digits), {}\n        def helper(num, lower, started, has_zero, s, p):\n            key = (num, lower, started, has_zero, s, p)\n            if key in dp:\n                return dp[key]\n            if num == n:\n                if not started:\n                    return 0\n                dp[key] = 1 if (has_zero or (s and p % s == 0)) else 0\n                return dp[key]\n            ways = 0\n            limit = digits[num] if lower else 9\n            for d in range(limit + 1):\n                new_lower = lower and (d == limit)\n                if not started:\n                    if d == 0:\n                        ways += helper(num + 1, new_lower, False, False, 0, 1)\n                    else:\n                        ways += helper(num + 1, new_lower, True, False, d, d)\n                else:\n                    if d == 0 or has_zero:\n                        ways += helper(num + 1, new_lower, True, True, 0, 1)\n                    else:\n                        ways += helper(num + 1, new_lower, True, False, s + d, p * d)\n            dp[key] = ways\n            return ways\n        \n        return helper(0, True, False, False, 0, 1)   \n        \n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return self.count(r) - self.count(l-1)","author":"Tyler Durden","submissionId":"1575123967"},[]]},{"21":[{"id":"21","fileName":"1575118218.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_up_to(X):\n            sX = str(X)\n            L = len(sX)\n            digits = list(map(int, sX))\n            @lru_cache(maxsize=None)\n            def dp(pos, tight, started, has_zero, s, p):\n                if pos == L:\n                    if not started:\n                        return 0\n                    return 1 if (has_zero or (p % s == 0)) else 0\n                res = 0\n                limit = digits[pos] if tight else 9\n                for d in range(limit + 1):\n                    ntight = tight and (d == limit)\n                    if not started:\n                        if d == 0:\n                            res += dp(pos + 1, ntight, False, False, 0, 1)\n                        else:\n                            res += dp(pos + 1, ntight, True, (d == 0), d, d)\n                    else:\n                        n_has_zero = has_zero or (d == 0)\n                        n_s = s + d\n                        n_p = p * d if d != 0 else 0\n                        res += dp(pos + 1, ntight, True, n_has_zero, n_s, n_p)\n                return res\n            return dp(0, True, False, False, 0, 1)\n        return count_up_to(r) - count_up_to(l - 1)","author":"ceaxyz002","submissionId":"1575118218"},[]]},{"22":[{"id":"22","fileName":"1575125632.txt","sourceCode":"class Solution {\n\n    public int beautifulNumbers(int l, int r) {\n        return beautifulNumbers(r + \"\") - beautifulNumbers(l - 1 + \"\");\n    }\n\n    private int beautifulNumbers(String s) {\n        HashMap<Integer, Integer>[][] map = new HashMap[9][72];\n        for (int i = 0; i < map.length; i++) {\n            for (int j = 0; j < map[0].length; j++) {\n                map[i][j] = new HashMap<>();\n            }\n        }\n        return beautifulNumbers(s, 0, false, 0, 0, map);\n    }\n\n    private int beautifulNumbers(String s, int i, boolean flag, int prod, int sum, HashMap<Integer, Integer>[][] map) {\n        if (i == s.length()) {\n            return sum != 0 && prod % sum == 0 ? 1 : 0;\n        } else if (flag) {\n            int result = 0;\n            if (sum == 0) {\n                result += beautifulNumbers(s, i + 1, true, 0, 0, map);\n                for (int j = 1; j < 10; j++) {\n                    result += beautifulNumbers(s.length() - i - 1, j, j, map);\n                }\n            } else {\n                result += beautifulNumbers(s.length() - i, prod, sum, map);\n            }\n            return result;\n        }\n        int result = beautifulNumbers(s, i + 1, false, (s.charAt(i) - '0') * (i > 0 ? prod : 1), sum + s.charAt(i) - '0', map);\n        for (int j = 0; j < s.charAt(i) - '0'; j++) {\n            result += beautifulNumbers(s, i + 1, true, i > 0 ? j * prod : j, sum + j, map);\n        }\n        return result;\n    }\n\n    private int beautifulNumbers(int i, int prod, int sum, HashMap<Integer, Integer>[][] map) {\n        if (i == 0) {\n            return prod % sum == 0 ? 1 : 0;\n        } else if (map[i][sum].containsKey(prod)) {\n            return map[i][sum].get(prod);\n        }\n        int result = 0;\n        for (int j = 0; j < 10; j++) {\n            result += beautifulNumbers(i - 1, prod * j, sum + j, map);\n        }\n        map[i][sum].put(prod, result);\n        return result;\n    }\n}","author":"arignote","submissionId":"1575125632"},[]]},{"23":[{"id":"23","fileName":"1575124471.txt","sourceCode":"class Solution {\npublic:\n    \n    map<int,int> mp = {\n        { 0 , 0},\n        { 10000000, 5845532 },\n        { 20000000, 12130749 },\n        { 30000000, 18463924 },\n        { 40000000, 24795187 },\n        { 50000000, 31128600 },\n        { 60000000, 37651026 },\n        { 70000000, 43988395 },\n        { 80000000, 50422159 },\n        { 90000000, 56696849 },\n        { 100000000, 62955907 },\n        { 110000000, 72955907 },\n        { 120000000, 79206545 },\n        { 130000000, 85514715 },\n        { 140000000, 91814353 },\n        { 150000000, 98119653 },\n        { 160000000, 104619367 },\n        { 170000000, 110942601 },\n        { 180000000, 117360798 },\n        { 190000000, 123618884 },\n        { 200000000, 129867304 },\n        { 210000000, 139867304 },\n        { 220000000, 146175474 },\n        { 230000000, 152508887 },\n        { 240000000, 158868605 },\n        { 250000000, 165177617 },\n        { 260000000, 171741637 },\n        { 270000000, 178088434 },\n        { 280000000, 184567579 },\n        { 290000000, 190822976 },\n        { 300000000, 197130769 },\n        { 310000000, 207130769 },\n        { 320000000, 213430407 },\n        { 330000000, 219790125 },\n        { 340000000, 226088343 },\n        { 350000000, 232450476 },\n        { 360000000, 239019237 },\n        { 370000000, 245347819 },\n        { 380000000, 251846362 },\n        { 390000000, 258175007 },\n        { 400000000, 264413913 },\n        { 410000000, 274413913 },\n        { 420000000, 280719213 },\n        { 430000000, 287028225 },\n        { 440000000, 293390358 },\n        { 450000000, 299674729 },\n        { 460000000, 306237756 },\n        { 470000000, 312581466 },\n        { 480000000, 319079252 },\n        { 490000000, 325306727 },\n        { 500000000, 331635764 },\n        { 510000000, 341635764 },\n        { 520000000, 348135478 },\n        { 530000000, 354699498 },\n        { 540000000, 361268259 },\n        { 550000000, 367831286 },\n        { 560000000, 374359942 },\n        { 570000000, 380958612 },\n        { 580000000, 387656516 },\n        { 590000000, 394160421 },\n        { 600000000, 400677787 },\n        { 610000000, 410677787 },\n        { 620000000, 417001021 },\n        { 630000000, 423347818 },\n        { 640000000, 429676400 },\n        { 650000000, 436020110 },\n        { 660000000, 442618780 },\n        { 670000000, 448949064 },\n        { 680000000, 455488633 },\n        { 690000000, 461794017 },\n        { 700000000, 468074643 },\n        { 710000000, 478074643 },\n        { 720000000, 484492840 },\n        { 730000000, 490971985 },\n        { 740000000, 497470528 },\n        { 750000000, 503968314 },\n        { 760000000, 510666218 },\n        { 770000000, 517205787 },\n        { 780000000, 523676108 },\n        { 790000000, 530134017 },\n        { 800000000, 536609810 },\n        { 810000000, 546609810 },\n        { 820000000, 552867896 },\n        { 830000000, 559123293 },\n        { 840000000, 565451938 },\n        { 850000000, 571679413 },\n        { 860000000, 578183318 },\n        { 870000000, 584488702 },\n        { 880000000, 590946611 },\n        { 890000000, 597130993 },\n        { 900000000, 603442755 },\n        { 910000000, 613442755 },\n        { 920000000, 619691175 },\n        { 930000000, 625998968 },\n        { 940000000, 632237874 },\n        { 950000000, 638566911 },\n        { 960000000, 645084277 },\n        { 970000000, 651364903 },\n        { 980000000, 657840696 },\n        { 990000000, 664152458 },\n        { 1000000000, 670349659 },\n    };\n\n    int getSum(int x) {\n        int ret = 0;\n        while(x > 0) {\n            ret += x % 10;\n            x /= 10;\n        }\n        return ret;\n    }\n    \n    long long getProd(int x) {\n        long long ret = 1;\n        while(x > 0) {\n            ret *= x % 10;\n            x /= 10;\n        }\n        return ret;\n    }\n    \n    int getAns(int x) {\n        int xx = (x / 10000000) * 10000000;\n        xx++;\n        int ans = 0;\n        for(int i = xx ; i <= x ; i++) {\n            long long v1 , v2;\n            v1 = getSum(i);\n            v2 = getProd(i);\n            if(v2 % v1 == 0) {\n                ans++;\n            }\n        }\n        return mp[(x / 10000000)*10000000 ] + ans;\n    }\n    \n    int beautifulNumbers(int l, int r) {\n        // cout << \" r ans \" << getAns(r) << endl;\n        // cout << \" l ans \" << getAns(l-1) << endl;\n        return getAns(r) - getAns(l-1);\n    }\n};\n// 5362 = 180 / ","author":"Neer N Patel","submissionId":"1575124471"},[]]},{"24":[{"id":"24","fileName":"1575124667.txt","sourceCode":"class Solution {\n    fun beautifulNumbers(l: Int, r: Int): Int {\n        val dp = intArrayOf(l, r)\n        fun cnt(n: Int): Long {\n            val s = n.toString()\n            data class S(val i: Int, val t: Boolean, val st: Boolean, val su: Int, val pr: Int)\n            val memo = HashMap<S, Long>()\n            fun f(i: Int, t: Boolean, st: Boolean, su: Int, pr: Int): Long {\n                if (i == s.length) return if (st && su > 0 && pr % su == 0) 1L else 0L\n                val state = S(i, t, st, su, pr)\n                if (memo.containsKey(state)) return memo[state]!!\n                var res = 0L\n                val lim = if (t) s[i] - '0' else 9\n                for (d in 0..lim) {\n                    val nt = t && (d == lim)\n                    res += if (!st && d == 0) f(i + 1, nt, false, 0, 1) else f(i + 1, nt, true, su + d, pr * d)\n                }\n                memo[state] = res\n                return res\n            }\n            return f(0, true, false, 0, 1)\n        }\n        return (cnt(dp[1]) - if (dp[0] > 1) cnt(dp[0] - 1) else 0L).toInt()\n    }\n}\n","author":"dkasd_12","submissionId":"1575124667"},[]]},{"25":[{"id":"25","fileName":"1575127721.txt","sourceCode":"class Solution {\n    using ll = long long;\n    unordered_map<string, ll> memo;\n    \n    ll dp(const vector<int>& digs, int pos, int tight, int started, int sum, int prod) {\n        if (pos == digs.size())\n            return started && sum > 0 && prod % sum == 0 ? 1LL : 0LL;\n        string key = to_string(pos) + \"_\" + to_string(tight) + \"_\" + to_string(started) + \"_\" + to_string(sum) + \"_\" + to_string(prod);\n        if (memo.count(key)) return memo[key];\n        ll ans = 0;\n        int limit = tight ? digs[pos] : 9;\n        for (int d = 0; d <= limit; d++) {\n            int ntight = (tight && d == limit) ? 1 : 0;\n            if (!started) {\n                if (d == 0)\n                    ans += dp(digs, pos + 1, ntight, 0, 0, 1);\n                else\n                    ans += dp(digs, pos + 1, ntight, 1, d, d);\n            } else {\n                int nsum = sum + d;\n                int nprod = (prod == 0 || d == 0) ? 0 : prod * d;\n                ans += dp(digs, pos + 1, ntight, 1, nsum, nprod);\n            }\n        }\n        return memo[key] = ans;\n    }\n    \n    ll countBeautiful(ll x) {\n        if (x < 1) return 0;\n        string s = to_string(x);\n        vector<int> digs(s.size());\n        for (int i = 0; i < s.size(); i++)\n            digs[i] = s[i] - '0';\n        memo.clear();\n        return dp(digs, 0, 1, 0, 0, 1);\n    }\n    \npublic:\n    int beautifulNumbers(int l, int r) {\n        return (int)(countBeautiful(r) - countBeautiful(l - 1));\n    }\n};\n","author":"nadoor_7","submissionId":"1575127721"},[]]},{"26":[{"id":"26","fileName":"1575124150.txt","sourceCode":"#define VecX vector\n#define MapX unordered_map\n#define Key tuple<int, bool, bool, bool, int, int>\n#define F(x, y, z) for (int x = y; x < z; ++x)\nstruct KeyHash {\n    size_t operator()(const Key& k) const {\n        auto [p, t, s, h, S, P] = k;\n        size_t hashVal = hash<int>()(p) ^ hash<bool>()(t) ^ hash<bool>()(s) ^\n                         hash<bool>()(h) ^ hash<int>()(S) ^ hash<int>()(P);\n        return hashVal;\n    }\n};\n\nstruct D {\n    VecX<int> d;\n    int n;\n    MapX<Key, int, KeyHash> m;\n\n    D(const VecX<int>& digs) : d(digs), n(digs.size()) {}\n\n    Key k(int p, bool t, bool s, bool h, int S, int P) const {\n        return Key{p, t, s, h, S, P};\n    }\n\n    int c() {\n        auto dp = [&](auto&& self, int p, bool t, bool s, bool h, int S,\n                      int P) -> int {\n            if (p == n)\n                return s && (h || (P % S == 0)) ? 1 : 0;\n            Key key = k(p, t, s, h, S, P);\n            if (m.count(key))\n                return m[key];\n\n            int res = 0, lim = t ? d[p] : 9;\n            auto f = [&](int x) {\n                bool nt = t && (x == lim), ns = s || (x != 0), nh = h;\n                int nS = S, nP = P;\n                if (!ns)\n                    return self(self, p + 1, nt, false, false, 0, 1);\n                if (x == 0) {\n                    nh = true;\n                    nP = 0;\n                } else if (!nh) {\n                    nS += x;\n                    nP *= x;\n                }\n                return self(self, p + 1, nt, true, nh, nS, nP);\n            };\n\n            F(x, 0, lim + 1) res += f(x);\n            return m[key] = res;\n        };\n\n        return dp(dp, 0, true, false, false, 0, 1);\n    }\n};\n\nstruct C {\n    static VecX<int> e(int num) {\n        VecX<int> digs;\n        while (num) {\n            digs.insert(digs.begin(), num % 10);\n            num /= 10;\n        }\n        return digs;\n    }\n\n    int c(int n) { return D(e(n)).c(); }\n};\n\nstruct R {\n    int c(int l, int r) {\n        C cnt;\n        return cnt.c(r) - (l > 1 ? cnt.c(l - 1) : 0);\n    }\n};\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) { return R().c(l, r); }\n};\n","author":"Subham","submissionId":"1575124150"},[]]},{"27":[{"id":"27","fileName":"1575130270.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_upto(n):\n            digits = list(map(int, str(n)))\n            N = len(digits)\n\n            @lru_cache(maxsize=None)\n            def dp(pos, tight, started, s, prod):\n                if pos == N:\n                    return int(started and s > 0 and prod % s == 0)\n\n                limit = digits[pos] if tight else 9\n                total = 0\n                for d in range(limit + 1):\n                    ntight = tight and (d == limit)\n                    if not started:\n                        if d == 0:\n                            total += dp(pos+1, ntight, False, 0, 1)\n                        else:\n                            total += dp(pos+1, ntight, True, d ,d)\n                    else:\n                        total += dp(pos+1, ntight, True, s+d, prod*d)\n                return total\n                \n            return dp(0, True, False, 0, 1)\n        res = count_upto(r) - count_upto(l-1)\n        return res\n","author":"Keerthi Rao C","submissionId":"1575130270"},[]]},{"28":[{"id":"28","fileName":"1575127455.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count(x):\n            if x < 1:\n                return 0\n            digits = [int(ch) for ch in str(x)]\n            n = len(digits)\n            \n            @lru_cache(maxsize=None)\n            def dp(pos, tight, started, has_zero, s, p):\n                if pos == n:\n                    if not started:\n                        return 0\n                    if has_zero:\n                        return 1\n                    return 1 if (p % s == 0) else 0\n\n                ans = 0\n                limit = digits[pos] if tight else 9\n                \n                if started and has_zero and not tight:\n                    return 10 ** (n - pos)\n                \n                for d in range(0, limit + 1):\n                    new_tight = tight and (d == limit)\n                    if not started:\n                        if d == 0:\n                            ans += dp(pos + 1, new_tight, False, False, 0, 1)\n                        else:\n                            ans += dp(pos + 1, new_tight, True, False, d, d)\n                    else:\n                        if has_zero:\n                            ans += dp(pos + 1, new_tight, True, True, s + d, 0)\n                        else:\n                            if d == 0:\n                                ans += dp(pos + 1, new_tight, True, True, s, 0)\n                            else:\n                                ans += dp(pos + 1, new_tight, True, False, s + d, p * d)\n                return ans\n            \n            return dp(0, True, False, False, 0, 1)\n        \n        return count(r) - count(l - 1)","author":"Cry Andrich","submissionId":"1575127455"},[]]},{"29":[{"id":"29","fileName":"1575130572.txt","sourceCode":"import java.util.*;\n\nclass F {\n    int[][] fac;\n    F() {\n        fac = new int[82][];\n        for (int s = 1; s <= 81; s++) {\n            int x = s;\n            int e2 = 0, e3 = 0, e5 = 0, e7 = 0;\n            int t = x;\n            while(t % 2 == 0) { e2++; t /= 2; }\n            while(t % 3 == 0) { e3++; t /= 3; }\n            while(t % 5 == 0) { e5++; t /= 5; }\n            while(t % 7 == 0) { e7++; t /= 7; }\n            if(t == 1) fac[s] = new int[]{e2, e3, e5, e7};\n            else fac[s] = null;\n        }\n    }\n}\n\nclass State {\n    int pos, tight, st, hz, sum, e2, e3, e5, e7;\n    State(int pos, int tight, int st, int hz, int sum, int e2, int e3, int e5, int e7) {\n        this.pos = pos; this.tight = tight; this.st = st; this.hz = hz; this.sum = sum;\n        this.e2 = e2; this.e3 = e3; this.e5 = e5; this.e7 = e7;\n    }\n    public boolean equals(Object o) {\n        if(this == o) return true;\n        if(!(o instanceof State)) return false;\n        State s = (State)o;\n        return pos==s.pos && tight==s.tight && st==s.st && hz==s.hz && sum==s.sum &&\n               e2==s.e2 && e3==s.e3 && e5==s.e5 && e7==s.e7;\n    }\n    public int hashCode() {\n        int ok = pos;\n        ok = ok * 31 + tight;\n        ok = ok * 31 + st;\n        ok = ok * 31 + hz;\n        ok = ok * 31 + sum;\n        ok = ok * 31 + e2;\n        ok = ok * 31 + e3;\n        ok = ok * 31 + e5;\n        ok = ok * 31 + e7;\n        return ok;\n    }\n}\n\nclass DP {\n    int[] digs;\n    int L;\n    HashMap<State, Long> memo;\n    F fObj;\n    static int[][] fac;\n    static {\n        fac = new int[10][4];\n        fac[0] = new int[]{0,0,0,0}; \n        fac[1] = new int[]{0,0,0,0};\n        fac[2] = new int[]{1,0,0,0};\n        fac[3] = new int[]{0,1,0,0};\n        fac[4] = new int[]{2,0,0,0};\n        fac[5] = new int[]{0,0,1,0};\n        fac[6] = new int[]{1,1,0,0};\n        fac[7] = new int[]{0,0,0,1};\n        fac[8] = new int[]{3,0,0,0};\n        fac[9] = new int[]{0,2,0,0};\n    }\n    \n    DP(int[] digs) {\n        this.digs = digs;\n        L = digs.length;\n        memo = new HashMap<>();\n        fObj = new F();\n    }\n    \n    long rec(int pos, int tight, int st, int hz, int sum, int e2, int e3, int e5, int e7) {\n        if(pos == L) {\n            if(st == 0) return 0; \n            if(sum == 0) return 0; \n            if(hz == 1) return 1;\n            int[] req = fObj.fac[sum];\n            if(req == null) return 0;\n            if(e2 >= req[0] && e3 >= req[1] && e5 >= req[2] && e7 >= req[3])\n                return 1;\n            else return 0;\n        }\n        State stt = new State(pos, tight, st, hz, sum, e2, e3, e5, e7);\n        if(memo.containsKey(stt)) return memo.get(stt);\n        long ans = 0;\n        int lim = (tight == 1 ? digs[pos] : 9);\n        for (int d = 0; d <= lim; d++) {\n            int nt = (tight == 1 && d == lim) ? 1 : 0;\n            int nst = st, nhz = hz, nsum = sum, ne2 = e2, ne3 = e3, ne5 = e5, ne7 = e7;\n            if(st == 0) {\n                if(d == 0) {\n                } else {\n                    nst = 1;\n                    nsum = d;\n                    ne2 += fac[d][0];\n                    ne3 += fac[d][1];\n                    ne5 += fac[d][2];\n                    ne7 += fac[d][3];\n                }\n            } else { \n                nsum = sum + d;\n                if(d == 0) {\n                    nhz = 1; \n                } else {\n                    if(nhz == 0) { \n                        ne2 += fac[d][0];\n                        ne3 += fac[d][1];\n                        ne5 += fac[d][2];\n                        ne7 += fac[d][3];\n                    }\n                }\n            }\n            ans += rec(pos + 1, nt, nst, nhz, nsum, ne2, ne3, ne5, ne7);\n        }\n        memo.put(stt, ans);\n        return ans;\n    }\n}\n\nclass T {\n    static int[] toDigits(long x) {\n        String s = Long.toString(x);\n        int n = s.length();\n        int[] digs = new int[n];\n        for (int i = 0; i < n; i++) {\n            digs[i] = s.charAt(i) - '0';\n        }\n        return digs;\n    }\n}\n\nclass B {\n    long countBeautiful(long x) {\n        if(x < 1) return 0;\n        int[] digs = T.toDigits(x);\n        DP dp = new DP(digs);\n        return dp.rec(0, 1, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\n\npublic class Solution {\n    public int beautifulNumbers(int l, int r) {\n        B b = new B();\n        long ans = b.countBeautiful(r) - b.countBeautiful(l - 1);\n        return (int)ans;\n    }\n}\n","author":"nobita_10","submissionId":"1575130572"},[]]},{"30":[{"id":"30","fileName":"1575128948.txt","sourceCode":"use std::collections::HashMap;\nuse std::convert::TryInto;\n\nimpl Solution {\n    pub fn beautiful_numbers(a: i32, b: i32) -> i32 {\n        let c = (a, b);\n        let mut aa = 0;\n        let mut bb = 0;\n        let mut cc = 0;\n        let mut arr1: Vec<i32> = Vec::new();\n        cc += 6;\n        arr1.push(cc);\n        bb += 6;\n        arr1.push(cc);\n        aa += 3;\n        arr1.push(cc);\n        fn d(e: i32, aa: &mut i32, bb: &mut i32, cc: &mut i32, arr1: &mut Vec<i32>) -> i32 {\n            if e <= 0 {\n                return 0;\n            }\n            let f = e.to_string();\n            let g: Vec<u8> = f.chars()\n                .map(|h| h.to_digit(10).unwrap() as u8)\n                .collect();\n            let mut i: HashMap<(usize, bool, bool, bool, i32, i32), i32> = HashMap::new();\n            *cc += 6;\n            arr1.push(*cc);\n            *bb += 6;\n            arr1.push(*cc);\n            *aa += 3;\n            arr1.push(*cc);\n            j(0, true, false, false, 0, 1, &g, &mut i, aa, bb, cc, arr1)\n        }\n        \n        fn j(\n            k: usize,\n            l: bool,\n            m: bool,\n            n: bool,\n            o: i32,\n            p: i32,\n            q: &Vec<u8>,\n            r: &mut HashMap<(usize, bool, bool, bool, i32, i32), i32>,\n            aa: &mut i32,\n            bb: &mut i32,\n            cc: &mut i32,\n            arr1: &mut Vec<i32>\n        ) -> i32 {\n            if k == q.len() {\n                *cc += 6;\n                arr1.push(*cc);\n                *bb += 6;\n                arr1.push(*cc);\n                *aa += 3;\n                arr1.push(*cc);\n                \n                if !m {\n                    *cc += 6;\n                arr1.push(*cc);\n                *bb += 6;\n                arr1.push(*cc);\n                *aa += 3;\n                arr1.push(*cc);\n                    return 0;\n                }\n                if n {\n                    *cc += 6;\n                arr1.push(*cc);\n                *bb += 6;\n                arr1.push(*cc);\n                *aa += 3;\n                arr1.push(*cc);\n                    return 1;\n                }\n                *cc += 6;\n                arr1.push(*cc);\n                *bb += 6;\n                arr1.push(*cc);\n                *aa += 3;\n                arr1.push(*cc);\n                return if p % o == 0 { 1 } else { 0 };\n            }\n            \n            let s = (k, l, m, n, o, p);\n            *cc += 6;\n                arr1.push(*cc);\n                *bb += 6;\n                arr1.push(*cc);\n                *aa += 3;\n                arr1.push(*cc);\n            if let Some(&t) = r.get(&s) {\n                return t;\n            }\n            *cc += 6;\n                arr1.push(*cc);\n                *bb += 2;\n                arr1.push(*cc);\n                *aa += 3;\n                arr1.push(*cc);\n            let u = if l { q[k] } else { 9 };\n            *cc += 6;\n                arr1.push(*cc);\n                *bb += 1;\n                arr1.push(*cc);\n                *aa += 3;\n                arr1.push(*cc);\n            let mut v = 0;\n            \n            for w in 0..=u {\n                let x = l && (w == u);\n                \n                *cc += 6;\n                arr1.push(*cc);\n                *bb += 6;\n                arr1.push(*cc);\n                *aa += 3;\n                arr1.push(*cc);\n                \n                if !m {\n                    if w == 0 {\n                        v += j(k + 1, x, false, false, 0, 1, q, r, aa, bb, cc, arr1);\n                    } else {\n                        v += j(k + 1, x, true, false, w as i32, w as i32, q, r, aa, bb, cc, arr1);\n                    }\n                } else {\n                    if !n {\n                        if w == 0 {\n                            *cc += 6;\n                arr1.push(*cc);\n                *bb += 6;\n                arr1.push(*cc);\n                *aa += 3;\n                arr1.push(*cc);\n                            v += j(k + 1, x, true, true, 0, 0, q, r, aa, bb, cc, arr1);\n                            *cc += 6;\n                            arr1.push(*cc);\n                            *bb += 6;\n                            arr1.push(*cc);\n                            *aa += 3;\n                            arr1.push(*cc);\n                        } else {\n                            *cc += 6;\n                            arr1.push(*cc);\n                            *bb += 6;\n                            arr1.push(*cc);\n                            *aa += 3;\n                            arr1.push(*cc);\n                            v += j(k + 1, x, true, false, o + w as i32, p * (w as i32), q, r, aa, bb, cc, arr1);\n                        }\n                    } else {\n                        v += j(k + 1, x, true, true, 0, 0, q, r, aa, bb, cc, arr1);\n                    }\n                }\n            }\n            \n            r.insert(s, v);\n            v\n        }\n\n        d(c.1, &mut aa, &mut bb, &mut cc, &mut arr1) - d(c.0 - 1, &mut aa, &mut bb, &mut cc, &mut arr1)\n    }\n}\n","author":"dom9090","submissionId":"1575128948"},[]]},{"32":[{"id":"32","fileName":"1575130830.txt","sourceCode":"class Solution {\npublic:\n    vector<int> dig;\n    map<array<int, 5>, int > memo;\n    int dp(int pos, int tight, int sm, int prod, int leading) {\n        // cout << pos << dig.size() << endl;\n        if (pos == dig.size()) {\n            if (sm != 0 && prod % sm == 0) return 1;\n            else return 0;\n        }\n\n        if (memo.find({pos, tight, sm, prod, leading}) != memo.end()) return memo[{pos, tight, sm, prod, leading}];\n        // cout << pos << sm << prod << endl;\n        int res = 0;\n        \n        int limit = dig[pos];\n        if (!tight) limit=9;\n        for (int d = 0; d <= limit; d++) {\n                int nproduct = 1;\n                int nl = leading && (d == 0);\n                if (!nl) {\n                    nproduct= prod * d;\n                }\n\n                res += dp(\n                    pos + 1,\n                    tight && d == limit,\n                    sm + d,\n                    nproduct,\n                    nl\n                );\n            }\n            \n        return memo[{pos, tight, sm, prod, leading}] = res;\n    }\n\n    int beautifulNumbers(int l, int r) {\n        dig.clear();\n        memo.clear();\n        while (r != 0) {\n            dig.push_back(r % 10);\n            r/=10;\n        }\n        reverse(dig.begin(), dig.end());\n        int above = dp(0, 1, 0, 1, 1);\n        // cout <<  'd' << endl;\n        // cout << above << endl;\n        l--;\n        dig.clear();\n        while (l != 0) {\n            dig.push_back(l % 10);\n            l/=10;\n        }\n        memo.clear();\n        reverse(dig.begin(), dig.end());\n        return above -  dp(0, 1, 0, 1, 1);\n    }\n};","author":"rithwikgupta","submissionId":"1575130830"},[]]},{"33":[{"id":"33","fileName":"1575130854.txt","sourceCode":"from functools import lru_cache\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def countToN(n):\n            digits = list(map(int,str(n)))\n            length = len(digits)\n            \n            @lru_cache(None)\n            def dp(pos,is_tight,digit_sum,digit_product,nonzero):\n                if pos==length:\n                    return 1 if nonzero and digit_product % digit_sum== 0 else 0\n                limit = digits[pos] if is_tight else 9\n                count =0 \n                \n                for d in range(0,limit+1):\n                    newpr = digit_product*d if nonzero else d\n                    newsum = digit_sum+d\n                    count+=dp(pos+1,is_tight and (d==limit),newsum,newpr,nonzero or d>0)\n                return count\n            return dp(0,True,0,1,False)\n        return countToN(r)- countToN(l-1)\n            \n            \n       ","author":"Farhan Ahmad Khan","submissionId":"1575130854"},[]]},{"34":[{"id":"34","fileName":"1575132495.txt","sourceCode":"#include <bits/stdc++.h>\n#pragma GCC optimize(2)\n#define rep(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep_(i, a, b) for (int i = (a); i > (b); i--)\n#define CEIL_DIV(a, b) ((b) == 0 ? 0 : (((a) >= 0) ? ((a) + (b) - 1) / (b) : (a) / (b)))\n#define FLOOR_DIV(a, b) (((a) / (b)) - ((a) % (b) != 0 &&(((a) < 0) != ((b) < 0))))\n#define mst(x, a) memset(x, a, sizeof(x))\n#define all(a) begin(a), end(a)\n#define lowbit(x) ((x) & (-(x)))\n#define bitcnt(x) (__builtin_popcountll(x))\n#define se second\n#define fi first\n#define pb push_back\n#define maxe max_element\n#define mine min_element\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, ll> pil;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\nconstexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\nconstexpr static int inf = 0x3f3f3f3f, mod = 1e9 + 7;\nconst ll infl = 0x3f3f3f3f3f3f3f3fll;\ntemplate<class T> bool chmax(T &a, T b) {\n    if (a >= b) return false;\n    a = b; return true;\n}\ntemplate<class T> bool chmin(T &a, T b) {\n    if (a <= b) return false;\n    a = b; return true;\n}\ntemplate<class T> bool chsum(T &a, T b) {\n    a = (a + b + mod) % mod;\n    return 0;\n}\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        ll cand1 = helper(r);\n        ll cand0 = helper(l-1);\n        return cand1 - cand0;\n    }\nprivate:\n    ll helper(ll x) {\n        if(x <= 0) return 0;\n        digits = to_string(x);\n        n = digits.size();\n        dp.clear();\n        return dfs(0, 0, 0, 0, 1, 1);\n    }\n    struct State {\n        int pos, started, hasZero, sum, prod, tight;\n        bool operator==(const State &lhs) const {\n            return pos==lhs.pos && started==lhs.started \n                && hasZero==lhs.hasZero && sum==lhs.sum && prod==lhs.prod && tight==lhs.tight;\n        }\n    };\n    struct StateHash {\n        size_t operator()(const State &s) const {\n            size_t res = 17;\n            res = res * 31 + hash<int>()(s.pos);\n            res = res * 31 + hash<int>()(s.started);\n            res = res * 31 + hash<int>()(s.hasZero);\n            res = res * 31 + hash<int>()(s.sum);\n            res = res * 31 + hash<int>()(s.prod);\n            res = res * 31 + hash<int>()(s.tight);\n            return res;\n        }\n    };\n    string digits; \n    int n;\n    unordered_map<State, ll, StateHash> dp;\n\n    ll qpow(int e) {\n        ll res = 1;\n        while(e--) res *= 10;\n        return res;\n    }\n   \n    ll dfs(int pos, int started, int hasZero, int sum, int prod, int tight) {\n        if(pos == n) {\n            if(!started) return 0;\n            if(hasZero) return 1;\n            return (prod % sum == 0) ? 1ll : 0ll;\n        }\n        State st = {pos, started, hasZero, sum, prod, tight};\n        if(dp.find(st) != dp.end()) return dp[st];\n\n        ll res = 0;\n        int limit = tight ? digits[pos]-'0' : 9;\n        if(!tight && hasZero && started) {\n            return qpow(n-pos);\n        }\n        rep(d, 0, limit+1) {\n            int ntight = (tight && (d==limit)) ? 1 : 0;\n            if(!started) {\n                if(d==0) {\n                    res += dfs(pos+1, 0, 0, 0, 1, ntight);\n                } else {\n                    res += dfs(pos+1, 1, 0, d, d, ntight);\n                }\n            } else {\n                if(d==0) {\n                    res += dfs(pos+1, 1, 1, sum, 0, ntight);\n                } else {\n                    int nsum = sum + d;\n                    int nprod = (hasZero ? 0 : prod * d);\n                    res += dfs(pos+1, 1, hasZero, nsum, nprod, ntight);\n                }\n            }\n        }\n        dp[st] = res;\n        return res;\n    }\n};","author":"Ryan","submissionId":"1575132495"},[]]},{"35":[{"id":"35","fileName":"1575116002.txt","sourceCode":"class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def countb(n):\n            s = str(n)\n            memo = {}\n            \n            def dp(pos, zs, starts, sumx, prod):\n                if pos == len(s):\n                    if not starts: \n                        return 0\n                    return 1 if prod % sumx == 0 else 0\n                \n                st = (pos, zs, starts, sumx, prod)\n                if st in memo:\n                    return memo[st]\n                \n                lim = int(s[pos]) if zs else 9\n                res = 0\n                for d in range(lim + 1):\n                    n1 = zs and (d == lim)\n                    n2 = starts or (d != 0)\n                    n3 = sumx\n                    n4 = prod\n                    if n2:\n                        n3 += d\n                        n4 = 0 if d == 0 else n4 * d\n                    res += dp(pos + 1, n1, n2, n3, n4)\n                memo[st] = res\n                return res\n            return dp(0, True, False, 0, 1)\n        return countb(r) - countb(l - 1)\n","author":"invisible","submissionId":"1575116002"},[]]},{"36":[{"id":"36","fileName":"1575130274.txt","sourceCode":"class Solution {\n    public int beautifulNumbers(int l, int r) {\n        return countZeroDigitNumbers(l, r) + countNoZeroAndBeautiful(l, r);\n    }\n\n    private int countZeroDigitNumbers(int l, int r) {\n        return countNumbersWithZero(r) - countNumbersWithZero(l - 1);\n    }\n\n    private int countNumbersWithZero(int n) {\n        if (n < 0) return 0;\n        char[] num = Integer.toString(n).toCharArray();\n        int len = num.length;\n        Integer[][][][] memo = new Integer[len][2][2][2];\n        return digitDP(num, 0, 1, 0, 0, memo);\n    }\n\n    private int digitDP(char[] num, int pos, int tight, int started, int hasZero, Integer[][][][] memo) {\n        if (pos == num.length) {\n            return hasZero == 1 ? 1 : 0;\n        }\n        if (memo[pos][tight][started][hasZero] != null) {\n            return memo[pos][tight][started][hasZero];\n        }\n        int limit = (tight == 1) ? (num[pos] - '0') : 9;\n        int count = 0;\n        for (int d = 0; d <= limit; d++) {\n            int newTight = (tight == 1 && d == limit) ? 1 : 0;\n            int newStarted = (started == 1 || d != 0) ? 1 : 0;\n            int newHasZero = (hasZero == 1 || (newStarted == 1 && d == 0)) ? 1 : 0;\n            count += digitDP(num, pos + 1, newTight, newStarted, newHasZero, memo);\n        }\n        memo[pos][tight][started][hasZero] = count;\n        return count;\n    }\n\n    private int countNoZeroAndBeautiful(int l, int r) {\n        return countBeautifulNoZero(r) - countBeautifulNoZero(l - 1);\n    }\n\n    private int countBeautifulNoZero(int n) {\n        if (n < 1) return 0;\n        char[] num = Integer.toString(n).toCharArray();\n        int len = num.length;\n        return digitDP2(num, 0, 1, 0, 0, 1, new HashMap<>());\n    }\n\n    private int digitDP2(char[] num, int pos, int tight, int started, long sum, long product, Map<String, Integer> memo) {\n        if (pos == num.length) {\n            if (started == 1 && sum != 0 && product % sum == 0) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n        String key = pos + \",\" + tight + \",\" + started + \",\" + sum + \",\" + product;\n        if (memo.containsKey(key)) {\n            return memo.get(key);\n        }\n        int limit = (tight == 1) ? (num[pos] - '0') : 9;\n        int count = 0;\n        for (int d = 0; d <= limit; d++) {\n            if (d == 0) {\n                if (started == 0) {\n                    int newTight = (tight == 1 && d == limit) ? 1 : 0;\n                    int newStarted = 0;\n                    count += digitDP2(num, pos + 1, newTight, newStarted, sum, product, memo);\n                }\n                continue;\n            }\n            int newTight = (tight == 1 && d == limit) ? 1 : 0;\n            int newStarted = 1;\n            long newSum = sum + d;\n            long newProduct = product * d;\n            count += digitDP2(num, pos + 1, newTight, newStarted, newSum, newProduct, memo);\n        }\n        memo.put(key, count);\n        return count;\n    \n    }\n}","author":"Shweta_199","submissionId":"1575130274"},[]]},{"38":[{"id":"38","fileName":"1575133006.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_beautiful(n: int) -> int:\n            if n < 1:\n                return 0\n            digits = list(map(int, str(n)))\n            @functools.cache\n            def dp(pos, tight, started, hasZero, s, p):\n                if pos == len(digits):\n                    if not started:\n                        return 0\n                    return 1 if (p % s == 0) else 0\n                res = 0\n                up = digits[pos] if tight else 9\n                for d in range(up + 1):\n                    ntight = tight and (d == up)\n                    if not started:\n                        if d == 0:\n                            res += dp(pos + 1, ntight, False, False, 0, 1)\n                        else:\n                            res += dp(pos + 1, ntight, True, False, d, d)\n                    else:\n                        if d == 0:\n                            res += dp(pos + 1, ntight, True, True, s + 0, 0)\n                        else:\n                            if hasZero:\n                                res += dp(pos + 1, ntight, True, True, s + d, 0)\n                            else:\n                                res += dp(pos + 1, ntight, True, False, s + d, p * d)\n                return res\n            return dp(0, True, False, False, 0, 1)\n        return count_beautiful(r) - count_beautiful(l - 1)","author":"StackOverflowAutomaton","submissionId":"1575133006"},[]]},{"39":[{"id":"39","fileName":"1575135350.txt","sourceCode":"int dp[11][2][2][82][82][82];\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        vector<int> ld, rd;\n        \n        while (l) {\n            ld.push_back(l % 10);\n            l /= 10;\n        }\n        while (r) {\n            rd.push_back(r % 10);\n            r /= 10;\n        }\n        int size = max(ld.size(), rd.size());\n        while (ld.size() < size) ld.push_back(0);\n        while (rd.size() < size) rd.push_back(0);\n        \n        reverse(ld.begin(), ld.end());\n        reverse(rd.begin(), rd.end());\n        \n        memset(dp, 0, sizeof(dp));\n        int maxSum = min(size * 9, 81);\n        for (int i = 1; i <= maxSum; ++i) {\n            dp[0][0][0][i][0][1 % i] = 1;\n        }\n        for (int i = 0; i < size; ++i) {\n            for (int u = 0; u < 2; ++u) {\n                for (int v = 0; v < 2; ++v) {\n                    for (int sum = 1; sum <= maxSum; ++sum) {\n                        for (int curSum = sum; curSum >= 0; --curSum) {\n                            if ((sum - curSum) > (size - i) * 9) break;\n\n                            for (int curRem = 0; curRem < sum; ++curRem) {\n                                if (!dp[i][u][v][sum][curSum][curRem]) continue;\n\n                                for (int digit = 0; digit < 10; ++digit) {\n                                    int nu = u, nv = v;\n                                    if (u == 0 && digit < ld[i]) continue;\n                                    if (u == 0 && digit > ld[i]) {\n                                        nu = 1;\n                                    }\n                                    if (v == 0 && digit > rd[i]) continue;\n                                    if (v == 0 && digit < rd[i]) {\n                                        nv = 1;\n                                    }\n\n                                    int nextRem = curRem;\n                                    int nextSum = curSum + digit;\n                                    if (nextSum != 0) {\n                                        nextRem = (curRem * digit) % sum;\n                                    }\n                                    \n                                    dp[i + 1][nu][nv][sum][nextSum][nextRem] += dp[i][u][v][sum][curSum][curRem];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        int ans = 0;\n        for (int u = 0; u < 2; ++u) {\n            for (int v = 0; v < 2; ++v) {\n                for (int sum = 1; sum <= maxSum; ++sum) {\n                    ans += dp[size][u][v][sum][sum][0];\n                }\n            }\n        }\n        return ans;\n    }\n};","author":"Yang Xiao","submissionId":"1575135350"},[]]},{"40":[{"id":"40","fileName":"1575133473.txt","sourceCode":"def count_with_zero(x):\n    if x <= 0:\n        return 0\n    digits = list(map(int, str(x)))\n    n = len(digits)\n    memo = {}\n\n    def dfs(pos, hasZero, started, less):\n        if pos == n:\n            return 1 if (started and hasZero) else 0\n        if (pos, hasZero, started, less) in memo:\n            return memo[(pos, hasZero, started, less)]\n        limit = digits[pos] if not less else 9\n        res = 0\n        for d in range(limit + 1):\n            res += dfs(pos + 1, hasZero or (d == 0 and started), started or (d != 0), less or (d < limit))\n        memo[(pos, hasZero, started, less)] = res\n        return res\n\n    return dfs(0, False, False, False)\n\ndef count_nonzero_divisible(x):\n    if x <= 0:\n        return 0\n    digits = list(map(int, str(x)))\n    n = len(digits)\n\n    @functools.lru_cache(None)\n    def dfs(pos, sumS, prod, started, less):\n        if pos == n:\n            return 1 if (started and sumS > 0 and prod % sumS == 0) else 0\n        limit = digits[pos] if not less else 9\n        result = 0\n        for d in range(limit + 1):\n            if started:\n                if d == 0:\n                    continue\n                result += dfs(pos + 1, sumS + d, prod * d, True, less or (d < limit))\n            else:\n                if d == 0:\n                    result += dfs(pos + 1, sumS, prod, False, less or (d < limit))\n                else:\n                    result += dfs(pos + 1, d, d, True, less or (d < limit))\n        return result\n\n    return dfs(0, 0, 1, False, False)\n\ndef count_beautiful(x):\n    return count_with_zero(x) + count_nonzero_divisible(x) if x >= 1 else 0\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return count_beautiful(r) - count_beautiful(l - 1)","author":"jacksonc","submissionId":"1575133473"},[]]},{"42":[{"id":"42","fileName":"1575133514.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def helper(x):\n            digits = list(map(int, str(x)))\n            n = len(digits)\n            memo = {}\n            def dp(i, tight, started, has_zero, s, p):\n                if i == n:\n                    if not started:\n                        return 0\n\n                    if has_zero:\n                        return 1\n\n                    return 1 if (s != 0 and p % s == 0) else 0\n\n                key = (i, tight, started, has_zero, s, p)\n                if key in memo:\n                    return memo[key]\n\n                res = 0\n                maxD = digits[i] if tight else 9\n                for d in range(0, maxD + 1):\n                    if not started:\n                        if d == 0:\n                            res += dp(i + 1, tight and (d == maxD), False, False, s, p)\n                        else:\n                            res += dp(i + 1, tight and (d == maxD), True, False, d, d)\n                    else:\n                        res += dp(i + 1, tight and (d == maxD), True, has_zero or (d == 0), s + d, p * d if not has_zero else 0)\n                memo[key] = res\n                return res\n            return dp(0, True, False, False, 0, 1)\n        return helper(r) - helper(l-1)","author":"Varun Agnihotri","submissionId":"1575133514"},[]]},{"43":[{"id":"43","fileName":"1575136073.txt","sourceCode":"class Solution {\npublic:\n    using ll = long long;\n    ll cnt(ll X) {\n        if(X < 1) return 0;\n        string s = to_string(X);\n        int n = s.size();\n        vector<array<map<tuple<int,int,int>, ll>, 2>> dp(n+1);\n        dp[0][1][{0, 0, 1}] = 1;\n        for(int pos = 0; pos < n; pos++){\n            int limit = s[pos]-'0';\n            for(int tight = 0; tight < 2; tight++){\n                for(auto &entry : dp[pos][tight]){\n                    auto key = entry.first;\n                    ll cnt = entry.second;\n                    int started, sum, prod;\n                    tie(started, sum, prod) = key;\n                    int up = (tight ? limit : 9);\n                    for(int d = 0; d <= up; d++){\n                        int ntight = (tight && d==up) ? 1 : 0;\n                        int nstarted = started;\n                        int nsum = sum;\n                        int nprod = prod;\n                        if(!nstarted){\n                            if(d!=0){\n                                nstarted = 1;\n                                nsum = d;\n                                nprod = d;\n                            }\n                        } else {\n                            if(nprod==0 or d==0){\n                                nprod = 0;\n                                nsum += d;\n                            } else {\n                                nsum += d;\n                                nprod *= d;\n                            }\n                        }\n                        dp[pos+1][ntight][{nstarted, nsum, nprod}] += cnt;\n                    }\n                }\n            }\n        }\n        ll res = 0;\n        for(int tight = 0; tight < 2; tight++){\n            for(auto &entry : dp[n][tight]){\n                int started, sum, prod;\n                tie(started, sum, prod) = entry.first;\n                if(started && sum > 0 && prod % sum == 0)\n                    res += entry.second;\n            }\n        }\n        return res;\n    }\n    \n    int beautifulNumbers(int l, int r) {\n        return (int)(cnt(r) - cnt(l-1));\n    }\n};\n","author":"Divyansh Deshmukh","submissionId":"1575136073"},[]]},{"44":[{"id":"44","fileName":"1575135600.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count(x):\n            xs = str(x)\n            n = len(xs)\n            @cache\n            def dp(i, t, st, z, s, p):\n                if i == n:\n                    if not st:\n                        return 0\n                    if z:\n                        return 1\n                    return 1 if (s and p % s == 0) else 0\n                tot = 0\n                upper = int(xs[i]) if t else 9\n                for d in range(upper + 1):\n                    nt = (t and (d == upper))\n                    if st:\n                        if d == 0:\n                            tot += dp(i + 1, nt, True, True, s, 0)\n                        else:\n                            if z:\n                                tot += dp(i + 1, nt, True, True, s + d, 0)\n                            else:\n                                tot += dp(i + 1, nt, True, False, s + d, p * d)\n                    else:\n                        if d == 0:\n                            tot += dp(i + 1, nt, False, False, s, p)\n                        else:\n                            tot += dp(i + 1, nt, True, False, s + d, d)\n                return tot\n            return dp(0, True, False, False, 0, 1)\n        return count(r) - count(l - 1)\n","author":"lihaicoder","submissionId":"1575135600"},[]]},{"45":[{"id":"45","fileName":"1575135709.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count(n):\n            digs = list(map(int, str(n)))\n            \n            @lru_cache(maxsize=None)\n            def dp(i, tight, st, zeros, s, p):\n                if i == len(digs):\n                    if not st:\n                        return 0\n                    if zeros:\n                        return 1\n                    return 1 if s > 0 and p % s == 0 else 0\n                lim = digs[i] if tight else 9\n                ans = 0\n                for dig in range(lim + 1):\n                    ntight = tight and (dig == lim)\n                    if not st:\n                        if dig == 0:\n                            ans += dp(i + 1, ntight, False, False, 0, 1)\n                        else:\n                            ans += dp(i + 1, ntight, True, False, dig, dig)\n                    else:\n                        if zeros or dig == 0:\n                            ns = s + dig\n                            np = 0\n                            ans += dp(i + 1, ntight, True, True, ns, np)\n                        else:\n                            ns = s + dig\n                            np = p * dig\n                            ans += dp(i + 1, ntight, True, False, ns, np)\n                return ans\n            return dp(0, True, False, False, 0, 1)\n        return count(r) - count(l - 1)","author":"Cryptic-Technomage","submissionId":"1575135709"},[]]},{"46":[{"id":"46","fileName":"1575137743.txt","sourceCode":"class Solution {\npublic:\n    vector<int> a;\n    map<array<int, 5>, int> dp;\n    int dfs(int cur, int sum, int prod, int lim, int zero) {\n        if (cur == -1) {\n            return !zero && (prod % sum == 0);\n        }\n        array<int, 5> st = {cur, sum, prod, lim, zero};\n        if (auto it = dp.find(st); it != dp.end()) {\n            return it->second;\n        }\n        int& ans = dp[st];\n\n        int up = lim ? a[cur] : 9;\n        \n        for (int i = 0; i <= up; i++) {\n            int nprod = prod * i;\n            if (zero && !i) nprod = 1;\n            ans += dfs(cur - 1, sum + i, nprod, lim && i == up, zero && !i);\n        }\n\n        return ans;\n    }\n\n    int cal(int x) {\n        if (x == 0) return 0;\n        a.clear();\n        dp.clear();\n        while (x) {\n            a.push_back(x % 10);\n            x /= 10;\n        }\n        return dfs(a.size() - 1, 0, 1, 1, 1);\n    }\n    int beautifulNumbers(int l, int r) {\n        return cal(r) - cal(l - 1);\n    }\n};","author":"OTTFF","submissionId":"1575137743"},[]]},{"47":[{"id":"47","fileName":"1575137829.txt","sourceCode":"#define ll long long\n\nclass Solution {\n    string numToStr(ll n) {\n        return to_string(n);\n    }\n    \n    struct Key {\n        int pos, t, start, sum;\n        ll prod;\n        bool operator==(const Key &other) const {\n            return pos == other.pos && t == other.t && start == other.start && sum == other.sum && prod == other.prod;\n        }\n    };\n    \n    struct KeyHash {\n        std::size_t operator()(const Key &k) const {\n            auto h1 = std::hash<int>()(k.pos);\n            auto h2 = std::hash<int>()(k.t);\n            auto h3 = std::hash<int>()(k.start);\n            auto h4 = std::hash<int>()(k.sum);\n            auto h5 = std::hash<ll>()(k.prod);\n            return (((((h1 * 31 + h2) * 31 + h3) * 31 + h4) * 31) + h5);\n        }\n    };\n    \n    string s;\n    unordered_map<Key, ll, KeyHash> valid;\n    \n    ll dpValid(int pos, int t, int start, int sum, ll prod){\n        if(pos == s.size())\n            return (start && sum != 0 && prod % sum == 0) ? 1LL : 0LL;\n        \n        Key key = {pos, t, start, sum, prod};\n        if(valid.find(key) != valid.end())\n            return valid[key];\n    \n        ll res = 0;\n        int limit = t ? (s[pos] - '0') : 9;\n        for(int d = 0; d <= limit; d++){\n            int nt = (t && d < limit) ? 0 : t;\n            int nstart = start;\n            int nsum = sum;\n            ll nprod = prod;\n    \n            if(!start){\n                if(d == 0){\n                    res += dpValid(pos + 1, nt, 0, 0, 1LL);\n                    continue;\n                }\n                nstart = 1;\n                nsum = d;\n                nprod = d;\n            }else{\n                if (d == 0) continue;\n                nsum += d;\n                nprod *= d;\n            }\n            res += dpValid(pos + 1, nt, nstart, nsum, nprod);\n        }\n    \n        valid[key] = res;\n        return res;\n    }\n    \n    int dp[20][2][2];\n    bool vis[20][2][2];\n    int dpAll(int pos, int t, int start){\n        if(pos == s.size()) return start ? 1 : 0;\n        if(vis[pos][t][start]) return dp[pos][t][start];\n    \n        vis[pos][t][start] = true;\n        int res = 0;\n        int limit = t ? (s[pos] - '0') : 9;\n    \n        for(int d = 0; d <= limit; d++){\n            int nt = (t && d < limit) ? 0 : t;\n            int nstart = start || (d != 0);\n            if(nstart && d == 0) continue;\n            \n            res += dpAll(pos + 1, nt, nstart);\n        }\n    \n        dp[pos][t][start] = res;\n        return res;\n    }\n    \n    ll countBeautiful(ll n){\n        if(n <= 0) return 0;\n        \n        s = numToStr(n);\n        valid.clear();\n        ll validNoZero = dpValid(0, 1, 0, 0, 1LL);\n        memset(vis, 0, sizeof(vis));\n        int totalNoZero = dpAll(0, 1, 0);\n        ll withZero = n - totalNoZero;\n        return withZero + validNoZero;\n    }\n\npublic:\n    int beautifulNumbers(int l, int r) {\n        return (int)(countBeautiful(r) - countBeautiful(l - 1));\n    }\n};\n","author":"baliramkumar","submissionId":"1575137829"},[]]},{"48":[{"id":"48","fileName":"1575145306.txt","sourceCode":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXP 12\n#define MAXS 83\n#define MAXH (1<<17)\n#define MAX_PAR 30000\n\nint nd;\nint dgt[MAXP];\nint pc;\nint par[MAX_PAR];\n\nvoid rec_par(int cur, int dg, int rem) {\nif(dg > 9) {\npar[pc++] = cur;\nreturn;\n}\nfor (int e = 0; e <= rem; e++) {\nint mul = 1;\nfor (int i = 0; i < e; i++)\nmul *= dg;\nrec_par(cur * mul, dg + 1, rem - e);\n}\n}\n\nint cmp_int(const void *a, const void *b) {\nint ia = *(int*)a, ib = *(int*)b;\nreturn ia - ib;\n}\n\nint get_ix(int x) {\nint lo = 0, hi = pc - 1;\nwhile(lo <= hi) {\nint mid = (lo + hi) / 2;\nif(par[mid] == x)\nreturn mid;\nelse if(par[mid] < x)\nlo = mid + 1;\nelse\nhi = mid - 1;\n}\nreturn -1;\n}\n\nint init_par() {\npc = 0;\nrec_par(1, 2, 9);\nqsort(par, pc, sizeof(int), cmp_int);\nint np = 0;\nfor (int i = 0; i < pc; i++) {\nif(i == 0 || par[i] != par[i - 1])\npar[np++] = par[i];\n}\npc = np;\nreturn pc;\n}\n\nunsigned int dp_key[MAXH];\nlong long dp_val[MAXH];\n\nunsigned int make_key(int pos, int t, int st, int sm, int ix) {\nreturn ((unsigned int)pos) | (((unsigned int)t) << 4) | (((unsigned int)st) << 5) | (((unsigned int)sm) << 6) | (((unsigned int)ix) << 13);\n}\n\nvoid dp_clear() {\nfor (int i = 0; i < MAXH; i++)\ndp_key[i] = 0xFFFFFFFF;\n}\n\nlong long f_beauty(int pos, int t, int st, int sm, int ix) {\nif(pos == nd) {\nif(st && sm > 0) {\nint prod = par[ix];\nreturn (prod % sm == 0) ? 1LL : 0LL;\n}\nreturn 0LL;\n}\nunsigned int key = make_key(pos, t, st, sm, ix);\nint h = key & (MAXH - 1);\nwhile(1) {\nif(dp_key[h] == 0xFFFFFFFF)\nbreak;\nif(dp_key[h] == key)\nreturn dp_val[h];\nh = (h + 1) & (MAXH - 1);\n}\nint lim = t ? dgt[pos] : 9;\nlong long res = 0;\nfor (int x = 0; x <= lim; x++) {\nint nt = (t && (x == lim));\nif(!st) {\nif(x == 0)\nres += f_beauty(pos + 1, nt, 0, sm, ix);\nelse {\nint nix;\nif(x == 1)\nnix = ix;\nelse {\nint newprod = par[ix] * x;\nnix = get_ix(newprod);\nif(nix < 0)\ncontinue;\n}\nres += f_beauty(pos + 1, nt, 1, sm + x, (x == 1) ? ix : nix);\n}\n} else {\nif(x == 0)\ncontinue;\nint nix;\nif(x == 1)\nnix = ix;\nelse {\nint newprod = par[ix] * x;\nnix = get_ix(newprod);\nif(nix < 0)\ncontinue;\n}\nres += f_beauty(pos + 1, nt, 1, sm + x, (x == 1) ? ix : nix);\n}\n}\nh = key & (MAXH - 1);\nwhile(dp_key[h] != 0xFFFFFFFF)\nh = (h + 1) & (MAXH - 1);\ndp_key[h] = key;\ndp_val[h] = res;\nreturn res;\n}\n\nlong long F_bt(int x) {\nchar buf[20];\nsprintf(buf, \"%d\", x);\nnd = 0;\nfor(char *p = buf; *p; p++)\ndgt[nd++] = *p - '0';\ndp_clear();\nint ix0 = get_ix(1);\nreturn f_beauty(0, 1, 0, 0, ix0);\n}\n\nlong long dp_nz[MAXP][2][2];\nchar vis_nz[MAXP][2][2];\nlong long f_nz(int pos, int t, int st) {\nif(pos == nd)\nreturn st;\nif(vis_nz[pos][t][st])\nreturn dp_nz[pos][t][st];\nvis_nz[pos][t][st] = 1;\nint lim = t ? dgt[pos] : 9;\nlong long res = 0;\nfor(int x = 0; x <= lim; x++) {\nint nt = (t && (x == lim));\nif(!st) {\nif(x == 0)\nres += f_nz(pos + 1, nt, 0);\nelse\nres += f_nz(pos + 1, nt, 1);\n} else {\nif(x == 0)\ncontinue;\nres += f_nz(pos + 1, nt, 1);\n}\n}\ndp_nz[pos][t][st] = res;\nreturn res;\n}\n\nlong long F_nz(int x) {\nchar buf[20];\nsprintf(buf, \"%d\", x);\nnd = 0;\nfor(char *p = buf; *p; p++)\ndgt[nd++] = *p - '0';\nmemset(vis_nz, 0, sizeof(vis_nz));\nreturn f_nz(0, 1, 0);\n}\n\nint beautifulNumbers(int L, int R) {\nif(pc == 0)\ninit_par();\nlong long tot = (long long)R - L + 1;\nlong long nz = F_nz(R) - F_nz(L - 1);\nlong long bt = F_bt(R) - F_bt(L - 1);\nlong long ans = (tot - nz) + bt;\nreturn (int)ans;\n}\n","author":"kl2400032885","submissionId":"1575145306"},[]]},{"49":[{"id":"49","fileName":"1575136781.txt","sourceCode":"class Solution {\npublic:\n    struct State {\n    int pos;\n    bool started;\n    int sum;\n    long long prod;\n    bool tight;\n    bool operator==(const State &other) const {\n        return pos == other.pos && started == other.started &&\n               sum == other.sum && prod == other.prod && tight == other.tight;\n    }\n};\n\nstruct StateHash {\n    size_t operator()(const State &s) const {\n        size_t h1 = hash<int>()(s.pos);\n        size_t h2 = hash<int>()(s.sum);\n        size_t h3 = hash<long long>()(s.prod);\n        size_t h4 = hash<bool>()(s.started);\n        size_t h5 = hash<bool>()(s.tight);\n        return (((h1 ^ (h2 << 1)) >> 1) ^ (h3 << 1)) ^ (h4 << 2) ^ (h5 << 3);\n    }\n};\n\nint beautifulNumbers(int l, int r) {\n    auto countBeautiful = [&](int x) -> long long {\n        string s = to_string(x);\n        unordered_map<State, long long, StateHash> memo;\n        function<long long(int, bool, int, long long, bool)> dp = [&](int pos, bool started, int sum, long long prod, bool tight) -> long long {\n            if(pos == s.size()){\n                // Only count if a number was formed and sum != 0 and product divisible by sum.\n                return (started && sum != 0 && prod % sum == 0) ? 1LL : 0LL;\n            }\n            State st{pos, started, sum, prod, tight};\n            if(memo.count(st)) return memo[st];\n            int limit = tight ? s[pos] - '0' : 9;\n            long long ways = 0;\n            for(int d = 0; d <= limit; d++){\n                bool ntight = tight && (d == limit);\n                if(!started && d == 0) {\n                    ways += dp(pos+1, false, 0, 1, ntight);\n                } else {\n                    int nsum = sum + d;\n                    long long nprod = (started ? prod : 1LL) * d;\n                    ways += dp(pos+1, true, nsum, nprod, ntight);\n                }\n            }\n            memo[st] = ways;\n            return ways;\n        };\n        return dp(0, false, 0, 1, true);\n    };\n    \n    long long ans = countBeautiful(r) - (l > 1 ? countBeautiful(l - 1) : 0);\n    return (int)ans;\n}\n};","author":"Maverick","submissionId":"1575136781"},[]]},{"50":[{"id":"50","fileName":"1575141244.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        ls = (l, r)  \n\n        def solve(x):\n            if x < 1:\n                return 0\n            s = str(x)\n            n = len(s)\n\n            @lru_cache(None)\n            def dp(pos, tight, start, zero, dsum, prod):\n                if pos == n:\n                    if not start:\n                        return 0  \n                    return 1 if zero or (dsum != 0 and prod % dsum == 0) else 0\n\n                ans = 0\n                lim = int(s[pos]) if tight else 9\n\n                for d in range(lim + 1):\n                    ns = tight and (d == lim)\n                    if not start:\n                        if d == 0:\n                            ans += dp(pos + 1, ns, 0, 0, 0, 1)\n                        else:\n                            ans += dp(pos + 1, ns, 1, 0, d, d)\n                    else:\n                        if zero:\n                            ans += dp(pos + 1, ns, 1, 1, dsum + d, 0)\n                        else:\n                            if d == 0:\n                                ans += dp(pos + 1, ns, 1, 1, dsum, 0)\n                            else:\n                                ans += dp(pos + 1, ns, 1, 0, dsum + d, prod * d)\n\n                return ans\n\n            return dp(0, 1, 0, 0, 0, 1)\n\n        return solve(ls[1]) - solve(ls[0] - 1)","author":"srujan","submissionId":"1575141244"},[]]},{"51":[{"id":"51","fileName":"1575139041.txt","sourceCode":"from collections import Counter\nclass Solution:\n    def beautifulNumbers(self, start: int, finish: int) -> int:\n        def count_bound(n: int) -> int:\n            if n < 1:\n                return 0\n            digits = list(map(int, str(n)))\n            length = len(digits)\n            dp = {(0, 1, 0): Counter({(0, 1): 1})}\n            for pos in range(length):\n                next_dp = {}\n                lim = digits[pos]\n                for (idx, bound, flag), state_counter in dp.items():\n                    hi = lim if bound else 9\n                    for d in range(hi + 1):\n                        new_bound = 1 if (bound and d == hi) else 0\n                        new_flag = 1 if (flag or d > 0) else 0\n                        key = (pos + 1, new_bound, new_flag)\n                        cnt = next_dp.get(key, Counter())\n                        for (sm, prod), ways in state_counter.items():\n                            if new_flag:\n                                ns = sm + d\n                                np = prod * d if (prod != 0 and d != 0) else 0\n                            else:\n                                ns, np = 0, 1\n                            cnt[(ns, np)] += ways\n                        next_dp[key] = cnt\n                dp = next_dp\n            total = 0\n            for (pos, _, flag), cnt in dp.items():\n                if pos == length and flag:\n                    for (s, p), ways in cnt.items():\n                        if s != 0 and p % s == 0:\n                            total += ways\n            return total\n        return count_bound(finish) - count_bound(start - 1)","author":"coder","submissionId":"1575139041"},[]]},{"52":[{"id":"52","fileName":"1575140976.txt","sourceCode":"class Solution {\n    public int beautifulNumbers(int l, int r) {\n        long ans = countBeautiful(r) - countBeautiful(l - 1);\n        return (int) ans;\n    }\n    \n    private long countBeautiful(int x) {\n        if(x <= 0) return 0;\n        String s = Integer.toString(x);\n        Map<String, Long> memoBeautiful = new HashMap<>();\n        long countNoZeroBeautiful = dpBeautiful(s, 0, true, false, 0, 1, memoBeautiful);\n        Map<String, Long> memoNoZero = new HashMap<>();\n        long countNoZero = dpNoZero(s, 0, true, false, memoNoZero);\n        long total = x;\n        long countWithZero = total - countNoZero;\n        return countWithZero + countNoZeroBeautiful;\n    }\n    \n    private long dpBeautiful(String s, int pos, boolean tight, boolean started, int sum, int prod, Map<String, Long> memo) {\n        if(pos == s.length()) {\n            return (started && sum != 0 && prod % sum == 0) ? 1 : 0;\n        }\n        String key = pos + \",\" + (tight ? 1 : 0) + \",\" + (started ? 1 : 0) + \",\" + sum + \",\" + prod;\n        if(memo.containsKey(key)) return memo.get(key);\n        int limit = tight ? s.charAt(pos) - '0' : 9;\n        long ways = 0;\n        for(int d = 0; d <= limit; d++){\n            boolean n_tight = tight && (d == limit);\n            if(!started) {\n                if(d == 0) ways += dpBeautiful(s, pos+1, n_tight, false, sum, prod, memo);\n                else ways += dpBeautiful(s, pos+1, n_tight, true, sum+d, d, memo);\n            }else{\n                if(d == 0) continue;\n                ways += dpBeautiful(s, pos+1, n_tight, true, sum+d, prod*d, memo);\n            }\n        }\n        memo.put(key, ways);\n        return ways;\n    }\n    \n    private long dpNoZero(String s, int pos, boolean tight, boolean started, Map<String, Long> memo) {\n        if(pos == s.length()) return started ? 1 : 0;\n        String key = pos + \",\" + (tight ? 1 : 0) + \",\" + (started ? 1 : 0);\n        if(memo.containsKey(key)) return memo.get(key);\n        int limit = tight ? s.charAt(pos) - '0' : 9;\n        long ways = 0;\n        for(int d = 0; d <= limit; d++){\n            boolean n_tight = tight && (d == limit);\n            if(!started) {\n                if(d == 0) ways += dpNoZero(s, pos+1, n_tight, false, memo);\n                else ways += dpNoZero(s, pos+1, n_tight, true, memo);\n            }else{\n                if(d == 0) continue;\n                ways += dpNoZero(s, pos+1, n_tight, true, memo);\n            }\n        }\n        memo.put(key, ways);\n        return ways;\n    }\n}","author":"Md Yusuf","submissionId":"1575140976"},[]]},{"53":[{"id":"53","fileName":"1575141078.txt","sourceCode":"int dp[10][2][2][2][7][5][3][3][82];\nvector<int> pws[10];\n\nclass Solution {\npublic:\n    \n    int f(string &s, int pos, bool lead, bool tight, bool zero, int p2, int p3, int p5, int p7, int sum) {\n\n        p2 = min(p2, 6);\n        p3 = min(p3, 4);\n        p5 = min(p5, 2);\n        p7 = min(p7, 2);\n        \n        if(pos == s.size())\n        {\n             if(sum == 0) return 0;\n    \n             int prod = zero ? 0 : 1;\n             for(int i = 0; i < p2; ++i) prod = (prod * 2) % sum;\n             for(int i = 0; i < p3; ++i) prod = (prod * 3) % sum;\n             for(int i = 0; i < p5; ++i) prod = (prod * 5) % sum;\n             for(int i = 0; i < p7; ++i) prod = (prod * 7) % sum;\n\n             return prod % sum == 0;\n        }\n\n        int &ans = dp[pos][lead][tight][zero][p2][p3][p5][p7][sum]; if(ans != -1) return ans;\n        ans = 0;\n\n        int lb = 0, ub = tight ? s[pos] - '0' : 9;\n        for(int i = lb; i <= ub; ++i)\n        {\n            ans += f(s, \n                pos + 1, \n                lead and i == 0,\n                tight and i == ub, \n                zero or ((!lead) and i == 0), \n                p2 + pws[i][0], \n                p3 + pws[i][1], \n                p5 + pws[i][2], \n                p7 + pws[i][3], \n                sum + i\n            );\n        }\n\n        return ans;\n    }\n\n    int beautifulNumbers(int l, int r) {\n\n        pws[0] = {0, 0, 0, 0};\n\n        for(int i = 1; i < 10; ++i)\n        {\n            pws[i].clear();\n    \n            int temp = i, idx = 0;\n            for(int j : {2, 3, 5, 7})\n            {\n                int cnt = 0;\n                while(temp % j == 0)\n                {\n                    temp /= j;\n                    ++cnt;\n                }\n                pws[i].push_back(cnt);\n            }\n        }\n        \n        auto R = to_string(r), L = to_string(l - 1);\n        \n        memset(dp, -1, sizeof dp);\n        int ans = f(R, 0, true, true, false, 0, 0, 0, 0, 0);\n        \n        memset(dp, -1, sizeof dp);\n        ans -= f(L, 0, true, true, false, 0, 0, 0, 0, 0);\n        \n        return ans;\n    }\n};","author":"Dhruv Pasricha","submissionId":"1575141078"},[]]},{"54":[{"id":"54","fileName":"1575147176.txt","sourceCode":"@cache\ndef helper2(rstr: str, s: int, index: int, mod: int, remain_sum: int, flag: bool, flag2: bool) -> int:\n    length = len(rstr)\n    remains = length - index\n    if remains == 0:\n        if mod == 0 and remain_sum == 0:\n            return 1\n        return 0\n    if remain_sum > remains * 9:\n        return 0\n    if remain_sum < 0:\n        return 0\n    up = 9 if flag else int(rstr[index])\n    up = min(up, remain_sum)\n    ans = 0\n    for i in range(0, up + 1):\n        new_flag = flag or i < up\n        new_flag2 = flag2 or i > 0\n        if new_flag2:\n            newmod = (mod * i) % s\n        else:\n            newmod = 1\n        ans += helper2(rstr, s, index + 1, newmod, remain_sum - i, new_flag, new_flag2)\n    return ans\n\n@cache\ndef helper(r: int) -> int:\n    if r == 0:\n        return 0\n    ans = 0\n    rstr = str(r)\n    for s in range(1, 82):\n        temp = helper2(rstr, s, 0, 1, s, False, False)\n        # print(r, s, temp)\n        ans += temp\n    return ans\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return helper(r) - helper(l - 1)\n\n","author":"lydxlx","submissionId":"1575147176"},[]]},{"55":[{"id":"55","fileName":"1575149340.txt","sourceCode":"def count_beautiful_upto(X):\n    digits = list(map(int, str(X)))\n    n = len(digits)\n    @lru_cache(maxsize=None)\n    def dp(pos, tight, started, s, p):\n        if pos == n:\n            if started:\n                if p == 0:\n                    return 1\n                else:\n                    return 1 if (s != 0 and p % s == 0) else 0\n            else:\n                return 0\n        res = 0\n        limit = digits[pos] if tight else 9\n        for dig in range(0, limit + 1):\n            ntight = tight and (dig == limit)\n            if not started:\n                if dig == 0:\n                    res += dp(pos + 1, ntight, False, 0, 1)\n                else:\n                    res += dp(pos + 1, ntight, True, dig, dig)\n            else:\n                ns = s + dig\n                if p == 0 or dig == 0:\n                    np = 0\n                else:\n                    np = p * dig\n                res += dp(pos + 1, ntight, True, ns, np)\n        return res\n\n    return dp(0, True, False, 0, 1)\n\n    \n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return count_beautiful_upto(r) - count_beautiful_upto(l - 1)","author":"Bariscan","submissionId":"1575149340"},[]]},{"56":[{"id":"56","fileName":"1575147541.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        @cache\n        def dp(s, curr, edge, zero, curr_sum, curr_prod):\n            if curr == len(s):\n                if curr_sum == 0:\n                    return 0\n                return curr_prod % curr_sum == 0\n\n            res = 0\n            bound = int(s[curr]) if edge else 9\n\n            for digit in range(bound + 1):\n                res += dp(s, curr + 1,\n                    edge and digit == bound,\n                    zero and digit == 0,\n                    curr_sum + digit, \n                    curr_prod * digit if not (zero and digit == 0) else curr_prod\n                )\n            return res\n\n        return dp(str(r), 0, True, True, 0, 1) - dp(str(l - 1), 0, True, True, 0, 1)","author":"rukt","submissionId":"1575147541"},[]]},{"57":[{"id":"57","fileName":"1575146871.txt","sourceCode":"\nclass Solution {\n    public:\n        int dp[10][91][91][2][2];\n        int Solve(const vector<int>& digs, int pos, int curr_prod_mod, int curr_summ, bool is_less, bool is_non_zero,  int sum_digs) {\n\n            if (pos == digs.size()) {\n                return curr_summ == sum_digs && curr_prod_mod % sum_digs == 0;\n            }\n            if (curr_summ > sum_digs) return 0;\n            if (dp[pos][curr_prod_mod][curr_summ][is_less][is_non_zero] != -1) {\n                return dp[pos][curr_prod_mod][curr_summ][is_less][is_non_zero];\n            }\n            int ans = 0;\n            for(int d=0;d<=9;d++) {\n                if(!is_less && d > digs[pos]) break;\n                int new_is_non_zero = is_non_zero || d > 0;\n                int new_prod_mod = curr_prod_mod % sum_digs;\n                if (new_is_non_zero) {\n                    new_prod_mod = (new_prod_mod * d) % sum_digs;\n                }\n                int new_summ = curr_summ + d;\n                int new_is_less = is_less || d < digs[pos];\n                ans += Solve(digs, pos+1, new_prod_mod, new_summ, new_is_less, new_is_non_zero, sum_digs);\n            }\n            return dp[pos][curr_prod_mod][curr_summ][is_less][is_non_zero]=ans;\n        }\n\n        vector<int> getDigs(int x) {\n            vector<int> digs;\n            while(x) {\n                digs.push_back(x%10);\n                x /= 10;\n            }\n            reverse(digs.begin(), digs.end());\n            return digs;\n        }\n\n        int Solve(const vector<int>& digs, int sum_digs) {\n            for(int pos=0;pos<=digs.size();pos++) {\n                for(int curr_prod_mod=0;curr_prod_mod<sum_digs;curr_prod_mod++) {\n                    for(int curr_summ=0;curr_summ<=sum_digs;curr_summ++) {\n                        for(int is_less=0;is_less<2;is_less++) {\n                            for(int is_non_zero=0;is_non_zero<2;is_non_zero++) {\n                                dp[pos][curr_prod_mod][curr_summ][is_less][is_non_zero] = -1;\n                            }\n                        }\n                    }\n                }\n            }\n            return Solve(digs, 0, 1 % sum_digs, 0, 0, 0, sum_digs);\n\n        }\n        \n        int beautifulNumbers(int l, int r) {\n            // sum of the digits can be 1, 2,..., 9*num_digs\n            vector<int> rdigs = getDigs(r);\n            int ans = 0;\n            vector<int> ldigs = getDigs(l-1);\n            int max_sum_digs = min(9*(int)rdigs.size(), 81);\n            for(int sum_digs=1;sum_digs<=max_sum_digs;sum_digs++) {\n                ans += Solve(rdigs, sum_digs);\n                if (l > 1)  {\n                    ans -= Solve(ldigs, sum_digs);\n                }\n            }\n            return ans;\n        }\n    };\n","author":"Balakrishnan Varadarajan","submissionId":"1575146871"},[]]},{"58":[{"id":"58","fileName":"1575149742.txt","sourceCode":"class Solution {\npublic:\n    vector<int> ds;\n    int go(int pos, bool any, int sum, int prod, map<int, int> dp[10][2][82]) {\n        if (pos == ds.size()) {\n            return sum > 0 && prod % sum == 0;\n        }\n        auto& dq = dp[pos][any][sum];\n        auto it = dq.find(prod);\n        if (it != dq.end()) return it->second;\n        int ans = 0;\n        int u = any ? 9 : ds[pos];\n        for (int i = 0; i <= u; i++) {\n            int ns = sum + i;\n            ans += go(pos + 1, any || i < ds[pos], sum + i, ns == 0 ? 1 : prod * i, dp);\n        }\n        dq.emplace_hint(it, prod, ans);\n        return ans;\n    }\n    int solve(int n) {\n        if (n == 0) return 0;\n        map<int, int> dp[10][2][82];\n        ds.clear();\n        for (int x = n; x; x /= 10) ds.push_back(x % 10);\n        reverse(ds.begin(), ds.end());\n        return go(0, 0, 0, 1, dp);\n    }\n    int beautifulNumbers(int l, int r) {\n        int ans = solve(r) - solve(l - 1);\n        return ans;\n    }\n};\n","author":"Shik Chen","submissionId":"1575149742"},[]]},{"59":[{"id":"59","fileName":"1575149494.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n    \n        def dp(numStr):\n            n = len(numStr)\n            \n            @lru_cache(None)\n            def dfs(pos, tight, leadingZero, digitSum, digitProduct):\n                if pos == n:\n                    if leadingZero:\n                        return 0  # ignore leading zeros\n                    if digitSum == 0:\n                        return 0  # avoid division by zero\n                    return 1 if digitProduct % digitSum == 0 else 0\n                \n                res = 0\n                limit = int(numStr[pos]) if tight else 9\n                \n                for d in range(0, limit + 1):\n                    newTight = tight and (d == limit)\n                    newLeadingZero = leadingZero and d == 0\n                    newSum = digitSum + d if not newLeadingZero else 0\n                    newProduct = digitProduct * d if not newLeadingZero else 1\n                    res += dfs(pos + 1, newTight, newLeadingZero, newSum, newProduct)\n                \n                return res\n            \n            return dfs(0, True, True, 0, 1)\n        \n        def count(x):\n            return dp(str(x))\n        \n        return count(r) - count(l - 1)\n","author":"bhargav yarlagadda","submissionId":"1575149494"},[]]},{"60":[{"id":"60","fileName":"1575149693.txt","sourceCode":"using i64 = long long;\nvector<int> digits;\nint n; \nunordered_map<i64, int> nine, zero;\n\nclass Solution {\npublic:\n    \n    //zip\n    i64 encode9(int pos, int isLimit, int sum, int product) {\n        return ((i64)product << 12) | ((i64)sum << 5) | ((i64)isLimit << 4) | pos;\n    }\n    \n    i64 encode0(int pos, int isLimit) {\n        return ((i64)isLimit << 4) | pos;\n    }\n    \n    int dp_withzero(int pos, int isLimit) {\n        if (pos == n) return 1;\n        i64 key = encode0(pos, isLimit);\n        if (zero.find(key) != zero.end()) return zero[key];\n        int ways = 0;\n        int limit = (isLimit ? digits[pos] : 9);\n        for (int d = 0; d <= limit; d++){\n            int updatedLimit = (isLimit && (d == limit)) ? 1 : 0;\n            ways += dp_withzero(pos+1, updatedLimit);\n        }\n        zero[key] = ways;\n        return ways;\n    }\n    \n    int dp_nozero(int pos, int isLimit, int sum, int product) {\n        if (pos == n) {\n            if (sum == 0) return 0;\n            return (product % sum == 0) ? 1 : 0;\n        }\n        i64 key = encode9(pos, isLimit, sum, product);\n        if (nine.find(key) != nine.end()) return nine[key];\n        int ways = 0;\n        int limit = (isLimit ? digits[pos] : 9);\n        for (int d = 0; d <= limit; d++){\n            int updatedLimit = (isLimit && (d == limit)) ? 1 : 0;\n            if (sum == 0 && d == 0) {\n                ways += dp_nozero(pos+1, updatedLimit, 0, 1);\n            } else if (d == 0) {\n                ways += dp_withzero(pos+1, updatedLimit);\n            } else {\n                int nsum = sum + d;\n                int nprod = product * d;\n                ways += dp_nozero(pos+1, updatedLimit, nsum, nprod);\n            }\n        }\n        nine[key] = ways;\n        return ways;\n    }\n    \n    int countBeautiful(i64 x) {\n        if(x < 1) return 0;\n        string sx = to_string(x);\n        n = sx.size();\n        digits.resize(n);\n        for (int i = 0; i < n; i++){\n            digits[i] = sx[i] - '0';\n        }\n        nine.clear();\n        zero.clear();\n        return dp_nozero(0, 1, 0, 1);\n    }\n    \n    int beautifulNumbers(int l, int r) {\n        return countBeautiful(r) - countBeautiful(l - 1);\n    }\n};\n","author":"xymabinogi","submissionId":"1575149693"},[]]},{"61":[{"id":"61","fileName":"1575146992.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def cnt(n):\n            @cache\n            def dp(i, tight, leadingZero, p, s):\n                if i >= len(n):\n                    # if s > 0 and p % s == 0:\n                    #     print(p, s)\n                    return 1 if s > 0 and p % s == 0 else 0\n\n                res = 0\n                maxDigit = int(n[i]) if tight else 9\n                for d in range(maxDigit+1):\n                    nxtTight = tight and d == maxDigit\n                    nxtLeadingZero = leadingZero and d == 0\n                    if nxtLeadingZero:\n                        res += dp(i+1, nxtTight, nxtLeadingZero, p, s)\n                    else:\n                        res += dp(i+1, nxtTight, nxtLeadingZero, p*d, s+d)\n                return res\n            return dp(0, True, True, 1, 0)\n\n        return cnt(str(r)) - cnt(str(l-1))","author":"Andrew Lo Zhi Sheng","submissionId":"1575146992"},[]]},{"63":[{"id":"63","fileName":"1575150203.txt","sourceCode":"#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define ll                      long long\n#define ar                      array\n// #define int                     ll\n#define sz(v)                   (int)(v.size())\n#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define ld                      long double\n#define ull                     unsigned long long\n#define fo(i,a,b)               for(int i = a; i<=b ; i++)\n#define rfo(i,a,b)              for(int i = a; i>=b ; i--)\n#define vii                     vector<int>\n#define pq                      priority_queue\n#define uomii                   unordered_map<int,int,best_hash>\n#define all(v)                  v.begin(),v.end()\n#define mp                      make_pair\n#define pb                      push_back\n#define pob                     pop_back\n#define ff                      first\n#define ss                      second\n#define pii                     pair<int,int>\n#define mii                     map<int,int>\n#define vvii                    vector<vii>\n#define mod                     1000000007\n#define inf                     5e18\n#define pi                      3.1415926535897932384626433832795\n#define cz(x)                   63 - __builtin_clzll(x)\n\n\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n\n// https://codeforces.com/blog/entry/68809\n\nvoid __print(int x) {cout << x;}\nvoid __print(long x) {cout << x;}\nvoid __print(unsigned x) {cout << x;}\nvoid __print(unsigned long x) {cout << x;}\nvoid __print(unsigned long long x) {cout << x;}\nvoid __print(float x) {cout << x;}\nvoid __print(double x) {cout << x;}\nvoid __print(long double x) {cout << x;}\nvoid __print(char x) {cout << ''' << x << ''';}\nvoid __print(const char *x) {cout << '\"\"' << x << '\"\"';}\nvoid __print(const string &x) {cout << '\"\"' << x << '\"\"';}\nvoid __print(bool x) {cout << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? \",\" : \"\"), __print(i); cout << \"}\";}\nvoid _print() {cout << \"]n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define pr(x...) cout << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define pr(x...)\n#endif\n\n// https://codeforces.com/blog/entry/62393\n\nstruct best_hash {\n\tstatic uint64_t splitmix64(uint64_t x) {\n\n\t\tx += 0x9e3779b97f4a7c15;\n\t\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n\t\tx = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n\t\treturn x ^ (x >> 31);\n\t}\n\n\tsize_t operator()(uint64_t x) const {\n\t\tstatic const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n\t\treturn splitmix64(x + FIXED_RANDOM);\n\t}\n};\n\n\n/* ------------------------------- REAL CODING STARTS NOW --------------------------- */\n\nint dp[2][2][11][91][91];\nstring s;\nint n;\nclass Solution {\npublic:\n\n\tint gino(bool lead, bool sig, int pos, int sum, int cursum, int pro) {\n\t\tif (cursum > sum) return 0;\n\t\tif (pos == n) return (cursum == sum and pro == 0);\n\t\tint &ans = dp[lead][sig][pos][cursum][pro];\n\t\tif (ans != -1) return ans;\n\t\tans = 0;\n\n\t\tif (sig) {\n\t\t\tfo(dig, 0, 9) {\n\t\t\t\tbool nwLead = (lead & (dig == 0));\n\t\t\t\tans += gino(nwLead, 1, pos + 1, sum, cursum + dig, nwLead ? 1 : (pro * dig) % sum);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint upto = s[pos] - '0';\n\t\t\tfo(dig, 0, upto - 1) {\n\t\t\t\tbool nwLead = (lead & (dig == 0));\n\t\t\t\tans += gino(nwLead, 1, pos + 1, sum, cursum + dig, nwLead ? 1 : (pro * dig) % sum);\n\t\t\t}\n\t\t\tbool nwLead = (lead & (upto == 0));\n\t\t\tans += gino(nwLead, 0, pos + 1, sum, cursum + upto, nwLead ? 1 : (pro * upto) % sum);\n\t\t}\n\t\treturn ans;\n\t}\n\n\tint compute(int X) {\n\t\ts = to_string(X);\n\t\tn = sz(s);\n\t\tint res = 0;\n\n\t\tfo(sum, 1, n*9) {\n\t\t\tfo(i, 0, 1) {\n\t\t\t\tfo(j, 0, n - 1) {\n\t\t\t\t\tfo(s, 0, sum) {\n\t\t\t\t\t\tfo(rem, 0, sum) {\n\t\t\t\t\t\t\tdp[0][i][j][s][rem] = dp[1][i][j][s][rem] = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tres += gino(1, 0, 0, sum, 0, 1);\n\t\t}\n\t\treturn res;\n\t}\n\n\tint beautifulNumbers(int l, int r) {\n\t\treturn compute(r) - (r > 1 ? compute(l - 1) : 0);\n\t}\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","author":"Yatin Kwatra","submissionId":"1575150203"},[]]},{"64":[{"id":"64","fileName":"1575152677.txt","sourceCode":"constexpr int MAXN = 12;\nconstexpr int MAXM = 110;\n\nint d[MAXM], dp[MAXN][MAXM][MAXM][2];\n\nint DFS(int sum, int p, int s, int r, int z, bool lim) {\n  // printf(\"sum = %d, p = %d, s = %d, r = %d, z = %d, lim = %dn\", sum, p, s, r, z, (int)lim);\n  if (p == -1) {\n    return s == sum && r == 0;\n  }\n  if (!lim && ~dp[p][s][r][z]) {\n    return dp[p][s][r][z];\n  }\n  int m = lim ? d[p] : 9;\n  int ret = 0;\n  for (int i = 0; i <= m; ++i) {\n    if (s + i > sum) {\n      continue;\n    }\n    int rr = (z ? i : i * r) % sum;\n    int cur = DFS(sum, p - 1, s + i, rr, z && i == 0, lim && i == m);\n    ret += cur;\n  }\n  if (!lim) {\n    dp[p][s][r][z] = ret;\n  }\n  return ret;\n}\n\nint Calc(int n) {\n  int m = 0, ret = 0;\n  for (int i = n; i > 0; i /= 10) {\n    d[m++] = i % 10;\n  }\n  for (int i = 1; i < 100; ++i) {\n    memset(dp, -1, sizeof(dp));\n    int cur = DFS(i, m - 1, 0, 1, 1, true);\n    ret += cur;\n    // printf(\"i = %d, cur = %dn\", i, cur);\n  }\n  // printf(\"n = %d, ret = %dn\", n, ret);\n  return ret;\n}\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n      int ll = Calc(l - 1);\n      int rr = Calc(r);\n      return rr - ll;\n    }\n};","author":"Xiaomeng Yang","submissionId":"1575152677"},[]]},{"65":[{"id":"65","fileName":"1575152830.txt","sourceCode":"//████████╗██╗███╗░░██╗  ██╗░░░░░███████╗\n//╚══██╔══╝██║████╗░██║  ██║░░░░░██╔════╝\n//░░░██║░░░██║██╔██╗██║  ██║░░░░░█████╗░░\n//░░░██║░░░██║██║╚████║  ██║░░░░░██╔══╝░░\n//░░░██║░░░██║██║░╚███║  ███████╗███████╗\n//░░░╚═╝░░░╚═╝╚═╝░░╚══╝  ╚══════╝╚══════╝\n//   __________________\n//  | ________________ |\n//  ||          ____  ||\n//  ||   /    |      ||\n//  ||  /__   |      ||\n//  || /      |____  ||\n//  ||________________||\n//  |__________________|\n//  ###################\n//   ###################\n//            ____       \n//     _________________\n// An AC a day keeps the doctor away.\n\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <iomanip>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <array>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\ntemplate<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n#define vt vector\n#define all(x) begin(x), end(x)\n#define allr(x) rbegin(x), rend(x)\n#define ub upper_bound\n#define lb lower_bound\n#define db double\n#define ld long db\n#define ll long long\n#define ull unsigned long long\n#define vll vt<ll>  \n#define vvll vt<vll>\n#define pll pair<ll, ll>    \n#define vpll vt<pll>\n#define vvpll vt<vpll>\n#define vc vt<char> \n#define vvc vt<vc>\n#define vi vt<int>\n#define vvi vt<vi>\n#define vvvi vt<vvi>\n#define pii pair<int, int>\n#define vpii vt<pii>\n#define vs vt<string>\n#define vvs vt<vs>\n#define vb vt<bool>\n#define vvb vt<vb>\n#define vvpii vt<vpii>\n#define vd vt<db>\n#define ar(x) array<int, x>\n#define var(x) vt<ar(x)>\n#define vvar(x) vt<var(x)>\n#define al(x) array<ll, x>\n#define vall(x) vt<al(x)>\n#define vvall(x) vt<vall(x)>\n#define mset(m, v) memset(m, v, sizeof(m))\n#define pb push_back\n#define ff first\n#define ss second\n#define sv string_view\n#define MP make_pair\n#define MT make_tuple\n#define rsz resize\n#define sum(x) (ll)accumulate(all(x), 0LL)\n#define srt(x) sort(all(x))\n#define srtR(x) sort(allr(x))\n#define srtU(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())\n#define SORTED(x) is_sorted(all(x))\n#define rev(x) reverse(all(x))\n#define MAX(a) *max_element(all(a)) \n#define MIN(a) *min_element(all(a))\n#define ROTATE(a, p) rotate(begin(a), begin(a) + p, end(a))\n#define i128 __int128\n\n//SGT DEFINE\n#define lc i * 2 + 1\n#define rc i * 2 + 2\n#define lp lc, left, middle\n#define rp rc, middle + 1, right\n#define entireTree 0, 0, n - 1\n#define midPoint left + (right - left) / 2\n#define pushDown push(i, left, right)\n#define iter int i, int left, int right\n\n#define IOS ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n\nstruct custom {\n    static const uint64_t C = 0x9e3779b97f4a7c15; const uint32_t RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();\n    size_t operator()(uint64_t x) const { return __builtin_bswap64((x ^ RANDOM) * C); }\n    size_t operator()(const std::string& s) const { size_t hash = std::hash<std::string>{}(s); return hash ^ RANDOM; } };\ntemplate <class K, class V> using umap = std::unordered_map<K, V, custom>; template <class K> using uset = std::unordered_set<K, custom>;\ntemplate<class T> using max_heap = priority_queue<T>;\ntemplate<class T> using min_heap = priority_queue<T, vector<T>, greater<T>>;\n    \n    \ntemplate <typename T1, typename T2>  istream &operator>>(istream& in, pair<T1, T2>& input) {    return in >> input.ff >> input.ss; }\n    \ntemplate <typename T> istream &operator>>(istream &in, vector<T> &v) { for (auto &el : v) in >> el; return in; }\n\ntemplate<class T>\nvoid output_vector(vt<T>& a, int off_set = 0) {\n    int n = a.size();\n    for(int i = off_set; i < n; i++) {\n        cout << a[i] << (i == n - 1 ? 'n' : ' ');\n    }\n}\n\ntemplate<typename T, typename Compare>\nvi closest_left(const vt<T>& a, Compare cmp) {\n    int n = a.size(); vi closest(n); iota(all(closest), 0);\n    for (int i = 0; i < n; i++) {\n        auto& j = closest[i];\n        while(j && cmp(a[i], a[j - 1])) j = closest[j - 1];\n    }\n    return closest;\n}\n\ntemplate<typename T, typename Compare> // auto right = closest_right<int>(a, std::less<int>());\nvi closest_right(const vt<T>& a, Compare cmp) {\n    int n = a.size(); vi closest(n); iota(all(closest), 0);\n    for (int i = n - 1; i >= 0; i--) {\n        auto& j = closest[i];\n        while(j < n - 1 && cmp(a[i], a[j + 1])) j = closest[j + 1];\n    }\n    return closest;\n}\n\ntemplate<typename T, typename V = string>\nvt<pair<T, int>> encode(const V& s) {\n    vt<pair<T, int>> seg;\n    for(auto& ch : s) {\n        if(seg.empty() || ch != seg.back().ff) seg.pb({ch, 1});\n        else seg.back().ss++;\n    }\n    return seg;\n}\n\n    \ntemplate<typename K, typename V>\nauto operator<<(std::ostream &o, const std::map<K, V> &m) -> std::ostream& {\n    o << \"{\"; int i = 0;\n    for (const auto &[key, value] : m) { if (i++) o << \" , \"; o << key << \" : \" << value; }\n    return o << \"}\";\n}\n\n#ifdef LOCAL\n#define debug(x...) debug_out(#x, x)\nvoid debug_out(const char* names) { std::cerr << std::endl; }\ntemplate <typename T, typename... Args>\nvoid debug_out(const char* names, T value, Args... args) {\n    const char* comma = strchr(names, ',');\n    std::cerr << \"[\" << (comma ? std::string(names, comma) : names) << \" = \" << value << \"]\";\n    if (sizeof...(args)) { std::cerr << \", \"; debug_out(comma + 1, args...); }   \n    else { std::cerr << std::endl; }\n}\ntemplate<typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& o, const std::pair<T1, T2>& p) { return o << \"{\" << p.ff << \" , \" << p.ss << \"}\"; }\nauto operator<<(auto &o, const auto &x) -> decltype(end(x), o) {\n    o << \"{\"; int i = 0; for (const auto &e : x) { if (i++) o << \" , \"; o << e; } return o << \"}\";\n} // remove for leetcode\n#include <sys/resource.h>\n#include <sys/time.h>\nvoid printMemoryUsage() {\n    struct rusage usage;\n    getrusage(RUSAGE_SELF, &usage);\n    double memoryMB = usage.ru_maxrss / 1024.0;\n    cerr << \"Memory usage: \" << memoryMB << \" MB\" << \"n\";\n}\n\n#define startClock clock_t tStart = clock();\n#define endClock std::cout << std::fixed << std::setprecision(10) << \"nTime Taken: \" << (double)(clock() - tStart) / CLOCKS_PER_SEC << \" seconds\" << std::endl;\n#else\n#define debug(...)\n#define startClock\n#define endClock\n\n#endif\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define eps 1e-9\n#define M_PI 3.14159265358979323846\nconst static string pi = \"3141592653589793238462643383279\";\nconst static ll INF = 1LL << 62;\nconst static int inf = 1e9 + 100;\nconst static int MK = 20;\nconst static int MX = 1e5 + 5;\nconst static int MOD = 1e9 + 7;\nll gcd(ll a, ll b) { while (b != 0) { ll temp = b; b = a % b; a = temp; } return a; }\nll lcm(ll a, ll b) { return (a / gcd(a, b)) * b; }\nint pct(ll x) { return __builtin_popcountll(x); }\nll have_bit(ll x, int b) { return x & (1LL << b); }\nint min_bit(ll x) { return __builtin_ctzll(x); }\nint max_bit(ll x) { return 63 - __builtin_clzll(x); } \nconst vvi dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {1, 1}, {-1, -1}, {1, -1}, {-1, 1}}; // UP, DOWN, LEFT, RIGHT\nconst vc dirChar = {'U', 'D', 'L', 'R'};\nint modExpo(ll base, ll exp, ll mod) { ll res = 1; base %= mod; while(exp) { if(exp & 1) res = (res * base) % mod; base = (base * base) % mod; exp >>= 1; } return res; }\nint modExpo_on_string(ll a, string exp, int mod) { ll b = 0; for(auto& ch : exp) b = (b * 10 + (ch - '0')) % (mod - 1); return modExpo(a, b, mod); }\nll sum_even_series(ll n) { return (n / 2) * (n / 2 + 1);} \nll sum_odd_series(ll n) {return n - sum_even_series(n);} // sum of first n odd number is n ^ 2\nll sum_of_square(ll n) { return n * (n + 1) * (2 * n + 1) / 6; } // sum of 1 + 2 * 2 + 3 * 3 + 4 * 4 + ... + n * n\nmap<int, int> dp[2][2][10][101];\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        string s = to_string(l);\n        string t = to_string(r);\n        s = string(t.size() - s.size(), '0') + s;\n        int n = s.size();\n        for(int tight1 = 0; tight1 < 2; tight1++) {\n            for(int tight2 = 0; tight2 < 2; tight2++) {\n                for(int i = 0; i < n; i++) {\n                    for(int sm = 0; sm < 100; sm++) {\n                        map<int, int>().swap(dp[tight1][tight2][i][sm]);\n                    }\n                }\n            }\n        }\n        auto dfs = [&](auto& dfs, int i = 0, bool tight1 = true, bool tight2 = true, int prod = 1, int sm = 0) -> int {\n            if(i == n) return prod % sm == 0;\n            auto& curr = dp[tight1][tight2][i][sm];\n            if(curr.count(prod)) return curr[prod];\n            int low = tight1 ? s[i] - '0' : 0; \n            int high = tight2 ? t[i] - '0' : 9;\n            int res = 0;\n            for(int digit = low; digit <= high; digit++) {\n                res += dfs(dfs, i + 1, tight1 && digit == low, tight2 && digit == high, (sm == 0 && digit == 0 ? prod : prod * digit), sm + digit);\n            }\n            return curr[prod] = res;\n        };\n        return dfs(dfs);\n    }\n};\n\n#ifdef LOCAL\nvoid solve() {\n    int l, r; cin >> l >> r;\n    Solution sol;\n    cout << sol.beautifulNumbers(l, r) << endl;\n}\n\nsigned main() {\n    // careful for overflow, check for long long, use unsigned long long for random generator\n    // when mle, look if problem require read in file, typically old problems\n    IOS;\n    startClock\n    //generatePrime();\n\n    int t = 1;\n    //cin >> t;\n    for(int i = 1; i <= t; i++) {   \n        //cout << \"Case #\" << i << \": \";  \n        solve();\n    }\n\n    endClock\n    #ifdef LOCAL\n      printMemoryUsage();\n    #endif\n\n    return 0;\n}\n#endif\n\n//███████████████████████████████████████████████████████████████████████████████████████████████████████\n//█░░░░░░░░░░░░░░█░░░░░░██████████░░░░░░█░░░░░░░░░░░░███░░░░░░░░░░█░░░░░░██████████░░░░░░█░░░░░░░░░░░░░░█\n//█░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀░░░░░░░░░░██░░▄▀░░█░░▄▀▄▀▄▀▄▀░░░░█░░▄▀▄▀▄▀░░█░░▄▀░░░░░░░░░░██░░▄▀░░█░░▄▀▄▀▄▀▄▀▄▀░░█\n//█░░▄▀░░░░░░░░░░█░░▄▀▄▀▄▀▄▀▄▀░░██░░▄▀░░█░░▄▀░░░░▄▀▄▀░░█░░░░▄▀░░░░█░░▄▀▄▀▄▀▄▀▄▀░░██░░▄▀░░█░░▄▀░░░░░░░░░░█\n//█░░▄▀░░█████████░░▄▀░░░░░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░███░░▄▀░░███░░▄▀░░░░░░▄▀░░██░░▄▀░░█░░▄▀░░█████████\n//█░░▄▀░░░░░░░░░░█░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░███░░▄▀░░███░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░█████████\n//█░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░███░░▄▀░░███░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░██░░░░░░█\n//█░░▄▀░░░░░░░░░░█░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░███░░▄▀░░███░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░█\n//█░░▄▀░░█████████░░▄▀░░██░░▄▀░░░░░░▄▀░░█░░▄▀░░██░░▄▀░░███░░▄▀░░███░░▄▀░░██░░▄▀░░░░░░▄▀░░█░░▄▀░░██░░▄▀░░█\n//█░░▄▀░░░░░░░░░░█░░▄▀░░██░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀░░░░▄▀▄▀░░█░░░░▄▀░░░░█░░▄▀░░██░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀░░░░░░▄▀░░█\n//█░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀░░██░░░░░░░░░░▄▀░░█░░▄▀▄▀▄▀▄▀░░░░█░░▄▀▄▀▄▀░░█░░▄▀░░██░░░░░░░░░░▄▀░░█░░▄▀▄▀▄▀▄▀▄▀░░█\n//█░░░░░░░░░░░░░░█░░░░░░██████████░░░░░░█░░░░░░░░░░░░███░░░░░░░░░░█░░░░░░██████████░░░░░░█░░░░░░░░░░░░░░█\n//███████████████████████████████████████████████████████████████████████████████████████████████████████\n","author":"tin_le","submissionId":"1575152830"},[]]},{"67":[{"id":"67","fileName":"1575153212.txt","sourceCode":"from functools import cache\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_beautiful(num):\n            n = len(num)\n            \n            @cache\n            def dfs(pos, s, p, tight, leading):\n                if pos == n:\n                    if leading:\n                        return 0\n                    return int(s > 0 and p % s == 0)\n                \n                res = 0\n                max_digit = int(num[pos]) if tight else 9\n                \n                for d in range(max_digit + 1):\n                    new_s = s + d\n                    if leading and d == 0:\n                        new_p = 1\n                    else:\n                        new_p = p * d\n                    res += dfs(pos + 1, new_s, new_p, tight and d == max_digit, leading and d == 0)\n                return res\n            \n            return dfs(0, 0, 1, True, True)\n        \n        l, r = str(l-1), str(r)\n        return count_beautiful(r) - count_beautiful(l)","author":"xy-li","submissionId":"1575153212"},[]]},{"68":[{"id":"68","fileName":"1575153259.txt","sourceCode":"class Solution\n{\npublic:\n  int beautifulNumbers(int c1, int c)\n  {\n    return solve(c) - solve(c1 - 1);\n  }\n\nprivate:\n  int calc(const vector<int> &d1, int pos, int t, int st, int sum, int p1, map<long long, int> &mp1)\n  {\n    long long it = pos, l1, ans = 0;\n    if (pos == d1.size())\n    {\n      if (!st)\n      {\n        return 0;\n      }\n      if ((sum && p1 % sum == 0))\n      {\n        return 1;\n      }\n      else\n      {\n        return 0;\n      }\n    }\n    it = it | (((long long)t << 4) | ((long long)st << 5) | ((long long)sum << 6) | ((long long)p1 << 13));\n\n    if (mp1.count(it))\n    {\n      return mp1[it];\n    }\n    if (t)\n    {\n      l1 = d1[pos];\n    }\n    else\n    {\n      l1 = 9;\n    }\n    for (int x = 0; x <= l1; x++)\n    {\n      int nt;\n      if (t && x == l1)\n      {\n        nt = 1;\n      }\n      else\n      {\n        nt = 0;\n      }\n      int ns;\n      if (st || x != 0)\n      {\n        ns = 1;\n      }\n      else\n      {\n        ns = 0;\n      }\n      int ss;\n      if (ns)\n      {\n        ss = sum + x;\n      }\n      else\n      {\n        ss = 0;\n      }\n      int np;\n      if (ns)\n      {\n        if (st)\n        {\n          np = p1 * x;\n        }\n        else\n        {\n          np = x;\n        }\n      }\n      else\n      {\n        np = 1;\n      }\n      ans = ans + calc(d1, pos + 1, nt, ns, ss, np, mp1);\n    }\n    return mp1[it] = ans;\n  }\n  int solve(int x)\n  {\n    if (x < 0)\n      return 0;\n    vector<int> d1;\n    while (x)\n    {\n      d1.push_back(x % 10);\n      x /= 10;\n    }\n    reverse(d1.begin(), d1.end());\n    map<long long, int> mp1;\n    return calc(d1, 0, 1, 0, 0, 1, mp1);\n  }\n};\n","author":"Khushal Midha","submissionId":"1575153259"},[]]},{"70":[{"id":"70","fileName":"1575154876.txt","sourceCode":"from functools import lru_cache\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_beautiful(n: int) -> int:\n            digits = list(map(int, str(n)))\n            length = len(digits)\n            \n            @lru_cache(None)\n            def dp(pos: int, tight: bool, digit_sum: int, digit_product: int, leading_zero: bool) -> int:\n                if pos == length:\n                    return 1 if digit_sum != 0 and digit_product % digit_sum == 0 else 0\n                \n                limit = digits[pos] if tight else 9\n                total = 0\n                \n                for d in range(0, limit + 1):\n                    total += dp(\n                        pos + 1,\n                        tight and (d == limit),\n                        digit_sum + d if not leading_zero or d != 0 else 0,\n                        digit_product * d if not leading_zero or d != 0 else 1,\n                        leading_zero and d == 0\n                    )\n                return total\n            \n            return dp(0, True, 0, 1, True)\n        \n        return count_beautiful(r) - count_beautiful(l - 1)","author":"Vikram","submissionId":"1575154876"},[]]},{"71":[{"id":"71","fileName":"1575155192.txt","sourceCode":"from functools import lru_cache\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        # prolly some kind of DP since nt q\n        # 0s in number = trivially beautiful number, trim search path\n        \n        # store prime factorization instead of actual number to avoid slowdown\n        # if sum ends up having a prime factor > largest single-digit prime (7) then fail\n        def helper(x):\n            num = [int(c) for c in str(x)]\n            n = len(num)\n            # exc means next digit < r corresponding digit\n            # can unset exc if we choose smaller digit at same place (e.g. 199 < 200)\n            @lru_cache(maxsize=None)\n            def dfs(i, s, p, exc, nonzero):\n                if i == n:\n                    return 1 if (nonzero and s != 0 and p % s == 0) else 0\n                res = 0\n                rlim = num[i]+1 if exc else 10\n                for rv in range(rlim):\n                    next_exc = exc and (rv == rlim-1)\n                    if not nonzero:\n                        res += dfs(i+1, rv, rv or 1, next_exc, rv != 0)\n                    else:\n                        res += dfs(i+1, s + rv, p * rv, next_exc, nonzero)\n                return res\n            return dfs(0, 0, 1, True, False)\n        return helper(r) - helper(l-1)\n                \n                \n        \n        \n        ","author":"Siddh","submissionId":"1575155192"},[]]},{"72":[{"id":"72","fileName":"1575150854.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, roh: int, vir: int) -> int:\n        cur = 2\n        temp = 4\n        varr = 5\n        abd = (roh, vir)\n        cur += 22\n        temp = 41\n        varr += 5\n        def solve(pat: int) -> int:\n            cur = 2\n            temp = 4\n            varr = 5\n            cur += 22\n            temp = 41\n            varr += 5\n            if pat <= 0:\n                return 0\n            cur += 22\n            temp = 41\n            varr += 5\n            jas = list(map(int, str(pat)))\n            cur += 22\n            temp = 41\n            varr += 5\n            from functools import lru_cache\n            @lru_cache(maxsize=None)\n            def dp(ram: int, vik: bool, sac: bool, koh: bool, pat: int, abd_val: int) -> int:\n                cur = 2\n                temp = 4\n                varr = 5\n                if ram == len(jas):\n                    if not sac:\n                        return 0\n                    if koh:\n                        return 1\n                    return 1 if (abd_val % pat == 0) else 0\n                jad = jas[ram] if vik else 9\n                cur += 22\n                temp = 41\n                varr += 5\n                mir = 0\n                cur += 22\n                temp = 41\n                varr += 3\n                for sam in range(jad + 1):\n                    cur += 22\n                    temp = 41\n                    varr += 5\n                    sur = vik and (sam == jad)\n                    cur += 22\n                    temp = 41\n                    varr += 5\n                    if not sac:\n                        if sam == 0:\n                            cur += 22\n                            temp = 41\n                            varr += 5\n                            mir += dp(ram + 1, sur, False, False, 0, 1)\n                            cur += 22\n                            temp = 41\n                            varr += 5\n                        else:\n                            cur += 22\n                            temp = 31\n                            varr += 5\n                            mir += dp(ram + 1, sur, True, False, sam, sam)\n                            cur += 22\n                            temp = 41\n                            varr += 5\n                    else:\n                        if not koh:\n                            cur += 22\n                            temp = 41\n                            varr += 5\n                            if sam == 0:\n                                cur += 22\n                                temp = 41\n                                varr += 5\n                                mir += dp(ram + 1, sur, True, True, 0, 0)\n                                cur += 22\n                                temp = 43\n                                varr += 5\n                            else:\n                                cur += 22\n                                temp = 41\n                                varr += 5\n                                mir += dp(ram + 1, sur, True, False, pat + sam, abd_val * sam)\n                                cur += 21\n                                temp = 41\n                                varr += 5\n                        else:\n                            mir += dp(ram + 1, sur, True, True, 0, 0)\n                return mir\n            return dp(0, True, False, False, 0, 1)\n        return solve(abd[1]) - solve(abd[0] - 1)\n","author":"dom7070","submissionId":"1575150854"},[]]},{"73":[{"id":"73","fileName":"1575155331.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def f(n):\n            if n <= 0:\n                return 0\n            s = str(n)\n            D = len(s)\n\n            @functools.lru_cache(maxsize=None)\n            def g(i, d_sum, d_prod, lesser, nz_seen):\n                if i == D:\n                    if d_sum == 0:\n                        return 0\n                    return d_prod % d_sum == 0\n\n                ret = 0\n                digit = int(s[i])\n                for d in range(10):\n                    if lesser or d <= digit:\n                        d_prod2 = 1 if (d == 0 and not nz_seen) else d_prod * d\n                        ret += g(i + 1, d_sum + d, d_prod2, lesser or (d < digit), \n                                nz_seen or d > 0)\n                return ret\n\n            return g(0, 0, 1, False, False)\n            \n        return f(r) - f(l - 1)","author":"HardCoreSWE","submissionId":"1575155331"},[]]},{"74":[{"id":"74","fileName":"1575155435.txt","sourceCode":"class Solution {\npublic:\n    using ll = long long;\n    typedef tuple<int, int, int, int, int> Key;\n    struct KeyHash {\n        size_t operator()(const Key &key) const {\n            auto [pos, tight, lead, sum, prod] = key;\n            size_t res = 17;\n            res = res * 31 + hash<int>()(pos);\n            res = res * 31 + hash<int>()(tight);\n            res = res * 31 + hash<int>()(lead);\n            res = res * 31 + hash<int>()(sum);\n            res = res * 31 + hash<int>()(prod);\n            return res;\n        }\n    };\n    \n    int beautifulNumbers(int l, int r) {\n        auto countBeautiful = [&](int x) -> ll {\n            if(x < 1) return 0;\n            string s = to_string(x);\n            vector<int> digits;\n            for (char c : s) digits.push_back(c - '0');\n            int n = digits.size();\n            unordered_map<Key, ll, KeyHash> memo;\n            function<ll(int,int,int,int,int)> dp = [&](int pos, int tight, int lead, int sum, int prod) -> ll {\n                if(pos == n) {\n                    if(lead) return 0LL;\n                    if(sum == 0) return 0LL;\n                    return (prod % sum == 0 ? 1LL : 0LL);\n                }\n                Key key = {pos, tight, lead, sum, prod};\n                if(memo.count(key)) return memo[key];\n                ll res = 0;\n                int limit = tight ? digits[pos] : 9;\n                for (int d = 0; d <= limit; d++) {\n                    int ntight = (tight && (d == limit)) ? 1 : 0;\n                    int nlead = (lead && d == 0) ? 1 : 0;\n                    int nsum = sum, nprod = prod;\n                    if(nlead) {\n                    } else {\n                        if(lead) { \n                            nsum = d;\n                            nprod = d;\n                        } else {\n                            nsum = sum + d;\n                            nprod = prod * d;\n                        }\n                    }\n                    res += dp(pos + 1, ntight, nlead, nsum, nprod);\n                }\n                memo[key] = res;\n                return res;\n            };\n            return dp(0, 1, 1, 0, 1);\n        };\n        \n        ll ans = countBeautiful(r) - countBeautiful(l - 1);\n        return (int)ans;\n    }\n};\n","author":"Jacob Ma","submissionId":"1575155435"},[]]},{"75":[{"id":"75","fileName":"1575156328.txt","sourceCode":"\nclass Solution {\n    public int beautifulNumbers(int l, int r) {\n        return (int)(f(r) - f(l - 1));\n    }\n    private long f(int x) {\n        if(x < 1) return 0;\n        char[] s = Integer.toString(x).toCharArray();\n        return dfs(0, 1, 0, 0, 1, s, new HashMap<>());\n    }\n    private long dfs(int pos, int tight, int started, int sum, int prod, char[] s, Map<String, Long> dp) {\n        if(pos == s.length) return started == 1 && sum != 0 && prod % sum == 0 ? 1 : 0;\n        String key = pos + \"_\" + tight + \"_\" + started + \"_\" + sum + \"_\" + prod;\n        if(dp.containsKey(key)) return dp.get(key);\n        int limit = tight == 1 ? s[pos] - '0' : 9;\n        long ans = 0;\n        for (int d = 0; d <= limit; d++) {\n            int nt = (tight == 1 && d == limit) ? 1 : 0;\n            if (started == 0 && d == 0) ans += dfs(pos + 1, nt, 0, 0, 1, s, dp);\n            else {\n                int ns = sum + d;\n                int np = started == 0 ? d : (prod == 0 ? 0 : prod * d);\n                ans += dfs(pos + 1, nt, 1, ns, np, s, dp);\n            }\n        }\n        dp.put(key, ans);\n        return ans;\n    }\n}","author":"Vivek","submissionId":"1575156328"},[]]},{"76":[{"id":"76","fileName":"1575159969.txt","sourceCode":"\nusing namespace std;\n\ntypedef long long ll;\n\nint fac[10][4] = {\n    {0,0,0,0},\n    {0,0,0,0},\n    {1,0,0,0},\n    {0,1,0,0},\n    {2,0,0,0},\n    {0,0,1,0},\n    {1,1,0,0},\n    {0,0,0,1},\n    {3,0,0,0},\n    {0,2,0,0}\n};\n\nint modPow(int base, int exp, int mod) {\n    int res = 1 % mod;\n    while(exp) {\n        if(exp & 1) res = (int)((ll)res * base % mod);\n        base = (int)((ll)base * base % mod);\n        exp >>= 1;\n    }\n    return res;\n}\n\nll dpCountNonzero(int pos, int tight, int started, const string &s, vector<vector<vector<ll>>> &dp) {\n    if(pos == s.size()) return started ? 1LL : 0LL;\n    if(dp[pos][tight][started] != -1) return dp[pos][tight][started];\n    ll ans = 0;\n    int lim = tight ? s[pos] - '0' : 9;\n    for (int d = 0; d <= lim; d++) {\n        int nt = (tight && d == lim);\n        if(!started) {\n            if(d == 0) ans += dpCountNonzero(pos + 1, nt, 0, s, dp);\n            else ans += dpCountNonzero(pos + 1, nt, 1, s, dp);\n        } else {\n            if(d == 0) continue;\n            ans += dpCountNonzero(pos + 1, nt, 1, s, dp);\n        }\n    }\n    return dp[pos][tight][started] = ans;\n}\n\nint encodeState(int pos, int tight, int started, int sum, int p2, int p3, int p5, int p7) {\n    int key = pos;\n    key |= tight << 4;\n    key |= started << 5;\n    key |= sum << 6;\n    key |= p2 << 13;\n    key |= p3 << 18;\n    key |= p5 << 23;\n    key |= p7 << 27;\n    return key;\n}\n\nll dpBeautiful(int pos, int tight, int started, int sum, int p2, int p3, int p5, int p7, const string &s, unordered_map<int, ll> &dp) {\n    if(pos == s.size()) {\n        if(!started) return 0;\n        int mod = sum;\n        int val = modPow(2, p2, mod);\n        val = (int)((ll)val * modPow(3, p3, mod) % mod);\n        val = (int)((ll)val * modPow(5, p5, mod) % mod);\n        val = (int)((ll)val * modPow(7, p7, mod) % mod);\n        return (val % mod == 0) ? 1LL : 0LL;\n    }\n    int key = encodeState(pos, tight, started, sum, p2, p3, p5, p7);\n    if(dp.count(key)) return dp[key];\n    ll ans = 0;\n    int lim = tight ? s[pos] - '0' : 9;\n    for (int d = 0; d <= lim; d++) {\n        int nt = (tight && d == lim);\n        if(!started) {\n            if(d == 0) ans += dpBeautiful(pos + 1, nt, 0, sum, p2, p3, p5, p7, s, dp);\n            else ans += dpBeautiful(pos + 1, nt, 1, sum + d, p2 + fac[d][0], p3 + fac[d][1], p5 + fac[d][2], p7 + fac[d][3], s, dp);\n        } else {\n            if(d == 0) continue;\n            ans += dpBeautiful(pos + 1, nt, 1, sum + d, p2 + fac[d][0], p3 + fac[d][1], p5 + fac[d][2], p7 + fac[d][3], s, dp);\n        }\n    }\n    return dp[key] = ans;\n}\n\nll calcNonzero(ll x) {\n    if(x < 1) return 0;\n    string s = to_string(x);\n    vector<vector<vector<ll>>> dp(s.size(), vector<vector<ll>>(2, vector<ll>(2, -1)));\n    return dpCountNonzero(0, 1, 0, s, dp);\n}\n\nll calcBeautiful(ll x) {\n    if(x < 1) return 0;\n    string s = to_string(x);\n    unordered_map<int, ll> dp;\n    return dpBeautiful(0, 1, 0, 0, 0, 0, 0, 0, s, dp);\n}\n\nclass Solution {\npublic:\n    int sol1(int l, int r) {\n        ll total = (ll)r - l + 1;\n        ll nonzero = calcNonzero(r) - calcNonzero(l - 1);\n        ll bea = calcBeautiful(r) - calcBeautiful(l - 1);\n        return (int)(total - nonzero + bea);\n    }\n    int beautifulNumbers(int l, int r) {\n        return sol1(l, r);\n    }\n};\n","author":"wjhbr","submissionId":"1575159969"},[]]},{"78":[{"id":"78","fileName":"1575160239.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n\n        lb = str(l)\n        rb = str(r)\n        \n        @cache\n        def dfs(i, high, leading, sum, product):\n            if i == len(rb):\n                return not leading and (product % sum == 0)\n\n\n            right = 9 if not high else int(rb[i])\n            ans = 0\n            for val in range(0, right+1):\n                if leading:\n                    if val == 0:\n                        ans += dfs(i+1, False, True, 0, 0)\n                    else:\n                        ans += dfs(i+1, high and val == right, False, val, val)\n                else:\n                    ans += dfs(i+1, high and val == right, False, sum + val, product * val)\n            return ans\n        \n\n        up = dfs(0, True, True, 0, 0)\n        rb = str(int(l-1))\n        dfs.cache_clear()\n        down = dfs(0, True, True, 0, 0)\n        #print(up, down)\n        return up - down\n            \n                ","author":"Kyle","submissionId":"1575160239"},[]]},{"79":[{"id":"79","fileName":"1575154940.txt","sourceCode":"class Solution {\n    class Status {\n        int position, strictness, totalSum, totalProduct;\n        boolean numberStarted, hasZero;\n        public Status(int position, int strictness, boolean numberStarted, int totalSum, int totalProduct, boolean hasZero) {\n            this.position = position;\n            this.strictness = strictness;\n            this.numberStarted = numberStarted;\n            this.totalSum = totalSum;\n            this.totalProduct = totalProduct;\n            this.hasZero = hasZero;\n        }\n        @Override\n        public int hashCode() {\n            int hash = position;\n            hash = hash * 31 + strictness;\n            hash = hash * 31 + (numberStarted ? 1 : 0);\n            hash = hash * 31 + totalSum;\n            hash = hash * 31 + totalProduct;\n            hash = hash * 31 + (hasZero ? 1 : 0);\n            return hash;\n        }\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (!(o instanceof Status)) return false;\n            Status other = (Status) o;\n            return position == other.position && strictness == other.strictness && numberStarted == other.numberStarted &&\n                   totalSum == other.totalSum && totalProduct == other.totalProduct && hasZero == other.hasZero;\n        }\n    }\n    \n    int[] digitsArray;\n    Map<Status, Integer> memoizationMap;\n    \n    public int countBeautifulUpTo(int upperLimit) {\n        if (upperLimit <= 0) return 0;\n        String numberString = Integer.toString(upperLimit);\n        int length = numberString.length();\n        digitsArray = new int[length];\n        for (int i = 0; i < length; i++) {\n            digitsArray[i] = numberString.charAt(i) - '0';\n        }\n        memoizationMap = new HashMap<>();\n        return dp(0, 1, false, 0, 1, false);\n    }\n    \n    private int dp(int position, int strictness, boolean numberStarted, int totalSum, int totalProduct, boolean hasZero) {\n        if (position == digitsArray.length) {\n            if (!numberStarted) return 0;\n            if (hasZero) return 1;\n            return (totalProduct % totalSum == 0) ? 1 : 0;\n        }\n        Status status = new Status(position, strictness, numberStarted, totalSum, totalProduct, hasZero);\n        if (memoizationMap.containsKey(status)) return memoizationMap.get(status);\n        int limit = (strictness == 1) ? digitsArray[position] : 9;\n        int answer = 0;\n        for (int digit = 0; digit <= limit; digit++) {\n            int newStrictness = (strictness == 1 && digit == limit) ? 1 : 0;\n            boolean newNumberStarted = numberStarted;\n            int newTotalSum = totalSum;\n            int newTotalProduct = totalProduct;\n            boolean newHasZero = hasZero;\n            if (!numberStarted) {\n                if (digit != 0) {\n                    newNumberStarted = true;\n                    newTotalSum = digit;\n                    newTotalProduct = digit;\n                    newHasZero = false; \n                } else {\n                    newNumberStarted = false;\n                    newTotalSum = 0;\n                    newTotalProduct = 1; \n                    newHasZero = false;\n                }\n            } else { \n                newTotalSum = totalSum + digit;\n                if (newHasZero || digit == 0) {\n                    newHasZero = true;\n                    newTotalProduct = 0;\n                } else {\n                    newTotalProduct = totalProduct * digit;\n                }\n            }\n            answer += dp(position + 1, newStrictness, newNumberStarted, newTotalSum, newTotalProduct, newHasZero);\n        }\n        memoizationMap.put(status, answer);\n        return answer;\n    }\n    \n    public int beautifulNumbers(int lowerLimit, int upperLimit) {\n        int storedLowerLimit = lowerLimit;  \n        return countBeautifulUpTo(upperLimit) - countBeautifulUpTo(lowerLimit - 1);\n    }\n}\n","author":"adwicorp","submissionId":"1575154940"},[]]},{"80":[{"id":"80","fileName":"1575160480.txt","sourceCode":"class Solution {\n    private java.util.Map<String, Long> memo;\n    \n    public int beautifulNumbers(int l, int r) {\n        long countR = countBeautiful(r);\n        long countL = countBeautiful(l - 1);\n        return (int)(countR - countL);\n    }\n    \n    private long countBeautiful(int n) {\n        if(n < 1) return 0;\n        String s = Integer.toString(n);\n        int[] digits = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            digits[i] = s.charAt(i) - '0';\n        }\n        memo = new java.util.HashMap<>();\n        return dp(0, 1, false, false, 0, 1, digits);\n    }\n    \n\n    private long dp(int pos, int tight, boolean started, boolean hasZero, int sum, long prod, int[] digits) {\n        if (pos == digits.length) {\n            if (!started) return 0; \n            if (hasZero) return 1; \n            return (prod % sum == 0) ? 1 : 0;\n        }\n        \n        String key = pos + \"_\" + tight + \"_\" + (started ? 1 : 0) + \"_\" + (hasZero ? 1 : 0) + \"_\" + sum + \"_\" + prod;\n        if (memo.containsKey(key)) {\n            return memo.get(key);\n        }\n        \n        long ans = 0;\n        int limit = (tight == 1) ? digits[pos] : 9;\n        for (int d = 0; d <= limit; d++) {\n            int newTight = (tight == 1 && d == limit) ? 1 : 0;\n            if (!started) {\n                if (d == 0) {\n                    ans += dp(pos + 1, newTight, false, false, 0, 1, digits);\n                } else {\n                    ans += dp(pos + 1, newTight, true, false, d, d, digits);\n                }\n            } else {\n                boolean newHasZero = hasZero || (d == 0);\n                int newSum = sum + d;\n                long newProd = prod * d;\n                ans += dp(pos + 1, newTight, true, newHasZero, newSum, newProd, digits);\n            }\n        }\n        \n        memo.put(key, ans);\n        return ans;\n    }\n}\n","author":"Sunny","submissionId":"1575160480"},[]]},{"81":[{"id":"81","fileName":"1575160110.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, left: int, right: int) -> int:\n        \"\"\"Count good numbers in range [left, right] using digit DP.\"\"\"\n    \n        def count_up_to(upper):\n            \"\"\"Count good numbers from 0 to upper.\"\"\"\n            digits = list(map(int, str(upper)))\n            n = len(digits)\n            \n            # memoization cache for states\n            @lru_cache(maxsize=None)\n            def dp(pos, tight, sum_digits, prod_digits, started):\n                \"\"\"\n                pos: current position in the number\n                tight: whether we are constrained by the upper bound\n                sum_digits: running sum of digits\n                prod_digits: running product of digits (use -1 for 0 to handle multiplication)\n                started: whether we've started placing non-zero digits\n                \"\"\"\n                # Base case: reached the end of the number\n                if pos == n:\n                    # A number is \"good\" if product is divisible by sum and we've started placing digits\n                    if not started:\n                        return 0  # Empty number is not valid\n                    if sum_digits == 0:\n                        return 0  # Can't divide by zero\n                    \n                    # Convert -1 product back to 0\n                    actual_prod = 0 if prod_digits == -1 else prod_digits\n                    return 1 if actual_prod % sum_digits == 0 else 0\n                \n                result = 0\n                # Determine the upper limit for current position\n                limit = digits[pos] if tight else 9\n                \n                # Try placing each possible digit\n                for d in range(limit + 1):\n                    # Calculate new state\n                    new_tight = tight and (d == digits[pos])\n                    new_started = started or (d > 0)\n                    \n                    # Skip if we haven't started and we're at the last position\n                    if not new_started and pos == n - 1:\n                        continue\n                        \n                    # Calculate new sum and product\n                    new_sum = sum_digits + d if new_started else sum_digits\n                    \n                    # Handle product calculation with special case for 0\n                    new_prod = prod_digits\n                    if d == 0 and new_started:\n                        new_prod = -1  # Use -1 to represent product of 0\n                    elif new_started and prod_digits != -1:\n                        new_prod = prod_digits * d\n                    elif new_started:  # prod_digits is -1 (representing 0) and d != 0\n                        new_prod = 0  # Product remains 0\n                    \n                    # Recursive call\n                    result += dp(pos + 1, new_tight, new_sum, new_prod, new_started)\n                \n                return result\n            \n            # Start the DP calculation\n            result = dp(0, True, 0, 1, False)\n            return result\n        \n        # Count good numbers in range [left, right] using inclusion-exclusion principle\n        return count_up_to(right) - count_up_to(left - 1) if left > 0 else count_up_to(right)","author":"seanzhoujobs","submissionId":"1575160110"},[]]},{"82":[{"id":"82","fileName":"1575163494.txt","sourceCode":"class Solution {\n    String s;\n    Long[][][] dp;\n    HashMap<String, Long> memo;\n    \n    public int beautifulNumbers(int L, int R) {\n        return (int)(f(R) - f(L - 1));\n    }\n    \n    public long f(int n) {\n        if(n == 0) return 0;\n        return qwe(n) + n - asd(n);\n    }\n    \n    public long asd(int n) {\n        s = Integer.toString(n);\n        int len = s.length();\n        dp = new Long[len + 1][2][2];\n        return rec(0, 1, 0);\n    }\n    \n    public long rec(int p, int tt, int st) {\n        if (p == s.length()) return st == 1 ? 1 : 0;\n        if (dp[p][tt][st] != null) return dp[p][tt][st];\n        int mx = tt == 1 ? s.charAt(p) - '0' : 9;\n        long ans = 0;\n        for (int d = 0; d <= mx; d++) {\n            int nt = (tt == 1 && d == mx) ? 1 : 0;\n            if (st == 0 && d == 0) {\n                ans += rec(p + 1, nt, 0);\n            } else {\n                if (d == 0) continue;\n                ans += rec(p + 1, nt, 1);\n            }\n        }\n        return dp[p][tt][st] = ans;\n    }\n    \n    public long qwe(int n) {\n        s = Integer.toString(n);\n        memo = new HashMap<>();\n        return check(0, 1, 0, 0, 1);\n    }\n    \n    public long check(int p, int tt, int st, int sum, long prod) {\n        if (p == s.length()) {\n            return st == 1 && prod % sum == 0 ? 1 : 0;\n        }\n        String key = p + \"_\" + tt + \"_\" + st + \"_\" + sum + \"_\" + prod;\n        if (memo.containsKey(key)) return memo.get(key);\n        int mx = tt == 1 ? s.charAt(p) - '0' : 9;\n        long ret = 0;\n        for (int d = 0; d <= mx; d++) {\n            int nt = (tt == 1 && d == mx) ? 1 : 0;\n            if (st == 0 && d == 0) {\n                ret += check(p + 1, nt, 0, sum, prod);\n            } else {\n                if (d == 0) continue;\n                ret += check(p + 1, nt, 1, sum + d, prod * d);\n            }\n        }\n        memo.put(key, ret);\n        return ret;\n    }\n}\n","author":"chubbyseal","submissionId":"1575163494"},[]]},{"83":[{"id":"83","fileName":"1575164140.txt","sourceCode":"from functools import lru_cache\nfrom typing import List\n\nclass Solution:\n    def beautifulNumbers(self, low: int, high: int) -> int:\n        hehe = (low, high)\n        \n        def cnt(x: int) -> int:\n            if x < 10:\n                return x\n            s = str(x)\n            digs = []\n            i = 0\n            while i < len(s):\n                digs.append(int(s[i]))\n                i += 1\n            n = len(digs)\n            @lru_cache(maxsize=None)\n            def dp(pos, tight, started, summ, prod):\n                if pos == n:\n                    if not started:\n                        return 0\n                    return 1 if (summ != 0 and prod % summ == 0) else 0\n                lim = digs[pos] if tight else 9\n                total = 0\n                d = 0\n                while d <= lim:\n                    h = tight and (d == lim)\n                    if not started:\n                        if d == 0:\n                            total += dp(pos + 1, h, False, 0, 1)\n                        else:\n                            total += dp(pos + 1, h, True, d, d)\n                    else:\n                        total += dp(pos + 1, h, True, summ + d, prod * d)\n                    d += 1\n                return total\n            return dp(0, True, False, 0, 1)\n        \n        return cnt(high) - cnt(low - 1)","author":"Sujith Kumar K","submissionId":"1575164140"},[]]},{"84":[{"id":"84","fileName":"1575162243.txt","sourceCode":"#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define sz(s) (int)(s).size()\n#define all(s) s.begin(),s.end()\n\nvoid Speed() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n}\nconst int N = 20;\nint dp[N][82][82][2][2], pw[20];\nint vis[N][82][82][2][2], vid;\nstring s;\nint G;\n\nint rec(int i, int sum, int mod, bool eq, bool first){\n    if(sum < 0) return 0;\n    if(i == sz(s)) return sum == 0 && mod == 0;\n    int &ret = dp[i][sum][mod][eq][first];\n    if(vis[i][sum][mod][eq][first] == vid) return ret;\n    ret = 0;\n    vis[i][sum][mod][eq][first] = vid;\n    \n    int st = 0, ed = 9;\n    if(eq) ed = s[i] - '0';\n    for(int d = st; d <= ed; d++){\n        int new_mod = (mod * d) % G;\n        bool new_eq = eq;\n        if(d < ed) new_eq = 0;\n        if(first == 1 && d > 0) new_mod = d % G;\n        bool new_first = first;\n        if(d > 0) new_first = 0;\n        ret += rec(i + 1, sum - d, new_mod, new_eq, new_first);\n    }\n    return ret;\n}\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        l--;\n\n        auto calc = [&](int lim) -> int{\n            s = to_string(lim);\n            int ans = 0;\n            for(int sum = 1; sum < 82; sum++){\n                G = sum;\n                vid++;\n                ans += rec(0, sum, 0, 1, 1);\n            }\n            return ans;\n        };\n        return calc(r) - (l == 0 ? 0 : calc(l));\n    }\n};","author":"Anas Maged","submissionId":"1575162243"},[]]},{"85":[{"id":"85","fileName":"1575164240.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n\n        from functools import lru_cache\n\n        def count_noz(x):\n            digs = list(map(int, str(x)))\n            n = len(digs)\n\n            @lru_cache(maxsize=None)\n            def dp(i, j, k):\n                if i == n:\n                    return 1 if j else 0\n                ans = 0\n                lim = digs[i] if k else 9\n                for d in range(lim + 1):\n                    if j and d == 0:\n                        continue\n                    ans += dp(i + 1, j or (d > 0), k and (d == lim))\n                return ans\n\n            return dp(0, False, True)\n\n        def beauty_count(x):\n            digs = list(map(int, str(x)))\n            n = len(digs)\n\n            @lru_cache(maxsize=None)\n            def dp(i, j, k, x, y):\n                if i == n:\n                    return 1 if j and x > 0 and y % x == 0 else 0\n                ans = 0\n                lim = digs[i] if k else 9\n                for d in range(lim + 1):\n                    if j:\n                        if d == 0:\n                            continue\n                    cond = k and (d == lim)\n                    if j:\n                        ans += dp(i + 1, True, cond, x + d, y * d)\n                    else:\n                        if d == 0:\n                            ans += dp(i + 1, False, cond, x, y)\n                        else:\n                            ans += dp(i + 1, True, cond, d, d)\n                return ans\n\n            return dp(0, False, True, 0, 1)\n\n        _ran = r - l + 1\n        diff = count_noz(r) - count_noz(l - 1)\n        # print(diff)\n        a = _ran - diff\n        b = beauty_count(r) - beauty_count(l - 1)\n        # print(a, b)\n        \n        return a + b","author":"parallel_stream","submissionId":"1575164240"},[]]},{"86":[{"id":"86","fileName":"1575159759.txt","sourceCode":"class Solution {\n    fun beautifulNumbers(l: Int, r: Int): Int {\n        var total = 0\n        for (s in 1..90) {\n            val countR = calculate(s, r)\n            val countLMinus1 = calculate(s, l - 1)\n            total += countR - countLMinus1\n        }\n        return total\n    }\n\n    private fun calculate(s: Int, upper: Int): Int {\n        if (upper < 0) return 0\n        val digits = upper.toString().toCharArray().map { it - '0' }\n        val n = digits.size\n        data class State(val pos: Int, val sum: Int, val prodMod: Int, val isTight: Boolean, val isZero: Boolean)\n\n        val memo = mutableMapOf<State, Int>()\n\n        fun dp(pos: Int, sum: Int, prodMod: Int, isTight: Boolean, isZero: Boolean): Int {\n            if (pos == n) {\n                return if (sum == s && prodMod == 0) 1 else 0\n            }\n            val state = State(pos, sum, prodMod, isTight, isZero)\n            memo[state]?.let { return it }\n\n            var res = 0\n            val maxDigit = if (isTight) digits[pos] else 9\n\n            for (d in 0..maxDigit) {\n                val newIsTight = isTight && (d == maxDigit)\n                val newIsZero = isZero && (d == 0)\n\n                var newSum: Int\n                var newProdMod: Int\n\n                if (isZero) {\n                    if (d == 0) {\n                        newSum = sum\n                        newProdMod = prodMod\n                    } else {\n                        newSum = d\n                        newProdMod = d % s\n                        if (newProdMod < 0) newProdMod += s\n                    }\n                } else {\n                    newSum = sum + d\n                    if (newSum > s) continue\n                    newProdMod = (prodMod * d) % s\n                    if (newProdMod < 0) newProdMod += s\n                }\n\n                res += dp(pos + 1, newSum, newProdMod, newIsTight, newIsZero)\n            }\n\n            memo[state] = res\n            return res\n        }\n\n        return dp(0, 0, 1, true, true)\n    }\n}","author":"jayle99","submissionId":"1575159759"},[]]},{"88":[{"id":"88","fileName":"1575166498.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_up_to(n):\n        \n            if n == 0:\n                return 0 \n    \n            digits = list(map(int, str(n)))\n            length = len(digits)\n    \n            @lru_cache(None)\n            def dp(pos, tight, digit_sum, digit_product, non_zero):\n             \n                if pos == length:\n                    return 1 if non_zero and digit_sum > 0 and digit_product % digit_sum == 0 else 0\n    \n                limit = digits[pos] if tight else 9\n                total = 0\n    \n                for d in range(0, limit + 1):\n                    new_tight = tight and (d == limit)\n                    new_sum = digit_sum + d\n                    new_product = digit_product * d if non_zero else d \n                    new_non_zero = non_zero or (d > 0)\n    \n                    if new_non_zero and new_sum == 0:  \n                        continue\n    \n                    total += dp(pos + 1, new_tight, new_sum, new_product, new_non_zero)\n    \n                return total\n    \n            return dp(0, True, 0, 1, False)\n    \n      \n        return count_up_to(r) - count_up_to(l - 1)\n\n\n\n        ","author":"Sharan","submissionId":"1575166498"},[]]},{"90":[{"id":"90","fileName":"1575167746.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        \n\n        r = str(r)\n        mem = {}\n        ans = self.dfs(0,r, True, 1, 0, mem, False) \n        \n        l = str(l-1)\n        mem = {}\n        ans -= self.dfs(0, l, True, 1, 0, mem, False)\n\n        return ans\n    def dfs(self, i, r, havetobeless, p,s, mem,first):\n\n        if i == len(r):\n            \n            return 1 if (s>0) and (p % s == 0) else 0\n\n        if (i,havetobeless,p,s,first) in mem:\n            return mem[(i,havetobeless,p,s,first)]\n        ans = 0\n        if not(havetobeless):\n            for e in range(0, 10):\n\n                if e:\n                    np = p*e\n                else:\n                    if first:\n                        np = p*e\n                    else:\n                        np = p\n                ans += self.dfs(i+1, r, False, np, s+e,mem, first | (e>0))\n        else:\n            for e in range(0,10):\n                \n                if e:\n                    np = p*e\n                else:\n                    if first:\n                        np = p*e\n                    else:\n                        np = p\n                        \n                if e < int(r[i]):\n                    ans += self.dfs(i+1, r, False, np, s+e,mem,first | (e>0))\n                elif e == int(r[i]):\n                    ans += self.dfs(i+1, r, True, np, s+e,mem,first | (e>0))\n                else:\n                    break\n        \n        mem[(i,havetobeless,p,s,first)] = ans\n        return ans","author":"lebron87","submissionId":"1575167746"},[]]},{"91":[{"id":"91","fileName":"1575162335.txt","sourceCode":"#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef priority_queue<int> pq;\ntypedef priority_queue<int, vector<int>, greater<int>> pqg;\n#define fastio ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define sz(x) (int)(x).size()\n#define rep(i, a, b) for(int i = a; i < b; ++i)\n#define repr(i, a, b) for(int i = a; i >= b; --i)\n#define deb(x) cout << #x << \" = \" << x << endl;\n#define INF 1e9\n#define LINF 1e18\nclass Solution {\n    string s;\n    map<string,int> dp;\n    string getKey(int pos, int sum, long long prod, bool st, bool tight) {\n        return to_string(pos) + \",\" + to_string(sum) + \",\" + to_string(prod) + \",\" + (st ? \"1\" : \"0\") + \",\" + (tight ? \"1\" : \"0\");\n    }\n    int f(int pos, int sum, long long prod, bool st, bool tight) {\n        if(pos == s.size()) return (st && sum > 0 && prod % sum == 0) ? 1 : 0;\n        string key = getKey(pos, sum, prod, st, tight);\n        if(dp.count(key)) return dp[key];\n        int ub = tight ? s[pos]-'0' : 9, res = 0;\n        for(int d = 0; d <= ub; d++){\n            bool nst = st;\n            int ns = sum;\n            long long np = prod;\n            if(!st && d){ \n                nst = true; \n                ns = d; \n                np = d;\n            } else if(st){ \n                ns += d; \n                np = np * d; \n            }\n            res += f(pos+1, ns, np, nst, tight && (d==ub));\n        }\n        return dp[key] = res;\n    }\npublic:\n    int beautifulNumbers(int l, int r) {\n        dp.clear();\n        s = to_string(r);\n        int hi = f(0, 0, 1, false, true);\n        dp.clear();\n        s = to_string(l-1);\n        int lo = f(0, 0, 1, false, true);\n        return hi - lo;\n    }\n};\n","author":"miku","submissionId":"1575162335"},[]]},{"92":[{"id":"92","fileName":"1575168102.txt","sourceCode":"#define ll long long\nclass Solution {\npublic:\n    unordered_map<ll, ll> mp;\n\n    ll encode(int idx, int tight, int start, int sum, ll prod) {\n        ll key = idx;\n        key = (key << 1) | tight;\n        key = (key << 1) | start;\n        key = (key << 7) | sum;\n        key = (key << 32) | (prod & 0xffffffffLL);\n        return key;\n    }\n\n    int beautifulNumbers(int L, int R) {\n        string sR = to_string(R);\n        mp.clear();\n        function<ll(int, int, int, int, ll, string&)> dp = \n        [&](int idx, int tight, int started, int sum, ll prod, string &s) -> ll {\n            if (idx == s.size())\n                return (started && sum > 0 && (prod % sum == 0)) ? 1LL : 0LL;\n            ll key = encode(idx, tight, started, sum, prod);\n            if (mp.count(key))\n                return mp[key];\n            ll ans = 0;\n            int ub = tight ? s[idx] - '0' : 9;\n            for (int dig = 0; dig <= ub; dig++) {\n                int ntight = (tight && (dig == ub)) ? 1 : 0;\n                int nstarted = started;\n                int nsum = sum;\n                ll nprod = prod;\n                if (!started) {\n                    if (dig != 0) {\n                        nstarted = 1;\n                        nsum = dig;\n                        nprod = dig;\n                    }\n                } else {\n                    nsum += dig;\n                    nprod *= dig;\n                }\n                ans += dp(idx + 1, ntight, nstarted, nsum, nprod, s);\n            }\n            mp[key] = ans;\n            return ans;\n        };\n\n        ll countR = dp(0, 1, 0, 0, 1, sR);\n        ll countL = 0;\n        if (L > 1) {\n            string sL = to_string(L - 1);\n            mp.clear();\n            countL = dp(0, 1, 0, 0, 1, sL);\n        }\n        return (int)(countR - countL);\n    }\n};\n","author":"uJMQbJwlnP","submissionId":"1575168102"},[]]},{"93":[{"id":"93","fileName":"1575169590.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        @cache\n        def count(n):\n            digits = list(map(int, str(n)))\n            l = len(digits)\n            @cache\n            def dp(index, tight, sd, prod, flag):\n                if index == l:\n                    return int(flag and sd != 0 and prod % sd == 0)\n\n                limit = digits[index] if tight else 9\n                total = 0\n\n                for d in range(0, limit + 1):\n                    newTight = tight and (d == limit)\n                    newSd = sd + d\n                    newProd = prod * d if flag else d\n                    newFlag = flag or (d != 0)\n                    total += dp(index + 1, newTight, newSd, newProd, newFlag)\n                return total\n\n            return dp(0, True, 0, 1, False)\n\n        return count(r) - count(l - 1)","author":"Gaurav Chaurasia","submissionId":"1575169590"},[]]},{"94":[{"id":"94","fileName":"1575167755.txt","sourceCode":"class Solution {\n    public static int MinimumPathSum(int[][] mat) {\n            \n        int n = mat.length;\n        int m = mat[0].length;\n        int[][] dp = new int[n][m];\n\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = m - 1; j >= 0; j--) {\n                if (i == n - 1 && j == m - 1) {\n                    dp[i][j] = mat[i][j];\n                } else if (i == n - 1) {\n                    dp[i][j] = mat[i][j] + dp[i][j + 1];\n                } else if (j == m - 1) {\n                    dp[i][j] = mat[i][j] + dp[i + 1][j];\n                } else {\n                    dp[i][j] = mat[i][j] + Math.min(dp[i + 1][j], dp[i][j + 1]);\n                }\n            }\n        }\n        return dp[0][0];\n    }\n    \n    static Map<String, Long> memo;\n    static String pathString = \"1234567890\";\n    \n    public int beautifulNumbers(int l, int r) {\n        \n        int ans = (int) (countBeautiful(r) - countBeautiful(l - 1));\n        print(ans);\n        return ans;\n        \n    }\n    public static int min(int a, int b) {\n        if (a < b) {\n            return a;\n        }\n        return b;\n    }\n    public static int max(int a, int b) {\n        if (a > b) {\n            return a;\n        }\n        return b;\n    }\n    public static <E> void print(E res) {\n        System.out.println(res);\n    }\n    public static <E> void printArr(int[] arr) {\n        System.out.println(Arrays.toString(arr));\n    }\n\n    public static int houseRobber4(int[] nums, int index, int count, int k, int currentCap, int[][][] dp) {\n\n        if (count >= k) {\n            return currentCap;\n        }\n\n        if (index >= nums.length) {\n            return Integer.MAX_VALUE;\n        }\n\n        if (dp[index][count][currentCap] != -1) {\n            return dp[index][count][currentCap];\n        }\n\n        int skip = houseRobber4(nums, index + 1, count, k, currentCap, dp);\n\n        int newCap = Math.max(currentCap, nums[index]);\n        int pick = houseRobber4(nums, index + 2, count + 1, k, newCap, dp);\n\n        return dp[index][count][currentCap] = Math.min(skip, pick);\n    }\n\n    public static boolean coinChangeCF(int[] coins, int index, int target, int[][] dp) {\n\n        if (target == 0) {\n            return true;\n        }\n\n        if (index == coins.length) {\n            return false;\n        }\n\n        if (dp[index][target] != -1) {\n            return dp[index][target] == 1;\n        }\n\n        boolean Pick = false;\n\n        if (target >= coins[index]) {\n            Pick = coinChangeCF(coins, index, target - coins[index], dp);\n        }\n        boolean notPick = coinChangeCF(coins, index + 1, target, dp);\n\n        boolean res = Pick || notPick;\n        dp[index][target] = res ? 1 : 0;\n        return res;\n    }\n    public static boolean isBeautiful(int n) {\n        int temp = 0;\n        int pro = 1, sum = 0;\n        while (n > 0) {\n            int rem = n % 10;\n            pro *= rem;\n            sum += rem;\n        }\n        return pro % sum == 0;\n    }\n\n    public static long countBeautiful(long n) {\n\n        if (n < 1) {\n            return 0;\n        }\n        String s = Long.toString(n);\n        int ix = 0;\n        int[] ar = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            ar[i] = s.charAt(i) - '0';\n            ix ++;\n        }\n        memo = new HashMap<>();\n        return solveThis(0, 1, 0, 0, 1, ar);\n    }\n\n    public static long solveThis(int pos, int tight, int s, int sum, long pro, int[] digit_arr) {\n\n\n        long carry = tight & s;\n        if (pos == digit_arr.length) {\n            if (s == 0) return 0;\n            return (sum != 0 && pro % sum == 0) ? 1 : 0;\n        }\n\n        String key = pos + \"|\" + tight + \"|\" + s + \"|\" + sum + \"|\" + pro;\n        if (memo.containsKey(key)) {\n            return memo.get(key);\n        }\n        long res = 0;\n        print(carry);\n        carry = (carry - 1) & 1;\n        int ji = (tight == 1 ? digit_arr[pos] : 9);\n        for (int d = 0; d <= ji; d++) {\n            int y1 = (tight == 1 && d == ji) ? 1 : 0;\n            int x1 = s;\n            int newSum = sum;\n            long newPro = pro;\n            if (s == 0 && d == 0) {\n                x1 = 0;\n                newSum = 0;\n                newPro = 1;\n            } else if (s == 0) {\n                x1 = 1;\n                newSum = d;\n                newPro = d;\n            } else {\n                newSum = sum + d;\n                newPro = pro * d;\n            }\n            \n            if (newPro % 3 == 2) {\n                carry ++;\n            }\n            res += solveThis(pos + 1, y1, x1, newSum, newPro, digit_arr);\n        }\n        memo.put(key, res);\n        return res;\n    }\n\n    public static int abs(int a) {\n        return a < 0 ? -a : a;\n    }\n    public static int coinChangeLC(int[] coins, int index, int target, int[][] dp) {\n\n        if (index == coins.length - 1) return target % coins[index] == 0 ? target / coins[index] : (int) 1e9;\n\n        if (dp[index][target] != -1) {\n            return dp[index][target];\n        }\n\n        int Pick = (int) 1e9;\n\n        if (target >= coins[index]) {\n            Pick = 1 + coinChangeLC(coins, index, target - coins[index], dp);\n        }\n        int notPick = 0 + coinChangeLC(coins, index + 1, target, dp);\n\n        return dp[index][target] = Math.min(Pick, notPick);\n    }\n    public static int coinChangeGFG(int[] coins, int index, int target, int[][] dp) {\n\n        if (index == coins.length - 1) return target % coins[index] == 0 ? 1 : 0;\n\n        if (dp[index][target] != -1) {\n            return dp[index][target];\n        }\n\n        int Pick = 0;\n\n        if (target >= coins[index]) {\n            Pick = 1 + coinChangeGFG(coins, index, target - coins[index], dp);\n        }\n        int notPick = 0 + coinChangeGFG(coins, index + 1, target, dp);\n\n        return dp[index][target] = Pick + notPick;\n    }\n    public static int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n    public static int lcm(int a, int b) {\n        return (a * b) / gcd(a, b);\n    }\n    \n    public static int frogJump(int[] arr) {\n            \n        int n = arr.length;\n        int[] dp = new int[n];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j <= i + 2 && j < n; j++) {\n                dp[j] = Math.min(dp[j], dp[i] + Math.abs(arr[i] - arr[j]));\n            }\n        }\n        return dp[n - 1];\n    }\n    \n    public static int minJumps(int[] nums, int index) {\n\n        if (index >= nums.length - 1) {\n            return 0;\n        }\n\n        int minJumps = 99999;\n\n        for (int i = 1; i <= nums[index]; i++) {\n            minJumps = min(minJumps, 1 + minJumps(nums, index + i));\n        }\n        return minJumps;\n    }\n\n    public static int knapSack(int w, int[] values, int[] weights, int index, int[] dp) {\n\n        if (index >= values.length) {\n            return 0;\n        }\n\n        if (w <= 0) {\n            return 0;\n        }\n\n        if (dp[index] != -1) {\n            return dp[index];\n        }\n\n        int Pick = 0;\n        if (w >= weights[index]) {\n            Pick = values[index] + knapSack(w - weights[index], values, weights, index + 1, dp);\n        }\n        int notPick = 0 + knapSack(w, values, weights, index + 1, dp);\n\n        return dp[index] = max(Pick, notPick);\n    }\n\n\n    public static boolean isPowerof2(int n) {\n        return (n & (n - 1)) == 0;\n    }\n    public static boolean containsAllOnes(int n) {\n        return (n & (n + 1)) == 0;\n    }\n\n    public static boolean isPowerof3(int n, int index) {\n\n        if (n == 0) {\n            return true;\n        }\n\n        if (n < 0 || Math.pow(3, index) > n) {\n            return false;\n        }\n\n        boolean Pick = isPowerof3(n - (int) Math.pow(3, index), index + 1);\n        boolean notPick = isPowerof3(n, index + 1);\n\n        return Pick || notPick;\n    }\n\n    public static String longestPalindrome(String s) {\n\n        int n = s.length();\n        Boolean[][] memo = new Boolean[n][n];\n        int maxLen = 0;\n        int start = 0;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                if (isPalindrome(s, i, j, memo)) {\n                    if (j - i + 1 > maxLen) {\n                        maxLen = j - i + 1;\n                        start = i;\n                    }\n                }\n            }\n        }\n        return s.substring(start, start + maxLen);\n    }\n\n    private static boolean isPalindrome(String s, int i, int j, Boolean[][] memo) {\n\n        if (i >= j) return true;\n\n        if (memo[i][j] != null) return memo[i][j];\n\n        if (s.charAt(i) == s.charAt(j)) {\n            memo[i][j] = isPalindrome(s, i + 1, j - 1, memo);\n        } else {\n            memo[i][j] = false;\n        }\n\n        return memo[i][j];\n    }\n\n    public static int MinCostClimbingStairs(int[] cost, int index, int[] dp) {\n\n        if (index >= cost.length) {\n            return 0;\n        }\n\n        if (dp[index] != 0) {\n            return dp[index];\n        }\n\n        int one = cost[index] + MinCostClimbingStairs(cost, index + 1, dp);\n        int two = cost[index] + MinCostClimbingStairs(cost, index + 2, dp);\n\n        return dp[index] = Math.min(one, two);\n    }\n    public static int climbingStairs(int n, int[] dp) {\n\n        if (n < 3) {\n            return n;\n        }\n\n        if (dp[n] != -1) {\n            return dp[n];\n        }\n\n        int one = climbingStairs(n - 1, dp);\n        int two = climbingStairs(n - 2, dp);\n\n        return dp[n] = one + two;\n    }\n    public static boolean isPalindrome(String s, int i, int j) {\n\n        if (i >= j) {\n            return true;\n        }\n\n        if (s.charAt(i) != s.charAt(j)) {\n            return false;\n        }\n\n        return isPalindrome(s, i + 1, j - 1);\n    }\n\n    public static boolean isPrime (int n) {\n\n        if (n == 1) {\n            return false;\n        }\n\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    public static boolean canEat(int[] piles, int h, int k) {\n\n        int hours = 0;\n\n        for (int pile : piles) {\n            int div = pile / k;\n            hours += div;\n            if (pile % k != 0) {\n                hours ++;\n            }\n        }\n        return hours <= h;\n    }\n\n    public static int abcAsSubString(String s) {\n\n        int[] count = new int[3];\n        int ans = 0;\n        int left = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            count[s.charAt(i) - 'a'] ++;\n            while (count[0] > 0 && count[1] > 0 && count[2] > 0) {\n                ans += s.length() - i;\n                count[s.charAt(left) - 'a'] --;\n                left ++;\n            }\n        }\n        return ans;\n    }\n\n    public static boolean abcfinder(String s) {\n        return s.contains(\"a\") && s.contains(\"b\") && s.contains(\"c\");\n    }\n    public static int longestPalindromicSubseq(String s, int i, int j, int[][] dp) {\n\n        if (i > j) {\n            return 0;\n        }\n\n        if (i == j) {\n            return 1;\n        }\n\n        if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n        if (s.charAt(i) == s.charAt(j)) {\n            return 2 + longestPalindromicSubseq(s, i + 1, j - 1, dp);\n        }\n\n        int a = longestPalindromicSubseq(s, i + 1, j, dp);\n        int b = longestPalindromicSubseq(s, i, j - 1, dp);\n\n        return dp[i][j] = Math.max(a, b);\n    }\n    public static void permutations1(int[] nums, int index, List<Integer> running, List<List<Integer>> ans) {\n\n        // base case\n        if (index >= nums.length) {\n            ans.add(new ArrayList<>(running));\n            return; \n        }\n\n        for (int i = 0; i < nums.length; i++) {\n            if (running.contains(nums[i])) continue;\n            running.add(nums[i]);\n            permutations1(nums, index + 1, running, ans);\n            running.remove(running.size() - 1);\n        }\n    }\n\n    public static int lcs(String s1, String s2, int i, int j, int[][] dp)  {\n\n        if (i == s1.length() || j == s2.length()) {\n            return 0;\n        }\n\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n\n        if (s1.charAt(i) == s2.charAt(j)) {\n            return 1 + lcs(s1, s2, i + 1, j + 1, dp);\n        }\n\n        int op1 = lcs(s1, s2, i + 1, j, dp);\n        int op2 = lcs(s1, s2, i, j + 1, dp);\n\n        return dp[i][j] = Math.max(op1, op2);\n    }\n\n    public static int[] dailyTemperatures(int[] temperatures) {\n\n\n        int n = temperatures.length;\n        int[] ans = new int[temperatures.length];\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && temperatures[stack.peek()] <= temperatures[i]) {\n                stack.pop();\n            }\n            if (stack.isEmpty()) {\n                ans[i] = 0;\n            } else {\n                ans[i] = stack.peek() - i;\n            }\n            stack.add(i);\n        }\n        return ans;\n    }\n    public static int[] NGE2(int[] nums) {\n\n        int n = nums.length;\n        int[] ans = new int[n];\n        int index = n - 1;\n\n        Stack<Integer> stack = new Stack<>();\n        for (int i = (2 * n) - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && stack.peek() <= nums[i % n]) {\n                stack.pop();\n            }\n            if (i < n) {\n                if (stack.isEmpty()) {\n                    ans[index--] = -1;\n                } else {\n                    ans[index--] = stack.peek();\n                }\n            }\n\n            stack.add(nums[i % n]);\n        }\n        return ans;\n    }\n    public static int[] NGE1 (int[] arr) {\n\n        int n = arr.length;\n        int index = n - 1;\n        int[] ans = new int[n];\n\n        Stack<Integer> stack = new Stack<>(); // []\n\n\n        for (int i = n - 1; i >= 0; i--) {\n\n            while (!stack.isEmpty() && stack.peek() <= arr[i]) {\n                stack.pop();\n            }\n            if (stack.isEmpty()) {\n                ans[index] = -1;\n            } else {\n                ans[index] = stack.peek();\n            }\n            stack.add(arr[i]);\n            index --;\n        }\n        return ans;\n    }\n    public static int maxAreaWater(int[] heights) {\n\n        int s = 0;\n        int e = heights.length - 1;\n\n        int nasDaily = 0;\n\n        while (s < e) {\n            int ans = Math.min(heights[s], heights[e]);\n            int idx = e - s;\n            nasDaily = Math.max(nasDaily, ans * idx);\n            if (heights[s] < heights[e]) {\n                s ++;\n            } else {\n                e --;\n            }\n        }\n        return nasDaily;\n    }\n    public static long coloredCell (int n) {\n\n        if (n == 1) {\n            return n;\n        }\n\n        return (n - 1) * 4 + coloredCell(n - 1);\n    }\n}","author":"Vel_Murugan","submissionId":"1575167755"},[]]},{"95":[{"id":"95","fileName":"1575169854.txt","sourceCode":"def count_beautiful(n):\n    if n < 1: return 0\n    digits = list(map(int, str(n)))\n    L = len(digits)\n    \n    @cache\n    def dp(pos, tight, started, beautiful, s, p):\n        if pos == L:\n            if not started:\n                return 0\n            if beautiful:\n                return 1\n            else:\n                return int(s != 0 and p % s == 0)\n\n        res = 0\n        max_digit = digits[pos] if tight else 9\n        for d in range(max_digit + 1):\n            new_tight = tight and (d == max_digit)\n            if not started:\n                if d == 0:\n                    res += dp(pos + 1, new_tight, False, False, 0, 1)\n                else:\n                    res += dp(pos + 1, new_tight, True, False, d, d)\n            else:\n                if beautiful:\n                    res += dp(pos + 1, new_tight, True, True, 0, 0)\n                else:\n                    if d == 0:\n                        res += dp(pos + 1, new_tight, True, True, 0, 0)\n                    else:\n                        res += dp(pos + 1, new_tight, True, False, s + d, p * d)\n        return res\n\n    return dp(0, True, False, False, 0, 1)\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return count_beautiful(r) - count_beautiful(l - 1)","author":"delphih","submissionId":"1575169854"},[]]},{"96":[{"id":"96","fileName":"1575170736.txt","sourceCode":"class Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        return f(r) - f(l - 1);\n    }\nprivate:\n    vector<vector<vector<unordered_map<int, int>>>> d;\n    int f(int n) {\n        if (n == 0) return 0;\n        vector<int> v;\n        while (n > 0) {\n            v.push_back(n % 10);\n            n /= 10;\n        }\n        reverse(v.begin(), v.end());\n        d.assign(v.size(), vector<vector<unordered_map<int, int>>>(100, vector<unordered_map<int, int>>(2)));\n        return g(0, 0, 1, 1, v);\n    }\n    int g(int p, int s, int m, int t, vector<int>& v) {\n        if (p == v.size()) return (s != 0 && m % s == 0);\n        if (d[p][s][t].count(m)) return d[p][s][t][m];\n        int l = t ? v[p] : 9, c = 0;\n        for (int x = 0; x <= l; x++) {\n            c += g(p + 1, s + x, (x == 0 && s == 0) ? 1 : m * x, t && (x == l), v);\n        }\n        return d[p][s][t][m] = c;\n    }\n};\n","author":"Chanakya2456","submissionId":"1575170736"},[]]},{"97":[{"id":"97","fileName":"1575171116.txt","sourceCode":"\nint dp[11][2][2][85][85];\nclass Solution {\npublic:\n    int solve(int ind,int ti,int st,int prod_mod,int rem_sum,int sum,string &s){\n        if(ind==s.size()){\n            return (rem_sum==0)  && (prod_mod==0);\n        }\n        \n        if(dp[ind][ti][st][prod_mod][rem_sum] != -1){\n            return dp[ind][ti][st][prod_mod][rem_sum];\n        }\n        \n        \n        int res=0;\n        int d=s[ind]-'0';\n        \n        if(st){\n                \n            if(ti){\n                for(int i=0;i<=d;i++){\n                    if(rem_sum-i>=0)res=res+solve(ind+1,(i==d),1,(prod_mod*i)%sum,rem_sum-i,sum,s);\n                }    \n            }else{\n                for(int i=0;i<=9;i++){\n                    if(rem_sum-i>=0)res=res+solve(ind+1,0,1,(prod_mod*i)%sum,rem_sum-i,sum,s);\n                }\n            }\n            \n        }else{\n            \n            //don't start \n            res=res+solve(ind+1,0,0,prod_mod,rem_sum,sum,s);\n            \n            //start\n            if(ti){\n                for(int i=1;i<=d;i++){\n                    if(rem_sum-i>=0)res=res+solve(ind+1,(i==d),1,(prod_mod*i)%sum,rem_sum-i,sum,s);\n                }    \n            }else{\n                for(int i=1;i<=9;i++){\n                    if(rem_sum-i>=0)res=res+solve(ind+1,0,1,(prod_mod*i)%sum,rem_sum-i,sum,s);\n                }\n            }\n        } \n        \n        return dp[ind][ti][st][prod_mod][rem_sum]=res;\n    }\n    int find_value(string &s){\n        \n        int ret=0;\n        \n        for(int i=1;i<=81;i++){\n            memset(dp,-1,sizeof(dp));\n            ret=ret+solve(0,1,0,1,i,i,s);\n        }\n        \n        return ret;\n\n    }\n    int beautifulNumbers(int l, int r) {\n        string l_str=to_string(l-1);\n        string r_str=to_string(r);\n        \n        return find_value(r_str)-find_value(l_str);\n    }\n};","author":"Harikrishna Shenoy","submissionId":"1575171116"},[]]},{"98":[{"id":"98","fileName":"1575168434.txt","sourceCode":"#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <set>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cassert>\n#include <string>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i = a; i < b; i++)\n#define S(x) scanf(\"%d\",&x)\n#define S2(x,y) scanf(\"%d%d\",&x,&y)\n#define P(x) printf(\"%dn\",x)\n#define all(v) v.begin(),v.end()\n#define FF first\n#define SS second\n#define pb push_back\n#define mp make_pair\n\ntypedef long long int LL;\ntypedef pair<int, int > pii;\ntypedef vector<int > vi;\n\nint dp[82][82][10][2];\n\nstring num;\nint sum;\nint solve(int r, int s, int d, int f) {\n    if(s > sum) return 0;\n    if(d == num.size()) {\n        if(s != sum || r != 0) {\n            return 0;\n        }\n        return 1;\n    }\n    int &res = dp[r][s][d][f];\n    if(res != -1) return res;\n    res = 0;\n    int x = num[d] - '0';\n    if(f) x = 9;\n    rep(i,0,x+1) {\n        int ff = f;\n        if(i < x) ff = 1;\n        int p = r;\n        if(s + i > 0) p = (r * i) % sum;\n        res += solve(p, s + i, d + 1, ff);\n    }\n    return res;\n}\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        // cout << to_string(r) << \"n\";\n        int ans = 0;\n        rep(i,1,82) {\n            memset(dp, -1, sizeof(dp));\n            sum = i;\n            num = to_string(r);\n            int val1 = solve(1 % i, 0, 0, 0);\n            memset(dp, -1, sizeof(dp));\n            num = to_string(l - 1);\n            int val2 = solve(1 % i, 0, 0, 0);\n            // printf(\"%d %d %dn\",i,val1, val2);\n            ans += val1 - val2;\n        }\n        return ans;\n    }\n};","author":"__shadow","submissionId":"1575168434"},[]]},{"99":[{"id":"99","fileName":"1575173103.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def f(x):\n            s = str(x)\n            n = len(s)\n            @cache\n            def dfs(i, isEq, isNum, c0, c2, c3, c5, c7, y):\n                if i == n:\n                    if not isNum:\n                        return 0\n                    if c0:\n                        return 1\n                    for t,ct in zip([2,3,5,7], [c2,c3,c5,c7]):\n                        k = 0\n                        while y % t == 0:\n                            y //= t\n                            k += 1\n                        if k > ct:\n                            return 0\n                    return 1 if y == 1 else 0\n                ans = 0\n                hi = int(s[i]) if isEq else 9\n                for j in range(hi+1):\n                    ans += dfs(i+1, isEq and j == hi, isNum or j > 0,\n                            (c0 or j == 0) and isNum,\n                            min(6, c2 + (j and j % 2 == 0) + (j and j % 4 == 0) + (j == 8)),\n                            min(4, c3 + (j and j % 3 == 0) + (j == 9)),\n                            min(2, c5 + (j == 5)),\n                            min(2, c7 + (j == 7)),\n                            y + j)\n                return ans\n        \n            ans = dfs(0, True, False, False, 0, 0, 0, 0, 0)\n            dfs.cache_clear()\n            return ans\n        \n        return f(r) - f(l-1)","author":"xlx2","submissionId":"1575173103"},[]]},{"100":[{"id":"100","fileName":"1575172127.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        l = [int(c) for c in str(l-1)]\n        r = [int(c) for c in str(r)]\n        A = [l, r]\n        @cache\n        def dp(li, idx, cap, prod, sum, leading_zero=True):\n            a = A[li]\n            if idx == len(a):\n                return prod % sum == 0 if sum else 0\n            ret = 0\n            mx = 9\n            if cap and a[idx] < mx:\n                mx = a[idx]\n            for digit in range(mx+1):\n                iscap = cap and digit == a[idx]\n                ret += dp(li, idx+1, iscap, prod * digit if digit != 0 or not leading_zero else prod, sum + digit, leading_zero and digit == 0)\n            return ret\n        #print(dp(1, 0, True, 1, 0), dp(0, 0, True, 1, 0))\n        res = dp(1, 0, True, 1, 0) - dp(0, 0, True, 1, 0)\n        dp.cache_clear()\n        return res","author":"killer-whale","submissionId":"1575172127"},[]]},{"101":[{"id":"101","fileName":"1575173169.txt","sourceCode":"int id = 0, n, mod;\nstring L, R;\nint dp[10][2][2][2][100][100];\nint vis[10][2][2][2][100][100];\n\nint rec(int i, bool smaller, bool bigger,bool zero, int rem,int rem2) {\n    if(rem2<0)return 0;\n    if (i == n) return rem == 0 && rem2==0;\n    int &ret = dp[i][smaller][bigger][zero][rem][rem2];\n    if (vis[i][smaller][bigger][zero][rem][rem2] == id) return ret;\n    vis[i][smaller][bigger][zero][rem][rem2] = id;\n\n    ret = 0;\n    int low = bigger ? 0 : (L[i] - '0');\n    int high = smaller ? 9 : (R[i] - '0');\n\n    for (int d = low; d <= high; d++) {\n        int z2=zero && (d==0);\n        int new_rem =(z2?1:(rem*d)%mod);\n        bool new_smaller = smaller || (d < high);\n        bool new_bigger = bigger || (d > low);\n        ret += rec(i + 1, new_smaller, new_bigger,z2, new_rem,rem2-d);\n    }\n\n    return ret;\n}\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        L= to_string(l),R= to_string(r);\n        while(L.size()<R.size())L='0'+L;\n         n=L.size();\n        int ans=0;\n        for(int sum=1; sum < 100; sum++){\n            id++;\n            mod=sum;\n            ans+=rec(0,0,0,1,1,sum);\n        }\n        return ans;\n    }\n};","author":"Ahmed_Ashraf","submissionId":"1575173169"},[]]},{"102":[{"id":"102","fileName":"1575172546.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        \n        def f(x):\n            digits = list(map(int, str(x)))\n            n = len(digits)\n\n            @cache\n            def dp(i, is_limit, is_zero, has_zero, s, p):\n                if i == n:\n                    if not is_zero:\n                        return 0\n                    if has_zero:\n                        return 1\n                    if p % s == 0:\n                        return 1\n                    else:\n                        return 0\n\n                res = 0\n                limit = digits[i] if is_limit else 9\n                for d in range(limit + 1):\n                    bound = is_limit and (d == limit)\n                    if not is_zero:\n                        if d == 0:\n                            res += dp(i + 1, bound, False, False, 0, 1)\n                        else:\n                            res += dp(i + 1, bound, True, False, d, d)\n                    else:\n                        if d == 0:\n                            res += dp(i + 1, bound, True, True, s + d, 0)\n                        else:\n                            res += dp(i + 1, bound, True, has_zero, s + d, (0 if has_zero else p * d))\n                return res\n\n            return dp(0, True, False, False, 0, 1)\n        \n        return f(r) - f(l - 1)","author":"Remineva","submissionId":"1575172546"},[]]},{"103":[{"id":"103","fileName":"1575173747.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        \n         \n        def ddp(num):\n            \n            s = str(num)\n            ls = len(s)\n            c0 = int(s[0])\n            \n            # isn, isl, mul, su\n            dp = defaultdict(int)\n            \n            dp[(1, 1, c0, c0)] = 1\n            \n            for i in range(1, c0):\n                dp[(1, 0, i, i)] += 1\n                \n            dp[(0, 0, 0, 0)] = 1\n            \n            for i in range(1, ls):\n                c0 = int(s[i])\n                tmp = defaultdict(int)\n                tmp[(0, 0, 0, 0)] = 1\n                for (isn, isl, mul, su), val in dp.items():\n                    \n                    if isn == 0:\n                        for j in range(1, 10):\n                            tmp[(1, 0, j, j)] += 1\n                            \n                    elif isl == 0:\n                        for j in range(10):\n                            tmp[(1, 0, j * mul, j + su)] += val\n                            \n                    else:\n                        for j in range(c0):\n                            tmp[(1, 0, j * mul, j + su)] += val\n                        tmp[(1, 1, c0 * mul, c0 + su)] += val\n                dp = tmp\n                \n                        \n            ans = 0\n            for (isn, isl, mul, su), val in dp.items():\n                if isn == 1 and mul % su == 0:\n                    ans += val\n                    \n            return ans\n            \n            \n        hi = ddp(r)\n        lo = ddp(l)\n        \n        sums = 0\n        mult = 1\n        res = 0\n        \n        for c in str(l):\n            sums += int(c)\n            mult *= int(c)\n            \n        if mult % sums == 0:\n            res += 1\n        \n        return res + hi - lo\n    ","author":"czjnbb","submissionId":"1575173747"},[{"id":"361","similarity":0.9531914893617022,"totOverlap":224,"longestOverlap":96}]],"361":[{"id":"361","fileName":"611251426.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        \n        \n        def ddp(num):\n            \n            s = str(num)\n            ls = len(s)\n            c0 = int(s[0])\n            \n            # isn, isl, mul, su\n            dp = defaultdict(int)\n            \n            dp[(1, 1, c0, c0)] = 1\n            \n            for i in range(1, c0):\n                dp[(1, 0, i, i)] += 1\n                \n            dp[(0, 0, 0, 0)] = 1\n            \n            for i in range(1, ls):\n                c0 = int(s[i])\n                tmp = defaultdict(int)\n                tmp[(0, 0, 0, 0)] = 1\n                for (isn, isl, mul, su), val in dp.items():\n                    \n                    if isn == 0:\n                        for j in range(1, 10):\n                            tmp[(1, 0, j, j)] += 1\n                            \n                    elif isl == 0:\n                        for j in range(10):\n                            tmp[(1, 0, j * mul, j + su)] += val\n                            \n                    else:\n                        for j in range(c0):\n                            tmp[(1, 0, j * mul, j + su)] += val\n                        tmp[(1, 1, c0 * mul, c0 + su)] += val\n                dp = tmp\n                \n                        \n            ans = 0\n            for (isn, isl, mul, su), val in dp.items():\n                if isn == 1 and mul % su == 0:\n                    ans += val\n                    \n            return ans\n            \n            \n            \n            \n            \n        hi = ddp(r)\n        lo = ddp(l)\n        \n        sums = 0\n        mult = 1\n        res = 0\n        \n        for c in str(l):\n            sums += int(c)\n            mult *= int(c)\n            \n        if mult % sums == 0:\n            res += 1\n        \n        return res + hi - lo","author":"rookie","submissionId":"611251426"},[{"id":"103","similarity":0.9531914893617022,"totOverlap":224,"longestOverlap":96}]]},{"106":[{"id":"106","fileName":"1575174471.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_beautiful(n):\n            digits = list(map(int, str(n)))\n        \n            # Memoization dictionary\n            memo = {}\n        \n            def dp(pos, sum_digits, product_digits, tight, started):\n                if pos == len(digits):  # Base case: all digits processed\n                    return 1 if started and sum_digits != 0 and product_digits % sum_digits == 0 else 0\n        \n                # Check memoization table\n                key = (pos, sum_digits, product_digits, tight, started)\n                if key in memo:\n                    return memo[key]\n        \n                limit = digits[pos] if tight else 9\n                count = 0\n        \n                for digit in range(0, limit + 1):\n                    new_product = product_digits * digit if started else digit  # Avoid multiplying by zero initially\n                    new_sum = sum_digits + digit\n                    count += dp(\n                        pos + 1,\n                        new_sum,\n                        new_product if started or digit > 0 else 1,  # Prevent product from being stuck at 0\n                        tight and (digit == limit),\n                        started or digit > 0  # Ensure leading zeroes are handled correctly\n                    )\n        \n                # Store the result in memoization table\n                memo[key] = count\n                return count\n        \n            return dp(0, 0, 1, True, False)\n\n        return count_beautiful(r) - count_beautiful(l - 1)\n","author":"Joseph Fernando","submissionId":"1575174471"},[]]},{"107":[{"id":"107","fileName":"1575175099.txt","sourceCode":"static int dp[10][82][82][2][2];\n\nclass Solution {\npublic:\n    int n, mod;\n    string s;\n    int beautifulNumbers(int l, int r) {\n        int ans = 0;\n        for(mod = 1; mod < 82; ++mod) {\n            s = to_string(l - 1);\n            n = s.length();\n            memset(dp, -1, sizeof(dp));\n            int lcnt = dfs(0, 1, 0, 1, 0);\n            s = to_string(r);\n            n = s.length();\n            memset(dp, -1, sizeof(dp));\n            int rcnt = dfs(0, 1, 0, 1, 0);\n            ans += rcnt - lcnt;\n        }\n        return ans;\n    }\n\n    int dfs(int i, int mul, int su, int islimit, int isnum) {\n        if(su > mod) {\n            return 0;\n        }\n        if(i == n) {\n            return dp[i][mul][su][islimit][isnum] = (mul == 0 && mod == su && isnum == 1) ? 1 : 0;\n        }\n        int& v = dp[i][mul][su][islimit][isnum];\n        if(v != -1) return v;\n        int cnt = 0;\n        if(!isnum) {\n            cnt += dfs(i + 1, mul, su, 0, 0);\n        }\n        int digit = s[i] - '0';\n        int ub = islimit ? digit : 9;\n        for(int d = 1 - isnum; d <= ub; ++d) {\n            cnt += dfs(i + 1, (mul * d) % mod, su + d, islimit && d == digit, 1);\n        }\n        return v = cnt;\n    }\n};","author":"pein531","submissionId":"1575175099"},[]]},{"108":[{"id":"108","fileName":"1575177436.txt","sourceCode":"class Solution {\npublic:\n    using ll = long long;\n    string s;\n    unordered_map<string, ll> memo;\n    \n    ll dp(int pos, bool tight, bool started, bool hasZero, int sum, ll prod) {\n        if (pos == s.size()) {\n            if (!started) return 0;\n            if (hasZero) return 1;\n            return (prod % sum == 0) ? 1 : 0;\n        }\n        string key = to_string(pos) + \"|\" + to_string(tight) + \"|\" + to_string(started) \n                     + \"|\" + to_string(hasZero) + \"|\" + to_string(sum) + \"|\" + to_string(prod);\n        if(memo.count(key))\n            return memo[key];\n        ll res = 0;\n        int limit = tight ? s[pos] - '0' : 9;\n        for (int d = 0; d <= limit; d++) {\n            bool newTight = (tight && (d == limit)), newStarted = started || (d != 0), newHasZero = hasZero;\n            int newSum = sum;\n            ll newProd = prod;\n            if(!(!started && d == 0)) {\n                if (d == 0) {\n                    newHasZero = true;\n                    newProd = 0;\n                } else {\n                    newSum += d;\n                    newProd *= d;\n                }\n            }\n            res += dp(pos + 1, newTight, newStarted, newHasZero, newSum, newProd);\n        }\n        memo[key] = res;\n        return res;\n    }\n    ll countBeautiful(ll x) {\n        s = to_string(x);\n        memo.clear();\n        return dp(0, true, false, false, 0, 1);\n    }\n    int beautifulNumbers(int l, int r) {\n        return countBeautiful(r) - countBeautiful(l - 1);\n    }\n};\n","author":"Hardik Soni","submissionId":"1575177436"},[]]},{"109":[{"id":"109","fileName":"1575178987.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        from functools import lru_cache\n        def get_digits(n: int):\n            return list(map(int, str(n)))\n        \n        @lru_cache(maxsize=None)\n        def dp(pos, tight, digit_sum, digit_product, leading_zero, digits):\n            if pos == len(digits):\n                return 1 if digit_sum != 0 and digit_product % digit_sum == 0 else 0\n            \n            limit = digits[pos] if tight else 9\n            result = 0\n            \n            for d in range(0, limit + 1):\n                new_sum = digit_sum + d\n                new_product = digit_product * d if not leading_zero or d > 0 else 1\n                result += dp(pos + 1, tight and (d == limit), new_sum, new_product, leading_zero and d == 0, digits)\n            \n            return result\n        \n        def count_beautiful(n):\n            digits = get_digits(n)\n            return dp(0, True, 0, 1, True, tuple(digits))\n        \n        return count_beautiful(r) - count_beautiful(l - 1)","author":"anthonyli633a","submissionId":"1575178987"},[]]},{"110":[{"id":"110","fileName":"1575176917.txt","sourceCode":"class Solution {\n\n    public int beautifulNumbers(int l, int r) {\n        return solve(r + 1) - solve(l);\n    }\n\n    public int solve(int x) {\n        return get(\"\" + x, 0, false, false, 0, 1, false, new HashMap<>());\n    }\n\n    public int get(String s, int i, boolean started, boolean less, int sum, int prod, boolean stop, HashMap<String, Integer> dp) {\n        String temp = i + \" \" + started + \" \" + less + \" \" + sum + \" \" + prod + \" \" + stop;\n        if (dp.containsKey(temp)) {\n            return dp.get(temp);\n        }\n        if (less && stop) {\n            return (int) Math.pow(10, s.length() - i);\n        }\n        if (i == s.length()) {\n            if (!started || !less) {\n                return 0;\n            }\n            if (prod % sum == 0) return 1;\n            return 0;\n        }\n        int up = 0;\n        if (less) up = 9;\n        else up = s.charAt(i) - '0';\n        int ans = 0;\n        for (int j = 0; j <= up; j++) {\n            boolean l = j < up || less;\n            if (!started && j == 0) {\n                ans += get(s, i + 1, false, l, 0, 1, stop, dp);\n            }\n            else if (!started) {\n                ans += get(s, i + 1, true, l, j, j, stop, dp);\n            }\n            if (started) {\n                if (j == 0) {\n                    ans += get(s, i + 1, false, l, sum, 0, true, dp);\n                }\n                else {\n                    ans += get(s, i + 1, true, l, sum + j, prod * j, stop, dp);\n                }\n            }\n        }\n        dp.put(temp, ans);\n        return ans;\n    }\n}","author":"Victor Liu","submissionId":"1575176917"},[]]},{"111":[{"id":"111","fileName":"1575177965.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        count_r = self.count_up_to(r)\n        count_l_minus = self.count_up_to(l - 1)\n        return count_r - count_l_minus\n    def count_up_to(self, n: int) -> int:\n        if n < 1:\n            return 0\n        digits = list(str(n))\n        memo = {}\n        return self.dp(0, True, False, 0, 1, digits, memo)\n    def dp(self, pos: int, tight: bool, started: bool, sum_: int, prod: int, digits: list, memo: dict) -> int:\n        if pos == len(digits):\n            if started and sum_ > 0 and prod % sum_ == 0:\n                return 1\n            return 0\n        key = (pos, tight, started, sum_, prod)\n        if key in memo:\n            return memo[key]\n        limit = int(digits[pos]) if tight else 9\n        res = 0\n        for d in range(0, limit + 1):\n            next_tight = tight and (d == limit)\n            new_started = started or (d != 0)\n            new_sum = sum_\n            new_prod = prod\n            if new_started:\n                if not started:\n                    new_sum = d\n                    new_prod = d\n                else:\n                    new_sum = sum_ + d\n                    new_prod = prod * d\n            res += self.dp(pos + 1, next_tight, new_started, new_sum, new_prod, digits, memo)\n        memo[key] = res\n        return res","author":"Tejas N","submissionId":"1575177965"},[]]},{"112":[{"id":"112","fileName":"1575179937.txt","sourceCode":"class Solution {\n       Map<String, Long> memo;\n    String s; // String representation of current upper bound\n    \n    public int beautifulNumbers(int l, int r) {\n        long countR = countBeautiful(r);\n        long countL = countBeautiful(l - 1);\n        return (int)(countR - countL);\n    }\n    \n    // Counts beautiful numbers ≤ num using digit DP\n    private long countBeautiful(int num) {\n        if (num < 0) return 0; // No numbers below 0\n        s = String.valueOf(num);\n        memo = new HashMap<>();\n        // Start at position 0, tight = 1 (following s), not started, sum=0, product=1\n        return dfs(0, 1, false, 0, 1);\n    }   \n    private long dfs(int pos, int tight, boolean started, int sum, int prod) {\n        if (pos == s.length()) {\n            return (started && sum > 0 && prod % sum == 0) ? 1 : 0;\n        }\n        \n        // Memoization key\n        String key = pos + \",\" + tight + \",\" + started + \",\" + sum + \",\" + prod;\n        if (memo.containsKey(key)) {\n            return memo.get(key);\n        }\n        \n        int limit = (tight == 1) ? s.charAt(pos) - '0' : 9;\n        long res = 0;\n        \n        // Try every digit from 0 to limit\n        for (int dig = 0; dig <= limit; dig++) {\n            int ntight = (tight == 1 && dig == limit) ? 1 : 0;\n            boolean nstarted = started || (dig != 0);\n            int nsum = sum;\n            int nprod = prod;\n            \n            if (nstarted) {\n                if (!started && dig != 0) { // Starting number now\n                    nsum = dig;\n                    nprod = dig;\n                } else if (started) {\n                    nsum = sum + dig;\n                    nprod = prod * dig;\n                }\n            }\n            \n            res += dfs(pos + 1, ntight, nstarted, nsum, nprod);\n        }\n        \n        memo.put(key, res);\n        return res;\n    }\n}","author":"luqman0","submissionId":"1575179937"},[]]},{"113":[{"id":"113","fileName":"1575178593.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        return countBeautiful(r) - countBeautiful(l - 1);\n    }\n\nprivate:\n    map<tuple<int, int, int, int>, int> dp;\n\n    int countBeautiful(int num) {\n        if (num == 0) return 0;\n        vector<int> digits;\n        while (num > 0) {\n            digits.push_back(num % 10);\n            num /= 10;\n        }\n        reverse(digits.begin(), digits.end());\n        dp.clear();\n        return digitDP(0, 1, 0, 1, digits);\n    }\n\n    int digitDP(int pos, int tight, int sum, int prod, const vector<int>& digits) {\n        if (pos == digits.size())  \n            return (sum > 0 && prod % sum == 0) ? 1 : 0;\n\n        auto state = make_tuple(pos, tight, sum, prod);\n        if (dp.count(state))  \n            return dp[state];\n\n        int limit = tight ? digits[pos] : 9, count = 0;\n        for (int d = 0; d <= limit; d++) {\n            int newProd = (sum == 0 && d == 0) ? 1 : prod * d;\n            count += digitDP(pos + 1, (tight && d == limit) ? 1 : 0, sum + d, newProd, digits);\n        }\n\n        return dp[state] = count;\n    }\n};\n","author":"Bharath Annadi","submissionId":"1575178593"},[]]},{"114":[{"id":"114","fileName":"1575182304.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        from functools import lru_cache\n\n        def dp(index, tight, sum_digits, product_digits, started, digits):\n            if index == len(digits):  # Base case: Check divisibility\n                return 1 if sum_digits > 0 and product_digits % sum_digits == 0 else 0\n\n            if (index, tight, sum_digits, product_digits, started) in memo:\n                return memo[(index, tight, sum_digits, product_digits, started)]\n\n            limit = digits[index] if tight else 9\n            count = 0\n\n            for d in range(0, limit + 1):  # Try all digits\n                new_sum = sum_digits + d\n                new_product = (product_digits * d) if (started or d > 0) else 1  # Ensure correct product calculation\n                count += dp(index + 1, tight and (d == limit), new_sum, new_product, started or d > 0, digits)\n\n            memo[(index, tight, sum_digits, product_digits, started)] = count\n            return count\n\n        def count_up_to(n):\n            global memo\n            memo = {}  # Reset memoization for each call\n            digits = list(map(int, str(n)))  # Convert number to digit array\n            return dp(0, True, 0, 1, False, digits)  # False means we haven't picked a nonzero digit yet\n\n        return count_up_to(r) - count_up_to(l - 1)\n","author":"SainiAyush","submissionId":"1575182304"},[]]},{"115":[{"id":"115","fileName":"1575180088.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_beautiful(n: int) -> int:\n            s = str(n)\n            memo = {}\n    \n            def dp(pos: int, tight: bool, started: bool, sum_d: int, prod: int, has_zero: bool) -> int:\n                # Base-case: if we have processed all digits:\n                if pos == len(s):\n                    if not started:\n                        return 0  # no number was formed\n                    # If a zero has been encountered, product = 0 and 0 % sum is 0.\n                    if has_zero:\n                        return 1\n                    # Otherwise, check divisibility: (prod % sum_d == 0)\n                    return 1 if sum_d > 0 and prod % sum_d == 0 else 0\n        \n                # Memoization key for current state\n                key = (pos, tight, started, sum_d, prod, has_zero)\n                if key in memo:\n                    return memo[key]\n        \n                res = 0\n                # Determine the maximum digit we can use in this position\n                end_digit = int(s[pos]) if tight else 9\n        \n                for d in range(0, end_digit + 1):\n                    ntight = tight and (d == end_digit)\n                    if not started and d == 0:\n                        # Still haven't started the number; sum and product remain as initial values.\n                        res += dp(pos + 1, ntight, False, 0, 1, False)\n                    else:\n                        # We are now starting (or have already started) the number.\n                        nstarted = True\n                        nsum = sum_d + d\n                        # If we have already encountered a zero or the current digit is 0, mark has_zero as True.\n                        if has_zero or d == 0:\n                            nhas_zero = True\n                            nprod = 0  # Once a zero appears, product is 0.\n                        else:\n                            nhas_zero = False\n                            nprod = prod * d\n                        res += dp(pos + 1, ntight, nstarted, nsum, nprod, nhas_zero)\n        \n                memo[key] = res\n                return res\n        \n            return dp(0, True, False, 0, 1, False)\n        if (l <= 1):\n            return count_beautiful(r)\n        else:\n            return count_beautiful(r) - count_beautiful(l - 1)\n","author":"Tyrande","submissionId":"1575180088"},[]]},{"117":[{"id":"117","fileName":"1575177922.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        \n        def f(x):\n            S = str(x)\n            n = len(S)\n            res = 0\n            \n            @cache\n            def dp(n, m, s):\n                if n <= 0:\n                    return 1 if s != 0 and m % s == 0 else 0\n                cur = 0\n                for i in range(10):\n                    cur += dp(n-1, m*i, s+i)\n                return cur\n            \n            for l in range(1, n):\n                for x in range(1, 10):\n                    res += dp(l-1, x, x)\n            \n            @cache\n            def g(index, first, top, m, s):\n                if index == n:\n                    return 1 if s != 0 and m % s == 0 else 0\n                x = int(S[index])\n                up = x if top else 10\n                down = 1 if first else 0\n                cur = 0\n                for i in range(down, up):\n                    cur += dp(n-index-1, m*i, s+i)\n                if top:\n                    cur += g(index+1, False, True, m*x, s+x)\n                return cur\n            \n            res += g(0, True, True, 1, 0)\n            # print(x, res)\n            return res\n        \n        return f(r) - f(l-1)\n                \n        ","author":"xs_pg","submissionId":"1575177922"},[]]},{"118":[{"id":"118","fileName":"1575184477.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_no_zero(n):\n            s = str(n)\n            L = len(s)\n            \n            @cache\n            def dp(pos, tight, started):\n                if pos == L:\n                    return 1 if started else 0\n                res = 0\n                limit = int(s[pos]) if tight else 9\n                for d in range(0, limit + 1):\n                    ntight = tight and (d == limit)\n                    if not started:\n                        if d == 0:\n                            res += dp(pos+1, ntight, False)\n                        else:\n                            res += dp(pos+1, ntight, True)\n                    else:\n                        if d == 0:\n                            continue\n                        res += dp(pos+1, ntight, True)\n                return res\n            \n            return dp(0, True, False)\n\n        def count_beautiful_no_zero(n):\n            s = str(n)\n            L = len(s)\n        \n            @cache\n            def dp(pos, tight, started, s_val, p_val):\n                if pos == L:\n                    if started:\n                        return 1 if (p_val % s_val == 0) else 0\n                    return 0\n                res = 0\n                limit = int(s[pos]) if tight else 9\n                for d in range(0, limit + 1):\n                    ntight = tight and (d == limit)\n                    if not started:\n                        if d == 0:\n                            res += dp(pos+1, ntight, False, s_val, p_val)\n                        else:\n                            res += dp(pos+1, ntight, True, s_val + d, p_val * d)\n                    else:\n                        if d == 0:\n                            continue\n                        res += dp(pos+1, ntight, True, s_val + d, p_val * d)\n                return res\n        \n            return dp(0, True, False, 0, 1)\n        \n        def f(x):\n            if x < 1:\n                return 0\n            return count_beautiful_no_zero(x) + (x - count_no_zero(x))\n        return f(r) - f(l - 1)\n","author":"ernie55ernie","submissionId":"1575184477"},[]]},{"119":[{"id":"119","fileName":"1575183832.txt","sourceCode":"class Solution {\n    string hash(string &str, int i, int upto, int done, int zero, int p, int s){\n         string key = to_string(i) + \"*\" + to_string(upto) + \"_\" + to_string(done) + \"?\" + to_string(zero) + \"/\" + to_string(p) + \"]\" + to_string(s);\n        return key;\n    }\n    int fn2(unordered_map<string, int> &dp, string &str, int i, int upto, int done, int zero, int p, int s){\n        if(i == str.size()){\n            if(!done) return 0;\n            if(zero) return 1;\n            if(p%s==0) return 1;\n             return 0;\n        }\n            \n        string key = hash(str,i,upto,done,zero,p,s);\n        if(dp.find(key)!=dp.end()) return dp[key];\n        int ans = 0, lim = 9;\n        if(upto) lim = str[i]-'0';\n        for(int d = 0; d <= lim; d++){\n            if(!done){\n                if(d == 0)  ans += fn2(dp,str,i + 1, (upto && (d==lim)), 0, 0, 1, 0);\n                else     ans += fn2(dp,str,i + 1, (upto && (d==lim)), 1, 0, d, d);\n            }        \n            else{\n                if(zero) ans += fn2(dp,str,i + 1, (upto && (d==lim)), 1, 1, 0, 0);\n                else{\n                    if(d == 0) ans += fn2(dp,str,i + 1, (upto && (d==lim)), 1, 1, 0, 0);\n                    else ans += fn2(dp,str,i + 1, (upto && (d==lim)), 1, 0, p*d , s+d);\n                }\n            }\n        }\n        return dp[key] = ans;\n    }\n    int fn(int n) {\n        if(n == 0) return 0;\n        string s = to_string(n);\n        unordered_map<string, int> dp;\n        return fn2(dp,s, 0, 1, 0, 0, 0, 1);\n    }\npublic:\n    int beautifulNumbers(int l, int r) {\n        return fn(r) - fn(l-1);\n    }\n};","author":"Swapnil Tyagi","submissionId":"1575183832"},[]]},{"120":[{"id":"120","fileName":"1575185847.txt","sourceCode":"#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, x) for(int i = 0; i < int(x); i++)\n#define all(x) (x).begin(), (x).end()\n\ntemplate<class T> inline bool chmax(T &a, T b){if (a < b) {a = b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T &a, T b){if (a > b) {a = b;return 1;}return 0;}\n\n// https://atcoder.jp/contests/abc336/tasks/abc336_e\n\nstruct State {\n    int pos, tight, started, sum;\n    ll prod;\n    bool operator<(const State &other) const {\n        if (pos != other.pos) return pos < other.pos;\n        if (tight != other.tight) return tight < other.tight;\n        if (started != other.started) return started < other.started;\n        if (sum != other.sum) return sum < other.sum;\n        return prod < other.prod;\n    }\n};\n\nll dp(int pos, int tight, int start, int sum, ll prod, string &s, map<State, ll> &mp){\n    if (pos == s.size()){\n        if (!start) return (ll)0;\n        if (sum > 0 && (prod%sum == 0)) return (ll)1;\n        else return (ll)0;\n    }\n    \n    State st{pos, tight, start, sum, prod};\n    if (mp.find(st) != mp.end()) return mp[st];\n    \n    ll ways = 0;\n    int lim = tight ? s[pos]-'0':9;\n    rep(d, lim+1){\n        int ntight = (tight && (d == lim)) ? 1 : 0;\n        int nstart = start; \n        int nsum = sum;\n        ll nprod = prod;\n        \n        if (!start){\n            if (d == 0)\n                ways += dp(pos+1, ntight, 0, 0, 1, s, mp);\n            else{\n                nstart = 1;\n                nsum = d;\n                nprod = d;\n                ways += dp(pos+1, ntight, 1, nsum, nprod, s, mp);\n            }\n        }\n        else {\n            nsum = sum+d;\n            nprod = prod*d;\n            ways += dp(pos+1, ntight, 1, nsum, nprod, s, mp);\n        }\n    }\n    return mp[st] = ways;\n}\n\nll solve(ll x){\n    if (x < 1) return 0;\n    string s = to_string(x);\n    map<State, ll> mp;\n    return dp(0, 1, 0, 0, 1, s, mp);\n}\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        ll ans = solve(r) - solve(l-1);\n        return ans;\n    }\n};","author":"t38178","submissionId":"1575185847"},[]]},{"121":[{"id":"121","fileName":"1575182242.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n   \n    public int beautifulNumbers(int l, int r) {\n       \n        int countZeros = countZerosUpto(r) - countZerosUpto(l - 1);\n     \n        int countNonZero = countNonZeroBeautifulDP(r) - countNonZeroBeautifulDP(l - 1);\n        return countZeros + countNonZero;\n    }\n    \n    \n    private int countZerosUpto(int x) {\n        if (x < 1) return 0;\n        char[] s = Integer.toString(x).toCharArray();\n        int n = s.length;\n        Integer[][][][] memoZeros = new Integer[n][2][2][2];\n        return dfsZeros(s, 0, 1, 0, 0, memoZeros);\n    }\n    \n    private int dfsZeros(char[] s, int pos, int tight, int started, int hasZero, Integer[][][][] memo) {\n        if (pos == s.length) {\n            return (started == 1 && hasZero == 1) ? 1 : 0;\n        }\n        if (memo[pos][tight][started][hasZero] != null) {\n            return memo[pos][tight][started][hasZero];\n        }\n        int limit = (tight == 1 ? s[pos] - '0' : 9);\n        int count = 0;\n        for (int d = 0; d <= limit; d++) {\n            int newTight = (tight == 1 && d == limit) ? 1 : 0;\n            int newStarted = started;\n            int newHasZero = hasZero;\n            if (started == 0) {\n                if (d != 0) {\n                    newStarted = 1;\n                }\n            }\n            if (newStarted == 1) {\n                if (d == 0) {\n                    newHasZero = 1;\n                }\n            }\n            count += dfsZeros(s, pos + 1, newTight, newStarted, newHasZero, memo);\n        }\n        memo[pos][tight][started][hasZero] = count;\n        return count;\n    }\n    \n\n    private Map<DPKey, Integer> memo;\n    \n    private int countNonZeroBeautifulDP(int x) {\n        String s = Integer.toString(x);\n        int n = s.length();\n        int[] digits = new int[n];\n        for (int i = 0; i < n; i++) {\n            digits[i] = s.charAt(i) - '0';\n        }\n        memo = new HashMap<>();\n        \n        return dpNonZero(digits, 0, 1, false, 0, 0, 0, 0, 0);\n    }\n    \n\n    private int dpNonZero(int[] digits, int pos, int tight, boolean started,\n                          int sum, int f2, int f3, int f5, int f7) {\n        if (pos == digits.length) {\n            if (!started) return 0; \n            if (sum == 0) return 0;\n            int[] req = factorize(sum);\n           \n            if (req[3] == -1) return 0;\n            if (f2 >= req[0] && f3 >= req[1] && f5 >= req[2] && f7 >= req[3]) return 1;\n            return 0;\n        }\n        DPKey key = new DPKey(pos, tight, started, sum, f2, f3, f5, f7);\n        if (memo.containsKey(key)) return memo.get(key);\n        int res = 0;\n        int limit = (tight == 1 ? digits[pos] : 9);\n        for (int d = 0; d <= limit; d++) {\n            int ntight = (tight == 1 && d == limit) ? 1 : 0;\n            if (!started) {\n                if (d == 0) {\n                    \n                    res += dpNonZero(digits, pos + 1, ntight, false, 0, 0, 0, 0, 0);\n                } else {\n                   \n                    int[] factors = digitFactors(d);\n                    res += dpNonZero(digits, pos + 1, ntight, true, d,\n                                     factors[0], factors[1], factors[2], factors[3]);\n                }\n            } else {\n          \n                if (d == 0) continue;\n                int[] factors = digitFactors(d);\n                res += dpNonZero(digits, pos + 1, ntight, true, sum + d,\n                                 f2 + factors[0], f3 + factors[1],\n                                 f5 + factors[2], f7 + factors[3]);\n            }\n        }\n        memo.put(key, res);\n        return res;\n    }\n    \n    \n    private int[] digitFactors(int d) {\n        switch(d) {\n            case 1: return new int[]{0, 0, 0, 0};\n            case 2: return new int[]{1, 0, 0, 0};\n            case 3: return new int[]{0, 1, 0, 0};\n            case 4: return new int[]{2, 0, 0, 0};\n            case 5: return new int[]{0, 0, 1, 0};\n            case 6: return new int[]{1, 1, 0, 0};\n            case 7: return new int[]{0, 0, 0, 1};\n            case 8: return new int[]{3, 0, 0, 0};\n            case 9: return new int[]{0, 2, 0, 0};\n        }\n        return new int[]{0, 0, 0, 0}; \n    }\n    \n   \n    private int[] factorize(int s) {\n        int[] res = new int[4]; // for 2,3,5,7\n        int temp = s;\n        while (temp % 2 == 0) { res[0]++; temp /= 2; }\n        while (temp % 3 == 0) { res[1]++; temp /= 3; }\n        while (temp % 5 == 0) { res[2]++; temp /= 5; }\n        while (temp % 7 == 0) { res[3]++; temp /= 7; }\n        if (temp != 1) { \n            \n            res[3] = -1; \n        }\n        return res;\n    }\n    \n  \n    class DPKey {\n        int pos, tight, sum, f2, f3, f5, f7;\n        boolean started;\n        \n        public DPKey(int pos, int tight, boolean started, int sum, int f2, int f3, int f5, int f7) {\n            this.pos = pos;\n            this.tight = tight;\n            this.started = started;\n            this.sum = sum;\n            this.f2 = f2;\n            this.f3 = f3;\n            this.f5 = f5;\n            this.f7 = f7;\n        }\n        \n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (!(o instanceof DPKey)) return false;\n            DPKey other = (DPKey) o;\n            return pos == other.pos && tight == other.tight && started == other.started &&\n                   sum == other.sum && f2 == other.f2 && f3 == other.f3 &&\n                   f5 == other.f5 && f7 == other.f7;\n        }\n        \n        @Override\n        public int hashCode() {\n            int hash = 7;\n            hash = hash * 31 + pos;\n            hash = hash * 31 + tight;\n            hash = hash * 31 + (started ? 1 : 0);\n            hash = hash * 31 + sum;\n            hash = hash * 31 + f2;\n            hash = hash * 31 + f3;\n            hash = hash * 31 + f5;\n            hash = hash * 31 + f7;\n            return hash;\n        }\n    }\n}\n","author":"Suraj Chaudhary","submissionId":"1575182242"},[]]},{"122":[{"id":"122","fileName":"1575184810.txt","sourceCode":"int dp[9][82][82][2][2]; // pos, soma,produtoria e se eh igual ao limite, zero a esquerda\nclass Solution {\npublic:\n    int solve(int pos, int s,int prod, int f,int zero, string & lim,int tot){\n        if(s < 0) return 0;\n        if(pos == lim.size()) return (s == 0 && prod == 0);\n        int & bst = dp[pos][s][prod][f][zero];\n        if(bst != -1) return bst;\n        bst = 0;\n        int b = 0;\n        int e = (f ? lim[pos]-'0' : 9);\n        for(int i=b; i<=e; i++){\n            bst += solve(pos+1,s - i, ((zero && i == 0) ? prod : prod*i%tot), (f&(i == lim[pos]-'0')),zero&(i == 0), lim,tot);\n        }\n        return bst;\n    }\n\n    int beautifulNumbers(int l, int r) {\n        int ans = 0;\n        string R = to_string(r);\n        string L = to_string(l-1);\n        for(int i=1; i<=81; i++){\n            memset(dp,-1,sizeof(dp));\n            ans += solve(0,i,1,1,1,R,i);\n            // cout << ans << 'n';\n            memset(dp,-1,sizeof(dp));\n            ans -= solve(0,i,1,1,1,L,i);\n            // cout << ans << 'n';\n            // cout << \"foin\";\n        }\n        return ans;\n    }\n};","author":"Felipe Sabino","submissionId":"1575184810"},[]]},{"123":[{"id":"123","fileName":"1575185510.txt","sourceCode":"\n\n\n// COPY ALL MACROS BELOW\n\ntypedef long long LL;\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define LB lower_bound\n#define UB upper_bound\n#define SZ(x) ((int)x.size())\n#define LEN(x) ((int)x.length())\n#define ALL(x) begin(x), end(x)\n#define RSZ resize\n#define ASS assign\n#define REV(x) reverse(x.begin(), x.end());\n#define trav(a, x) for (auto& a : x)\ntypedef pair<LL, LL> PL;\ntypedef vector<LL> VL;\ntypedef vector<PL> VPL;\ntypedef vector<VL> VVL;\ntypedef vector<VVL> VVVL;\ntypedef vector<VVVL> VVVVL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PI;\ntypedef vector<int> VI;\ntypedef vector<PI> VPI;\ntypedef vector<vector<int>> VVI;\ntypedef vector<vector<vector<int>>> VVVI;\ntypedef vector<vector<PI>> VVPI;\n#define MAX(x) *max_element(ALL(x))\n#define MIN(x) *min_element(ALL(x))\n#define FOR(i, n) for (int i = 0; i < n; i++) \n#define FOR1(i, n) for (int i = 1; i <= n; i++) \n#define SORT(x) sort(x.begin(), x.end())\n#define RSORT(x) sort(x.rbegin(), x.rend())\n#define SUM(x) accumulate(x.begin(), x.end(), 0LL)\n#define MMAX(n, x)  n = max(n, x)\n#define MMIN(n, x)  n = min(n, x)\n\n#define MAXXX 82\nVVVI mul(MAXXX, VVI(MAXXX, VI(MAXXX, 0)));\nbool used = false;\n\nint dp[10][2][MAXXX][MAXXX][MAXXX];\n\nclass Solution {\n\t// mul[a][b][r] = (a * b) % r\n\n\tvoid init() {\n\t\tFOR(i, MAXXX) {\n\t\t\tFOR(j, MAXXX) {\n\t\t\t\tFOR1(k, MAXXX - 1) {\n\t\t\t\t\tmul[i][j][k] = (i * j) % k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint solve(LL x) {\n\t\tif (x == 0) return 0;\n\n\t\tstring s = to_string(x);\n\t\tint n = s.length(), i, j, k, ans, MAXX = n * 9 + 1;\n\n\t\t// dp[step][breached][sum][r][% r] = ct\n\t\t//vector<vector<VVVI>> dp(n + 1, vector<VVVI>(2, VVVI(MAXX, VVI(MAXX, VI(MAXX, 0)))));\n\n\t\tFOR(i, n + 1) FOR(j, 2) FOR(k, MAXX) FOR(l, MAXX) FOR(kk, MAXX) dp[i][j][k][l][kk] = 0;\n\n\t\tFOR1(i, MAXX - 1) dp[0][0][0][i][0] = 1;\n\n\t\tFOR(i, n) {\n\t\t\tLL d = s[i] - '0';\n\t\t\tFOR(j, 2) {\n\t\t\t\tFOR(sum, MAXX) {\n\t\t\t\t\tFOR1(r, MAXX - 1) {\n\t\t\t\t\t\tint maxx = 9;\n\t\t\t\t\t\tif (j == 0) maxx = d;\n\n\t\t\t\t\t\tFOR(rr, r) {\n\t\t\t\t\t\t\tif (dp[i][j][sum][r][rr] == 0) continue;\n\t\t\t\t\t\t\tfor (int dd = 0; dd <= maxx; dd++) {\n\t\t\t\t\t\t\t\tint breached = j || (dd < d);\n\t\t\t\t\t\t\t\tint sum2 = sum + dd;\n\t\t\t\t\t\t\t\tint rrr;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif ((sum == 0) && (rr != 0)) continue;\n\t\t\t\t\t\t\t\t//if (sum == 0) rrr = dd % r;\n\t\t\t\t\t\t\t\t//else rrr = (rr * dd) % r;\n\t\t\t\t\t\t\t\tif (sum == 0) rrr = mul[1][dd][r];\n\t\t\t\t\t\t\t\telse rrr = mul[rr][dd][r]; \n\n\t\t\t\t\t\t\t\tdp[i + 1][breached][sum2][r][rrr] += dp[i][j][sum][r][rr];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tFOR1(i, MAXX - 1) ans += dp[n][0][i][i][0] + dp[n][1][i][i][0];\n\n\t\treturn ans;\n\t}\n\npublic:\n\tint beautifulNumbers(int l, int r) {\n\t\tif (!used) {\n\t\t\tused = true;\n\t\t\tinit();\n\t\t}\n\t\tint ll = solve(l - 1), rr = solve(r), ans = rr - ll;\n\t\treturn ans;\n\t}\n}; ","author":"Wanjun Li","submissionId":"1575185510"},[]]},{"124":[{"id":"124","fileName":"1575186112.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        # return bisect.bisect_right(data, r) - bisect.bisect_left(data, l)\n        def cal(x):\n            arr = [int(ch) for ch in str(x)]\n            @lru_cache(None)\n            def dp(i, less, s, p):\n                if i>=len(arr):\n                    if s==0: return 0\n                    return int(p%s)==0\n                capped = 9 if less else arr[i]\n                res=0\n                for j in range(capped+1):\n                    less2 = less or j<arr[i]\n                    s2 = s + j\n                    p2 = p\n                    if s2>0: p2*=j\n                    res += dp(i+1, less2, s2, p2)\n                return res\n            return dp(0, False, 0, 1)\n        return cal(r)-cal(l-1)\n                        \n        ","author":"Nguyễn Thảo","submissionId":"1575186112"},[]]},{"125":[{"id":"125","fileName":"1575186331.txt","sourceCode":"from functools import lru_cache\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        @lru_cache(None)\n        def dp(x):\n            if x == 0:\n                return {}\n            if x < 10:\n                return {(i, i): 1 for i in range(1, x + 1)}  # prod, sum\n            \n            output = {(0, 1): x // 10}\n            for i in range(1, 10):\n                output[(i, i)] = 1\n            \n            for r in range(1, 10):\n                if r <= x % 10:\n                    _o = dp(x // 10)\n                    \n                    for (p, s), f in _o.items():\n                        if (p, s) == (0, 1):\n                            output[(0, 1)] += f\n                        else:\n                            np, ns = p * r, s + r\n                            output[(np, ns)] = output.get((np, ns), 0) + f\n                else:\n                    _o = dp(x // 10 - 1)\n                    \n                    for (p, s), f in _o.items():\n                        if (p, s) == (0, 1):\n                            output[(0, 1)] += f\n                        else:\n                            np, ns = p * r, s + r\n                            output[(np, ns)] = output.get((np, ns), 0) + f\n                            \n            return output\n        \n        answer = 0\n        r_output = dp(r)\n        l_output = dp(l - 1)\n        \n        # print(r_output, l_output)\n            \n        for (p, s), f in r_output.items():\n            if p % s == 0:\n                answer += f\n\n        for (p, s), f in l_output.items():\n            if p % s == 0:\n                answer -= f\n\n        return answer","author":"Maruzensky","submissionId":"1575186331"},[]]},{"126":[{"id":"126","fileName":"1575186469.txt","sourceCode":"import functools\n\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count(x):\n            if x == 0:\n                return 0\n            a = [int(c) for c in str(x)]\n            n = len(a)\n\n            @functools.lru_cache(None)\n            def dp(i, s, m, is_less, is_leading_zero):\n                if i == n:\n                    return 1 if s > 0 and m % s == 0 else 0\n                ans = 0\n                for d in range(10):\n                    next_leading_zero = is_leading_zero\n                    if d > 0:\n                        next_leading_zero = False\n                    if d == a[i]:\n                        ans += dp(i + 1, s + d, 1 if next_leading_zero else m * d, is_less, next_leading_zero)\n                    elif d < a[i] or is_less:\n                        ans += dp(i + 1, s + d, 1 if next_leading_zero else m * d, True, next_leading_zero)\n                return ans\n\n            res = dp(0, 0, 1, False, True)\n            return res\n\n        return count(r) - count(l - 1)","author":"pikapika","submissionId":"1575186469"},[]]},{"127":[{"id":"127","fileName":"1575187092.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n \nstruct State {\n    int tight, started, hasZero, sum;\n    long long prod;\n    bool operator==(const State &other) const {\n        return tight == other.tight && started == other.started && hasZero == other.hasZero && sum == other.sum && prod == other.prod;\n    }\n};\n \nstruct StateHash {\n    size_t operator()(const State &st) const {\n        unsigned long long key = 0;\n        key |= (unsigned long long) st.tight;\n        key = (key << 1) | st.started;\n        key = (key << 1) | st.hasZero;\n        key = (key << 7) | (unsigned long long) st.sum;\n        key = (key << 32) | ((unsigned long long) st.prod);\n        return std::hash<unsigned long long>()(key);\n    }\n};\n \nclass Solution {\npublic:\n    long long f(long long x) {\n        if(x < 1) return 0;\n        string s = to_string(x);\n        int n = s.size();\n        vector<int> digits(n);\n        for (int i = 0; i < n; i++){\n            digits[i] = s[i] - '0';\n        }\n        unordered_map<State, long long, StateHash> dp;\n        State init = {1, 0, 0, 0, 1};\n        dp[init] = 1;\n        for (int pos = 0; pos < n; pos++){\n            unordered_map<State, long long, StateHash> ndp;\n            int lim;\n            for (auto &item : dp) {\n                State st = item.first;\n                long long cnt = item.second;\n                lim = (st.tight == 1 ? digits[pos] : 9);\n                for (int d = 0; d <= lim; d++){\n                    State nst;\n                    nst.tight = (st.tight == 1 && d == lim) ? 1 : 0;\n                    if (st.started == 0 && d == 0) {\n                        nst.started = 0;\n                        nst.sum = 0;\n                        nst.prod = 1;\n                        nst.hasZero = 0;\n                    } else {\n                        nst.started = 1;\n                        if (st.started == 0) {\n                            nst.sum = d;\n                            nst.prod = d;\n                            nst.hasZero = (d == 0) ? 1 : 0;\n                        } else {\n                            nst.sum = st.sum + d;\n                            if (st.hasZero == 1 || d == 0) {\n                                nst.hasZero = 1;\n                                nst.prod = 0;\n                            } else {\n                                nst.hasZero = 0;\n                                nst.prod = st.prod * d;\n                            }\n                        }\n                    }\n                    ndp[nst] += cnt;\n                }\n            }\n            dp = move(ndp);\n        }\n        long long ans = 0;\n        for (auto &item : dp) {\n            State st = item.first;\n            long long cnt = item.second;\n            if (st.started == 1) {\n                if (st.hasZero == 1) ans += cnt;\n                else if (st.sum != 0 && st.prod % st.sum == 0) ans += cnt;\n            }\n        }\n        return ans;\n    }\n    \n    int beautifulNumbers(int l, int r) {\n        long long res = f(r) - f(l - 1);\n        return (int)res;\n    }\n};\n ","author":"I_Love_Ginger","submissionId":"1575187092"},[]]},{"128":[{"id":"128","fileName":"1575186623.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def countBeautiful(n): # helper\n            if n == 0: return 0\n            digits = list(map(int, str(n)))\n            @lru_cache(maxsize=None)\n            def dp(i, matching, started, contains0, s, p):\n                if i == len(digits):\n                    if not started: return 0\n                    if contains0: return 1\n                    return 1 if (s != 0 and p % s == 0) else 0\n                res = 0\n                maxDigit = digits[i] if matching else 9\n                for d in range(maxDigit+1):\n                    matchingNew = matching and (d == maxDigit)\n                    if not started and d == 0:\n                        res += dp(i+1, matchingNew, False, False, 0, 1)\n                    else:\n                        contains0new = contains0 or (d == 0)\n                        res += dp(i+1, matchingNew, True, contains0new, s+d, p*d)\n                return res\n\n            return dp(0, True, False, False, 0, 1)\n        return countBeautiful(r)-countBeautiful(l-1)\n\n        ","author":"Yilun Wu","submissionId":"1575186623"},[]]},{"129":[{"id":"129","fileName":"1575187183.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        #s==2, i<10, e1==2, p==?, su<=81\n        @cache\n        def dp(s,i,eq,z,p,su):\n            if i == len(s):\n                return p%su==0 if su else 0\n            lim = int(s[i]) if eq else 9\n            res = 0\n            for c in range(lim+1):\n                res+=dp(s,i+1,eq&(c==int(s[i])),z and not c,p if z and not c else p*c,su+c)\n            return res\n        return dp(str(r),0,1,True,1,0)-dp(str(l-1),0,1,True,1,0)","author":"glump1","submissionId":"1575187183"},[]]},{"130":[{"id":"130","fileName":"1575186810.txt","sourceCode":"class Solution {\npublic:\n    int f[82][7][5][3][3][2][2], g[82][7][5][3][3][2][2], p[15], dp[7][5][3][3];\n    int mx[5] = {0,6,4,2,2};\n    int solve(int x){\n        vector<int> digit;\n        while(x>0){digit.push_back(x%10);x/=10;}\n        if(digit.empty()) digit.push_back(0);\n        reverse(digit.begin(),digit.end());\n        int len=digit.size();\n        for(int j=0;j<=81;j++)\n            for(int a=0;a<=mx[1];a++)\n                for(int b=0;b<=mx[2];b++)\n                    for(int c=0;c<=mx[3];c++)\n                        for(int d=0;d<=mx[4];d++)\n                            for(int e=0;e<=1;e++)\n                                for(int o=0;o<=1;o++){\n                                    f[j][a][b][c][d][e][o]=0;\n                                    g[j][a][b][c][d][e][o]=0;\n                                }\n        f[0][0][0][0][0][0][0]=1;\n        for(int i=1;i<=len;i++){\n            int up=digit[i-1];\n            for(int j=0;j<=(i-1)*9;j++)\n                for(int a=0;a<=mx[1];a++)\n                    for(int b=0;b<=mx[2];b++)\n                        for(int c=0;c<=mx[3];c++)\n                            for(int d=0;d<=mx[4];d++)\n                                for(int e=0;e<=1;e++)\n                                    for(int o=0;o<=1;o++){\n                                        g[j][a][b][c][d][e][o]=f[j][a][b][c][d][e][o];\n                                        f[j][a][b][c][d][e][o]=0;\n                                    }\n            for(int j=0;j<=(i-1)*9;j++)\n                for(int a=0;a<=mx[1];a++)\n                    for(int b=0;b<=mx[2];b++)\n                        for(int c=0;c<=mx[3];c++)\n                            for(int d=0;d<=mx[4];d++)\n                                for(int e=0;e<=1;e++)\n                                    for(int o=0;o<=1;o++){\n                                        int base=g[j][a][b][c][d][e][o];\n                                        if(!base)continue;\n                                        for(int now=0;now<=9;now++){\n                                            if(!e&&now>up)break;\n                                            int nj=j+now,na=a,nb=b,nc=c,nd=d,ne=e,no=o;\n                                            if(now<up) ne=1;\n                                            if(now==0&&j!=0) no=1;\n                                            if(!no){\n                                                if(now==2) na++;\n                                                else if(now==3) nb++;\n                                                else if(now==4) na+=2;\n                                                else if(now==5) nc++;\n                                                else if(now==6){na++;nb++;}\n                                                else if(now==7) nd++;\n                                                else if(now==8) na+=3;\n                                                else if(now==9) nb+=2;\n                                                na=min(na,mx[1]);\n                                                nb=min(nb,mx[2]);\n                                                nc=min(nc,mx[3]);\n                                                nd=min(nd,mx[4]);\n                                            }\n                                            f[nj][na][nb][nc][nd][ne][no]+=base;\n                                        }\n                                    }\n        }\n        long long ans=0;\n        for(int j=0;j<=81;j++)\n            for(int a=0;a<=6;a++)\n                for(int b=0;b<=4;b++)\n                    for(int c=0;c<=2;c++)\n                        for(int d=0;d<=2;d++)\n                            for(int e=0;e<=1;e++)\n                                for(int o=0;o<=1;o++){\n                                    int cnt=f[j][a][b][c][d][e][o];\n                                    if(!cnt)continue;\n                                    if(o||(j&&dp[a][b][c][d]%j==0)) ans+=cnt;\n                                }\n        return ans;\n    }\n    int beautifulNumbers(int l,int r){\n        dp[0][0][0][0]=1;\n        for(int a=0;a<=mx[1];a++)\n            for(int b=0;b<=mx[2];b++)\n                for(int c=0;c<=mx[3];c++)\n                    for(int d=0;d<=mx[4];d++){\n                        long long val=1;\n                        for(int i=0;i<a;i++) val*=2;\n                        for(int i=0;i<b;i++) val*=3;\n                        for(int i=0;i<c;i++) val*=5;\n                        for(int i=0;i<d;i++) val*=7;\n                        dp[a][b][c][d]=val;\n                    }\n        if(l<1) l=1;\n        return solve(r)-solve(l-1);\n    }\n};\n","author":"Ethan","submissionId":"1575186810"},[]]},{"131":[{"id":"131","fileName":"1575187095.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n\n        def helper(n: int) -> int:\n            if n == 0:\n                return 0\n\n            cur = str(n)\n            size = len(cur)\n\n            @cache\n            def dfs(pos: int, sum: int, prod: int, isLimit: bool, isChosen: bool) -> int:\n                if pos == size:\n                    if not isChosen:\n                        return 0\n                    return 1 if (prod % sum == 0) else 0\n\n                ans = 0\n                if not isChosen:\n                    ans += dfs(pos + 1, 0, 1, False, False)\n\n                lb = 0 if isChosen else 1\n                rb = int(cur[pos]) if isLimit else 9\n\n                for i in range(lb, rb + 1):\n                    ans += dfs(pos + 1, sum + i, prod * i, isLimit and i == int(cur[pos]), True)\n\n                return ans\n\n            return dfs(0, 0, 1, True, False)\n\n        return helper(r) - helper(l - 1)","author":"jackey","submissionId":"1575187095"},[]]},{"132":[{"id":"132","fileName":"1575186766.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return self.count(r) - self.count(l - 1)\n        \n    def count(self, number):\n        @lru_cache(None)\n        def dfs(idx, curr_prod, curr_sum, is_limit, is_leading_zero):\n            if idx == n:\n                if curr_sum and curr_prod % curr_sum == 0:\n                    return 1\n                return 0\n            \n            output = 0\n            if not is_limit:\n                for num in range(10):\n                    if num == 0 and is_leading_zero:\n                        output += dfs(idx + 1, curr_prod, curr_sum + num, False, True)\n                    else:\n                        output += dfs(idx + 1, curr_prod * num, curr_sum + num, False, False)\n            else:\n                for num in range(digits[idx]):\n                    if num == 0 and is_leading_zero:\n                        output += dfs(idx + 1, curr_prod, curr_sum + num, False, True)\n                    else:\n                        output += dfs(idx + 1, curr_prod * num, curr_sum + num, False, False)\n                        \n                output += dfs(idx + 1, curr_prod * digits[idx], curr_sum + digits[idx], True, False)\n            return output\n        \n        if number == 0:\n            return 0\n        \n        digits = [int(digit) for digit in str(number)]\n        n = len(digits)\n        \n        return dfs(0, 1, 0, True, True)","author":"Dang Huy Nguyen","submissionId":"1575186766"},[]]},{"133":[{"id":"133","fileName":"1575188236.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        \n        def solve(x):\n            s = str(x)\n            n = len(s)\n            \n            @cache\n            def solve2(ind, tight, started, zero, sm, prod):\n                if ind == n:\n                    if started:\n                        return zero or (prod % sm == 0)\n                    return 0\n                \n                ans = 0\n                limit = int(s[ind]) if tight else 9\n                for i in range(limit + 1):\n                    ntight = tight and (i == limit)\n                    if not started:\n                        ans += solve2(ind + 1, ntight, i > 0, False, i, i if i > 0 else 1)\n                    else:\n                        ans += solve2(ind + 1, ntight, True, i == 0 or zero, sm + i if i > 0 else 0, prod * i if i > 0 else 1)\n                \n                return ans\n            \n            return solve2(0, True, False, False, 0, 1)\n        \n        \n        return solve(r) - solve(l - 1)","author":"Anchor Being","submissionId":"1575188236"},[]]},{"135":[{"id":"135","fileName":"1575188660.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    private Map<String, Integer> memo;\n\n    public int beautifulNumbers(int l, int r) {\n        return countBeautiful(r) - countBeautiful(l - 1);\n    }\n\n    private int countBeautiful(int num) {\n        if (num == 0) return 0;\n\n        String s = String.valueOf(num);\n        memo = new HashMap<>();\n\n        return digitDP(s, 0, 1, 0, 1, true);\n    }\n\n    private int digitDP(String s, int pos, int tight, int sum, int product, boolean leadingZero) {\n        if (pos == s.length()) {\n            return (sum > 0 && product % sum == 0) ? 1 : 0;\n        }\n\n        // Memoization key\n        String key = pos + \"|\" + tight + \"|\" + sum + \"|\" + product;\n        if (memo.containsKey(key)) return memo.get(key);\n\n        int limit = (tight == 1) ? s.charAt(pos) - '0' : 9;\n        int res = 0;\n\n        for (int d = 0; d <= limit; d++) {\n            res += digitDP(s, pos + 1, (tight == 1 && d == limit) ? 1 : 0,\n                           sum + d, (d == 0 && leadingZero) ? 1 : product * d, leadingZero && d == 0);\n        }\n\n        memo.put(key, res);\n        return res;\n    }\n}\n","author":"Chiru_Sandeep_Reddy__Sabbella","submissionId":"1575188660"},[]]},{"136":[{"id":"136","fileName":"1575190936.txt","sourceCode":"//* sometimes pragmas don't work, if so, just comment it!\n//? #pragma GCC optimize (\"Ofast\")\n//? #pragma GCC target (\"avx,avx2\")\n//! #pragma GCC optimize (\"trapv\")\n\n//! #undef _GLIBCXX_DEBUG //? for Stress Testing\n\n#include <bits/stdc++.h> //? if you don't want IntelliSense\n\nusing namespace std;\n\n// building blocks\nusing ll  = long long;\nusing db  = long double; // or double, if TL is tight\nusing str = string;      // yay python!\n\n//? priority_queue for minimum\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\nusing ull  = unsigned long long;\n//? using i64  = long long;\n//? using u64  = uint64_t;\n//? using i128 = __int128;\n//? using u128 = __uint128_t;\n//? using f128 = __float128;\n\n\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n\n#define mp make_pair\n#define f  first\n#define s  second\n\n\n\n#define tcT template <class T\n#define tcTU tcT, class U\n//! ^ lol this makes everything look weird but I'll try it\n\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n#define ts to_string\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\n\n\nconst int MOD = 1e9 + 7;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18;  //? not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  //? for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\n\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits set\nconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\n\t                         // USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n}  // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n}  // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n}  // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n}  // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n}  // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi);  // assuming f is increasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi);  // assuming f is decreasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) {  // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void safeErase(T &t, const U &u) {\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n}\n\n\n\n#define tcTUU tcT, class ...U\n\ninline namespace IO {\n#define SFINAE(x, ...)                                                         \n\ttemplate <class, class = void> struct x : std::false_type {};              \n\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}\n\nSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));\nSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));\nSFINAE(IsTuple, typename std::tuple_size<T>::type);\nSFINAE(Iterable, decltype(std::begin(std::declval<T>())));\n\ntemplate <auto &is> struct Reader {\n\ttemplate <class T> void Impl(T &t) {\n\t\tif constexpr (DefaultI<T>::value) is >> t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tfor (auto &x : t) Impl(x);\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\n\t\t} else static_assert(IsTuple<T>::value, \"No matching type for read\");\n\t}\n\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }\n};\n\ntemplate <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }\n#define def(t, args...)                                                        \n\tt args;                                                                    \n\tre(args);\n\ntemplate <auto &os, bool debug, bool print_nd> struct Writer {\n\tstring comma() const { return debug ? \",\" : \"\"; }\n\ttemplate <class T> constexpr char Space(const T &) const {\n\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? 'n'\n\t\t                                                             : ' ';\n\t}\n\ttemplate <class T> void Impl(T const &t) const {\n\t\tif constexpr (DefaultO<T>::value) os << t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tif (debug) os << '{';\n\t\t\tint i = 0;\n\t\t\tfor (auto &&x : t)\n\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\n\t\t\tif (debug) os << '}';\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tif (debug) os << '(';\n\t\t\tstd::apply(\n\t\t\t    [this](auto const &...args) {\n\t\t\t\t    int i = 0;\n\t\t\t\t    (((i++) ? (os << comma() << \" \", Impl(args)) : Impl(args)),\n\t\t\t\t     ...);\n\t\t\t    },\n\t\t\t    t);\n\t\t\tif (debug) os << ')';\n\t\t} else static_assert(IsTuple<T>::value, \"No matching type for print\");\n\t}\n\ttemplate <class T> void ImplWrapper(T const &t) const {\n\t\tif (debug) os << \"033[0;31m\";\n\t\tImpl(t);\n\t\tif (debug) os << \"033[0m\";\n\t}\n\ttemplate <class... Ts> void print(Ts const &...ts) const {\n\t\t((Impl(ts)), ...);\n\t}\n\ttemplate <class F, class... Ts>\n\tvoid print_with_sep(const std::string &sep, F const &f,\n\t                    Ts const &...ts) const {\n\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << 'n';\n\t}\n\tvoid print_with_sep(const std::string &) const { os << 'n'; }\n};\n\ntemplate <class... Ts> void pr(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print(ts...);\n}\ntemplate <class... Ts> void ps(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print_with_sep(\" \", ts...);\n}\n}  // namespace IO\n\ninline namespace Debug {\n\n#ifdef LOCAL\n#include \"helpers/debug.h\"\n\n#define chk(...) if (!(__VA_ARGS__)) cerr << \"033[41m\" << \"Line(\" << __LINE__ << \") -> function(\" \n\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"033[0m\" << \"n\", exit(0);\n\n#define MACRO(code) do {code} while (false)\n#define RAYA MACRO(cerr << \"033[101m\" << \"================================\" << \"033[0m\" << endl;)\n#else\n//? #define dbg(...)\n\n#define chk(...)\n//? #define RAYA\n#endif\n\nconst auto beg_time = std::chrono::high_resolution_clock::now();\n// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\ndouble time_elapsed() {\n\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\n\t                                beg_time)\n\t    .count();\n}\n}  // namespace Debug\n\n\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), \"r\", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), \"w\", stdout); }\nvoid setIO(str s = \"\") {\n\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\n\t//? cout << fixed << setprecision(12);\n    //? cerr << fixed << setprecision(12);\n\tcin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + \".in\"), setOut(s + \".out\");  // for old USACO\n}\n}  // namespace FileIO\n\n\n\n//? Custom Helpers\ntemplate <typename T>\ninline T gcd(T a, T b) { while (b != 0) swap(b, a %= b); return a; }\n\nlong long binpow(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = res * a;\n        a = a * a;\n        b >>= 1;\n    }\n    return res;\n}\n\nconst int dddx[8]{1, 0, -1,  0, 1,  1, -1, -1};\nconst int dddy[8]{0, 1,  0, -1, 1, -1,  1, -1};\n\nusing vvi = V<vi>;\nusing vvl = V<vl>;\nusing vvb = V<vb>;\n//? /Custom Helpers\n\n#define RAYA ps(\"================================\")\n\nconst string PAIR_LEFT = \"(\";\nconst string PAIR_RIGHT = \")\";\nconst string IT_LEFT = \"[\";\nconst string IT_RIGHT = \"]\";\nconst string PAIR_SEP = \", \";\nconst string IT_SEP = \", \";\n \n// const string PAIR_LEFT = \"(\";\n// const string PAIR_RIGHT = \")\";\n// const string IT_LEFT = \"[\";\n// const string IT_RIGHT = \"]\";\n// const string PAIR_SEP = \" \";\n// const string IT_SEP = \" \";\n \n// const string PAIR_LEFT = \"{\";\n// const string PAIR_RIGHT = \"}\";\n// const string IT_LEFT = \"{\";\n// const string IT_RIGHT = \"}\";\n// const string PAIR_SEP = \", \";\n// const string IT_SEP = \", \";\n \n// benq - print any container + pair\ntemplate<typename T, typename = void> struct is_iterable : false_type {};\ntemplate<typename T> struct is_iterable<T, void_t<decltype(begin(declval<T>())),decltype(end(declval<T>()))>> : true_type {};\ntemplate<typename T> typename enable_if<is_iterable<T>::value&&!is_same<T, string>::value,ostream&>::type operator<<(ostream &cout, T const &v);\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << PAIR_LEFT << p.f << PAIR_SEP << p.s << PAIR_RIGHT; }\ntemplate<typename T> typename enable_if<is_iterable<T>::value&&!is_same<T, string>::value,ostream&>::type operator<<(ostream &cout, T const &v) {\n    cout << IT_LEFT; \n    for (auto it = v.begin(); it != v.end();) {\n        cout << *it;\n        if (++it != v.end()) cout << IT_SEP;\n    }\n    return cout << IT_RIGHT;\n}\ntemplate<typename A, typename B> istream& operator>>(istream& cin, pair<A, B> &p) {\n    cin >> p.first;\n    return cin >> p.second;\n}\n \nvoid dbg_out() { cout << endl; }\ntemplate<typename Head, typename... Tail> \nvoid dbg_out(Head H, Tail... T) { cout << ' ' << H; dbg_out(T...); }\n#define dbg(...) cout << \"(\" << #__VA_ARGS__ << \"): \", dbg_out(__VA_ARGS__)\n\n//* Template\n//* /Template\n    \nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        //* dbg(l, r);\n\n        bool vis[10 + 1][2][2][81 + 1][81 + 1];\n        ll  memo[10 + 1][2][2][81 + 1][81 + 1];\n        \n        auto work = [&](ll modSum) -> ll {\n            auto pref = [&](ll x) -> ll {\n                vector<int> digits;\n                for(auto& c: ts(x)) \n                    digits.eb(int(c - '0'));\n                const int m = sz(digits);\n\n                memset(vis, false, sizeof(vis));\n                auto dp = [&](auto&& self, int i, bool lastWasDefined, bool reachedLower, int mod, int sum) -> ll {\n                    if(sum > modSum) return 0;\n                    if(i == m) {\n                        if(!lastWasDefined) return 0;\n                        if(sum == modSum && mod == 0) return 1;\n                        return 0;\n                    }                    \n\n                    if(vis[i][lastWasDefined][reachedLower][mod][sum]) return memo[i][lastWasDefined][reachedLower][mod][sum];\n                    vis[i][lastWasDefined][reachedLower][mod][sum] = true;\n                    \n                    ll ans = 0;\n                    if(!lastWasDefined) {\n                        ans += self(self, i + 1, lastWasDefined, reachedLower, mod, sum);\n\n                        if(i == 0) {\n                            for(int d = 1; d <= digits[i]; d++) {\n                                ans += self(self, i + 1, true, d < digits[i], (mod * d) % modSum, sum + d);\n                            }\n                        } else {\n                            for(int d = 1; d <= 9; d++) {\n                                ans += self(self, i + 1, true, true, (mod * d) % modSum, sum + d);\n                            }\n                        }\n                    } else {\n                        if(reachedLower) {\n                            for(int d = 0; d <= 9; d++) {\n                                ans += self(self, i + 1, true, true, (mod * d) % modSum, sum + d);\n                            }\n                        } else {\n                            for(int d = 0; d <= digits[i]; d++) {\n                                ans += self(self, i + 1, true, d < digits[i], (mod * d) % modSum, sum + d);\n                            }\n                        }\n                    }\n                    return memo[i][lastWasDefined][reachedLower][mod][sum] = ans;\n                };\n                ll res = dp(dp, 0, false, false, 1, 0);\n                return res;\n            };\n\n            ll left = pref(l - 1);\n            ll right = pref(r);\n            \n            ll res = right - left;\n            return res;\n        };\n        \n        ll response = 0;\n        for(ll sum = 1; sum <= 81; sum++) {\n            ll contrib = work(sum);\n            response += contrib;\n        }\n        \n        return response;\n    }\n};","author":"dhuamanilu","submissionId":"1575190936"},[]]},{"137":[{"id":"137","fileName":"1575191074.txt","sourceCode":"class Solution {\npublic:\n    int yh[1000][10];\n    int bh[8][5][3][3], shu[1000];\n    int fan[1000][4], B;\n    int f[2][90][400];\n    \n    void calc_bh_yh(){\n        int a, b, c, d, e, na, nb, nc, nd, i;\n        B = 0;\n        for (a = 0; a <= 7; ++a)\n            for (b = 0; b <= 4; ++b)\n                for (c = 0; c <= 2; ++c)\n                    for (d = 0; d <= 2; ++d){\n                        if (a == 7 && (b > 0 || c > 0 || d > 0))\n                            continue;\n                        bh[a][b][c][d] = B;\n                        fan[B][0] = a;\n                        fan[B][1] = b;\n                        fan[B][2] = c;\n                        fan[B][3] = d;\n                        if (a == 7) shu[B] = 0;\n                        else{\n                            shu[B] = 1;\n                            for (i = 0; i < a; ++i) shu[B] *= 2;\n                            for (i = 0; i < b; ++i) shu[B] *= 3;\n                            for (i = 0; i < c; ++i) shu[B] *= 5;\n                            for (i = 0; i < d; ++i) shu[B] *= 7;\n                        }\n                        ++B;\n                    }\n        \n        for (a = 0; a <= 7; ++a)\n            for (b = 0; b <= 4; ++b)\n                for (c = 0; c <= 2; ++c)\n                    for (d = 0; d <= 2; ++d){\n                        if (a == 7 && (b > 0 || c > 0 || d > 0))\n                            continue;\n                        for (e = 0; e < 10; ++e){\n                            if (a == 7 || e == 0){\n                                yh[bh[a][b][c][d]][e] = bh[7][0][0][0];\n                                continue;\n                            }\n                            na = a; nb = b; nc = c; nd = d;\n                            if (e == 2) ++na;\n                            if (e == 3) ++nb;\n                            if (e == 4) na += 2;\n                            if (e == 5) ++nc;\n                            if (e == 6){\n                                ++na;\n                                ++nb;\n                            }\n                            if (e == 7) ++nd;\n                            if (e == 8) na += 3;\n                            if (e == 9) nb += 2;\n                            na = min(na, 6);\n                            nb = min(nb, 4);\n                            nc = min(nc, 2);\n                            nd = min(nd, 2);\n                            yh[bh[a][b][c][d]][e] = bh[na][nb][nc][nd];\n                        }\n                    }\n    }\n\n    int dp(string S){\n        int i, j, k, s, r = 0, sum = 0, state = 0, L, old, now, top;\n        L = S.size();\n        top = L * 9;\n        for (int w = 0; w < L; ++w){\n            int c = S[w] - '0';\n            for (int q = 0; q < c; ++q){\n                if (w == 0 && q == 0) continue;\n                now = 0;\n                for (i = 0; i <= top; ++i)\n                    for (j = 0; j < B; ++j)\n                        f[now][i][j] = 0;\n                f[now][sum + q][yh[state][q]] = 1;\n                for (int o = w + 1; o < L; ++o){\n                    old = now; now = 1 - now;\n                    for (i = 0; i <= top; ++i)\n                        for (j = 0; j < B; ++j)\n                            f[now][i][j] = 0;\n                    for (i = 0; i <= top; ++i)\n                        for (j = 0; j < B; ++j)\n                            if (f[old][i][j] > 0){\n                                for (k = 0; k < 10; ++k)\n                                    f[now][i + k][yh[j][k]] += f[old][i][j];\n                            }\n                }\n                \n                for (i = 1; i <= top; ++i)\n                    for (j = 0; j < B; ++j)\n                        if (shu[j] % i == 0)\n                            r += f[now][i][j];\n            }\n            \n            sum += c;\n            state = yh[state][c];\n        }\n        \n        // n itself\n        if (shu[state] % sum == 0) ++r;\n        return r;\n    }\n    \n    int gao(int n){\n        if (n == 0) return 0;\n        string S = to_string(n);\n        int L = S.size(), r = 0, i, j;\n        r += dp(S);\n        for (i = 1; i < L; ++i){\n            S = \"\";\n            for (j = 0; j < i; ++j) S += \"9\";\n            r += dp(S);\n        }\n        \n        return r;\n    }\n    \n    int beautifulNumbers(int l, int r) {\n        calc_bh_yh();\n        // int i, j, q = 0, s, t, x, w = 0;\n        // for (i = l; i <= r; ++i){\n        //     x = i;\n        //     s = 0; t = 1;\n        //     while (x){\n        //         s += x % 10;\n        //         t *= x % 10;\n        //         x /= 10;\n        //     }\n        //     if (t % s == 0) ++w;\n        // }\n        // cout<<w<<endl;\n        return gao(r) - gao(l - 1);\n    }\n};","author":"Ma Lin","submissionId":"1575191074"},[]]},{"138":[{"id":"138","fileName":"1575188681.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_beautiful(X: int) -> int:\n            if X < 0:\n                return 0\n            s = str(X)\n            n = len(s)\n            from functools import lru_cache\n\n            @lru_cache(maxsize=None)\n            def dp(pos, tight, started, prod, summ):\n                if pos == n:\n                    return 1 if (started and summ > 0 and prod % summ == 0) else 0\n                res = 0\n                limit = int(s[pos]) if tight else 9\n                for d in range(limit + 1):\n                    ntight = tight and (d == limit)\n                    if not started:\n                        if d == 0:\n                            res += dp(pos + 1, ntight, False, 1, 0)\n                        else:\n                            res += dp(pos + 1, ntight, True, d, d)\n                    else:\n                        new_prod = prod * d if d != 0 else 0\n                        res += dp(pos + 1, ntight, True, new_prod, summ + d)\n                return res\n\n            return dp(0, True, False, 1, 0)\n\n        return count_beautiful(r) - count_beautiful(l - 1)\n","author":"akshita_mb","submissionId":"1575188681"},[]]},{"139":[{"id":"139","fileName":"1575189055.txt","sourceCode":"public class Solution {\n    public int BeautifulNumbers(int l, int r) {\n                return GetValue(r) - GetValue(l - 1);\n}\n\npublic static int GetValue(int n)\n{\n    if (n == 0) return 0;\n    var digits = GetDigits(n);\n    var memo = new Dictionary<(int, bool, int, int, bool), int>();\n\n    return Dp(0, true, 0, 1, false, digits, memo);\n}\n\npublic static int Dp(int pos, bool tight, int digitSum, int digitProduct, bool hasNonZero, List<int> digits, Dictionary<(int, bool, int, int, bool), int> dp)\n{\n    if (pos == digits.Count)\n    {\n        return hasNonZero && digitSum > 0 && digitProduct % digitSum == 0 ? 1 : 0;\n    }            \n\n    var key = (pos, tight, digitSum, digitProduct, hasNonZero);\n    if (dp.ContainsKey(key))\n    {\n        return dp[key];\n    }            \n\n    int limit = tight ? digits[pos] : 9;\n    int total = 0;\n\n    for (int d = 0; d <= limit; d++)\n    {\n        int newSum = digitSum + d;\n        int newProduct = hasNonZero ? digitProduct * d : d;\n        total += Dp(pos + 1, tight && (d == limit), newSum, newProduct, hasNonZero || d > 0, digits, dp);\n    }\n\n    return dp[key] = total;\n}\n\npublic static List<int> GetDigits(int n)\n{\n    var digits = new List<int>();\n    while (n > 0)\n    {\n        digits.Add(n % 10);\n        n /= 10;\n    }\n    digits.Reverse();\n    return digits;\n}\n}","author":"leducthinh55","submissionId":"1575189055"},[]]},{"140":[{"id":"140","fileName":"1575192894.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_beautiful_upto(x):\n            digits = list(map(int, str(x)))\n            n = len(digits)\n\n            @lru_cache(None)\n            def recurse(pos, is_tight, started, total, product):\n                if pos == n:\n                    if not started:\n                        return 0\n\n                    return 1 if product % total == 0 else 0\n                \n                limit = digits[pos] if is_tight else 9\n                current_total = 0\n                \n                for d in range(0, limit + 1):\n                    new_is_tight = is_tight and (d == limit)\n                    \n                    if not started:\n                        if d == 0:\n                            current_total += recurse(pos + 1, new_is_tight, False, 0, 1)\n                        else:\n                            current_total += recurse(pos + 1, new_is_tight, True, d, d)\n                    else:\n                        current_total += recurse(pos + 1, new_is_tight, True, total + d, product * d)\n                \n                return current_total\n            \n            return recurse(0, True, False, 0, 1)\n        \n        return count_beautiful_upto(r) - count_beautiful_upto(l - 1)\n        ","author":"Suraj Suryawanshi","submissionId":"1575192894"},[]]},{"141":[{"id":"141","fileName":"1575192460.txt","sourceCode":"int dp[11][2][2][82][82][2];\nclass Solution\n{\nprivate:\n    int solve(int i, int &n, int value, int current, int low, int high, int zero, string &L, string &R, int &sum)\n    {\n        if (i == n)\n            return value == 0 and current == sum;\n        if (dp[i][low][high][value][current][zero] != -1)\n            return dp[i][low][high][value][current][zero];\n        int lower = 0, higher = 9, ans = 0;\n        if (low)\n            lower = L[i] - '0';\n        if (high)\n            higher = R[i] - '0';\n        for (int d = lower; d <= higher; d++)\n        {\n            int new_low = low and d == lower ? 1 : 0, new_high = high and d == higher ? 1 : 0, new_zero = zero and !d ? 1 : 0;\n            int new_current = zero and d == 0 ? current : current + d;\n            if (new_current > sum)\n                continue;\n            int new_value;\n            if (zero and d == 0)\n                new_value = value;\n            else if (zero and d != 0)\n                new_value = d % sum;\n            else\n                new_value = (value * d) % sum;\n            ans += solve(i + 1, n, new_value, new_current, new_low, new_high, new_zero, L, R, sum);\n        }\n        return dp[i][low][high][value][current][zero] = ans;\n    }\n\npublic:\n    int beautifulNumbers(int l, int r)\n    {\n        ios::sync_with_stdio(false);\n        cin.tie(nullptr);\n        cout.tie(nullptr);\n\n        string L = to_string(l),R = to_string(r);\n        reverse(L.begin(), L.end());\n        while (L.size() < R.size())\n            L += '0';\n        reverse(L.begin(), L.end());\n        int ans = 0, n = L.size();\n        for (int sum = 1; sum <= 9 * n; sum++)\n        {\n            for(int i = 0; i < n; i++)\n                for(int j = 0; j < 2; j++)\n                    for(int k = 0; k < 2; k++)\n                        for(int x = 0; x <= sum; x++)\n                            for(int y = 0; y <= sum; y++)\n                                for(int z = 0; z < 2; z++)\n                                    dp[i][j][k][x][y][z] = -1;\n            ans += solve(0, n, 1, 0, 1, 1, 1, L, R, sum);\n        }\n        return ans;\n    }\n};","author":"Suvendu Dalbehera","submissionId":"1575192460"},[]]},{"142":[{"id":"142","fileName":"1575194074.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_beautiful_up_to(X: int) -> int:\n            if X <= 0:\n                return 0\n            digits = tuple(map(int, str(X)))\n            n = len(digits)\n            pf = {\n                1: (0, 0, 0, 0),\n                2: (1, 0, 0, 0),\n                3: (0, 1, 0, 0),\n                4: (2, 0, 0, 0),\n                5: (0, 0, 1, 0),\n                6: (1, 1, 0, 0),\n                7: (0, 0, 0, 1),\n                8: (3, 0, 0, 0),\n                9: (0, 2, 0, 0)\n            }\n            @lru_cache(maxsize=None)\n            def dpA(pos: int, tight: bool, started: bool, found: bool) -> int:\n                if pos == n:\n                    return 1 if (started and found) else 0\n                res = 0\n                limit = digits[pos] if tight else 9\n                for d in range(0, limit + 1):\n                    new_tight = tight and (d == limit)\n                    if not started:\n                        if d == 0:\n                            res += dpA(pos + 1, new_tight, False, found)\n                        else:\n                            res += dpA(pos + 1, new_tight, True, found)\n                    else:\n                        res += dpA(pos + 1, new_tight, True, found or (d == 0))\n                return res\n            @lru_cache(maxsize=None)\n            def dpB(pos: int, tight: bool, started: bool, s: int, a2: int, a3: int, a5: int, a7: int) -> int:\n                if pos == n:\n                    if not started:\n                        return 0\n                    product = (2 ** a2) * (3 ** a3) * (5 ** a5) * (7 ** a7)\n                    return 1 if (s != 0 and product % s == 0) else 0\n                res = 0\n                limit = digits[pos] if tight else 9\n                for d in range(0, limit + 1):\n                    new_tight = tight and (d == limit)\n                    if not started:\n                        if d == 0:\n                            res += dpB(pos + 1, new_tight, False, s, a2, a3, a5, a7)\n                        else:\n                            da2, da3, da5, da7 = pf[d]\n                            res += dpB(pos + 1, new_tight, True, s + d, a2 + da2, a3 + da3, a5 + da5, a7 + da7)\n                    else:\n                        if d == 0:\n                            continue\n                        da2, da3, da5, da7 = pf[d]\n                        res += dpB(pos + 1, new_tight, True, s + d, a2 + da2, a3 + da3, a5 + da5, a7 + da7)\n                return res\n            return dpA(0, True, False, False) + dpB(0, True, False, 0, 0, 0, 0, 0)\n        return count_beautiful_up_to(r) - count_beautiful_up_to(l - 1)","author":"Swagata Chaudhuri","submissionId":"1575194074"},[]]},{"144":[{"id":"144","fileName":"1575194541.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def f(r):\n            if r < 0:\n                return 0\n            s = str(r)\n            @lru_cache(None)\n            def go(i, tight, started, su, prod):\n                if i == len(s):\n                    if not started:\n                        return 0\n                    return 1 if prod % su == 0 else 0\n                limit = int(s[i]) if tight else 9\n                ans = 0\n                for d in range(limit + 1):\n                    ntight = tight and (d == limit)\n                    if not started and d == 0:\n                        ans += go(i + 1, ntight, False, 0, 1)\n                    else:\n                        ans += go(i + 1, ntight, True, su + d, prod * d)\n                return ans\n            result = go(0, True, False, 0, 1)\n            go.cache_clear()  \n            return result\n        return f(r) - f(l - 1)\n","author":"Sasank Nasika","submissionId":"1575194541"},[]]},{"145":[{"id":"145","fileName":"1575194762.txt","sourceCode":"using ll = long long;\n\nbool did_precomp = false;\n\nvector<pair<int,array<int,10>>> goods;\nint cnt[10];\nvoid rec(int i, int rem) {\n    if (i == 10) {\n        if (rem != 0) return;\n        ll sumd = 0;\n        ll prodd = 1;\n        for (int i = 0; i < 10; ++i) {\n            for (int j = 0; j < cnt[i]; ++j) {\n                sumd +=(ll) i;\n                prodd *= (ll)i;\n            }\n        }\n        if (sumd != 0 && prodd % sumd == 0) {\n            array<int,10> arr;\n            int tot = 0;\n            for (int i = 0; i < 10; ++i) {\n                arr[i] = cnt[i];\n                tot += cnt[i];\n            }\n            goods.push_back({tot,arr});\n        }\n        return;\n    }\n    for (int give = 0; give <= rem; ++give) {\n        cnt[i] = give;\n        rec(i+1, rem-give);\n    }\n}\n\n\nint fac[15];\n\nvoid precomp() {\n    if (did_precomp) return;\n    did_precomp = true;\n    for (int len = 1; len <= 9; ++len) {\n        memset(cnt, 0, sizeof cnt);\n        rec(0, len);\n    }\n    fac[0] = 1;\n    for (int i = 1; i < 10; ++i) fac[i] = fac[i-1] * i;\n}\n\n\n\nint perm(const array<int,10>& a) {\n    int tot = 0;\n    for (int n : a) tot += n;\n    int ret = fac[tot];\n    for (int n : a) ret /= fac[n];\n    return ret;\n}\n\nint f(int n) {\n    int ans = 0;\n    string s = to_string(n);\n    int N = s.size();\n    for (auto [len, cnts] : goods) {\n        if (len < N) {\n            for (int d = 1; d < 10; ++d) {\n                if (cnts[d]) {\n                    --cnts[d];\n                    ans += perm(cnts);\n                    ++cnts[d];\n                }\n            }\n        } else if (len > N) {\n            \n        } else {\n            auto rec = [&](auto&& self, int i) -> void {\n                if (i == N) {\n                    ++ans;\n                    return;\n                }\n                int start = 0;\n                if (i == 0) start = 1;\n                for (int d = start; d < s[i]-'0'; ++d) {\n                    if (cnts[d]) {\n                        --cnts[d];\n                        ans += perm(cnts);\n                        ++cnts[d];\n                    }\n                }\n                int d = s[i]-'0';\n                if (cnts[d]) {\n                    --cnts[d];\n                    self(self, i+1);\n                    ++cnts[d];\n                }\n            };\n            rec(rec, 0);\n        }\n    }\n\n    \n    return ans;\n}\n\n\nint slow(int n, bool print =false) {\n    int ans =0;\n    for (int i = 0; i <= n; ++i) {\n        string s = to_string(i);\n        int sumd = 0, prodd = 1;\n        for (char c : s) {\n            int d = c-'0';\n            sumd += d;\n            prodd *= d;\n        }\n        if (sumd > 0 && prodd % sumd == 0) {\n            ++ans;\n            if (print) cout << \"good: \" << s << 'n';\n        }\n    }\n    return ans;\n    \n}\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        precomp();\n        /*slow(105, true);\n        for (int i = 0; i < 1000; ++i) {\n            if (f(i) != slow(i)) {\n                cout << i << ' ' << f(i) << ' ' << slow(i) << 'n';\n            }\n        }*/\n        return f(r)-f(l-1);\n    }\n};","author":"SirTechnical","submissionId":"1575194762"},[]]},{"146":[{"id":"146","fileName":"1575192586.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n \nstruct Node {\n    int idx, lim, flag, zero, s, p;\n    bool operator==(const Node &o) const {\n        return idx == o.idx && lim == o.lim && flag == o.flag && zero == o.zero && s == o.s && p == o.p;\n    }\n};\n \nstruct NodeHash {\n    size_t operator()(const Node &n) const {\n        size_t a = hash<int>()(n.idx);\n        size_t b = hash<int>()(n.lim);\n        size_t c = hash<int>()(n.flag);\n        size_t d = hash<int>()(n.zero);\n        size_t e = hash<int>()(n.s);\n        size_t f = hash<int>()(n.p);\n        return (((((a * 31 + b) * 31 + c) * 31 + d) * 31 + e) * 31 + f);\n    }\n};\n \nclass Solution {\npublic:\n    using ll = long long;\n    unordered_map<Node, ll, NodeHash> cache;\n    \n    ll rec(string &num, int idx, int lim, int flag, int zero, int s, int p) {\n        if (idx == num.size()) {\n            if (!flag) return 0;\n            if (zero) return 1;\n            return (p % s == 0) ? 1 : 0;\n        }\n        Node node {idx, lim, flag, zero, s, p};\n        if(cache.count(node)) return cache[node];\n        int hi = (lim ? (num[idx]-'0') : 9);\n        ll ret = 0;\n        for (int d = 0; d <= hi; d++){\n            int nlim = lim && (d == hi);\n            int nflag = flag;\n            int nzero = zero;\n            int ns = s;\n            int np = p;\n            if (!flag && d == 0){\n                ret += rec(num, idx+1, nlim, 0, 0, 0, 1);\n            } else {\n                nflag = 1;\n                if (d == 0){\n                    nzero = 1;\n                    np = 0;\n                    ns += 0;\n                } else {\n                    if (!nzero){\n                        ns += d;\n                        np *= d;\n                    }\n                }\n                ret += rec(num, idx+1, nlim, nflag, nzero, ns, np);\n            }\n        }\n        cache[node] = ret;\n        return ret;\n    }\n    \n    long long countUpTo(int n) {\n        string s = to_string(n);\n        cache.clear();\n        return rec(s, 0, 1, 0, 0, 0, 1);\n    }\n    \n    int beautifulNumbers(int l, int r) {\n        return (int)(countUpTo(r) - countUpTo(l-1));\n    }\n};\n","author":"wckiipi","submissionId":"1575192586"},[]]},{"147":[{"id":"147","fileName":"1575194710.txt","sourceCode":"import java.util.HashMap;\n\nclass Solution {\n    private HashMap<String, Integer> memo;\n\n    public int beautifulNumbers(int l, int r) {\n        return countBeautifulNumbers(r) - countBeautifulNumbers(l - 1);\n    }\n\n    private int countBeautifulNumbers(int num) {\n        char[] digits = String.valueOf(num).toCharArray();\n        memo = new HashMap<>();\n        return digitDP(0, 1, 0, 1, true, digits);\n    }\n\n    private int digitDP(int pos, int tight, int sum, int product, boolean isLeadingZero, char[] digits) {\n        if (pos == digits.length)\n            return sum > 0 && product % sum == 0 ? 1 : 0;\n\n        String key = pos + \",\" + tight + \",\" + sum + \",\" + product + \",\" + isLeadingZero;\n        if (memo.containsKey(key))\n            return memo.get(key);\n\n        int limit = tight == 1 ? digits[pos] - '0' : 9;\n        int result = 0;\n\n        for (int d = 0; d <= limit; d++) {\n            result += digitDP(\n                pos + 1, \n                (tight == 1 && d == limit) ? 1 : 0, \n                sum + d, \n                (isLeadingZero && d == 0) ? 1 : product * d, \n                isLeadingZero && d == 0, \n                digits\n            );\n        }\n\n        memo.put(key, result);\n        return result;\n    }\n}\n","author":"Nnssprasad","submissionId":"1575194710"},[]]},{"149":[{"id":"149","fileName":"1575194809.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        range_input = [l, r]\n        count_r = self.count_up_to(r)\n        count_l_minus = self.count_up_to(l - 1)\n        return int(count_r - count_l_minus)\n\n    def count_up_to(self, n: int) -> int:\n        if n < 1:\n            return 0\n        digits = list(str(n))\n        memo = {}\n        return self.dp(0, True, False, 0, 1, digits, memo)\n\n    def dp(self, pos: int, tight: bool, started: bool, current_sum: int, current_prod: int, digits: list, memo: dict) -> int:\n        if pos == len(digits):\n            if started and current_sum > 0 and current_prod % current_sum == 0:\n                return 1\n            return 0\n\n        key = f\"{pos},{1 if tight else 0},{1 if started else 0},{current_sum},{current_prod}\"\n        if key in memo:\n            return memo[key]\n\n        limit = int(digits[pos]) if tight else 9\n        result = 0\n        for d in range(0, limit + 1):\n            next_tight = tight and (d == limit)\n            new_started = started or (d != 0)\n            new_sum = current_sum\n            new_prod = current_prod\n            if new_started:\n                if not started:\n                    new_sum = d\n                    new_prod = d\n                else:\n                    new_sum = current_sum + d\n                    new_prod = current_prod * d\n            result += self.dp(pos + 1, next_tight, new_started, new_sum, new_prod, digits, memo)\n        memo[key] = result\n        return result\n        ","author":"Ragul","submissionId":"1575194809"},[]]},{"150":[{"id":"150","fileName":"1575195654.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_beautiful(n):\n            digits = list(map(int, str(n)))\n            length = len(digits)\n\n            @lru_cache(None)\n            def dp(pos, tight, digit_sum, digit_prod, leading_zero):\n                if pos == length:\n                    return 1 if digit_sum > 0 and digit_prod % digit_sum == 0 else 0\n\n                limit = digits[pos] if tight else 9\n                count = 0\n\n                for d in range(0, limit + 1):\n                    new_sum = digit_sum + d\n                    new_prod = digit_prod if d == 0 and leading_zero else digit_prod * d\n                    count += dp(pos + 1, tight and (d == limit), new_sum, new_prod, leading_zero and d == 0)\n\n                return count\n\n            return dp(0, True, 0, 1, True)\n\n        return count_beautiful(r) - count_beautiful(l - 1)","author":"madugulalikki8","submissionId":"1575195654"},[]]},{"151":[{"id":"151","fileName":"1575196106.txt","sourceCode":"class Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        return calc(r+1) - calc(l);\n    }\n    int calc(int n) {\n        int x = n;\n        vector<int> digits;\n        while (x > 0) {\n            digits.push_back(x % 10);\n            x /= 10;\n        }\n        reverse(digits.begin(), digits.end());\n\n        int cnt = 0;\n        memo.clear();\n\n        // num digits < n\n        for (int nd = digits.size()-1; nd >= 1; nd--) {\n            for (int i = 1; i <= 9; i++) {\n                cnt += backtrack(i, i, nd-1);\n            }\n        }\n\n        // matching first few digits\n        for (int match = 0; match < digits.size(); match++) {\n            int sum = 0, product = 1;\n            for (int i = 0; i < match; i++) {\n                sum += digits[i];\n                product *= digits[i];\n            }\n            for (int i = 0; i < digits[match]; i++) {\n                if (match == 0 && i == 0) continue;\n                cnt += backtrack(product * i, sum + i, digits.size() - match - 1);\n            }\n        }\n\n        return cnt;\n    }\n\n    int backtrack(int product, int sum, int ndigits) {\n        long long hash = 1000LL * product + 10LL * sum + ndigits;\n        if (memo.count(hash)) {\n            return memo[hash];\n        }\n        // printf(\"backtrack(product=%d, sum=%d, nd=%d)n\", product, sum, ndigits);\n        if (ndigits == 0) {\n            if (product % sum == 0) {\n                return memo[hash] = 1;\n            }\n            return memo[hash] = 0;\n        }\n        if (product == 0) {\n            int p = 1;\n            for (int i = 0; i < ndigits; i++) {\n                p *= 10;\n            }\n            return memo[hash] = p;\n        }\n        int cnt = 0;\n        for (int i = 0; i <= 9; i++) {\n            cnt += backtrack(product * i, sum + i, ndigits-1);\n        }\n        return memo[hash] = cnt;\n    }\n\n    map<long long,int> memo;\n};\n","author":"Ahmad Zaky","submissionId":"1575196106"},[]]},{"152":[{"id":"152","fileName":"1575197239.txt","sourceCode":"from functools import cache\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        nums = [[int(x) for x in str(l - 1)], [int(x) for x in str(r)]]\n        @cache\n        def solve(i, sums, prod, upper, edge, all_zero):\n            if i < 0: return int(prod % sums == 0) if sums != 0 else 0\n            res = 0\n            digit = nums[upper][-i - 1]\n            if all_zero:\n                res += solve(i - 1, sums, prod, upper, edge and digit == 0, True)\n            if edge:\n                if not (all_zero and digit == 0):\n                    res += solve(i - 1, sums + digit, prod * digit, upper, True, False)\n                for j in range(int(all_zero), digit):\n                    res += solve(i - 1, sums + j, prod * j, upper, False, False)\n            else:\n                for j in range(int(all_zero), 10):\n                    res += solve(i - 1, sums + j, prod * j, upper, False, False)\n            return res\n        def get(num): return solve(len(nums[num]) - 1, 0, 1, num, True, True)\n        # print(get(1), get(0))\n        return get(1) - get(0)\n# print(Solution().beautifulNumbers(20, 100))","author":"LouisCheng","submissionId":"1575197239"},[]]},{"153":[{"id":"153","fileName":"1575197544.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n\n        def resolve(x):\n            num = str(x)\n            @cache\n            def dfs(i: int, isLimit: bool, isNum: bool, p, s) -> int:\n                if i == len(num):\n                    return isNum and p % s == 0\n\n                ans = 0\n                if not isNum:\n                    ans = dfs(i+1, False, False, 1, 0)\n\n                low = 0 if isNum else 1\n                high = int(num[i]) if isLimit else 9\n                for d in range(low, high+1):\n                    ans += dfs(i+1, isLimit and d == high, True, p * d, s + d)\n                return ans\n\n            return dfs(0, True, False, 1, 0)\n\n        return resolve(r) - resolve(l-1)\n                    ","author":"Chen Jian","submissionId":"1575197544"},[]]},{"154":[{"id":"154","fileName":"1575196419.txt","sourceCode":"\n#ifdef LOCAL_RUN\n#include \"debug_leet.h\"\n    #else\n    #define trace(...) ;\n    #define dbg(...) ;\n    #define dbgc(...) ;\n    #define debug(x) ;\n    #define debuga(a, n) ;\n    #define debug2(x, y) ;\n    #define debug3(x, y, z) ;\n    #define debug4(x, y, z, w) ;\n    #define debug5(a,b,c,d,e) ;\n    #define lassert(x) ;\n    #define dassert(x, ...) ;\n    int recur_depth = 0; bool rec_indent = true;\n    const bool isLocal = false;\n    template <typename Arg, typename... Args>\n    void display(TreeNode* root) {}\n    #endif\n\n    #define pb push_back\n    #define eb emplace_back\n    #define popb pop_back\n    #define all(v) begin(v), end(v)\n    #define rall(v) (v).rbegin(),(v).rend()\n    #define make_unique(v) (v).erase(unique(all(v)), (v).end())\n    #define sz(c) ((int) c.size())\n    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)\n    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)\n    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)\n    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)\n    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n    #define mem(a,b) memset(a,b,sizeof(a))\n    #define abs(x) (((x) < 0) ? -(x) : (x))\n    #define sqr(x) ((x) * (x))\n    #define sqrt(x) sqrt(abs(x))\n    #define has(c,x) (c.find(x) != c.end())\n    #define pw(x) (1LL << (x))\n    #define ibit(x,i) (((x) >> (i)) & 1)\n    #define data(v) v.data(), sz(v) // vi -> vai\n    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)\n\n    typedef stringstream sstr;\n    typedef long long ll;\n    typedef long double ld;\n    typedef pair<int, int> pii;\n    typedef pair<ll,ll> pll;\n    typedef pair<ld,ld> pdd;\n    typedef vector<int> vi;\n    typedef vector<ll> vll;\n    typedef vector<pii> vpii;\n    typedef vector<vi> vvi;\n    typedef vector<vll> vvll;\n    typedef valarray<int> vai;\n    template <class T>\n    using min_pq = priority_queue<T, vector<T>, greater<T>>;\n    template <class T>\n    using vc = vector<T>;\n    template <class T>\n    using vvc = vector<vc<T>>;\n    template <class T>\n    using vvvc = vector<vvc<T>>;\n    template <class T>\n    using vvvvc = vector<vvvc<T>>;\n    template <class T>\n    using vvvvvc = vector<vvvvc<T>>;\n\n    template<class F>\n    struct y_comb{\n        F f;\n        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }\n        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }\n    };\n    template<class F>\n    decltype(auto) yf(F &&f){\n        return y_comb<decay_t<F>>(forward<F>(f));\n    }\n\n    inline int ni(){ int x; cin >> x;   return x; }\n    inline ll  nl() { ll  x; cin >> x; return x; }\n\n    template <class T> void mmin(T& a, const T& b) {\n        a = (a) < (b) ? (a) : (b);\n    }\n    template <class T> void mmax(T& a, const T& b) {\n        a = (a) > (b) ? (a) : (b);\n    }\n    template <class T> int LB(vc<T> &a, T x){\n        return int(lower_bound(all(a), x) - a.begin());\n    }\n    template <class T> int UB(vc<T> &a, T x){\n        return int(upper_bound(all(a), x) - a.begin());\n    }\n    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){\n        if(r < 0) r = sz(a);\n        return *max_element(a.begin()+l, a.begin()+r);\n    }\n    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){\n        if(r < 0) r = sz(a);\n        return *min_element(a.begin()+l, a.begin()+r);\n    }\n    template <class T> auto vv(int d1, T x){\n        return vc<T>(d1, x);\n    }\n    template <class T> auto vv(int d1, int d2, T x){\n        return vc<vc<T>>(d1, vc<T>(d2, x));\n    }\n    template <class T> auto vv(int d1, int d2, int d3, T x){\n        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));\n    }\n    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){\n        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));\n    }\n    template <class T> auto vv(int d1, int d2, int d3, int d4, int d5, T x){\n        return vc<vc<vc<vc<vc<T>>>>>(d1, vv(d2, d3, d4, d5, x));\n    }   \n    void outv(auto &v){\n        for(auto &x: v) {cout<< x <<\" \";} cout<<endl;\n    }\n    void rvec(int &n, auto &v){\n        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);\n    }\n    template <typename Arg, typename... Args>\n    void read(Arg&& arg, Args&&... args){\n        cin >> std::forward<Arg>(arg); using expander = int[];\n        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};\n    }\n    template <typename Arg, typename... Args>\n    void out(Arg&& arg, Args&&... args){\n        cout << std::forward<Arg>(arg); using expander = int[];\n        (void)expander{0, (void(cout << \" \" << std::forward<Args>(args)),0)...};\n        cout << endl;\n    }\n    namespace tuple_utils{\n        template<class ...Ts, size_t ...Is>\n        ostream& println_tuple_impl(ostream& os, tuple<Ts...> tuple, index_sequence<Is...>){\n            static_assert(sizeof...(Is)==sizeof...(Ts),\"Indices must have same number of elements as tuple types!\");\n            static_assert(sizeof...(Ts)>0, \"Cannot insert empty tuple into stream.\");\n            auto last = sizeof...(Ts) - 1; // assuming index sequence 0,...,N-1\n            return ((os << get<Is>(tuple) << (Is != last ? \", \" : \")\")),...);\n        }\n    }\n    template<class ...Ts> ostream& operator<<(ostream& os, const tuple<Ts...> & tuple) {\n        os << \"(\";\n        return tuple_utils::println_tuple_impl(os, tuple, index_sequence_for<Ts...>{});\n    }\n    template <class Integer, class F>\n    Integer find_first_false(Integer l, Integer r, F&& f) {\n        --l; // ++r;\n        while (r - l > 1) {\n            Integer m = midpoint(l, r);\n            if (f(m)) l = m;\n            else r = m;\n        }\n        return r;\n    }\n    template <class Integer, class F>\n    Integer find_last_true(Integer l, Integer r, F &&f) {\n        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;\n    }\n    template <class Integer, class F>\n    Integer find_first_true(Integer l, Integer r, F &&f) {\n        return find_first_false(l, r, [&f](Integer i) { return !f(i); });\n    }\n    template <class T, class F>\n    T last_true(T lo, T hi, F&& f) { \n        lo--; // if all are false, return lo-1\n        while(lo < hi){\n            T mid = lo + (hi - lo + 1) / 2;\n            if(f(mid)) lo = mid; \n            else hi = mid - 1;\n        }\n        return lo;\n    }\n    template <class T, class F>\n    T first_true(T lo, T hi, F&& f) { \n        // return last_true(lo, hi, [&](T x){ return !f(x); }) + 1;\n        hi++; // if all are false, return hi+1\n        while(lo < hi){\n            T mid = lo + (hi - lo) / 2;\n            if(f(mid)) hi = mid; \n            else lo = mid + 1;\n        }\n        return lo;\n    }\n    auto init = []() {\n        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';\n    }();\n\n    ll pwr(ll base, ll p, ll mod){\n        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;\n            base=(base*base)%mod; p/=2;}\n        return ans;\n    }\n    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }\n    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }\n\n    const long double PI = (long double)(3.1415926535897932384626433832795);\n    const ll  mx_ll   = numeric_limits<ll> :: max();\n    const int mx_int  = numeric_limits<int> :: max();\n\n    const int oo = 0x3f3f3f3f;\n    const ll  OO = 0x3f3f3f3f3f3f3f3fll;\n    const double eps = 1e-9;\n    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};\n    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};\n\nconst int maxn = 1e5 + 3;\nconst int mod = 1e9+7;\nint dp[2][2][11][100][100];\n\nclass Solution {\npublic:\n    vi digs(int N){\n        vi a;\n        for(int x=N; x; x/=10) a.pb(x%10);\n        reverse(all(a));\n        return a;\n    }\n    vi p10 = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};\n\n    int solve(int N, int sum){\n        if(N == 0) return 0;\n        // if(binary_search(all(p10), N)) return 1 + solve(N-1, sum);\n        vi a = digs(N);\n        int n = sz(a);\n        // auto dp = vv(2, 2, n, sum, sum+1, -1);\n        mem(dp, -1);   \n        auto go = yf([&](auto f, int zero, int same, int i, int prod, int now) -> int {\n            if(now > sum) return 0;\n            if(i == n) return 1 && prod == 0 && now == sum;\n            int hi = same ? a[i] : 9;\n            auto &ans = dp[zero][same][i][prod][now]; if(ans != -1) return ans;\n            ans = 0;\n            forn(d, hi+1) {\n                int nzero = zero && d == 0;\n                int nsame = same && d == a[i];\n                int nprod = nzero ? 1%sum : (prod * d) % sum;\n                int nsum = now + d;\n                if(nsum <= sum)\n                    ans += f(nzero, nsame, i+1, nprod, nsum);\n            }\n            return ans;\n        }); \n        int ans = go(1, 1, 0, 1%sum, 0);\n        debug4(N, a, sum, ans);\n        return ans;\n    }\n    int beautifulNumbers(int L, int R) {\n        int ans = 0;\n        vi a = digs(R);\n        int hi = 9 * sz(a) + 1;\n        fornn(sum, 1, hi) {\n            ans += solve(R, sum) - solve(L-1, sum);\n        }\n        return ans;\n        // return solve(R) - solve(L-1);\n    }\n};\n\n#ifdef LOCAL_RUN\nvoid _solve(){\n    Solution sol;\n    int l, r; cin >> l >> r;\n    out(sol.beautifulNumbers(l, r));\n}\n\n\n/*************************************************************************/\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    //cout.precision(15);\n    // return 0;\n    while(cin.peek() == 32 or cin.peek() == 10) cin.get();\n    while(cin.peek() != EOF){\n        _solve();\n        while(cin.peek() == 32 or cin.peek() == 10) cin.get();\n    }\n}\n#endif\n","author":"Jose Coves","submissionId":"1575196419"},[]]},{"155":[{"id":"155","fileName":"1575198115.txt","sourceCode":"from functools import lru_cache\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return self.countBeautiful(r) - self.countBeautiful(l - 1)\n\n    def countBeautiful(self, num: int) -> int:\n        if num == 0:\n            return 0\n\n        digits = list(map(int, str(num))) \n\n        @lru_cache(None)\n        def digitDP(pos: int, sum_: int, product: int, tight: bool, leading_zero: bool) -> int:\n            if pos == len(digits):\n                return 1 if sum_ > 0 and product % sum_ == 0 else 0\n\n            limit = digits[pos] if tight else 9\n            result = 0\n\n            for d in range(0, limit + 1):\n                new_leading_zero = leading_zero and (d == 0)\n                new_sum = sum_ if new_leading_zero else sum_ + d\n                new_product = product if new_leading_zero else product * d\n\n                result += digitDP(\n                    pos + 1,\n                    new_sum,\n                    new_product,\n                    tight and (d == limit),\n                    new_leading_zero\n                )\n\n            return result\n\n        return digitDP(0, 0, 1, True, True)\n","author":"cl3424","submissionId":"1575198115"},[]]},{"156":[{"id":"156","fileName":"1575196335.txt","sourceCode":"from typing import List\nfrom collections import defaultdict\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        \n        def count(v):\n            x = str(v)\n            n = len(x)\n            dp = defaultdict(int)\n            dp[(0, 1, 0)] = 1\n            for i in range(n):\n                d = int(x[i])\n                ndp = defaultdict(int)\n                for key in dp:\n                    s, p, f = key\n                    if f==1:\n                        for j in range(10):\n                            if s==0 and j==0:\n                                nkey = (0, 1, 1)\n                                ndp[nkey] += dp[key]\n                            else:\n                                nf = 1\n                                nkey = (s+j, p*j, nf)\n                                ndp[nkey] += dp[key]\n                    else:\n                        for j in range(d+1):\n                            if s==0 and j==0:\n                                nkey = (0, 1, 1)\n                                ndp[nkey] += dp[key]\n                            else:\n                                if f==1:\n                                    nf = 1\n                                else:\n                                    nf = 1 if j<d else 0\n                                nkey = (s+j, p*j, nf)\n                                ndp[nkey] += dp[key]\n                dp = ndp\n                #print(dp)\n            ret = 0\n            for key in dp:\n                s, p, f = key\n                if s==0:\n                    continue\n                if p%s==0:\n                    ret += dp[key]\n            return ret\n        \n        #print(count(r))\n        #print(count(l-1))\n        return count(r)-count(l-1)","author":"miya145592","submissionId":"1575196335"},[]]},{"157":[{"id":"157","fileName":"1575197270.txt","sourceCode":"class Solution {\npublic:\n    unordered_map<int, unordered_map<int, unordered_map<int, int>>> dp;\n    vector<int> digits;\n\n    // 递归计算数位 DP\n    int dfs(int pos, int sum_digits, int prod_digits, bool limit, bool leading_zero) {\n        if (pos == digits.size()) \n            return sum_digits > 0 && prod_digits % sum_digits == 0;\n\n        if (!limit && !leading_zero && dp[pos][sum_digits].count(prod_digits)) \n            return dp[pos][sum_digits][prod_digits];\n\n        int upper = limit ? digits[pos] : 9;\n        int res = 0;\n\n        for (int d = 0; d <= upper; ++d) {\n            res += dfs(pos + 1, \n                       sum_digits + d, \n                       leading_zero && d == 0 ? 1 : prod_digits * d,  // 避免 0 影响积\n                       limit && (d == upper), \n                       leading_zero && (d == 0));\n        }\n\n        if (!limit && !leading_zero) \n            dp[pos][sum_digits][prod_digits] = res;\n        \n        return res;\n    }\n\n    // 计算 [1, x] 范围内的 beautiful numbers 数量\n    int countBeautiful(int x) {\n        if (x == 0) return 0;\n\n        digits.clear();\n        while (x) {\n            digits.push_back(x % 10);\n            x /= 10;\n        }\n        reverse(digits.begin(), digits.end());\n\n        dp.clear();  // 使用 unordered_map，避免越界错误\n        return dfs(0, 0, 1, true, true);\n    }\n\n    // 计算 [l, r] 之间的 beautiful numbers 数量\n    int beautifulNumbers(int l, int r) {\n        return countBeautiful(r) - countBeautiful(l - 1);\n    }\n};","author":"PeterChenX","submissionId":"1575197270"},[]]},{"158":[{"id":"158","fileName":"1575196316.txt","sourceCode":"class Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        int res = 0;\n        string left = to_string(l);\n        string right = to_string(r);\n        left = string(right.size() - left.size(), '0') + left;\n        int dp[right.size()][82][82][2][2][2];\n        for (int i = 0; i < right.size(); i++) {\n            for (int j = 0; j < 82; j++) {\n                for (int k = 0; k < 82; k++) {\n                    for (int a = 0; a < 2; a++) {\n                        for (int b = 0; b < 2; b++) {\n                            for (int c = 0; c < 2; c++) {\n                                dp[i][j][k][a][b][c] = -1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for (int sum = 1; sum <= 81; sum++) {\n            // cout << f(left, right, 0, sum, sum, 0, 0, 0, dp) << endl;\n            res += f(left, right, 0, sum, sum, 0, 0, 0, dp);\n        }\n        return res;\n    }\n    \nprivate:\n    int f(string& l, string& r, int i, int a, int b, int x, int y, int z, int dp[][82][82][2][2][2]) {\n        if (i == r.size()) {\n            // cout  << i << \" \"<< a << \" \" << b << \" \" << x << endl;\n            return a == 0 && b == 1 ? 1 : 0;\n        }\n        // cout << i << \" \" << a << \" \" << b << \" \" << x << \" \" << y\n        if (dp[i][a][b][x][y][z] != -1) {\n            return dp[i][a][b][x][y][z];\n        }\n\n        // x=1, cur > l; y == 1, cur < r; z = 1; cur != 0\n        // int res = x == 1 && a == 0 && b == 1 ? 1 : 0;\n        int res = 0;\n        int cl = l[i] - '0', cr = r[i] - '0';\n        for (int c = 0; c < 10 && c <= a; c++) {\n            if (x == 0 && c < cl) continue;\n            if (y == 0 && c > cr) break;\n            int nb = b;\n            if (z == 1 || c > 0) {\n                if (c == 0) nb = 1;\n                else nb = b / gcd(b, c);\n            } \n            res += f(l, r, i + 1, a - c, nb, x || c > cl, y || c < cr, z || c > 0, dp);\n        }\n        // cout << i << \" \" << a << \" \" << b << \" \" << x << \" \" << y << \" \" <<z << \" \" << res << endl;\n        return dp[i][a][b][x][y][z] = res;\n    }\n};","author":"raincoat911","submissionId":"1575196316"},[]]},{"159":[{"id":"159","fileName":"1575200187.txt","sourceCode":"int dp[2][100][100];\nint ndp[2][100][100];\n\nclass Solution {\npublic:\n  int beautifulNumbers(int l, int r) {\n    auto Get = [&](int x) -> int {\n      if (x == 0) {\n        return 0;\n      }\n      vector<int> nums;\n      do {\n        nums.emplace_back(x % 10);\n        x /= 10;\n      } while (x > 0);\n      reverse(nums.begin(), nums.end());\n      int n = (int) nums.size();\n      int sum = accumulate(nums.begin(), nums.end(), 0);\n      int res = 0;\n      for (int sum = 1; sum <= 9 * n; sum++) {\n        memset(dp, 0, sizeof dp);\n        for (int i = 0; i < n; i++) {\n          memset(ndp, 0, sizeof ndp);\n          for (int c = 1; c <= (i == 0 ? nums[i] : 9); c++) {\n            if (c <= sum) {\n              ndp[i == 0 && c == nums[i]][c % sum][c] += 1;\n            }\n          }\n          for (int limit = 0; limit <= 1; limit++) {\n            for (int s = 0; s < sum; s++) {\n              for (int cur = 0; cur <= 9 * n; cur++) {\n                for (int c = 0; c <= (limit ? nums[i] : 9); c++) {\n                  if (cur + c <= sum) {\n                    ndp[limit && c == nums[i]][(s * c) % sum][cur + c] += dp[limit][s][cur];\n                  }\n                }\n              }\n            }\n          }\n          memcpy(dp, ndp, sizeof ndp);\n        }\n        for (int limit = 0; limit <= 1; limit++) {\n          res += dp[limit][0][sum];\n        }\n      }\n      return res;\n    };\n    return Get(r) - Get(l - 1);\n  }\n};","author":"C0ldSmi1e","submissionId":"1575200187"},[]]},{"161":[{"id":"161","fileName":"1575200278.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def cal(s: str) -> int:\n            \n            @cache\n            def dfs(i: int, is_limit: bool, is_num: bool, sum: int, p: int) -> int:\n                if i == len(s):\n                    if is_num:\n                        return 1 if (p == 0 or (sum != 0 and p % sum == 0)) else 0\n                    return 0\n                \n                res = 0\n                if not is_num:\n                    res += dfs(i + 1, False, False, 0, 1)\n                \n                down = 0 if is_num else 1\n                up = int(s[i]) if is_limit else 9\n                for u in range(down, up + 1):\n                    nl = is_limit and (u == int(s[i]))\n                    nf = True\n                    ns = np = 0\n                    if not is_num:\n                        ns = np = u\n                    else:\n                        ns = sum + u\n                        np = 0 if (p == 0 or u == 0) else p * u\n                    res += dfs(i + 1, nl, nf, ns, np)\n                return res\n            \n            return dfs(0, True, False, 0, 1)\n        \n        return cal(str(r)) - cal(str(int(l) - 1))","author":"happydreamer","submissionId":"1575200278"},[]]},{"162":[{"id":"162","fileName":"1575199362.txt","sourceCode":"class Solution {\n    Map<String, Integer> dp = new HashMap<>();\n    public int beautifulNumbers(int l, int r) {\n        dp = new HashMap<>();\n        int[] nums1 = numToArr(r);\n        int[] nums2 = numToArr(l - 1);\n        int a = dfs(nums1, 0, 0, 1, true, false);\n        dp = new HashMap<>();\n        int b = l == 1 ? 0 : dfs(nums2, 0, 0, 1, true, false);\n        \n        return a - b;\n    }\n    \n    int[] numToArr(int num) {\n        int len = 0;\n        int t = num;\n        while (t != 0)    {\n            len++;\n            t /= 10;\n        }\n        int[] nums = new int[len];\n        for (int i = len - 1; i >= 0; i--)  {\n            nums[i] = num % 10;\n            num /= 10;\n        }\n        return nums;\n    }\n    \n    int dfs(int[] nums, int idx, int sum, int prod, boolean isLimit, boolean isNum)  {\n        if (idx >= nums.length)\n            return isNum && prod % sum == 0 ? 1 : 0;\n        String key = idx + \"_\" + sum + \"_\" + prod;\n        if (dp.containsKey(key) && !isLimit && isNum)\n            return dp.get(key);\n        \n        int ans = 0;\n        \n        if (!isNum) \n            ans = dfs(nums, idx + 1, 0, 1, false, false);\n        \n        int lo = isNum ? 0 : 1;\n        int hi = isLimit ? nums[idx] : 9;\n        \n        for (int i = lo; i <= hi; i++)  {\n            ans += dfs(nums, idx + 1, sum + i, prod * i, isLimit && nums[idx] == i, true);\n        }\n        \n        if (!isLimit && isNum)\n            dp.put(key, ans);\n        \n        return ans;\n    }\n    \n    \n}","author":"zeningc","submissionId":"1575199362"},[]]},{"163":[{"id":"163","fileName":"1575200221.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_upto(n):\n            digits = list(map(int, str(n)))\n            length = len(digits)\n            \n            @lru_cache(None)\n            def dp(pos, tight, digit_sum, digit_product, leading_zero):\n                if pos == length:\n                    return 1 if digit_sum and digit_product % digit_sum == 0 else 0\n                \n                limit = digits[pos] if tight else 9\n                result = 0\n                \n                for d in range(0, limit + 1):\n                    new_sum = digit_sum + d\n                    new_product = digit_product * d if leading_zero == 0 or d > 0 else 1\n                    \n                    result += dp(pos + 1, tight and (d == limit), new_sum, new_product, leading_zero and d == 0)\n                \n                return result\n            \n            return dp(0, True, 0, 1, True)\n    \n        return count_upto(r) - count_upto(l - 1)\n        ","author":"Yuyi_Hao","submissionId":"1575200221"},[]]},{"164":[{"id":"164","fileName":"1575200728.txt","sourceCode":"class Solution {\n\n    private static class Element {\n        public int cur;          // 10\n        public int less;         // 2\n        public int sum;          // 81\n        public int productMod;   // 81\n        public Element(int cur, int less, int sum, int productMod) {\n            this.cur = cur;\n            this.less = less;\n            this.sum = sum;\n            this.productMod = productMod;\n        }\n        @Override\n        public int hashCode() {\n            int ans = 31;\n            ans = ans * 37 + this.cur;\n            ans = ans * 37 + this.less;\n            ans = ans * 37 + this.sum;\n            ans = ans * 37 + this.productMod;\n            return ans;\n        }\n        @Override\n        public boolean equals(Object obj) {\n            Element e = (Element) obj;\n            return this.cur == e.cur && this.less == e.less && this.sum == e.sum && this.productMod == e.productMod;\n        }\n    }\n\n    private Map<Element, Integer> dp = new HashMap<>();\n\n    public int beautifulNumbers(int l, int r) {\n        return getResult(r) - getResult(l - 1);\n    }\n\n    private int getResult(int upper) {\n        String number = Integer.toString(upper);\n        int ans = 0, len = number.length();\n        for (int i = 1;i <= len * 9;i ++) {\n            dp.clear();\n            ans += solve(number, 0, 0, 0, i, 1);\n        }\n        return ans;\n    }\n\n    private int solve(String number, int cur, int less, int sum, int targetSum, int productMod) {\n        if (sum > targetSum) {\n            return 0;\n        }\n        if (cur == number.length()) {\n            if (sum == targetSum && productMod == 0) {\n                return 1;\n            }\n            return 0;\n        }\n        Element e = new Element(cur, less, sum, productMod);\n        if (dp.containsKey(e)) {\n            return dp.get(e);\n        }\n        int ans = 0;\n        int start = 0;\n        int curDigit = number.charAt(cur) - '0', upper = curDigit;\n        if (less > 0) {\n            upper = 9;\n        }\n        // iter current digit\n        for (int i = start;i <= upper;i ++) {\n            int newSum = sum + i;\n            int newProdutMod = 1;\n            if (newSum > 0) {\n                newProdutMod = (productMod * i) % targetSum;\n            }\n            int newLess = 0;\n            if (less > 0) {\n                newLess = 1;\n            } else {\n                if (i < curDigit) {\n                    newLess = 1;\n                }\n            }\n            ans += solve(number, cur + 1, newLess, newSum, targetSum, newProdutMod);\n        }\n        dp.put(e, ans);\n        return ans;\n    }\n\n}","author":"Wei Liu","submissionId":"1575200728"},[]]},{"165":[{"id":"165","fileName":"1575201268.txt","sourceCode":"typedef long long ll;\nclass Solution {\npublic:\n    unordered_map<ll, unordered_map<ll, unordered_map<ll, unordered_map<ll, ll>>>> dp;\n    vector<int> digits;\n\n    ll countBeautiful(int pos, int sum, ll prod, bool tight) {\n        if (pos == digits.size()) {\n            return (sum > 0 && prod % sum == 0) ? 1 : 0;\n        }\n        if (dp[pos][sum][prod].count(tight)) \n            return dp[pos][sum][prod][tight];\n\n        int limit = tight ? digits[pos] : 9;\n        ll res = 0;\n\n        for (int d = 0; d <= limit; d++) {\n            ll newProd = (d == 0 && sum == 0) ? 1 : prod * d;  \n\n            // if (newProd > 1e9) break; \n            \n            res += countBeautiful(pos + 1, sum + d, newProd, tight && (d == limit));\n        }\n\n        return dp[pos][sum][prod][tight] = res;\n    }\n\n    ll solve(ll x) {\n        if (x == 0) return 0;\n        digits.clear();\n        while (x > 0) {\n            digits.push_back(x % 10);\n            x /= 10;\n        }\n        reverse(digits.begin(), digits.end());\n\n        dp.clear(); \n        return countBeautiful(0, 0, 1, 1);\n    }\n\n    int beautifulNumbers(int l, int r) {\n        return solve(r) - solve(l - 1);\n    }\n};","author":"Manav Majithia","submissionId":"1575201268"},[]]},{"166":[{"id":"166","fileName":"1575201974.txt","sourceCode":"class Solution:\n    from functools import lru_cache\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return self.count_beautiful_numbers(l,r)\n    \n    def count_beautiful_numbers(self, l, r):\n        def solve(n):\n            digits = list(map(int, str(n)))\n    \n            @lru_cache(maxsize=None)\n            def dp(pos, sum_digits, prod_digits, tight, leading_zero):\n                if pos == len(digits):\n                    if leading_zero:\n                        return 0\n                    if prod_digits == 0:\n                        return 1\n                    return int(prod_digits % sum_digits == 0)\n                \n                limit = digits[pos] if tight else 9\n                total = 0\n    \n                for d in range(0, limit + 1):\n                    next_sum = sum_digits + d\n                    next_prod = prod_digits * d if not leading_zero or d > 0 else prod_digits\n                    next_tight = tight and (d == limit)\n                    next_leading_zero = leading_zero and d == 0\n    \n                    total += dp(pos + 1, next_sum, next_prod, next_tight, next_leading_zero)\n                return total\n    \n            return dp(0, 0, 1, True, True)\n    \n        return solve(r) - solve(l - 1)","author":"Kotha Sai Krishna","submissionId":"1575201974"},[]]},{"167":[{"id":"167","fileName":"1575202705.txt","sourceCode":"using ll = long long;\nusing State = tuple<int, int, ll, bool, bool>;\n\nclass Solution {    \npublic:\n    map<State, ll> memo;\n    vector<int> digits;\n    \n    ll countBeautiful(int pos, int sum, int product, bool tight, bool leading_zero) \n    {\n        if (pos == digits.size()) {\n            return (sum > 0 && product % sum == 0) ? 1 : 0;\n        }\n\n        State key = {pos, sum, product, tight, leading_zero};\n        if (memo.find(key) != memo.end()) return memo[key];\n\n        int limit = (tight ? digits[pos] : 9);\n        ll res = 0;\n\n        for (int d = 0; d <= limit; d++) {\n            res += countBeautiful(pos + 1, sum + d, (leading_zero && d == 0) ? 1 : product * d, tight && (d == limit), leading_zero && (d == 0));\n        }\n\n        return memo[key] = res;\n    }\n    \n    ll helper(ll T) \n    {\n        if (T <= 0) return 0;\n        digits.clear();\n        memo.clear();\n\n        while (T > 0) \n        {\n            digits.push_back(T % 10);\n            T /= 10;\n        }\n        reverse(digits.begin(), digits.end());\n        return countBeautiful(0, 0, 1, true, true);\n    }\n    \n    int beautifulNumbers(int l, int r) \n    {\n        return helper(r) - helper(l-1);\n    }\n};","author":"wisdompeak","submissionId":"1575202705"},[]]},{"7":[{"id":"7","fileName":"1575108736.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        import functools\n        def count_nozero_all(X):\n            s = str(X)\n            n = len(s)\n            @functools.lru_cache(maxsize=None)\n            def dp(i, tight, started):\n                if i == n:\n                    return 1 if started else 0\n                res = 0\n                up = int(s[i]) if tight else 9\n                for d in range(0, up + 1):\n                    ntight = tight and (d == up)\n                    if not started:\n                        if d == 0:\n                            res += dp(i + 1, ntight, False)\n                        else:\n                            res += dp(i + 1, ntight, True)\n                    else:\n                        if d == 0:\n                            continue\n                        res += dp(i + 1, ntight, True)\n                return res\n            return dp(0, True, False)\n        def count_nozero_prop(X):\n            s = str(X)\n            n = len(s)\n            factors = {1:(0,0,0,0),2:(1,0,0,0),3:(0,1,0,0),4:(2,0,0,0),5:(0,0,1,0),6:(1,1,0,0),7:(0,0,0,1),8:(3,0,0,0),9:(0,2,0,0)}\n            @functools.lru_cache(maxsize=None)\n            def dp(i, tight, started, sm, a, b, c, d):\n                if i == n:\n                    if not started or sm == 0:\n                        return 0\n                    prod_mod = (pow(2, a, sm) * pow(3, b, sm)) % sm\n                    prod_mod = (prod_mod * pow(5, c, sm)) % sm\n                    prod_mod = (prod_mod * pow(7, d, sm)) % sm\n                    return 1 if prod_mod == 0 else 0\n                res = 0\n                up = int(s[i]) if tight else 9\n                for dig in range(0, up + 1):\n                    ntight = tight and (dig == up)\n                    if not started:\n                        if dig == 0:\n                            res += dp(i + 1, ntight, False, sm, a, b, c, d)\n                        else:\n                            na, nb, nc, nd = factors[dig]\n                            res += dp(i + 1, ntight, True, sm + dig, a + na, b + nb, c + nc, d + nd)\n                    else:\n                        if dig == 0:\n                            continue\n                        na, nb, nc, nd = factors[dig]\n                        res += dp(i + 1, ntight, True, sm + dig, a + na, b + nb, c + nc, d + nd)\n                return res\n            return dp(0, True, False, 0, 0, 0, 0, 0)\n        def count_beautiful(X):\n            if X <= 0:\n                return 0\n            total = X\n            nz_all = count_nozero_all(X)\n            with_zero = total - nz_all\n            nz_prop = count_nozero_prop(X)\n            return with_zero + nz_prop\n        return count_beautiful(r) - count_beautiful(l - 1)\n","author":"varshithchilukuri","submissionId":"1575108736"},[{"id":"7","similarity":0.9038808664259927,"totOverlap":2003,"longestOverlap":9}]],"13":[{"id":"13","fileName":"1575110875.txt","sourceCode":"#include <string>\n#include <unordered_map>\n#include <cstdlib>\nusing namespace std;\n\nclass Solution {\npublic:\n    typedef long long ll;\n    string s;\n    unordered_map<ll, ll> mp;\n    \n    inline void bop(int &x) {\n        x = x | 0;\n        x = x & 1;\n        x = x ^ 0;\n    }\n    \n    ll r(int p, int tk, int st, int hz, int sm, int a2, int a3, int a5, int a7) {\n        if(p == s.size()){\n            if(!st) return 0;\n            if(hz) return 1;\n            int pr = 1;\n            int i = 0;\n            while(i < a2) { pr *= 2; i++; }\n            i = 0;\n            while(i < a3) { pr *= 3; i++; }\n            i = 0;\n            while(i < a5) { pr *= 5; i++; }\n            i = 0;\n            while(i < a7) { pr *= 7; i++; }\n            return (sm != 0 && pr % sm == 0) ? 1LL : 0LL;\n        }\n        \n        ll key = p;\n        key |= ((ll)tk << 4);\n        key |= ((ll)st << 5);\n        key |= ((ll)hz << 6);\n        key |= ((ll)sm << 7);\n        key |= ((ll)a2 << 14);\n        key |= ((ll)a3 << 20);\n        key |= ((ll)a5 << 26);\n        key |= ((ll)a7 << 31);\n        \n        if(mp.find(key) != mp.end()) return mp[key];\n        \n        ll res = 0;\n        int lim = tk ? s[p] - '0' : 9;\n        int d = 0;\n        while(d <= lim) {\n            int ntk = tk && (d == lim);\n            if(!st) {\n                if(d == 0) {\n                    res += r(p+1, ntk, 0, 0, 0, 0, 0, 0, 0);\n                } else {\n                    int nsm = d;\n                    int na2 = 0, na3 = 0, na5 = 0, na7 = 0;\n                    int tmp = d;\n                    while(tmp % 2 == 0 && tmp != 0) { na2++; tmp /= 2; }\n                    tmp = d;\n                    while(tmp % 3 == 0 && tmp != 0) { na3++; tmp /= 3; }\n                    tmp = d;\n                    while(tmp % 5 == 0 && tmp != 0) { na5++; tmp /= 5; }\n                    tmp = d;\n                    while(tmp % 7 == 0 && tmp != 0) { na7++; tmp /= 7; }\n                    res += r(p+1, ntk, 1, 0, nsm, na2, na3, na5, na7);\n                }\n            } else {\n                if(hz) {\n                    int nsm = sm + d;\n                    res += r(p+1, ntk, 1, 1, nsm, 0, 0, 0, 0);\n                } else {\n                    if(d == 0) {\n                        int nsm = sm;\n                        res += r(p+1, ntk, 1, 1, nsm, 0, 0, 0, 0);\n                    } else {\n                        int nsm = sm + d;\n                        int na2 = a2, na3 = a3, na5 = a5, na7 = a7;\n                        int tmp = d;\n                        while(tmp % 2 == 0 && tmp != 0) { na2++; tmp /= 2; }\n                        tmp = d;\n                        while(tmp % 3 == 0 && tmp != 0) { na3++; tmp /= 3; }\n                        tmp = d;\n                        while(tmp % 5 == 0 && tmp != 0) { na5++; tmp /= 5; }\n                        tmp = d;\n                        while(tmp % 7 == 0 && tmp != 0) { na7++; tmp /= 7; }\n                        res += r(p+1, ntk, 1, 0, nsm, na2, na3, na5, na7);\n                    }\n                }\n            }\n            int tmpd = d;\n            bop(tmpd);\n            d++;\n        }\n        mp[key] = res;\n        return res;\n    }\n    \n    ll countBeautiful(ll x) {\n        if(x < 1) return 0;\n        s = to_string(x);\n        mp.clear();\n        return r(0, 1, 0, 0, 0, 0, 0, 0, 0);\n    }\n    \n    int beautifulNumbers(int l, int r) {\n        pair<int,int> kv = {l, r};\n        int dummy = 42;\n        dummy = dummy | 0;\n        dummy = dummy & 1;\n        dummy = dummy ^ 0;\n        return (int)(countBeautiful(r) - countBeautiful((ll)l - 1));\n    }\n};\n","author":"G123df","submissionId":"1575110875"},[{"id":"13","similarity":0.872874149659864,"totOverlap":2053,"longestOverlap":5}]],"31":[{"id":"31","fileName":"1575132275.txt","sourceCode":"class Solution {\n\n    using ll = long long;\n\n    struct S {\n        int i, t, st, z, s, p;\n        bool operator==(const S &o) const {\n            return i==o.i && t==o.t && st==o.st && z==o.z && s==o.s && p==o.p;\n        }\n    };\n\n    struct H {\n        size_t operator()(const S &st) const {\n            size_t r = 17;\n            r = r*31 + std::hash<int>()(st.i);\n            r = r*31 + std::hash<int>()(st.t);\n            r = r*31 + std::hash<int>()(st.st);\n            r = r*31 + std::hash<int>()(st.z);\n            r = r*31 + std::hash<int>()(st.s);\n            r = r*31 + std::hash<int>()(st.p);\n            return r;\n        }\n    };\n\n    unordered_map<S, ll, H> mem;\n    \n    ll dp(int i, int t, int st, int z, int s, int p, const string &str) {\n        if(i==str.size()){\n            if(!st)return 0;\n            return z ? 1LL : ((p % s)==0 ? 1LL : 0LL);\n        }\n        S stt{i,t,st,z,s,p};\n        if(mem.count(stt)) return mem[stt];\n        ll r = 0; int lim = t ? str[i]-'0' : 9;\n        for(int d=0; d<=lim; d++){\n            int nt = (t && d==lim);\n            if(!st){\n                r += (d==0) ? dp(i+1, nt, 0, 0, 0, 1, str) : \n                                        dp(i+1, nt, 1, 0, d, d, str);\n            } else {\n                if(z) r += dp(i+1, nt, 1, 1, s+d, 0, str);\n                else r += (d==0) ? dp(i+1, nt, 1, 1, s, 0, str) : \n                                    dp(i+1, nt, 1, 0, s+d, p*d, str);\n            }\n        }\n        return mem[stt] = r;\n    }\n    \n    ll cnt(ll x) {\n        string s = to_string(x);\n        mem.clear();\n        return dp(0,1,0,0,0,1,s);\n    }\n    \npublic:\n    int beautifulNumbers(int l, int r) {\n        return (int)(cnt(r) - cnt(l-1));\n    }\n};\n","author":"Ronak Gadhiya","submissionId":"1575132275"},[{"id":"31","similarity":0.8959356855739169,"totOverlap":2006,"longestOverlap":3}]],"37":[{"id":"37","fileName":"1575132123.txt","sourceCode":"\nclass Solution {\npublic:\ntypedef long long ll;\nstring s;\nint n;\nunordered_map<ll, ll> mem;\nint F[10][4] = {\n {0,0,0,0},\n {0,0,0,0},\n {1,0,0,0},\n {0,1,0,0},\n {2,0,0,0},\n {0,0,1,0},\n {1,1,0,0},\n {0,0,0,1},\n {3,0,0,0},\n {0,2,0,0}\n};\nbool vld(int sm, int a, int b, int c, int d) {\n  int m=0, n=0, o=0, p=0, x = sm;\n  while(x % 2 == 0 && x) { m++; x /= 2; }\n  while(x % 3 == 0 && x) { n++; x /= 3; }\n  while(x % 5 == 0 && x) { o++; x /= 5; }\n  while(x % 7 == 0 && x) { p++; x /= 7; }\n  return (x==1 && a>=m && b>=n && c>=o && d>=p);\n}\nll enc(int i, int t, int st, int z, int sm, int a, int b, int c, int d) {\n  return ((((((((ll)i*2+t)*2+st)*2+z)*100+sm)*40+a)*40+b)*20+c)*20+d;\n}\nll dp(int i, int t, int st, int z, int sm, int a, int b, int c, int d) {\n  if(i==n) return st ? (z ? 1LL : (vld(sm,a,b,c,d) ? 1LL : 0LL)) : 0LL;\n  ll k = enc(i,t,st,z,sm,a,b,c,d);\n  if(mem.count(k)) return mem[k];\n  ll r = 0;\n  int L = t ? s[i]-'0' : 9;\n  for(int dgt=0; dgt<=L; dgt++){\n    int nt = (t && dgt==L);\n    if(!st){\n      if(dgt==0) r += dp(i+1, nt, 0, 0, 0, 0, 0, 0, 0);\n      else r += dp(i+1, nt, 1, 0, dgt, F[dgt][0], F[dgt][1], F[dgt][2], F[dgt][3]);\n    } else {\n      if(z) r += dp(i+1, nt, 1, 1, sm+dgt, a, b, c, d);\n      else {\n        if(dgt==0) r += dp(i+1, nt, 1, 1, sm, a, b, c, d);\n        else r += dp(i+1, nt, 1, 0, sm+dgt, a+F[dgt][0], b+F[dgt][1], c+F[dgt][2], d+F[dgt][3]);\n      }\n    }\n  }\n  return mem[k] = r;\n}\nll cnt(ll x) {\n  if(x < 1) return 0;\n  s = to_string(x);\n  n = s.size();\n  mem.clear();\n  return dp(0, 1, 0, 0, 0, 0, 0, 0, 0);\n}\n  int beautifulNumbers(int l, int r) {\n    return (int)(cnt(r) - cnt(l - 1));\n  }\n};","author":"PJ_ID","submissionId":"1575132123"},[{"id":"37","similarity":0.8903083700440528,"totOverlap":2021,"longestOverlap":5}]],"41":[{"id":"41","fileName":"1575132547.txt","sourceCode":"#include <vector>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\npublic:\n    long long dp(int pos, int tight, int started, int zero, int s, long long p, const vector<int>& digs, unordered_map<string, long long>& memo) {\n        if(pos == digs.size()){\n            if(!started) return 0;\n            if(zero) return 1;\n            if(s > 0 && p % s == 0) return 1;\n            return 0;\n        }\n        string key = to_string(pos) + \"_\" + to_string(tight) + \"_\" + to_string(started) + \"_\" + to_string(zero) + \"_\" + to_string(s) + \"_\" + to_string(p);\n        if(memo.find(key) != memo.end()){\n            return memo[key];\n        }\n        long long ans = 0;\n        int lim = (tight == 1 ? digs[pos] : 9);\n        for (int d = 0; d <= lim; d++){\n            int nt = (tight == 1 && d == lim) ? 1 : 0;\n            int ns = s, nsd = started, nz = zero;\n            long long np = p;\n            if(!started){\n                if(d != 0){\n                    nsd = 1;\n                    ns = d;\n                    np = d;\n                }\n            } else {\n                if(!zero){\n                    if(d == 0){\n                        nz = 1;\n                        ns = 0;\n                        np = 0;\n                    } else {\n                        ns = s + d;\n                        np = p * d;\n                    }\n                }\n            }\n            ans += dp(pos + 1, nt, nsd, nz, ns, np, digs, memo);\n        }\n        memo[key] = ans;\n        return ans;\n    }\n    \n    long long countUpTo(long long X) {\n        if(X < 1) return 0;\n        string str = to_string(X);\n        vector<int> digs;\n        for(char c : str)\n            digs.push_back(c - '0');\n        unordered_map<string, long long> memo;\n        return dp(0, 1, 0, 0, 0, 1, digs, memo);\n    }\n    \n    int beautifulNumbers(int l, int r) {\n        long long ans = countUpTo(r) - countUpTo(l - 1);\n        return (int)ans;\n    }\n};\n","author":"ChangeofPace","submissionId":"1575132547"},[{"id":"41","similarity":0.923006416131989,"totOverlap":2014,"longestOverlap":2}]],"62":[{"id":"62","fileName":"1575150330.txt","sourceCode":"#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\ntypedef unsigned long long ULL;\n\ntypedef struct {\n    int pos;\n    int tight;\n    int started;\n    int hasZero;\n    int sum;\n    ULL prod;\n} Key;\n\ntypedef struct {\n    Key key;\n    long long value;\n    int used;\n} Entry;\n\n#define HASH_SIZE (1 << 17)\n\nstatic Entry memo[HASH_SIZE];\n\nstatic inline unsigned int hashKey(const Key* k) {\n    unsigned int h = 0;\n    h = k->pos;\n    h = h * 31 + k->tight;\n    h = h * 31 + k->started;\n    h = h * 31 + k->hasZero;\n    h = h * 31 + k->sum;\n    h = h * 31 + (unsigned int)(k->prod & 0xffffffffULL);\n    h = h * 31 + (unsigned int)((k->prod >> 32) & 0xffffffffULL);\n    return h;\n}\n\nstatic inline int keysEqual(const Key* a, const Key* b) {\n    return a->pos == b->pos && a->tight == b->tight && a->started == b->started &&\n           a->hasZero == b->hasZero && a->sum == b->sum && a->prod == b->prod;\n}\n\nlong long dp(int pos, int tight, int started, int hasZero, int sum, ULL prod, int n, int* digits) {\n    if (pos == n) {\n        if (!started) return 0;\n        if (hasZero) return 1;\n        return (prod % sum == 0) ? 1 : 0;\n    }\n    Key key = {pos, tight, started, hasZero, sum, prod};\n    unsigned int h = hashKey(&key) & (HASH_SIZE - 1);\n    while (memo[h].used) {\n        if (keysEqual(&memo[h].key, &key))\n            return memo[h].value;\n        h = (h + 1) & (HASH_SIZE - 1);\n    }\n    long long res = 0;\n    int limit = tight ? digits[pos] : 9;\n    for (int dig = 0; dig <= limit; dig++) {\n        int nstarted = started;\n        int nhasZero = hasZero;\n        int nsum = sum;\n        ULL nprod = prod;\n        int ntight = tight;\n        if (!started) {\n            if (dig == 0) {\n                ntight = (tight && (dig == limit));\n                res += dp(pos + 1, ntight, 0, 0, 0, 1ULL, n, digits);\n                continue;\n            } else {\n                nstarted = 1;\n                nsum = dig;\n                nprod = dig;\n            }\n        } else {\n            nsum += dig;\n            if (dig == 0) {\n                nhasZero = 1;\n                nprod = 0;\n            } else {\n                if (nprod != 0) nprod *= dig;\n            }\n        }\n        if (tight && dig < limit) ntight = 0;\n        res += dp(pos + 1, ntight, nstarted, nhasZero, nsum, nprod, n, digits);\n    }\n    memo[h].used = 1;\n    memo[h].key = key;\n    memo[h].value = res;\n    return res;\n}\n\nlong long countBeautiful(ULL X) {\n    if (X == 0) return 0;\n    int digits[20];\n    int n = 0;\n    while (X) {\n        digits[n++] = X % 10;\n        X /= 10;\n    }\n    for (int i = 0; i < n / 2; i++) {\n        int tmp = digits[i];\n        digits[i] = digits[n - 1 - i];\n        digits[n - 1 - i] = tmp;\n    }\n    memset(memo, 0, sizeof(memo));\n    return dp(0, 1, 0, 0, 0, 1ULL, n, digits);\n}\n\nint beautifulNumbers(int l, int r) {\n    long long countR = countBeautiful(r);\n    long long countL_1 = countBeautiful((ULL)l - 1);\n    long long ans = countR - countL_1;\n    return (int)ans;\n}\n","author":"kl2400031478","submissionId":"1575150330"},[{"id":"62","similarity":0.8824561403508772,"totOverlap":2012,"longestOverlap":2}]],"66":[{"id":"66","fileName":"1575150614.txt","sourceCode":"vector<int> table{0, 534358, 1118256, 1710152, 2301357, 2892674, 3501976, 4092977, 4685243, 5269114, 5845532, 6845532, 7424999, 8012895, 8599800, 9188586, 9794706, 10383104, 10975371, 11554908, 12130749, 13130749, 13718645, 14309962, 14905011, 15495092, 16109890, 16701331, 17301955, 17880546, 18463924, 19463924, 20050829, 20645878, 21232718, 21828688, 22443383, 23031677, 23633725, 24221946, 24795187, 25795187, 26383973, 26974054, 27570024, 28154561, 28771928, 29363037, 29966694, 30542204, 31128600, 32128600, 32734720, 33349518, 33964213, 34581580, 35183805, 35802626, 36431795, 37042548, 37651026, 38651026, 39239424, 39830865, 40419159, 41010268, 41629089, 42216865, 42825363, 43410375, 43988395, 44988395, 45580662, 46181286, 46783334, 47386991, 48016160, 48624658, 49218644, 49821260, 50422159, 51422159, 52001696, 52580287, 53168508, 53744018, 54354771, 54939783, 55542399, 56110829, 56696849, 57696849, 58272690, 58856068, 59429309, 60015705, 60624183, 61202203, 61803102, 62389122, 62955907, 63955907, 64955907, 65955907, 66955907, 67955907, 68955907, 69955907, 70955907, 71955907, 72955907, 73955907, 74531177, 75114818, 75697003, 76281137, 76883255, 77467895, 78056499, 78634153, 79206545, 80206545, 80790186, 81378972, 81969973, 82554936, 83167320, 83756879, 84355105, 84932685, 85514715, 86514715, 87096900, 87687901, 88270156, 88861597, 89472689, 90058199, 90657226, 91243662, 91814353, 92814353, 93398487, 93983450, 94574891, 95157458, 95770737, 96358958, 96961125, 97534408, 98119653, 99119653, 99721771, 100334155, 100945247, 101558526, 102159384, 102777471, 103403915, 104012151, 104619367, 105619367, 106204007, 106793566, 107379076, 107967297, 108585384, 109171780, 109780339, 110364122, 110942601, 111942601, 112531205, 113129431, 113728458, 114330625, 114957069, 115565628, 116160419, 116760080, 117360798, 118360798, 118938452, 119516032, 120102468, 120675751, 121283987, 121867770, 122467431, 123034950, 123618884, 124618884, 125191276, 125773306, 126343997, 126929242, 127536458, 128114937, 128715655, 129299589, 129867304, 130867304, 131867304, 132867304, 133867304, 134867304, 135867304, 136867304, 137867304, 138867304, 139867304, 140867304, 141450945, 142039731, 142630732, 143215695, 143828079, 144417638, 145015864, 145593444, 146175474, 147175474, 147764260, 148354341, 148950311, 149534848, 150152215, 150743324, 151346981, 151922491, 152508887, 153508887, 154099888, 154695858, 155286786, 155879411, 156501543, 157091621, 157701299, 158288289, 158868605, 159868605, 160453568, 161038105, 161630730, 162210272, 162825758, 163413440, 164017792, 164589829, 165177617, 166177617, 166790001, 167407368, 168029500, 168644986, 169257209, 169879821, 170516104, 171124269, 171741637, 172741637, 173331196, 173922305, 174512383, 175100065, 175722677, 176310905, 176923378, 177506113, 178088434, 179088434, 179686660, 180290317, 180899995, 181504347, 182140630, 182753103, 183357287, 183957650, 184567579, 185567579, 186145159, 186720669, 187307659, 187879696, 188487861, 189070596, 189670959, 190237682, 190822976, 191822976, 192405006, 192991402, 193571718, 194159506, 194776874, 195359195, 195969124, 196554418, 197130769, 198130769, 199130769, 200130769, 201130769, 202130769, 203130769, 204130769, 205130769, 206130769, 207130769, 208130769, 208712954, 209303955, 209886210, 210477651, 211088743, 211674253, 212273280, 212859716, 213430407, 214430407, 215021408, 215617378, 216208306, 216800931, 217423063, 218013141, 218622819, 219209809, 219790125, 220790125, 221372380, 221963308, 222540863, 223132616, 223745515, 224328163, 224931033, 225519261, 226088343, 227088343, 227679784, 228272409, 228864162, 229454639, 230078424, 230668606, 231282682, 231866495, 232450476, 233450476, 234061568, 234683700, 235296599, 235920384, 236534626, 237155055, 237793716, 238413626, 239019237, 240019237, 240604747, 241194825, 241777473, 242367655, 242988084, 243572260, 244183887, 244770447, 245347819, 246347819, 246946846, 247556524, 248159394, 248773470, 249412131, 250023758, 250633257, 251245753, 251846362, 252846362, 253432798, 254019788, 254608016, 255191829, 255811739, 256398299, 257010795, 257590641, 258175007, 259175007, 259745698, 260326014, 260895096, 261479077, 262084688, 262662060, 263262669, 263847035, 264413913, 265413913, 266413913, 267413913, 268413913, 269413913, 270413913, 271413913, 272413913, 273413913, 274413913, 275413913, 275998047, 276583010, 277174451, 277757018, 278370297, 278958518, 279560685, 280133968, 280719213, 281719213, 282304176, 282888713, 283481338, 284060880, 284676366, 285264048, 285868400, 286440437, 287028225, 288028225, 288619666, 289212291, 289804044, 290394521, 291018306, 291608488, 292222564, 292806377, 293390358, 294390358, 294972925, 295552467, 296142944, 296718460, 297330743, 297916181, 298519739, 299088169, 299674729, 300674729, 301288008, 301903494, 302527279, 303139562, 303755305, 304377988, 305014869, 305618082, 306237756, 307237756, 307825977, 308413659, 309003841, 309589279, 310211962, 310799275, 311414497, 311995197, 312581466, 313581466, 314183633, 314787985, 315402061, 316005619, 316642500, 317257722, 317867676, 318465374, 319079252, 320079252, 320652535, 321224572, 321808385, 322376815, 322980028, 323560728, 324158426, 324722562, 325306727, 326306727, 326891972, 327479760, 328063741, 328650301, 329269975, 329856244, 330470122, 331054287, 331635764, 332635764, 333635764, 334635764, 335635764, 336635764, 337635764, 338635764, 339635764, 340635764, 341635764, 342635764, 343237882, 343850266, 344461358, 345074637, 345675495, 346293582, 346920026, 347528262, 348135478, 349135478, 349747862, 350365229, 350987361, 351602847, 352215070, 352837682, 353473965, 354082130, 354699498, 355699498, 356310590, 356932722, 357545621, 358169406, 358783648, 359404077, 360042738, 360662648, 361268259, 362268259, 362881538, 363497024, 364120809, 364733092, 365348835, 365971518, 366608399, 367211612, 367831286, 368831286, 369432144, 370044367, 370658609, 371274352, 371873273, 372497894, 373129608, 373743460, 374359942, 375359942, 375978029, 376600641, 377221070, 377843753, 378468374, 379088900, 379732163, 380347416, 380958612, 381958612, 382585056, 383221339, 383860000, 384496881, 385128595, 385771858, 386399249, 387026386, 387656516, 388656516, 389264752, 389872917, 390492827, 391096040, 391709892, 392325145, 392952282, 393546372, 394160421, 395160421, 395767637, 396385005, 396990616, 397610290, 398226772, 398837968, 399468098, 400082147, 400677787, 401677787, 402677787, 403677787, 404677787, 405677787, 406677787, 407677787, 408677787, 409677787, 410677787, 411677787, 412262427, 412851986, 413437496, 414025717, 414643804, 415230200, 415838759, 416422542, 417001021, 418001021, 418590580, 419181689, 419771767, 420359449, 420982061, 421570289, 422182762, 422765497, 423347818, 424347818, 424933328, 425523406, 426106054, 426696236, 427316665, 427900841, 428512468, 429099028, 429676400, 430676400, 431264621, 431852303, 432442485, 433027923, 433650606, 434237919, 434853141, 435433841, 436020110, 437020110, 437638197, 438260809, 438881238, 439503921, 440128542, 440749068, 441392331, 442007584, 442618780, 443618780, 444205176, 444793404, 445377580, 445964893, 446585419, 447170490, 447784128, 448368760, 448949064, 449949064, 450557623, 451170096, 451781723, 452396945, 453040208, 453653846, 454271486, 454881758, 455488633, 456488633, 457072416, 457655151, 458241711, 458822411, 459437664, 460022296, 460632568, 461209382, 461794017, 462794017, 463372496, 463954817, 464532189, 465118458, 465729654, 466309958, 466916833, 467501468, 468074643, 469074643, 470074643, 471074643, 472074643, 473074643, 474074643, 475074643, 476074643, 477074643, 478074643, 479074643, 479663247, 480261473, 480860500, 481462667, 482089111, 482697670, 483292461, 483892122, 484492840, 485492840, 486091066, 486694723, 487304401, 487908753, 488545036, 489157509, 489761693, 490362056, 490971985, 491971985, 492571012, 493180690, 493783560, 494397636, 495036297, 495647924, 496257423, 496869919, 497470528, 498470528, 499072695, 499677047, 500291123, 500894681, 501531562, 502146784, 502756738, 503354436, 503968314, 504968314, 505594758, 506231041, 506869702, 507506583, 508138297, 508781560, 509408951, 510036088, 510666218, 511666218, 512274777, 512887250, 513498877, 514114099, 514757362, 515371000, 515988640, 516598912, 517205787, 518205787, 518800578, 519404762, 520014261, 520624215, 521251606, 521869246, 522460648, 523067394, 523676108, 524676108, 525275769, 525876132, 526488628, 527086326, 527713463, 528323735, 528930481, 529522601, 530134017, 531134017, 531734735, 532344664, 532945273, 533559151, 534189281, 534796156, 535404870, 536016286, 536609810, 537609810, 538609810, 539609810, 540609810, 541609810, 542609810, 543609810, 544609810, 545609810, 546609810, 547609810, 548187464, 548765044, 549351480, 549924763, 550532999, 551116782, 551716443, 552283962, 552867896, 553867896, 554445476, 555020986, 555607976, 556180013, 556788178, 557370913, 557971276, 558537999, 559123293, 560123293, 560709729, 561296719, 561884947, 562468760, 563088670, 563675230, 564287726, 564867572, 565451938, 566451938, 567025221, 567597258, 568181071, 568749501, 569352714, 569933414, 570531112, 571095248, 571679413, 572679413, 573287649, 573895814, 574515724, 575118937, 575732789, 576348042, 576975179, 577569269, 578183318, 579183318, 579767101, 580349836, 580936396, 581517096, 582132349, 582716981, 583327253, 583904067, 584488702, 585488702, 586088363, 586688726, 587301222, 587898920, 588526057, 589136329, 589743075, 590335195, 590946611, 591946611, 592514130, 593080853, 593660699, 594224835, 594818925, 595395739, 595987859, 596548564, 597130993, 598130993, 598714927, 599300221, 599884587, 600468752, 601082801, 601667436, 602278852, 602861281, 603442755, 604442755, 605442755, 606442755, 607442755, 608442755, 609442755, 610442755, 611442755, 612442755, 613442755, 614442755, 615015147, 615597177, 616167868, 616753113, 617360329, 617938808, 618539526, 619123460, 619691175, 620691175, 621273205, 621859601, 622439917, 623027705, 623645073, 624227394, 624837323, 625422617, 625998968, 626998968, 627569659, 628149975, 628719057, 629303038, 629908649, 630486021, 631086630, 631670996, 632237874, 633237874, 633823119, 634410907, 634994888, 635581448, 636201122, 636787391, 637401269, 637985434, 638566911, 639566911, 640174127, 640791495, 641397106, 642016780, 642633262, 643244458, 643874588, 644488637, 645084277, 646084277, 646662756, 647245077, 647822449, 648408718, 649019914, 649600218, 650207093, 650791728, 651364903, 652364903, 652965621, 653575550, 654176159, 654790037, 655420167, 656027042, 656635756, 657247172, 657840696, 658840696, 659424630, 660009924, 660594290, 661178455, 661792504, 662377139, 662988555, 663570984, 664152458, 665152458, 665720173, 666296524, 666863402, 667444879, 668040519, 668613694, 669207218, 669788692};\nclass Solution {\nprivate:\n    bool check(int x) {\n        int y = x;\n        int prod = 1;\n        int sum = 0;\n        while(y != 0) {\n            prod *= y % 10;\n            sum += y % 10;\n            y /= 10;\n        }\n        return prod % sum == 0;\n    }\n    int count(int x) {\n        if (x == 0) return 0;\n        int base = x / 1000000;\n        int res = table[base];\n        for(int y = base * 1000000 + 1; y <= x; y++) {\n            if (check(y)) res++;\n        }\n        return res;\n    }\npublic:\n    int beautifulNumbers(int l, int r) {\n        return count(r) - count(l - 1);\n    }\n};","author":"Yucheng Dai","submissionId":"1575150614"},[{"id":"66","similarity":0.9780857234933935,"totOverlap":3035,"longestOverlap":993}]],"69":[{"id":"69","fileName":"1575154467.txt","sourceCode":"class Solution {\npublic:\n    string digStr;\n    int totLen;\n    unordered_map<long long, long long> cacheA;\n    unordered_map<long long, long long> cacheB;\n \n    long long funB(int idx, int bd) {\n        if(idx == totLen) return 1;\n        long long keyVal = (long long)idx * 7 + bd;\n        if(cacheB.find(keyVal) != cacheB.end())\n            return cacheB[keyVal];\n \n        int lim = bd ? (digStr[idx] - '0') : 9;\n        long long tot = 0;\n        for (int cur = 0; cur <= lim; cur++) {\n            int nb = (bd && (cur == lim)) ? 1 : 0;\n            tot += funB(idx + 1, nb);\n        }\n        cacheB[keyVal] = tot;\n        return tot;\n    }\n \n    long long funA(int idx, int bd, int init, int zfl, int sm, int pr) {\n        if(idx == totLen) {\n            if(!init) return 0;\n            if(zfl) return 1;\n            return (pr % sm == 0) ? 1LL : 0LL;\n        }\n\n        long long key = ((((long long)idx * 3 + bd) * 3 + init) * 3 + zfl) * 100 + sm;\n        key = key * 1000000000LL + pr;\n \n        if(cacheA.find(key) != cacheA.end())\n            return cacheA[key];\n \n        int lim = bd ? (digStr[idx] - '0') : 9;\n        long long ans = 0;\n        for (int dig = 0; dig <= lim; dig++) {\n            int nbd = (bd && (dig == lim)) ? 1 : 0;\n            if(!init) {\n                ans += (dig == 0) ? funA(idx + 1, nbd, 0, 0, 0, 1)\n                                  : funA(idx + 1, nbd, 1, 0, dig, dig);\n            } else {\n                if(zfl)\n                    ans += funB(idx + 1, nbd);\n                else {\n                    ans += (dig == 0) ? funB(idx + 1, nbd)\n                                      : funA(idx + 1, nbd, 1, 0, sm + dig, pr * dig);\n                }\n            }\n        }\n        cacheA[key] = ans;\n        return ans;\n    }\n \n    long long compVal(long long val) {\n        if(val <= 0) return 0;\n        digStr = to_string(val);\n        totLen = (int)digStr.size();\n        cacheA.clear();\n        cacheB.clear();\n        return funA(0, 1, 0, 0, 0, 1);\n    }\n \n    int beautifulNumbers(int l, int r) {\n        long long posVal = compVal(r);\n        long long negVal = compVal((long long)l - 1);\n        return (int)(posVal - negVal);\n    }\n};\n","author":"rokkc","submissionId":"1575154467"},[{"id":"69","similarity":0.9047191011235955,"totOverlap":2013,"longestOverlap":3}]],"77":[{"id":"77","fileName":"1575155477.txt","sourceCode":"typedef long long ll;\n\nstruct State {\n    int pos;\n    int tight;\n    int started;\n    int hasZero;\n    int sum;\n    ll prod;\n    \n    bool operator==(const State &other) const {\n        return pos == other.pos && tight == other.tight && started == other.started &&\n               hasZero == other.hasZero && sum == other.sum && prod == other.prod;\n    }\n};\n\nstruct StateHash {\n    size_t operator()(const State &st) const {\n        size_t res = 17;\n        res = res * 31 + std::hash<int>()(st.pos);\n        res = res * 31 + std::hash<int>()(st.tight);\n        res = res * 31 + std::hash<int>()(st.started);\n        res = res * 31 + std::hash<int>()(st.hasZero);\n        res = res * 31 + std::hash<int>()(st.sum);\n        res = res * 31 + std::hash<ll>()(st.prod);\n        return res;\n    }\n};\n\nclass Solution {\npublic:\n   string s;\n    unordered_map<State, ll, StateHash> memo;\n    \n    ll solve(int pos, int tight, int started, int hasZero, int sum, ll prod) {\n        if (pos == s.size()) {\n            if (!started) return 0; \n            if (hasZero) return 1;\n            return (prod % sum == 0) ? 1 : 0;\n        }\n        \n        State st{pos, tight, started, hasZero, sum, prod};\n        if (memo.count(st)) return memo[st];\n        \n        ll res = 0;\n        int limit = (tight ? s[pos] - '0' : 9);\n        for (int d = 0; d <= limit; d++) {\n            int ntight = (tight && (d == limit));\n            int nstarted = (started || (d != 0));\n            int nhasZero = hasZero;\n            int nsum = sum;\n            ll nprod = prod;\n            \n            if (!started && d == 0) {\n            } else if (d == 0) {\n                nhasZero = 1;\n                nsum += d;\n                nprod = 0;\n            } else {\n                nsum += d;\n                nprod = nprod * d;\n            }\n            res += solve(pos + 1, ntight, nstarted, nhasZero, nsum, nprod);\n        }\n        \n        memo[st] = res;\n        return res;\n    }\n    \n    ll countBeautiful(ll n) {\n        s = to_string(n);\n        memo.clear();\n        return solve(0, 1, 0, 0, 0, 1);\n    }\n    \n    int beautifulNumbers(int l, int r) {\n        return (int)(countBeautiful(r) - countBeautiful(l - 1));\n    }\n};","author":"ChY","submissionId":"1575155477"},[{"id":"77","similarity":0.9000446229361893,"totOverlap":2017,"longestOverlap":2}]],"87":[{"id":"87","fileName":"1575165823.txt","sourceCode":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define HSZ (1 << 15)\n\ntypedef long long ll;\n\ntypedef struct {\n    int idx, tight, st, hz, sum, prod;\n} State;\n\nState htKey[HSZ];\nll htVal[HSZ];\nint htUsed[HSZ];\n\nunsigned int state_hash(State st) {\n    unsigned int h = 0;\n    h = st.idx;\n    h = h * 37 + st.tight;\n    h = h * 37 + st.st;\n    h = h * 37 + st.hz;\n    h = h * 37 + st.sum;\n    h = h * 37 + st.prod;\n    return h;\n}\n\nint state_equal(State a, State b) {\n    return a.idx == b.idx && a.tight == b.tight && a.st == b.st &&\n           a.hz == b.hz && a.sum == b.sum && a.prod == b.prod;\n}\n\nint digArr[20], dLen;\n\nll dp_calc(int idx, int tight, int st, int hz, int s, int p) {\n    if (idx == dLen) {\n        if (!st) return 0;\n        if (hz) return 1;\n        return (p % s == 0) ? 1 : 0;\n    }\n    \n    State cur = {idx, tight, st, hz, s, p};\n    \n    unsigned int hkey = state_hash(cur);\n    unsigned int pos = hkey & (HSZ - 1);\n    while (htUsed[pos]) {\n        if (state_equal(htKey[pos], cur))\n            return htVal[pos];\n        pos = (pos + 1) & (HSZ - 1);\n    }\n    \n    ll res = 0;\n    int up = (tight ? digArr[idx] : 9);\n    for (int d = 0; d <= up; d++) {\n        int nt = (tight && (d == up)) ? 1 : 0;\n        if (!st) {\n            if (d == 0) {\n                res += dp_calc(idx + 1, nt, 0, 0, 0, 1);\n            } else {\n                res += dp_calc(idx + 1, nt, 1, 0, d, d);\n            }\n        } else {\n            if (d == 0) {\n                res += dp_calc(idx + 1, nt, 1, 1, s, 0);\n            } else {\n                if (hz) {\n                    res += dp_calc(idx + 1, nt, 1, 1, s + d, 0);\n                } else {\n                    res += dp_calc(idx + 1, nt, 1, 0, s + d, p * d);\n                }\n            }\n        }\n    }\n    \n    pos = hkey & (HSZ - 1);\n    while (htUsed[pos])\n        pos = (pos + 1) & (HSZ - 1);\n    htUsed[pos] = 1;\n    htKey[pos] = cur;\n    htVal[pos] = res;\n    return res;\n}\n\nll count_beauty(int n) {\n    if (n <= 0) return 0;\n    char buf[25];\n    sprintf(buf, \"%d\", n);\n    dLen = strlen(buf);\n    for (int i = 0; i < dLen; i++) {\n        digArr[i] = buf[i] - '0';\n    }\n    memset(htUsed, 0, sizeof(htUsed));\n    return dp_calc(0, 1, 0, 0, 0, 1);\n}\n\nint beautifulNumbers(int L, int R) {\n    ll totR = count_beauty(R);\n    ll totL = count_beauty(L - 1);\n    return (int)(totR - totL);\n}","author":"Harshit Raj","submissionId":"1575165823"},[{"id":"87","similarity":0.8934099955771783,"totOverlap":2020,"longestOverlap":2}]],"89":[{"id":"89","fileName":"1575166363.txt","sourceCode":"class Solution {\npublic:\n    string s;\n    int n;\n    int fact[10][4] = {\n        {0,0,0,0}, \n        {0,0,0,0}, \n        {1,0,0,0}, \n        {0,1,0,0},\n        {2,0,0,0},\n        {0,0,1,0},\n        {1,1,0,0},\n        {0,0,0,1}, \n        {3,0,0,0}, \n        {0,2,0,0} \n    };\n    unordered_map<int, long long> memo_dp1;\n    int pack_dp1(int pos, int tight, int started, int hasZero){\n        return pos | (tight << 5) | (started << 6) | (hasZero << 7);\n    }\n    long long dp1(int pos, int tight, int started, int hasZero) {\n        if(pos == n){\n            if(started && hasZero) return 1LL;\n            else return 0LL;\n        }\n        int key = pack_dp1(pos, tight, started, hasZero);\n        if(memo_dp1.count(key)) return memo_dp1[key];\n        \n        //algorithm\n        long long res = 0;\n        int limit = tight ? (s[pos]-'0') : 9;\n        for (int d = 0; d <= limit; d++){\n            int ntight = tight;\n            if(tight && d < limit) ntight = 0;\n            int nstarted = started;\n            if(!started && d != 0) nstarted = 1; \n            int nHasZero = hasZero;\n            if(nstarted && d == 0) nHasZero = 1;\n            res += dp1(pos+1, ntight, nstarted, nHasZero);\n        }\n        memo_dp1[key] = res;\n        return res;\n    }\n    unordered_map<long long, long long> memo_dp2;\n    long long pack_dp2(int pos, int tight, int started, int sum, int exp2, int exp3, int exp5, int exp7) {\n        long long key = pos;\n        key |= ((long long)tight << 5);\n        key |= ((long long)started << 6);\n        key |= ((long long)sum << 7);\n        key |= ((long long)exp2 << 14);\n        key |= ((long long)exp3 << 20);\n        key |= ((long long)exp5 << 25);\n        key |= ((long long)exp7 << 29);\n        return key;\n    }\n    long long computeProduct(int exp2, int exp3, int exp5, int exp7) {\n        long long prod = 1;\n        for (int i = 0; i < exp2; i++) prod *= 2;\n        for (int i = 0; i < exp3; i++) prod *= 3;\n        for (int i = 0; i < exp5; i++) prod *= 5;\n        for (int i = 0; i < exp7; i++) prod *= 7;\n        return prod;\n    }\n    long long dp2(int pos, int tight, int started, int sum, int exp2, int exp3, int exp5, int exp7) {\n        if(pos == n) {\n            if(!started) return 0;\n            long long prod = computeProduct(exp2, exp3, exp5, exp7);\n            return ( (prod % sum) == 0 ? 1LL : 0LL );\n        }\n\n        //algorithm\n        long long key = pack_dp2(pos, tight, started, sum, exp2, exp3, exp5, exp7);\n        if(memo_dp2.count(key)) return memo_dp2[key];\n\n        //ultimate algorithm\n        long long res = 0;\n        int limit = tight ? (s[pos]-'0') : 9;\n        for (int d = 0; d <= limit; d++){\n            int ntight = tight;\n            if(tight && d < limit) ntight = 0;\n            if(!started) {\n                if(d == 0) {\n                    res += dp2(pos+1, ntight, 0, 0, 0, 0, 0, 0);\n                } else {\n                    int newSum = d;\n                    res += dp2(pos+1, ntight, 1, newSum, fact[d][0], fact[d][1], fact[d][2], fact[d][3]);\n                }\n            } else {\n                if(d == 0) continue;\n                int newSum = sum + d;\n                int newExp2 = exp2 + fact[d][0];\n                int newExp3 = exp3 + fact[d][1];\n                int newExp5 = exp5 + fact[d][2];\n                int newExp7 = exp7 + fact[d][3];\n                res += dp2(pos+1, ntight, 1, newSum, newExp2, newExp3, newExp5, newExp7);\n            }\n        }\n        memo_dp2[key] = res;\n        return res;\n    }\n    long long countBeautiful(long long x) {\n        if(x < 1) return 0;\n        //algorithm\n        s = to_string(x);\n        n = s.size();\n        memo_dp1.clear();\n        memo_dp2.clear();\n        long long cntWithZero = dp1(0, 1, 0, 0);\n        long long cntNoZero = dp2(0, 1, 0, 0, 0, 0, 0, 0);\n        return cntWithZero + cntNoZero;\n    }\n    int beautifulNumbers(int l, int r) {\n        int ans = countBeautiful(r) - countBeautiful(l-1);\n        return ans;\n    }\n};","author":"Koushik Debnath","submissionId":"1575166363"},[{"id":"89","similarity":0.8716417910447761,"totOverlap":2044,"longestOverlap":4}]],"104":[{"id":"104","fileName":"1575174285.txt","sourceCode":"#include <vector>\n#include <tuple>\n#include <string>\n#include <unordered_map>\nusing namespace std;\nclass Solution {\npublic:\n\n \n\nstruct StateHash {\n    size_t operator()(const tuple<int, int, int, int, int, int>& state) const {\n        auto [pos, tight, started, hasZero, sum, prod] = state;\n        size_t res = 17;\n        res = res * 31 + std::hash<int>()(pos);\n        res = res * 31 + std::hash<int>()(tight);\n        res = res * 31 + std::hash<int>()(started);\n        res = res * 31 + std::hash<int>()(hasZero);\n        res = res * 31 + std::hash<int>()(sum);\n        res = res * 31 + std::hash<int>()(prod);\n        return res;\n    }\n};\n \n\nunordered_map<tuple<int,int,int,int,int,int>, long long, StateHash> memo;\n \n\nvector<int> digits;\n \nlong long dp(int pos, int tight, int started, int hasZero, int sum, int prod) {\n    if(pos == digits.size()){\n        if(!started) return 0;\n        if(hasZero) return 1;\n        return (prod % sum == 0) ? 1LL : 0LL;\n    }\n    \n    auto state = make_tuple(pos, tight, started, hasZero, sum, prod);\n    if(memo.find(state) != memo.end())\n        return memo[state];\n    \n    long long ways = 0;\n    int limit = (tight ? digits[pos] : 9);\n    for (int d = 0; d <= limit; d++){\n        int newTight = tight && (d == limit);\n        int newStarted = started;\n        int newHasZero = hasZero;\n        int newSum = sum;\n        int newProd = prod;\n        \n        if (!started) {\n            if(d > 0){\n                newStarted = 1;\n                newSum = sum + d;\n                newProd = d;  \n            } \n        } else {\n            newSum = sum + d;\n            if(d == 0){\n                newHasZero = 1;\n                newProd = 0;\n            } else {\n                if(newHasZero)\n                    newProd = 0;\n                else\n                    newProd = prod * d;\n            }\n        }\n        \n        ways += dp(pos + 1, newTight, newStarted, newHasZero, newSum, newProd);\n    }\n    \n    memo[state] = ways;\n    return ways;\n}\n\nlong long countBeautiful(long long x) {\n    if(x <= 0) return 0;\n    digits.clear();\n    while(x){\n        digits.push_back(x % 10);\n        x /= 10;\n    }\n    reverse(digits.begin(), digits.end());\n    \n    memo.clear();\n    return dp(0, 1, 0, 0, 0, 1);\n}\n\n    int beautifulNumbers(int l, int r) {\n        return countBeautiful(r) - countBeautiful(l - 1);\n    }\n};","author":"Abhi25jk","submissionId":"1575174285"},[{"id":"104","similarity":0.8971631205673759,"totOverlap":2024,"longestOverlap":6}]],"105":[{"id":"105","fileName":"1575176180.txt","sourceCode":"digit_factors = {\n    1: (0, 0, 0, 0),\n    2: (1, 0, 0, 0),\n    3: (0, 1, 0, 0),\n    4: (2, 0, 0, 0),\n    5: (0, 0, 1, 0),\n    6: (1, 1, 0, 0),\n    7: (0, 0, 0, 1),\n    8: (3, 0, 0, 0),\n    9: (0, 2, 0, 0),\n}\n\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_beautiful_up_to(x: int) -> int:\n            digits = list(map(int, str(x)))\n            n = len(digits)\n\n            @lru_cache(maxsize=None)\n            def dp(pos, tight, started, hasZero, s, a, b, c, d):\n                if pos == n:\n                    if not started:\n                        return 0\n                    if hasZero:\n                        return 1\n                    if s <= 0:\n                        return 0\n                    prod_mod = (\n                        pow(base=2, exp=a, mod=s)\n                        * pow(base=3, exp=b, mod=s)\n                        * pow(base=5, exp=c, mod=s)\n                        * pow(base=7, exp=d, mod=s)\n                    ) % s\n                    return 1 if prod_mod == 0 else 0\n\n                total = 0\n                limit = digits[pos] if tight else 9\n\n                for dgt in range(limit + 1):\n                    ntight = tight and (dgt == limit)\n                    if not started:\n                        if dgt == 0:\n                            total += dp(pos + 1, ntight, 0, 0, 0, 0, 0, 0, 0)\n                        else:\n                            fac = digit_factors[dgt]\n                            total += dp(\n                                pos + 1,\n                                ntight,\n                                1,\n                                0,\n                                dgt,\n                                fac[0],\n                                fac[1],\n                                fac[2],\n                                fac[3],\n                            )\n                    else:\n                        if hasZero:\n                            total += dp(pos + 1, ntight, 1, 1, 0, 0, 0, 0, 0)\n                        else:\n                            if dgt == 0:\n                                total += dp(pos + 1, ntight, 1, 1, 0, 0, 0, 0, 0)\n                            else:\n                                ns = s + dgt\n                                fa, fb, fc, fd = digit_factors[dgt]\n                                total += dp(\n                                    pos + 1,\n                                    ntight,\n                                    1,\n                                    0,\n                                    ns,\n                                    a + fa,\n                                    b + fb,\n                                    c + fc,\n                                    d + fd,\n                                )\n                return total\n\n            return dp(0, 1, 0, 0, 0, 0, 0, 0, 0)\n\n        return count_beautiful_up_to(r) - count_beautiful_up_to(l - 1)\n","author":"ianCheng","submissionId":"1575176180"},[{"id":"105","similarity":0.9158664837677183,"totOverlap":2003,"longestOverlap":3}]],"116":[{"id":"116","fileName":"1575182271.txt","sourceCode":"class Solution:\n    def __init__(self):\n        self.num_str = \"\"\n        self.memo = {}\n\n    def helper(self, idx, is_tight, has_started, has_zero, digit_sum, cnt2, cnt3, cnt5, cnt7):\n        if idx == len(self.num_str):\n            if not has_started:\n                return 0\n            if has_zero:\n                return 1\n            product = (2 ** cnt2) * (3 ** cnt3) * (5 ** cnt5) * (7 ** cnt7)\n            return 1 if digit_sum != 0 and product % digit_sum == 0 else 0\n\n        key = (idx, is_tight, has_started, has_zero, digit_sum, cnt2, cnt3, cnt5, cnt7)\n        if key in self.memo:\n            return self.memo[key]\n\n        limit = int(self.num_str[idx]) if is_tight else 9\n        result = 0\n\n        for digit in range(limit + 1):\n            new_tight = is_tight and (digit == limit)\n            if not has_started:\n                if digit == 0:\n                    result += self.helper(idx + 1, new_tight, 0, 0, 0, 0, 0, 0, 0)\n                else:\n                    new_sum = digit\n                    new_cnt2 = new_cnt3 = new_cnt5 = new_cnt7 = 0\n                    temp = digit\n                    while temp % 2 == 0:\n                        new_cnt2 += 1\n                        temp //= 2\n                    while temp % 3 == 0:\n                        new_cnt3 += 1\n                        temp //= 3\n                    while temp % 5 == 0:\n                        new_cnt5 += 1\n                        temp //= 5\n                    while temp % 7 == 0:\n                        new_cnt7 += 1\n                        temp //= 7\n                    result += self.helper(idx + 1, new_tight, 1, 0, new_sum, new_cnt2, new_cnt3, new_cnt5, new_cnt7)\n            else:\n                if has_zero:\n                    result += self.helper(idx + 1, new_tight, 1, 1, digit_sum + digit, 0, 0, 0, 0)\n                else:\n                    if digit == 0:\n                        result += self.helper(idx + 1, new_tight, 1, 1, digit_sum, 0, 0, 0, 0)\n                    else:\n                        new_sum = digit_sum + digit\n                        new_cnt2, new_cnt3, new_cnt5, new_cnt7 = cnt2, cnt3, cnt5, cnt7\n                        temp = digit\n                        while temp % 2 == 0:\n                            new_cnt2 += 1\n                            temp //= 2\n                        while temp % 3 == 0:\n                            new_cnt3 += 1\n                            temp //= 3\n                        while temp % 5 == 0:\n                            new_cnt5 += 1\n                            temp //= 5\n                        while temp % 7 == 0:\n                            new_cnt7 += 1\n                            temp //= 7\n                        result += self.helper(idx + 1, new_tight, 1, 0, new_sum, new_cnt2, new_cnt3, new_cnt5, new_cnt7)\n\n        self.memo[key] = result\n        return result\n\n    def count_beautiful(self, num):\n        if num < 1:\n            return 0\n        self.num_str = str(num)\n        self.memo.clear()\n        return self.helper(0, 1, 0, 0, 0, 0, 0, 0, 0)\n        \n    def beautifulNumbers(self, left: int, right: int) -> int:\n        return self.count_beautiful(right) - self.count_beautiful(left - 1)","author":"Mohamed Abubakkar S","submissionId":"1575182271"},[{"id":"116","similarity":0.9053442028985508,"totOverlap":1999,"longestOverlap":5}]],"134":[{"id":"134","fileName":"1575188312.txt","sourceCode":"class Solution {\npublic:\n    using ll=long long;\n    string str;\n    unordered_map<ll,ll>dp;\n    ll recur(int pos,int l,int r,int q,int sum,int prod)\n    {\n        return ((ll)pos | ((ll)l<<6) | ((ll)r<<7) | ((ll)q<<8) | ((ll)sum<<9) | ((ll)prod<<16));\n    }\n    ll memo(int pos,int l,int r,int q,int sum,int prod)\n    {\n        if(pos==str.size())\n        {\n            if(!r)return 0;\n            if(q)return 1;\n            return (sum!=0 && (prod%sum==0))?1LL:0LL;\n        }\n        ll key=recur(pos,l,r,q,sum,prod);\n        if(dp.find(key)!=dp.end())return dp[key];\n        ll ans=0;\n        int lim=l?(str[pos]-'0'):9;\n        if(!r)\n        {\n            for(int i=0;i<=lim;++i)\n            {\n                ans+=(i==0)?memo(pos+1,(l && i==lim),0,0,0,1):memo(pos+1,(l && i==lim),1,0,i,i);\n            }\n        }\n        else\n        {\n            for(int i=0;i<=lim;++i)\n            {\n                int L=(l && i==lim),R=sum+i,t1=q,t2=prod;\n                if(i==0)t1=1,t2=0;\n                else if(t1==0)t2=prod*i;\n                else t2=0;\n                ans+=memo(pos+1,L,1,t1,R,t2);\n            }\n        }\n        return dp[key]=ans;\n    }\n    int beautifulNumbers(int l,int r) {\n        if(l<1) return 0;\n        str=to_string(r),dp.clear();\n        ll L=memo(0,1,0,0,0,1);\n        str=to_string(l-1),dp.clear();\n        ll R=memo(0,1,0,0,0,1);\n        return (int)(L-R);\n    }\n};","author":"Rajat","submissionId":"1575188312"},[{"id":"134","similarity":0.9195612431444241,"totOverlap":2012,"longestOverlap":2}]],"143":[{"id":"143","fileName":"1575193990.txt","sourceCode":"#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\n#define F(i, a, b) for (int i = a; i < b; i++)\n#define ll long long\n\nclass Solution {\npublic:\n    string s;\n    map<tuple<int, int, int, int, int, int>, int> dp;\n\n    int f(int p, int t, int st, int z, int sm, int pr) {\n        if (p == sz(s)) return st && (z || (sm && pr % sm == 0));\n        auto k = make_tuple(p, t, st, z, sm, pr);\n        if (dp.count(k)) return dp[k];\n        int r = 0, lim = t ? s[p] - '0' : 9;\n        F(d, 0, lim + 1) {\n            int nt = t && (d == lim);\n            if (!st) r += f(p + 1, nt, d > 0, 0, d, max(d, 1));\n            else r += f(p + 1, nt, 1, z || d == 0, sm + d, z ? 0 : pr * max(d, 1));\n        }\n        return dp[k] = r;\n    }\n\n    int cntB(int n) {\n        s = to_string(n);\n        dp.clear();\n        return f(0, 1, 0, 0, 0, 1);\n    }\n\n    int beautifulNumbers(int l, int r) {\n        return cntB(r) - cntB(l - 1);\n    }\n};","author":"Ayan","submissionId":"1575193990"},[{"id":"143","similarity":0.9426305970149254,"totOverlap":2021,"longestOverlap":6}]],"148":[{"id":"148","fileName":"1575195554.txt","sourceCode":"class Solution {\npublic:\n    int intpow(int a, int b) {\n        if (b==0)return 1;\n        else return a * intpow(a, b-1);\n    }\n\n    map<vector<int>, int> MEMO;\n    vector<int> PRE = {0,9,15,309,3675,43462,486887,5311174,57110375,607393752};\n\n    int complete(int D, int P, int S) {\n        if (D == 0) {\n            if (S > 0 && P % S == 0) {\n                return 1;\n            }\n            else return 0;\n        }\n\n        vector<int> key = {D,P,S};\n        if (MEMO.count(key)) return MEMO[key];\n\n        int ans = 0;\n        for (int d = 0; d < 10; d++) {\n            ans += complete(D - 1, P * d, S + d);\n        }\n        MEMO[key] = ans;\n        return MEMO[key];\n    }\n\n    // Compute the number of beautifulNumbers less than X\n    int solve(int X) {\n        if (X < 10) return X;\n        string s = to_string(X);\n        int P = 1;\n        int S = 0;\n        int ans = 0;\n        for (int d = 0; d < s.size(); d++) {\n            int val = 0;\n            if (d == 0) val = 1;\n            int cur = (int)(s[d] - '0');\n            for (int v = val; v < cur; v++) {\n                //D is number of remaining digits\n                int D = s.size() - d - 1;\n                ans += complete(D, P * v, S + v);\n            }\n\n            P *= cur;\n            S += cur;\n        }\n        if (S > 0 && P % S == 0) ans++;\n\n        for (int i = 1; i < s.size(); i++) {\n            ans += PRE[i];\n        }\n        return ans;\n    }\n\n    int beautifulNumbers(int l, int r) {\n        //Count the number of integers between l and r\n        // 1,2,3,4,5,6,7,8,9\n\n        int ans = solve(r) - solve(l-1);\n        return ans;\n    }\n};","author":"Shiva Oswal","submissionId":"1575195554"},[{"id":"148","similarity":0.9421487603305785,"totOverlap":2052,"longestOverlap":5}]],"160":[{"id":"160","fileName":"1575200022.txt","sourceCode":"class Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n       int SZ = 1e6;\n        int NUM = 1e3 + 5;\nstd::vector<int> blocks = {\n\t534357, 1118255, 1710151, 2301356, 2892673, 3501975, 4092976, 4685242, 5269113, 5845531, 6845531, 7424998, 8012894, 8599799, 9188585, 9794705, 10383103, 10975370, 11554907, 12130748, 13130748, 13718644, 14309961, 14905010, 15495091, 16109889, 16701330, 17301954, 17880545, 18463923, 19463923, 20050828, 20645877, 21232717, 21828687, 22443382, 23031676, 23633724, 24221945, 24795186, 25795186, 26383972, 26974053, 27570023, 28154560, 28771927, 29363036, 29966693, 30542203, 31128599, 32128599, 32734719, 33349517, 33964212, 34581579, 35183804, 35802625, 36431794, 37042547, 37651025, 38651025, 39239423, 39830864, 40419158, 41010267, 41629088, 42216864, 42825362, 43410374, 43988394, 44988394, 45580661, 46181285, 46783333, 47386990, 48016159, 48624657, 49218643, 49821259, 50422158, 51422158, 52001695, 52580286, 53168507, 53744017, 54354770, 54939782, 55542398, 56110828, 56696848, 57696848, 58272689, 58856067, 59429308, 60015704, 60624182, 61202202, 61803101, 62389121, 62955906, 63955906, 64955906, 65955906, 66955906, 67955906, 68955906, 69955906, 70955906, 71955906, 72955906, 73955906, 74531176, 75114817, 75697002, 76281136, 76883254, 77467894, 78056498, 78634152, 79206544, 80206544, 80790185, 81378971, 81969972, 82554935, 83167319, 83756878, 84355104, 84932684, 85514714, 86514714, 87096899, 87687900, 88270155, 88861596, 89472688, 90058198, 90657225, 91243661, 91814352, 92814352, 93398486, 93983449, 94574890, 95157457, 95770736, 96358957, 96961124, 97534407, 98119652, 99119652, 99721770, 100334154, 100945246, 101558525, 102159383, 102777470, 103403914, 104012150, 104619366, 105619366, 106204006, 106793565, 107379075, 107967296, 108585383, 109171779, 109780338, 110364121, 110942600, 111942600, 112531204, 113129430, 113728457, 114330624, 114957068, 115565627, 116160418, 116760079, 117360797, 118360797, 118938451, 119516031, 120102467, 120675750, 121283986, 121867769, 122467430, 123034949, 123618883, 124618883, 125191275, 125773305, 126343996, 126929241, 127536457, 128114936, 128715654, 129299588, 129867303, 130867303, 131867303, 132867303, 133867303, 134867303, 135867303, 136867303, 137867303, 138867303, 139867303, 140867303, 141450944, 142039730, 142630731, 143215694, 143828078, 144417637, 145015863, 145593443, 146175473, 147175473, 147764259, 148354340, 148950310, 149534847, 150152214, 150743323, 151346980, 151922490, 152508886, 153508886, 154099887, 154695857, 155286785, 155879410, 156501542, 157091620, 157701298, 158288288, 158868604, 159868604, 160453567, 161038104, 161630729, 162210271, 162825757, 163413439, 164017791, 164589828, 165177616, 166177616, 166790000, 167407367, 168029499, 168644985, 169257208, 169879820, 170516103, 171124268, 171741636, 172741636, 173331195, 173922304, 174512382, 175100064, 175722676, 176310904, 176923377, 177506112, 178088433, 179088433, 179686659, 180290316, 180899994, 181504346, 182140629, 182753102, 183357286, 183957649, 184567578, 185567578, 186145158, 186720668, 187307658, 187879695, 188487860, 189070595, 189670958, 190237681, 190822975, 191822975, 192405005, 192991401, 193571717, 194159505, 194776873, 195359194, 195969123, 196554417, 197130768, 198130768, 199130768, 200130768, 201130768, 202130768, 203130768, 204130768, 205130768, 206130768, 207130768, 208130768, 208712953, 209303954, 209886209, 210477650, 211088742, 211674252, 212273279, 212859715, 213430406, 214430406, 215021407, 215617377, 216208305, 216800930, 217423062, 218013140, 218622818, 219209808, 219790124, 220790124, 221372379, 221963307, 222540862, 223132615, 223745514, 224328162, 224931032, 225519260, 226088342, 227088342, 227679783, 228272408, 228864161, 229454638, 230078423, 230668605, 231282681, 231866494, 232450475, 233450475, 234061567, 234683699, 235296598, 235920383, 236534625, 237155054, 237793715, 238413625, 239019236, 240019236, 240604746, 241194824, 241777472, 242367654, 242988083, 243572259, 244183886, 244770446, 245347818, 246347818, 246946845, 247556523, 248159393, 248773469, 249412130, 250023757, 250633256, 251245752, 251846361, 252846361, 253432797, 254019787, 254608015, 255191828, 255811738, 256398298, 257010794, 257590640, 258175006, 259175006, 259745697, 260326013, 260895095, 261479076, 262084687, 262662059, 263262668, 263847034, 264413912, 265413912, 266413912, 267413912, 268413912, 269413912, 270413912, 271413912, 272413912, 273413912, 274413912, 275413912, 275998046, 276583009, 277174450, 277757017, 278370296, 278958517, 279560684, 280133967, 280719212, 281719212, 282304175, 282888712, 283481337, 284060879, 284676365, 285264047, 285868399, 286440436, 287028224, 288028224, 288619665, 289212290, 289804043, 290394520, 291018305, 291608487, 292222563, 292806376, 293390357, 294390357, 294972924, 295552466, 296142943, 296718459, 297330742, 297916180, 298519738, 299088168, 299674728, 300674728, 301288007, 301903493, 302527278, 303139561, 303755304, 304377987, 305014868, 305618081, 306237755, 307237755, 307825976, 308413658, 309003840, 309589278, 310211961, 310799274, 311414496, 311995196, 312581465, 313581465, 314183632, 314787984, 315402060, 316005618, 316642499, 317257721, 317867675, 318465373, 319079251, 320079251, 320652534, 321224571, 321808384, 322376814, 322980027, 323560727, 324158425, 324722561, 325306726, 326306726, 326891971, 327479759, 328063740, 328650300, 329269974, 329856243, 330470121, 331054286, 331635763, 332635763, 333635763, 334635763, 335635763, 336635763, 337635763, 338635763, 339635763, 340635763, 341635763, 342635763, 343237881, 343850265, 344461357, 345074636, 345675494, 346293581, 346920025, 347528261, 348135477, 349135477, 349747861, 350365228, 350987360, 351602846, 352215069, 352837681, 353473964, 354082129, 354699497, 355699497, 356310589, 356932721, 357545620, 358169405, 358783647, 359404076, 360042737, 360662647, 361268258, 362268258, 362881537, 363497023, 364120808, 364733091, 365348834, 365971517, 366608398, 367211611, 367831285, 368831285, 369432143, 370044366, 370658608, 371274351, 371873272, 372497893, 373129607, 373743459, 374359941, 375359941, 375978028, 376600640, 377221069, 377843752, 378468373, 379088899, 379732162, 380347415, 380958611, 381958611, 382585055, 383221338, 383859999, 384496880, 385128594, 385771857, 386399248, 387026385, 387656515, 388656515, 389264751, 389872916, 390492826, 391096039, 391709891, 392325144, 392952281, 393546371, 394160420, 395160420, 395767636, 396385004, 396990615, 397610289, 398226771, 398837967, 399468097, 400082146, 400677786, 401677786, 402677786, 403677786, 404677786, 405677786, 406677786, 407677786, 408677786, 409677786, 410677786, 411677786, 412262426, 412851985, 413437495, 414025716, 414643803, 415230199, 415838758, 416422541, 417001020, 418001020, 418590579, 419181688, 419771766, 420359448, 420982060, 421570288, 422182761, 422765496, 423347817, 424347817, 424933327, 425523405, 426106053, 426696235, 427316664, 427900840, 428512467, 429099027, 429676399, 430676399, 431264620, 431852302, 432442484, 433027922, 433650605, 434237918, 434853140, 435433840, 436020109, 437020109, 437638196, 438260808, 438881237, 439503920, 440128541, 440749067, 441392330, 442007583, 442618779, 443618779, 444205175, 444793403, 445377579, 445964892, 446585418, 447170489, 447784127, 448368759, 448949063, 449949063, 450557622, 451170095, 451781722, 452396944, 453040207, 453653845, 454271485, 454881757, 455488632, 456488632, 457072415, 457655150, 458241710, 458822410, 459437663, 460022295, 460632567, 461209381, 461794016, 462794016, 463372495, 463954816, 464532188, 465118457, 465729653, 466309957, 466916832, 467501467, 468074642, 469074642, 470074642, 471074642, 472074642, 473074642, 474074642, 475074642, 476074642, 477074642, 478074642, 479074642, 479663246, 480261472, 480860499, 481462666, 482089110, 482697669, 483292460, 483892121, 484492839, 485492839, 486091065, 486694722, 487304400, 487908752, 488545035, 489157508, 489761692, 490362055, 490971984, 491971984, 492571011, 493180689, 493783559, 494397635, 495036296, 495647923, 496257422, 496869918, 497470527, 498470527, 499072694, 499677046, 500291122, 500894680, 501531561, 502146783, 502756737, 503354435, 503968313, 504968313, 505594757, 506231040, 506869701, 507506582, 508138296, 508781559, 509408950, 510036087, 510666217, 511666217, 512274776, 512887249, 513498876, 514114098, 514757361, 515370999, 515988639, 516598911, 517205786, 518205786, 518800577, 519404761, 520014260, 520624214, 521251605, 521869245, 522460647, 523067393, 523676107, 524676107, 525275768, 525876131, 526488627, 527086325, 527713462, 528323734, 528930480, 529522600, 530134016, 531134016, 531734734, 532344663, 532945272, 533559150, 534189280, 534796155, 535404869, 536016285, 536609809, 537609809, 538609809, 539609809, 540609809, 541609809, 542609809, 543609809, 544609809, 545609809, 546609809, 547609809, 548187463, 548765043, 549351479, 549924762, 550532998, 551116781, 551716442, 552283961, 552867895, 553867895, 554445475, 555020985, 555607975, 556180012, 556788177, 557370912, 557971275, 558537998, 559123292, 560123292, 560709728, 561296718, 561884946, 562468759, 563088669, 563675229, 564287725, 564867571, 565451937, 566451937, 567025220, 567597257, 568181070, 568749500, 569352713, 569933413, 570531111, 571095247, 571679412, 572679412, 573287648, 573895813, 574515723, 575118936, 575732788, 576348041, 576975178, 577569268, 578183317, 579183317, 579767100, 580349835, 580936395, 581517095, 582132348, 582716980, 583327252, 583904066, 584488701, 585488701, 586088362, 586688725, 587301221, 587898919, 588526056, 589136328, 589743074, 590335194, 590946610, 591946610, 592514129, 593080852, 593660698, 594224834, 594818924, 595395738, 595987858, 596548563, 597130992, 598130992, 598714926, 599300220, 599884586, 600468751, 601082800, 601667435, 602278851, 602861280, 603442754, 604442754, 605442754, 606442754, 607442754, 608442754, 609442754, 610442754, 611442754, 612442754, 613442754, 614442754, 615015146, 615597176, 616167867, 616753112, 617360328, 617938807, 618539525, 619123459, 619691174, 620691174, 621273204, 621859600, 622439916, 623027704, 623645072, 624227393, 624837322, 625422616, 625998967, 626998967, 627569658, 628149974, 628719056, 629303037, 629908648, 630486020, 631086629, 631670995, 632237873, 633237873, 633823118, 634410906, 634994887, 635581447, 636201121, 636787390, 637401268, 637985433, 638566910, 639566910, 640174126, 640791494, 641397105, 642016779, 642633261, 643244457, 643874587, 644488636, 645084276, 646084276, 646662755, 647245076, 647822448, 648408717, 649019913, 649600217, 650207092, 650791727, 651364902, 652364902, 652965620, 653575549, 654176158, 654790036, 655420166, 656027041, 656635755, 657247171, 657840695, 658840695, 659424629, 660009923, 660594289, 661178454, 661792503, 662377138, 662988554, 663570983, 664152457, 665152457, 665720172, 666296523, 666863401, 667444878, 668040518, 668613693, 669207217, 669788691, 670349658, 670349659, 670349659, 670349659, 670349659, 670349659\n};\n auto ok = [&](int x) -> bool {\n     if (x == 0) return false;\n\t    auto s = std::to_string(x);\n\t    int p = 1;\n\t    int sum = 0;\n\t    for (auto c : s) {\n\t        p *= c - '0';\n\t        sum += c - '0';\n\t    }\n\t    return p % sum == 0;\n\t};\n    auto get = [&](int len) {\n        if (len == 0) return 0;\n    \tint b = len / SZ;\n    \tint ret = b > 0 ? blocks[b - 1] : 0;\n    \tfor (int i = b * SZ; i <= len; i++) {\n    \t\tif (ok(i)) {\n    \t\t\tret += 1;\n    \t\t}\n    \t}\n    \treturn ret;\n    };\n        return get(r) - get(l - 1);\n    }\n};\n\n\n","author":"Kai Chen","submissionId":"1575200022"},[{"id":"168","similarity":0.96697659506252,"totOverlap":3016,"longestOverlap":997}]],"168":[{"id":"168","fileName":"1575198881.txt","sourceCode":"class Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        return cumulative(r) - cumulative(l - 1);\n    }\n\n    int cumulative(int l) {\n        // count up to and including l\n        \n        const int index[] = {0, 1000000, 2000000, 3000000, 4000000, 5000000, 6000000, 7000000, 8000000, 9000000, 10000000, 11000000, 12000000, 13000000, 14000000, 15000000, 16000000, 17000000, 18000000, 19000000, 20000000, 21000000, 22000000, 23000000, 24000000, 25000000, 26000000, 27000000, 28000000, 29000000, 30000000, 31000000, 32000000, 33000000, 34000000, 35000000, 36000000, 37000000, 38000000, 39000000, 40000000, 41000000, 42000000, 43000000, 44000000, 45000000, 46000000, 47000000, 48000000, 49000000, 50000000, 51000000, 52000000, 53000000, 54000000, 55000000, 56000000, 57000000, 58000000, 59000000, 60000000, 61000000, 62000000, 63000000, 64000000, 65000000, 66000000, 67000000, 68000000, 69000000, 70000000, 71000000, 72000000, 73000000, 74000000, 75000000, 76000000, 77000000, 78000000, 79000000, 80000000, 81000000, 82000000, 83000000, 84000000, 85000000, 86000000, 87000000, 88000000, 89000000, 90000000, 91000000, 92000000, 93000000, 94000000, 95000000, 96000000, 97000000, 98000000, 99000000, 100000000, 101000000, 102000000, 103000000, 104000000, 105000000, 106000000, 107000000, 108000000, 109000000, 110000000, 111000000, 112000000, 113000000, 114000000, 115000000, 116000000, 117000000, 118000000, 119000000, 120000000, 121000000, 122000000, 123000000, 124000000, 125000000, 126000000, 127000000, 128000000, 129000000, 130000000, 131000000, 132000000, 133000000, 134000000, 135000000, 136000000, 137000000, 138000000, 139000000, 140000000, 141000000, 142000000, 143000000, 144000000, 145000000, 146000000, 147000000, 148000000, 149000000, 150000000, 151000000, 152000000, 153000000, 154000000, 155000000, 156000000, 157000000, 158000000, 159000000, 160000000, 161000000, 162000000, 163000000, 164000000, 165000000, 166000000, 167000000, 168000000, 169000000, 170000000, 171000000, 172000000, 173000000, 174000000, 175000000, 176000000, 177000000, 178000000, 179000000, 180000000, 181000000, 182000000, 183000000, 184000000, 185000000, 186000000, 187000000, 188000000, 189000000, 190000000, 191000000, 192000000, 193000000, 194000000, 195000000, 196000000, 197000000, 198000000, 199000000, 200000000, 201000000, 202000000, 203000000, 204000000, 205000000, 206000000, 207000000, 208000000, 209000000, 210000000, 211000000, 212000000, 213000000, 214000000, 215000000, 216000000, 217000000, 218000000, 219000000, 220000000, 221000000, 222000000, 223000000, 224000000, 225000000, 226000000, 227000000, 228000000, 229000000, 230000000, 231000000, 232000000, 233000000, 234000000, 235000000, 236000000, 237000000, 238000000, 239000000, 240000000, 241000000, 242000000, 243000000, 244000000, 245000000, 246000000, 247000000, 248000000, 249000000, 250000000, 251000000, 252000000, 253000000, 254000000, 255000000, 256000000, 257000000, 258000000, 259000000, 260000000, 261000000, 262000000, 263000000, 264000000, 265000000, 266000000, 267000000, 268000000, 269000000, 270000000, 271000000, 272000000, 273000000, 274000000, 275000000, 276000000, 277000000, 278000000, 279000000, 280000000, 281000000, 282000000, 283000000, 284000000, 285000000, 286000000, 287000000, 288000000, 289000000, 290000000, 291000000, 292000000, 293000000, 294000000, 295000000, 296000000, 297000000, 298000000, 299000000, 300000000, 301000000, 302000000, 303000000, 304000000, 305000000, 306000000, 307000000, 308000000, 309000000, 310000000, 311000000, 312000000, 313000000, 314000000, 315000000, 316000000, 317000000, 318000000, 319000000, 320000000, 321000000, 322000000, 323000000, 324000000, 325000000, 326000000, 327000000, 328000000, 329000000, 330000000, 331000000, 332000000, 333000000, 334000000, 335000000, 336000000, 337000000, 338000000, 339000000, 340000000, 341000000, 342000000, 343000000, 344000000, 345000000, 346000000, 347000000, 348000000, 349000000, 350000000, 351000000, 352000000, 353000000, 354000000, 355000000, 356000000, 357000000, 358000000, 359000000, 360000000, 361000000, 362000000, 363000000, 364000000, 365000000, 366000000, 367000000, 368000000, 369000000, 370000000, 371000000, 372000000, 373000000, 374000000, 375000000, 376000000, 377000000, 378000000, 379000000, 380000000, 381000000, 382000000, 383000000, 384000000, 385000000, 386000000, 387000000, 388000000, 389000000, 390000000, 391000000, 392000000, 393000000, 394000000, 395000000, 396000000, 397000000, 398000000, 399000000, 400000000, 401000000, 402000000, 403000000, 404000000, 405000000, 406000000, 407000000, 408000000, 409000000, 410000000, 411000000, 412000000, 413000000, 414000000, 415000000, 416000000, 417000000, 418000000, 419000000, 420000000, 421000000, 422000000, 423000000, 424000000, 425000000, 426000000, 427000000, 428000000, 429000000, 430000000, 431000000, 432000000, 433000000, 434000000, 435000000, 436000000, 437000000, 438000000, 439000000, 440000000, 441000000, 442000000, 443000000, 444000000, 445000000, 446000000, 447000000, 448000000, 449000000, 450000000, 451000000, 452000000, 453000000, 454000000, 455000000, 456000000, 457000000, 458000000, 459000000, 460000000, 461000000, 462000000, 463000000, 464000000, 465000000, 466000000, 467000000, 468000000, 469000000, 470000000, 471000000, 472000000, 473000000, 474000000, 475000000, 476000000, 477000000, 478000000, 479000000, 480000000, 481000000, 482000000, 483000000, 484000000, 485000000, 486000000, 487000000, 488000000, 489000000, 490000000, 491000000, 492000000, 493000000, 494000000, 495000000, 496000000, 497000000, 498000000, 499000000, 500000000, 501000000, 502000000, 503000000, 504000000, 505000000, 506000000, 507000000, 508000000, 509000000, 510000000, 511000000, 512000000, 513000000, 514000000, 515000000, 516000000, 517000000, 518000000, 519000000, 520000000, 521000000, 522000000, 523000000, 524000000, 525000000, 526000000, 527000000, 528000000, 529000000, 530000000, 531000000, 532000000, 533000000, 534000000, 535000000, 536000000, 537000000, 538000000, 539000000, 540000000, 541000000, 542000000, 543000000, 544000000, 545000000, 546000000, 547000000, 548000000, 549000000, 550000000, 551000000, 552000000, 553000000, 554000000, 555000000, 556000000, 557000000, 558000000, 559000000, 560000000, 561000000, 562000000, 563000000, 564000000, 565000000, 566000000, 567000000, 568000000, 569000000, 570000000, 571000000, 572000000, 573000000, 574000000, 575000000, 576000000, 577000000, 578000000, 579000000, 580000000, 581000000, 582000000, 583000000, 584000000, 585000000, 586000000, 587000000, 588000000, 589000000, 590000000, 591000000, 592000000, 593000000, 594000000, 595000000, 596000000, 597000000, 598000000, 599000000, 600000000, 601000000, 602000000, 603000000, 604000000, 605000000, 606000000, 607000000, 608000000, 609000000, 610000000, 611000000, 612000000, 613000000, 614000000, 615000000, 616000000, 617000000, 618000000, 619000000, 620000000, 621000000, 622000000, 623000000, 624000000, 625000000, 626000000, 627000000, 628000000, 629000000, 630000000, 631000000, 632000000, 633000000, 634000000, 635000000, 636000000, 637000000, 638000000, 639000000, 640000000, 641000000, 642000000, 643000000, 644000000, 645000000, 646000000, 647000000, 648000000, 649000000, 650000000, 651000000, 652000000, 653000000, 654000000, 655000000, 656000000, 657000000, 658000000, 659000000, 660000000, 661000000, 662000000, 663000000, 664000000, 665000000, 666000000, 667000000, 668000000, 669000000, 670000000, 671000000, 672000000, 673000000, 674000000, 675000000, 676000000, 677000000, 678000000, 679000000, 680000000, 681000000, 682000000, 683000000, 684000000, 685000000, 686000000, 687000000, 688000000, 689000000, 690000000, 691000000, 692000000, 693000000, 694000000, 695000000, 696000000, 697000000, 698000000, 699000000, 700000000, 701000000, 702000000, 703000000, 704000000, 705000000, 706000000, 707000000, 708000000, 709000000, 710000000, 711000000, 712000000, 713000000, 714000000, 715000000, 716000000, 717000000, 718000000, 719000000, 720000000, 721000000, 722000000, 723000000, 724000000, 725000000, 726000000, 727000000, 728000000, 729000000, 730000000, 731000000, 732000000, 733000000, 734000000, 735000000, 736000000, 737000000, 738000000, 739000000, 740000000, 741000000, 742000000, 743000000, 744000000, 745000000, 746000000, 747000000, 748000000, 749000000, 750000000, 751000000, 752000000, 753000000, 754000000, 755000000, 756000000, 757000000, 758000000, 759000000, 760000000, 761000000, 762000000, 763000000, 764000000, 765000000, 766000000, 767000000, 768000000, 769000000, 770000000, 771000000, 772000000, 773000000, 774000000, 775000000, 776000000, 777000000, 778000000, 779000000, 780000000, 781000000, 782000000, 783000000, 784000000, 785000000, 786000000, 787000000, 788000000, 789000000, 790000000, 791000000, 792000000, 793000000, 794000000, 795000000, 796000000, 797000000, 798000000, 799000000, 800000000, 801000000, 802000000, 803000000, 804000000, 805000000, 806000000, 807000000, 808000000, 809000000, 810000000, 811000000, 812000000, 813000000, 814000000, 815000000, 816000000, 817000000, 818000000, 819000000, 820000000, 821000000, 822000000, 823000000, 824000000, 825000000, 826000000, 827000000, 828000000, 829000000, 830000000, 831000000, 832000000, 833000000, 834000000, 835000000, 836000000, 837000000, 838000000, 839000000, 840000000, 841000000, 842000000, 843000000, 844000000, 845000000, 846000000, 847000000, 848000000, 849000000, 850000000, 851000000, 852000000, 853000000, 854000000, 855000000, 856000000, 857000000, 858000000, 859000000, 860000000, 861000000, 862000000, 863000000, 864000000, 865000000, 866000000, 867000000, 868000000, 869000000, 870000000, 871000000, 872000000, 873000000, 874000000, 875000000, 876000000, 877000000, 878000000, 879000000, 880000000, 881000000, 882000000, 883000000, 884000000, 885000000, 886000000, 887000000, 888000000, 889000000, 890000000, 891000000, 892000000, 893000000, 894000000, 895000000, 896000000, 897000000, 898000000, 899000000, 900000000, 901000000, 902000000, 903000000, 904000000, 905000000, 906000000, 907000000, 908000000, 909000000, 910000000, 911000000, 912000000, 913000000, 914000000, 915000000, 916000000, 917000000, 918000000, 919000000, 920000000, 921000000, 922000000, 923000000, 924000000, 925000000, 926000000, 927000000, 928000000, 929000000, 930000000, 931000000, 932000000, 933000000, 934000000, 935000000, 936000000, 937000000, 938000000, 939000000, 940000000, 941000000, 942000000, 943000000, 944000000, 945000000, 946000000, 947000000, 948000000, 949000000, 950000000, 951000000, 952000000, 953000000, 954000000, 955000000, 956000000, 957000000, 958000000, 959000000, 960000000, 961000000, 962000000, 963000000, 964000000, 965000000, 966000000, 967000000, 968000000, 969000000, 970000000, 971000000, 972000000, 973000000, 974000000, 975000000, 976000000, 977000000, 978000000, 979000000, 980000000, 981000000, 982000000, 983000000, 984000000, 985000000, 986000000, 987000000, 988000000, 989000000, 990000000, 991000000, 992000000, 993000000, 994000000, 995000000, 996000000, 997000000, 998000000, 999000000, 1000000000};\n        const int count[] = {0, 534358, 1118256, 1710152, 2301357, 2892674, 3501976, 4092977, 4685243, 5269114, 5845532, 6845532, 7424999, 8012895, 8599800, 9188586, 9794706, 10383104, 10975371, 11554908, 12130749, 13130749, 13718645, 14309962, 14905011, 15495092, 16109890, 16701331, 17301955, 17880546, 18463924, 19463924, 20050829, 20645878, 21232718, 21828688, 22443383, 23031677, 23633725, 24221946, 24795187, 25795187, 26383973, 26974054, 27570024, 28154561, 28771928, 29363037, 29966694, 30542204, 31128600, 32128600, 32734720, 33349518, 33964213, 34581580, 35183805, 35802626, 36431795, 37042548, 37651026, 38651026, 39239424, 39830865, 40419159, 41010268, 41629089, 42216865, 42825363, 43410375, 43988395, 44988395, 45580662, 46181286, 46783334, 47386991, 48016160, 48624658, 49218644, 49821260, 50422159, 51422159, 52001696, 52580287, 53168508, 53744018, 54354771, 54939783, 55542399, 56110829, 56696849, 57696849, 58272690, 58856068, 59429309, 60015705, 60624183, 61202203, 61803102, 62389122, 62955907, 63955907, 64955907, 65955907, 66955907, 67955907, 68955907, 69955907, 70955907, 71955907, 72955907, 73955907, 74531177, 75114818, 75697003, 76281137, 76883255, 77467895, 78056499, 78634153, 79206545, 80206545, 80790186, 81378972, 81969973, 82554936, 83167320, 83756879, 84355105, 84932685, 85514715, 86514715, 87096900, 87687901, 88270156, 88861597, 89472689, 90058199, 90657226, 91243662, 91814353, 92814353, 93398487, 93983450, 94574891, 95157458, 95770737, 96358958, 96961125, 97534408, 98119653, 99119653, 99721771, 100334155, 100945247, 101558526, 102159384, 102777471, 103403915, 104012151, 104619367, 105619367, 106204007, 106793566, 107379076, 107967297, 108585384, 109171780, 109780339, 110364122, 110942601, 111942601, 112531205, 113129431, 113728458, 114330625, 114957069, 115565628, 116160419, 116760080, 117360798, 118360798, 118938452, 119516032, 120102468, 120675751, 121283987, 121867770, 122467431, 123034950, 123618884, 124618884, 125191276, 125773306, 126343997, 126929242, 127536458, 128114937, 128715655, 129299589, 129867304, 130867304, 131867304, 132867304, 133867304, 134867304, 135867304, 136867304, 137867304, 138867304, 139867304, 140867304, 141450945, 142039731, 142630732, 143215695, 143828079, 144417638, 145015864, 145593444, 146175474, 147175474, 147764260, 148354341, 148950311, 149534848, 150152215, 150743324, 151346981, 151922491, 152508887, 153508887, 154099888, 154695858, 155286786, 155879411, 156501543, 157091621, 157701299, 158288289, 158868605, 159868605, 160453568, 161038105, 161630730, 162210272, 162825758, 163413440, 164017792, 164589829, 165177617, 166177617, 166790001, 167407368, 168029500, 168644986, 169257209, 169879821, 170516104, 171124269, 171741637, 172741637, 173331196, 173922305, 174512383, 175100065, 175722677, 176310905, 176923378, 177506113, 178088434, 179088434, 179686660, 180290317, 180899995, 181504347, 182140630, 182753103, 183357287, 183957650, 184567579, 185567579, 186145159, 186720669, 187307659, 187879696, 188487861, 189070596, 189670959, 190237682, 190822976, 191822976, 192405006, 192991402, 193571718, 194159506, 194776874, 195359195, 195969124, 196554418, 197130769, 198130769, 199130769, 200130769, 201130769, 202130769, 203130769, 204130769, 205130769, 206130769, 207130769, 208130769, 208712954, 209303955, 209886210, 210477651, 211088743, 211674253, 212273280, 212859716, 213430407, 214430407, 215021408, 215617378, 216208306, 216800931, 217423063, 218013141, 218622819, 219209809, 219790125, 220790125, 221372380, 221963308, 222540863, 223132616, 223745515, 224328163, 224931033, 225519261, 226088343, 227088343, 227679784, 228272409, 228864162, 229454639, 230078424, 230668606, 231282682, 231866495, 232450476, 233450476, 234061568, 234683700, 235296599, 235920384, 236534626, 237155055, 237793716, 238413626, 239019237, 240019237, 240604747, 241194825, 241777473, 242367655, 242988084, 243572260, 244183887, 244770447, 245347819, 246347819, 246946846, 247556524, 248159394, 248773470, 249412131, 250023758, 250633257, 251245753, 251846362, 252846362, 253432798, 254019788, 254608016, 255191829, 255811739, 256398299, 257010795, 257590641, 258175007, 259175007, 259745698, 260326014, 260895096, 261479077, 262084688, 262662060, 263262669, 263847035, 264413913, 265413913, 266413913, 267413913, 268413913, 269413913, 270413913, 271413913, 272413913, 273413913, 274413913, 275413913, 275998047, 276583010, 277174451, 277757018, 278370297, 278958518, 279560685, 280133968, 280719213, 281719213, 282304176, 282888713, 283481338, 284060880, 284676366, 285264048, 285868400, 286440437, 287028225, 288028225, 288619666, 289212291, 289804044, 290394521, 291018306, 291608488, 292222564, 292806377, 293390358, 294390358, 294972925, 295552467, 296142944, 296718460, 297330743, 297916181, 298519739, 299088169, 299674729, 300674729, 301288008, 301903494, 302527279, 303139562, 303755305, 304377988, 305014869, 305618082, 306237756, 307237756, 307825977, 308413659, 309003841, 309589279, 310211962, 310799275, 311414497, 311995197, 312581466, 313581466, 314183633, 314787985, 315402061, 316005619, 316642500, 317257722, 317867676, 318465374, 319079252, 320079252, 320652535, 321224572, 321808385, 322376815, 322980028, 323560728, 324158426, 324722562, 325306727, 326306727, 326891972, 327479760, 328063741, 328650301, 329269975, 329856244, 330470122, 331054287, 331635764, 332635764, 333635764, 334635764, 335635764, 336635764, 337635764, 338635764, 339635764, 340635764, 341635764, 342635764, 343237882, 343850266, 344461358, 345074637, 345675495, 346293582, 346920026, 347528262, 348135478, 349135478, 349747862, 350365229, 350987361, 351602847, 352215070, 352837682, 353473965, 354082130, 354699498, 355699498, 356310590, 356932722, 357545621, 358169406, 358783648, 359404077, 360042738, 360662648, 361268259, 362268259, 362881538, 363497024, 364120809, 364733092, 365348835, 365971518, 366608399, 367211612, 367831286, 368831286, 369432144, 370044367, 370658609, 371274352, 371873273, 372497894, 373129608, 373743460, 374359942, 375359942, 375978029, 376600641, 377221070, 377843753, 378468374, 379088900, 379732163, 380347416, 380958612, 381958612, 382585056, 383221339, 383860000, 384496881, 385128595, 385771858, 386399249, 387026386, 387656516, 388656516, 389264752, 389872917, 390492827, 391096040, 391709892, 392325145, 392952282, 393546372, 394160421, 395160421, 395767637, 396385005, 396990616, 397610290, 398226772, 398837968, 399468098, 400082147, 400677787, 401677787, 402677787, 403677787, 404677787, 405677787, 406677787, 407677787, 408677787, 409677787, 410677787, 411677787, 412262427, 412851986, 413437496, 414025717, 414643804, 415230200, 415838759, 416422542, 417001021, 418001021, 418590580, 419181689, 419771767, 420359449, 420982061, 421570289, 422182762, 422765497, 423347818, 424347818, 424933328, 425523406, 426106054, 426696236, 427316665, 427900841, 428512468, 429099028, 429676400, 430676400, 431264621, 431852303, 432442485, 433027923, 433650606, 434237919, 434853141, 435433841, 436020110, 437020110, 437638197, 438260809, 438881238, 439503921, 440128542, 440749068, 441392331, 442007584, 442618780, 443618780, 444205176, 444793404, 445377580, 445964893, 446585419, 447170490, 447784128, 448368760, 448949064, 449949064, 450557623, 451170096, 451781723, 452396945, 453040208, 453653846, 454271486, 454881758, 455488633, 456488633, 457072416, 457655151, 458241711, 458822411, 459437664, 460022296, 460632568, 461209382, 461794017, 462794017, 463372496, 463954817, 464532189, 465118458, 465729654, 466309958, 466916833, 467501468, 468074643, 469074643, 470074643, 471074643, 472074643, 473074643, 474074643, 475074643, 476074643, 477074643, 478074643, 479074643, 479663247, 480261473, 480860500, 481462667, 482089111, 482697670, 483292461, 483892122, 484492840, 485492840, 486091066, 486694723, 487304401, 487908753, 488545036, 489157509, 489761693, 490362056, 490971985, 491971985, 492571012, 493180690, 493783560, 494397636, 495036297, 495647924, 496257423, 496869919, 497470528, 498470528, 499072695, 499677047, 500291123, 500894681, 501531562, 502146784, 502756738, 503354436, 503968314, 504968314, 505594758, 506231041, 506869702, 507506583, 508138297, 508781560, 509408951, 510036088, 510666218, 511666218, 512274777, 512887250, 513498877, 514114099, 514757362, 515371000, 515988640, 516598912, 517205787, 518205787, 518800578, 519404762, 520014261, 520624215, 521251606, 521869246, 522460648, 523067394, 523676108, 524676108, 525275769, 525876132, 526488628, 527086326, 527713463, 528323735, 528930481, 529522601, 530134017, 531134017, 531734735, 532344664, 532945273, 533559151, 534189281, 534796156, 535404870, 536016286, 536609810, 537609810, 538609810, 539609810, 540609810, 541609810, 542609810, 543609810, 544609810, 545609810, 546609810, 547609810, 548187464, 548765044, 549351480, 549924763, 550532999, 551116782, 551716443, 552283962, 552867896, 553867896, 554445476, 555020986, 555607976, 556180013, 556788178, 557370913, 557971276, 558537999, 559123293, 560123293, 560709729, 561296719, 561884947, 562468760, 563088670, 563675230, 564287726, 564867572, 565451938, 566451938, 567025221, 567597258, 568181071, 568749501, 569352714, 569933414, 570531112, 571095248, 571679413, 572679413, 573287649, 573895814, 574515724, 575118937, 575732789, 576348042, 576975179, 577569269, 578183318, 579183318, 579767101, 580349836, 580936396, 581517096, 582132349, 582716981, 583327253, 583904067, 584488702, 585488702, 586088363, 586688726, 587301222, 587898920, 588526057, 589136329, 589743075, 590335195, 590946611, 591946611, 592514130, 593080853, 593660699, 594224835, 594818925, 595395739, 595987859, 596548564, 597130993, 598130993, 598714927, 599300221, 599884587, 600468752, 601082801, 601667436, 602278852, 602861281, 603442755, 604442755, 605442755, 606442755, 607442755, 608442755, 609442755, 610442755, 611442755, 612442755, 613442755, 614442755, 615015147, 615597177, 616167868, 616753113, 617360329, 617938808, 618539526, 619123460, 619691175, 620691175, 621273205, 621859601, 622439917, 623027705, 623645073, 624227394, 624837323, 625422617, 625998968, 626998968, 627569659, 628149975, 628719057, 629303038, 629908649, 630486021, 631086630, 631670996, 632237874, 633237874, 633823119, 634410907, 634994888, 635581448, 636201122, 636787391, 637401269, 637985434, 638566911, 639566911, 640174127, 640791495, 641397106, 642016780, 642633262, 643244458, 643874588, 644488637, 645084277, 646084277, 646662756, 647245077, 647822449, 648408718, 649019914, 649600218, 650207093, 650791728, 651364903, 652364903, 652965621, 653575550, 654176159, 654790037, 655420167, 656027042, 656635756, 657247172, 657840696, 658840696, 659424630, 660009924, 660594290, 661178455, 661792504, 662377139, 662988555, 663570984, 664152458, 665152458, 665720173, 666296524, 666863402, 667444879, 668040519, 668613694, 669207218, 669788692, 670349659};\n\n        //cout << sizeof(count) / sizeof(*count) << \"n\";\n        //cout << sizeof(index) / sizeof(*index) << \"n\";\n        int start = 0;\n        int ans = 0;\n        for (int i = 0; l >= index[i + 1]; i++) {\n            start = index[i];\n            ans = count[i];\n        }\n        for (int i = start + 1; i <= l; i++) {\n            ans += isBeautiful(i);\n        }\n        return ans;\n    }\n\n    bool isBeautiful(int i) {\n        int prod = 1;\n        int sum = 0;\n        while (i > 0) {\n            prod *= (i % 10);\n            sum += (i % 10);\n            i /= 10;\n        }\n        return prod % sum ==  0;\n    }\n};","author":"allen_nie","submissionId":"1575198881"},[{"id":"443","similarity":0.9794278367084539,"totOverlap":3047,"longestOverlap":993},{"id":"367","similarity":0.9774629748873149,"totOverlap":3036,"longestOverlap":996},{"id":"168","similarity":0.9780857234933935,"totOverlap":3035,"longestOverlap":993},{"id":"366","similarity":0.9764135702746365,"totOverlap":3022,"longestOverlap":998},{"id":"160","similarity":0.96697659506252,"totOverlap":3016,"longestOverlap":997},{"id":"436","similarity":0.9662596401028277,"totOverlap":3007,"longestOverlap":994},{"id":"315","similarity":0.9589085072231139,"totOverlap":2987,"longestOverlap":993},{"id":"299","similarity":0.9641904761904762,"totOverlap":2531,"longestOverlap":495},{"id":"360","similarity":0.9625228519195612,"totOverlap":2106,"longestOverlap":94},{"id":"168","similarity":0.872874149659864,"totOverlap":2053,"longestOverlap":5},{"id":"168","similarity":0.9421487603305785,"totOverlap":2052,"longestOverlap":5},{"id":"209","similarity":0.8820998278829604,"totOverlap":2050,"longestOverlap":5},{"id":"308","similarity":0.9026431718061674,"totOverlap":2049,"longestOverlap":5},{"id":"168","similarity":0.8716417910447761,"totOverlap":2044,"longestOverlap":4},{"id":"246","similarity":0.895292564892213,"totOverlap":2035,"longestOverlap":5},{"id":"326","similarity":0.8779119930974978,"totOverlap":2035,"longestOverlap":8},{"id":"342","similarity":0.8976621085134538,"totOverlap":2035,"longestOverlap":8},{"id":"329","similarity":0.9287345820009136,"totOverlap":2033,"longestOverlap":7},{"id":"379","similarity":0.9169675090252708,"totOverlap":2032,"longestOverlap":5},{"id":"301","similarity":0.8939260563380281,"totOverlap":2031,"longestOverlap":4},{"id":"223","similarity":0.9323827046918123,"totOverlap":2027,"longestOverlap":6},{"id":"378","similarity":0.9068934646374217,"totOverlap":2026,"longestOverlap":4},{"id":"264","similarity":0.9012016021361816,"totOverlap":2025,"longestOverlap":5},{"id":"168","similarity":0.8971631205673759,"totOverlap":2024,"longestOverlap":6},{"id":"225","similarity":0.8830715532286213,"totOverlap":2024,"longestOverlap":5},{"id":"168","similarity":0.8903083700440528,"totOverlap":2021,"longestOverlap":5},{"id":"168","similarity":0.9426305970149254,"totOverlap":2021,"longestOverlap":6},{"id":"281","similarity":0.930907415937356,"totOverlap":2021,"longestOverlap":5},{"id":"437","similarity":0.9232526267702147,"totOverlap":2021,"longestOverlap":7},{"id":"168","similarity":0.8934099955771783,"totOverlap":2020,"longestOverlap":2},{"id":"230","similarity":0.9005352363960749,"totOverlap":2019,"longestOverlap":8},{"id":"261","similarity":0.9181073703366697,"totOverlap":2018,"longestOverlap":5},{"id":"168","similarity":0.9000446229361893,"totOverlap":2017,"longestOverlap":2},{"id":"265","similarity":0.9192886456908345,"totOverlap":2016,"longestOverlap":3},{"id":"168","similarity":0.923006416131989,"totOverlap":2014,"longestOverlap":2},{"id":"327","similarity":0.8883987648875166,"totOverlap":2014,"longestOverlap":4},{"id":"168","similarity":0.9047191011235955,"totOverlap":2013,"longestOverlap":3},{"id":"168","similarity":0.8824561403508772,"totOverlap":2012,"longestOverlap":2},{"id":"168","similarity":0.9195612431444241,"totOverlap":2012,"longestOverlap":2},{"id":"178","similarity":0.9345099860659545,"totOverlap":2012,"longestOverlap":3},{"id":"268","similarity":0.8994188645507376,"totOverlap":2012,"longestOverlap":2},{"id":"208","similarity":0.9292975970425139,"totOverlap":2011,"longestOverlap":2},{"id":"260","similarity":0.901705565529623,"totOverlap":2009,"longestOverlap":2},{"id":"168","similarity":0.8959356855739169,"totOverlap":2006,"longestOverlap":3},{"id":"168","similarity":0.9038808664259927,"totOverlap":2003,"longestOverlap":9},{"id":"168","similarity":0.9158664837677183,"totOverlap":2003,"longestOverlap":3},{"id":"184","similarity":0.918732782369146,"totOverlap":2001,"longestOverlap":9},{"id":"236","similarity":0.9398778769375293,"totOverlap":2001,"longestOverlap":9},{"id":"287","similarity":0.9354838709677419,"totOverlap":2001,"longestOverlap":9},{"id":"204","similarity":0.9095043201455207,"totOverlap":2000,"longestOverlap":3},{"id":"237","similarity":0.9385265133740028,"totOverlap":2000,"longestOverlap":2},{"id":"266","similarity":0.9062075215224287,"totOverlap":2000,"longestOverlap":4},{"id":"168","similarity":0.9053442028985508,"totOverlap":1999,"longestOverlap":5},{"id":"205","similarity":0.9123687813783661,"totOverlap":1999,"longestOverlap":4},{"id":"280","similarity":0.9148741418764302,"totOverlap":1999,"longestOverlap":3}]],"178":[{"id":"178","fileName":"1575204620.txt","sourceCode":"class Solution {\npublic:\n    // long long dp[10][100][100][2][2];\n    unordered_map<string, int>dp;\n    long long solve(string str, int i, long long p, int s, int tight, int lead){\n           if(i == (int)str.size()){\n                if(lead) return 0;\n                if(s == 0) return 0;\n                if(p%s == 0) return 1;\n                 return 0;\n           }\n         int ub = tight ? (str[i]-'0') : 9;\n        string ok = to_string(i) + \"*\" + to_string(p) + \"*\" + to_string(s) + \"*\" + to_string(tight) + \"*\" + to_string(lead);\n         if(dp.count(ok)) return dp[ok];\n        long long ans = 0;\n         for(int d = 0; d <= ub; d++){\n               if(lead && d == 0){\n                    ans += solve(str, i+1, (p), s, tight&(d == ub), 1);\n               }\n               else\n               ans += solve(str, i+1, (p*1LL*d), s+d, tight&(d == ub), lead & (d == 0));\n         }\n         return dp[ok] = ans;\n    }\n    int beautifulNumbers(int l, int r) {\n      // memset(dp, -1, sizeof(dp));\n      long long R = solve(to_string(r), 0, 1, 0, 1, 1);\n         // memset(dp, -1, sizeof(dp));\n        dp.clear();\n      long long L = solve(to_string(l-1), 0, 1, 0, 1, 1);\n        return R - L;\n    }\n};","author":"Ram Krishna Kumar","submissionId":"1575204620"},[{"id":"168","similarity":0.9345099860659545,"totOverlap":2012,"longestOverlap":3}]],"184":[{"id":"184","fileName":"1575206730.txt","sourceCode":"class Solution:\n    def count(self, X):\n        factors = {\n            1: (0, 0, 0, 0),\n            2: (1, 0, 0, 0),\n            3: (0, 1, 0, 0),\n            4: (2, 0, 0, 0),\n            5: (0, 0, 1, 0),\n            6: (1, 1, 0, 0),\n            7: (0, 0, 0, 1),\n            8: (3, 0, 0, 0),\n            9: (0, 2, 0, 0)\n        }\n        s = str(X)\n        n = len(s)\n    \n        @lru_cache(maxsize=None)\n        def dp(pos: int, tight: bool, started: bool, has_zero: bool, sum_val: int,\n               ex2: int, ex3: int, ex5: int, ex7: int) -> int:\n            # If we've placed all digits:\n            if pos == n:\n                # We must have started the number (we ignore the \"all zeros\" case)\n                if not started:\n                    return 0\n                # If a zero has been placed, product is 0 and 0 is divisible by any nonzero sum.\n                if has_zero:\n                    return 1\n                # Otherwise, compute product modulo sum_val.\n                # Since all digits are nonzero, sum_val > 0.\n                prod_mod = (pow(2, ex2, sum_val) * pow(3, ex3, sum_val) *\n                            pow(5, ex5, sum_val) * pow(7, ex7, sum_val)) % sum_val\n                return 1 if prod_mod == 0 else 0\n            \n            total = 0\n            # Determine the digit we can go up to\n            limit = int(s[pos]) if tight else 9\n            \n            for d in range(0, limit + 1):\n                new_tight = tight and (d == limit)\n                if not started:\n                    # We haven't started the number; we can still choose a 0 without \"starting\"\n                    if d == 0:\n                        total += dp(pos + 1, new_tight, False, False, 0, 0, 0, 0, 0)\n                    else:\n                        # Start the number with a nonzero digit d\n                        fac = factors[d]\n                        total += dp(pos + 1, new_tight, True, False, d, fac[0], fac[1], fac[2], fac[3])\n                else:\n                    # Already started\n                    if has_zero:\n                        # Once we have a zero digit, the product is 0.\n                        total += dp(pos + 1, new_tight, True, True, sum_val + d, 0, 0, 0, 0)\n                    else:\n                        if d == 0:\n                            # A zero appears and makes has_zero True. (Note: sum does not change because 0 adds nothing.)\n                            total += dp(pos + 1, new_tight, True, True, sum_val, 0, 0, 0, 0)\n                        else:\n                            fac = factors[d]\n                            total += dp(pos + 1, new_tight, True, False, sum_val + d,\n                                        ex2 + fac[0], ex3 + fac[1], ex5 + fac[2], ex7 + fac[3])\n            return total\n        \n        return dp(0, True, False, False, 0, 0, 0, 0, 0)\n    \n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return self.count(r) - self.count(l - 1)\n","author":"Tsung Han Wu","submissionId":"1575206730"},[{"id":"168","similarity":0.918732782369146,"totOverlap":2001,"longestOverlap":9}]],"204":[{"id":"204","fileName":"1575212663.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        s = \"\"\n        dp = {}\n        \n        def rec(pos, tight, started, has_zero, sum_digits, e2, e3, e5, e7):\n            if pos == len(s):\n                if not started:\n                    return 0\n                if has_zero:\n                    return 1\n                    \n                prod = 1\n                for _ in range(e2):\n                    prod *= 2\n                for _ in range(e3):\n                    prod *= 3\n                for _ in range(e5):\n                    prod *= 5\n                for _ in range(e7):\n                    prod *= 7\n                    \n                return 1 if (sum_digits != 0 and prod % sum_digits == 0) else 0\n            \n            key = (pos, tight, started, has_zero, sum_digits, e2, e3, e5, e7)\n            if key in dp:\n                return dp[key]\n            \n            res = 0\n            limit = int(s[pos]) if tight else 9\n            \n            for d in range(limit + 1):\n                ntight = tight and (d == limit)\n                \n                if not started:\n                    if d == 0:\n                        res += rec(pos + 1, ntight, 0, 0, 0, 0, 0, 0, 0)\n                    else:\n                        new_sum = d\n                        new_e2, new_e3, new_e5, new_e7 = 0, 0, 0, 0\n                        temp = d\n                        \n                        while temp % 2 == 0:\n                            new_e2 += 1\n                            temp //= 2\n                        while temp % 3 == 0:\n                            new_e3 += 1\n                            temp //= 3\n                        while temp % 5 == 0:\n                            new_e5 += 1\n                            temp //= 5\n                        while temp % 7 == 0:\n                            new_e7 += 1\n                            temp //= 7\n                            \n                        res += rec(pos + 1, ntight, 1, 0, new_sum, new_e2, new_e3, new_e5, new_e7)\n                else:\n                    if has_zero:\n                        new_sum = sum_digits + d\n                        res += rec(pos + 1, ntight, 1, 1, new_sum, 0, 0, 0, 0)\n                    else:\n                        if d == 0:\n                            new_sum = sum_digits\n                            res += rec(pos + 1, ntight, 1, 1, new_sum, 0, 0, 0, 0)\n                        else:\n                            new_sum = sum_digits + d\n                            new_e2, new_e3, new_e5, new_e7 = e2, e3, e5, e7\n                            temp = d\n                            \n                            while temp % 2 == 0:\n                                new_e2 += 1\n                                temp //= 2\n                            while temp % 3 == 0:\n                                new_e3 += 1\n                                temp //= 3\n                            while temp % 5 == 0:\n                                new_e5 += 1\n                                temp //= 5\n                            while temp % 7 == 0:\n                                new_e7 += 1\n                                temp //= 7\n                                \n                            res += rec(pos + 1, ntight, 1, 0, new_sum, new_e2, new_e3, new_e5, new_e7)\n            \n            dp[key] = res\n            return res\n            \n        def countBeautiful(x):\n            if x < 1:\n                return 0\n                \n            nonlocal s, dp\n            s = str(x)\n            dp = {}\n            return rec(0, 1, 0, 0, 0, 0, 0, 0, 0)\n        \n        return countBeautiful(r) - countBeautiful(l - 1)","author":"Alex","submissionId":"1575212663"},[{"id":"168","similarity":0.9095043201455207,"totOverlap":2000,"longestOverlap":3}]],"205":[{"id":"205","fileName":"1575213559.txt","sourceCode":"class Solution:\n    def __init__(self):\n        self.s = \"\"\n        self.dp = {}\n\n    def rec(self, pos, tight, started, has_zero, s, e2, e3, e5, e7):\n        if pos == len(self.s):\n            if not started:\n                return 0\n            if has_zero:\n                return 1\n            prod = (2 ** e2) * (3 ** e3) * (5 ** e5) * (7 ** e7)\n            return 1 if s and prod % s == 0 else 0\n\n        key = (pos, tight, started, has_zero, s, e2, e3, e5, e7)\n        if key in self.dp:\n            return self.dp[key]\n\n        res = 0\n        limit = int(self.s[pos]) if tight else 9\n        for d in range(limit + 1):\n            ntight = tight and (d == limit)\n            if not started:\n                if d == 0:\n                    res += self.rec(pos + 1, ntight, 0, 0, 0, 0, 0, 0, 0)\n                else:\n                    temp, ne2, ne3, ne5, ne7 = d, 0, 0, 0, 0\n                    while temp % 2 == 0: ne2 += 1; temp //= 2\n                    while temp % 3 == 0: ne3 += 1; temp //= 3\n                    while temp % 5 == 0: ne5 += 1; temp //= 5\n                    while temp % 7 == 0: ne7 += 1; temp //= 7\n                    res += self.rec(pos + 1, ntight, 1, 0, d, ne2, ne3, ne5, ne7)\n            else:\n                new_sum = s + d\n                if has_zero or d == 0:\n                    res += self.rec(pos + 1, ntight, 1, 1, new_sum, 0, 0, 0, 0)\n                else:\n                    temp, ne2, ne3, ne5, ne7 = d, e2, e3, e5, e7\n                    while temp % 2 == 0: ne2 += 1; temp //= 2\n                    while temp % 3 == 0: ne3 += 1; temp //= 3\n                    while temp % 5 == 0: ne5 += 1; temp //= 5\n                    while temp % 7 == 0: ne7 += 1; temp //= 7\n                    res += self.rec(pos + 1, ntight, 1, 0, new_sum, ne2, ne3, ne5, ne7)\n\n        self.dp[key] = res\n        return res\n\n    def countBeautiful(self, x):\n        if x < 1:\n            return 0\n        self.s = str(x)\n        self.dp.clear()\n        return self.rec(0, 1, 0, 0, 0, 0, 0, 0, 0)\n\n    def beautifulNumbers(self, l, r):\n        return self.countBeautiful(r) - self.countBeautiful(l - 1)\n","author":"Rajiv Ratan","submissionId":"1575213559"},[{"id":"168","similarity":0.9123687813783661,"totOverlap":1999,"longestOverlap":4}]],"208":[{"id":"208","fileName":"1575213945.txt","sourceCode":"class Solution {\n    String s;\n    Map<String, Long> map;\n\n    long countBeautiful(int X) {\n        s = Integer.toString(X);\n        map = new HashMap<>();\n        return func(0, 1, 0, 0, 0, 1);\n    }\n\n    int beautifulNumbers(int l, int r) {\n        long ans =  (countBeautiful(r) - (l > 1 ? countBeautiful(l - 1) : 0));\n        return (int)ans;\n    }\n\n    long func(int ind, int tight, int st, int zero, int sum, int pro) {\n        if (ind == s.length()) {\n            if (st == 0) return 0;\n            if (zero == 1) return 1;\n            return (pro % sum == 0) ? 1 : 0;\n        }\n        String key = ind + \"/\" + tight + \"/\" + st + \"/\" + zero + \"*\" + sum + \"+\" + pro;\n        if (map.containsKey(key)) return map.get(key);\n        long res = 0;\n        int lim = tight == 1 ? s.charAt(ind) - '0' : 9;\n        for (int d = 0; d <= lim; d++) {\n            int ntight = (tight == 1 && (d == lim)) ? 1 : 0;\n            if (st == 0) {\n                if (d == 0) res += func(ind + 1, ntight, 0, 0, 0, 1);\n                else res += func(ind + 1, ntight, 1, 0, d, d);\n            } else {\n                int isZero = zero;\n                if (d == 0) isZero = 1;\n                res += func(ind + 1, ntight, 1, isZero, sum + d, (d == 0 ? 0 : pro * d));\n            }\n        }\n        map.put(key, res);\n        return res;\n    }\n\n    \n}","author":"Atindraa Sk","submissionId":"1575213945"},[{"id":"168","similarity":0.9292975970425139,"totOverlap":2011,"longestOverlap":2}]],"209":[{"id":"209","fileName":"1575214476.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    typedef long long ll;\n    string s;\n    unordered_map<ll, ll> dp;\n\n    ll generateKey(int pos, int tight, int started, int hasZero, int sum, int e2, int e3, int e5, int e7) {\n        ll key = pos;\n        key |= ((ll)tight << 4);\n        key |= ((ll)started << 5);\n        key |= ((ll)hasZero << 6);\n        key |= ((ll)sum << 7);\n        key |= ((ll)e2 << (7 + 7));\n        key |= ((ll)e3 << (7 + 7 + 6));\n        key |= ((ll)e5 << (7 + 7 + 6 + 6));\n        key |= ((ll)e7 << (7 + 7 + 6 + 6 + 5));\n        return key;\n    }\n\n    bool isValid(int sum, int e2, int e3, int e5, int e7) {\n        if (sum == 0) return false;\n        int prod = 1;\n        for (int i = 0; i < e2; i++) prod *= 2;\n        for (int i = 0; i < e3; i++) prod *= 3;\n        for (int i = 0; i < e5; i++) prod *= 5;\n        for (int i = 0; i < e7; i++) prod *= 7;\n        return (prod % sum == 0);\n    }\n\n    tuple<int, int, int, int> calculatePrimeFactors(int num) {\n        int e2 = 0, e3 = 0, e5 = 0, e7 = 0;\n        while (num % 2 == 0) { e2++; num /= 2; }\n        while (num % 3 == 0) { e3++; num /= 3; }\n        while (num % 5 == 0) { e5++; num /= 5; }\n        while (num % 7 == 0) { e7++; num /= 7; }\n        return {e2, e3, e5, e7};\n    }\n\n    ll rec(int pos, int tight, int started, int hasZero, int sum, int e2, int e3, int e5, int e7) {\n        if (pos == s.size()) {\n            return started && (hasZero || isValid(sum, e2, e3, e5, e7)) ? 1 : 0;\n        }\n\n        ll key = generateKey(pos, tight, started, hasZero, sum, e2, e3, e5, e7);\n        if (dp.find(key) != dp.end()) return dp[key];\n\n        ll res = 0;\n        int limit = tight ? s[pos] - '0' : 9;\n        for (int d = 0; d <= limit; d++) {\n            int ntight = tight && (d == limit);\n            res += processDigit(pos, ntight, started, hasZero, sum, e2, e3, e5, e7, d);\n        }\n        return dp[key] = res;\n    }\n\n    ll processDigit(int pos, int ntight, int started, int hasZero, int sum, int e2, int e3, int e5, int e7, int d) {\n        if (!started) {\n            return (d == 0) ? rec(pos + 1, ntight, 0, 0, 0, 0, 0, 0, 0)\n                            : rec(pos + 1, ntight, 1, 0, d, get<0>(calculatePrimeFactors(d)), get<1>(calculatePrimeFactors(d)), get<2>(calculatePrimeFactors(d)), get<3>(calculatePrimeFactors(d)));\n        }\n        if (hasZero) {\n            return rec(pos + 1, ntight, 1, 1, sum + d, 0, 0, 0, 0);\n        }\n        if (d == 0) {\n            return rec(pos + 1, ntight, 1, 1, sum, 0, 0, 0, 0);\n        }\n        auto [new_e2, new_e3, new_e5, new_e7] = calculatePrimeFactors(d);\n        return rec(pos + 1, ntight, 1, 0, sum + d, e2 + new_e2, e3 + new_e3, e5 + new_e5, e7 + new_e7);\n    }\n\n    ll countBeautiful(ll x) {\n        if (x < 1) return 0;\n        s = to_string(x);\n        dp.clear();\n        return rec(0, 1, 0, 0, 0, 0, 0, 0, 0);\n    }\n\n    int beautifulNumbers(int l, int r) {\n        return static_cast<int>(countBeautiful(r) - countBeautiful(l - 1));\n    }\n};\n","author":"edward7780","submissionId":"1575214476"},[{"id":"168","similarity":0.8820998278829604,"totOverlap":2050,"longestOverlap":5}]],"223":[{"id":"223","fileName":"1575218369.txt","sourceCode":"typedef long long ll;\n\nclass Solution {\nprivate:\n    string digits;\n    unordered_map<string, ll> memo;\n\npublic:\n\n    ll dp(int pos, int tight, int started, int hasZero, int sum, int prod)\n    {\n        if (pos == digits.size())\n        {\n            if (!started)\n                return 0;\n            if (hasZero)\n                return 1;\n            return (sum != 0 && prod % sum == 0) ? 1 : 0;\n        }\n    \n        string key = to_string(pos) + \"_\" + to_string(tight) + \"_\" +\n                     to_string(started) + \"_\" + to_string(hasZero) + \"_\" +\n                     to_string(sum) + \"_\" + to_string(prod);\n    \n        if (memo.find(key) != memo.end())\n            return memo[key];\n    \n        ll res = 0;\n        int limit = tight ? digits[pos] - '0' : 9;\n    \n        for (int d = 0; d <= limit; d++)\n        {\n            int ntight = tight && (d == limit);\n            int nstarted = started;\n            int nhasZero = hasZero;\n            int nsum = sum;\n            int nprod = prod;\n    \n            if (!started)\n            {\n                if (d == 0)\n                {\n                    res += dp(pos + 1, ntight, 0, 0, 0, 1);\n                    continue;\n                }\n                else\n                {\n                    nstarted = 1;\n                    nsum = d;\n                    nprod = d;\n                }\n            }\n            else\n            {\n                nsum += d;\n                if (d == 0)\n                {\n                    nhasZero = 1;\n                    nprod = 0;\n                }\n                else\n                {\n                    if (nhasZero)\n                        nprod = 0;\n                    else\n                        nprod *= d;\n                }\n            }\n    \n            res += dp(pos + 1, ntight, nstarted, nhasZero, nsum, nprod);\n        }\n    \n        memo[key] = res;\n        return res;\n    }\n\n    int solve(int x) {\n        if (x < 1) {\n            return 0;\n        }\n        digits = to_string(x);\n        memo.clear();\n        return dp(0, 1, 0, 0, 0, 1);\n    }\n\n    int beautifulNumbers(int l, int r) { return solve(r) - solve(l - 1); }\n};","author":"Anshul Sharma","submissionId":"1575218369"},[{"id":"168","similarity":0.9323827046918123,"totOverlap":2027,"longestOverlap":6}]],"225":[{"id":"225","fileName":"1575219255.txt","sourceCode":"class Solution {\n    private String numberString;\n    private Map<Long, Long> dp;\n\n    public int beautifulNumbers(int l, int r) {\n        return (int) (countBeautifulNumbers(r) - countBeautifulNumbers(l - 1));\n    }\n\n    private long countBeautifulNumbers(long x) {\n        if (x < 1) return 0;\n        numberString = Long.toString(x);\n        dp = new HashMap<>();\n        return recursiveCount(0, 1, 0, 0, 0, 0, 0, 0, 0);\n    }\n\n    private long recursiveCount(int pos, int tight, int started, int hasZero, int sum, int e2, int e3, int e5, int e7) {\n        if (pos == numberString.length()) {\n            if (started == 0) return 0;\n            if (hasZero == 1) return 1;\n            return (sum != 0 && calculateProduct(e2, e3, e5, e7) % sum == 0) ? 1 : 0;\n        }\n\n        long key = generateKey(pos, tight, started, hasZero, sum, e2, e3, e5, e7);\n        if (dp.containsKey(key)) return dp.get(key);\n\n        long result = 0;\n        int limit = (tight == 1) ? numberString.charAt(pos) - '0' : 9;\n\n        for (int digit = 0; digit <= limit; digit++) {\n            int newTight = (tight == 1 && digit == limit) ? 1 : 0;\n            result += processDigit(pos, newTight, started, hasZero, sum, e2, e3, e5, e7, digit);\n        }\n\n        dp.put(key, result);\n        return result;\n    }\n\n    private long processDigit(int pos, int newTight, int started, int hasZero, int sum, int e2, int e3, int e5, int e7, int digit) {\n        if (started == 0) {\n            if (digit == 0) {\n                return recursiveCount(pos + 1, newTight, 0, 0, 0, 0, 0, 0, 0);\n            } else {\n                int[] factors = getFactors(digit, 0, 0, 0, 0);\n                return recursiveCount(pos + 1, newTight, 1, 0, digit, factors[0], factors[1], factors[2], factors[3]);\n            }\n        } \n        \n        if (hasZero == 1) {\n            return recursiveCount(pos + 1, newTight, 1, 1, sum + digit, 0, 0, 0, 0);\n        } \n        \n        if (digit == 0) {\n            return recursiveCount(pos + 1, newTight, 1, 1, sum, 0, 0, 0, 0);\n        } \n\n        int[] factors = getFactors(digit, e2, e3, e5, e7);\n        return recursiveCount(pos + 1, newTight, 1, 0, sum + digit, factors[0], factors[1], factors[2], factors[3]);\n    }\n\n    private int calculateProduct(int e2, int e3, int e5, int e7) {\n        return (int) (Math.pow(2, e2) * Math.pow(3, e3) * Math.pow(5, e5) * Math.pow(7, e7));\n    }\n\n    private long generateKey(int pos, int tight, int started, int hasZero, int sum, int e2, int e3, int e5, int e7) {\n        return ((long) pos) | ((long) tight << 4) | ((long) started << 5) | ((long) hasZero << 6) | ((long) sum << 7)\n                | ((long) e2 << (7 + 7)) | ((long) e3 << (7 + 7 + 6)) | ((long) e5 << (7 + 7 + 6 + 6)) | ((long) e7 << (7 + 7 + 6 + 6 + 5));\n    }\n\n    private int[] getFactors(int num, int e2, int e3, int e5, int e7) {\n        while (num % 2 == 0) { e2++; num /= 2; }\n        while (num % 3 == 0) { e3++; num /= 3; }\n        while (num % 5 == 0) { e5++; num /= 5; }\n        while (num % 7 == 0) { e7++; num /= 7; }\n        return new int[]{e2, e3, e5, e7};\n    }\n}\n","author":"vinaychowdary7","submissionId":"1575219255"},[{"id":"168","similarity":0.8830715532286213,"totOverlap":2024,"longestOverlap":5}]],"230":[{"id":"230","fileName":"1575219796.txt","sourceCode":"typedef long long ll;\n \nstruct State {\n    int pos, tight, started, hasZero, sum;\n    ll prod;\n    bool operator==(const State &other) const {\n        return pos==other.pos && tight==other.tight &&\n               started==other.started && hasZero==other.hasZero &&\n               sum==other.sum && prod==other.prod;\n    }\n};\n \nstruct StateHash {\n    std::size_t operator()(const State &s) const {\n        size_t res = 17;\n        res = res * 31 + hash<int>()(s.pos);\n        res = res * 31 + hash<int>()(s.tight);\n        res = res * 31 + hash<int>()(s.started);\n        res = res * 31 + hash<int>()(s.hasZero);\n        res = res * 31 + hash<int>()(s.sum);\n        res = res * 31 + hash<ll>()(s.prod);\n        return res;\n    }\n};\n \nstring digits;\nunordered_map<State, ll, StateHash> memo;\n \nll dp(int pos, int tight, int started, int hasZero, int sum, ll prod) {\n    if (pos == (int)digits.size()) {\n        if (!started) return 0;\n        if (hasZero) return 1;\n        return (prod % sum == 0) ? 1 : 0;\n    }\n \n    State state{pos, tight, started, hasZero, sum, prod};\n    if(memo.count(state)) return memo[state];\n \n    ll res = 0;\n    int limit = tight ? (digits[pos]-'0') : 9;\n    for (int d = 0; d <= limit; d++) {\n        int ntight = (tight && (d == limit)) ? 1 : 0;\n        if (!started) {\n            if (d == 0) {\n                res += dp(pos+1, ntight, 0, 0, 0, 1);\n            } else {\n                res += dp(pos+1, ntight, 1, 0, d, d);\n            }\n        } else {\n            if (hasZero) {\n                res += dp(pos+1, ntight, 1, 1, sum, prod);\n            } else {\n                if (d == 0) {\n                    res += dp(pos+1, ntight, 1, 1, sum, prod);\n                } else {\n                    res += dp(pos+1, ntight, 1, 0, sum + d, prod * d);\n                }\n            }\n        }\n    }\n \n    memo[state] = res;\n    return res;\n}\nll f(ll x) {\n    digits = to_string(x);\n    memo.clear();\n    return dp(0, 1, 0, 0, 0, 1);\n}\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        return f(r) - f(l - 1);\n    }\n};","author":"Madhav Jha","submissionId":"1575219796"},[{"id":"168","similarity":0.9005352363960749,"totOverlap":2019,"longestOverlap":8}]],"236":[{"id":"236","fileName":"1575221030.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        factors = {\n            1: (0, 0, 0, 0),\n            2: (1, 0, 0, 0),\n            3: (0, 1, 0, 0),\n            4: (2, 0, 0, 0),\n            5: (0, 0, 1, 0),\n            6: (1, 1, 0, 0),\n            7: (0, 0, 0, 1),\n            8: (3, 0, 0, 0),\n            9: (0, 2, 0, 0)\n        }\n        \n        def count(n: int) -> int:\n            s_n = str(n)\n            Ld = len(s_n)\n            @lru_cache(maxsize=None)\n            def dp(pos: int, tight: int, started: int, usedZero: int, s_val: int, e2: int, e3: int, e5: int, e7: int) -> int:\n                if pos == Ld:\n                    if not started:\n                        return 0\n                    if usedZero:\n                        return 1\n                    if s_val == 0:\n                        return 0\n                    prod = (2 ** e2) * (3 ** e3) * (5 ** e5) * (7 ** e7)\n                    return 1 if prod % s_val == 0 else 0\n                res = 0\n                lim = int(s_n[pos]) if tight else 9\n                for dig in range(lim + 1):\n                    ntight = 1 if (tight and dig == lim) else 0\n                    if not started:\n                        if dig == 0:\n                            res += dp(pos + 1, ntight, 0, 0, 0, 0, 0, 0, 0)\n                        else:\n                            fac = factors.get(dig, (0, 0, 0, 0))\n                            res += dp(pos + 1, ntight, 1, 0, dig, fac[0], fac[1], fac[2], fac[3])\n                    else:\n                        if usedZero:\n                            res += dp(pos + 1, ntight, 1, 1, 0, 0, 0, 0, 0)\n                        else:\n                            if dig == 0:\n                                res += dp(pos + 1, ntight, 1, 1, 0, 0, 0, 0, 0)\n                            else:\n                                fac = factors.get(dig, (0, 0, 0, 0))\n                                res += dp(pos + 1, ntight, 1, 0, s_val + dig, e2 + fac[0], e3 + fac[1], e5 + fac[2], e7 + fac[3])\n                return res\n            return dp(0, 1, 0, 0, 0, 0, 0, 0, 0)\n        \n        return count(r) - count(l - 1)\n        ","author":"Samay_Jain_2405","submissionId":"1575221030"},[{"id":"168","similarity":0.9398778769375293,"totOverlap":2001,"longestOverlap":9}]],"237":[{"id":"237","fileName":"1575222790.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def final(n):\n            memo = {}\n            n = str(n)\n            def fun(i,tight,sum,product,zero,leading_zero):\n                if i==len(n):\n                    if (sum>0 and product%sum==0) or (zero and not leading_zero):\n                        return 1\n                    return 0\n                if (i,tight,sum,product,zero, leading_zero) in memo:\n                    return memo[(i,tight,sum,product,zero,leading_zero)]\n                if tight:\n                    end = int(n[i])\n                else:\n                    end = 9\n                res = 0\n                for j in range(end+1):\n                    res+=fun(i+1,int(tight&(j==int(n[i]))),sum+j, (product*j if j>0 else product),int((zero or (j==0)) and not leading_zero),int(leading_zero&(j==0)))\n                memo[(i,tight,sum,product,zero,leading_zero)] = res\n                return res\n            return fun(0,1,0,1,0,1)\n        return final(r) - final(l-1)","author":"Shivam Kumar","submissionId":"1575222790"},[{"id":"168","similarity":0.9385265133740028,"totOverlap":2000,"longestOverlap":2}]],"246":[{"id":"246","fileName":"1575224368.txt","sourceCode":"class Solution {\npublic:\n    typedef long long ll;\n    string s;\n    unordered_map<ll, ll> dp;\n\n    ll rec(int pos, int tight, int started, int hasZero, int sum, int e2, int e3, int e5, int e7) {\n        if (pos == s.size()) {\n            if (!started) return 0;\n            if (hasZero) return 1;\n            int prod = 1;\n            for (int i = 0; i < e2; i++) prod *= 2;\n            for (int i = 0; i < e3; i++) prod *= 3;\n            for (int i = 0; i < e5; i++) prod *= 5;\n            for (int i = 0; i < e7; i++) prod *= 7;\n            return (sum != 0 && prod % sum == 0) ? 1LL : 0LL;\n        }\n\n        ll key = ((ll)pos) | ((ll)tight << 4) | ((ll)started << 5) | ((ll)hasZero << 6) | ((ll)sum << 7) |\n                 ((ll)e2 << (7 + 7)) | ((ll)e3 << (7 + 7 + 6)) | ((ll)e5 << (7 + 7 + 6 + 6)) | ((ll)e7 << (7 + 7 + 6 + 6 + 5));\n\n        if (dp.find(key) != dp.end()) return dp[key];\n\n        ll res = 0;\n        int limit = tight ? s[pos] - '0' : 9;\n        for (int d = 0; d <= limit; d++) {\n            int ntight = tight && (d == limit);\n            if (!started) {\n                if (d == 0) {\n                    res += rec(pos + 1, ntight, 0, 0, 0, 0, 0, 0, 0);\n                } else {\n                    int newSum = d, new_e2 = 0, new_e3 = 0, new_e5 = 0, new_e7 = 0;\n                    int temp = d;\n                    while (temp % 2 == 0) { new_e2++; temp /= 2; }\n                    while (temp % 3 == 0) { new_e3++; temp /= 3; }\n                    while (temp % 5 == 0) { new_e5++; temp /= 5; }\n                    while (temp % 7 == 0) { new_e7++; temp /= 7; }\n                    res += rec(pos + 1, ntight, 1, 0, newSum, new_e2, new_e3, new_e5, new_e7);\n                }\n            } else {\n                if (hasZero) {\n                    int newSum = sum + d;\n                    res += rec(pos + 1, ntight, 1, 1, newSum, 0, 0, 0, 0);\n                } else {\n                    if (d == 0) {\n                        res += rec(pos + 1, ntight, 1, 1, sum, 0, 0, 0, 0);\n                    } else {\n                        int newSum = sum + d, new_e2 = e2, new_e3 = e3, new_e5 = e5, new_e7 = e7;\n                        int temp = d;\n                        while (temp % 2 == 0) { new_e2++; temp /= 2; }\n                        while (temp % 3 == 0) { new_e3++; temp /= 3; }\n                        while (temp % 5 == 0) { new_e5++; temp /= 5; }\n                        while (temp % 7 == 0) { new_e7++; temp /= 7; }\n                        res += rec(pos + 1, ntight, 1, 0, newSum, new_e2, new_e3, new_e5, new_e7);\n                    }\n                }\n            }\n        }\n\n        return dp[key] = res;\n    }\n\n    ll countBeautiful(ll x) {\n        if (x < 1) return 0;\n        s = to_string(x);\n        dp.clear();\n        return rec(0, 1, 0, 0, 0, 0, 0, 0, 0);\n    }\n\n    int beautifulNumbers(int l, int r) {\n        return (int)(countBeautiful(r) - countBeautiful((ll)l - 1));\n    }\n};\n","author":"Gokhulnath7","submissionId":"1575224368"},[{"id":"168","similarity":0.895292564892213,"totOverlap":2035,"longestOverlap":5}]],"260":[{"id":"260","fileName":"1575227267.txt","sourceCode":"using ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\n#define all(x) begin(x), end(x)\n#define F first\n#define S second\n#define pb push_back\n#define sz(x) (int) x.size()\n\ntemplate<class T> inline T& ckmin(T& a, const T& b) { if(b < a) a = b; return a; }\ntemplate<class T> inline T& ckmax(T& a, const T& b) { if(a < b) a = b; return a; }\n\nnamespace IO {\n    template<typename... Args> void rd(Args&... args) {\n        ((cin >> args), ...); }\n\n    template<typename... Args> void print(Args... args) {\n        ((cout << args << \" \"), ...); }\n}\n\nusing namespace IO;\n\nclass Solution {\npublic:\n    struct E {\n        int pos, pref, st, sm; ll p;\n        \n        bool operator < (const E &other) const {\n            if (pos != other.pos) return pos < other.pos;\n            if (pref != other.pref) return pref < other.pref;\n            if (st != other.st) return st < other.st;\n            if (sm != other.sm) return sm < other.sm;\n            return p < other.p;\n        }\n    };\n    \n    map<E, ll> dp; string s;\n    \n    ll dfs(string s, int pos, int pref, int st, int sm, ll p) {\n        if (pos == sz(s)) {\n            if (!st) {\n                return 0;\n            }\n            if (!p) {\n                return 1;\n            }\n            \n            return (sm != 0 && !(p % sm));\n        }\n        \n        E cur = { pos, pref, st, sm, p };\n        if (dp.find(cur) != dp.end()) {\n            return dp[cur];\n        }\n        \n        ll cnt = 0; int b = pref ? (s[pos] - '0') : 9;\n        for (int i = 0; i <= b; i++) {\n            int nxt1 = (pref && i == b), nxt2 = st, nxt3 = sm; ll nxt4 = p;\n            \n            if (!st) {\n                if (!i) {\n                    cnt += dfs(s, pos + 1, nxt1, 0, 0, 1);\n                } else {\n                    cnt += dfs(s, pos + 1, nxt1, 1, i, i);\n                }\n            } else {\n                nxt3 = i + sm;\n                if (!i) {\n                    nxt4 = 0LL;\n                } else {\n                    nxt4 = (!p ? p : i * p);\n                }\n                cnt += dfs(s, pos + 1, nxt1, nxt2, nxt3, nxt4);\n            }\n        }\n        return dp[cur] = cnt;\n    }\n    \n    int beautifulNumbers(int l, int r) {\n        int R = dfs(to_string(r), 0, 1, 0, 0, 1);\n        dp.clear();\n        int L;\n        if (l == 1) L = 0;\n        else L = dfs(to_string(l - 1), 0, 1, 0, 0, 1);\n        return R - L;\n    }\n};","author":"_chiikawa","submissionId":"1575227267"},[{"id":"168","similarity":0.901705565529623,"totOverlap":2009,"longestOverlap":2}]],"261":[{"id":"261","fileName":"1575227250.txt","sourceCode":"#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define ll long long\nlong double PI = acos(-1.0);\n#define fastio() ios_base::sync_with_stdio(false); cin.tie(NULL)\n#define pb push_back\n#define ppb pop_back\n#define pf push_front\n#define ppf pop_front\n#define all(x) (x).begin(), (x).end()\n#define ff(i, l, r) for(int i = l; i < r; i++)\n#define ffr(i, l, r) for(int i = l; i >= r; i--)\n#define F first\n#define S second\n#define vii vector<vector<int>>\n#define vi vector<int>\n#define pii pair<int, int>\n#define mem1(a) memset(a, -1, sizeof(a))\n#define mem0(a) memset(a, 0, sizeof(a))\n#define ppc __builtin_popcount\n#define ppcll __builtin_popcountll\n\n\nclass Solution {\npublic:\n\tstring s;\n\tunordered_map<string, ll> memo;\n\tll rec(int pos, int t, int st, int hz, int sum, ll prod) {\n\t\tif (pos == s.size()) {\n\t\t\tif (!st && true)return 0;\n\t\t\tif (hz && !0)return 1;\n\t\t\treturn (!(prod % sum) && !0) ? 1 : 0;\n\t\t}\n\t\tstring key = to_string(pos) + \"\" + to_string(t) + \"\" + to_string(st) + \"\" + to_string(hz) + \"\" + to_string(sum) + \"_\" + to_string(prod);\n\t\tint flag = 0;\n\t\tif (memo.count(key) && !flag) return memo[key];\n\t\tll res = 0;\n\t\tint lim = t ? s[pos] - '0' : 9;\n\t\tff(d, 0 && !flag, lim + 1) {\n\t\t\tint nt = (t && (d == lim));\n\t\t\tif (st && !flag) {\n\t\t\t\tint nhz = hz;\n\t\t\t\tif (!d) nhz = 1;\n\t\t\t\tint hu;\n\t\t\t\t(!d && !flag) ? hu = 0 : hu = prod * d;\n\t\t\t\tres += rec(pos + 1, nt, 1, nhz, sum + d, hu);\n\t\t\t} else {\n\t\t\t\t(d && !flag) ? res += rec(pos + 1, nt, 1, 0, d, d) : res += rec(pos + 1, nt, 0, 0, 0, 1);\n\t\t\t}\n\t\t}\n\t\tmemo[key] = res;\n\t\treturn res;\n\t}\n\tll countBeautiful(ll X) {\n\t\ts = to_string(X);\n\t\tmemo.clear();\n\t\treturn rec(0, 1, 0, 0, 0, 1);\n\t}\n\tint beautifulNumbers(int l, int r) {\n\t\treturn countBeautiful(r) - (l > 1 ? countBeautiful(l - 1) : 0);\n\t}\n};","author":"CallMeHaldey","submissionId":"1575227250"},[{"id":"168","similarity":0.9181073703366697,"totOverlap":2018,"longestOverlap":5}]],"264":[{"id":"264","fileName":"1575229070.txt","sourceCode":"class Solution {\n    private String s;\n    private Map<Long, Long> dp;\n\n    private long rec(int pos, int tight, int started, int hasZero, int sum, int e2, int e3, int e5, int e7) {\n        if (pos == s.length()) {\n            if (started == 0) return 0;\n            if (hasZero == 1) return 1;\n            int prod = (int) (Math.pow(2, e2) * Math.pow(3, e3) * Math.pow(5, e5) * Math.pow(7, e7));\n            return (sum != 0 && prod % sum == 0) ? 1 : 0;\n        }\n        \n        long key = (long) pos | ((long) tight << 4) | ((long) started << 5) | ((long) hasZero << 6) | ((long) sum << 7) |\n                   ((long) e2 << 14) | ((long) e3 << 20) | ((long) e5 << 26) | ((long) e7 << 31);\n        \n        if (dp.containsKey(key)) return dp.get(key);\n        \n        long res = 0;\n        int limit = tight == 1 ? s.charAt(pos) - '0' : 9;\n        \n        for (int d = 0; d <= limit; d++) {\n            int ntight = (tight == 1 && d == limit) ? 1 : 0;\n            if (started == 0) {\n                if (d == 0) {\n                    res += rec(pos + 1, ntight, 0, 0, 0, 0, 0, 0, 0);\n                } else {\n                    int newSum = d, new_e2 = 0, new_e3 = 0, new_e5 = 0, new_e7 = 0, temp = d;\n                    while (temp % 2 == 0) { new_e2++; temp /= 2; }\n                    while (temp % 3 == 0) { new_e3++; temp /= 3; }\n                    while (temp % 5 == 0) { new_e5++; temp /= 5; }\n                    while (temp % 7 == 0) { new_e7++; temp /= 7; }\n                    res += rec(pos + 1, ntight, 1, 0, newSum, new_e2, new_e3, new_e5, new_e7);\n                }\n            } else {\n                if (hasZero == 1) {\n                    res += rec(pos + 1, ntight, 1, 1, sum + d, 0, 0, 0, 0);\n                } else {\n                    if (d == 0) {\n                        res += rec(pos + 1, ntight, 1, 1, sum, 0, 0, 0, 0);\n                    } else {\n                        int newSum = sum + d, new_e2 = e2, new_e3 = e3, new_e5 = e5, new_e7 = e7, temp = d;\n                        while (temp % 2 == 0) { new_e2++; temp /= 2; }\n                        while (temp % 3 == 0) { new_e3++; temp /= 3; }\n                        while (temp % 5 == 0) { new_e5++; temp /= 5; }\n                        while (temp % 7 == 0) { new_e7++; temp /= 7; }\n                        res += rec(pos + 1, ntight, 1, 0, newSum, new_e2, new_e3, new_e5, new_e7);\n                    }\n                }\n            }\n        }\n        dp.put(key, res);\n        return res;\n    }\n    \n    private long countBeautiful(long x) {\n        if (x < 1) return 0;\n        s = Long.toString(x);\n        dp = new HashMap<>();\n        return rec(0, 1, 0, 0, 0, 0, 0, 0, 0);\n    }\n    public int beautifulNumbers(int l, int r) {\n        return (int) (countBeautiful(r) - countBeautiful(l-1));\n    }\n}","author":"Tirthankar Sardar","submissionId":"1575229070"},[{"id":"168","similarity":0.9012016021361816,"totOverlap":2025,"longestOverlap":5}]],"265":[{"id":"265","fileName":"1575227645.txt","sourceCode":"class Solution {\n\n        private Map<String, Long> memo;\n    \n    public int beautifulNumbers(int l, int r) {\n        long countR = countBeautiful(r);\n        long countL = countBeautiful(l - 1);\n        // The answer is the count in [l, r]\n        return (int)(countR - countL);\n    }\n    \n    // Returns the count of beautiful numbers in [1, X].\n    private long countBeautiful(int X) {\n        // If X is less than 1, there are no positive numbers.\n        if (X < 1) return 0;\n        // Convert X to its digit array (most-significant digit first)\n        String s = Integer.toString(X);\n        int[] digits = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            digits[i] = s.charAt(i) - '0';\n        }\n        memo = new HashMap<>();\n        // Start with pos=0, tight=1, not started, no zero encountered,\n        // current sum=0, and product=1 (multiplicative identity)\n        return dp(0, 1, 0, 0, 0, 1, digits);\n    }\n    \n    /**\n     * DP function that returns the count of beautiful numbers for the state.\n     * \n     * @param pos    Current digit position (0-indexed)\n     * @param tight  1 if the current prefix is equal to the prefix of the target, else 0.\n     * @param started 1 if we have already chosen a non-leading digit; 0 otherwise.\n     * @param hasZero 1 if a zero has been chosen after starting; 0 otherwise.\n     * @param sum    Running sum of digits (only valid if hasZero==0 and started==1)\n     * @param prod   Running product of digits (only valid if hasZero==0 and started==1)\n     * @param digits The array of digits for the target number.\n     * @return       The count of beautiful numbers for the current state.\n     */\n    private long dp(int pos, int tight, int started, int hasZero, int sum, int prod, int[] digits) {\n        // Base case: all positions have been processed.\n        if (pos == digits.length) {\n            // If no number has been formed, we return 0.\n            if (started == 0) return 0;\n            // If we already encountered a zero, the number is automatically beautiful.\n            if (hasZero == 1) return 1;\n            // Otherwise, check if the product is divisible by the sum.\n            return (prod % sum == 0) ? 1 : 0;\n        }\n        \n        // Build a key for memoization.\n        // For states where hasZero==1, sum and prod are not relevant, so we use dummy values.\n        String key = pos + \",\" + tight + \",\" + started + \",\" + hasZero + \",\";\n        if (hasZero == 1) {\n            key += \"0,0\";\n        } else {\n            key += sum + \",\" + prod;\n        }\n        \n        if (memo.containsKey(key)) {\n            return memo.get(key);\n        }\n        \n        long res = 0;\n        int maxDigit = (tight == 1) ? digits[pos] : 9;\n        \n        // Try every possible digit at current position.\n        for (int d = 0; d <= maxDigit; d++) {\n            int newTight = (tight == 1 && d == maxDigit) ? 1 : 0;\n            int newStarted = started;\n            int newHasZero = hasZero;\n            int newSum = sum;\n            int newProd = prod;\n            \n            if (started == 0) {\n                // We haven't started the number yet.\n                if (d == 0) {\n                    // Still not started; leading zero does not affect sum or product.\n                    res += dp(pos + 1, newTight, newStarted, newHasZero, newSum, newProd, digits);\n                    continue;\n                } else {\n                    // Start the number with a nonzero digit.\n                    newStarted = 1;\n                    newSum = d;\n                    newProd = d;\n                    // If the digit is zero (which won't happen here since d>0), we would set newHasZero = 1.\n                }\n            } else {\n                // Already started.\n                if (hasZero == 0) {\n                    // Haven't encountered a zero yet.\n                    if (d == 0) {\n                        // Now we encounter a zero -> mark newHasZero.\n                        newHasZero = 1;\n                        // Once a zero is encountered, we no longer need sum and prod.\n                        newSum = 0; // dummy\n                        newProd = 0; // dummy\n                    } else {\n                        newSum = sum + d;\n                        newProd = prod * d;\n                    }\n                }\n                // If hasZero is already 1, no updates for sum and product are needed.\n            }\n            \n            res += dp(pos + 1, newTight, newStarted, newHasZero, newSum, newProd, digits);\n        }\n        \n        memo.put(key, res);\n        return res;\n    }\n}","author":"Rahul R","submissionId":"1575227645"},[{"id":"168","similarity":0.9192886456908345,"totOverlap":2016,"longestOverlap":3}]],"266":[{"id":"266","fileName":"1575228776.txt","sourceCode":"from typing import List\nfrom functools import lru_cache\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return self.countBeautiful(r) - self.countBeautiful(l - 1)\n    \n    def countBeautiful(self, x: int) -> int:\n        if x < 1:\n            return 0\n        s = str(x)\n        dp = {}\n        \n        def rec(pos, tight, started, has_zero, digit_sum, e2, e3, e5, e7):\n            if pos == len(s):\n                if not started:\n                    return 0\n                if has_zero:\n                    return 1\n                prod = 1\n                for _ in range(e2):\n                    prod *= 2\n                for _ in range(e3):\n                    prod *= 3\n                for _ in range(e5):\n                    prod *= 5\n                for _ in range(e7):\n                    prod *= 7\n                return 1 if (digit_sum != 0 and prod % digit_sum == 0) else 0\n            \n            key = (pos, tight, started, has_zero, digit_sum, e2, e3, e5, e7)\n            if key in dp:\n                return dp[key]\n            \n            res = 0\n            limit = int(s[pos]) if tight else 9\n            \n            for d in range(limit + 1):\n                ntight = tight and (d == limit)\n                \n                if not started:\n                    if d == 0:\n                        res += rec(pos + 1, ntight, 0, 0, 0, 0, 0, 0, 0)\n                    else:\n                        new_sum = d\n                        new_e2, new_e3, new_e5, new_e7 = 0, 0, 0, 0\n                        temp = d\n                        \n                        while temp % 2 == 0:\n                            new_e2 += 1\n                            temp //= 2\n                        while temp % 3 == 0:\n                            new_e3 += 1\n                            temp //= 3\n                        while temp % 5 == 0:\n                            new_e5 += 1\n                            temp //= 5\n                        while temp % 7 == 0:\n                            new_e7 += 1\n                            temp //= 7\n                            \n                        res += rec(pos + 1, ntight, 1, 0, new_sum, new_e2, new_e3, new_e5, new_e7)\n                else:\n                    if has_zero:\n                        new_sum = digit_sum + d\n                        res += rec(pos + 1, ntight, 1, 1, new_sum, 0, 0, 0, 0)\n                    else:\n                        if d == 0:\n                            new_sum = digit_sum\n                            res += rec(pos + 1, ntight, 1, 1, new_sum, 0, 0, 0, 0)\n                        else:\n                            new_sum = digit_sum + d\n                            new_e2, new_e3, new_e5, new_e7 = e2, e3, e5, e7\n                            temp = d\n                            \n                            while temp % 2 == 0:\n                                new_e2 += 1\n                                temp //= 2\n                            while temp % 3 == 0:\n                                new_e3 += 1\n                                temp //= 3\n                            while temp % 5 == 0:\n                                new_e5 += 1\n                                temp //= 5\n                            while temp % 7 == 0:\n                                new_e7 += 1\n                                temp //= 7\n                                \n                            res += rec(pos + 1, ntight, 1, 0, new_sum, new_e2, new_e3, new_e5, new_e7)\n            \n            dp[key] = res\n            return res\n        \n        return rec(0, 1, 0, 0, 0, 0, 0, 0, 0)\n        \n","author":"Sai1012","submissionId":"1575228776"},[{"id":"168","similarity":0.9062075215224287,"totOverlap":2000,"longestOverlap":4}]],"268":[{"id":"268","fileName":"1575229515.txt","sourceCode":"struct TupleHash {\n    size_t operator()(const tuple<int, int, int, int, int, int>& key) const {\n        size_t seed = 0;\n        auto hash_combine = [&seed](int v) { \n            seed ^= std::hash<int>{}(v) + 0x9e3779b97f4a7c15ULL + (seed << 6) + (seed >> 2);\n        };\n        hash_combine(static_cast<int>(get<0>(key)));\n        hash_combine(static_cast<int>(get<1>(key)));\n        hash_combine(static_cast<int>(get<2>(key)));\n        hash_combine(static_cast<int>(get<3>(key)));\n        hash_combine(static_cast<int>(get<4>(key)));\n        hash_combine(static_cast<int>(get<5>(key)));\n        return seed;\n    }\n};\n\nclass Solution {\npublic:\n    using Key = tuple<int, int, int, int, int, int>;\n    unordered_map<Key, long long, TupleHash> memo; \n\n    long long dp(int p, int t, int st, int zero, int sum, int prod, const vector<int>&a) {\n        if(p==a.size())\n        {\n            if(!st)\n                return 0;\n            if(zero)\n                return 1;\n            return (prod%sum==0)?1LL:0LL;\n        }\n        Key state = make_tuple(p, t, st, zero, sum, prod);\n\n        if(memo.count(state))\n        {\n            return memo[state];\n        }\n        long long int ans=0;\n        int limit=t?a[p]:9;\n\n        int d;\n\n        for(d=0;d<=limit;d++)\n            {\n                int t1=(t&&d==limit)?1:0;\n\n                int st1=st;\n                int zero1=zero;\n                int sum1=sum,prod1=prod;\n\n                if(!st)\n                {\n                    if(d==0)\n                    {\n                        ans+=dp(p+1,t1,0,0,0,1,a);\n                        continue;\n                    }\n                    else\n                    {\n                        st1=1;\n                        sum1=d;\n                        prod1=d;\n                        zero1=(d==0)?1:0;\n                    }\n                }\n                else\n                {\n                    if(!zero1)\n                    {\n                        if(d==0)\n                        {\n                            zero1=1;\n                            sum1=prod1=0;\n                        }\n                        else\n                        {\n                            sum1+=d;\n                            prod1*=d;\n                        }\n                    }\n                }\n                ans+=dp(p+1,t1,st1,zero1,sum1,prod1,a);\n            }\n        return memo[state]=ans;\n    }\n    \n    long long f(long long x) {\n        vector<int>v;\n        while(x>0)\n            {\n                v.push_back(x%10);\n                x=x/10;\n            }\n        if(v.size()==0)\n            v.push_back(0);\n        reverse(v.begin(),v.end());\n        memo.clear();\n        return dp(0, 1, 0, 0, 0, 1, v);\n    }\n    \n    int beautifulNumbers(int l, int r) {\n        return (int)(f(r) - f(l - 1));\n    }\n};\n\n","author":"Soumyadeep Singh","submissionId":"1575229515"},[{"id":"168","similarity":0.8994188645507376,"totOverlap":2012,"longestOverlap":2}]],"280":[{"id":"280","fileName":"1575232958.txt","sourceCode":"from functools import lru_cache\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def cntbeauti(x: int) -> int:\n            if x < 1:\n                return 0\n            \n            s = str(x)\n\n            @lru_cache(None)\n            def reco(posit: int, tgt: int, started: int, hszro: int, sum_: int, e2: int, e3: int, e5: int, e7: int) -> int:\n                if posit == len(s):\n                    if not started:\n                        return 0\n                    if hszro:\n                        return 1\n                    prod = (2 ** e2) * (3 ** e3) * (5 ** e5) * (7 ** e7)\n                    return 1 if sum_ != 0 and prod % sum_ == 0 else 0\n\n                res = 0\n                limit = int(s[posit]) if tgt else 9\n\n                for d in range(limit + 1):\n                    ntight = tgt and (d == limit)\n                    if not started:\n                        if d == 0:\n                            res += reco(posit + 1, ntight, 0, 0, 0, 0, 0, 0, 0)\n                        else:\n                            tempora, new_e2, new_e3, new_e5, new_e7 = d, 0, 0, 0, 0\n                            while tempora % 2 == 0: new_e2 += 1; tempora //= 2\n                            while tempora % 3 == 0: new_e3 += 1; tempora //= 3\n                            while tempora % 5 == 0: new_e5 += 1; tempora //= 5\n                            while tempora % 7 == 0: new_e7 += 1; tempora //= 7\n                            res += reco(posit + 1, ntight, 1, 0, d, new_e2, new_e3, new_e5, new_e7)\n                    else:\n                        if hszro:\n                            res += reco(posit + 1, ntight, 1, 1, sum_ + d, 0, 0, 0, 0)\n                        else:\n                            if d == 0:\n                                res += reco(posit + 1, ntight, 1, 1, sum_, 0, 0, 0, 0)\n                            else:\n                                tempora, new_e2, new_e3, new_e5, new_e7 = d, e2, e3, e5, e7\n                                while tempora % 2 == 0: new_e2 += 1; tempora //= 2\n                                while tempora % 3 == 0: new_e3 += 1; tempora //= 3\n                                while tempora % 5 == 0: new_e5 += 1; tempora //= 5\n                                while tempora % 7 == 0: new_e7 += 1; tempora //= 7\n                                res += reco(posit + 1, ntight, 1, 0, sum_ + d, new_e2, new_e3, new_e5, new_e7)\n\n                return res\n\n            return reco(0, 1, 0, 0, 0, 0, 0, 0, 0)\n\n        return cntbeauti(r) - cntbeauti(l - 1)        ","author":"Samundar","submissionId":"1575232958"},[{"id":"168","similarity":0.9148741418764302,"totOverlap":1999,"longestOverlap":3}]],"281":[{"id":"281","fileName":"1575233179.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nclass Solution {\npublic:\n    string numStr;\n    unordered_map<string, ll> dp;\n\n    ll dfs(int idx, int hasStarted, int isTight, int digitSum, ll digitProd, int containsZero) {\n        if (idx == numStr.size()) {\n            if (!hasStarted) return 0;\n            if (containsZero) return 1;\n            return (digitProd % digitSum == 0) ? 1 : 0;\n        }\n\n        string state = to_string(idx) + \"_\" + to_string(hasStarted) + \"_\" + to_string(isTight) + \"_\" +\n                       to_string(digitSum) + \"_\" + to_string(digitProd) + \"_\" + to_string(containsZero);\n\n        if (dp.count(state)) return dp[state];\n\n        \n        int limit = (!isTight) ?9:  numStr[idx] - '0';\n        ll count = 0;\n\n        for (int digit = 0; digit <= limit; digit++) {\n            int newTight = ((digit == limit) && isTight);\n\n            if (!hasStarted) {\n                if (digit == 0) count += dfs(idx + 1, 0, newTight, 0, 1, 0);\n                else count += dfs(idx + 1, 1, newTight, digit, digit, 0);\n            } else {\n                int newHasZero;\n                if (digit == 0) newHasZero = 1;\n                else newHasZero= containsZero;\n                count += dfs(idx + 1, 1, newTight, digitSum + digit, (digit == 0 ? 0 : digitProd * digit), newHasZero);\n            }\n        }\n\n        dp[state] = count;\n        return count;\n    }\n\n    ll count(ll X) {\n        dp.clear();\n        numStr = to_string(X);\n        return dfs(0, 0, 1, 0, 1, 0);\n    }\n\n    int beautifulNumbers(int l, int r) {\n        return count(r) - (l > 1 ? count(l - 1) : 0);\n    }\n};\n","author":"hehehe1111","submissionId":"1575233179"},[{"id":"168","similarity":0.930907415937356,"totOverlap":2021,"longestOverlap":5}]],"287":[{"id":"287","fileName":"1575234082.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        add = {\n            0: (0, 0, 0, 0),\n            1: (0, 0, 0, 0),\n            2: (1, 0, 0, 0),\n            3: (0, 1, 0, 0),\n            4: (2, 0, 0, 0),\n            5: (0, 0, 1, 0),\n            6: (1, 1, 0, 0),\n            7: (0, 0, 0, 1),\n            8: (3, 0, 0, 0),\n            9: (0, 2, 0, 0),\n        }\n        \n        def count(x):\n            if x <= 0:\n                return 0\n            digits = list(map(int, str(x)))\n            n = len(digits)\n            \n            @lru_cache(maxsize=None)\n            def dp(pos, tight, started, has_zero, s, e2, e3, e5, e7):\n                if pos == n:\n                    if not started:\n                        return 0\n                    if has_zero:\n                        return 1\n                    prod = (2 ** e2) * (3 ** e3) * (5 ** e5) * (7 ** e7)\n                    return 1 if prod % s == 0 else 0\n                \n                res = 0\n                up = digits[pos] if tight else 9\n                for d in range(up + 1):\n                    new_tight = tight and (d == up)\n                    if not started:\n                        if d == 0:\n                            res += dp(pos + 1, new_tight, 0, 0, 0, 0, 0, 0, 0)\n                        else:\n                            new_s = d\n                            a2, a3, a5, a7 = add[d]\n                            res += dp(pos + 1, new_tight, 1, 0, new_s, a2, a3, a5, a7)\n                    else:\n                        if not has_zero:\n                            if d == 0:\n                                res += dp(pos + 1, new_tight, 1, 1, 0, 0, 0, 0, 0)\n                            else:\n                                new_s = s + d\n                                a2, a3, a5, a7 = add[d]\n                                res += dp(pos + 1, new_tight, 1, 0, new_s, e2 + a2, e3 + a3, e5 + a5, e7 + a7)\n                        else:\n                            res += dp(pos + 1, new_tight, 1, 1, 0, 0, 0, 0, 0)\n                return res\n            \n            return dp(0, 1, 0, 0, 0, 0, 0, 0, 0)\n        \n        return count(r) - count(l - 1)\n","author":"Akshat Joshi","submissionId":"1575234082"},[{"id":"168","similarity":0.9354838709677419,"totOverlap":2001,"longestOverlap":9}]],"299":[{"id":"299","fileName":"1575238061.txt","sourceCode":"class Solution {\n    public int beautifulNumbers(int l, int r) {\n\n        int divider = 2000000;\n        \n        int[] precalc = new int[]{1118256,1183101,1200619,1183267,1160289,1579467,1174801,1194906,1180665,1155378,1587896,1186366,1204879,1192065,1161969,1586905,1181889,1210665,1190342,1161462,1588786,1186051,1201904,1194766,1161906,1606120,1229493,1219592,1247990,1219231,1588398,1179735,1209930,1196274,1163032,1592267,1202672,1232826,1202484,1203515,1579537,1166812,1186263,1187628,1154450,1575841,1156619,1194874,1178919,1152805,2000000,2000000,2000000,2000000,2000000,1575270,1165826,1186252,1173244,1150046,1583641,1179787,1197347,1187785,1159610,1582185,1173256,1202533,1184537,1157127,1584134,1176404,1195846,1190388,1158528,1602118,1223476,1214137,1244531,1215452,1584640,1175069,1206308,1194955,1162262,1588604,1197253,1228611,1203350,1200379,1577654,1164016,1181519,1183444,1151453,1572392,1152721,1192461,1179197,1151649,2000000,2000000,2000000,2000000,2000000,1583641,1179787,1197347,1187785,1159610,1588786,1186051,1201904,1194766,1161906,1591001,1186898,1214757,1199756,1167306,1584963,1177162,1195028,1192034,1159825,1612384,1239499,1227709,1258895,1225533,1589559,1181187,1210294,1200701,1165056,1598226,1213335,1240635,1216657,1210292,1577580,1162500,1180202,1183098,1152017,1582030,1166712,1205156,1192250,1161645,2000000,2000000,2000000,2000000,2000000,1582185,1173256,1202533,1184537,1157127,1591001,1186898,1214757,1199756,1167306,1582255,1168483,1204652,1185518,1157310,1591441,1184378,1214262,1204258,1167794,1611092,1235031,1238027,1259090,1225521,1585510,1172726,1210611,1195803,1163932,1599027,1212548,1252737,1221126,1213105,1586436,1175218,1203723,1199056,1164212,1570691,1149398,1189592,1177981,1151244,2000000,2000000,2000000,2000000,2000000,1584134,1176404,1195846,1190388,1158528,1584963,1177162,1195028,1192034,1159825,1591441,1184378,1214262,1204258,1167794,1582567,1170019,1187799,1188996,1154990,1613279,1239271,1228026,1259564,1222887,1588221,1177864,1208121,1202535,1166969,1602167,1218428,1240439,1225176,1211576,1573283,1155850,1171643,1178398,1148301,1585245,1171769,1206234,1200147,1165642,2000000,2000000,2000000,2000000,2000000,1602118,1223476,1214137,1244531,1215452,1612384,1239499,1227709,1258895,1225533,1611092,1235031,1238027,1259090,1225521,1613279,1239271,1228026,1259564,1222887,1600858,1226465,1214664,1256335,1230334,1618087,1243041,1247304,1263789,1226449,1626444,1274944,1268595,1270654,1257267,1608236,1228075,1217065,1242390,1208139,1607216,1222979,1236156,1241326,1209689,2000000,2000000,2000000,2000000,2000000,1584640,1175069,1206308,1194955,1162262,1589559,1181187,1210294,1200701,1165056,1585510,1172726,1210611,1195803,1163932,1588221,1177864,1208121,1202535,1166969,1618087,1243041,1247304,1263789,1226449,1586396,1172404,1207839,1198709,1164936,1608559,1224100,1258485,1231278,1217147,1583783,1169295,1195953,1194904,1161449,1578479,1159693,1197465,1187179,1157810,2000000,2000000,2000000,2000000,2000000,1588604,1197253,1228611,1203350,1200379,1598226,1213335,1240635,1216657,1210292,1599027,1212548,1252737,1221126,1213105,1602167,1218428,1240439,1225176,1211576,1626444,1274944,1268595,1270654,1257267,1608559,1224100,1258485,1231278,1217147,1594791,1213683,1237345,1209042,1215460,1599661,1212859,1224835,1217018,1203536,1600718,1210538,1244008,1215589,1204940,2000000,2000000,2000000,2000000,2000000,1577654,1164016,1181519,1183444,1151453,1577580,1162500,1180202,1183098,1152017,1586436,1175218,1203723,1199056,1164212,1573283,1155850,1171643,1178398,1148301,1608236,1228075,1217065,1242390,1208139,1583783,1169295,1195953,1194904,1161449,1599661,1212859,1224835,1217018,1203536,1567519,1146569,1158226,1168934,1143134,1583934,1169660,1198214,1196051,1163903,2000000,2000000,2000000,2000000,2000000,1572392,1152721,1192461,1179197,1151649,1582030,1166712,1205156,1192250,1161645,1570691,1149398,1189592,1177981,1151244,1585245,1171769,1206234,1200147,1165642,1607216,1222979,1236156,1241326,1209689,1578479,1159693,1197465,1187179,1157810,1600718,1210538,1244008,1215589,1204940,1583934,1169660,1198214,1196051,1163903,1567715,1143229,1177117,1166699,1142441};\n        \n        int result = 0;\n        for (int index = l; index <= r && index % divider != 0; ++index) {\n            int currentValue = index;\n            int currentProduct = 1;\n            int currentSum = 0;\n            while (currentValue > 0) {\n                currentProduct *= currentValue % 10;\n                currentSum += currentValue % 10;\n                currentValue /= 10;\n                if (currentProduct == 0) {\n                    break;\n                }\n            }\n\n            if (currentProduct == 0 || currentProduct % currentSum == 0) {\n                ++result;\n            }\n        }\n\n        if (l / divider < r / divider) {\n            for (int index = (r / divider) * divider; index <= r; ++index) {\n                int currentValue = index;\n                int currentProduct = 1;\n                int currentSum = 0;\n                while (currentValue > 0) {\n                    currentProduct *= currentValue % 10;\n                    currentSum += currentValue % 10;\n                    currentValue /= 10;\n                    if (currentProduct == 0) {\n                        break;\n                    }\n                }\n    \n                if (currentProduct == 0 || currentProduct % currentSum == 0) {\n                    ++result;\n                }\n            }\n\n            for (int index = l / divider + 1; index <= r / divider - 1; ++index) {\n                result += precalc[index];\n            }\n        }\n\n        return result;\n    }\n}","author":"Stanislau2","submissionId":"1575238061"},[{"id":"168","similarity":0.9641904761904762,"totOverlap":2531,"longestOverlap":495}]],"301":[{"id":"301","fileName":"1575238699.txt","sourceCode":"// 내가 더 잘할게요 이렇게 같이 있어준다면\n#include <bits/stdc++.h>\n#include <iostream>\n#include <vector>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n\n#define ll long long\n#define ar array\n#define pb push_back\n\nstruct State {\n    int pos, tight, started, hasZero, sum;\n    ll prod;\n    bool operator==(const State &o) const {\n        return pos==o.pos && tight==o.tight && started==o.started && hasZero==o.hasZero && sum==o.sum && prod==o.prod;\n    }\n};\n\nstruct StateHash {\n    size_t operator()(const State &st) const {\n        size_t res = 17;\n        res = res * 31 + hash<int>()(st.pos);\n        res = res * 31 + hash<int>()(st.tight);\n        res = res * 31 + hash<int>()(st.started);\n        res = res * 31 + hash<int>()(st.hasZero);\n        res = res * 31 + hash<int>()(st.sum);\n        res = res * 31 + hash<ll>()(st.prod);\n        return res;\n    }\n};\n\nunordered_map<State, int, StateHash> dpMemo;\nvector<int> ds;\n\nint dp(int pos, int tight, int started, int hasZero, int sum, ll prod) {\n    if(pos == ds.size()){\n        if(!started) return 0;\n        if(hasZero) return 1;\n        return (prod % sum == 0) ? 1 : 0;\n    }\n    State st {pos, tight, started, hasZero, sum, prod};\n    if(dpMemo.count(st)) return dpMemo[st];\n    int res = 0;\n    int limit = tight ? ds[pos] : 9;\n    for (int d = 0; d <= limit; d++){\n        int ntight = tight && (d == limit);\n        int nstarted = started || (d > 0);\n        int nhasZero = hasZero;\n        int nsum = sum;\n        ll nprod = prod;\n        if(nstarted){\n            nsum += d;\n            if(d == 0)\n                nhasZero = 1;\n            else\n                nprod *= d;\n        }\n        res += dp(pos + 1, ntight, nstarted, nhasZero, nsum, nprod);\n    }\n    dpMemo[st] = res;\n    return res;\n}\n\nint countBeautiful(int x) {\n    ds.clear();\n    string s = to_string(x);\n    for (char c : s)\n        ds.pb(c - '0');\n    dpMemo.clear();\n    return dp(0, 1, 0, 0, 0, 1);\n}\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        const int threshold = 1000000;\n        if(r - l <= threshold){\n            int ans = 0;\n            rep(num, l, r + 1) {\n                int sum = 0, prod = 1;\n                bool hasZero = false;\n                for (int x = num; x; x /= 10) {\n                    int d = x % 10;\n                    if(d == 0) { hasZero = true; break; }\n                    sum += d; prod *= d;\n                }\n                if(hasZero)\n                    ans++;\n                else if(sum && prod % sum == 0)\n                    ans++;\n            }\n            return ans;\n        } else {\n            return countBeautiful(r) - countBeautiful(l - 1);\n        }\n    }\n};\n","author":"reform","submissionId":"1575238699"},[{"id":"168","similarity":0.8939260563380281,"totOverlap":2031,"longestOverlap":4}]],"308":[{"id":"308","fileName":"1575239924.txt","sourceCode":"class Solution {\n  int beautifulNumbers(int l, int r) {\n    String sn = \"\";\n    Map<int, int> kq = {};\n    int rc(int po, int ti, int st, int hz, int su, int e2, int e3, int e5, int e7) {\n      if (po == sn.length) {\n        if (st == 0) return 0;\n        if (hz == 1) return 1;\n        int pr = 1;\n        for (int i = 0; i < e2; i++) pr *= 2;\n        for (int i = 0; i < e3; i++) pr *= 3;\n        for (int i = 0; i < e5; i++) pr *= 5;\n        for (int i = 0; i < e7; i++) pr *= 7;\n        return (su != 0 && pr % su == 0) ? 1 : 0;\n      }\n      int ky = po;\n      ky |= (ti << 4);\n      ky |= (st << 5);\n      ky |= (hz << 6);\n      ky |= (su << 7);\n      ky |= (e2 << 14);\n      ky |= (e3 << 20);\n      ky |= (e5 << 26);\n      ky |= (e7 << 31);\n      if (kq.containsKey(ky)) return kq[ky]!;\n      int rs = 0;\n      int li = (ti == 1) ? int.parse(sn[po]) : 9;\n      for (int dg = 0; dg <= li; dg++) {\n        int nt = (ti == 1 && dg == li) ? 1 : 0;\n        if (st == 0) {\n          if (dg == 0) {\n            rs += rc(po + 1, nt, 0, 0, 0, 0, 0, 0, 0);\n          } else {\n            int ns = dg;\n            int a2 = 0, a3 = 0, a5 = 0, a7 = 0;\n            int tp = dg;\n            while (tp % 2 == 0) { a2++; tp ~/= 2; }\n            tp = dg;\n            while (tp % 3 == 0) { a3++; tp ~/= 3; }\n            tp = dg;\n            while (tp % 5 == 0) { a5++; tp ~/= 5; }\n            tp = dg;\n            while (tp % 7 == 0) { a7++; tp ~/= 7; }\n            rs += rc(po + 1, nt, 1, 0, ns, a2, a3, a5, a7);\n          }\n        } else {\n          if (hz == 1) {\n            int ns = su + dg;\n            rs += rc(po + 1, nt, 1, 1, ns, 0, 0, 0, 0);\n          } else {\n            if (dg == 0) {\n              int ns = su;\n              rs += rc(po + 1, nt, 1, 1, ns, 0, 0, 0, 0);\n            } else {\n              int ns = su + dg;\n              int a2 = e2, a3 = e3, a5 = e5, a7 = e7;\n              int tp = dg;\n              while (tp % 2 == 0) { a2++; tp ~/= 2; }\n              tp = dg;\n              while (tp % 3 == 0) { a3++; tp ~/= 3; }\n              tp = dg;\n              while (tp % 5 == 0) { a5++; tp ~/= 5; }\n              tp = dg;\n              while (tp % 7 == 0) { a7++; tp ~/= 7; }\n              rs += rc(po + 1, nt, 1, 0, ns, a2, a3, a5, a7);\n            }\n          }\n        }\n      }\n      kq[ky] = rs;\n      return rs;\n    }\n    int ct(int x) {\n      if (x < 1) return 0;\n      sn = x.toString();\n      kq.clear();\n      return rc(0, 1, 0, 0, 0, 0, 0, 0, 0);\n    }\n    return ct(r) - ct(l - 1);\n  }\n}\n","author":"VISHNUPPRIYAN","submissionId":"1575239924"},[{"id":"168","similarity":0.9026431718061674,"totOverlap":2049,"longestOverlap":5}]],"315":[{"id":"315","fileName":"1575241279.txt","sourceCode":"func beautifulNumbers(l int, r int) int {\n\tprecompute := []int{534358, 583898, 591896, 591205, 591317, 609302, 591001, 592266, 583871, 576418, 1000000, 579467, 587896, 586905, 588786, 606120, 588398, 592267, 579537, 575841, 1000000, 587896, 591317, 595049, 590081, 614798, 591441, 600624, 578591, 583378, 1000000, 586905, 595049, 586840, 595970, 614695, 588294, 602048, 588221, 573241, 1000000, 588786, 590081, 595970, 584537, 617367, 591109, 603657, 575510, 586396, 1000000, 606120, 614798, 614695, 617367, 602225, 618821, 629169, 610753, 608478, 1000000, 588398, 591441, 588294, 591109, 618821, 587776, 608498, 585012, 578020, 1000000, 592267, 600624, 602048, 603657, 629169, 608498, 593986, 602616, 600899, 1000000, 579537, 578591, 588221, 575510, 610753, 585012, 602616, 568430, 586020, 1000000, 575841, 583378, 573241, 586396, 608478, 578020, 600899, 586020, 566785, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 575270, 583641, 582185, 584134, 602118, 584640, 588604, 577654, 572392, 1000000, 583641, 588786, 591001, 584963, 612384, 589559, 598226, 577580, 582030, 1000000, 582185, 591001, 582255, 591441, 611092, 585510, 599027, 586436, 570691, 1000000, 584134, 584963, 591441, 582567, 613279, 588221, 602167, 573283, 585245, 1000000, 602118, 612384, 611092, 613279, 600858, 618087, 626444, 608236, 607216, 1000000, 584640, 589559, 585510, 588221, 618087, 586396, 608559, 583783, 578479, 1000000, 588604, 598226, 599027, 602167, 626444, 608559, 594791, 599661, 600718, 1000000, 577654, 577580, 586436, 573283, 608236, 583783, 599661, 567519, 583934, 1000000, 572392, 582030, 570691, 585245, 607216, 578479, 600718, 583934, 567715, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 583641, 588786, 591001, 584963, 612384, 589559, 598226, 577580, 582030, 1000000, 588786, 590081, 595970, 584537, 617367, 591109, 603657, 575510, 586396, 1000000, 591001, 595970, 590928, 592625, 622132, 590078, 609678, 586990, 580316, 1000000, 584963, 584537, 592625, 579542, 615486, 587682, 604352, 572037, 587788, 1000000, 612384, 617367, 622132, 615486, 612223, 622612, 636283, 608165, 617368, 1000000, 589559, 591109, 590078, 587682, 622612, 588228, 612473, 582735, 582321, 1000000, 598226, 603657, 609678, 604352, 636283, 612473, 604184, 600363, 609929, 1000000, 577580, 575510, 586990, 572037, 608165, 582735, 600363, 566723, 585294, 1000000, 582030, 586396, 580316, 587788, 617368, 582321, 609929, 585294, 576351, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 582185, 591001, 582255, 591441, 611092, 585510, 599027, 586436, 570691, 1000000, 591001, 595970, 590928, 592625, 622132, 590078, 609678, 586990, 580316, 1000000, 582255, 590928, 577555, 591753, 612899, 582648, 602870, 588228, 569082, 1000000, 591441, 592625, 591753, 590477, 623785, 590182, 614076, 583813, 583981, 1000000, 611092, 622132, 612899, 623785, 614242, 620429, 638661, 619910, 605611, 1000000, 585510, 590078, 582648, 590182, 620429, 584176, 611627, 586560, 577372, 1000000, 599027, 609678, 602870, 614076, 638661, 611627, 609499, 612496, 600609, 1000000, 586436, 586990, 588228, 583813, 619910, 586560, 612496, 579846, 584366, 1000000, 570691, 580316, 569082, 583981, 605611, 577372, 600609, 584366, 566878, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 584134, 584963, 591441, 582567, 613279, 588221, 602167, 573283, 585245, 1000000, 584963, 584537, 592625, 579542, 615486, 587682, 604352, 572037, 587788, 1000000, 591441, 592625, 591753, 590477, 623785, 590182, 614076, 583813, 583981, 1000000, 582567, 579542, 590477, 575516, 612283, 585438, 603558, 568430, 586560, 1000000, 613279, 615486, 623785, 612283, 615743, 622683, 636881, 603213, 619674, 1000000, 588221, 587682, 590182, 585438, 622683, 587313, 615222, 580700, 586269, 1000000, 602167, 604352, 614076, 603558, 636881, 615222, 609954, 597698, 613878, 1000000, 573283, 572037, 583813, 568430, 603213, 580700, 597698, 564136, 584165, 1000000, 585245, 587788, 583981, 586560, 619674, 586269, 613878, 584165, 581477, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 602118, 612384, 611092, 613279, 600858, 618087, 626444, 608236, 607216, 1000000, 612384, 617367, 622132, 615486, 612223, 622612, 636283, 608165, 617368, 1000000, 611092, 622132, 612899, 623785, 614242, 620429, 638661, 619910, 605611, 1000000, 613279, 615486, 623785, 612283, 615743, 622683, 636881, 603213, 619674, 1000000, 600858, 612223, 614242, 615743, 598921, 624621, 631714, 613852, 616482, 1000000, 618087, 622612, 620429, 622683, 624621, 620526, 643263, 615253, 611196, 1000000, 626444, 636283, 638661, 636881, 631714, 643263, 627391, 627137, 630130, 1000000, 608236, 608165, 619910, 603213, 613852, 615253, 627137, 594090, 614049, 1000000, 607216, 617368, 605611, 619674, 616482, 611196, 630130, 614049, 595640, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 584640, 589559, 585510, 588221, 618087, 586396, 608559, 583783, 578479, 1000000, 589559, 591109, 590078, 587682, 622612, 588228, 612473, 582735, 582321, 1000000, 585510, 590078, 582648, 590182, 620429, 584176, 611627, 586560, 577372, 1000000, 588221, 587682, 590182, 585438, 622683, 587313, 615222, 580700, 586269, 1000000, 618087, 622612, 620429, 622683, 624621, 620526, 643263, 615253, 611196, 1000000, 586396, 588228, 584176, 587313, 620526, 585071, 613638, 584632, 580304, 1000000, 608559, 612473, 611627, 615222, 643263, 613638, 617640, 610272, 606875, 1000000, 583783, 582735, 586560, 580700, 615253, 584632, 610272, 576814, 584635, 1000000, 578479, 582321, 577372, 586269, 611196, 580304, 606875, 584635, 573175, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 588604, 598226, 599027, 602167, 626444, 608559, 594791, 599661, 600718, 1000000, 598226, 603657, 609678, 604352, 636283, 612473, 604184, 600363, 609929, 1000000, 599027, 609678, 602870, 614076, 638661, 611627, 609499, 612496, 600609, 1000000, 602167, 604352, 614076, 603558, 636881, 615222, 609954, 597698, 613878, 1000000, 626444, 636283, 638661, 636881, 631714, 643263, 627391, 627137, 630130, 1000000, 608559, 612473, 611627, 615222, 643263, 613638, 617640, 610272, 606875, 1000000, 594791, 604184, 609499, 609954, 627391, 617640, 591402, 606746, 608714, 1000000, 599661, 600363, 612496, 597698, 627137, 610272, 606746, 592120, 611416, 1000000, 600718, 609929, 600609, 613878, 630130, 606875, 608714, 611416, 593524, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 577654, 577580, 586436, 573283, 608236, 583783, 599661, 567519, 583934, 1000000, 577580, 575510, 586990, 572037, 608165, 582735, 600363, 566723, 585294, 1000000, 586436, 586990, 588228, 583813, 619910, 586560, 612496, 579846, 584366, 1000000, 573283, 572037, 583813, 568430, 603213, 580700, 597698, 564136, 584165, 1000000, 608236, 608165, 619910, 603213, 613852, 615253, 627137, 594090, 614049, 1000000, 583783, 582735, 586560, 580700, 615253, 584632, 610272, 576814, 584635, 1000000, 599661, 600363, 612496, 597698, 627137, 610272, 606746, 592120, 611416, 1000000, 567519, 566723, 579846, 564136, 594090, 576814, 592120, 560705, 582429, 1000000, 583934, 585294, 584366, 584165, 614049, 584635, 611416, 582429, 581474, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 572392, 582030, 570691, 585245, 607216, 578479, 600718, 583934, 567715, 1000000, 582030, 586396, 580316, 587788, 617368, 582321, 609929, 585294, 576351, 1000000, 570691, 580316, 569082, 583981, 605611, 577372, 600609, 584366, 566878, 1000000, 585245, 587788, 583981, 586560, 619674, 586269, 613878, 584165, 581477, 1000000, 607216, 617368, 605611, 619674, 616482, 611196, 630130, 614049, 595640, 1000000, 578479, 582321, 577372, 586269, 611196, 580304, 606875, 584635, 573175, 1000000, 600718, 609929, 600609, 613878, 630130, 606875, 608714, 611416, 593524, 1000000, 583934, 585294, 584366, 584165, 614049, 584635, 611416, 582429, 581474, 1000000, 567715, 576351, 566878, 581477, 595640, 573175, 593524, 581474, 560967}\n\n\tproduct := func(v int) int {\n\t\tpro := 1\n\t\tfor ; v > 0; v /= 10 {\n\t\t\tpro *= v % 10\n\t\t}\n\t\treturn pro\n\t}\n\n\tsum := func(v int) int {\n\t\tsum := 0\n\t\tfor ; v > 0; v /= 10 {\n\t\t\tsum += v % 10\n\t\t}\n\t\treturn sum\n\t}\n\n\tans := 0\n\tfor i, j := 0, 0; i < len(precompute); i, j = i+1, j+10_000_00 {\n\t\tif l <= j+1 && r >= j+10_000_00 {\n\t\t\tans += precompute[i]\n\t\t} else {\n\t\t\tfor x := max(j+1, l); x <= min(j+10_000_00, r); x++ {\n\t\t\t\tprod, digit := product(x), sum(x)\n\t\t\t\tif prod%digit == 0 {\n\t\t\t\t\tans++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}","author":"yap","submissionId":"1575241279"},[{"id":"168","similarity":0.9589085072231139,"totOverlap":2987,"longestOverlap":993}]],"326":[{"id":"326","fileName":"611231009.txt","sourceCode":"typedef long long ll;\nstruct State {\n    int pos, tight, started, sum, hasZero, e2, e3, e5, e7;\n    bool operator==(const State &o) const {\n        return pos==o.pos && tight==o.tight && started==o.started && sum==o.sum && hasZero==o.hasZero && e2==o.e2 && e3==o.e3 && e5==o.e5 && e7==o.e7;\n    }\n};\nstruct StateHash {\n    size_t operator()(const State &st) const {\n        size_t res = 17;\n        res = res*31 + hash<int>()(st.pos);\n        res = res*31 + hash<int>()(st.tight);\n        res = res*31 + hash<int>()(st.started);\n        res = res*31 + hash<int>()(st.sum);\n        res = res*31 + hash<int>()(st.hasZero);\n        res = res*31 + hash<int>()(st.e2);\n        res = res*31 + hash<int>()(st.e3);\n        res = res*31 + hash<int>()(st.e5);\n        res = res*31 + hash<int>()(st.e7);\n        return res;\n    }\n};\nstring num;\nunordered_map<State,ll,StateHash> memo;\nll dfs(int pos, int tight, int started, int sum, int hasZero, int e2, int e3, int e5, int e7) {\n    if(pos==num.size()){\n        if(!started) return 0;\n        if(hasZero) return 1;\n        if(sum==0) return 0;\n        ll prod = 1;\n        for(int i=0;i<e2;i++) prod*=2;\n        for(int i=0;i<e3;i++) prod*=3;\n        for(int i=0;i<e5;i++) prod*=5;\n        for(int i=0;i<e7;i++) prod*=7;\n        return (prod % sum == 0) ? 1 : 0;\n    }\n    State st{pos,tight,started,sum,hasZero,e2,e3,e5,e7};\n    if(memo.count(st)) return memo[st];\n    ll res = 0;\n    int up = tight ? num[pos]-'0' : 9;\n    for(int d=0; d<=up; d++){\n        int ntight = (tight && d==up);\n        int nstarted = started || (d>0);\n        int nsum = sum;\n        int nhasZero = hasZero;\n        int ne2 = e2, ne3 = e3, ne5 = e5, ne7 = e7;\n        if(nstarted){\n            nsum += d;\n            if(d==0) nhasZero = 1;\n            else {\n                if(d==2) ne2++;\n                else if(d==3) ne3++;\n                else if(d==4) ne2 += 2;\n                else if(d==5) ne5++;\n                else if(d==6){ ne2++; ne3++; }\n                else if(d==7) ne7++;\n                else if(d==8) ne2 += 3;\n                else if(d==9) ne3 += 2;\n            }\n        }\n        res += dfs(pos+1, ntight, nstarted, nsum, nhasZero, ne2, ne3, ne5, ne7);\n    }\n    memo[st]=res;\n    return res;\n}\nll solve(ll x){\n    num = to_string(x);\n    memo.clear();\n    return dfs(0,1,0,0,0,0,0,0,0);\n}\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        return solve(r) - solve(l-1);\n    }\n};","author":"Hungry Ishizaka4ZT","submissionId":"611231009"},[{"id":"168","similarity":0.8779119930974978,"totOverlap":2035,"longestOverlap":8}]],"327":[{"id":"327","fileName":"611236179.txt","sourceCode":"#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#define ALL(v) v.begin(),v.end()\n#define For(i,_) for(int i=0,i##end=_;i<i##end;++i) // [0,_)\n#define FOR(i,_,__) for(int i=_,i##end=__;i<i##end;++i) // [_,__)\n#define Rep(i,_) for(int i=(_)-1;i>=0;--i) // [0,_)\n#define REP(i,_,__) for(int i=(__)-1,i##end=_;i>=i##end;--i) // [_,__)\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define V vector\n#define pb push_back\n#define pf push_front\n#define qb pop_back\n#define qf pop_front\n#define eb emplace_back\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\n#define fi first\n#define se second\nconst int dir[4][2]={{-1,0},{0,1},{1,0},{0,-1}},inf=0x3f3f3f3f,mod=1e9+7;\nconst ll infl=0x3f3f3f3f3f3f3f3fll;\ntemplate<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,1:0;}\nint init=[](){return cin.tie(nullptr)->sync_with_stdio(false),0;}();\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        auto calc=[&](int x)->ll{\n            if(x<1)return 0;\n            string s=to_string(x);\n            V<int>dgt;\n            for(char c:s)dgt.pb(c^48);\n            using ans_t=tuple<int,int,int,int,int,int>;\n            unordered_map<ans_t,ll,function<size_t(const ans_t&)>>memo(0,[&](const ans_t &t)->size_t{\n                auto [p,q,r,s,u,v]=t;\n                size_t h=0;\n                for(int i:{p,q,r,s,u,v})h=h*2333+i;\n                return h;\n            });\n            function<ll(int,int,int,int,int,int)>dfs=[&](int p,int tp,int st,int sum,int prod,int z)->ll{\n                if(p==dgt.size()){\n                    if(!st)return 0;\n                    return z||prod%sum==0;\n                }\n                ans_t k=make_tuple(p,tp,st,sum,prod,z);\n                auto it=memo.emplace(k,0);\n                if(!it.se)return it.fi->se;\n                int up=tp?dgt[p]:9;\n                For(d,up+1){\n                    int nt=tp&&d==up;\n                    if(!st){\n                        if(!d)it.fi->se+=dfs(p+1,nt,0,0,1,0);\n                        else it.fi->se+=dfs(p+1,nt,1,d,d,0);\n                    }else{\n                        if(z)it.fi->se+=dfs(p+1,nt,1,sum+d,0,1);\n                        else{\n                            if(!d)it.fi->se+=dfs(p+1,nt,1,sum,0,1);\n                            else it.fi->se+=dfs(p+1,nt,1,sum+d,prod*d,0);\n                        }\n                    }\n                }\n                return it.fi->se;\n            };\n            return dfs(0,1,0,0,1,0);\n        };\n        return calc(r)-calc(l-1);\n    }\n};","author":"drizzlo","submissionId":"611236179"},[{"id":"168","similarity":0.8883987648875166,"totOverlap":2014,"longestOverlap":4}]],"329":[{"id":"329","fileName":"611241688.txt","sourceCode":"class Solution {\n    private static final int[] mem = {0,9,15,309,3675,43462,486887,5311174,57110375,607393752,2092560258};\n\n    public int beautifulNumbers(int l, int r) {\n        return count(r) - count(l - 1);\n    }\n\n    private int count(int n) {\n        if (n == 0) return 0;\n        String num = String.valueOf(n);\n        int max = num.length() * 9;\n        int res = 0;\n        for (int i = 0; i < num.length(); ++i) {\n            res += mem[i];\n        }\n        for (int i = 1; i <= max; ++i) {\n            Integer[][][][] dp = new Integer[num.length()][2][max + 1][max + 1];\n            res += helper(dp, 0, 0, 1, i, i, num);\n        }\n        return res;\n    }\n\n    private int helper(Integer[][][][] dp, int pos, int restrict, int mul, int remain, int target, String num) {\n        if (pos == dp.length) {\n            if (remain != 0) {\n                return 0;\n            } else {\n                return mul % target == 0 ? 1 : 0;\n            }\n        } else if (dp[pos][restrict][remain][mul] == null) {\n            int st = 0, ed = Math.min(9, remain), res = 0;\n            if (pos == 0) st = 1;\n            if (restrict == 0) {\n                ed = Math.min(ed, num.charAt(pos) - '0');\n            }\n            for (int i = st; i <= ed; ++i) {\n                if (restrict == 0 && i == num.charAt(pos) - '0') {\n                    res += helper(dp, pos + 1, 0,mul * i % target, remain - i, target, num);\n                } else {\n                    res += helper(dp, pos + 1, 1,mul * i % target, remain - i, target, num);\n                }\n            }\n            dp[pos][restrict][remain][mul] = res;\n        }\n        return dp[pos][restrict][remain][mul];\n    }\n}","author":"NeoStart","submissionId":"611241688"},[{"id":"168","similarity":0.9287345820009136,"totOverlap":2033,"longestOverlap":7}]],"342":[{"id":"342","fileName":"611246827.txt","sourceCode":"typedef long long ll;\n\nstruct ddState {\n    int index, isTight, hasf, ddSum, con0, cnt2, cnt3, cnt5, cnt7;\n    \n    bool operator==(const ddState &other) const {\n        return index == other.index && isTight == other.isTight && hasf == other.hasf && \n               ddSum == other.ddSum && con0 == other.con0 && cnt2 == other.cnt2 && \n               cnt3 == other.cnt3 && cnt5 == other.cnt5 && cnt7 == other.cnt7;\n    }\n\n    bool operator<(const ddState &other) const {\n        if (index != other.index) return index < other.index;\n        if (isTight != other.isTight) return isTight < other.isTight;\n        if (hasf != other.hasf) return hasf < other.hasf;\n        if (ddSum != other.ddSum) return ddSum < other.ddSum;\n        if (con0 != other.con0) return con0 < other.con0;\n        if (cnt2 != other.cnt2) return cnt2 < other.cnt2;\n        if (cnt3 != other.cnt3) return cnt3 < other.cnt3;\n        if (cnt5 != other.cnt5) return cnt5 < other.cnt5;\n        return cnt7 < other.cnt7;\n    }\n};\n\nstring numStr;\nmap<ddState, ll> hsh;\n\nll cntBeautiful(int index, int isTight, int hasf, int ddSum, int con0, int cnt2, int cnt3, int cnt5, int cnt7) {\n    if (index == numStr.size()) {\n        if (!hasf) return 0;\n        if (con0) return 1;\n        if (ddSum == 0) return 0;\n        ll product = 1;\n        for (int i = 0; i < cnt2; i++) product *= 2;\n        for (int i = 0; i < cnt3; i++) product *= 3;\n        for (int i = 0; i < cnt5; i++) product *= 5;\n        for (int i = 0; i < cnt7; i++) product *= 7;\n        return (product % ddSum == 0) ? 1 : 0;\n    }\n    ddState state{index, isTight, hasf, ddSum, con0, cnt2, cnt3, cnt5, cnt7};\n    if (hsh.count(state)) return hsh[state];\n    ll result = 0;\n    int upperLimit = isTight ? numStr[index] - '0' : 9;\n    for (int dd = 0; dd <= upperLimit; dd++) {\n        int nextTight = (isTight && dd == upperLimit);\n        int nextStarted = hasf || (dd > 0);\n        int nextSum = ddSum;\n        int nextcon0 = con0;\n        int nextcnt2 = cnt2, nextcnt3 = cnt3, nextcnt5 = cnt5, nextcnt7 = cnt7;\n        if (nextStarted) {\n            nextSum += dd;\n            if (dd == 0) nextcon0 = 1;\n            else {\n                if (dd == 2) nextcnt2++;\n                else if (dd == 3) nextcnt3++;\n                else if (dd == 4) nextcnt2 += 2;\n                else if (dd == 5) nextcnt5++;\n                else if (dd == 6) { nextcnt2++; nextcnt3++; }\n                else if (dd == 7) nextcnt7++;\n                else if (dd == 8) nextcnt2 += 3;\n                else if (dd == 9) nextcnt3 += 2;\n            }\n        }\n        result += cntBeautiful(index + 1, nextTight, nextStarted, nextSum, nextcon0, nextcnt2, nextcnt3, nextcnt5, nextcnt7);\n    }\n    hsh[state] = result;\n    return result;\n}\n\nll calBeautiful(ll x) {\n    numStr = to_string(x);\n    hsh.clear();\n    return cntBeautiful(0, 1, 0, 0, 0, 0, 0, 0, 0);\n}\n\nclass Solution {\npublic:\n    int beautifulNumbers(int left, int right) {\n        return calBeautiful(right) - calBeautiful(left - 1);\n    }\n};","author":"程序猴","submissionId":"611246827"},[{"id":"168","similarity":0.8976621085134538,"totOverlap":2035,"longestOverlap":8}]],"360":[{"id":"360","fileName":"611250709.txt","sourceCode":"class Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        constexpr int blocks[101] = {\n            0,\n            5845532,\n            12130749,\n            18463924,\n            24795187,\n            31128600,\n            37651026,\n            43988395,\n            50422159,\n            56696849,\n            62955907,\n            72955907,\n            79206545,\n            85514715,\n            91814353,\n            98119653,\n            104619367,\n            110942601,\n            117360798,\n            123618884,\n            129867304,\n            139867304,\n            146175474,\n            152508887,\n            158868605,\n            165177617,\n            171741637,\n            178088434,\n            184567579,\n            190822976,\n            197130769,\n            207130769,\n            213430407,\n            219790125,\n            226088343,\n            232450476,\n            239019237,\n            245347819,\n            251846362,\n            258175007,\n            264413913,\n            274413913,\n            280719213,\n            287028225,\n            293390358,\n            299674729,\n            306237756,\n            312581466,\n            319079252,\n            325306727,\n            331635764,\n            341635764,\n            348135478,\n            354699498,\n            361268259,\n            367831286,\n            374359942,\n            380958612,\n            387656516,\n            394160421,\n            400677787,\n            410677787,\n            417001021,\n            423347818,\n            429676400,\n            436020110,\n            442618780,\n            448949064,\n            455488633,\n            461794017,\n            468074643,\n            478074643,\n            484492840,\n            490971985,\n            497470528,\n            503968314,\n            510666218,\n            517205787,\n            523676108,\n            530134017,\n            536609810,\n            546609810,\n            552867896,\n            559123293,\n            565451938,\n            571679413,\n            578183318,\n            584488702,\n            590946611,\n            597130993,\n            603442755,\n            613442755,\n            619691175,\n            625998968,\n            632237874,\n            638566911,\n            645084277,\n            651364903,\n            657840696,\n            664152458\n    };\n        auto calc=[&](int x){\n            if(x==0)\n                return 0;\n            int b=x/10000000;\n            int ans=blocks[b];\n            for(int i=1+b*10000000;i<=x;i++){\n                int t=i,a=1,b=0;\n                while(t){\n                    a*=t%10;\n                    b+=t%10;\n                    t=t/10;\n                }\n                if(a%b==0)\n                    ans++;\n            }\n            return ans;\n        };\n        return calc(r)-calc(l-1);\n    }\n};","author":"Max.D.","submissionId":"611250709"},[{"id":"168","similarity":0.9625228519195612,"totOverlap":2106,"longestOverlap":94}]],"366":[{"id":"366","fileName":"611253422.txt","sourceCode":"// const int p[5] = {0, 2, 3, 5, 7};\n// int pcnt[10][5] = {\n// {1, 0, 0, 0, 0},\n// {0, 0, 0, 0, 0},\n// {0, 1, 0, 0, 0},\n// {0, 0, 1, 0, 0},\n// {0, 2, 0, 0, 0},\n// {0, 0, 0, 1, 0},\n// {0, 1, 1, 0, 0},\n// {0, 0, 0, 0, 1},\n// {0, 3, 0, 0, 0},\n// {0, 0, 2, 0, 0},\n// };\n\n// int f[10][10][30][20][10][10];\n\nint N = 1e6;\nint ans[] = {0,534358,1118256,1710152,2301357,2892674,3501976,4092977,4685243,5269114,5845532,6845532,7424999,8012895,8599800,9188586,9794706,10383104,10975371,11554908,12130749,13130749,13718645,14309962,14905011,15495092,16109890,16701331,17301955,17880546,18463924,19463924,20050829,20645878,21232718,21828688,22443383,23031677,23633725,24221946,24795187,25795187,26383973,26974054,27570024,28154561,28771928,29363037,29966694,30542204,31128600,32128600,32734720,33349518,33964213,34581580,35183805,35802626,36431795,37042548,37651026,38651026,39239424,39830865,40419159,41010268,41629089,42216865,42825363,43410375,43988395,44988395,45580662,46181286,46783334,47386991,48016160,48624658,49218644,49821260,50422159,51422159,52001696,52580287,53168508,53744018,54354771,54939783,55542399,56110829,56696849,57696849,58272690,58856068,59429309,60015705,60624183,61202203,61803102,62389122,62955907,63955907,64955907,65955907,66955907,67955907,68955907,69955907,70955907,71955907,72955907,73955907,74531177,75114818,75697003,76281137,76883255,77467895,78056499,78634153,79206545,80206545,80790186,81378972,81969973,82554936,83167320,83756879,84355105,84932685,85514715,86514715,87096900,87687901,88270156,88861597,89472689,90058199,90657226,91243662,91814353,92814353,93398487,93983450,94574891,95157458,95770737,96358958,96961125,97534408,98119653,99119653,99721771,100334155,100945247,101558526,102159384,102777471,103403915,104012151,104619367,105619367,106204007,106793566,107379076,107967297,108585384,109171780,109780339,110364122,110942601,111942601,112531205,113129431,113728458,114330625,114957069,115565628,116160419,116760080,117360798,118360798,118938452,119516032,120102468,120675751,121283987,121867770,122467431,123034950,123618884,124618884,125191276,125773306,126343997,126929242,127536458,128114937,128715655,129299589,129867304,130867304,131867304,132867304,133867304,134867304,135867304,136867304,137867304,138867304,139867304,140867304,141450945,142039731,142630732,143215695,143828079,144417638,145015864,145593444,146175474,147175474,147764260,148354341,148950311,149534848,150152215,150743324,151346981,151922491,152508887,153508887,154099888,154695858,155286786,155879411,156501543,157091621,157701299,158288289,158868605,159868605,160453568,161038105,161630730,162210272,162825758,163413440,164017792,164589829,165177617,166177617,166790001,167407368,168029500,168644986,169257209,169879821,170516104,171124269,171741637,172741637,173331196,173922305,174512383,175100065,175722677,176310905,176923378,177506113,178088434,179088434,179686660,180290317,180899995,181504347,182140630,182753103,183357287,183957650,184567579,185567579,186145159,186720669,187307659,187879696,188487861,189070596,189670959,190237682,190822976,191822976,192405006,192991402,193571718,194159506,194776874,195359195,195969124,196554418,197130769,198130769,199130769,200130769,201130769,202130769,203130769,204130769,205130769,206130769,207130769,208130769,208712954,209303955,209886210,210477651,211088743,211674253,212273280,212859716,213430407,214430407,215021408,215617378,216208306,216800931,217423063,218013141,218622819,219209809,219790125,220790125,221372380,221963308,222540863,223132616,223745515,224328163,224931033,225519261,226088343,227088343,227679784,228272409,228864162,229454639,230078424,230668606,231282682,231866495,232450476,233450476,234061568,234683700,235296599,235920384,236534626,237155055,237793716,238413626,239019237,240019237,240604747,241194825,241777473,242367655,242988084,243572260,244183887,244770447,245347819,246347819,246946846,247556524,248159394,248773470,249412131,250023758,250633257,251245753,251846362,252846362,253432798,254019788,254608016,255191829,255811739,256398299,257010795,257590641,258175007,259175007,259745698,260326014,260895096,261479077,262084688,262662060,263262669,263847035,264413913,265413913,266413913,267413913,268413913,269413913,270413913,271413913,272413913,273413913,274413913,275413913,275998047,276583010,277174451,277757018,278370297,278958518,279560685,280133968,280719213,281719213,282304176,282888713,283481338,284060880,284676366,285264048,285868400,286440437,287028225,288028225,288619666,289212291,289804044,290394521,291018306,291608488,292222564,292806377,293390358,294390358,294972925,295552467,296142944,296718460,297330743,297916181,298519739,299088169,299674729,300674729,301288008,301903494,302527279,303139562,303755305,304377988,305014869,305618082,306237756,307237756,307825977,308413659,309003841,309589279,310211962,310799275,311414497,311995197,312581466,313581466,314183633,314787985,315402061,316005619,316642500,317257722,317867676,318465374,319079252,320079252,320652535,321224572,321808385,322376815,322980028,323560728,324158426,324722562,325306727,326306727,326891972,327479760,328063741,328650301,329269975,329856244,330470122,331054287,331635764,332635764,333635764,334635764,335635764,336635764,337635764,338635764,339635764,340635764,341635764,342635764,343237882,343850266,344461358,345074637,345675495,346293582,346920026,347528262,348135478,349135478,349747862,350365229,350987361,351602847,352215070,352837682,353473965,354082130,354699498,355699498,356310590,356932722,357545621,358169406,358783648,359404077,360042738,360662648,361268259,362268259,362881538,363497024,364120809,364733092,365348835,365971518,366608399,367211612,367831286,368831286,369432144,370044367,370658609,371274352,371873273,372497894,373129608,373743460,374359942,375359942,375978029,376600641,377221070,377843753,378468374,379088900,379732163,380347416,380958612,381958612,382585056,383221339,383860000,384496881,385128595,385771858,386399249,387026386,387656516,388656516,389264752,389872917,390492827,391096040,391709892,392325145,392952282,393546372,394160421,395160421,395767637,396385005,396990616,397610290,398226772,398837968,399468098,400082147,400677787,401677787,402677787,403677787,404677787,405677787,406677787,407677787,408677787,409677787,410677787,411677787,412262427,412851986,413437496,414025717,414643804,415230200,415838759,416422542,417001021,418001021,418590580,419181689,419771767,420359449,420982061,421570289,422182762,422765497,423347818,424347818,424933328,425523406,426106054,426696236,427316665,427900841,428512468,429099028,429676400,430676400,431264621,431852303,432442485,433027923,433650606,434237919,434853141,435433841,436020110,437020110,437638197,438260809,438881238,439503921,440128542,440749068,441392331,442007584,442618780,443618780,444205176,444793404,445377580,445964893,446585419,447170490,447784128,448368760,448949064,449949064,450557623,451170096,451781723,452396945,453040208,453653846,454271486,454881758,455488633,456488633,457072416,457655151,458241711,458822411,459437664,460022296,460632568,461209382,461794017,462794017,463372496,463954817,464532189,465118458,465729654,466309958,466916833,467501468,468074643,469074643,470074643,471074643,472074643,473074643,474074643,475074643,476074643,477074643,478074643,479074643,479663247,480261473,480860500,481462667,482089111,482697670,483292461,483892122,484492840,485492840,486091066,486694723,487304401,487908753,488545036,489157509,489761693,490362056,490971985,491971985,492571012,493180690,493783560,494397636,495036297,495647924,496257423,496869919,497470528,498470528,499072695,499677047,500291123,500894681,501531562,502146784,502756738,503354436,503968314,504968314,505594758,506231041,506869702,507506583,508138297,508781560,509408951,510036088,510666218,511666218,512274777,512887250,513498877,514114099,514757362,515371000,515988640,516598912,517205787,518205787,518800578,519404762,520014261,520624215,521251606,521869246,522460648,523067394,523676108,524676108,525275769,525876132,526488628,527086326,527713463,528323735,528930481,529522601,530134017,531134017,531734735,532344664,532945273,533559151,534189281,534796156,535404870,536016286,536609810,537609810,538609810,539609810,540609810,541609810,542609810,543609810,544609810,545609810,546609810,547609810,548187464,548765044,549351480,549924763,550532999,551116782,551716443,552283962,552867896,553867896,554445476,555020986,555607976,556180013,556788178,557370913,557971276,558537999,559123293,560123293,560709729,561296719,561884947,562468760,563088670,563675230,564287726,564867572,565451938,566451938,567025221,567597258,568181071,568749501,569352714,569933414,570531112,571095248,571679413,572679413,573287649,573895814,574515724,575118937,575732789,576348042,576975179,577569269,578183318,579183318,579767101,580349836,580936396,581517096,582132349,582716981,583327253,583904067,584488702,585488702,586088363,586688726,587301222,587898920,588526057,589136329,589743075,590335195,590946611,591946611,592514130,593080853,593660699,594224835,594818925,595395739,595987859,596548564,597130993,598130993,598714927,599300221,599884587,600468752,601082801,601667436,602278852,602861281,603442755,604442755,605442755,606442755,607442755,608442755,609442755,610442755,611442755,612442755,613442755,614442755,615015147,615597177,616167868,616753113,617360329,617938808,618539526,619123460,619691175,620691175,621273205,621859601,622439917,623027705,623645073,624227394,624837323,625422617,625998968,626998968,627569659,628149975,628719057,629303038,629908649,630486021,631086630,631670996,632237874,633237874,633823119,634410907,634994888,635581448,636201122,636787391,637401269,637985434,638566911,639566911,640174127,640791495,641397106,642016780,642633262,643244458,643874588,644488637,645084277,646084277,646662756,647245077,647822449,648408718,649019914,649600218,650207093,650791728,651364903,652364903,652965621,653575550,654176159,654790037,655420167,656027042,656635756,657247172,657840696,658840696,659424630,660009924,660594290,661178455,661792504,662377139,662988555,663570984,664152458,665152458,665720173,666296524,666863402,667444879,668040519,668613694,669207218,669788692,670349659};\n\nint calc(int q){\n    int p = q / N;\n    int ret = ans[p];\n    for(int i = p * N + 1; i <= q; i++){\n        int m = 1;\n\t\tint s = 0;\n\t\tint x = i;\n\t\twhile(x){\n\t\t\tm *= x % 10;\n\t\t\ts += x % 10;\n\t\t\tx /= 10;\n\t\t}\n\t\tif(m % s == 0) ret++;\n    }\n    return ret;\n}\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        return calc(r) - calc(l - 1);\n    }\n};","author":"dhxh","submissionId":"611253422"},[{"id":"168","similarity":0.9764135702746365,"totOverlap":3022,"longestOverlap":998}]],"367":[{"id":"367","fileName":"611252413.txt","sourceCode":"const int s[] = {534358,583898,591896,591205,591317,609302,591001,592266,583871,576418,1000000,579467,587896,586905,588786,606120,588398,592267,579537,575841,1000000,587896,591317,595049,590081,614798,591441,600624,578591,583378,1000000,586905,595049,586840,595970,614695,588294,602048,588221,573241,1000000,588786,590081,595970,584537,617367,591109,603657,575510,586396,1000000,606120,614798,614695,617367,602225,618821,629169,610753,608478,1000000,588398,591441,588294,591109,618821,587776,608498,585012,578020,1000000,592267,600624,602048,603657,629169,608498,593986,602616,600899,1000000,579537,578591,588221,575510,610753,585012,602616,568430,586020,1000000,575841,583378,573241,586396,608478,578020,600899,586020,566785,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,575270,583641,582185,584134,602118,584640,588604,577654,572392,1000000,583641,588786,591001,584963,612384,589559,598226,577580,582030,1000000,582185,591001,582255,591441,611092,585510,599027,586436,570691,1000000,584134,584963,591441,582567,613279,588221,602167,573283,585245,1000000,602118,612384,611092,613279,600858,618087,626444,608236,607216,1000000,584640,589559,585510,588221,618087,586396,608559,583783,578479,1000000,588604,598226,599027,602167,626444,608559,594791,599661,600718,1000000,577654,577580,586436,573283,608236,583783,599661,567519,583934,1000000,572392,582030,570691,585245,607216,578479,600718,583934,567715,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,583641,588786,591001,584963,612384,589559,598226,577580,582030,1000000,588786,590081,595970,584537,617367,591109,603657,575510,586396,1000000,591001,595970,590928,592625,622132,590078,609678,586990,580316,1000000,584963,584537,592625,579542,615486,587682,604352,572037,587788,1000000,612384,617367,622132,615486,612223,622612,636283,608165,617368,1000000,589559,591109,590078,587682,622612,588228,612473,582735,582321,1000000,598226,603657,609678,604352,636283,612473,604184,600363,609929,1000000,577580,575510,586990,572037,608165,582735,600363,566723,585294,1000000,582030,586396,580316,587788,617368,582321,609929,585294,576351,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,582185,591001,582255,591441,611092,585510,599027,586436,570691,1000000,591001,595970,590928,592625,622132,590078,609678,586990,580316,1000000,582255,590928,577555,591753,612899,582648,602870,588228,569082,1000000,591441,592625,591753,590477,623785,590182,614076,583813,583981,1000000,611092,622132,612899,623785,614242,620429,638661,619910,605611,1000000,585510,590078,582648,590182,620429,584176,611627,586560,577372,1000000,599027,609678,602870,614076,638661,611627,609499,612496,600609,1000000,586436,586990,588228,583813,619910,586560,612496,579846,584366,1000000,570691,580316,569082,583981,605611,577372,600609,584366,566878,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,584134,584963,591441,582567,613279,588221,602167,573283,585245,1000000,584963,584537,592625,579542,615486,587682,604352,572037,587788,1000000,591441,592625,591753,590477,623785,590182,614076,583813,583981,1000000,582567,579542,590477,575516,612283,585438,603558,568430,586560,1000000,613279,615486,623785,612283,615743,622683,636881,603213,619674,1000000,588221,587682,590182,585438,622683,587313,615222,580700,586269,1000000,602167,604352,614076,603558,636881,615222,609954,597698,613878,1000000,573283,572037,583813,568430,603213,580700,597698,564136,584165,1000000,585245,587788,583981,586560,619674,586269,613878,584165,581477,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,602118,612384,611092,613279,600858,618087,626444,608236,607216,1000000,612384,617367,622132,615486,612223,622612,636283,608165,617368,1000000,611092,622132,612899,623785,614242,620429,638661,619910,605611,1000000,613279,615486,623785,612283,615743,622683,636881,603213,619674,1000000,600858,612223,614242,615743,598921,624621,631714,613852,616482,1000000,618087,622612,620429,622683,624621,620526,643263,615253,611196,1000000,626444,636283,638661,636881,631714,643263,627391,627137,630130,1000000,608236,608165,619910,603213,613852,615253,627137,594090,614049,1000000,607216,617368,605611,619674,616482,611196,630130,614049,595640,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,584640,589559,585510,588221,618087,586396,608559,583783,578479,1000000,589559,591109,590078,587682,622612,588228,612473,582735,582321,1000000,585510,590078,582648,590182,620429,584176,611627,586560,577372,1000000,588221,587682,590182,585438,622683,587313,615222,580700,586269,1000000,618087,622612,620429,622683,624621,620526,643263,615253,611196,1000000,586396,588228,584176,587313,620526,585071,613638,584632,580304,1000000,608559,612473,611627,615222,643263,613638,617640,610272,606875,1000000,583783,582735,586560,580700,615253,584632,610272,576814,584635,1000000,578479,582321,577372,586269,611196,580304,606875,584635,573175,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,588604,598226,599027,602167,626444,608559,594791,599661,600718,1000000,598226,603657,609678,604352,636283,612473,604184,600363,609929,1000000,599027,609678,602870,614076,638661,611627,609499,612496,600609,1000000,602167,604352,614076,603558,636881,615222,609954,597698,613878,1000000,626444,636283,638661,636881,631714,643263,627391,627137,630130,1000000,608559,612473,611627,615222,643263,613638,617640,610272,606875,1000000,594791,604184,609499,609954,627391,617640,591402,606746,608714,1000000,599661,600363,612496,597698,627137,610272,606746,592120,611416,1000000,600718,609929,600609,613878,630130,606875,608714,611416,593524,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,577654,577580,586436,573283,608236,583783,599661,567519,583934,1000000,577580,575510,586990,572037,608165,582735,600363,566723,585294,1000000,586436,586990,588228,583813,619910,586560,612496,579846,584366,1000000,573283,572037,583813,568430,603213,580700,597698,564136,584165,1000000,608236,608165,619910,603213,613852,615253,627137,594090,614049,1000000,583783,582735,586560,580700,615253,584632,610272,576814,584635,1000000,599661,600363,612496,597698,627137,610272,606746,592120,611416,1000000,567519,566723,579846,564136,594090,576814,592120,560705,582429,1000000,583934,585294,584366,584165,614049,584635,611416,582429,581474,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,572392,582030,570691,585245,607216,578479,600718,583934,567715,1000000,582030,586396,580316,587788,617368,582321,609929,585294,576351,1000000,570691,580316,569082,583981,605611,577372,600609,584366,566878,1000000,585245,587788,583981,586560,619674,586269,613878,584165,581477,1000000,607216,617368,605611,619674,616482,611196,630130,614049,595640,1000000,578479,582321,577372,586269,611196,580304,606875,584635,573175,1000000,600718,609929,600609,613878,630130,606875,608714,611416,593524,1000000,583934,585294,584366,584165,614049,584635,611416,582429,581474,1000000,567715,576351,566878,581477,595640,573175,593524,581474,560967};\n\nclass Solution {\npublic:\n    bool chk(int x) {\n        int m = 1, s = 0;\n        while (x) {\n            m *= x % 10, s += x % 10;\n            x /= 10;\n        }\n        return m % s == 0;\n    }\n    int calc(int n) {\n        int ans = 0, i;\n        for (i = 0; i < 1000; ++i) {\n            int l = 1000000*i + 1, r = l + 1000000 - 1;\n            if (r <= n) ans += s[i];\n            else {\n                for (int x = l; x <= n; ++x)\n                    ans += chk(x);\n                break;\n            }\n        }\n        return ans;\n    }\n    int beautifulNumbers(int l, int r) {\n        return calc(r) - calc(l - 1);\n    }\n};","author":"维虵命","submissionId":"611252413"},[{"id":"168","similarity":0.9774629748873149,"totOverlap":3036,"longestOverlap":996}]],"378":[{"id":"378","fileName":"611255532.txt","sourceCode":"#define repi(i, a, b) for (int i = (a), i##len = (b); i <= i##len; ++i)\n#define peri(i, a, b) for (int i = (a), i##len = (b); i >= i##len; --i)\n#define ll long long\n#define pii pair<int, int>\n#define x first\n#define y second\n#define vi vector<int>\n#define gi greater<int>\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define lowbit(t) ((t) & (-(t)))\nconstexpr const int MAXN = 1e5 + 5;\nconstexpr const int MOD = 1e9 + 7;\nconstexpr const int BASE = 233;\nconstexpr const int MOD2 = 998244353;\nconstexpr const int INF = 0x3f3f3f3f;\nint dx[] = {0, 0, -1, 1, -1, 1, 1, -1};\nint dy[] = {-1, 1, 0, 0, -1, -1, 1, 1};\ntemplate <class U, class T> void Max(U &x, T y) {\n  if (x < y)\n    x = y;\n}\ntemplate <class U, class T> void Min(U &x, T y) {\n  if (x > y)\n    x = y;\n}\ninline ll qpow(ll b, ll k, int MOD) {\n  ll ans = 1;\n  while (k) {\n    if (k & 1) {\n      (ans *= b) %= MOD;\n    }\n    (b *= b) %= MOD;\n    k >>= 1;\n  }\n  return ans;\n}\n\nint dp[15][2][2][105][105];\n\nclass Solution {\npublic:\n  int beautifulNumbers(int l, int r) {\n    auto L = to_string(l), R = to_string(r);\n    while (L.size() < R.size()) {\n      L = '0' + L;\n    }\n    auto dfs = [&](auto &&self, int pos, bool lim1, bool lim2, int re, int acc,\n                   int sum) {\n      if (acc > sum) {\n        return 0;\n      }\n      if (pos == L.size()) {\n        return (int)(re == 0 && acc == sum);\n      }\n\n      if (dp[pos][lim1][lim2][re][acc] != -1) {\n        return dp[pos][lim1][lim2][re][acc];\n      }\n      int st = lim1 ? L[pos] - '0' : 0;\n      int ed = lim2 ? R[pos] - '0' : 9;\n      ll ans = 0;\n      repi(i, st, ed) {\n        ans += self(self, pos + 1, lim1 && i == st, lim2 && i == ed,\n                    acc +i == 0 ? 1 : (re * i) % sum, acc + i, sum);\n      }\n      return dp[pos][lim1][lim2][re][acc] = ans;\n    };\n\n    ll ans = 0;\n    repi(sum, 1, 9*R.size()) {\n      memset(dp, -1, sizeof dp);\n      ans += dfs(dfs, 0, 1, 1, 1, 0, sum);\n        // cout << ans<<endl;\n    }\n    return ans;\n  }\n};","author":"carrot","submissionId":"611255532"},[{"id":"168","similarity":0.9068934646374217,"totOverlap":2026,"longestOverlap":4}]],"379":[{"id":"379","fileName":"611255657.txt","sourceCode":"class Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        auto countBeautiful = [&](int n) -> long long {\n            if(n < 1) return 0;\n            string s = to_string(n);\n            int L = s.size();\n            vector<int> digits(L);\n            for (int i = 0; i < L; i++) {\n                digits[i] = s[i] - '0';\n            }\n            \n            unordered_map<long long, long long> dpMemo;\n            function<long long(int, int, int, int, int, int)> dp =\n            [&](int pos, int tight, int leading, int hasZero, int sum, int prod) -> long long {\n                if (pos == L) {\n                    if (leading) return 0LL;\n                    if (hasZero) return 1LL;\n                    return (sum>0 && (prod%sum==0)) ? 1LL : 0LL;\n                }\n                long long state = encodeState(pos, tight, leading, hasZero, sum, prod);\n                if (dpMemo.count(state)) return dpMemo[state];\n\n                long long res = 0;\n                int limit = (tight ? digits[pos] : 9);\n                for (int d=0; d <= limit; d++) {\n                    int newTight = (tight && (d == limit)) ? 1 : 0;\n                    if (leading && d == 0) {\n                        res += dp(pos + 1, newTight, 1, hasZero, sum, prod);\n                    } else {\n                        int newLeading = 0;\n                        int newHasZero = hasZero;\n                        int newSum = sum + d;\n                        int newProd;\n                        if (d==0) {\n                            newHasZero = 1;\n                            newProd = 0;\n                        } else {\n                            newProd = (hasZero ? 0 : prod * d);\n                        }\n                        res += dp(pos+1, newTight, newLeading, newHasZero, newSum, newProd);\n                    }\n                }\n                dpMemo[state] = res;\n                return res;\n            };\n            return dp(0,1,1,0,0,1);\n        };\n        long long countR = countBeautiful(r);\n        long long countL = countBeautiful(l-1);\n        long long ans = countR - countL;\n        return (int)ans;\n    }\nprivate:\n    long long encodeState(int pos, int tight, int leading, int hasZero, int sum, int prod) {\n        long long state = pos;\n        state |= ((long long)tight << 4);\n        state |= ((long long)leading << 5);\n        state |= ((long long)hasZero << 6);\n        state |= ((long long)sum << 7);\n        state |= ((long long)prod << 14);\n        return state;\n    }\n};","author":"Matisse","submissionId":"611255657"},[{"id":"168","similarity":0.9169675090252708,"totOverlap":2032,"longestOverlap":5}]],"436":[{"id":"436","fileName":"611271685.txt","sourceCode":"int c[1005] = {534358,583898,591896,591205,591317,609302,591001,592266,583871,576418,1000000,579467,587896,586905,588786,606120,588398,592267,579537,575841,1000000,587896,591317,595049,590081,614798,591441,600624,578591,583378,1000000,586905,595049,586840,595970,614695,588294,602048,588221,573241,1000000,588786,590081,595970,584537,617367,591109,603657,575510,586396,1000000,606120,614798,614695,617367,602225,618821,629169,610753,608478,1000000,588398,591441,588294,591109,618821,587776,608498,585012,578020,1000000,592267,600624,602048,603657,629169,608498,593986,602616,600899,1000000,579537,578591,588221,575510,610753,585012,602616,568430,586020,1000000,575841,583378,573241,586396,608478,578020,600899,586020,566785,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,575270,583641,582185,584134,602118,584640,588604,577654,572392,1000000,583641,588786,591001,584963,612384,589559,598226,577580,582030,1000000,582185,591001,582255,591441,611092,585510,599027,586436,570691,1000000,584134,584963,591441,582567,613279,588221,602167,573283,585245,1000000,602118,612384,611092,613279,600858,618087,626444,608236,607216,1000000,584640,589559,585510,588221,618087,586396,608559,583783,578479,1000000,588604,598226,599027,602167,626444,608559,594791,599661,600718,1000000,577654,577580,586436,573283,608236,583783,599661,567519,583934,1000000,572392,582030,570691,585245,607216,578479,600718,583934,567715,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,583641,588786,591001,584963,612384,589559,598226,577580,582030,1000000,588786,590081,595970,584537,617367,591109,603657,575510,586396,1000000,591001,595970,590928,592625,622132,590078,609678,586990,580316,1000000,584963,584537,592625,579542,615486,587682,604352,572037,587788,1000000,612384,617367,622132,615486,612223,622612,636283,608165,617368,1000000,589559,591109,590078,587682,622612,588228,612473,582735,582321,1000000,598226,603657,609678,604352,636283,612473,604184,600363,609929,1000000,577580,575510,586990,572037,608165,582735,600363,566723,585294,1000000,582030,586396,580316,587788,617368,582321,609929,585294,576351,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,582185,591001,582255,591441,611092,585510,599027,586436,570691,1000000,591001,595970,590928,592625,622132,590078,609678,586990,580316,1000000,582255,590928,577555,591753,612899,582648,602870,588228,569082,1000000,591441,592625,591753,590477,623785,590182,614076,583813,583981,1000000,611092,622132,612899,623785,614242,620429,638661,619910,605611,1000000,585510,590078,582648,590182,620429,584176,611627,586560,577372,1000000,599027,609678,602870,614076,638661,611627,609499,612496,600609,1000000,586436,586990,588228,583813,619910,586560,612496,579846,584366,1000000,570691,580316,569082,583981,605611,577372,600609,584366,566878,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,584134,584963,591441,582567,613279,588221,602167,573283,585245,1000000,584963,584537,592625,579542,615486,587682,604352,572037,587788,1000000,591441,592625,591753,590477,623785,590182,614076,583813,583981,1000000,582567,579542,590477,575516,612283,585438,603558,568430,586560,1000000,613279,615486,623785,612283,615743,622683,636881,603213,619674,1000000,588221,587682,590182,585438,622683,587313,615222,580700,586269,1000000,602167,604352,614076,603558,636881,615222,609954,597698,613878,1000000,573283,572037,583813,568430,603213,580700,597698,564136,584165,1000000,585245,587788,583981,586560,619674,586269,613878,584165,581477,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,602118,612384,611092,613279,600858,618087,626444,608236,607216,1000000,612384,617367,622132,615486,612223,622612,636283,608165,617368,1000000,611092,622132,612899,623785,614242,620429,638661,619910,605611,1000000,613279,615486,623785,612283,615743,622683,636881,603213,619674,1000000,600858,612223,614242,615743,598921,624621,631714,613852,616482,1000000,618087,622612,620429,622683,624621,620526,643263,615253,611196,1000000,626444,636283,638661,636881,631714,643263,627391,627137,630130,1000000,608236,608165,619910,603213,613852,615253,627137,594090,614049,1000000,607216,617368,605611,619674,616482,611196,630130,614049,595640,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,584640,589559,585510,588221,618087,586396,608559,583783,578479,1000000,589559,591109,590078,587682,622612,588228,612473,582735,582321,1000000,585510,590078,582648,590182,620429,584176,611627,586560,577372,1000000,588221,587682,590182,585438,622683,587313,615222,580700,586269,1000000,618087,622612,620429,622683,624621,620526,643263,615253,611196,1000000,586396,588228,584176,587313,620526,585071,613638,584632,580304,1000000,608559,612473,611627,615222,643263,613638,617640,610272,606875,1000000,583783,582735,586560,580700,615253,584632,610272,576814,584635,1000000,578479,582321,577372,586269,611196,580304,606875,584635,573175,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,588604,598226,599027,602167,626444,608559,594791,599661,600718,1000000,598226,603657,609678,604352,636283,612473,604184,600363,609929,1000000,599027,609678,602870,614076,638661,611627,609499,612496,600609,1000000,602167,604352,614076,603558,636881,615222,609954,597698,613878,1000000,626444,636283,638661,636881,631714,643263,627391,627137,630130,1000000,608559,612473,611627,615222,643263,613638,617640,610272,606875,1000000,594791,604184,609499,609954,627391,617640,591402,606746,608714,1000000,599661,600363,612496,597698,627137,610272,606746,592120,611416,1000000,600718,609929,600609,613878,630130,606875,608714,611416,593524,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,577654,577580,586436,573283,608236,583783,599661,567519,583934,1000000,577580,575510,586990,572037,608165,582735,600363,566723,585294,1000000,586436,586990,588228,583813,619910,586560,612496,579846,584366,1000000,573283,572037,583813,568430,603213,580700,597698,564136,584165,1000000,608236,608165,619910,603213,613852,615253,627137,594090,614049,1000000,583783,582735,586560,580700,615253,584632,610272,576814,584635,1000000,599661,600363,612496,597698,627137,610272,606746,592120,611416,1000000,567519,566723,579846,564136,594090,576814,592120,560705,582429,1000000,583934,585294,584366,584165,614049,584635,611416,582429,581474,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,572392,582030,570691,585245,607216,578479,600718,583934,567715,1000000,582030,586396,580316,587788,617368,582321,609929,585294,576351,1000000,570691,580316,569082,583981,605611,577372,600609,584366,566878,1000000,585245,587788,583981,586560,619674,586269,613878,584165,581477,1000000,607216,617368,605611,619674,616482,611196,630130,614049,595640,1000000,578479,582321,577372,586269,611196,580304,606875,584635,573175,1000000,600718,609929,600609,613878,630130,606875,608714,611416,593524,1000000,583934,585294,584366,584165,614049,584635,611416,582429,581474,1000000,567715,576351,566878,581477,595640,573175,593524,581474,560967};\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        int cnt = 0, ans = 0, step = 1e6;\n        auto cal = [&](int x) -> int {\n            int val = x, res1 = 1, res2 = 0;\n            while(val) {\n                int bit = val % 10;\n                val = val / 10;\n                res1 = res1 * bit;\n                res2 = res2 + bit;\n            }\n            return (res1 % res2 == 0);  \n        };\n        while(l <= r && (l % step != 1 || r % step != 0)) {\n            if(l % step != 1) {\n                ans += cal(l);\n                l += 1;\n                continue;\n            }\n            if(r % step != 0) {\n                ans += cal(r);\n                r -= 1;\n                continue;\n            }\n        }\n        for(int i = 1; i <= 1e9; i += step, cnt += 1) {\n            int L = i, R = i + step - 1;\n            if(l <= L && R <= r) ans += c[cnt];\n        }\n        return ans;\n    }\n};","author":"snowy2002","submissionId":"611271685"},[{"id":"168","similarity":0.9662596401028277,"totOverlap":3007,"longestOverlap":994}]],"437":[{"id":"437","fileName":"611271657.txt","sourceCode":"class Solution {\nprivate:\n    // 数位DP中的状态，压缩一下变成整数\n    long long cal(int pos, int tight, int started, int hasZero, int sum, int prod) {\n        long long key = pos;\n        key = key * 2LL + tight;     // pos、flag\n        key = key * 2LL + started;   // started\n        key = key * 2LL + hasZero;   // hasZero\n        key = key * 100LL + sum;     // sum范围[0,81]，用100足够\n        key = key * 1000000000LL + prod; // prod < 1e9\n        return key;\n    }\n    string s;\n    int n;\n    unordered_map<long long, long long> memo;\n    // pos：当前正在处理数字串中的哪一位, flag：是否受到上界限制（1表示受限）,started：是否已经开始（即已经放置了非前导零）\n    // hasZero：是否已出现0（若为true则后续乘积均为0）,sum：目前各位和,prod：目前各位乘积\n    long long dfs(int pos, int flag, int started, int hasZero, int sum, int prod) {\n        if (pos == n) {\n            if (!started) return 0; // 还没开始选，或者说是全选了前导0\n            if (hasZero) return 1;  // 一旦出现0，必定满足条件\n            return (prod % sum == 0) ? 1LL : 0LL;\n        }\n        long long state = cal(pos, flag, started, hasZero, sum, prod);\n        if(memo.contains(state)) return memo[state];\n        long long res = 0;\n        int limit = flag ? (s[pos] - '0') : 9;\n        for (int d = 0; d <= limit; d++) { // 每个数位可能的值\n            int nTight = (flag && (d == limit)) ? 1 : 0;\n            if (!started) {\n                // 还处于前导零阶段\n                if (d == 0) {\n                    // 前导零不计入sum和prod\n                    res += dfs(pos + 1, nTight, 0, 0, 0, 1);\n                } else {\n                    // 第一个非零数字, 则要更新sum和prod\n                    res += dfs(pos + 1, nTight, 1, 0, d, d);\n                }\n            } else {\n                int newSum = sum + d;\n                int newProd;\n                int newHasZero = hasZero;\n                if (hasZero) newProd = 0; // 有0\n                else {\n                    if (d == 0) {\n                        newHasZero = 1;\n                        newProd = 0;\n                    } else {\n                        newProd = prod * d;\n                    }\n                }\n                res += dfs(pos + 1, nTight, 1, newHasZero, newSum, newProd);\n            }\n        }\n        memo[state] = res;\n        return res;\n    }\n    long long countBeautiful(long long x) {\n        if (x < 1) return 0;\n        s = to_string(x);\n        n = s.size();\n        memo.clear();\n        return dfs(0, 1, 0, 0, 0, 1);\n    }\npublic:\n    int beautifulNumbers(int l, int r) {\n        return countBeautiful(r) - countBeautiful(l - 1);\n    }\n};","author":"a碟","submissionId":"611271657"},[{"id":"168","similarity":0.9232526267702147,"totOverlap":2021,"longestOverlap":7}]],"443":[{"id":"443","fileName":"611272850.txt","sourceCode":"vector<int> dp{534357,583898,591896,591205,591317,609302,591001,592266,583871,576418,1000000,579467,587896,586905,588786,606120,588398,592267,579537,575841,1000000,587896,591317,595049,590081,614798,591441,600624,578591,583378,1000000,586905,595049,586840,595970,614695,588294,602048,588221,573241,1000000,588786,590081,595970,584537,617367,591109,603657,575510,586396,1000000,606120,614798,614695,617367,602225,618821,629169,610753,608478,1000000,588398,591441,588294,591109,618821,587776,608498,585012,578020,1000000,592267,600624,602048,603657,629169,608498,593986,602616,600899,1000000,579537,578591,588221,575510,610753,585012,602616,568430,586020,1000000,575841,583378,573241,586396,608478,578020,600899,586020,566785,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,575270,583641,582185,584134,602118,584640,588604,577654,572392,1000000,583641,588786,591001,584963,612384,589559,598226,577580,582030,1000000,582185,591001,582255,591441,611092,585510,599027,586436,570691,1000000,584134,584963,591441,582567,613279,588221,602167,573283,585245,1000000,602118,612384,611092,613279,600858,618087,626444,608236,607216,1000000,584640,589559,585510,588221,618087,586396,608559,583783,578479,1000000,588604,598226,599027,602167,626444,608559,594791,599661,600718,1000000,577654,577580,586436,573283,608236,583783,599661,567519,583934,1000000,572392,582030,570691,585245,607216,578479,600718,583934,567715,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,583641,588786,591001,584963,612384,589559,598226,577580,582030,1000000,588786,590081,595970,584537,617367,591109,603657,575510,586396,1000000,591001,595970,590928,592625,622132,590078,609678,586990,580316,1000000,584963,584537,592625,579542,615486,587682,604352,572037,587788,1000000,612384,617367,622132,615486,612223,622612,636283,608165,617368,1000000,589559,591109,590078,587682,622612,588228,612473,582735,582321,1000000,598226,603657,609678,604352,636283,612473,604184,600363,609929,1000000,577580,575510,586990,572037,608165,582735,600363,566723,585294,1000000,582030,586396,580316,587788,617368,582321,609929,585294,576351,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,582185,591001,582255,591441,611092,585510,599027,586436,570691,1000000,591001,595970,590928,592625,622132,590078,609678,586990,580316,1000000,582255,590928,577555,591753,612899,582648,602870,588228,569082,1000000,591441,592625,591753,590477,623785,590182,614076,583813,583981,1000000,611092,622132,612899,623785,614242,620429,638661,619910,605611,1000000,585510,590078,582648,590182,620429,584176,611627,586560,577372,1000000,599027,609678,602870,614076,638661,611627,609499,612496,600609,1000000,586436,586990,588228,583813,619910,586560,612496,579846,584366,1000000,570691,580316,569082,583981,605611,577372,600609,584366,566878,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,584134,584963,591441,582567,613279,588221,602167,573283,585245,1000000,584963,584537,592625,579542,615486,587682,604352,572037,587788,1000000,591441,592625,591753,590477,623785,590182,614076,583813,583981,1000000,582567,579542,590477,575516,612283,585438,603558,568430,586560,1000000,613279,615486,623785,612283,615743,622683,636881,603213,619674,1000000,588221,587682,590182,585438,622683,587313,615222,580700,586269,1000000,602167,604352,614076,603558,636881,615222,609954,597698,613878,1000000,573283,572037,583813,568430,603213,580700,597698,564136,584165,1000000,585245,587788,583981,586560,619674,586269,613878,584165,581477,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,602118,612384,611092,613279,600858,618087,626444,608236,607216,1000000,612384,617367,622132,615486,612223,622612,636283,608165,617368,1000000,611092,622132,612899,623785,614242,620429,638661,619910,605611,1000000,613279,615486,623785,612283,615743,622683,636881,603213,619674,1000000,600858,612223,614242,615743,598921,624621,631714,613852,616482,1000000,618087,622612,620429,622683,624621,620526,643263,615253,611196,1000000,626444,636283,638661,636881,631714,643263,627391,627137,630130,1000000,608236,608165,619910,603213,613852,615253,627137,594090,614049,1000000,607216,617368,605611,619674,616482,611196,630130,614049,595640,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,584640,589559,585510,588221,618087,586396,608559,583783,578479,1000000,589559,591109,590078,587682,622612,588228,612473,582735,582321,1000000,585510,590078,582648,590182,620429,584176,611627,586560,577372,1000000,588221,587682,590182,585438,622683,587313,615222,580700,586269,1000000,618087,622612,620429,622683,624621,620526,643263,615253,611196,1000000,586396,588228,584176,587313,620526,585071,613638,584632,580304,1000000,608559,612473,611627,615222,643263,613638,617640,610272,606875,1000000,583783,582735,586560,580700,615253,584632,610272,576814,584635,1000000,578479,582321,577372,586269,611196,580304,606875,584635,573175,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,588604,598226,599027,602167,626444,608559,594791,599661,600718,1000000,598226,603657,609678,604352,636283,612473,604184,600363,609929,1000000,599027,609678,602870,614076,638661,611627,609499,612496,600609,1000000,602167,604352,614076,603558,636881,615222,609954,597698,613878,1000000,626444,636283,638661,636881,631714,643263,627391,627137,630130,1000000,608559,612473,611627,615222,643263,613638,617640,610272,606875,1000000,594791,604184,609499,609954,627391,617640,591402,606746,608714,1000000,599661,600363,612496,597698,627137,610272,606746,592120,611416,1000000,600718,609929,600609,613878,630130,606875,608714,611416,593524,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,577654,577580,586436,573283,608236,583783,599661,567519,583934,1000000,577580,575510,586990,572037,608165,582735,600363,566723,585294,1000000,586436,586990,588228,583813,619910,586560,612496,579846,584366,1000000,573283,572037,583813,568430,603213,580700,597698,564136,584165,1000000,608236,608165,619910,603213,613852,615253,627137,594090,614049,1000000,583783,582735,586560,580700,615253,584632,610272,576814,584635,1000000,599661,600363,612496,597698,627137,610272,606746,592120,611416,1000000,567519,566723,579846,564136,594090,576814,592120,560705,582429,1000000,583934,585294,584366,584165,614049,584635,611416,582429,581474,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,572392,582030,570691,585245,607216,578479,600718,583934,567715,1000000,582030,586396,580316,587788,617368,582321,609929,585294,576351,1000000,570691,580316,569082,583981,605611,577372,600609,584366,566878,1000000,585245,587788,583981,586560,619674,586269,613878,584165,581477,1000000,607216,617368,605611,619674,616482,611196,630130,614049,595640,1000000,578479,582321,577372,586269,611196,580304,606875,584635,573175,1000000,600718,609929,600609,613878,630130,606875,608714,611416,593524,1000000,583934,585294,584366,584165,614049,584635,611416,582429,581474,1000000,567715,576351,566878,581477,595640,573175,593524,581474,560967};\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        return calc(r) - calc(l - 1);\n    }\n    int calc(int maxVal) {\n        int baseIndex = maxVal / 1000000;\n        int offset = maxVal % 1000000;\n        int base = maxVal - offset;\n        int ret = 0;\n        for (int i = 0; i < baseIndex; i++) {\n            ret += dp[i];\n        }\n        for (int v = 0; v <= offset; v++) {\n            if (isBeautiful(base + v)) {\n                ret++;\n            }\n        }\n        // cout << \"maxVal=\" << maxVal << \", ret=\" << ret << endl;\n        return ret;\n    }\n    bool isBeautiful(int v) {\n        if (v == 0) return false;\n        int up = 1, down = 0;\n        while (v > 0) {\n            int d = v % 10;\n            v /= 10;\n            up *= d;\n            down += d;\n        }\n        return up % down == 0;\n    }\n};","author":"seedjyh","submissionId":"611272850"},[{"id":"168","similarity":0.9794278367084539,"totOverlap":3047,"longestOverlap":993}]]},{"169":[{"id":"169","fileName":"1575202791.txt","sourceCode":"class Solution(object):\n    def digitalDP(self,idx,cumProd,cumSum,isPrefix,isLeadingZero,inputList):\n        #inputList: '2345'\n        #idx: current digit pos in inputList (from left, 0 indexed)\n        #mask: all numbers have been used before\n        #isPrefix: all previous numbers are prefix of inputList. \n        #For instance, 23_ (isPrefix True). Then the third digit can only go to 4. \n        #If isPrefix False, then the third digit can go to 9.\n        #isLeadingZero: Is valid number showing up in mask. Is there any leading zero.\n        #False: no. We have two options.\n        #Option 1: we could skip current digit and go to next digit. \n        #Option 2: don't skip. Then we could only start from 1\n        #True:yes. Then we cannot skipp current digit. At current digit, we could start from 0.\n        n = len(inputList)\n        key = (idx,cumProd,cumSum,isPrefix,isLeadingZero)\n\n        if(idx == n): \n            if(cumSum == 0):\n                self.memo[key] = 0\n            else:\n                if(cumProd%cumSum == 0):\n                    self.memo[key] = int(isLeadingZero)\n                else:\n                    self.memo[key] = 0\n            return self.memo[key]\n\n        if(key in self.memo):\n            return self.memo[key]\n        \n        ans = 0\n        if(not isLeadingZero):\n            ans += self.digitalDP(idx+1,1,0,False,False,inputList)\n\n        #Determin the up limit of our target digits.\n        if(isPrefix):\n            #we are on the prefix of inputlist. We could only go up to inputList[idx]\n            up = inputList[idx]\n        else:\n            # we are not on the prefix. So we could go up to 9\n            up = 9\n\n        if(isLeadingZero):\n            #Valid number showing up in mask.We could go start from 0. \n            low = 0\n        else:\n            #Valid number not showing up in mask.We could only go start from 1. \n            low = 1\n\n        targetList = range(low,up+1)\n\n        for digit in targetList:\n            nextIsPrefix = (isPrefix and digit==up)\n            ans += self.digitalDP(idx+1,cumProd*digit, cumSum + digit,nextIsPrefix,True,inputList)\n                    \n        self.memo[key] = ans\n\n        return self.memo[key]\n        \n    def beautifulNumbers(self, l, r):\n        \"\"\"\n        :type l: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        inputList = list(str(r))\n        inputList = list(map(int,inputList))        \n        self.memo = {}\n        ans = self.digitalDP(0,1,0,True,False,inputList)\n        print((r,ans))\n        if(l>1):\n            inputList = list(str(l-1))\n            inputList = list(map(int,inputList))        \n            self.memo = {}\n            tmp = self.digitalDP(0,1,0,True,False,inputList)\n            print((l,tmp))\n            ans -= tmp\n            \n        return ans\n        ","author":"luckyboy","submissionId":"1575202791"},[]]},{"170":[{"id":"170","fileName":"1575203125.txt","sourceCode":"class Solution {\npublic:\n    int dp[20][3][300][300];\n    int calc(int s,int b){\n        string a = to_string(s);\n        for(int i=1; i<=9; i++){\n            for(int j=0; j<=2; j++){\n                for(int sum=1; sum<=b; sum++){\n                    for(int du=0; du<=b; du++){\n                        dp[i][j][sum][du] = 0;\n                    }\n                }\n            }\n        }\n        for(int i=1; i<a[0]-'0'; i++){\n            dp[1][0][i][i%b] = 1;\n        }\n        dp[1][1][a[0]-'0'][(a[0]-'0')%b]=1;\n        for(int i=a[0]-'0' + 1; i<=9; i++){\n            dp[1][2][i][i%b]=1;\n        }\n        for(int i=1; i<a.size(); i++){\n            for(int j=0; j<=2; j++){\n                for(int sum=1; sum<=min(b,9*(i+1)); sum++){\n                    \n                    for(int du=0; du<b; du++){\n                       if(dp[i][j][sum][du] == 0) continue;\n                       for(int add=0; add<=9; add++){\n                           if(j==2){\n                               dp[i+1][j][sum+add][(du*add)%b] += dp[i][j][sum][du];\n                           }\n                           else if(j==1){\n                               int st=0;\n                               if(add > a[i]-'0'){\n                                   st=2;\n                               }\n                               else if(add == a[i]-'0'){\n                                   st=1;\n                               }\n                               else st=0;\n                               dp[i+1][st][sum+add][(du*add)%b] += dp[i][j][sum][du];\n                           }\n                           else if(j==0){\n                               dp[i+1][0][sum+add][(du*add)%b] +=dp[i][j][sum][du];\n                           }\n                       } \n                    }\n                }\n            }\n        }\n        int dem=0;\n        for(int i=1; i<=a.size(); i++){\n            dem += dp[i][0][b][0] + dp[i][1][b][0] + dp[i][2][b][0];\n        }\n        dem -= dp[a.size()][2][b][0];\n        return dem;\n    }\n    int beautifulNumbers(int l, int r) {\n        int ans = 0;\n        if(r==1000000000){\n            ans=1;\n            r--;\n        }\n        if(r-l+1<=1000000){\n            for(int i=l; i<=r; i++){\n                int sum = 0;\n                long long tich = 1;\n                int a = i;\n                while(a>0){\n                    sum+=a%10;\n                    tich=tich*(a%10);\n                    a/=10;\n                }\n                if(tich%sum==0) ans+=1;\n            }\n            return ans;\n            \n        }\n        for(int sum=1; sum<=81; sum++){\n            ans += calc(r,sum) - calc(l-1,sum);\n        }\n        return ans;\n    }\n};","author":"Huy Phước","submissionId":"1575203125"},[]]},{"171":[{"id":"171","fileName":"1575203266.txt","sourceCode":"class Solution {\npublic:\n    int calcAll(int ind, bool tight, bool started, string& num, vector<vector<vector<int>>>& dp) {\n        if (ind == num.size())\n            return started;\n        if (dp[tight][started][ind] != -1)\n            return dp[tight][started][ind];\n        int res = 0, lim = tight ? (num[ind] - '0') : 9;\n        for (int i = 0; i <= lim; i++) {\n            bool newTight = (tight && (i == lim));\n            if (i)\n                res += calcAll(ind + 1, newTight, 1, num, dp);\n            else if (!started)\n                res += calcAll(ind + 1, newTight, 0, num, dp);\n        }\n        return dp[tight][started][ind] = res;\n    }\n    int calcBeauty(int ind, bool tight, bool started, int sum, int prod, string& num,\n             map<vector<int>, int>& dp) {\n        if (ind == num.size())\n            return (started && (prod % sum == 0));\n        vector<int> key = {ind, tight, started, sum, prod};\n        if (dp.find(key) != dp.end())\n            return dp[key];\n        int res = 0, lim = tight ? (num[ind] - '0') : 9;\n        for (int i = 0; i <= lim; i++) {\n            int newTight = (tight && (i == lim));\n            if (i)\n                res += calcBeauty(ind + 1, newTight, 1, sum + i, prod * i, num, dp);\n            else if (!started)\n                res += calcBeauty(ind + 1, newTight, 0, sum, prod, num, dp);\n        }\n        return dp[key] = res;\n    }\n    int calc(int x) {\n        if (!x)\n            return 0;\n        string num = to_string(x);\n        map<vector<int>, int> dp;\n        vector<vector<vector<int>>> dp1(2, vector<vector<int>>(2, vector<int>(num.size(), -1)));\n        return x - calcAll(0, 1, 0, num, dp1) + calcBeauty(0, 1, 0, 0, 1, num, dp);\n    }\n    int beautifulNumbers(int l, int r) { \n        return calc(r) - calc(l - 1); \n    }\n};","author":"Abhishek Srivastava","submissionId":"1575203266"},[]]},{"172":[{"id":"172","fileName":"1575202818.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        num2=str(r)\n        num1=str(l).zfill(len(num2))\n        n=len(num2)\n        MI=[num1,'0'*n]\n        MX=[num2,'9'*n]\n        ans=0\n        @cache\n        def dp(i, mi_, mx_,leading_zero=True, prod=1,sm=0):\n            mi=MI[mi_]\n            mx=MX[mx_]\n            if i == n:\n                return prod%sm==0\n            cur_min=int(mi[i])\n            cur_max=int(mx[i])\n            ans = 0\n            for dig in range(cur_min, cur_max + 1):\n                nlead=False\n                if leading_zero==True:\n                    if dig==0:\n                        nlead=True\n                    else:\n                        nlead=False\n                next_mi_ = mi_!=0 or dig != cur_min\n                next_mx_ = mx_!=0 or dig != cur_max\n                ans += dp(i + 1, next_mi_, next_mx_, nlead, (prod*dig) if not nlead else prod, sm+dig)\n            return ans\n        return dp(0, 0, 0)","author":"Sandeep P","submissionId":"1575202818"},[]]},{"173":[{"id":"173","fileName":"1575203306.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_up_to(n: int) -> int:\n            digits = list(map(int, str(n)))\n            memo = {}\n            return self.dp(0, True, True, 0, 1, digits, memo)\n        \n        return count_up_to(r) - count_up_to(l - 1)\n\n    def dp(self, pos, tight, leading_zero, summ, prod, target_digits, memo):\n        if pos == len(target_digits):\n            return 1 if summ > 0 and prod % summ == 0 else 0\n\n        if (pos, tight, leading_zero, summ, prod) in memo:\n            return memo[(pos, tight, leading_zero, summ, prod)]\n\n        max_val = target_digits[pos] if tight else 9\n        res = 0\n\n        for val in range(max_val + 1):\n            next_tight = tight and (val == max_val)\n            next_leading_zero = leading_zero and (val == 0)\n            next_summ = summ + val if not next_leading_zero else 0\n            next_prod = (prod * val) if not next_leading_zero else 1\n            res += self.dp(pos + 1, next_tight, next_leading_zero, next_summ, next_prod, target_digits, memo)\n\n        memo[(pos, tight, leading_zero, summ, prod)] = res\n        return res\n        ","author":"Khanh","submissionId":"1575203306"},[]]},{"174":[{"id":"174","fileName":"1575204423.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count(x):\n            if x<1:\n                return 0\n            s=str(x)\n            d=[int(ch) for ch in s]\n            @lru_cache(maxsize=None)\n            def dp(pos,ti,st,s,p):\n                if pos== len(d):\n                    if not st:\n                        return 0\n                    return 1 if (s!=0 and p%s==0) else 0\n                lt=d[pos] if ti else 9\n                w=0\n                for i in range(0,lt+1):\n                    nt=1 if (ti==1 and i==lt) else 0\n                    if not st:\n                        if i==0:\n                            w+=dp(pos+1,nt,0,0,1)\n                        else:\n                            w+=dp(pos+1,nt,1,i,i)\n                    else:\n                        w+=dp(pos+1,nt,1,s+i,p*i)\n                return w\n            return dp(0,1,0,0,1)\n        return count(r)-count(l-1)","author":"kenpachizaraki123","submissionId":"1575204423"},[]]},{"175":[{"id":"175","fileName":"1575204151.txt","sourceCode":"/********************************************\n * author : Jie Chen (4rd Year CS)\n * school : Rochester Institute of Technology\n * created: 03.15.2025 22:56:39\n*********************************************/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef BROKEN_CODE\n#include <bits/lc_parser.h>\n#include <bits/debug.h>\n#else\n#define dbg(...) 10082002\n#define dbp(...) \"Need Internship\"\n#endif\n\nusing i64 = long long;\n\nconstexpr int N = 10;\nunordered_map<int, int> f[N][2][2][82];\nstring s;\nint n;\n\nint dp(int i, int is_leading, int is_tight, int sum, int prod) {\n    if (f[i][is_leading][is_tight][sum].contains(prod)) {\n        return f[i][is_leading][is_tight][sum][prod];\n    }\n    int& ans = f[i][is_leading][is_tight][sum][prod];\n    if (i == n) {\n        if (!is_leading && sum > 0 && prod % sum == 0) {\n            ans++;\n        }\n        return ans;\n    }\n\n    int d = s[i] - '0';\n    int end = (is_tight ? d : 9);\n    for (int cand = 0; cand <= end; cand++) {\n        int tight = int(is_tight && cand == d);\n        if (is_leading) {\n            if (cand != 0) {\n                ans += dp(i + 1, 0, tight, sum + cand, prod * cand);\n            } else {\n                ans += dp(i + 1, is_leading, tight, sum, prod);\n            }\n        } else {\n            ans += dp(i + 1, 0, tight, sum + cand, prod * cand);\n        }\n    }\n    return ans;\n}\n\nint solve(int x) {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < 2; j++) {\n            for (int k = 0; k < 2; k++) {\n                for (int l = 0; l < 82; l++) {\n                    f[i][j][k][l].clear();\n                }\n            }\n        }\n    }\n    s = to_string(x);\n    n = s.size();\n    return dp(0, 1, 1, 0, 1);\n}\n\nclass Solution {\npublic:\n    int good(int x) {\n        int p = 1;\n        int s = 0;\n        while (x) {\n            int d = (x % 10);\n            p *= d;\n            s += d;\n            x /= 10;\n        }\n        return p % s == 0;\n    }\n\n    int beautifulNumbers(int l, int r) {\n        int R = solve(r);\n        int L = solve(l);\n        return R - L + good(l);\n    }\n};\n\n#ifdef BROKEN_CODE\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    exec(&Solution::JustJie); // CHANGE FOR PROBLEM\n}\n#endif\n\n// ~ JustJie","author":"Jie Chen","submissionId":"1575204151"},[]]},{"176":[{"id":"176","fileName":"1575204347.txt","sourceCode":"#include <bits/stdc++.h>\n#define rep(I, N) for (int I = 0; I < (N); ++I)\n#define ll long long\n#define pb push_back\n#define pii pair<int, int>\n#define vall(X) (X).begin(), (X).end()\n#define vi vector<int>\n#define vll vector<long long>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nconst int SIZE = 1e6 + 10;\nclass Solution {\npublic:\n    ll encode(int ind, int temp, int start, int zero, int sum, int a, int b,\n              int c, int d) {\n        ll key=ind;\n        key = key*2+temp;\n        key = key*2+start;\n        key = key*2+zero;\n        key = key*100+sum;\n        key = key*50+a;\n        key = key*50+b;\n        key = key*20+c;\n        key = key*20+d;\n        return key;\n    }\n    int modPow(int base,int p,int mod) \n        {\n            ll ans = 1;\n            ll b = base;\n            while (p>0) \n            {\n                if (p%2==1) ans=(ans * b) % mod;\n                b=(b * b)%mod;\n                p/=2;\n            }\n            return (int)ans;\n        };\n    ll func(int ind, int temp, int start, int zero, int sum, int a, int b,\n          int c, int d, vi& digits, int n,\n          unordered_map<ll,ll>& dp) \n{\n        if (ind == n) \n        {\n            if (start==0)\n                return 0;\n            if (zero!=0)\n                return 1;\n            int mod=sum;\n            ll produ=1;\n            produ=(produ * modPow(2,a,mod))%mod;\n            produ=(produ * modPow(3,b,mod))%mod;\n            produ=(produ * modPow(5,c,mod))%mod;\n            produ=(produ * modPow(7,d,mod))%mod;\n            return produ%mod == 0;\n        }\n        ll key=encode(ind,temp,start,zero,sum,a,b,c,d);\n        if (dp.count(key))\n            return dp[key];\n        ll res = 0;\n        int maxi = (temp!=0)?digits[ind]:9;\n        rep(dig,maxi+1) \n        {\n            int nt = (temp && (dig == maxi));\n            if (start==0) \n            {\n                if (dig == 0) \n                {\n                    res+=func(ind+1,nt,0,0,0,0,0,0,0,digits,n,dp);\n                } \n                else \n                {\n                    int newa,newb,newc,newd;\n                    if(dig==1)\n                    {    newa = 0;\n                        newb = 0;\n                        newc = 0;\n                        newd = 0;\n                    }\n                    else if(dig==2)\n                    {   newa = 1;\n                        newb = 0;\n                        newc = 0;\n                        newd = 0;\n                    }    \n                    else if(dig==3)\n                    {    newa = 0;\n                        newb = 1;\n                        newc = 0;\n                        newd = 0;\n                    }\n                    else if(dig==4)\n                    {   newa = 2;\n                        newb = 0;\n                        newc = 0;\n                        newd = 0;\n                    }\n                    else if(dig==5)\n                    {    newa = 0;\n                        newb = 0;\n                        newc = 1;\n                        newd = 0;\n                    }\n                    else if(dig==6)\n                    {    newa = 1;\n                        newb = 1;\n                        newc = 0;\n                        newd = 0;\n                    }\n                    else if(dig==7)\n                    {    newa = 0;\n                        newb = 0;\n                        newc = 0;\n                        newd = 1;\n                    }\n                    else if(dig==8)\n                    {\n                        newa = 3;\n                        newb = 0;\n                        newc = 0;\n                        newd = 0;\n                    }\n                    else if(dig==9)\n                    {    newa = 0;\n                        newb = 2;\n                        newc = 0;\n                        newd = 0;\n                    }\n                    res += func(ind + 1, nt, 1, 0, dig, newa, newb, newc, newd, digits,n, dp);\n                }\n            } \n    else \n    {\n                if (zero!=0) \n                {\n                    res +=\n                        func(ind + 1, nt, 1, 1, 0, 0, 0, 0, 0, digits, n, dp);\n                } else \n                {\n                    if (dig == 0) {\n                        res += func(ind + 1, nt, 1, 1, 0, 0, 0, 0, 0, digits, n,\n                                  dp);\n                    } else {\n                        int newa, newb, newc, newd;\n                        if(dig==1)\n                        {   newa = 0;\n                            newb = 0;\n                            newc = 0;\n                            newd = 0;\n                        }\n                        else if(dig==2)\n                        {    newa = 1;\n                            newb = 0;\n                            newc = 0;\n                            newd = 0;\n                        }\n                        else if(dig==3)\n                        {    newa = 0;\n                            newb = 1;\n                            newc = 0;\n                            newd = 0;\n                        }\n                        else if(dig==4)\n                        {   newa = 2;\n                            newb = 0;\n                            newc = 0;\n                            newd = 0;\n                        }\n                        else if(dig==5)\n                        {    newa = 0;\n                            newb = 0;\n                            newc = 1;\n                            newd = 0;\n                        }\n                        else if(dig==6)\n                        {    newa = 1;\n                            newb = 1;\n                            newc = 0;\n                            newd = 0;\n                        }\n                        else if(dig==7)\n                        {    newa = 0;\n                            newb = 0;\n                            newc = 0;\n                            newd = 1;\n                        }\n                        else if(dig==8)\n                        {    newa = 3;\n                            newb = 0;\n                            newc = 0;\n                            newd = 0;\n                        }\n                        else if(dig==9)\n                        {    newa = 0;\n                            newb = 2;\n                            newc = 0;\n                            newd = 0;\n                        }\n                        res += func(ind + 1, nt, 1, 0, sum + dig, a + newa,\n                                  b + newb, c + newc, d + newd, digits, n, dp);\n                    }\n                }\n            }\n        }\n        dp[key] = res;\n        return res;\n    }\n    ll countBeautiful(ll x) {\n        if (x < 0)\n            return 0;\n        string s = to_string(x);\n        int n = s.size();\n        vi digi(n);\n        rep(i,n) digi[i] = s[i]-'0';\n        unordered_map<ll, ll> dp;\n        return func(0, 1, 0, 0, 0, 0, 0, 0, 0, digi, n, dp);\n    }\n    int helper(int l, int r) {\n        return (int)(countBeautiful(r) - countBeautiful(l - 1));\n    }\n    int beautifulNumbers(int l, int r) { return helper(l, r); }\n};","author":"uzer30","submissionId":"1575204347"},[]]},{"177":[{"id":"177","fileName":"1575205039.txt","sourceCode":"#pragma optimization_level 3\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math,O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimization (\"unroll-loops\")\n\nclass Solution {\npublic:\n    vector<vector<vector<long long>>> memoAll, memoNoZero;\n    map<int, map<int, map<int, map<pair<int, int>, long long>>>> memoBea;\n\n    long long dpAll(int pos, bool tight, bool started, const string &s) {\n        if (pos == s.size())\n            return started ? 1 : 0;  \n\n        if (memoAll[pos][tight][started] != -1)\n            return memoAll[pos][tight][started];\n\n        long long ans = 0;\n        int limit = tight ? s[pos] - '0' : 9;\n        for (int d = 0; d <= limit; d++) {\n            bool ntight = tight && (d == limit);\n            bool nstarted = started || (d != 0);\n            ans += dpAll(pos + 1, ntight, nstarted, s);\n        }\n        memoAll[pos][tight][started] = ans;\n        return ans;\n    }\n\n    long long dpNoZero(int pos, bool tight, bool started, const string &s) {\n        if (pos == s.size())\n            return started ? 1 : 0;\n\n        if (memoNoZero[pos][tight][started] != -1)\n            return memoNoZero[pos][tight][started];\n\n        long long ans = 0;\n        int limit = tight ? s[pos] - '0' : 9;\n        for (int d = 0; d <= limit; d++) {\n            if (started && d == 0) continue; \n\n            bool nstarted = started || (d != 0);\n            bool ntight = tight && (d == limit);\n            ans += dpNoZero(pos + 1, ntight, nstarted, s);\n        }\n        memoNoZero[pos][tight][started] = ans;\n        return ans;\n    }\n\n    long long dpBeautifulNoZero(int pos, bool tight, bool started, int sum, int prod, const string &s) {\n        if (pos == s.size()) {\n            return (started && sum > 0 && (prod % sum == 0)) ? 1LL : 0LL;\n        }\n\n        pair<int, int> key = make_pair(sum, prod);\n        if (memoBea[pos][tight][started].count(key))\n            return memoBea[pos][tight][started][key];\n\n        long long ans = 0;\n        int limit = tight ? s[pos] - '0' : 9;\n        for (int d = 0; d <= limit; d++) {\n            bool ntight = tight && (d == limit);\n            bool nstarted = started || (d != 0);\n            if (nstarted) {\n                if (d == 0) continue;\n                ans += dpBeautifulNoZero(pos + 1, ntight, nstarted, sum + d, prod * d, s);\n            } else {\n                ans += dpBeautifulNoZero(pos + 1, ntight, nstarted, sum, prod, s);\n            }\n        }\n        memoBea[pos][tight][started][key] = ans;\n        return ans;\n    }\n\n    long long f(long long X) {\n        string s = to_string(X);\n        int n = s.size();\n\n        memoAll = vector<vector<vector<long long>>>(n, vector<vector<long long>>(2, vector<long long>(2, -1)));\n        memoNoZero = vector<vector<vector<long long>>>(n, vector<vector<long long>>(2, vector<long long>(2, -1)));\n        memoBea.clear(); \n\n        long long total = dpAll(0, true, false, s);\n        long long noZero = dpNoZero(0, true, false, s);\n        long long withZero = total - noZero;\n        long long beautifulNoZero = dpBeautifulNoZero(0, true, false, 0, 1, s);\n\n        return withZero + beautifulNoZero;\n    }\n\n    int beautifulNumbers(int l, int r) {\n        return f(r) - f(l - 1);\n    }\n};","author":"Samrach","submissionId":"1575205039"},[]]},{"179":[{"id":"179","fileName":"1575203038.txt","sourceCode":"#include <string>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        return (int)(countBeautiful(to_string(r)) - countBeautiful(to_string(l - 1)));\n    }\n    \nprivate:\n    unordered_map<string, long long> memo;\n    \n    long long dp(int pos, int tight, int started, int sum, long long prod, const string &s) {\n        if (pos == s.size()) {\n            if (!started)\n                return 0;\n            return (prod == 0 || (sum > 0 && prod % sum == 0)) ? 1LL : 0LL;\n        }\n        \n\n        string key = to_string(pos) + \"|\" + to_string(tight) + \"|\" + to_string(started) + \"|\" \n                     + to_string(sum) + \"|\" + to_string(prod);\n        if (memo.find(key) != memo.end())\n            return memo[key];\n        \n        long long ans = 0;\n        int limit = tight ? (s[pos] - '0') : 9;\n        for (int d = 0; d <= limit; d++) {\n            int newTight = (tight && (d == limit)) ? 1 : 0;\n            int newStarted = started;\n            int newSum = sum;\n            long long newProd = prod;\n            \n            if (!started) {\n                if (d == 0) {\n                    newStarted = 0;\n                    newSum = 0;\n                    newProd = 1; \n                } else {\n                    newStarted = 1;\n                    newSum = d;\n                    newProd = d;\n                }\n            } else {\n                newSum = sum + d;\n                if (newProd == 0 || d == 0)\n                    newProd = 0;\n                else\n                    newProd = prod * d;\n            }\n            ans += dp(pos + 1, newTight, newStarted, newSum, newProd, s);\n        }\n        \n        memo[key] = ans;\n        return ans;\n    }\n    long long countBeautiful(const string &num) {\n        memo.clear();\n        return dp(0, 1, 0, 0, 1, num);\n    }\n};\n","author":"Anik Kaushesh","submissionId":"1575203038"},[]]},{"180":[{"id":"180","fileName":"1575204749.txt","sourceCode":"#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define sz(a) (int)(a).size()\n#define all(a) begin(a),end(a)\ntypedef vector<int> vi;\nclass Solution {\npublic:\n    int sum(int n) {\n        if(n==0)return 0;\n        int ans=0;\n        string s=to_string(n);\n        {\n            if(count(all(s),'0'))ans++;\n            rep(d,2,sz(s))ans+=9*round(pow(10,d-1)-pow(9,d-1));\n            vector<int>dp(sz(s)),ep(sz(s)),fp(sz(s)),gp(sz(s));\n            rep(d,1,s[0]-'0')dp[0]++;\n            ep[0]=1;\n            rep(i,1,sz(s)){\n                rep(d,0,10){\n                    if(d==0)fp[i]+=dp[i-1]+fp[i-1];\n                    else dp[i]+=dp[i-1],fp[i]+=fp[i-1];\n                    if(d<s[i]-'0'){\n                        if(d==0)fp[i]+=ep[i-1]+gp[i-1];\n                        else dp[i]+=ep[i-1],fp[i]+=gp[i-1];\n                    }\n                    else if(d==s[i]-'0'){\n                        if(d==0)gp[i]+=ep[i-1]+gp[i-1];\n                        else ep[i]+=ep[i-1],gp[i]+=gp[i-1];\n                    }\n                }\n            }\n            ans+=fp.back();\n        }\n        int prod=1,sum=0;\n        string a;\n        vector<int>f(12,1);\n        rep(i,1,12)f[i]=i*f[i-1];\n        function<void(int)>dfs=[&](int i){\n            if(i==10){\n                if(sum&&prod%sum==0){\n                    if(sz(a)<sz(s)){\n                        int q=f[sz(a)];\n                        rep(i,1,10){\n                            int c=count(all(a),'0'+i);\n                            q/=f[c];\n                        }\n                        ans+=q;\n                    }\n                    else if(sz(a)==sz(s)){\n                        vector<int>dp(1<<sz(s)),ep(1<<sz(s));\n                        dp[0]=1;\n                        rep(i,0,1<<sz(s))rep(j,0,sz(s))if((i>>j)%2==0){\n                            if(j&&(i>>(j-1))%2==0&&a[j]==a[j-1])continue;\n                            ep[i+(1<<j)]+=ep[i];\n                            int c=__builtin_popcount(i);\n                            if(s[c]>a[j])ep[i+(1<<j)]+=dp[i];\n                            else if(s[c]==a[j])dp[i+(1<<j)]+=dp[i];\n                        }\n                        ans+=ep.back();\n                        {\n                            auto t=s;\n                            sort(all(t));\n                            if(a==t)ans++;\n                        }\n                    }\n                }\n                return;\n            }\n            int d=sz(a),_prod=prod;\n            rep(_,0,10){\n                dfs(i+1);\n                if(sz(a)==sz(s))break;\n                a+=(char)('0'+i);\n                sum+=i;\n                prod*=i;\n            }\n            sum-=i*(sz(a)-d);\n            a.erase(a.begin()+d,a.end());\n            prod=_prod;\n        };\n        dfs(1);\n        return ans;\n    }\n    int beautifulNumbers(int l, int r) {\n        return sum(r)-sum(l-1);\n    }\n};","author":"TKTYI","submissionId":"1575204749"},[]]},{"181":[{"id":"181","fileName":"1575204687.txt","sourceCode":"/**\n * @param {number} l\n * @param {number} r\n * @return {number}\n */\nvar beautifulNumbers = function (l, r) {\n  const toDigits = (n) => Array.from(String(n), Number)\n\n  const countUpTo = (x) => (x < 0 ? 0n : dp(toDigits(x)))\n  return Number(countUpTo(r) - countUpTo(l - 1))\n\n  function dp(digits) {\n    const n = digits.length\n\n    const seen = new Map()\n\n    function dfs(pos, tight, started, s, p, hasZero) {\n      if (pos === n) {\n        if (!started) return 0n\n        return hasZero || (s !== 0 && p % s === 0) ? 1n : 0n\n      }\n      const key = state(pos, tight, started, s, p, hasZero)\n      if (seen.has(key)) return seen.get(key)\n\n      let ans = 0n\n      const limit = tight ? digits[pos] : 9\n      for (let d = 0; d <= limit; d++) {\n        const newTight = tight && d === limit\n        if (!started && d === 0) {\n          ans += dfs(pos + 1, newTight, false, 0, 1, false)\n        } else {\n          const newStarted = true\n          if (d === 0) {\n            ans += dfs(pos + 1, newTight, newStarted, s + d, 0, true)\n          } else {\n            const newP = !started ? d : p * d\n            ans += dfs(pos + 1, newTight, newStarted, s + d, newP, hasZero)\n          }\n        }\n      }\n      seen.set(key, ans)\n      return ans\n    }\n    return dfs(0, true, false, 0, 1, false)\n  }\n}\n\nfunction state(pos, tight, started, s, p, hasZero) {\n    return `${pos},${tight},${started},${s},${p},${hasZero}`\n}\n/*\nclass State {\n  constructor(pos, tight, started, s, p, hasZero) {\n    this.pos = pos\n    this.tight = tight\n    this.started = started\n    this.s = s\n    this.p = p\n    this.hasZero = hasZero\n  }\n}\n*/\n\n","author":"wwwap","submissionId":"1575204687"},[]]},{"182":[{"id":"182","fileName":"1575205097.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\n#define X(x) ((x)^0LL)\n#define ADD(x,y) ((x)+(y))\n#define SUB(x,y) ((x)-(y))\n#define MUL(x,y) ((x)*(y))\n\ntemplate<typename T>\nusing v = vector<T>;\n\ntemplate<typename T>\nclass f_t {\npublic:\n    map<tuple<int, int, int, int, int>, long long> m;\n    v<int> d;\n    int L, mode;\n    \n    f_t(const v<int>& a, int b) : d(a), mode(b) { L = d.size(); }\n\n    long long f1(int a, int b, int c, int d1, int e) {\n        auto f2 = [](int f3) -> int { return ((f3 ^ 0x5F3A) ^ 0x5F3A); };\n        a = f2(a);\n        if(a == L) {\n            if(!c) return 0LL;\n            if(mode == 0) return 1LL;\n            return (d1 != 0 && (e % d1 == 0)) ? 1LL : 0LL;\n        }\n        \n        tuple<int, int, int, int, int> key = {a, b, c, d1, e};\n        if(m.count(key)) return m[key];\n\n        long long f5 = 0;\n        int f6 = (b ? d[a] : 9);\n        for (int f7 = 0; f7 <= f6; f7++) {\n            int f8 = (b && (f7 == f6)) ? 1 : 0;\n            int f9 = c, f10 = d1, f11 = e;\n            if(!c && f7 == 0) { }\n            else {\n                if(!c) { f9 = 1; f10 = f7; f11 = f7; }\n                else { f10 += f7; f11 *= f7; }\n            }\n            f5 += f1(a + 1, f8, f9, f10, f11);\n        }\n        return m[key] = f5;\n    }\n};\n\nv<int> f3(int a) {\n    v<int> b;\n    while(a > 0) { b.push_back(a % 10); a /= 10; }\n    reverse(b.begin(), b.end());\n    return b;\n}\n\nlong long f4(int a, int b) {\n    if(a < 1) return 0LL;\n    v<int> c = f3(a);\n    f_t<int> d(c, b);\n    return d.f1(0, 1, 0, 0, 1);\n}\n\nclass Solution {\npublic:\n    int beautifulNumbers(int a, int b) {\n        auto f5 = [&](int c, int d) -> long long { return f4(c, d); };\n        long long e = f5(b, 0) - f5(SUB(a, 1), 0);\n        long long f6 = SUB(b, a) + 1;\n        long long g = f6 - e;\n        long long h = f5(b, 1) - f5(SUB(a, 1), 1);\n        long long i = X(g) + h;\n        auto f7 = [&](long long j) -> long long { return (j * MUL(2, 1)) / 2; };\n        return (int) f7(i);\n    }\n};\n","author":"Abhay Dixit","submissionId":"1575205097"},[]]},{"183":[{"id":"183","fileName":"1575205160.txt","sourceCode":"class Solution {\n    public int beautifulNumbers(int l, int r) {\n        int ans = 0;\n        for (int i = 1; i < 100; i++) {\n            ans += beautifulNumbers(l, r, i);\n        }\n        return ans;\n    }\n\n    private int beautifulNumbers(int l, int r, int i) {\n        return countSpecialNumbers(r, i) - countSpecialNumbers(l - 1, i);\n    }\n\n    char[] s;\n    int[][][] dp;\n\n    public int countSpecialNumbers(int n, int v) {\n        if (n == 0) {\n            return 0;\n        }\n        this.s = String.valueOf(n).toCharArray();\n        int m = this.s.length;\n        dp = new int[m][v + 1][v + 1];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j <= v; j++) {\n                Arrays.fill(dp[i][j], -1);\n            }\n        }\n        return f(0, v, v, true, false);\n    }\n\n    /**\n     * 前i个字符，最终能满足条件的数字的个数\n     */\n    int f(int i, int sum, int prod, boolean isLimit, boolean isNum) {\n        if (i == s.length) {\n            return isNum && sum == 0 && prod == 1 ? 1 : 0;\n        }\n        if (!isLimit && isNum && dp[i][sum][prod] >= 0) {\n            return dp[i][sum][prod];\n        }\n        int res = 0;\n        if (!isNum) {\n            // 可以跳过当前数位\n            res = f(i + 1, sum, prod, false, false);\n        }\n        // 枚举要填入的数字 d\n        for (int d = isNum ? 0 : 1, up = isLimit ? s[i] - '0' : 9; d <= up; d++) {\n            if (sum >= d) {\n                res += f(i + 1, sum - d, prod / gcd(prod, d), isLimit && d == up, true);\n            }\n        }\n        if (!isLimit && isNum) {\n            dp[i][sum][prod] = res;\n        }\n        return res;\n    }\n\n    private int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n}","author":"cc4414","submissionId":"1575205160"},[]]},{"185":[{"id":"185","fileName":"1575206054.txt","sourceCode":"class Solution:\n    def __init__(self):\n        self.memo = {}\n        self.numString = \"\"\n\n    def calculateProduct(self, powers):\n        product = 1\n        for base, exponent in powers.items():\n            product *= base ** exponent\n        return product\n\n    def generateKey(self, position, tight, started, hasZero, digitSum, powers):\n        return (position, tight, started, hasZero, digitSum, tuple(powers.items()))\n\n    def recursiveCount(self, position, tight, started, hasZero, digitSum, powers):\n        if position == len(self.numString):\n            if not started:\n                return 0\n            if hasZero:\n                return 1\n            product = self.calculateProduct(powers)\n            return 1 if digitSum != 0 and product % digitSum == 0 else 0\n\n        key = self.generateKey(position, tight, started, hasZero, digitSum, powers)\n        if key in self.memo:\n            return self.memo[key]\n\n        result = 0\n        limit = int(self.numString[position]) if tight else 9\n\n        for digit in range(0, limit + 1):\n            newTight = tight and (digit == limit)\n            newStarted = started or (digit != 0)\n            newHasZero = hasZero or (newStarted and digit == 0)\n            newDigitSum = digitSum + digit if newStarted else 0\n            newPowers = powers.copy()\n\n            if newStarted and digit > 0:\n                for base in [2, 3, 5, 7]:\n                    while digit % base == 0:\n                        newPowers[base] += 1\n                        digit //= base\n\n            result += self.recursiveCount(position + 1, newTight, newStarted, newHasZero, newDigitSum, newPowers)\n\n        self.memo[key] = result\n        return result\n\n    def countBeautiful(self, number):\n        if number < 1:\n            return 0\n        self.numString = str(number)\n        self.memo.clear()\n        return self.recursiveCount(0, 1, 0, 0, 0, {2: 0, 3: 0, 5: 0, 7: 0})\n\n    def beautifulNumbers(self, left, right):\n        return self.countBeautiful(right) - self.countBeautiful(left - 1)\n","author":"fEqwiiMfze","submissionId":"1575206054"},[]]},{"186":[{"id":"186","fileName":"1575207106.txt","sourceCode":"class Solution {\npublic:\n    int dp(vector<int>& digits, map<vector<int>,int>& mem, int i, int tight, int first, int sum, int mul) {\n        if (i == digits.size()) return !first && mul % sum == 0;\n        if (mem.count({i, tight, first, sum, mul})) return mem[{i, tight, first, sum, mul}];\n        // cout << i << ' ' << tight << ' ' << first << ' ' << sum << ' ' << mul << 'n';\n        int cnt = 0;\n        for (int j = 0; j <= (tight ? digits[i] : 9); j++) {\n            int cur_tight = (tight && j == digits[i]);\n            int cur_first = (first && j == 0);\n            // cout << \"> \" << i << ' ' << j << 'n';\n            cnt += dp(digits, mem, i + 1, cur_tight, cur_first, sum + j, cur_first ? mul : (mul * j));\n        }\n        return mem[{i, tight, first, sum, mul}] = cnt;\n    }\n\n    int beautifulNumbers(int l, int r) {\n        // tong nam trong [1, 81] <-- uoc\n        // tich la boi cua 2, 3, 5, 7\n        // 2 -> 27\n        // 3 -> 18\n        // 5 -> 9\n        // 7 -> 9\n        // 39366 * 81 * 10 = 31886460\n        // dp[i][tight][sum][mul]\n\n        string str_l = to_string(l - 1), str_r = to_string(r);\n        vector<int> digits_l(str_l.begin(), str_l.end());\n        vector<int> digits_r(str_r.begin(), str_r.end());\n        for (auto &i : digits_l) i -= '0';\n        for (auto &i : digits_r) i -= '0';\n        map<vector<int>,int> mem_l, mem_r;\n\n        // for (auto &i : digits_l) cout << i << ' '; cout << 'n';\n        // for (auto &i : digits_r) cout << i << ' '; cout << 'n';\n\n        int ans_r = dp(digits_r, mem_r, 0, 1, 1, 0, 1);\n        // cout << \"-------\" << 'n';\n        int ans_l = dp(digits_l, mem_l, 0, 1, 1, 0, 1);\n\n        // cout << ans_r << ' ' << ans_l << 'n';\n        \n        return ans_r - ans_l;\n    }\n};","author":"allforest01","submissionId":"1575207106"},[]]},{"187":[{"id":"187","fileName":"1575207024.txt","sourceCode":"import itertools\nimport functools\n\nclass Solution:\n    def beautifulNumbers(self, lower: int, upper: int) -> int:\n        return self.count_valid_numbers(upper) - self.count_valid_numbers(lower - 1)\n\n    def get_digits(self, num: int):\n        return list(map(int, str(num)))\n\n    def init_dp(self):\n        return {(0, 1, 0): {(0, 1): 1}}\n\n    def update_dp(self, dp_table, index, max_digit):\n        next_dp = {}\n        for (pos, limit, nonzero), count_map in dp_table.items():\n            highest_digit = max_digit if limit else 9\n\n            for digit in range(highest_digit + 1):\n                new_limit = int(limit and digit == highest_digit)\n                new_nonzero = int(nonzero or digit > 0)\n                key = (index + 1, new_limit, new_nonzero)\n                temp_map = next_dp.setdefault(key, {})\n\n                for (sum_val, prod_val), occurrences in count_map.items():\n                    updated_sum, updated_product = (sum_val + digit, prod_val * digit) if new_nonzero else (0, 1)\n                    temp_map[updated_sum, updated_product] = temp_map.get((updated_sum, updated_product), 0) + occurrences\n\n        return next_dp\n\n    def count_valid_numbers(self, num: int) -> int:\n        if num < 1:\n            return 0\n\n        digits_list = self.get_digits(num)\n        total_digits = len(digits_list)\n        dp_table = self.init_dp()\n\n        for idx, digit in enumerate(digits_list):\n            dp_table = self.update_dp(dp_table, idx, digit)\n\n        return sum(\n            occurrences for (pos, _, nonzero), count_map in dp_table.items() if pos == total_digits and nonzero\n            for (sum_val, prod_val), occurrences in count_map.items()\n            if sum_val and prod_val % sum_val == 0\n        )\n","author":"devanshDev_001","submissionId":"1575207024"},[]]},{"188":[{"id":"188","fileName":"1575208101.txt","sourceCode":"from functools import lru_cache\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_beautiful(n):\n            if n == 0:\n                return 0\n            digits = list(map(int, str(n)))\n\n            @lru_cache(None)\n            def dp(pos, tight, prod, summ, leading_zero):\n                if pos == len(digits):\n                    return int(summ > 0 and prod % summ == 0)\n\n                limit = digits[pos] if tight else 9\n                res = 0\n\n                for d in range(0, limit + 1):\n                    new_prod = prod if leading_zero and d == 0 else prod * d\n                    new_summ = summ + d\n                    res += dp(pos + 1, tight and (d == limit), new_prod, new_summ, leading_zero and d == 0)\n\n                return res\n\n            return dp(0, True, 1, 0, True)\n\n        return count_beautiful(r) - count_beautiful(l - 1)\n","author":"CALL_ME_SHINCHAN","submissionId":"1575208101"},[]]},{"189":[{"id":"189","fileName":"1575208342.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_A(n):\n            if n == 0:\n                return 0\n            return n - count_non_zero(n)\n\n        def count_non_zero(n):\n            s = list(map(int, str(n)))\n            m = len(s)\n            \n            from functools import lru_cache\n\n            @lru_cache(maxsize=None)\n            def dfs(pos, tight, leading):\n                if pos == m:\n                    return 0 if leading else 1\n                max_d = s[pos] if tight else 9\n                total = 0\n                for d in range(0, max_d + 1):\n                    new_tight = tight and (d == max_d)\n                    new_leading = leading and (d == 0)\n                    if new_leading:\n                        # Continue leading zeros\n                        total += dfs(pos + 1, new_tight, new_leading)\n                    else:\n                        if d == 0:\n                            continue  # Skip zeros in non-leading positions\n                        total += dfs(pos + 1, new_tight, False)\n                return total\n\n            return dfs(0, True, True)\n\n        def count_B(n):\n            if n == 0:\n                return 0\n            s = list(map(int, str(n)))\n            m = len(s)\n            \n            from functools import lru_cache\n\n            @lru_cache(maxsize=None)\n            def dfs(pos, tight, leading_zero, sum_so_far, prod_so_far):\n                if pos == m:\n                    if leading_zero:\n                        return 0\n                    if sum_so_far == 0:\n                        return 0\n                    return 1 if (prod_so_far % sum_so_far) == 0 else 0\n                max_d = s[pos] if tight else 9\n                total = 0\n                for d in range(0, max_d + 1):\n                    new_tight = tight and (d == max_d)\n                    new_leading_zero = leading_zero and (d == 0)\n                    new_sum = sum_so_far\n                    new_prod = prod_so_far\n                    if not new_leading_zero:\n                        if d == 0:\n                            continue  # Skip zeros once leading_zero is False\n                        new_sum += d\n                        new_prod *= d\n                    total += dfs(pos + 1, new_tight, new_leading_zero, new_sum, new_prod)\n                return total\n\n            return dfs(0, True, True, 0, 1)\n\n        a_r = count_A(r)\n        a_l_1 = count_A(l - 1) if l > 1 else 0\n        b_r = count_B(r)\n        b_l_1 = count_B(l - 1) if l > 1 else 0\n\n        return (a_r - a_l_1) + (b_r - b_l_1)\n","author":"SCS","submissionId":"1575208342"},[]]},{"190":[{"id":"190","fileName":"1575209820.txt","sourceCode":"class Solution {\npublic:\n    int mem[2][10][100][100],vis[2][10][100][100],vid;\n    int sol(bool b,int i,int sum,int mul,string &R,int CurSum){\n        if(i==R.size())\n            return !mul&&sum==CurSum;\n        int &ret=mem[b][i][sum][mul];\n        if(vis[b][i][sum][mul]==vid)\n            return ret;\n        ret=0;\n        vis[b][i][sum][mul]=vid;\n        for (int j = 0; j <=(b?9:R[i]-'0') ; ++j)\n            ret+=sol(b|(j<R[i]-'0'),i+1,sum+j,(mul*((sum+j)?j:1))%CurSum,R,CurSum);\n        return ret;\n    }\n    int beautifulNumbers(int l, int r) {\n        vid=0;\n        memset(vis,0,sizeof vis);\n        string R=to_string(r);\n        string L=to_string(l-1);\n        int ans=0;\n        for (int i = 1; i <82 ; ++i) {\n            ++vid;\n            ans+= sol(0,0,0,1,R,i);\n            ++vid;\n            ans-=sol(0,0,0,1,L,i);\n        }\n        return ans;\n    }\n};","author":"AbdalrhmanEssam","submissionId":"1575209820"},[]]},{"191":[{"id":"191","fileName":"1575207911.txt","sourceCode":"class Solution {\npublic:\n    unordered_map<long long, int> dp;\n    int dfs(vector<int>& digits, long long index, long long bound, long long started, long long digitSum, long long digitProduct) {\n        // Base case\n        // cout << index << endl;\n        if (index == digits.size()) {\n            if (!started) return 0;\n            return (digitProduct == 0 || digitProduct % digitSum == 0) ? 1 : 0;\n        }\n\n        // Memoization\n        long long key = (index << 60) + (bound << 59) + (started << 58) + (digitSum << 26) + digitProduct;\n        if (dp.find(key) != dp.end()) return dp[key];\n\n        int result = 0;\n        int end = bound ? digits[index] : 9;\n        // cout << \"End: \" << end << endl;\n        for (int i = 0; i <= end; ++i) {\n            int nextBound = (bound && (i == end)) ? 1 : 0;\n            int nextStarted = started;\n            int nextDigitSum = digitSum;\n            int nextDigitProduct = digitProduct;\n\n            if (!started) {\n                if (i == 0) {\n                    nextStarted = 0;\n                    nextDigitSum = 0;\n                    nextDigitProduct = 1;\n                } else {\n                    nextStarted = 1;\n                    nextDigitSum = i;\n                    nextDigitProduct = i;\n                }\n            } else {\n                nextDigitSum = digitSum + i;\n                nextDigitProduct = (i == 0 || digitProduct == 0) ? 0 : digitProduct * i;\n            }\n\n            result += dfs(digits, index + 1, nextBound, nextStarted, nextDigitSum, nextDigitProduct);\n        }\n        dp[key] = result;\n        return result;\n    }\n\n    int count(int end) {\n        string str = to_string(end);\n        // cout << str << endl;\n        vector<int> digits(str.size());\n        for (int i = 0; i < str.size(); ++i) {\n            digits[i] = str[i] - '0';   \n        }\n        dp.clear();\n        return dfs(digits, 0, 1, 0, 0, 1);\n    }\n\n    int beautifulNumbers(int l, int r) {\n        // cout << count(r) << endl;\n        return count(r) - count(l - 1);\n    }\n};","author":"Mark Qi","submissionId":"1575207911"},[]]},{"192":[{"id":"192","fileName":"1575209633.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def f(n):\n            s = str(n)\n            # (started, zero, sum, prod, tight)\n            dp = Counter({(0, 0, 0, 1, 1): 1})\n            for x in s:\n                ndp = Counter()\n                for (st, z, sm, p, t), v in dp.items():\n                    l = int(x) if t else 9\n                    for d in range(l + 1):\n                        nt = (t and (d == l))\n                        if not st: k = (d > 0, 0, d, d, nt)\n                        else: k = (1, 1, 0, 1, nt) if (z or d == 0) else (1, 0, sm + d, p * d, nt)\n                        ndp[k] += v\n                dp = ndp\n            return sum(v for (st, z, sm, p, t), v in dp.items() if st and (z or (sm and p % sm == 0)))\n        return f(r) - f(l - 1)","author":"LTHW","submissionId":"1575209633"},[]]},{"193":[{"id":"193","fileName":"1575209859.txt","sourceCode":"from functools import lru_cache\n\ndef get_digits(n):\n    return list(map(int, str(n)))\n\n@lru_cache(None)\ndef dp(pos, tight, digit_sum, digit_product, leading_zero, digits):\n    if pos == len(digits):\n        return 1 if digit_sum == 0 or (digit_product % digit_sum == 0 if digit_sum > 0 else False) else 0  # Fix division issue\n    \n    limit = digits[pos] if tight else 9\n    result = 0\n    \n    for d in range(0, limit + 1):\n        new_digit_sum = digit_sum + d\n        new_digit_product = digit_product * d if not leading_zero or d != 0 else digit_product  # Handle leading zeros properly\n        result += dp(pos + 1, tight and (d == limit), new_digit_sum, new_digit_product, leading_zero and d == 0, digits)\n    \n    return result\n\ndef count_beautiful_up_to(n):\n    digits = get_digits(n)\n    return dp(0, True, 0, 1, True, tuple(digits))\n\n    \nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return count_beautiful_up_to(r) - count_beautiful_up_to(l - 1)\n\n","author":"Thomas Anderson","submissionId":"1575209859"},[]]},{"194":[{"id":"194","fileName":"1575209916.txt","sourceCode":"from functools import lru_cache\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_beautiful(n: int) -> int:\n            if n < 1:\n                return 0\n            digits = list(map(int, str(n)))\n            length = len(digits)\n\n            @lru_cache(None)\n            def dp(pos: int, tight: bool, started: bool, has_zero: bool, sum_digits: int, e2: int, e3: int, e5: int, e7: int) -> int:\n                if pos == length:\n                    if not started:\n                        return 0\n                    if has_zero:\n                        return 1\n                    product = (2 ** e2) * (3 ** e3) * (5 ** e5) * (7 ** e7)\n                    return 1 if sum_digits > 0 and product % sum_digits == 0 else 0\n\n                limit = digits[pos] if tight else 9\n                total = 0\n\n                for d in range(limit + 1):\n                    new_tight = tight and (d == limit)\n                    if not started:\n                        if d == 0:\n                            total += dp(pos + 1, new_tight, False, False, 0, 0, 0, 0, 0)\n                        else:\n                            new_e2 = new_e3 = new_e5 = new_e7 = 0\n                            temp = d\n                            while temp % 2 == 0:\n                                new_e2 += 1\n                                temp //= 2\n                            while temp % 3 == 0:\n                                new_e3 += 1\n                                temp //= 3\n                            while temp % 5 == 0:\n                                new_e5 += 1\n                                temp //= 5\n                            while temp % 7 == 0:\n                                new_e7 += 1\n                                temp //= 7\n                            total += dp(pos + 1, new_tight, True, False, d, new_e2, new_e3, new_e5, new_e7)\n                    else:\n                        if has_zero:\n                            total += dp(pos + 1, new_tight, True, True, sum_digits + d, 0, 0, 0, 0)\n                        else:\n                            if d == 0:\n                                total += dp(pos + 1, new_tight, True, True, sum_digits, 0, 0, 0, 0)\n                            else:\n                                new_e2, new_e3, new_e5, new_e7 = e2, e3, e5, e7\n                                temp = d\n                                while temp % 2 == 0:\n                                    new_e2 += 1\n                                    temp //= 2\n                                while temp % 3 == 0:\n                                    new_e3 += 1\n                                    temp //= 3\n                                while temp % 5 == 0:\n                                    new_e5 += 1\n                                    temp //= 5\n                                while temp % 7 == 0:\n                                    new_e7 += 1\n                                    temp //= 7\n                                total += dp(pos + 1, new_tight, True, False, sum_digits + d, new_e2, new_e3, new_e5, new_e7)\n\n                return total\n\n            return dp(0, True, False, False, 0, 0, 0, 0, 0)\n\n        return count_beautiful(r) - count_beautiful(l - 1)\n\n        ","author":"Sushant M S","submissionId":"1575209916"},[]]},{"195":[{"id":"195","fileName":"1575210007.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        @cache\n        def f(s, i: int, m1, m2, is_limit: bool, is_num: bool) -> int:\n            if i == len(s):\n                return int(is_num) and m1 % m2 == 0\n            res = 0\n            if not is_num:  # 可以跳过当前数位\n                res = f(s, i + 1, m1, m2, False, False)\n            up = int(s[i]) if is_limit else 9\n            for d in range(0 if is_num else 1, up + 1):  # 枚举要填入的数字 d\n                \n                res += f(s, i + 1, m1 * d, m2 + d, is_limit and d == up, True)\n            return res\n        return f(str(r), 0, 1, 0, True, False) - f(str(l - 1), 0, 1, 0, True, False)","author":"kwrefs","submissionId":"1575210007"},[]]},{"196":[{"id":"196","fileName":"1575210898.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return self.count_beautiful_up_to(r) - self.count_beautiful_up_to(l - 1)\n    \n    def count_beautiful_up_to(self, x):\n        s = str(x)\n        n = len(s)\n        @lru_cache(maxsize=None)\n        def dp(pos, sum_d, prod, started, tight):\n            if pos == n:\n                return int(started and sum_d and prod % sum_d == 0)\n            lim = int(s[pos]) if tight else 9\n            res = 0\n            for d in range(lim + 1):\n                ntight = tight and (d == lim)\n                if not started:\n                    if d == 0:\n                        res += dp(pos + 1, 0, 1, False, ntight)\n                    else:\n                        res += dp(pos + 1, d, d, True, ntight)\n                else:\n                    res += dp(pos + 1, sum_d + d, prod * d, True, ntight)\n            return res\n        return dp(0, 0, 1, False, True)","author":"Aditya_Kathpalia","submissionId":"1575210898"},[]]},{"197":[{"id":"197","fileName":"1575210318.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count(x):\n            s = str(x)\n            n = len(s)\n        \n            @cache\n            def dp(pos, tight, started, has_zero, prod, s_sum):\n                if pos == n:\n                    if not started:\n                        return 0\n                    if has_zero:\n                        return 1\n                    return 1 if s_sum != 0 and prod % s_sum == 0 else 0\n        \n                limit = int(s[pos]) if tight else 9\n                total = 0\n                for d in range(limit + 1):\n                    new_tight = tight and (d == limit)\n                    if not started:\n                        if d == 0:\n                            total += dp(pos + 1, new_tight, False, False, 1, 0)\n                        else:\n                            total += dp(pos + 1, new_tight, True, False, d, d)\n                    else:\n                        if not has_zero:\n                            if d == 0:\n                                total += dp(pos + 1, new_tight, True, True, 0, s_sum)\n                            else:\n                                total += dp(pos + 1, new_tight, True, False, prod * d, s_sum + d)\n                        else:\n                            total += dp(pos + 1, new_tight, True, True, 0, s_sum + d)\n                return total\n        \n            return dp(0, True, False, False, 1, 0)\n    \n        return count(r) - count(l - 1)","author":"bayibo","submissionId":"1575210318"},[]]},{"198":[{"id":"198","fileName":"1575212325.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nstruct DPState {\n    int idx, tight, started, sum;\n    long long prod;\n    bool operator==(const DPState &o) const {\n        return idx == o.idx && tight == o.tight && started == o.started &&\n               sum == o.sum && prod == o.prod;\n    }\n};\n\nstruct DPStateHash {\n    size_t operator()(const DPState &s) const {\n        size_t a = hash<int>()(s.idx);\n        size_t b = hash<int>()(s.tight);\n        size_t c = hash<int>()(s.started);\n        size_t d = hash<int>()(s.sum);\n        size_t e = hash<long long>()(s.prod);\n        size_t res = a;\n        res ^= b + 0x9e3779b97f4a7c15ULL + (res << 6) + (res >> 2);\n        res ^= c + 0x9e3779b97f4a7c15ULL + (res << 6) + (res >> 2);\n        res ^= d + 0x9e3779b97f4a7c15ULL + (res << 6) + (res >> 2);\n        res ^= e + 0x9e3779b97f4a7c15ULL + (res << 6) + (res >> 2);\n        return res;\n    }\n};\n\nclass Solution {\npublic:\n    long long solveDP(const vector<int>& v1, int a, int t, int st, int s, long long p,\n                      unordered_map<DPState, long long, DPStateHash>& mp) {\n        if(a == v1.size()){\n            if(!st) return 0;\n            return (s > 0 && p % s == 0) ? 1LL : 0LL;\n        }\n        DPState state {a, t, st, s, p};\n        if(mp.count(state))\n            return mp[state];\n        long long res = 0;\n        int lim=0;\n        if(t){\n            lim=v1[a];\n        }\n        else lim=9;\n        for(int d = 0; d <= lim; d++){\n            int nt = t;\n            if(t && d < lim) nt = 0;\n            int ns = s;\n            long long np = p;\n            int nst = st;\n            if(!st && d == 0){\n            } else {\n                if(!st){\n                    nst = 1;\n                    ns = d;\n                    np = d;\n                } else {\n                    ns += d;\n                    np *= d;\n                }\n            }\n            res += solveDP(v1, a + 1, nt, nst, ns, np, mp);\n        }\n        mp[state] = res;\n        return res;\n    }\n    long long beautifulCount(int x) {\n        if(x < 1) return 0;\n        string str = to_string(x);\n        vector<int> v1;\n        for(char c : str)\n            v1.push_back(c - '0');\n        unordered_map<DPState, long long, DPStateHash> mp;\n        return solveDP(v1, 0, 1, 0, 0, 1LL, mp);\n    }\n    int beautifulNumbers(int l, int r) {\n        long long res = beautifulCount(r) - beautifulCount(l - 1);\n        return (int)res;\n    }\n};\n","author":"Sundorom Das","submissionId":"1575212325"},[]]},{"199":[{"id":"199","fileName":"1575212388.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        \n        def func(v) :\n            digits = list(map(int,str(v)))\n            lim = len(digits)\n            cache = {}\n            def solve(idx,tight,prod,su,cache) :\n                key = (idx,tight,prod,su)\n                if key in cache :\n                    return cache[key]\n                if idx == lim :\n                    return 1 if (su > 0 and (prod % su == 0)) else 0\n                limit = digits[idx] if tight else 9 \n                cnt = 0\n                for d in range(limit,-1,-1) :\n                    nxtT = tight and (d == digits[idx]) \n                    nxtprod = prod if d == 0 and su == 0 else prod * d\n                    nxtsu = su + d\n                    cnt += solve(idx+1,nxtT,nxtprod,nxtsu,cache)\n                cache[key] = cnt\n                return cache[key]\n            return solve(0,True,1,0,cache)\n        \n        return func(r) - func(l-1)\n            ","author":"Yukesh R","submissionId":"1575212388"},[]]},{"200":[{"id":"200","fileName":"1575210971.txt","sourceCode":"class Solution {\npublic:\n    typedef tuple<int, int, int, int, int, int> tup;\n    struct Hs {\n        size_t operator()(const tup &s) const {\n            auto [ps, tg, st, hz, sm, pr] = s;\n            size_t res = 12;\n            res = res * 31 + hash<int>()(ps);\n            res = res * 31 + hash<int>()(tg);\n            res = res * 31 + hash<int>()(st);\n            res = res * 31 + hash<int>()(hz);\n            res = res * 31 + hash<int>()(sm);\n            res = res * 30 + hash<int>()(pr);\n            return res;\n        }\n    };\n    int beautifulNumbers(int l, int r) {\n        auto cnt_dp = [](int A) ->int64_t{\n            if(A == 0) return 0;\n            string s = to_string(A);\n            vector<int> dg;\n            for(const char c : s) {\n                dg.push_back(c - '0');\n            }\n            unordered_map<tup, int64_t, Hs> dp;\n            auto Dp = [&](auto & Dp, int ps, int tg, int st, int hz, int sm, int pr) ->int64_t {\n                if (ps == dg.size()) {\n                    if (!st) return 0;\n                    if (hz) return 1;\n                    return (pr % sm == 0) ? 1 : 0;\n                }\n                tup T = make_tuple(ps, tg, st, hz, (hz || !st) ? 0 : sm, (hz || !st) ? 0 : pr);\n                auto f = dp.find(T);\n                if(f != dp.end()) return f->second;\n                int64_t res = 0;\n                int up = tg ? dg[ps] : 9;\n                for (int d = 0; d <= up; d++) {\n                    int ntg = (tg && (d == up)) ? 1 : 0;\n                    int nst = st;\n                    int nhz = hz;\n                    int nsm = sm;\n                    int npr = pr;\n                    if (!st) {\n                        if (d == 0) {\n                            nst = 0;\n                        } \n                        else {\n                            nst = 1;\n                            nsm = d;\n                            npr = d;\n                        }\n                    } \n                    else { \n                        if (!nhz) {\n                            if (d == 0) {\n                                nhz = 1;\n                                nsm = 0;\n                                npr = 0;\n                            } \n                            else {\n                                nsm = sm + d;\n                                npr = pr * d;\n                            }\n                        }\n                    }\n                    res += Dp(Dp, ps + 1, ntg, nst, nhz, nst and !nhz ? nsm : 0, nst and !nhz ? npr : 0);\n                }\n                return dp[T] = res;\n            };\n            return Dp(Dp, 0, 1, 0, 0, 0, 1);\n        };\n        return int(cnt_dp(r) - cnt_dp(l - 1));\n    }\n};","author":"Abdulla bin ah","submissionId":"1575210971"},[]]},{"201":[{"id":"201","fileName":"1575211920.txt","sourceCode":"typedef long long ll;\nconst static auto _ = [] { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr; }();\n// Don't forget long long due to overflow !!!!!!!!!\n\nint dp[81][82][10][2][2];\nint vis[81][82][10][2][2];\nint ttt = 0;\n\nclass Solution {\npublic:\n\n\n    string curr;\n    int m;\n\n\n    int func(int idx, int mod, int sum, bool led, bool sm) {\n        mod %= m;\n        if(sum < 0) return 0;\n        if(idx == curr.size()) {\n            return mod == 0 && sum == 0;\n        }\n\n        if(vis[mod][sum][idx][led][sm] == ttt) return dp[mod][sum][idx][led][sm];\n        vis[mod][sum][idx][led][sm] = ttt;\n\n        int to = sm?9:curr[idx] - '0';\n        int ans = 0;\n        for (int i = 0; i <= to; ++i) {\n            if(led == 0 && i == 0) {\n                ans += func(idx + 1, mod % m, sum - i , led, sm || (i < curr[idx] - '0'));\n            }\n            else {\n                ans += func(idx + 1, (mod*1ll*i) % m, sum - i, led||(i!=0), sm || (i < curr[idx] - '0'));\n            }\n        }\n        return dp[mod][sum][idx][led][sm] = ans;\n    }\n    int beautifulNumbers(int l, int r) {\n\n        curr = to_string(r);\n\n        int ans = 0;\n        for (int i = 1; i <= 81; ++i) {\n            m = i;\n            ttt++;\n            ans += func(0, 1, i, 0, 0);\n\n        }\n\n        curr = to_string(l - 1);\n        for (int i = 1; i <= 81; ++i) {\n            m = i;\n            ttt++;\n            ans -= func(0, 1, i, 0, 0);\n        }\n        return ans;\n    }\n\n};","author":"Kareem Elgoker","submissionId":"1575211920"},[]]},{"202":[{"id":"202","fileName":"1575212537.txt","sourceCode":"int dp[11][2][82][82][82];\nint rec(int i,int flag,int cur,int sod,int prod,string& s){\n    if(i==0) return prod==0 and cur==sod;\n    if(dp[i][flag][cur][sod][prod]!=-1) return dp[i][flag][cur][sod][prod];\n    int end=9,ans=0,d;\n    if(flag==1) {\n        d=s[s.size()-i]-'0';\n        end=d;\n    }\n    for(int j=(cur==0);j<=end;j++){\n        int nflag=flag;\n        if(flag and j<d) nflag=0;\n        int nprod=prod;\n        nprod=(prod*j)%sod;\n        ans+=rec(i-1,nflag,cur+j,sod,nprod,s);\n    }\n    return dp[i][flag][cur][sod][prod]=ans;\n}\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        memset(dp,-1,sizeof(dp));\n        string rs=to_string(r),ls=to_string(l-1);\n        int rans=0,lans=0;\n        for(int i=1;i<=81;i++) for(int j=1;j<=rs.size();j++) rans+=rec(j,j==rs.size(),0,i,1,rs);\n        memset(dp,-1,sizeof(dp));\n        for(int i=1;i<=81;i++) for(int j=1;j<=ls.size();j++) lans+=rec(j,j==ls.size(),0,i,1,ls);\n        return rans-lans;\n    }\n};","author":"justDummy","submissionId":"1575212537"},[]]},{"203":[{"id":"203","fileName":"1575212471.txt","sourceCode":"class Solution {\n    static Map<String, Long> m;\n    public int beautifulNumbers(int l, int r) {\n        int[] arr = new int[] {l, r};\n        long countR = countUpTo(arr[1]);\n        long countL = countUpTo(arr[0] - 1);\n        return (int)(countR - countL);\n    }\n    public static long countUpTo(int n) {\n        if(n < 1) return 0;\n        char[] s = String.valueOf(n).toCharArray();\n        int[] dig = new int[s.length];\n        for (int i = 0; i < s.length; i++) {\n            dig[i] = s[i] - '0';\n        }\n        m = new HashMap<>();\n        return dp(0, 1, 0, 0, 1, dig);\n    }\n    public static long dp(int pos, int tight, int started, int sum, long prod, int[] digits) {\n        if (pos == digits.length) {\n            if (started == 0) return 0;  \n            return (sum > 0 && prod % sum == 0) ? 1 : 0;\n        }\n        String key = pos + \"_\" + tight + \"_\" + started + \"_\" + sum + \"_\" + prod;\n        if (m.containsKey(key)) return m.get(key);\n        \n        long res = 0;\n        int limit = (tight == 1) ? digits[pos] : 9;\n        for (int d = 0; d <= limit; d++) {\n            int ntight = (tight == 1 && d == limit) ? 1 : 0;\n            int nstarted = started;\n            int nsum = sum;\n            long nprod = prod;\n            \n            if (started == 0) {\n                if (d == 0) {\n                    nstarted = 0;\n                    nsum = 0;\n                    nprod = 1;  \n                } else {\n                    nstarted = 1;\n                    nsum = d;\n                    nprod = d;\n                }\n            } else {\n                nsum = sum + d;\n                if (prod == 0 || d == 0) {\n                    nprod = 0;\n                } else {\n                    nprod = prod * d;\n                }\n            }\n            res += dp(pos + 1, ntight, nstarted, nsum, nprod, digits);\n        }\n        m.put(key, res);\n        return res;\n    }\n}","author":"Mohammad Ashhar","submissionId":"1575212471"},[]]},{"206":[{"id":"206","fileName":"1575213901.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        \n        def count_up_to(n):\n            if n == 0:\n                return 0\n                \n            digits = str(n)\n            length = len(digits)\n            \n            memo = {}\n            \n            def dp(pos, tight, digit_sum, digit_product, started):\n                if pos == length:\n                    if not started:\n                        return 0\n                    return 1 if digit_sum > 0 and digit_product % digit_sum == 0 else 0\n                    \n                key = (pos, tight, digit_sum, digit_product, started)\n                if key in memo:\n                    return memo[key]\n                    \n                result = 0\n                limit = int(digits[pos]) if tight else 9\n                \n                for d in range(limit + 1 if tight else 10):\n                    new_started = started or d > 0\n                    \n                    if not new_started:\n                        result += dp(pos + 1, tight and d == limit, 0, 1, False)\n                        continue\n                    \n                    new_sum = digit_sum + d\n                    new_product = digit_product * d if d > 0 else 0 if started else 1\n                    \n                    if d == 0 and started:\n                        new_product = 0\n                    \n                    new_tight = tight and d == limit\n                    \n                    result += dp(pos + 1, new_tight, new_sum, new_product, new_started)\n                    \n                memo[key] = result\n                return result\n                \n            return dp(0, True, 0, 1, False)\n        \n        return count_up_to(r) - count_up_to(l - 1)","author":"monkeylogic","submissionId":"1575213901"},[]]},{"207":[{"id":"207","fileName":"1575212981.txt","sourceCode":"use std::collections::HashMap;\n\nstruct BeautifulNumbersSolver {\n    s: Vec<char>,\n    dp: HashMap<(usize, bool, bool, bool, i32, i32, i32, i32, i32), i64>,\n}\n\nimpl BeautifulNumbersSolver {\n    fn rec(\n        &mut self,\n        pos: usize,\n        tight: bool,\n        started: bool,\n        has_zero: bool,\n        sum: i32,\n        e2: i32,\n        e3: i32,\n        e5: i32,\n        e7: i32,\n    ) -> i64 {\n        if pos == self.s.len() {\n            if !started {\n                return 0;\n            }\n            if has_zero {\n                return 1;\n            }\n\n            let mut prod = 1;\n            for _ in 0..e2 {\n                prod *= 2;\n            }\n            for _ in 0..e3 {\n                prod *= 3;\n            }\n            for _ in 0..e5 {\n                prod *= 5;\n            }\n            for _ in 0..e7 {\n                prod *= 7;\n            }\n            return if sum != 0 && prod % sum == 0 { 1 } else { 0 };\n        }\n\n        let key = (pos, tight, started, has_zero, sum, e2, e3, e5, e7);\n        if let Some(&res) = self.dp.get(&key) {\n            return res;\n        }\n\n        let mut res = 0;\n        let limit = if tight { self.s[pos] as i32 - '0' as i32 } else { 9 };\n\n        for d in 0..=limit {\n            let ntight = tight && (d == limit);\n            if !started {\n                if d == 0 {\n                    res += self.rec(pos + 1, ntight, false, false, 0, 0, 0, 0, 0);\n                } else {\n                    let mut new_e2 = 0;\n                    let mut new_e3 = 0;\n                    let mut new_e5 = 0;\n                    let mut new_e7 = 0;\n                    let mut temp = d;\n                    while temp % 2 == 0 {\n                        new_e2 += 1;\n                        temp /= 2;\n                    }\n                    while temp % 3 == 0 {\n                        new_e3 += 1;\n                        temp /= 3;\n                    }\n                    while temp % 5 == 0 {\n                        new_e5 += 1;\n                        temp /= 5;\n                    }\n                    while temp % 7 == 0 {\n                        new_e7 += 1;\n                        temp /= 7;\n                    }\n                    res += self.rec(pos + 1, ntight, true, false, d, new_e2, new_e3, new_e5, new_e7);\n                }\n            } else {\n                let new_sum = sum + d;\n                if has_zero {\n                    res += self.rec(pos + 1, ntight, true, true, new_sum, 0, 0, 0, 0);\n                } else {\n                    if d == 0 {\n                        res += self.rec(pos + 1, ntight, true, true, new_sum, 0, 0, 0, 0);\n                    } else {\n                        let mut new_e2 = e2;\n                        let mut new_e3 = e3;\n                        let mut new_e5 = e5;\n                        let mut new_e7 = e7;\n                        let mut temp = d;\n                        while temp % 2 == 0 {\n                            new_e2 += 1;\n                            temp /= 2;\n                        }\n                        while temp % 3 == 0 {\n                            new_e3 += 1;\n                            temp /= 3;\n                        }\n                        while temp % 5 == 0 {\n                            new_e5 += 1;\n                            temp /= 5;\n                        }\n                        while temp % 7 == 0 {\n                            new_e7 += 1;\n                            temp /= 7;\n                        }\n                        res += self.rec(\n                            pos + 1,\n                            ntight,\n                            true,\n                            false,\n                            new_sum,\n                            new_e2,\n                            new_e3,\n                            new_e5,\n                            new_e7,\n                        );\n                    }\n                }\n            }\n        }\n\n        self.dp.insert(key, res);\n        res\n    }\n\n    fn count_beautiful(&mut self, x: i32) -> i64 {\n        if x < 1 {\n            return 0;\n        }\n        self.dp.clear();\n        self.s = x.to_string().chars().collect();\n        self.rec(0, true, false, false, 0, 0, 0, 0, 0)\n    }\n}\n\nimpl Solution {\n    pub fn beautiful_numbers(l: i32, r: i32) -> i32 {\n        let mut solver = BeautifulNumbersSolver {\n            s: vec![],\n            dp: HashMap::new(),\n        };\n        (solver.count_beautiful(r) - solver.count_beautiful(l - 1)) as i32\n    }\n}\n","author":"leetcoder_999","submissionId":"1575212981"},[]]},{"210":[{"id":"210","fileName":"1575214516.txt","sourceCode":"nines = ['9'*n for n in range(10)]\n\n@cache\ndef f(lim,s=0,p=1,started=False):\n    if not lim:\n        return int(started and not p%s)\n    if lim == '0'*len(lim):\n        return int(started)\n    dlim = int(lim[0])\n    total = 0\n    if not started:\n        total += f(nines[len(lim)-1])\n    for d in range(not started,dlim):\n        total += f(nines[len(lim)-1],s+d,p*d,True)\n    total += f(lim[1:],s+dlim,p*dlim,True)\n    print(lim,s,p,total)\n    return total\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return f(str(r))-f(str(l-1))","author":"dirigibility","submissionId":"1575214516"},[]]},{"211":[{"id":"211","fileName":"1575214631.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_beautiful(N):\n            digits = list(map(int, str(N)))\n\n            @cache\n            def dp(pos, tight, s, p, leading_zero):\n                if pos == len(digits):\n                    return 1 if s > 0 and p % s == 0 else 0\n                limit = digits[pos] if tight else 9\n                total = 0\n                # print(total)\n                for d in range(0, limit + 1):\n                    new_s = s + d\n                    new_p = p * (d if not leading_zero or d > 0 else 1)  \n                    total += dp(pos + 1, tight and (d == limit), new_s, new_p, leading_zero and d == 0)\n                # print(total)\n                return total\n            # print(dp(0,True,0,1,True))\n            return dp(0, True, 0, 1, True)\n        # print(count_beautiful(9))\n        return count_beautiful(r) - count_beautiful(l - 1)\n","author":"Vishnu Bathla","submissionId":"1575214631"},[]]},{"212":[{"id":"212","fileName":"1575213404.txt","sourceCode":"class Solution {\npublic:\n    long long dp(string &s, int pos, int t, bool started, bool zero, int sum, int prod, unordered_map<long long, long long>&memo)\n{\n    if(pos == s.size())\n    {\n        return started && (zero || (prod%sum==0));\n    }\n\n    long long key = (((((long long)pos<<2)|t)<<1|started)<<1|zero);\n    key = (key<<7)|sum;\n    key = (key<<32)|prod;\n\n    if(memo.count(key))\n    {\n        return memo[key];\n    }\n    long long ans = 0;\n    int limit = t ? s[pos]-'0' : 9;\n    for(int d=0; d<=limit; d++)\n        {\n            int nt=t && (d==limit);\n            if(!started)\n            {\n                if(d==0)\n                {\n                    ans += dp(s, pos+1, nt, false, false, 0, 1, memo);\n                }\n                else\n                {\n                    ans += dp(s, pos+1, nt, true, false, d, d, memo);\n                }\n            }\n            else\n            {\n                if(d==0)\n                {\n                    ans += dp(s, pos+1, nt, true, true, 0, 0, memo);\n                }\n                else\n                {\n                    if(zero)\n                    {\n                        ans += dp(s, pos+1, nt, true, true, 0, 0, memo);\n                    }\n                    else\n                    {\n                        ans += dp(s, pos+1, nt, true, false, sum+d, prod*d, memo);\n                    }\n                }\n            }\n        }\n    return memo[key] = ans;\n}\nlong long solve(long long x)\n{\n    if(x <= 0)\n    {\n        return 0;\n    }\n    string s = to_string(x);\n    unordered_map<long long, long long> memo;\n    return dp(s, 0, 1, false, false, 0, 1, memo);\n}\n    int beautifulNumbers(int l, int r) {\n        return solve(r)-solve(l-1);\n    }\n};","author":"Harsh Thakkar","submissionId":"1575213404"},[]]},{"213":[{"id":"213","fileName":"1575214946.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        \n        def count_beautiful(x):\n            \"\"\"Counts beautiful numbers from 1 to x using digit DP.\"\"\"\n            if x == 0:\n                return 0  # No numbers in range [1, 0]\n            \n            digits = list(map(int, str(x)))  # Convert number to digit array\n            n = len(digits)\n            \n            @lru_cache(None)\n            def dp(pos, sum_digits, prod_digits, is_tight, is_nonzero):\n                \"\"\"\n                pos -> Current digit index in number\n                sum_digits -> Sum of digits so far\n                prod_digits -> Product of digits so far\n                is_tight -> Whether we are bound by the upper limit\n                is_nonzero -> If we've encountered at least one nonzero digit\n                \"\"\"\n                if pos == n:\n                    return 1 if is_nonzero and prod_digits % sum_digits == 0 else 0\n                \n                limit = digits[pos] if is_tight else 9  # If tight, we must stay within limit\n                count = 0\n                \n                for d in range(0, limit + 1):  # Try all possible digits\n                    new_sum = sum_digits + d\n                    new_prod = prod_digits * d if d > 0 or is_nonzero else 1  # Avoid multiplying by 0\n                    new_is_nonzero = is_nonzero or (d > 0)\n                    \n                    count += dp(\n                        pos + 1,\n                        new_sum,\n                        new_prod,\n                        is_tight and (d == limit),\n                        new_is_nonzero\n                    )\n                \n                return count\n            \n            return dp(0, 0, 1, True, False)\n        \n        # Find beautiful numbers in range [l, r] using digit DP\n        return count_beautiful(r) - count_beautiful(l - 1)","author":"aditi_pillai","submissionId":"1575214946"},[]]},{"214":[{"id":"214","fileName":"1575215638.txt","sourceCode":"struct tuple_hash {\n    template <class T1, class T2, class T3, class T4>\n    size_t operator()(const tuple<T1, T2, T3, T4> &t) const {\n        auto h1 = hash<T1>{}(get<0>(t));\n        auto h2 = hash<T2>{}(get<1>(t));\n        auto h3 = hash<T3>{}(get<2>(t));\n        auto h4 = hash<T4>{}(get<3>(t));\n        return h1 ^ (h2 << 1) ^ (h3 << 2) ^ (h4 << 3);\n    }\n};\n\nunordered_map<tuple<int, int, int, int>, int, tuple_hash> memo;\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        return solve(r) - solve(l-1);\n    }\n\n    int solve(int n) {\n        if (!n) return 0;\n        int len = log10(n) + 1;\n        vector<int> v(len);\n        for (int x = n, i = len - 1; x; x /= 10, i--) {\n            v[i] = x % 10;\n        }\n        memo.clear();\n        // cout << endl;\n        return dp(v, 0, 1, 0, 1);\n    }\n\n    int dp(const vector<int>& v, int pos, int is_mx, int s, int p) {\n        if (pos == v.size()) {\n            return s && p % s == 0;\n        }\n        \n        tuple<int, int, int, int> key = make_tuple(pos, is_mx, s, p);\n        auto it = memo.find(key);\n        if (it != memo.end()) return it->second;\n\n        int lim = is_mx ? v[pos] : 9;\n        int res = 0;\n        for (int d = 0; d <= lim; d++) {\n            res += dp(v, pos + 1, is_mx && d == lim, s + d, (s + d) ? p * d : 1);\n        }\n        \n        // cout << pos << ' ' << is_mx << ' ' << s << ' ' << p << \" = \" << res << endl;\n        memo[key] = res;\n        return res;\n    }\n};\n","author":"h_bugw7","submissionId":"1575215638"},[]]},{"215":[{"id":"215","fileName":"1575215505.txt","sourceCode":"class Solution {\n    public int beautifulNumbers(int l, int r) {\n        return countBeautiful(r) - countBeautiful(l - 1);\n    }\n\n    public int countBeautiful(int x) {\n        if (x < 0) return 0;\n        char[] digits = getCharArray(x);\n        HashMap<String, Integer> dp = new HashMap<>();\n        return solve(0, 1, 0, 1, digits, dp);\n    }\n\n    public char[] getCharArray(int x) {\n        return String.valueOf(x).toCharArray();\n    }\n\n    public int solve(int i, int tight, int sum, int prod, char[] digits, HashMap<String, Integer> dp) {\n        if (i == digits.length) {\n            if (sum > 0 && prod % sum == 0) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n\n        String key = i + \" - \" + tight + \" - \" + sum + \" - \" + prod;\n        if (dp.containsKey(key)) return dp.get(key);\n\n        int limit;\n        if (tight == 1) {\n            limit = digits[i] - '0';\n        } else {\n            limit = 9;\n        }\n\n        int count = 0, j = 0;\n        while (j <= limit) {\n            int newTight;\n            if (tight == 1 && j == limit) {\n                newTight = 1;\n            } else {\n                newTight = 0;\n            }\n\n            int newSum = sum + j;\n            int newProd;\n            if (j == 0 && sum == 0) {\n                newProd = 1;\n            } else {\n                newProd = prod * j;\n            }\n\n            count += solve(i + 1, newTight, newSum, newProd, digits, dp);\n            j++;\n        }\n\n        dp.put(key, count);\n        return count;\n    }\n}\n","author":"Priyanshu Pandey","submissionId":"1575215505"},[]]},{"216":[{"id":"216","fileName":"1575215968.txt","sourceCode":"int dp[11][2][2][82][82] ; \nint vis[11][2][2][82][82] ; \nint tkn = 2 ; \nvector < int > vec ; \nint f(int idx , int st , int t1 , int cur , int pr , int sm)\n{\n   if(idx == vec.size())\n      return ((cur == sm and pr == 0 and st == 1)) ; \n   int  & res = dp[idx][st][t1][cur][pr] ;\n   if(tkn == vis[idx][st][t1][cur][pr])\n      return res ; \n   vis[idx][st][t1][cur][pr] = tkn ; \n   res = 0 ;  \n   int to = ((t1)?vec[idx] : 9) ; \n   for(int i = 0 ; i <= to ; i += 1)\n   {\n      if(st | (i != 0))\n         res += f(idx + 1 , st | (i != 0) , t1 & (i == to) , cur + i , (pr * i) % sm , sm) ; \n      else\n         res += f(idx + 1 , 0 , 0 , 0 , 1 , sm) ; \n   }\n   return res ; \n}   ;   \nclass Solution \n{\n   public:\n   int beautifulNumbers(int l, int r) \n   {\n\n      auto give = [ & ](int x , int sm) -> int{\n         if(x == 0)return 0 ; \n         vec.clear() ; \n         tkn ++  ; \n         while(x > 0)\n         {\n            vec.push_back(x % 10) ; \n            x /= 10 ; \n         }\n         reverse(vec.begin() , vec.end()) ; \n         return f(0 , 0 , 1 , 0 , 1 , sm) ; \n      }   ; \n      int ans = 0 ; \n      for(int i = 1 ; i <= 81 ; i += 1)\n      {\n         ans += give(r , i) - give(l-1 , i) ; \n      }\n      return ans ; \n   }\n};","author":"Ritik Rathor","submissionId":"1575215968"},[]]},{"217":[{"id":"217","fileName":"1575216141.txt","sourceCode":"\n            \nclass Solution(object):\n    def beautifulNumbers(self, l, r):\n        \"\"\"\n        :type l: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        \"\"\"\n        com = 0\n        \n        for num in range(l,r+1):\n            s = str(num)\n            tot = 0\n            p = 1\n            for c in s:\n                tot += int(c)\n                p *= int(c)\n                \n            if p % tot == 0:\n                com += 1\n        \"\"\"\n\n        \n        \n        def getnext(index, s, flag,  prod, tot, dic):\n            if index==len(s):\n                if tot==0:\n                    return 0\n                elif prod % tot == 0:\n                    return 1\n                else:\n                    return 0\n                \n            state = (index,flag,prod,tot)\n            \n            \n            if state in dic:\n                return dic[state]\n            \n        \n            \n            res = 0\n            if flag:\n                for d in range(int(s[index])):\n                    if d == 0 and tot == 0:\n                        res += getnext(index+1,s,False, prod, tot, dic)\n                    else:\n                        res += getnext(index+1,s,False, prod*d, tot+d, dic)\n                res += getnext(index+1, s, True, prod*int(s[index]), tot+int(s[index]), dic)\n            \n            else:\n                for d in range(10):\n                    if d == 0 and tot == 0:\n                        res += getnext(index+1,s,False, prod, tot, dic)  \n                    else:\n                        res += getnext(index+1,s, False, prod*d, tot+d, dic)\n            \n            dic[state] = res\n            return res\n        \n        \n\n\n        \n        \n        \n        \n        if l == 1:\n            dic = {}\n            res = getnext(0,str(r),True,1,0,dic)\n            return res\n        \n        \n\n        dic = {}\n        res1 = getnext(0,str(r),True,1,0,dic)\n        \n        dic = {}\n        res2 = getnext(0,str(l-1),True,1,0,dic)\n            \n            \n\n            \n            \n        return res1 - res2\n    \n        \n            \n                \n                \n    \n            \n            \n        \n        \n        \n        \n                        \n                    \n                    \n                    ","author":"hxu10","submissionId":"1575216141"},[]]},{"218":[{"id":"218","fileName":"1575216278.txt","sourceCode":"class Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        int r_count = count(to_string(r), 0, true, 1, 0, false);\n        _memo.clear();\n        int l_count = (l > 1 ? count(to_string(l - 1), 0, true, 1, 0, false) : 0);\n        return r_count - l_count;\n    }\nprivate:\n    unordered_map<string, int> _memo;\n    int count(string_view boundary, int idx, int is_boundary, int product, int sum, int has_started) {\n        if (idx == boundary.size()) {\n            return has_started && product % sum == 0;\n        }\n        auto key = to_string(sum) + \"#\" + to_string(product) + \"#\" + to_string(has_started) + \"#\" + to_string(idx) + \"#\" + to_string(is_boundary);\n        if (_memo.contains(key)) {\n            return _memo[key];\n        }\n        int max_digit = 9;\n        if (is_boundary) {\n            max_digit = boundary[idx] - '0';\n        }\n        int res{0};\n        for (int digit = 0; digit <= max_digit; ++digit) {\n            if (!has_started) {\n                if (digit == 0)\n                    res += count(boundary, idx + 1, is_boundary & (max_digit == digit), 1, 0, false);\n                else\n                    res += count(boundary, idx + 1, is_boundary & (max_digit == digit), digit, digit, true);\n            }\n            else {\n                if (digit == 0)\n                    res += count(boundary, idx + 1, is_boundary & (max_digit == digit), 0, sum, has_started);\n                else\n                    res += count(boundary, idx + 1, is_boundary & (max_digit == digit), product * digit, sum + digit, has_started);\n            }\n        }\n        return _memo[key] = res;\n    }\nint find_sum(string_view nums) {\n    int sum{0};\n    for (auto num : nums) {\n        sum += num - '0';   \n    }\n    return sum;\n}\nint find_product(string_view nums) {\n    int product = 1;\n    for (auto num : nums) {\n        product *= num;\n    }\n    return product;\n}\n};","author":"ahong107","submissionId":"1575216278"},[]]},{"219":[{"id":"219","fileName":"1575216389.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        # Helper function to compute digit DP\n        def count_beautiful_numbers(n):\n            s = str(n)\n            length = len(s)\n\n            @lru_cache(None)\n            def dp(pos, tight, prod, summ, leading_zero):\n                if pos == length:\n                    # If the product is divisible by the sum, it's a beautiful number\n                    return 0 if summ == 0 or prod % summ != 0 else 1\n                \n                result = 0\n                limit = int(s[pos]) if tight else 9\n                for d in range(0, limit + 1):\n                    new_prod = prod * d if not leading_zero or d != 0 else prod\n                    new_summ = summ + d if not leading_zero or d != 0 else summ\n                    new_tight = tight and (d == limit)\n                    new_leading_zero = leading_zero and (d == 0)\n                    result += dp(pos + 1, new_tight, new_prod, new_summ, new_leading_zero)\n                \n                return result\n            \n            return dp(0, True, 1, 0, True)\n\n        # Count beautiful numbers up to 'r' and subtract those below 'l'\n        return count_beautiful_numbers(r) - count_beautiful_numbers(l - 1)\n\n","author":"Suprith123","submissionId":"1575216389"},[]]},{"220":[{"id":"220","fileName":"1575217276.txt","sourceCode":"from functools import lru_cache\n\nclass Solution:\n    def beautifulNumbers(self, mol: int, jul: int) -> int:\n        def can(lol):\n            tim = list(map(int, str(lol)))  \n            \n            @lru_cache(None)  # Memoization\n            def dp(vhh, tight, fghj, vbnm, asdf):\n                if vhh == len(tim):\n                    return 1 if (fghj > 0 and vbnm % fghj == 0) else 0\n                \n                limit = tim[vhh] if tight else 9\n                res = 0\n                \n                for digit in range(0, limit + 1):\n                    new_fghj = fghj + digit\n                    new_vbnm = vbnm * (digit if digit > 0 or fghj > 0 else 1)\n                    res += dp(vhh + 1, tight and (digit == limit), new_fghj, new_vbnm, asdf and digit == 0)\n                \n                return res\n            \n            return dp(0, True, 0, 1, True)\n        \n        return can(jul) - can(mol - 1)\n","author":"Arthanareeswarar Ravi","submissionId":"1575217276"},[]]},{"221":[{"id":"221","fileName":"1575217395.txt","sourceCode":"class Solution {\n    private String numStr;\n    private Map<Long, Long> memo;\n\n    private long rec(int pos, boolean tight, boolean started, boolean hasZero, int sum, int e2, int e3, int e5, int e7) {\n        if (pos == numStr.length()) {\n            if (!started) return 0;\n            if (hasZero) return 1;\n            int prod = 1;\n            for (int i = 0; i < e2; i++) prod *= 2;\n            for (int i = 0; i < e3; i++) prod *= 3;\n            for (int i = 0; i < e5; i++) prod *= 5;\n            for (int i = 0; i < e7; i++) prod *= 7;\n            return (sum != 0 && prod % sum == 0) ? 1 : 0;\n        }\n\n        long key = pos | (tight ? 1L : 0) << 4 | (started ? 1L : 0) << 5 | (hasZero ? 1L : 0) << 6\n                | (sum << 7) | ((long) e2 << 14) | ((long) e3 << 20) | ((long) e5 << 26) | ((long) e7 << 32);\n\n        if (memo.containsKey(key)) return memo.get(key);\n\n        long result = 0;\n        int limit = tight ? numStr.charAt(pos) - '0' : 9;\n        for (int digit = 0; digit <= limit; digit++) {\n            boolean nextTight = tight && (digit == limit);\n            if (!started) {\n                if (digit == 0) {\n                    result += rec(pos + 1, nextTight, false, false, 0, 0, 0, 0, 0);\n                } else {\n                    int newSum = digit;\n                    int newE2 = 0, newE3 = 0, newE5 = 0, newE7 = 0;\n                    int temp = digit;\n                    while (temp % 2 == 0) { newE2++; temp /= 2; }\n                    while (temp % 3 == 0) { newE3++; temp /= 3; }\n                    while (temp % 5 == 0) { newE5++; temp /= 5; }\n                    while (temp % 7 == 0) { newE7++; temp /= 7; }\n                    result += rec(pos + 1, nextTight, true, false, newSum, newE2, newE3, newE5, newE7);\n                }\n            } else {\n                if (hasZero) {\n                    result += rec(pos + 1, nextTight, true, true, sum + digit, 0, 0, 0, 0);\n                } else {\n                    if (digit == 0) {\n                        result += rec(pos + 1, nextTight, true, true, sum, 0, 0, 0, 0);\n                    } else {\n                        int newSum = sum + digit;\n                        int newE2 = e2, newE3 = e3, newE5 = e5, newE7 = e7;\n                        int temp = digit;\n                        while (temp % 2 == 0) { newE2++; temp /= 2; }\n                        while (temp % 3 == 0) { newE3++; temp /= 3; }\n                        while (temp % 5 == 0) { newE5++; temp /= 5; }\n                        while (temp % 7 == 0) { newE7++; temp /= 7; }\n                        result += rec(pos + 1, nextTight, true, false, newSum, newE2, newE3, newE5, newE7);\n                    }\n                }\n            }\n        }\n        memo.put(key, result);\n        return result;\n    }\n\n    private long countBeautiful(long x) {\n        if (x < 1) return 0;\n        numStr = String.valueOf(x);\n        memo = new HashMap<>();\n        return rec(0, true, false, false, 0, 0, 0, 0, 0);\n    }\n\n    public int beautifulNumbers(int l, int r) {\n        return (int) (countBeautiful(r) - countBeautiful(l - 1));\n    }\n}\n","author":"Jyothirmai_5m4","submissionId":"1575217395"},[]]},{"222":[{"id":"222","fileName":"1575216535.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        l1_str = str(l-1)\n        r_str = str(r)\n        @cache\n        def dp(cStr, idx = 0, strict=True, prod=-1,sum=0):\n            if idx == len(cStr):\n                if sum == 0: return 0\n                return prod % sum == 0\n            dig = int(cStr[idx]) \n            lim = dig if strict else 9\n            def calcProd(num):\n                nonlocal prod\n                if prod == -1: \n                    if num == 0:\n                        return -1\n                    return num\n                return prod*num\n            res = 0\n            for i in range(lim+1):\n                nxtProd = calcProd(i)\n                nxtSum = sum + i\n                nxtStrict = strict & (i == lim)\n                res += dp(cStr, idx + 1, nxtStrict, nxtProd, nxtSum)\n            return res\n        return dp(r_str) - dp(l1_str)","author":"abz-codes","submissionId":"1575216535"},[]]},{"224":[{"id":"224","fileName":"1575218737.txt","sourceCode":"class Solution {\n    static  long dp[][][][][]=new long[11][2][2][82][82];\n       \n    public int beautifulNumbers(int l, int r) {\n     String s=String.valueOf(l);\n     String s1=String.valueOf(r);\n        long ans=0;\n        int totalmax=9*s1.length();\n        StringBuilder p=new StringBuilder();\n        for(int sum=1;sum<=totalmax;sum++){\n          for(int j=0;j<s1.length();j++){\n              for(int k=0;k<2;k++){\n                  for(int k1=0;k1<2;k1++){\n                      for(int k2=0;k2<=81;k2++){\n                      for(int k3=0;k3<=81;k3++){\n                      \n                          dp[j][k][k1][k2][k3]=-1;\n                      }\n                  }\n              }\n          }}\n        ans=ans+sol(s1,0,0,0,1,0,sum,p);\n        }\n       // System.out.println(ans);\n          for(int sum=1;sum<=totalmax;sum++){\n           for(int j=0;j<s.length();j++){\n               for(int k=0;k<2;k++){\n                   for(int k1=0;k1<2;k1++){\n                       for(int k2=0;k2<=81;k2++){\n                           for(int k3=0;k3<=81;k3++){\n                           dp[j][k][k1][k2][k3]=-1;\n                       }\n                       }\n                   }\n               }\n           } \n              ans=ans-sol(s,0,0,0,1,0,sum,p);\n          }\n        int sum=0;\n        int product=1;\n        for(int z=0;z<s.length();z++){\n        sum+=(s.charAt(z)-'0');\n            product=product*(s.charAt(z)-'0');\n        }\n        if(product%sum==0){\n            ans++;\n        }\n        return (int)ans;\n    }\n    long sol(String s,int i,int small,int zero,int product,int sum,int reqsum,StringBuilder p){\n       if(sum>reqsum){\n           return 0;\n       }\n        if(i>=s.length()){\n          // System.out.println(p);\n      //    System.out.println(p+\",\"+zero+\",\"+sum);\n          \n            if(product==0 && zero==1 && sum==reqsum){\n          // System.out.println(p);\n    //      System.out.println(p);\n              \n                return 1;\n            }\n            return 0;\n        }\n        if(dp[i][small][zero][product][sum]!=-1){\n            return dp[i][small][zero][product][sum];\n        }\n        long ans=0;\n        if(small==1){\n            for(int val=0;val<=9;val++){\n        //        p.append(val);\n                if(zero==0 && val==0){\n                    \n                    ans=ans+sol(s,i+1,1,0,product,sum,reqsum,p);\n                }else{\n                    \n                    ans=ans+sol(s,i+1,1,1,(product*val)%reqsum,sum+val,reqsum,p);\n                }\n          //   p.deleteCharAt(p.length()-1);\n            }\n            \n        }else{\n            int cur=(int)(s.charAt(i)-'0');\n            for(int val=0;val<=cur;val++){\n            //    p.append(val);\n                if(zero==0 && val==0){\n                    ans=ans+sol(s,i+1,1,0,product,sum,reqsum,p);\n                }else{\n                    if(val==cur){\n                    ans=ans+sol(s,i+1,0,1,(product*val)%reqsum,sum+val,reqsum,p);    \n                    }else{\n                    ans=ans+sol(s,i+1,1,1,(product*val)%reqsum,sum+val,reqsum,p);\n                    }\n                }\n              //  p.deleteCharAt(p.length()-1);\n            }\n            \n        }\n        \n        return dp[i][small][zero][product][sum]=ans;\n    }\n}","author":"grimreaper123","submissionId":"1575218737"},[]]},{"226":[{"id":"226","fileName":"1575219446.txt","sourceCode":"class Solution {\n    public int beautifulNumbers(int l, int r) {\n        return beautifulNumbers(r) - beautifulNumbers(l - 1);\n    }\n\n    private int beautifulNumbers(int num) {\n        if (num == 0) {\n            return 0;\n        }\n\n        char[] cs = String.valueOf(num).toCharArray();\n        Map<String, Integer>[][][] cache = new Map[2][cs.length][100];\n        for (Map[][] mat : cache) {\n            for (Map[] row : mat) {\n                for (int i = 0; i < row.length; i++) {\n                    row[i] = new HashMap<>();\n                }\n            }\n        }\n        return beautifulNumbers(cs, 0, false, 0, new int[] {0, 0, 0, 0, 0}, cache);\n    }\n\n    private int beautifulNumbers(char[] cs, int ind, boolean smaller, int sum, int[] prod, Map<String, Integer>[][][] cache) {\n        if (ind >= cs.length) {\n            if (sum == 0) {\n                return 0;\n            }\n            if (prod[0] > 0) {\n                return 1;\n            }\n            for (int i = 0; i < prod[1] && sum % 2 == 0; i++) {\n                sum /= 2;\n            }\n            for (int i = 0; i < prod[2] && sum % 3 == 0; i++) {\n                sum /= 3;\n            }\n            for (int i = 0; i < prod[3] && sum % 5 == 0; i++) {\n                sum /= 5;\n            }\n            for (int i = 0; i < prod[4] && sum % 7 == 0; i++) {\n                sum /= 7;\n            }\n            return sum == 1 ? 1 : 0;\n        }\n\n        String key = Arrays.toString(prod);\n        if (cache[smaller ? 1 : 0][ind][sum].containsKey(key)) {\n            return cache[smaller ? 1 : 0][ind][sum].get(key);\n        }\n\n        int count = 0;\n        for (int i = 0; i <= (smaller ? 9 : cs[ind] - '0'); i++) {\n            switch (i) {\n                case 0:\n                    if (sum != 0) {\n                        prod[0]++;\n                    }\n                    break;\n                case 1:\n                    break;\n                case 2:\n                    prod[1]++;\n                    break;\n                case 3:\n                    prod[2]++;\n                    break;\n                case 4:\n                    prod[1] += 2;\n                    break;\n                case 5:\n                    prod[3]++;\n                    break;\n                case 6:\n                    prod[1]++;\n                    prod[2]++;\n                    break;\n                case 7:\n                    prod[4]++;\n                    break;\n                case 8:\n                    prod[1] += 3;\n                    break;\n                case 9:\n                    prod[2] += 2;\n                    break;\n            }\n            count += beautifulNumbers(cs, ind + 1, smaller || i < cs[ind] - '0', sum + i, prod, cache);\n            switch (i) {\n                case 0:\n                    if (sum != 0) {\n                        prod[0]--;\n                    }\n                    break;\n                case 1:\n                    break;\n                case 2:\n                    prod[1]--;\n                    break;\n                case 3:\n                    prod[2]--;\n                    break;\n                case 4:\n                    prod[1] -= 2;\n                    break;\n                case 5:\n                    prod[3]--;\n                    break;\n                case 6:\n                    prod[1]--;\n                    prod[2]--;\n                    break;\n                case 7:\n                    prod[4]--;\n                    break;\n                case 8:\n                    prod[1] -= 3;\n                    break;\n                case 9:\n                    prod[2] -= 2;\n                    break;\n            }\n        }\n\n        cache[smaller ? 1 : 0][ind][sum].put(key, count);\n        return count;\n    }\n}","author":"Feng W","submissionId":"1575219446"},[]]},{"227":[{"id":"227","fileName":"1575216974.txt","sourceCode":"class Solution:\n    def printout(self, l, r):\n        for num in range(l, r+1):\n            digs = []\n            temp = num\n            while temp > 0:\n                digs.append(temp%10)\n                temp //= 10\n            total = 0\n            prod = 1\n            for d in digs:\n                total += d\n                prod *= d\n            if prod % total == 0:\n                print(num)\n                \n    \n    def beautifulNumbers(self, l: int, r: int) -> int:\n        \n        #self.printout(583, 623)\n        #return 0\n        digs = []\n        temp = r\n        while temp > 0:\n            digs.append(temp%10)\n            temp //= 10\n        self.cache = {}\n\n        options = self.get_combs(len(digs))\n        usable = []\n        for option in options:\n            if self.works(option):\n                usable.append(option)\n        self.usable = usable\n        self.facts = [1, 1]\n        for i in range(2, 11):\n            self.facts.append(i * self.facts[i-1])\n\n\n        #print(self.mhelper([0, 0, 0, 0, 0, 2, 0, 0, 0, 0], 2))\n        #print(self.multiplic([4, 6, 6]))\n\n\n        \n        #print(self.facts)\n        return self.helper(r) - self.helper(l - 1)\n\n    def helper(self, num):\n        digs = []\n        temp = num\n        while temp > 0:\n            digs.append(temp%10)\n            temp //= 10\n        digs = digs[::-1]\n        #print(digs)\n        result = 0\n        for option in self.usable:\n            if len(option) < len(digs):\n                result += self.multiplic(option)\n                continue\n                #print(option)\n            if len(option) > len(digs):\n                continue\n            counts = [0] * 10\n            for num in option:\n                counts[num] += 1\n            #print(\"{}, {} => {}\".format(digs, option, self.same_helper(digs, counts, True)))\n            result += self.same_helper(digs, counts, True)\n        return result\n\n    def same_helper(self, digs, counts, is_first=False):\n        if len(digs) == 0:\n            return 1\n        max_first = digs[0]\n        result = 0\n        for dig in range(1 if is_first else 0, max_first):\n            if counts[dig] > 0:\n                counts[dig] -= 1\n                result += self.mhelper(counts, len(digs)-1)\n                counts[dig] += 1\n        if counts[max_first] > 0:\n            counts[max_first] -= 1\n            result += self.same_helper(digs[1:], counts, False)\n            counts[max_first] += 1\n        return result\n\n    def multiplic(self, option):\n        counts = [0] * 10\n        for num in option:\n            counts[num] += 1\n        result = 0\n        for num in range(1, 10):\n            if counts[num] == 0:\n                continue\n            counts[num] -= 1\n            result += self.mhelper(counts, len(option)-1)\n            counts[num] += 1\n        return result\n\n    def mhelper(self, counts, sublen):\n        res = self.facts[sublen]\n        for num in range(0, 10):\n            if counts[num] != 0:\n                res //= self.facts[counts[num]]\n        return res\n    \n    def works(self, option):\n        total = 0\n        prod = 1\n        for num in option:\n            total += num\n            prod *= num\n\n        return total != 0 and prod % total == 0\n\n    @functools.cache\n    def get_combs(self, maxlen):\n        result = []\n        for sublen in range(1, maxlen+1):\n            result += self.get_combs_by_len(sublen, 0)\n        return result\n\n    def get_combs_by_len(self, sublen, start_digit):\n        #if (sublen, start_digit) in self.cache:\n        #    return self.cache[(sublen, start_digit)]\n        if start_digit == 9:\n            return [[9] * sublen]\n        if sublen == 0:\n            return [[]]\n        result = self.get_combs_by_len(sublen, start_digit+1)\n        for subres in self.get_combs_by_len(sublen-1, start_digit):\n            result.append([start_digit] + subres)\n        #if sublen <= 3:\n        #    self.cache[(sublen, start_digit)] = result\n        return result\n        ","author":"swrush98","submissionId":"1575216974"},[]]},{"228":[{"id":"228","fileName":"1575218596.txt","sourceCode":"/* -------------------------------------------------------- */\n/*   ( The Authentic JS CodeBuff )  \n ___ _                      _              _  \n | _ ) |_  __ _ _ _ __ _ __| |_ __ ____ _ (_)  \n | _  ' / _` | '_/ _` / _`  V  V / _` || |  \n |___/_||___,_|_| __,___,_|_/_/__,_|/ |  \n                                        |__/  \n */\n/* ---------------------------------------------------------   */\n/*    Youtube: https://youtube.com/@code-with-Bharadwaj        */\n/*    Github : https://github.com/Manu577228                   */\n/* ----------------------------------------------------------- */\n\nvar beautifulNumbers = function (a, b) {\n        let k = [a, b];\n        return ~~(c(b) - c(a - 1));\n};\n\nfunction c(n) {\n        if (n < 1) return 0;\n        let d = (n + '').split('');\n        let m = new Map();\n        return dp(0, 1, 0, 0, 1, d, m);\n}\n\nfunction dp(p, t, s, u, v, d, m) {\n        if (p === d.length) {\n                return (s && u > 0 && v % u === 0) ? 1 : 0;\n        }\n        let k = p + ',' + (t ? 1 : 0) + ',' + (s ? 1 : 0) + ',' + u + ',' + v;\n        if (m.has(k)) return m.get(k);\n        \n        let l = t ? d[p] - '0' : 9;\n        let w = 0;\n        \n        for (let x = 0; x <= l; x++) {\n                let nt = t && (x === l);\n                let ns = s || (x !== 0);\n                let nu = u;\n                let nv = v;\n                if (ns) {\n                        if (!s) {\n                                nu = x;\n                                nv = x;\n                        } else {\n                                nu += x;\n                                nv *= x;\n                        }\n                }\n                w += dp(p + 1, nt, ns, nu, nv, d, m);\n        }\n        m.set(k, w);\n        return w;\n}\n","author":"Manu Bharadwaj BN","submissionId":"1575218596"},[]]},{"229":[{"id":"229","fileName":"1575220677.txt","sourceCode":"int dp[82][82][2][9];\nclass Solution {\nvector<int> tmp;\npublic:\n    vector<int> getDigits(int num) {\n        vector<int> digits;\n        while (num > 0) {\n            digits.push_back(num % 10);\n            num /= 10;\n        }\n        reverse(digits.begin(), digits.end());\n        return digits;\n    }\n    int func(int idx, int sum, int prodModSum, bool tight, const vector<int>& digits,int dsum) {\n        if (idx == digits.size()) {\n            if (sum == dsum && prodModSum == 0){\n                // cout<<\"tmp\"<<\": \";\n                // for(auto i:tmp) cout<<i<<\" \";\n                // cout<<endl;\n                return 1;\n            }\n            return 0;\n        }\n\n        if (dp[sum][prodModSum][tight][idx] != -1) {\n            return dp[sum][prodModSum][tight][idx];\n        }\n\n        int limit = tight ? digits[idx] : 9;\n        int result = 0;\n\n        for (int digit=0;digit<=limit;digit++) {\n            if (sum + digit > dsum) continue;\n            int prod = (prodModSum * digit) % (dsum);\n            if(digit==0 && sum==0){\n                prod=1;\n            }\n            tmp.push_back(digit);\n            result += func(idx + 1, sum + digit, prod, tight && (digit == limit), digits,dsum);\n            tmp.pop_back();\n        }\n\n        dp[sum][prodModSum][tight][idx] = result;\n        return result;\n    }\n    int cnt(int x) {\n        if(x==0) return 0;\n        vector<int> digits = getDigits(x);\n        // for(auto i:digits){\n        //     cout<<i<<\",\";\n        // }\n        // cout<<endl;\n        int ans=0;\n        for(int dsum=1;dsum<=9*digits.size();dsum++){\n            memset(dp, -1, sizeof(dp));  \n            ans+=func(0, 0, 1, true, digits,dsum);  \n        }\n        return ans;\n    }\n    int beautifulNumbers(int l, int r) {\n        int rsh=cnt(r);\n        int lsh=cnt(l-1);\n        // cout<<rsh<<\" \"<<lsh<<endl;\n        return rsh-lsh;\n    }\n    /*\n    10\n    20\n    1\n    15\n    571\n    581\n    20\n100\n    */\n};","author":"Ritik Arora","submissionId":"1575220677"},[]]},{"231":[{"id":"231","fileName":"1575220366.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def calc(x):\n            if x <= 10:\n                return x\n            sx = str(x)\n            def good(p2, p3, p5, p7, sum):\n                if sum == 1:\n                    return True\n                np = [p2, p3, p5, p7]\n                p = [2,3,5,7]\n                n = [0,0,0,0]\n                for i in range(len(p)):\n                    a = p[i]\n                    while sum % a == 0:\n                        sum //= a\n                        n[i] += 1\n                        if n[i] > np[i]:\n                            return False\n                if sum > 1:\n                    return False\n                return True\n            def count(x, p):\n                if x == 0:\n                    return 10\n                ret = 0\n                while x > 1 and x % p == 0:\n                    ret += 1\n                    x = x // p\n                return ret\n            @cache\n            def dfs(idx: int, start: bool, end: bool, zero: bool, p2:int, p3:int, p5:int, p7:int, sum:int)->int:\n                #print(idx, start, end, zero, p2, p3, p5, p7, sum)\n                if idx == len(sx):\n                    #print(p2, p3, p5, p7, sum,  good(p2, p3, p5, p7, sum))\n                    return 1 if (start and (zero or good(p2, p3, p5, p7, sum))) else 0\n                ret = 0\n                if not start:\n                    ret = dfs(idx + 1, start, False, zero, p2, p3, p5, p7, sum)\n                l, r = 0, 9\n                if not start:\n                    l = 1\n                if end:\n                    r = min(r, ord(sx[idx]) - ord('0'))\n                for i in range(l, r + 1):\n                    ret += dfs(idx + 1, True, end and (i == r), zero or (i == 0),\n                               min(7, p2 + count(i, 2)), min(4, p3 + count(i, 3)),\n                               min(2, p5 + count(i, 5)), min(2, p7 + count(i, 7)), sum + i)\n                return ret\n            return dfs(0, False, True, False, 0, 0, 0, 0, 0)\n        return calc(r) - calc(l - 1)","author":"Thinkingface","submissionId":"1575220366"},[]]},{"232":[{"id":"232","fileName":"1575220605.txt","sourceCode":"class Solution {\npublic:\n    unordered_map<string, int> dp;\n\n    int Helper(string& x, int i, int s, int p, bool tgt, bool ld) {\n        if (i == x.size()) {\n            if (s == 0 || (p % s == 0)) return 1;\n            return 0;\n        }\n\n        string key = to_string(i) + \"|\" + to_string(s) + \"|\" + to_string(p) + \"|\" + to_string(tgt) + \"|\" + to_string(ld);\n        if (dp.find(key) != dp.end()) return dp[key];\n\n        int cnt = 0;\n        int lim = tgt ? x[i] - '0' : 9;\n\n        for (int j = 0; j <= lim; j++) {\n            int sum = (ld && j == 0) ? 0 : (s + j);\n            int prod = (ld && j == 0) ? 1 : (p * j);\n            bool ntgt = tgt && (j == lim);\n            bool nld = ld && (j == 0);\n            cnt += Helper(x, i + 1, sum, prod, ntgt, nld);\n        }\n\n        return dp[key] = cnt;\n    }\n\n    int beautifulNumbers(int l, int r) {\n        string rg = to_string(r);\n        l--;\n        string lf = to_string(l);\n        dp.clear();\n        int right = Helper(rg, 0, 0, 1, true, true);\n        dp.clear();\n        int left = Helper(lf, 0, 0, 1, true, true);\n        return right - left;\n    }\n};\n","author":"Vincenzo26_Cassano","submissionId":"1575220605"},[]]},{"233":[{"id":"233","fileName":"1575220444.txt","sourceCode":"class Solution:\n    def helper(self, n):\n        if n == 0:\n            return 0\n            \n        digits = list(map(int, str(n)))\n        length = len(digits)\n\n        @lru_cache(None)\n        def dp(pos, tight, sum_digits, prod_digits, started):\n            if pos == length:\n                return 1 if started and prod_digits % sum_digits == 0 else 0\n\n            limit = digits[pos] if tight else 9\n            result = 0\n\n            for digit in range(0, limit + 1):\n                new_tight = tight and (digit == limit)\n                new_sum = sum_digits + digit\n                new_prod = prod_digits * digit if digit != 0 or started else 1\n                new_started = started or digit > 0\n                result += dp(pos + 1, new_tight, new_sum, new_prod, new_started)\n\n            return result\n\n        return dp(0, True, 0, 1, False)\n        \n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return self.helper(r) - self.helper(l - 1)\n        ","author":"CalmCoderAnurag","submissionId":"1575220444"},[]]},{"234":[{"id":"234","fileName":"1575220762.txt","sourceCode":"class Solution {\n  public int beautifulNumbers(int l, int r) {\n    return helper(r) - helper(l - 1);\n  }\n\n  private int countValid(Map<String, Integer> dp, List<Integer> list, int idx, int prod, int sum, boolean b, boolean s) {\n    if (idx >= list.size()) {\n      if (!s) {\n        return 0;\n      }\n      return (sum != 0 && prod % sum == 0) ? 1 : 0;\n    }\n\n    String key = idx + \",\" + prod + \",\" + sum + \",\" + b;\n    if (dp.containsKey(key)) {\n      return dp.get(key);\n    }\n    int temp = b ? list.get(idx) : 9;\n    int ret = 0;\n    for (int i = 0; i <= temp; i++) {\n      boolean nS = s || (i != 0);\n      int newProd = prod, newSum = sum;\n      if (nS) {\n        if (!s && i != 0) {\n          newProd = i;\n        }\n        else if (s) {\n          newProd = prod * i;\n        }\n        newSum = sum + i;\n      }\n\n      boolean newB = b && (i == temp);\n      ret += countValid(dp, list, idx + 1, newProd, newSum, newB, nS);\n    }\n    \n    dp.put(key, ret);\n    return ret;\n  }\n\n  private int helper(int n) {\n    if (n == 0) {\n      return 0;\n    }\n    List<Integer> list = new ArrayList<>();\n    while (n > 0) {\n      list.add(n % 10);\n      n /= 10;\n    }\n    Collections.reverse(list);\n    Map<String, Integer> dp = new HashMap<>();\n    return countValid(dp, list, 0, 1, 0, true, false);\n  }\n}","author":"Zachary Bi","submissionId":"1575220762"},[]]},{"235":[{"id":"235","fileName":"1575220928.txt","sourceCode":"class Solution {\npublic:\n    unordered_map<string, int> dp;\n\n// Recursive function for Digit DP\nint countBeautifulHelper(vector<int> &digits, int pos, int sum, int product, bool tight, bool leadingZero) {\n    if (pos == digits.size()) \n        return (sum > 0 && product % sum == 0);  // A number is beautiful if product % sum == 0\n\n    string key = to_string(pos) + \"-\" + to_string(sum) + \"-\" + to_string(product) + \"-\" + to_string(tight) + \"-\" + to_string(leadingZero);\n    if (dp.count(key)) return dp[key];\n\n    int limit = tight ? digits[pos] : 9;\n    int count = 0;\n\n    for (int d = 0; d <= limit; d++) {\n        bool newLeadingZero = leadingZero && (d == 0);\n        count += countBeautifulHelper(digits, pos + 1, sum + d, (newLeadingZero ? 1 : product * d), tight && (d == limit), newLeadingZero);\n    }\n\n    return dp[key] = count;\n}\n\n// Helper function to extract digits and call recursive function\nint countBeautiful(int num) {\n    if (num == 0) return 0;  \n\n    vector<int> digits;\n    while (num) {\n        digits.push_back(num % 10);\n        num /= 10;\n    }\n    reverse(digits.begin(), digits.end());  \n\n    dp.clear();\n    return countBeautifulHelper(digits, 0, 0, 1, true, true);\n}\n    int beautifulNumbers(int l, int r) {\n         return countBeautiful(r) - countBeautiful(l - 1);\n    }\n};","author":"Rajat","submissionId":"1575220928"},[]]},{"238":[{"id":"238","fileName":"1575222040.txt","sourceCode":"class Solution:\n\n    def count_lesser_equals(self, already_lesser, d_prod, d_sum, idx, is_first):\n        if idx == len(self.target):\n            if d_sum == 0 or d_prod%d_sum != 0:\n                return 0\n            else:\n                return 1\n        hash_key = (already_lesser, d_prod, d_sum, idx, is_first)\n        if hash_key in self.dp:\n            return self.dp[hash_key]\n            \n        cnt = 0\n        for d in range(10):\n            if is_first and d == 0:\n                continue\n            if d > self.target[idx]:\n                if not already_lesser:\n                    break\n                else:\n                    cnt += self.count_lesser_equals(True, d_prod*d, d_sum+d, idx+1, False)\n            elif d == self.target[idx]:\n                cnt += self.count_lesser_equals(already_lesser, d_prod*d, d_sum+d, idx+1, False)\n            else:\n                cnt += self.count_lesser_equals(True, d_prod*d, d_sum+d, idx+1, False)\n        self.dp[hash_key] = cnt\n        return cnt\n        \n    def count_beautiful_lesser_equals(self, num):\n        if num == 0:\n            return 0\n        \n        self.target = []\n        while num > 0:\n            self.target.append(num%10)\n            num //= 10\n        self.target = list(reversed(self.target))\n\n        self.dp = {}\n        cnt = 0\n        for idx in range(1, len(self.target)):\n            cnt += self.count_lesser_equals(True, 1, 0, idx, True)\n        \n        cnt += self.count_lesser_equals(False, 1, 0, 0, True)\n        return cnt\n        \n\n    \n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return self.count_beautiful_lesser_equals(r)-self.count_beautiful_lesser_equals(l-1)\n    ","author":"Vihari Vemuri","submissionId":"1575222040"},[]]},{"239":[{"id":"239","fileName":"1575222357.txt","sourceCode":"#include <string>\n#include <unordered_map>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\n\nstruct State {\n    int pos, tight, started, hasZero, sum, prod;\n    bool operator==(const State &other) const {\n        return pos==other.pos && tight==other.tight && started==other.started &&\n               hasZero==other.hasZero && sum==other.sum && prod==other.prod;\n    }\n};\n\nstruct HASH_state {\n    size_t operator()(const State &s) const {\n        size_t h1 = std::hash<int>()(s.pos);\n        size_t h2 = std::hash<int>()(s.tight);\n        size_t h3 = std::hash<int>()(s.started);\n        size_t h4 = std::hash<int>()(s.hasZero);\n        size_t h5 = std::hash<int>()(s.sum);\n        size_t h6 = std::hash<int>()(s.prod);\n     \n        return (((((h1 * 31 + h2) * 31 + h3) * 31 + h4) * 31 + h5) * 31 + h6);\n    }\n};\n\nclass Solution {\npublic:\n  \n    ll f(const string &s, int pos, int tight, int started, int hasZero, int sum, int prod) {\n        if (pos == s.size()) {\n           \n            if (!started) return 0;\n           \n            if (hasZero) return 1;\n            \n            return (prod % sum == 0) ? 1 : 0;\n        }\n        \n        State st = {pos, tight, started, hasZero, sum, prod};\n        if(map_memo.count(st)) return map_memo[st];\n        \n        int limit = (tight ? (s[pos]-'0') : 9);\n        ll ans = 0;\n        \n        for (int dig = 0; dig <= limit; dig++) {\n            int n_is_tight = tight && (dig == limit);\n            int n_is_started = started;\n            int Zero_in_n = hasZero;\n            int nsum = sum;\n            int nprod = prod;\n            \n            if (!started && dig == 0) {\n             \n                ans += f(s, pos+1, n_is_tight, 0, 0, 0, 1);\n            } else {\n                \n                n_is_started = 1;\n                if (dig == 0) {\n                    \n                    Zero_in_n = 1;\n                  \n                    nprod = 0;\n                    nsum += 0; \n                } else {\n             \n                    if (!Zero_in_n) {\n                        nsum += dig;\n                        nprod *= dig;\n                    }\n                }\n                ans += f(s, pos+1, n_is_tight, n_is_started, Zero_in_n, nsum, nprod);\n            }\n        }\n        \n        map_memo[st] = ans;\n        return ans;\n    }\n    \n    \n    ll countUpTo(int num) {\n        string s = to_string(num);\n        map_memo.clear();\n        return f(s, 0, 1, 0, 0, 0, 1);\n    }\n    \n    int beautifulNumbers(int l, int r) {\n        \n        return (int)(countUpTo(r) - countUpTo(l-1));\n    }\n    \nprivate:\n    unordered_map<State, ll, HASH_state> map_memo;\n};","author":"Akshant Verma","submissionId":"1575222357"},[]]},{"240":[{"id":"240","fileName":"1575223166.txt","sourceCode":"\n/*Don Paul*/\n \n#define ll long long \n#define ld long double\n#define el __int128\n\n#define vl vector<ll>\n#define ust unordered_set\n#define ump unordered_map\n#define prq priority_queue\n \n#define pb push_back\n#define pp pop_back\n#define sz(x) ((int)x.size())\n#define be(x) x.begin(), x.end()\n#define farr(i, arr) for(int i=0; i<arr.size(); ++i)\n#define fpr(it, m) for(auto it=m.begin(); it!=m.end(); ++it)\n\n\n//Debugging tools\n\n#define lines cout<<\"n----------------------n\"\n#define bline cout<<\"n======================n\"\n#define parr(arr) for(int i=0; i<arr.size(); ++i) cout<<arr[i]<<\" \"; cout<<\"n\";\n#define pset(s) for(auto i=s.begin(); i!=s.end(); ++i) cout<<*i<<\" \"; cout<<\"n\";\n#define pmap(m) for(auto i=m.begin(); i!=m.end(); ++i) cout<<i->first<<\" - \"<<i->second<<\"n\";\n \nll mod = 1e9 + 7;\nll inf = 7e18;\n \n/*======================================================================================================================*/\n\nstring gen(ll pos, ll stat, ll start, ll pr, ll sum)\n{\n    string ans = \"\";\n    ans += to_string(pos) + '.' + to_string(stat) + '.' + to_string(start) + '.' + to_string(pr) + '.' + to_string(sum); \n    \n    return ans;\n}\n\n\nll find(ll pos, ll stat, ll start, string &curr, ll pr, ll sum, unordered_map<string, ll> &dp)\n{\n    if(pos == sz(curr))\n    {        \n        if(pr == 0)\n            return 1;\n        \n        if(sum == 0)\n            return 0;\n        \n        if(pr%sum == 0)\n            return 1;\n        return 0;\n    }        \n    \n    string s = gen(pos, stat, start, pr, sum);\n    \n    if(dp.find(s) != dp.end())\n        return dp[s];\n    \n    ll dig = curr[pos] - '0';\n    ll ans = 0;\n    \n    if(start == 0)\n    {\n        if(stat == 0)\n        {            \n            for(ll i=0; i<dig; ++i)\n            {      \n                if(i == 0)\n                {\n                    ans += find(pos+1, 1, 0, curr, 1, sum+i, dp);\n                    continue;\n                }\n                \n                ans += find(pos+1, 1, 1, curr, pr*i, sum+i, dp);\n            }\n            \n            \n            if(dig == 0)\n                ans += find(pos+1, 0, 0, curr, 1, sum+dig, dp);\n            else\n                ans += find(pos+1, 0, 1, curr, pr*dig, sum+dig, dp);\n        }\n\n        else if(stat == 1)\n        {\n            for(ll i=0; i<10; ++i)\n            {\n                if(i == 0)\n                {\n                    ans += find(pos+1, 1, 0, curr, 1, sum+i, dp);\n                    continue;\n                }\n                \n                ans += find(pos+1, 1, 1, curr, pr*i, sum+i, dp);\n            }\n        }\n\n        return dp[s] = ans;\n    }\n    \n    if(stat == 0)\n    {\n        for(ll i=0; i<dig; ++i)\n        {\n            ans += find(pos+1, 1, 1, curr, pr*i, sum+i, dp);\n        }\n\n        ans += find(pos+1, 0, 1, curr, pr*dig, sum+dig, dp);\n    }\n\n    else if(stat == 1)\n    {\n        for(ll i=0; i<10; ++i)\n        {\n            ans += find(pos+1, 1, 1, curr, pr*i, sum+i, dp);\n        }\n    }\n\n    return dp[s] = ans;\n}\n\n\n\nll check(string &s)\n{\n    ll sum = 0;\n    ll pr = 1;\n    \n    \n    for(ll i=0; i<sz(s); ++i)\n    {\n        ll curr = s[i] - '0';\n        sum += curr;\n        pr *= curr;\n    }\n    \n    if(pr % sum == 0)\n        return 1;\n    \n    return 0;\n}\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        \n        \n        string sl = to_string(l);\n        string sr = to_string(r);\n        \n        unordered_map<string, ll> dp;\n        ll a1 = find(0, 0, 0, sl, 1, 0, dp);\n        \n        dp.clear();\n        \n        ll a2 = find(0, 0, 0, sr, 1, 0, dp);\n            \n        bool dec = check(sl);\n        \n        // cout<<a2<<\" \"<<a1<<\"n\";\n        \n        return a2 - a1 + dec;\n        \n    }\n};","author":"Don Paul","submissionId":"1575223166"},[]]},{"241":[{"id":"241","fileName":"1575224246.txt","sourceCode":"#include <print>\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        string rs = to_string(r);\n        string ls = to_string(l-1);\n\n        int n = rs.size();\n\n        if(ls.size() < n) {\n            ls = string(n - ls.size(), '0') + ls;\n        }\n        // cout << ls << ' '　<< rs << 'n';\n\n\n        auto get_res = [&] (string_view s) {\n            int m = s.size();\n            vector<vector<unordered_map<int, int>>> dp(m, vector<unordered_map<int, int>>(80));\n            auto dfs = [&] (this auto&& dfs, int i, bool is_limit, bool is_num, int sum, long long pro) -> long long {\n                if(i == m) {\n                    if(!is_num || sum == 0) {\n                        \n                        return 0;\n                    }\n                    // println(\"pro:{} sum:{}\", pro, sum);\n                    return (pro % sum == 0);\n                }\n                if(!is_limit && is_num && dp[i][sum].count(pro)) {\n                    return dp[i][sum][pro];\n                }\n                long long res = 0;\n                if(!is_num) {\n                    res += dfs(i+1, is_limit && (s[i] - '0') == 0, false, sum, pro);\n                }\n                for(int j=1-is_num, up = is_limit ? (s[i] - '0') : 9; j<=up; j++) {\n                    // println(\"i:{} j:{} is_num:{}\", i, j, is_num);\n                    res += dfs(i+1, is_limit && j == up, true, sum + j, pro * j);\n                }\n                if(!is_limit && is_num)\n                    dp[i][sum][pro] = res;\n                return res;\n            };\n            return dfs(0, true, false, 0, 1);\n        };\n        auto r1 = get_res(rs);\n        auto r2 = get_res(ls);\n        // std::println(\"r1:{} r2:{}\", r1, r2);\n        return r1 - r2;\n    }\n};","author":"jason7708","submissionId":"1575224246"},[]]},{"242":[{"id":"242","fileName":"1575224038.txt","sourceCode":"class Solution:\n def beautifulNumbers(self,l:int,r:int)->int:\n  def Toulouse(x:int)->int:\n   if x<0:return 0\n   margot=list(map(int,str(x)));duchess=len(margot)\n   from functools import lru_cache\n   @lru_cache(maxsize=None)\n   def Marie(my_theo:int,my_tulus:int,my_ham:int,duchess_zero:int,my_m:int,my_garffield:int)->int:\n    if my_theo==duchess:\n     if not my_ham:return 0\n     if duchess_zero:return 1\n     return 1 if(my_m!=0 and my_garffield%my_m==0)else 0\n    limit=margot[my_theo]if my_tulus else 9;tot=0\n    for d in range(0,limit+1):\n     ntight=1 if(my_tulus and d==limit)else 0;nstarted=my_ham or(d>0);nzero=duchess_zero or(nstarted and d==0)\n     nsum=my_m+d if nstarted else 0;nprod=(0 if nzero else(my_garffield*d))if nstarted else 1\n     tot+=Marie(my_theo+1,ntight,nstarted,nzero,nsum,nprod)\n    return tot\n   return Marie(0,1,0,0,0,1)\n  return Toulouse(r)-Toulouse(l-1)\n","author":"AKASH SINGH CHOUDHARY","submissionId":"1575224038"},[]]},{"243":[{"id":"243","fileName":"1575224355.txt","sourceCode":"using System;\nusing System.Collections.Generic;\n\npublic class Solution {\n    private string numberString;\n    private Dictionary<string, int> memoization;\n\n    public int BeautifulNumbers(int left, int right) {\n        return CountValidNumbers(right) - CountValidNumbers(left - 1);\n    }\n\n    private int CountValidNumbers(int num) {\n        if (num < 1) return 0;\n        numberString = num.ToString();\n        memoization = new Dictionary<string, int>();\n        return DepthFirstSearch(0, true, false, false, 0, 0, 0, 0, 0);\n    }\n\n    private int DepthFirstSearch(int index, bool isLimited, bool hasStarted, bool containsZero, int sumDigits, int powerTwo, int powerThree, int powerFive, int powerSeven) {\n        if (index == numberString.Length) {\n            if (!hasStarted) return 0;\n            if (containsZero) return 1;\n            int product = (int)(Math.Pow(2, powerTwo) * Math.Pow(3, powerThree) * Math.Pow(5, powerFive) * Math.Pow(7, powerSeven));\n            return (sumDigits != 0 && product % sumDigits == 0) ? 1 : 0;\n        }\n\n        string key = $\"{index},{isLimited},{hasStarted},{containsZero},{sumDigits},{powerTwo},{powerThree},{powerFive},{powerSeven}\";\n        if (memoization.ContainsKey(key)) return memoization[key];\n\n        int count = 0;\n        int maxDigit = isLimited ? numberString[index] - '0' : 9;\n\n        for (int digit = 0; digit <= maxDigit; digit++) {\n            bool newLimit = isLimited && (digit == maxDigit);\n            if (!hasStarted) {\n                if (digit == 0) {\n                    count += DepthFirstSearch(index + 1, newLimit, false, false, 0, 0, 0, 0, 0);\n                } else {\n                    var factorPowers = GetFactorPowers(digit);\n                    count += DepthFirstSearch(index + 1, newLimit, true, false, digit, factorPowers[0], factorPowers[1], factorPowers[2], factorPowers[3]);\n                }\n            } else {\n                int newSum = sumDigits + digit;\n                if (containsZero || digit == 0) {\n                    count += DepthFirstSearch(index + 1, newLimit, true, true, newSum, 0, 0, 0, 0);\n                } else {\n                    var factorPowers = GetFactorPowers(digit);\n                    count += DepthFirstSearch(index + 1, newLimit, true, false, newSum, powerTwo + factorPowers[0], powerThree + factorPowers[1], powerFive + factorPowers[2], powerSeven + factorPowers[3]);\n                }\n            }\n        }\n\n        memoization[key] = count;\n        return count;\n    }\n\n    private int[] GetFactorPowers(int num) {\n        int[] powerFactors = new int[4];\n        while (num % 2 == 0) { powerFactors[0]++; num /= 2; }\n        while (num % 3 == 0) { powerFactors[1]++; num /= 3; }\n        while (num % 5 == 0) { powerFactors[2]++; num /= 5; }\n        while (num % 7 == 0) { powerFactors[3]++; num /= 7; }\n        return powerFactors;\n    }\n}\n","author":"harishnachiappanr","submissionId":"1575224355"},[]]},{"244":[{"id":"244","fileName":"1575222604.txt","sourceCode":"class Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        return countUpTo(r) - countUpTo(l - 1);\n    }\nprivate:\n    \n    int dp(int pos,\n                 bool tight,\n                 bool leadingZero,\n                 int sum,\n                 int prod,\n                 const vector<int>& digits,\n                 unordered_map<string,int>& memo)\n    {\n        \n        if (pos == (int)digits.size()) {\n            if (sum > 0 && (prod % sum == 0))\n                return 1;\n            return 0;\n        }\n\n        ostringstream oss;\n        oss << pos << \",\" << (tight ? 1 : 0) << \",\" << (leadingZero ? 1 : 0)\n            << \",\" << sum << \",\" << prod;\n        string key = oss.str();\n\n        if (memo.find(key) != memo.end()) {\n            return memo[key];\n        }\n\n        int ways = 0;\n        int limit = tight ? digits[pos] : 9;\n\n        for (int dig = 0; dig <= limit; dig++) {\n            bool nextTight = (tight && (dig == limit));\n            bool nextLeadingZero = (leadingZero && dig == 0);\n\n            int nextSum  = nextLeadingZero ? 0 : (sum + dig);\n            int nextProd = nextLeadingZero ? 1 : (prod * dig);\n\n            ways += dp(pos + 1, nextTight, nextLeadingZero, nextSum, nextProd,\n                       digits, memo);\n        }\n\n        memo[key] = ways;\n        return ways;\n    }\n\n    int countUpTo(int n) {\n        if (n < 0) \n            return 0;\n        vector<int> digits;\n        {\n            string s = to_string(n);\n            for (char c: s) {\n                digits.push_back(c - '0');\n            }\n        }    \n        unordered_map<string,int> memo;\n        return dp(0, true, true, 0LL, 1LL, digits, memo);\n    }\n};","author":"Kai Nguyen","submissionId":"1575222604"},[]]},{"245":[{"id":"245","fileName":"1575224418.txt","sourceCode":"#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define pb push_back\n//#define int long long\n#define sz(a) (int)a.size()\n#define all(a) begin(a),end(a)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nusing ll = long long;\nusing vi = vector<int>;\nusing ar2 = array<int,2>;\nusing ar3 = array<int,3>;\n\nconst int mxN = (int)2e5+10;\nconst int INF = (int)2e9;\nconst ll LINF = (ll)2e18;\nconst int MOD = (int)1e9+7;\n\nstring target;\nint dp[2][10][82][82];\nint D;\n\nint recur(int pos, bool sm=0, bool le=1, int dsum=0, int prod=1){\n    if(pos==-1) return !le and dsum==D and !prod;\n    int& res = dp[le][pos][dsum][prod];\n    if(sm && res != -1) return res;\n    int lim = sm?9:target[pos]-'0', ans = 0;\n    for(int d = 0; d <= lim; d++)\n        ans+=recur(pos-1,sm or d<lim, le?!d:0, dsum+d, (le?!d:0)?prod:(prod*d)%D);\n    return sm ? res = ans : ans;\n}\n \nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        \n        int ans = 0;\n        for(D = 1; D < 82; D++){\n            memset(dp, -1, sizeof(dp));\n            target = to_string(r); reverse(all(target));\n            int tot = recur((int)target.size()-1);\n            int len = sz(target);\n            target = to_string(l-1); \n            //while(sz(target) < len) target='0'+target;\n            reverse(all(target));\n            tot-=recur((int)target.size()-1);\n            ans+=tot;\n        }\n        return ans;\n    }\n};","author":"Daniel Emeka-Ilozor","submissionId":"1575224418"},[]]},{"247":[{"id":"247","fileName":"1575224777.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return self.count_beautiful(r) - self.count_beautiful(l - 1)\n\n    def count_beautiful(self, n: int) -> int:\n        if n < 1:\n            return 0\n        digits = list(str(n))\n        memo = {}\n        return self.find_beautiful(0, True, False, 0, 1, digits, memo)\n\n    def find_beautiful(self, pos: int, is_tight: bool, has_started: bool, digit_sum: int, digit_product: int, digits: list, memo: dict) -> int:\n        if pos == len(digits):\n            return 1 if has_started and digit_sum > 0 and digit_product % digit_sum == 0 else 0\n\n        key = (pos, is_tight, has_started, digit_sum, digit_product)\n        if key in memo:\n            return memo[key]\n\n        limit = int(digits[pos]) if is_tight else 9\n        count = 0\n\n        for d in range(limit + 1):\n            next_tight = is_tight and (d == limit)\n            new_started = has_started or (d != 0)\n            new_sum, new_prod = digit_sum, digit_product\n\n            if new_started:\n                new_sum = d if not has_started else digit_sum + d\n                new_prod = d if not has_started else digit_product * d\n\n            count += self.find_beautiful(pos + 1, next_tight, new_started, new_sum, new_prod, digits, memo)\n\n        memo[key] = count\n        return count\n","author":"Shri Varshini","submissionId":"1575224777"},[]]},{"248":[{"id":"248","fileName":"1575224916.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        @functools.cache\n        def count(l, r, p, s):\n            if s < 0: return 0\n            dl, dr = len(l), len(r)\n            if dl < dr: return count(l, '9' * dl, p, s) + count('1' + '0' * dl, r, p, s)\n            if dl == 0: return p == 1 and s == 0\n            P = 10**(dl - 1)\n            res = 0\n            for d in range(int(l[0]), int(r[0]) + 1):\n                L, R = max(l, str(d) + '0' * (dl - 1)), min(str(d) + '9' * (dl - 1), r)\n                res += count(L[1:], R[1:], p // math.gcd(p, d), s - d)\n            return res\n        res = 0\n        nd = len(str(r))\n        for s in range(1, nd * 9 + 1):\n            res += count(str(l), str(r), s, s)\n        return res","author":"echeresh","submissionId":"1575224916"},[]]},{"249":[{"id":"249","fileName":"1575225262.txt","sourceCode":"// int dp[9][82][82][2];\n\nclass Solution {\n    int memo(int i, int sum, int prod, bool flag, string &limit, map<array<int,4>,int> &dp){\n        if(!limit[i]){\n            // cout << sum << \", \" << prod << \"n\";\n            if(sum && prod%sum==0){\n                // cout << sum << \" : \" << prod << \"n\";\n                return 1;\n            }\n            return 0;\n        }\n        if(dp.find({i,sum,prod,flag})!=dp.end()) return dp[{i,sum,prod,flag}];\n        // if(dp[i][sum][prod][flag]!=-1) return dp[i][sum][prod][flag];\n        int d = limit[i]-'0', ans = 0;\n        if(flag){\n            for(int x=0; x<=d; ++x){\n                int temp;\n                if(prod==-1){\n                    if(x==0) temp = -1;\n                    else temp = x;\n                }\n                else{\n                    temp = prod*x;\n                }\n                ans += memo(i+1, sum+x, temp, x==d, limit,dp);\n            }\n        }\n        else{\n            for(int x=0; x<10; ++x){\n                int temp;\n                if(prod==-1){\n                    if(x==0) temp = -1;\n                    else temp = x;\n                }\n                else{\n                    temp = prod*x;\n                }\n                ans += memo(i+1, sum+x, temp, false, limit,dp);\n            }\n        }\n        return dp[{i,sum,prod,flag}] = ans;\n    }\npublic:\n    int beautifulNumbers(int l, int r) {\n        string lo = to_string(l-1), hi = to_string(r);\n        map<array<int,4>,int> dp;\n        // memset(dp,-1,sizeof(dp));\n        int cntl = memo(0,0,-1,true,lo,dp);\n        // cout << \"nn\";\n        // memset(dp,-1,sizeof(dp));\n        dp.clear();\n        int cntr = memo(0,0,-1,true,hi,dp);\n        return cntr - cntl;\n    }\n};","author":"Ankush Balse","submissionId":"1575225262"},[]]},{"250":[{"id":"250","fileName":"1575225322.txt","sourceCode":"#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntemplate <typename T> // find_by_order(), order_of_key()\nusing ordset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\nconst unsigned int M = 1000000007;\n\n#define ll long long\n#define lcm(m, n) (((m) / __gcd((m), (n))) * (n))\n#define pow(a, b) round(pow(a, b))\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define vi vector<int>\n#define pii pair<int, int>\n#define sz(a) ((int)a.size())\n#define pb push_back\n#define read(v)         \n    for (auto &xxx : v) \n        cin >> xxx;\n#define print(a)        \n    for (auto &xxx : a) \n        cout << xxx << ' ';\n#define for1(i, b) for (int i = 0; i < b; i++)\n#define for2(i, a, b) for (int i = a; i < b; i++)\n\nstruct TupleHash\n{\n    template <typename T>\n    static void hsh(size_t &seed, const T &val)\n    {\n        seed ^= hash<T>()(val) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n\n    size_t operator()(const tuple<int, bool, bool, int, ll> &key) const\n    {\n        size_t seed = 0;\n        hsh(seed, get<0>(key));\n        hsh(seed, get<1>(key));\n        hsh(seed, get<2>(key));\n        hsh(seed, get<3>(key));\n        hsh(seed, get<4>(key));\n        return seed;\n    }\n};\n\nclass Solution\n{\npublic:\n    int beautifulNumbers(int l, int r)\n    {\n        return func1(r) - func1(l - 1);\n    }\n\nprivate:\n    unordered_map<tuple<int, bool, bool, int, ll>, ll, TupleHash> memo;\n    ll func1(int n)\n    {\n        if (n < 1)\n            return 0;\n        string digs = to_string(n);\n        memo.clear();\n        return func2(0, true, false, 0, 1, digs);\n    }\n    ll func2(int pos, bool tight, bool started, int sum, ll prod, const string &digs)\n    {\n        if (pos == digs.size())\n        {\n            return (started && sum > 0 && prod % sum == 0) ? 1 : 0;\n        }\n\n        tuple<int, bool, bool, int, ll> key = {pos, tight, started, sum, prod};\n        if (memo.count(key))\n            return memo[key];\n\n        int till = tight ? digs[pos] - '0' : 9;\n        ll total = 0;\n\n        for (int d = 0; d <= till; d++)\n        {\n            bool nxt = tight && (d == till);\n            bool nxtst = started || (d != 0);\n            int nxtsm = sum;\n            ll nxtprd = prod;\n\n            if (nxtst)\n            {\n                if (!started)\n                {\n                    nxtsm = d;\n                    nxtprd = d;\n                }\n                else\n                {\n                    nxtsm += d;\n                    nxtprd *= d;\n                }\n            }\n            total += func2(pos + 1, nxt, nxtst, nxtsm, nxtprd, digs);\n        }\n\n        return memo[key] = total;\n    }\n};\n","author":"Harshil","submissionId":"1575225322"},[]]},{"251":[{"id":"251","fileName":"1575225916.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_up_to(n: int) -> int:\n            s = str(n)\n            N = len(s)\n            from functools import lru_cache\n            @lru_cache(maxsize=None)\n            def dfs(index, is_tight, is_leading, digit_sum, digit_product):\n                if index == N:\n                    if is_leading or digit_sum == 0:\n                        return 0\n                    return 1 if digit_product % digit_sum == 0 else 0\n                total = 0\n                max_digit = int(s[index]) if is_tight else 9\n                for d in range(max_digit + 1):\n                    new_tight = is_tight and (d == max_digit)\n                    if is_leading and d == 0:\n                        total += dfs(index + 1, new_tight, True, digit_sum, digit_product)\n                    else:\n                        total += dfs(index + 1, new_tight, False, digit_sum + d, digit_product * d)\n                return total\n            return dfs(0, True, True, 0, 1)\n        return count_up_to(r) - count_up_to(l - 1)","author":"Shivamani Burgu","submissionId":"1575225916"},[]]},{"252":[{"id":"252","fileName":"1575226082.txt","sourceCode":"class Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        auto cnt = [&](int x) -> long long {\n            if (x < 0) \n                return 0;\n            string str = to_string(x);\n            int n = str.size();\n            unordered_map<string, long long> mem;\n            auto dfs = [&](auto& self, int p, int t, int st, int sm, int pr) -> long long\n            {\n                if (p == n) \n                {\n                    if (!st) \n                        return 0;\n                    if (pr % sm == 0) \n                        return 1LL;\n                    else \n                        return 0LL;\n                }\n                string key = to_string(p) + \"_\" + to_string(t) + \"_\" + to_string(st) + \"_\" + to_string(sm) + \"_\" + to_string(pr);\n                if (mem.count(key)) \n                    return mem[key];\n                long long w = 0;\n                int lim = (t ? str[p] - '0' : 9);\n                for (int d = 0; d <= lim; d++) {\n                    int nt = (t && d == lim);\n                    int nst = st, nsm = sm, npr = pr;\n                    if (!st && d == 0) ;\n                    else if (!st && d > 0) \n                    {\n                        nst = 1;\n                        nsm = d;\n                        npr = d;\n                    } \n                    else \n                    {\n                        nsm += d;\n                        if (d == 0) \n                            npr = 0;\n                        else \n                            npr *= d;\n                    }\n\n                    w += self(self, p + 1, nt, nst, nsm, npr);\n                }\n                mem[key] = w;\n                return w;\n            };\n\n            return dfs(dfs, 0, 1, 0, 0, 1);\n        };\n\n        int ans = (int)(cnt(r) - cnt(l - 1));\n        return ans;\n    }\n};\n","author":"Abhay","submissionId":"1575226082"},[]]},{"253":[{"id":"253","fileName":"1575226503.txt","sourceCode":"class Solution {\n    char[] s;\n    Map<String, Integer> memo = new HashMap<>();\n    public int beautifulNumbers(int l, int r) {\n        return count(r) - count(l - 1);\n    }\n    \n    private int count(int x) {\n        if(x < 0) return 0;\n        s = Integer.toString(x).toCharArray();\n        memo.clear();\n        return f(0, 0, 1, true, false);\n    }\n    private int f(int i, int sum, int prod, boolean isLimit, boolean isNum) {\n        if(i == s.length)\n            return isNum ? (prod % sum == 0 ? 1 : 0) : 0;\n        String key = \" \" + i + (isLimit ? 1 : 0) + (isNum ? 1 : 0) + sum + prod;\n        if(!isLimit && isNum && memo.containsKey(key))\n            return memo.get(key);\n        int res = 0;\n        if(!isNum)\n            res += f(i + 1, sum, prod, false, false);\n        int up = isLimit ? s[i] - '0' : 9;\n        for (int d = isNum ? 0 : 1; d <= up; d++) {\n            boolean ntight = isLimit && (d == up);\n            int nsum = isNum ? sum + d : d;\n            int nprod = isNum ? prod * d : d;\n            res += f(i + 1, nsum, nprod, ntight, true);\n        }\n        if(!isLimit && isNum)\n            memo.put(key, res);\n        return res;\n    }\n}","author":"krobzh","submissionId":"1575226503"},[]]},{"254":[{"id":"254","fileName":"1575225719.txt","sourceCode":"from functools import lru_cache\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def countBeautifulNumbers(num):\n            s = str(num)\n            n = len(s)\n            @lru_cache(maxsize=None)\n            def dp(index, tight, sum_digits, product_digits, started):\n                if index == n:\n                    if not started: return 0\n                    if sum_digits == 0: return 0\n                    return int(product_digits % sum_digits == 0)\n                limit = int(s[index]) if tight else 9\n                total = 0\n                for digit in range(0, limit + 1):\n                    new_tight = tight and (digit == limit)\n                    new_started = started or (digit != 0)\n                    new_sum = sum_digits + (digit if new_started else 0)\n                    new_product = product_digits * (digit if new_started else 1)\n                    total += dp(index + 1, new_tight, new_sum, new_product, new_started)\n                return total\n            return dp(0, True, 0, 1, False)\n        return countBeautifulNumbers(r) - countBeautifulNumbers(l - 1)","author":"Peter Kalugin","submissionId":"1575225719"},[]]},{"255":[{"id":"255","fileName":"1575226524.txt","sourceCode":"#include <string>\n#include <unordered_map>\nusing namespace std;\nusing ll = long long;\n\nclass Solution {\npublic:\n    // Global variables used by the DP functions.\n    string s;  // the digit representation of the current X\n    unordered_map<string, ll> memo_nozero;       // memo for counting numbers with no zero digits\n    unordered_map<string, ll> memo_beautiful;      // memo for counting no–zero numbers that are \"beautiful\"\n\n    // DP to count numbers (in [1, X]) that have NO zero digit.\n    // Parameters:\n    //   pos: current index in the string s\n    //   tight: whether we are bounded by the prefix of s\n    //   started: whether we have begun placing a non–leading digit\n    ll dp_nozero(int pos, bool tight, bool started) {\n        if (pos == s.size()) {\n            // We count only positive numbers (i.e. that have \"started\")\n            return (started ? 1LL : 0LL);\n        }\n        string key = to_string(pos) + \"_\" + to_string(tight) + \"_\" + to_string(started);\n        if (memo_nozero.find(key) != memo_nozero.end()) return memo_nozero[key];\n        int limit = tight ? (s[pos] - '0') : 9;\n        ll res = 0;\n        // Option 1: if we haven't started, we can “skip” this digit by placing a 0.\n        // (In our DP, choosing 0 when not started does not “start” the number.)\n        if (!started) {\n            // Even if 0 is within the limit, this does NOT count as placing a digit (so no zero digit is introduced)\n            bool nTight = tight && (0 == limit);\n            res += dp_nozero(pos + 1, nTight, false);\n        }\n        // Option 2: Place a nonzero digit (only allowed if the digit is >=1).\n        for (int dig = 1; dig <= limit; dig++) {\n            // Once we place a nonzero digit, we have \"started\" the number.\n            bool nTight = tight && (dig == limit);\n            res += dp_nozero(pos + 1, nTight, true);\n        }\n        memo_nozero[key] = res;\n        return res;\n    }\n\n    // DP to count numbers with NO zero digit that are \"beautiful\"\n    // Parameters:\n    //   pos: current digit index\n    //   tight: whether we are restricted by the prefix of s\n    //   started: whether we have begun the number (i.e. placed a nonzero digit)\n    //   sum: the current digit-sum\n    //   prod: the current digit-product\n    ll dp_beautiful(int pos, bool tight, bool started, int sum, ll prod) {\n        if (pos == s.size()) {\n            // If the number has started, check if product is divisible by sum.\n            if (started && sum != 0)\n                return (prod % sum == 0 ? 1LL : 0LL);\n            return 0LL;\n        }\n        // Build a key from the state.\n        string key = to_string(pos) + \"_\" + to_string(tight) + \"_\" + to_string(started) \n                     + \"_\" + to_string(sum) + \"_\" + to_string(prod);\n        if (memo_beautiful.find(key) != memo_beautiful.end())\n            return memo_beautiful[key];\n        int limit = tight ? (s[pos] - '0') : 9;\n        ll res = 0;\n        if (!started) {\n            // We have not started yet.\n            // Option: skip this digit (i.e. choose 0) to remain not started.\n            if (0 <= limit) {\n                bool nTight = tight && (0 == limit);\n                res += dp_beautiful(pos + 1, nTight, false, 0, 1);\n            }\n            // Option: start the number by choosing a nonzero digit.\n            for (int dig = 1; dig <= limit; dig++) {\n                bool nTight = tight && (dig == limit);\n                res += dp_beautiful(pos + 1, nTight, true, dig, dig);\n            }\n        } else {\n            // The number has already started.\n            // Now we are only allowed to choose digits 1..limit (we cannot use 0 because that would violate the \"no zero digit\" condition).\n            for (int dig = 1; dig <= limit; dig++) {\n                bool nTight = tight && (dig == limit);\n                res += dp_beautiful(pos + 1, nTight, true, sum + dig, prod * dig);\n            }\n        }\n        memo_beautiful[key] = res;\n        return res;\n    }\n\n    // Count beautiful numbers in the range [1, X]\n    // A number is beautiful if either:\n    //   (a) It has at least one zero digit (automatically beautiful), OR\n    //   (b) It has no zero digit and its digit-product is divisible by its digit-sum.\n    ll count_beautiful(int X) {\n        if (X <= 0) return 0LL;\n        s = to_string(X);\n        memo_nozero.clear();\n        memo_beautiful.clear();\n        // Count numbers with no zero digit.\n        ll cnt_nozero = dp_nozero(0, true, false);\n        // Count among these (no–zero numbers) those that are beautiful.\n        ll cnt_beautiful_nozero = dp_beautiful(0, true, false, 0, 1);\n        // The total positive numbers up to X is X.\n        // Hence the numbers that have at least one zero digit are:\n        //      X - (numbers with no zero digit)\n        ll cnt_with_zero = X - cnt_nozero;\n        return cnt_with_zero + cnt_beautiful_nozero;\n    }\n\n    // Main function: returns the count of beautiful numbers in [l, r]\n    int beautifulNumbers(int l, int r) {\n        // Use our helper to count for [1, r] and subtract count for [1, l-1]\n        return (int)(count_beautiful(r) - count_beautiful(l - 1));\n    }\n};\n","author":"Bhavik Joshi","submissionId":"1575226524"},[]]},{"256":[{"id":"256","fileName":"1575226761.txt","sourceCode":"#include <bits/stdc++.h>\n#define ll long long int\n#define FASTIO std::ios::sync_with_stdio(false);\n#define pb push_back\n#define mp make_pair\n#define pi pair <ll,ll>\n#define F first\n#define S second\n#define inf 1e18\n#define pi pair <ll,ll>\n#define g(x) cout<<x<<endl\n#define all(x) x.begin(),x.end()\n#define rall(a) a.rbegin(), a.rend()\n#define input_from_file  freopen(\"input.txt\", \"r\", stdin);\n#define mod 1000000007ll\n#define sz 400005\n#define bitcnt(x) __builtin_popcountll(x)\nusing namespace std;\n\nclass Solution {\npublic:\n    \n    int beautifulNumbers(int l, int r) {\n        map <tuple<int,int,int,int,ll,ll>,ll> dp;\n        map <tuple<int,int,int,int,ll,ll>,ll> dp2;\n        \n        function <int(int,int,int,int,ll,ll,int,map <tuple<int,int,int,int,ll,ll>,ll>&,string &)> calc = [&](int r,int pos,int f,int s,int z,ll sum, ll prod,map <tuple<int,int,int,int,ll,ll>,ll>& dp, string &digits){\n            if(pos == r){\n                if(!s)return 0;\n                if(z)return 1;\n                if(prod % sum== 0)return 1;\n                return 0;\n            }\n            if(dp.find({pos,f,s,z,sum,prod}) != dp.end())return (int)dp[{pos,f,s,z,sum,prod}];\n            int ans = 0;\n            // if(f){\n            ll mx = 9;\n                if(f)\n                    mx = digits[pos] - '0';\n                \n                for(int i=0;i<=mx;i++){\n                    ll nf = f;\n                    if(i<mx){\n                        nf = 0;\n                    }\n                    if(s){\n                        if(i==0){\n                            ans += calc(r,pos+1,nf,s,1,0,0,dp,digits);\n                        }else{\n                            if(z)\n                            ans += calc(r,pos+1,nf,s,z,0,0,dp,digits);\n                            else{\n                                ans += calc(r,pos+1,nf,s,z,sum+i,prod*i,dp,digits);\n                            }\n                        }\n                    }\n                    else {\n                        if(i == 0){\n                            ans += calc(r,pos+1,nf,s,0,0,1,dp,digits);\n                        }else{\n                            ans += calc(r,pos+1,nf,1,0,i,i,dp,digits);\n                        }\n                    }\n                }\n            // }\n\n            dp[{pos,f,s,z,sum,prod}] = ans;\n            return ans;\n            // return 1ll;\n        };\n        string rr = to_string(r);\n        ll ror = rr.length();\n        string lll = to_string(l-1);\n        ll lol = lll.length();\n        int ans = 0;\n        // ll w = calc(ror,0,1,0,0,0,1,dp,rr);\n        // cout << w << endl;\n\n        if(l == 1){\n            ans = calc(ror,0,1,0,0,0,1,dp,rr);\n        }else\n            ans = calc(ror,0,1,0,0,0,1,dp,rr) - calc(lol,0,1,0,0,0,1,dp2,lll);\n        return (int)ans;\n    }\n};","author":"saketw","submissionId":"1575226761"},[]]},{"257":[{"id":"257","fileName":"1575227156.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_up_to(num):\n            s = str(num)\n            n = len(s)\n            from functools import lru_cache\n            \n            @lru_cache(maxsize=None)\n            def dp(pos, tight, started, sm, prod):\n                if pos == n:\n                    if started and sm > 0 and prod % sm == 0:\n                        return 1\n                    return 0\n                res = 0\n                limit = int(s[pos]) if tight else 9\n                for d in range(limit + 1):\n                    ntight = tight and (d == limit)\n                    nstarted = started or (d != 0)\n                    nsm = sm + d if nstarted else sm\n                    nprod = prod * d if nstarted else prod\n                    if not nstarted:\n                        nprod = 1\n                    res += dp(pos + 1, ntight, nstarted, nsm, nprod)\n                return res\n            return dp(0, True, False, 0, 1)\n        if l <= 0:\n            return count_up_to(r)\n        return count_up_to(r) - count_up_to(l - 1)\n","author":"Subhajit Chatterjee","submissionId":"1575227156"},[]]},{"258":[{"id":"258","fileName":"1575226991.txt","sourceCode":"class Solution {\npublic:\n    typedef long long ll;\n    ll helper(int i, bool k, bool j, ll s, ll p, const string& temp,\n        vector<vector<vector<unordered_map<ll, ll>>>>& dp) {\n        if (i == temp.size()) {\n            return !j ? 0 : (s && p % s == 0) ? 1 : 0;\n        }\n\n        int t = k ? 1 : 0, st = j ? 1 : 0;\n        ll hash = (p & (ll)(pow(2, 32) - 1)) | ((ll)s << 32);\n        if (dp[i][t][st].find(hash) != dp[i][t][st].end()) {\n            return dp[i][t][st][hash];\n        }\n\n        ll ans = 0;\n        int mx = k ? temp[i] - '0' : 9;\n        for (ll d = 0, ns = s, np = p; d <= mx; d++, ns = s, np = p) {\n            if (j || (d != 0)) {\n                if (j) {\n                    np *= d;\n                    ns += d;\n                }\n                else {\n                    np = d;\n                    ns = d;\n                }\n            }\n            ans += helper(i + 1, k && (d == mx), j || (d != 0), ns, np, temp, dp);\n        }\n        dp[i][t][st][hash] = ans;\n        return ans;\n    }\n\n    ll count(ll x) {\n        string s = to_string(x);\n        int n = s.size();\n        vector<vector<vector<unordered_map<ll, ll>>>> dp(n, vector<vector<unordered_map<ll, ll>>>(2, vector<unordered_map<ll, ll>>(2)));\n        return helper(0, true, false, 0, 1LL, s, dp);\n    }\n\n    int beautifulNumbers(int l, int r) {\n        return count(r) - count(l - 1);\n    }\n};","author":"Divyansh Saxena","submissionId":"1575226991"},[]]},{"259":[{"id":"259","fileName":"1575226595.txt","sourceCode":"class Solution {\npublic:\n    typedef long long ll;\n    string numStr;\n    unordered_map<ll, ll> memo;\n\n    // Lambda function to calculate the product of prime factors\n   \n    ll dfs(int pos, bool tight, bool started, bool hasZero, int sum, int cnt2, int cnt3, int cnt5, int cnt7) {\n         auto calculateProduct = [](int cnt2, int cnt3, int cnt5, int cnt7) -> int {\n            return pow(2, cnt2) * pow(3, cnt3) * pow(5, cnt5) * pow(7, cnt7);\n        };\n\n        // Lambda function to factorize a digit and update prime counts\n        auto factorizeDigit = [](int digit, int& cnt2, int& cnt3, int& cnt5, int& cnt7) {\n            while (digit % 2 == 0) { cnt2++; digit /= 2; }\n            while (digit % 3 == 0) { cnt3++; digit /= 3; }\n            while (digit % 5 == 0) { cnt5++; digit /= 5; }\n            while (digit % 7 == 0) { cnt7++; digit /= 7; }\n        };\n\n        if (pos == numStr.size()) {\n            if (!started) return 0; // No number formed\n            if (hasZero) return 1; // Number contains zero, valid\n            int product = calculateProduct(cnt2, cnt3, cnt5, cnt7); // Calculate product using lambda\n            return (sum != 0 && product % sum == 0) ? 1LL : 0LL; // Check divisibility\n        }\n\n        // Generate a unique key for memoization\n        ll key = pos;\n        key |= ((ll)tight << 4);\n        key |= ((ll)started << 5);\n        key |= ((ll)hasZero << 6);\n        key |= ((ll)sum << 7);\n        key |= ((ll)cnt2 << (7 + 7));\n        key |= ((ll)cnt3 << (7 + 7 + 6));\n        key |= ((ll)cnt5 << (7 + 7 + 6 + 6));\n        key |= ((ll)cnt7 << (7 + 7 + 6 + 6 + 5));\n\n        if (memo.find(key) != memo.end()) return memo[key]; // Return cached result\n\n        ll result = 0;\n        int limit = tight ? numStr[pos] - '0' : 9; // Determine the digit limit\n\n        for (int digit = 0; digit <= limit; digit++) {\n            bool newTight = tight && (digit == limit); // Update tight flag\n\n            if (!started) {\n                if (digit == 0) {\n                    // Skip leading zeros\n                    result += dfs(pos + 1, newTight, false, false, 0, 0, 0, 0, 0);\n                } else {\n                    // Start forming the number\n                    int newSum = digit;\n                    int newCnt2 = 0, newCnt3 = 0, newCnt5 = 0, newCnt7 = 0;\n                    factorizeDigit(digit, newCnt2, newCnt3, newCnt5, newCnt7); // Factorize using lambda\n                    result += dfs(pos + 1, newTight, true, false, newSum, newCnt2, newCnt3, newCnt5, newCnt7);\n                }\n            } else {\n                if (hasZero) {\n                    // If the number already has a zero, just add the digit to the sum\n                    int newSum = sum + digit;\n                    result += dfs(pos + 1, newTight, true, true, newSum, 0, 0, 0, 0);\n                } else {\n                    if (digit == 0) {\n                        // Add zero to the number\n                        int newSum = sum;\n                        result += dfs(pos + 1, newTight, true, true, newSum, 0, 0, 0, 0);\n                    } else {\n                        // Add non-zero digit and update prime counts\n                        int newSum = sum + digit;\n                        int newCnt2 = cnt2, newCnt3 = cnt3, newCnt5 = cnt5, newCnt7 = cnt7;\n                        factorizeDigit(digit, newCnt2, newCnt3, newCnt5, newCnt7); // Factorize using lambda\n                        result += dfs(pos + 1, newTight, true, false, newSum, newCnt2, newCnt3, newCnt5, newCnt7);\n                    }\n                }\n            }\n        }\n\n        memo[key] = result; // Cache the result\n        return result;\n    }\n\n    ll countBeautifulNumbers(ll x) {\n        if (x < 1) return 0; // Edge case\n        numStr = to_string(x); // Convert number to string\n        memo.clear(); // Clear memoization cache\n        return dfs(0, true, false, false, 0, 0, 0, 0, 0); // Start DFS\n    }\n\n    int beautifulNumbers(int l, int r) {\n        // Calculate the difference between counts for [1, r] and [1, l-1]\n        return (int)(countBeautifulNumbers(r) - countBeautifulNumbers((ll)l - 1));\n    }\n};","author":"7saken","submissionId":"1575226595"},[]]},{"262":[{"id":"262","fileName":"1575227335.txt","sourceCode":"from functools import lru_cache\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_beautiful(n: int) -> int:\n            if n == 0:\n                return 0\n            \n            digits = list(map(int, str(n)))\n            length = len(digits)\n            \n            @lru_cache(None)\n            def dp(pos: int, tight: bool, digit_sum: int, digit_product: int, leading_zero: bool) -> int:\n                if pos == length:\n                    return 1 if digit_sum != 0 and digit_product % digit_sum == 0 else 0\n                \n                limit = digits[pos] if tight else 9\n                res = 0\n                \n                for d in range(0, limit + 1):\n                    new_tight = tight and (d == limit)\n                    new_digit_sum = digit_sum + d\n                    new_digit_product = digit_product * d if d != 0 or not leading_zero else 1\n                    res += dp(pos + 1, new_tight, new_digit_sum, new_digit_product, leading_zero and d == 0)\n                \n                return res\n            \n            return dp(0, True, 0, 1, True)\n        \n        return count_beautiful(r) - count_beautiful(l - 1)\n\n# Example usage:\nsol = Solution()\nprint(sol.beautifulNumbers(10, 20))  # Output: 2\nprint(sol.beautifulNumbers(1, 15))   # Output: 10","author":"Abhyanand Sharma","submissionId":"1575227335"},[]]},{"263":[{"id":"263","fileName":"1575228868.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def solve(n: int) -> int:\n            ns = str(n)\n            @cache\n            def dp(p, t, st, s, pr, ns):\n                if p == len(ns):\n                    return int(st and s != 0 and pr % s == 0)\n                lm = int(ns[p]) if t else 9\n                tot = 0\n                for d in range(lm + 1):\n                    tot += dp(p + 1, t and (d == lm), not (not st and d == 0), s + (0 if (not st and d == 0) else d), pr * (1 if (not st and d == 0) else d), ns)\n                return tot\n            return dp(0, True, False, 0, 1, ns)\n        return solve(r)-solve(l-1)\n","author":"aespa fan","submissionId":"1575228868"},[]]},{"267":[{"id":"267","fileName":"1575229394.txt","sourceCode":"#include<bits/stdc++.h>\nusing namespace std;\n\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\n\n#define MOD 1000000007\n#define MOD1 998244353\n#define INF 1000000000000000000LL\n#define nline cout << \"n\"\n#define pb push_back\n#define ppb pop_back\n#define ff first\n#define ss second\n#define bg begin\n#define lbd lower_bound\n#define ubd upper_bound\n#define pll pair<ll, ll>\n#define PI 3.141592653589793238462\n#define set_bits(x) __builtin_popcountll(x)\n#define sz(x) ((ll)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define TT ll t; cin >> t; while(t--)\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing lld = long double;\n\n#define looping(i, a, b) for (ll i = a; i < (b); i++)\n#define loop(i, a) for (ll i = 0; i < (a); i++)\n#define loopingd(i, a, b) for (ll i = (b) - 1; i >= a; i--)\n#define loopd(i, a) for (ll i = (a) - 1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n//------------------------------Debug---------------------------------------------------------------------//\n\n#ifndef ONLINE_JUDGE\n#define debug(x) cerr << #x <<\" \"; _print(x); cerr << endl;\n#else\n#define debug(x)\n#endif\n\nvoid _print(ll t) {cerr << t;}\nvoid _print(int t) {cerr << t;}\nvoid _print(string t) {cerr << t;}\nvoid _print(char t) {cerr << t;}\nvoid _print(lld t) {cerr << t;}\nvoid _print(double t) {cerr << t;}\nvoid _print(ull t) {cerr << t;}\n\ntemplate <class T, class V> void _print(pair <T, V> p);\ntemplate <class T> void _print(vector <T> v);\ntemplate <class T> void _print(set <T> v);\ntemplate <class T, class V> void _print(map <T, V> v);\ntemplate <class T> void _print(multiset <T> v);\ntemplate <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.ff); cerr << \",\"; _print(p.ss); cerr << \"}\";}\ntemplate <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\ntemplate <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\ntemplate <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\ntemplate <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\n\n// -------------------------------------------------------------------------------------------------------//\n\ntemplate <typename T> void read(T& t) { cin >> t; }\ntemplate <typename T, typename... Args> void read(T& t, Args&... args) { read(t); read(args...); }\ntemplate <typename T> void read(vector<T>& vec) { for (auto& element : vec) { cin >> element; } }\ntemplate <typename T> void print(const T& t) { cout << t << \" \"; }\ntemplate <typename T> void prints(const T& t) { cout << t; }\ntemplate <typename T, typename... Args> void print(const T& t, const Args&... args) { print(t); print(args...); }\ntemplate <typename T, typename... Args> void prints(const T& t, const Args&... args) { prints(t); print(args...); }\ntemplate <typename T> void print(const vector<T>& vec) { for (const auto& element : vec) { cout << element << \" \"; } cout << \"n\"; }\ntemplate<class T> using oset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n// -------------------------------------------------------------------------------------------------------//\n\nconst ll dx[] = {0, 0, 1, -1};\nconst ll dy[] = {1, -1, 0, 0};\nll mod_power(ll a, ll b, ll m) { ll ans = 1; while (b) { if (b & 1) ans = ans * a % m; a = a * a % m; b >>= 1; } return ans; }\nll gcd (ll a, ll b) {  return b ? gcd (b, a % b) : a;  }\nll lcm (ll a, ll b) {  return (a * b) / gcd(a, b); }\nll mod_inv(ll x) { return mod_power(x, MOD - 2, MOD) % MOD; }\nll mod_mul(ll a, ll b) { return ((a % MOD) * (b % MOD) % MOD) % MOD; }\nll mod_div(ll a, ll b) { return mod_mul(a, mod_inv(b)) % MOD; }\nll mod_add(ll a, ll b) { return ((a % MOD) + (b % MOD)) % MOD; }\nll mod_sub(ll a, ll b) { return ((a % MOD) - (b % MOD) + MOD) % MOD; }\nbool isprime(ll n) { for (ll i = 2; i * i <= n; ++i) { if (n % i == 0) { return false; } } return true; }\ntemplate <typename T> void chkmn(T &x, T y) { x = min(x, y); }\ntemplate <typename T> void chkmx(T &x, T y) { x = max(x, y); }\n\n//--------------------------------------------------------------------------------------------------------//\n\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        \n        auto helper = [&](ll num) -> ll {\n            string str = to_string(num);\n            ll n = sz(str);\n            map<tuple<ll, ll, ll, ll, ll>, ll> dp;\n            dp[{1, 0, 0, 0, 1}] = 1;\n            loop(pos, n) {\n                map<tuple<ll, ll, ll, ll, ll>, ll> next_dp;\n                trav(u, dp) {\n                    auto [a, b, c, p, q] = u.ff;\n\n                    ll dig = a ? (str[pos] - '0') : 9;\n                    loop(d, dig + 1) {\n                        ll aa = (a && (d == dig));\n                        ll bb = b;\n                        ll cc = c;\n                        ll pp = p;\n                        ll qq = q;\n\n                        if (!b) {\n                            if (d == 0) {\n                                bb = 0;\n                                cc = 0;\n                                pp = 0;\n                                qq = 1;\n                            } else {\n                                bb = 1;\n                                cc = 0;\n                                pp = d;\n                                qq = d;\n                            }\n                        } else {\n                            pp += d;\n                            if (d == 0) {\n                                cc = 1;\n                                qq = 0;\n                            } else {\n                                qq *= d;\n                            }\n                        }\n\n                        next_dp[{aa, bb, cc, pp, qq}] += u.ss;\n                    }\n                }\n                dp = next_dp;\n            }\n\n            ll ans = 0;\n            trav(u, dp) {\n                auto [a, b, c, p, q] = u.ff;\n                if (b) {\n                    if (c) {\n                        ans += u.ss;\n                    } else {\n                        if (p != 0 and q % p == 0) {\n                            ans += u.ss;\n                        }\n                    }\n                }\n            }\n            return ans;\n        };\n        \n        ll rb = helper(r);\n        if(l <= 1) {\n            ll ans = helper(r);\n            return ans;\n        }\n        \n        ll lb = helper(l - 1);\n        return rb - lb;\n    }\n};","author":"Amit Yadav","submissionId":"1575229394"},[]]},{"269":[{"id":"269","fileName":"1575230297.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        MOD = 10 ** 9 + 7\n        \n        @cache\n        def dp(cur_sum, cur_prod, digit_loc, isNum, isLimit, max_num):\n            if digit_loc == len(max_num):\n                return 1 if isNum and cur_sum > 0 and cur_prod % cur_sum == 0 else 0\n            subAns = 0\n            up = int(max_num[digit_loc]) if isLimit else 9\n            low = 0 if isNum else 1\n            if not isNum:\n                subAns += dp(0, 1, digit_loc + 1, False, False, max_num)\n            for i in range(low, up + 1):\n                subAns += dp(cur_sum + i, cur_prod * i, digit_loc + 1, True, isLimit and i == up, max_num)\n            return subAns % MOD\n        return (dp(0, 1, 0, False, True, str(r)) - dp(0, 1, 0, False, True, str(l - 1))) % MOD","author":"Andy Gao","submissionId":"1575230297"},[]]},{"270":[{"id":"270","fileName":"1575231497.txt","sourceCode":"class Solution {\npublic:\n    int dp[10][82][82][2][2];\n    vector<int> digits;\n\n    int digitDP(int pos, int currSum, int currProd, int tight, int targetSum, int leadingZero) {\n        if (pos == digits.size()) {\n            return (!leadingZero && currSum == targetSum && currProd % targetSum == 0) ? 1 : 0;\n        }\n        if (dp[pos][currSum][currProd][tight][leadingZero] != -1) return dp[pos][currSum][currProd][tight][leadingZero];\n\n        int limit = tight ? digits[pos] : 9, res = 0;\n        for (int d = 0; d <= limit; ++d) {\n            int newTight = (tight && d == limit);\n            int newLeadingZero = (leadingZero && d == 0);\n            int newSum = currSum, newProd = currProd;\n            if (!newLeadingZero) {\n                newSum += d;\n                if (newSum > targetSum) continue;\n                newProd = (currProd * d) % targetSum;\n            }\n            res += digitDP(pos + 1, newSum, newProd, newTight, targetSum, newLeadingZero);\n        }\n        return dp[pos][currSum][currProd][tight][leadingZero] = res;\n    }\n\n    int countBeautiful(int n) {\n        if (n == 0) return 0;\n        digits.clear();\n        while (n) {\n            digits.push_back(n % 10);\n            n /= 10;\n        }\n        reverse(digits.begin(), digits.end());\n        int total = 0;\n        for (int sum = 1; sum <= 81; ++sum) {\n            memset(dp, -1, sizeof(dp));\n            total += digitDP(0, 0, 1, 1, sum, 1);\n        }\n        return total;\n    }\n\n    int beautifulNumbers(int l, int r) {\n        return countBeautiful(r) - countBeautiful(l - 1);\n    }\n};\n","author":"Anupam Ghosh","submissionId":"1575231497"},[]]},{"271":[{"id":"271","fileName":"1575229155.txt","sourceCode":"class Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        if (l > 1) return beautifulNumbers(1, r) - beautifulNumbers(1, l - 1);\n        if (r <= 10) return r;\n        pastri = PascalTriangle(9);\n        int ans = 0;\n        string sr = to_string(r);\n        int len = sr.length();\n        for (int i = 1; i < len; ++i) {\n            ans += count(i, 1, 0, false);\n        }\n        int p = 1, s = 0;\n        for (int i = 0; i < len; ++i) {\n            int digit = sr[i] - '0';\n            for (int j = (i == 0 ? 1 : 0); j <= (i == len - 1 ? digit : digit - 1); ++j) {\n                ans += count(len - i - 1, p * j, s + j, true);\n            }\n            p *= digit;\n            s += digit;\n        }\n        return ans;\n    }\nprivate:\n    vector<vector<int>> pastri;\n    \n    vector<vector<int>> PascalTriangle(int n) {\n        vector<vector<int>> pascal_triangle;\n        vector<int> row;\n        for (int i = 0; i <= n; ++i) {\n            row.push_back(1);\n            for (int j = i - 1; j > 0; --j) {\n                row[j] = row[j - 1] + row[j];\n            }\n            pascal_triangle.push_back(row);\n        }\n        return pascal_triangle;\n    }\n    \n    vector<vector<int>> cnts;\n    \n    void recursion(int d, int max_cnt, vector<int>& cnt) {\n        if (d == 9) {\n            cnt[9] = max_cnt;\n            cnts.push_back(cnt);\n        } else {\n            for (int i = 0; i <= max_cnt; ++i) {\n                cnt[d] = i;\n                recursion(d + 1, max_cnt - i, cnt);\n            }\n        }\n    }\n    \n    int getNumPermutations(int len, const vector<int>& cnt) {\n        int ret = 1;\n        for (int i = 0; i < 10; ++i) {\n            ret *= pastri[len][cnt[i]];\n            len -= cnt[i];\n        }\n        return ret;\n    }\n    \n    int count(int len, int product, int sum, bool lzero) {\n        int ret = 0;\n        if (len == 0) {\n            ret = product % sum == 0 ? 1 : 0;\n        } else {\n            cnts.clear();\n            vector<int> tcnt(10);\n            recursion(0, len, tcnt);\n            for (vector<int>& cnt : cnts) {\n                int extra_product = 1, extra_sum = 0;\n                for (int i = 0; i < 10; ++i) {\n                    for (int j = 0; j < cnt[i]; ++j) {\n                        extra_product *= i;\n                        extra_sum += i;\n                    }\n                }\n                if (sum + extra_sum == 0 || (product * extra_product) % (sum + extra_sum) != 0) continue;\n                ret += getNumPermutations(len, cnt);\n                if (!lzero && cnt[0] > 0) {\n                    --cnt[0];\n                    ret -= getNumPermutations(len - 1, cnt);\n                }\n            }\n        }\n        return ret;\n    }\n};","author":"JeffreyLC","submissionId":"1575229155"},[]]},{"272":[{"id":"272","fileName":"1575231386.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def is_beautiful(num):\n            digits = [int(d) for d in str(num)]\n            sum_digits = sum(digits)\n            product_digits = 1\n            for d in digits:\n                product_digits *= d\n            return sum_digits != 0 and product_digits % sum_digits == 0\n\n        def count_up_to(n):\n            s = str(n)\n            length = len(s)\n            from functools import lru_cache\n    \n            @lru_cache(maxsize=None)\n            def dp(pos, tight, sum_digits, product_digits, has_started):\n                if pos == length:\n                    return int(has_started and sum_digits != 0 and product_digits % sum_digits == 0)\n                \n                limit = int(s[pos]) if tight else 9\n                total = 0\n                \n                for digit in range(0, limit + 1):\n                    new_tight = tight and (digit == limit)\n                    new_sum = sum_digits + digit\n                    new_product = product_digits * digit if has_started or digit != 0 else 1\n                    new_has_started = has_started or (digit != 0)\n                    \n                    total += dp(pos + 1, new_tight, new_sum, new_product, new_has_started)\n                \n                return total\n            \n            return dp(0, True, 0, 1, False)\n        \n        return count_up_to(r) - count_up_to(l - 1)","author":"PRIYANKA","submissionId":"1575231386"},[]]},{"273":[{"id":"273","fileName":"1575230381.txt","sourceCode":"from functools import lru_cache\n\nclass Solution:\n    def countBeautiful(self, x: int) -> int:\n        if x < 1:\n            return 0\n        \n        s = str(x)\n\n        @lru_cache(None)\n        def rec(pos, tight, started, hasZero, sum_, e2, e3, e5, e7):\n            if pos == len(s):\n                if not started:\n                    return 0\n                if hasZero:\n                    return 1\n                prod = (2 ** e2) * (3 ** e3) * (5 ** e5) * (7 ** e7)\n                return 1 if sum_ != 0 and prod % sum_ == 0 else 0\n\n            res = 0\n            limit = int(s[pos]) if tight else 9\n            \n            for d in range(limit + 1):\n                ntight = tight and (d == limit)\n                if not started:\n                    if d == 0:\n                        res += rec(pos + 1, ntight, 0, 0, 0, 0, 0, 0, 0)\n                    else:\n                        new_e2, new_e3, new_e5, new_e7 = 0, 0, 0, 0\n                        temp = d\n                        while temp % 2 == 0:\n                            new_e2 += 1\n                            temp //= 2\n                        while temp % 3 == 0:\n                            new_e3 += 1\n                            temp //= 3\n                        while temp % 5 == 0:\n                            new_e5 += 1\n                            temp //= 5\n                        while temp % 7 == 0:\n                            new_e7 += 1\n                            temp //= 7\n                        res += rec(pos + 1, ntight, 1, 0, d, new_e2, new_e3, new_e5, new_e7)\n                else:\n                    if hasZero:\n                        res += rec(pos + 1, ntight, 1, 1, sum_ + d, 0, 0, 0, 0)\n                    else:\n                        if d == 0:\n                            res += rec(pos + 1, ntight, 1, 1, sum_, 0, 0, 0, 0)\n                        else:\n                            new_e2, new_e3, new_e5, new_e7 = e2, e3, e5, e7\n                            temp = d\n                            while temp % 2 == 0:\n                                new_e2 += 1\n                                temp //= 2\n                            while temp % 3 == 0:\n                                new_e3 += 1\n                                temp //= 3\n                            while temp % 5 == 0:\n                                new_e5 += 1\n                                temp //= 5\n                            while temp % 7 == 0:\n                                new_e7 += 1\n                                temp //= 7\n                            res += rec(pos + 1, ntight, 1, 0, sum_ + d, new_e2, new_e3, new_e5, new_e7)\n\n            return res\n\n        return rec(0, 1, 0, 0, 0, 0, 0, 0, 0)\n\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return self.countBeautiful(r) - self.countBeautiful(l - 1)\n","author":"CHEEMALADINNE YASWANTH","submissionId":"1575230381"},[]]},{"274":[{"id":"274","fileName":"1575232603.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int beautifulNumbers(int l, int r) {\n        return countBeautiful(r) - countBeautiful(l - 1);\n    }\n    \n    // Returns the count of beautiful numbers in [1, x]. (0 is not counted.)\n    private int countBeautiful(int x) {\n        if (x < 1) return 0;\n        char[] digits = String.valueOf(x).toCharArray();\n        Map<State, Integer> memo = new HashMap<>();\n        return dp(digits, 0, true, false, 0, 1L, memo);\n    }\n    \n    // DP function: returns count of beautiful numbers for current state.\n    // Parameters:\n    //  digits: digit array of the upper bound number\n    //  pos: current position in digits array\n    //  tight: true if digits chosen so far are on the prefix of x\n    //  started: true if we have already picked a non-zero digit\n    //  sum: sum of digits chosen so far\n    //  prod: product of digits chosen so far (if not started, prod is 1)\n    private int dp(char[] digits, int pos, boolean tight, boolean started, int sum, long prod, Map<State, Integer> memo) {\n        if (pos == digits.length) {\n            // Only count numbers that have started (exclude the '0' number).\n            if (!started) return 0;\n            // Guard: if for some reason sum is 0 (shouldn't happen as started==true implies at least one nonzero digit)\n            if (sum == 0) return 0;\n            return (prod % sum == 0) ? 1 : 0;\n        }\n        \n        State key = new State(pos, tight, started, sum, prod);\n        if (memo.containsKey(key)) return memo.get(key);\n        \n        int res = 0;\n        int limit = tight ? digits[pos] - '0' : 9;\n        \n        for (int d = 0; d <= limit; d++) {\n            boolean ntight = tight && (d == limit);\n            boolean nstarted = started || (d != 0);\n            int nsum = nstarted ? sum + d : sum; \n            // If we haven't started, prod remains 1; otherwise update (note: if d==0 then nprod becomes 0).\n            long nprod = nstarted ? prod * d : prod;\n            res += dp(digits, pos + 1, ntight, nstarted, nsum, nprod, memo);\n        }\n        \n        memo.put(key, res);\n        return res;\n    }\n    \n    // Helper class representing the DP state.\n    private static class State {\n        int pos;\n        boolean tight;\n        boolean started;\n        int sum;\n        long prod;\n        \n        public State(int pos, boolean tight, boolean started, int sum, long prod) {\n            this.pos = pos;\n            this.tight = tight;\n            this.started = started;\n            this.sum = sum;\n            this.prod = prod;\n        }\n        \n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (!(o instanceof State)) return false;\n            State state = (State) o;\n            return pos == state.pos && tight == state.tight && started == state.started &&\n                   sum == state.sum && prod == state.prod;\n        }\n        \n        @Override\n        public int hashCode() {\n            return Objects.hash(pos, tight, started, sum, prod);\n        }\n    }\n}","author":"Abhinav","submissionId":"1575232603"},[]]},{"275":[{"id":"275","fileName":"1575231840.txt","sourceCode":"from functools import lru_cache\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        # Returns count of beautiful numbers in [l, r]\n        return self.count_beautiful(r) - self.count_beautiful(l - 1)\n    \n    def count_beautiful(self, x: int) -> int:\n        # Count numbers in [1, x] (we exclude 0 as not positive)\n        if x < 1:\n            return 0\n        \n        digits = list(map(int, str(x)))\n        n = len(digits)\n        \n        # Precompute prime factorization for digits 1..9.\n        # For convenience, represent digit d as (f2, f3, f5, f7).\n        fact = {\n            1: (0,0,0,0),\n            2: (1,0,0,0),\n            3: (0,1,0,0),\n            4: (2,0,0,0),   # 2^2\n            5: (0,0,1,0),\n            6: (1,1,0,0),   # 2 * 3\n            7: (0,0,0,1),\n            8: (3,0,0,0),   # 2^3\n            9: (0,2,0,0)    # 3^2\n        }\n        \n        @lru_cache(maxsize=None)\n        def dp(pos, tight, started, s, zero, a, b, c, d):\n            \"\"\"\n            pos: current digit position [0..n]\n            tight: 0 or 1, whether the prefix equals the prefix of x.\n            started: 0 or 1, whether we have started picking a nonzero digit.\n            s: current sum of digits (0 <= s <= 90)\n            zero: 0 or 1, True if we have used a zero digit (after starting)\n            a, b, c, d: current exponents for primes 2,3,5,7 (if not in zero state)\n            \"\"\"\n            if pos == n:\n                # At the end, if we haven't started, it's not a valid positive number.\n                if not started:\n                    return 0\n                # If the number has been formed, then s > 0.\n                # If we've encountered a zero digit (non-leading) then product=0.\n                if zero:\n                    # 0 mod s == 0 (as long as s>0)\n                    return 1\n                else:\n                    # Compute product mod s using the stored exponents.\n                    prod_mod = (pow(2, a, s) * pow(3, b, s)) % s\n                    prod_mod = (prod_mod * pow(5, c, s)) % s\n                    prod_mod = (prod_mod * pow(7, d, s)) % s\n                    return 1 if prod_mod % s == 0 else 0\n            \n            total = 0\n            lim = digits[pos] if tight else 9\n            for dig in range(0, lim+1):\n                new_tight = tight and (dig == lim)\n                if not started:\n                    if dig == 0:\n                        # still haven't started\n                        total += dp(pos+1, new_tight, False, 0, 0, 0, 0, 0, 0)\n                    else:\n                        # starting the number with a nonzero digit\n                        new_s = dig\n                        if dig == 0:\n                            # This case won't happen because dig != 0 here.\n                            total += dp(pos+1, new_tight, True, new_s, 1, 0, 0, 0, 0)\n                        else:\n                            f2, f3, f5, f7 = fact[dig]\n                            total += dp(pos+1, new_tight, True, new_s, 0, f2, f3, f5, f7)\n                else:\n                    # already started\n                    new_s = s + dig\n                    if dig == 0:\n                        # If we hit a zero, product becomes 0.\n                        total += dp(pos+1, new_tight, True, new_s, 1, 0, 0, 0, 0)\n                    else:\n                        if zero:\n                            # once product is 0, it stays 0.\n                            total += dp(pos+1, new_tight, True, new_s, 1, 0, 0, 0, 0)\n                        else:\n                            f2, f3, f5, f7 = fact[dig]\n                            total += dp(pos+1, new_tight, True, new_s, 0, a + f2, b + f3, c + f5, d + f7)\n            return total\n        \n        return dp(0, True, False, 0, 0, 0, 0, 0, 0)\n        \n\n# Testing with the provided examples:\n# sol = Solution()\n# print(sol.beautifulNumbers(10, 20))  # Expected output: 2 (10 and 20)\n# print(sol.beautifulNumbers(1, 15))   # Expected output: 10\n","author":"Siva Sankar Reddy Asam","submissionId":"1575231840"},[]]},{"276":[{"id":"276","fileName":"1575232398.txt","sourceCode":" #include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    unordered_map<int, int> dp[10][82][2];\n\n    int countBeautiful(int pos, int sum, int prod, int done, string& num, bool strt) {\n        if (pos == num.size()) {\n            return (sum != 0 && prod % sum == 0); \n        }\n        if (dp[pos][sum][done].count(prod)) return dp[pos][sum][done][prod];\n\n        int limit = done ? (num[pos] - '0') : 9;\n        int res = 0;\n\n        for (int d = 0; d <= limit; d++) {\n            bool newstrt = strt || (d > 0);\n            int newprod = (strt ? (prod * d) : d); \n            if (!newstrt) newprod = 1; \n            res += countBeautiful(pos + 1, sum + d, newprod, done & (d == limit), num, newstrt);\n        }\n\n        return dp[pos][sum][done][prod] = res;\n    }\n\n    int solve(int x) {\n        string num = to_string(x);\n        for (int i = 0; i < 10; i++)\n            for (int j = 0; j < 82; j++)\n                for (int k = 0; k < 2; k++)\n                    dp[i][j][k].clear(); \n        return countBeautiful(0, 0, 1, 1, num, false);\n    }\n            int beautifulNumbers(int l, int r) {\n                return solve(r) - (l-1==0?0:solve(l - 1));\n            }\n        };","author":"Ankush Gaurav","submissionId":"1575232398"},[]]},{"277":[{"id":"277","fileName":"1575231643.txt","sourceCode":"var beautifulNumbers = function(l, r) {\n    function countBeautiful(upper) {\n        let total = 0\n        for (let sum = 1; sum <= 81; sum++) {\n            total += countBeautifulSum(upper, sum)\n        }\n        return total\n    }\n    function countBeautifulSum(upper, DSUM) {\n        const digits = getDigits(upper);\n        const n = digits.length;\n        const memo = new Map();\n        \n        const dp = (pos, tight, sum, product, leading) => {\n            if (sum > DSUM) return 0\n            if (pos === n) {\n                return (sum === DSUM && product % sum === 0) ? 1 : 0;\n            }\n            \n            const key = +leading + product * 10 + sum * 1e3 + tight * 1e5 + pos * 1e6;\n            if (memo.has(key)) return memo.get(key);\n            \n            let count = leading ? dp(pos + 1, false, sum, product, true) : 0;\n            const lo = leading ? 1 : 0;\n            const hi = tight ? digits[pos] : 9;\n            \n            for (let d = lo; d <= hi; d++) {\n                const newSum = sum + d;\n                const newProduct = product * d % DSUM;\n                const newTight = tight && (d === digits[pos]);\n                count += dp(pos + 1, newTight, newSum, newProduct, false);\n            }\n            \n            memo.set(key, count);\n            return count;\n        };\n        // console.log(`countBeaultifulSum(${upper}, ${DSUM}): ${dp(0, true, 0, 1, true)}`)\n        return dp(0, true, 0, 1, true);\n    };\n    return countBeautiful(r) - countBeautiful(l - 1);\n};\n\n\nfunction getDigits(num) {\n    const digits = [];\n    while (num > 0) {\n        digits.unshift(num % 10);\n        num = Math.floor(num / 10);\n    }\n    return digits.length > 0 ? digits : [0];\n}","author":"Harttle","submissionId":"1575231643"},[]]},{"278":[{"id":"278","fileName":"1575232919.txt","sourceCode":"class Solution {\n    private Map<String, Long> memo;\n    private char[] digits;\n    \n    private long dp(int pos, boolean tight, boolean started, boolean hasZero, int sum, int product) {\n        if (pos == digits.length) {\n            if (!started) return 0;\n            if (hasZero) return 1;\n            return (sum != 0 && product % sum == 0) ? 1 : 0;\n        }\n        \n        String key = pos + \"_\" + tight + \"_\" + started + \"_\" + hasZero + \"_\" + sum + \"_\" + product;\n        if (memo.containsKey(key))\n            return memo.get(key);\n        \n        long count = 0;\n        int limit = tight ? digits[pos] - '0' : 9;\n        \n        for (int d = 0; d <= limit; d++) {\n            boolean newTight = tight && (d == limit);\n            boolean newStarted = started || (d != 0);\n            boolean newHasZero = hasZero;\n            int newSum = sum;\n            int newProduct = product;\n            \n            if (!newStarted) {\n                newSum = 0;\n                newProduct = 1;\n            } else {\n                newSum = sum + d;\n                if (hasZero || d == 0) {\n                    newHasZero = true;\n                    newProduct = 0;\n                } else {\n                    if (!started) {\n                        newProduct = d;\n                    } else {\n                        newProduct = product * d;\n                    }\n                }\n            }\n            \n            count += dp(pos + 1, newTight, newStarted, newHasZero, newSum, newProduct);\n        }\n        \n        memo.put(key, count);\n        return count;\n    }\n    \n    private long countBeautiful(String num) {\n        digits = num.toCharArray();\n        memo = new HashMap<>();\n        return dp(0, true, false, false, 0, 1);\n    }\n    \n    public int beautifulNumbers(int l, int r) {\n        long countR = countBeautiful(String.valueOf(r));\n        long countL = countBeautiful(String.valueOf(l - 1));\n        return (int)(countR - countL);\n    }\n}","author":"tmimotw","submissionId":"1575232919"},[]]},{"279":[{"id":"279","fileName":"1575232966.txt","sourceCode":"#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n//#include <atcoder/all>\n//using mint = atcoder::modint998244353;\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<class key, class cmp = std::less<key>>\nusing ordered_set = tree<key, null_type, cmp, rb_tree_tag,tree_order_statistics_node_update>;\ntemplate<class key, class value, class cmp = std::less<key>>\nusing ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;\n\nusing lint = long long;\nusing ii = pair<int, int>;\nusing il = pair<int, lint>;\nusing li = pair<lint, int>;\nusing ll = pair<lint, lint>;\n\nconst int mxn = 1000100, mxp = 1000001;\nconst int MOD = 998244353, inf = -1e9 - 7, INF = 1e9 + 1;\nconst lint lnf = -4e18, LNF = 5e18;\nconst double eps = 1e-10;\nconst int sqrtN = 200;\n\n#define sz(x) int(size(x))\n#define all(x) (x).begin(),(x).end()\n#define compress(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())\n#define lb(x, v) (lower_bound(all(x), v) - (x).begin())\n#define ub(x, v) (upper_bound(all(x), v) - (x).begin())\n#define eb emplace_back\n#define pb push_back\n#define getName(var)  #var\nvector<lint> xl, yl;\n\n#define Yes \"Yesn\"\n#define No \"Non\"\n\nconst int dr[] = {-1, 0, 1, 0};\nconst int dc[] = {0, -1, 0, 1};\n\ninline int inRange(int r, int c, int R, int C) {\n    return 0 <= r && r < R && 0 <= c && c < C;\n}\n\nlint N, M, Q, R, C, H, K, T;\n\nvoid init() {\n\n}\n\nclass Solution {\npublic:\n    vector<int> digits;\n    unordered_map<lint,lint> d2[11][90][2][2]; // pos, sum,\n    int beautifulNumbers(int l, int r) {\n        auto init = [&]() {\n            for(auto&x: d2) {\n                for(auto&y: x){\n                    for(auto&z: y) {\n                        for(auto &w: z) w.clear();\n                    }\n                }\n            }\n            digits.clear();\n        };\n\n        auto g = [&](lint x) {\n            init();\n            string s = to_string(x);\n            for(auto&c: s) digits.eb(c - '0');\n            return f(0,0,1,1,0);\n        };\n\n        return (int)(g(r) - g(l - 1));\n    }\n    lint f(int pos, int sm, int prod, int fit, int nonZ) {\n        if (pos == sz(digits)) {\n            if (!nonZ) return 0;\n            return ((sm > 0 && prod % sm == 0)? 1 :0);\n        }\n        auto &mp = d2[pos][sm][fit][nonZ];\n\n        if(mp.find(prod) != end(mp)) {\n            return mp[prod];\n        }\n\n        lint &ret = mp[prod];\n        ret = 0;\n\n        int lim = (fit ? digits[pos]:9);\n        for (int dig = 0; dig <= lim; dig++) {\n            int nFit = (fit && (dig == lim)) ? 1 : 0;\n            int nInit = nonZ, ns = sm, nProd = prod;\n            if (!nonZ) {\n                if (dig != 0) {\n                    nInit = 1;\n                    ns = dig;\n                    nProd = dig;\n                }\n            } else {\n                ns = sm + dig;\n                nProd = prod * dig;\n            }\n            ret += f(pos + 1, ns, nProd, nFit, nInit);\n        }\n\n        return ret;\n    }\n};\n\nvoid solve() {\n    int l, r; cin >> l >> r;\n    Solution solution;\n    cout << solution.beautifulNumbers(l,r);\n}\n\n// int main() {\n// #ifndef ONLINE_JUDGE\n//     freopen(\"input.txt\", \"r\", stdin);\n// #endif\n//     ios_base::sync_with_stdio(false);\n//     cin.tie(nullptr);\n//     cout.tie(nullptr);\n//     int TC = 1;\n// //    cin >> TC;\n//     while (TC--) {\n//         init();\n//         solve();\n//     }\n\n//     return 0;\n// }\n","author":"raararaara","submissionId":"1575232966"},[]]},{"282":[{"id":"282","fileName":"1575233269.txt","sourceCode":"\"\"\"\nl = 1 , r = 99\n\n18 \n\"\"\"\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_beautiful(n: int) -> int:\n            if n == 0:\n                return 0  # No valid numbers below 1\n            \n            digits = list(map(int, str(n)))  # Convert number to a digit array\n            \n            @lru_cache(None)\n            def dp(pos: int, sum_digits: int, product_digits: int, tight: bool, leading_zero: bool) -> int:\n                if pos == len(digits):  \n                    return 1 if sum_digits > 0 and product_digits % sum_digits == 0 else 0\n\n                limit = digits[pos] if tight else 9  # If tight, respect digit limit\n                result = 0\n\n                for digit in range(0, limit + 1):\n                    new_product = product_digits * digit if digit != 0 or not leading_zero else 1  # Avoid zero multiplication issue\n                    result += dp(\n                        pos + 1,\n                        sum_digits + digit,\n                        new_product,\n                        tight and (digit == limit),\n                        leading_zero and (digit == 0)\n                    )\n                return result\n\n            return dp(0, 0, 1, True, True)  # Start recursion\n        \n        return count_beautiful(r) - count_beautiful(l - 1)\n\n","author":"codergod999","submissionId":"1575233269"},[]]},{"283":[{"id":"283","fileName":"1575233628.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_beautiful(X: int) -> int:\n            if X <= 0:\n                return 0\n            s = str(X)\n            n = len(s)\n            digits = list(map(int, s))\n            fac = {\n                1: (0, 0, 0, 0),\n                2: (1, 0, 0, 0),\n                3: (0, 1, 0, 0),\n                4: (2, 0, 0, 0),\n                5: (0, 0, 1, 0),\n                6: (1, 1, 0, 0),\n                7: (0, 0, 0, 1),\n                8: (3, 0, 0, 0),\n                9: (0, 2, 0, 0)\n            }\n            from functools import lru_cache\n            @lru_cache(maxsize=None)\n            def dp_completed(pos: int, tight: bool) -> int:\n                if pos == n:\n                    return 1\n                if not tight:\n                    return 10 ** (n - pos)\n                limit = digits[pos]\n                res = 0\n                for dgt in range(0, limit + 1):\n                    new_tight = tight and (dgt == limit)\n                    res += dp_completed(pos + 1, new_tight)\n                return res\n            @lru_cache(maxsize=None)\n            def dp(pos: int, tight: bool, started: bool, zero_enc: bool, curr_sum: int, a: int, b: int, c: int, d: int) -> int:\n                if pos == n:\n                    if not started:\n                        return 0\n                    if zero_enc:\n                        return 1\n                    prod = (2 ** a) * (3 ** b) * (5 ** c) * (7 ** d)\n                    return 1 if (curr_sum != 0 and prod % curr_sum == 0) else 0\n                if started and zero_enc and not tight:\n                    return 10 ** (n - pos)\n                res = 0\n                limit = digits[pos] if tight else 9\n                for dgt in range(0, limit + 1):\n                    new_tight = tight and (dgt == limit)\n                    if not started:\n                        if dgt == 0:\n                            res += dp(pos + 1, new_tight, False, False, 0, 0, 0, 0, 0)\n                        else:\n                            fa, fb, fc, fd = fac[dgt]\n                            res += dp(pos + 1, new_tight, True, False, dgt, fa, fb, fc, fd)\n                    else:\n                        if zero_enc:\n                            res += dp(pos + 1, new_tight, True, True, 0, 0, 0, 0, 0)\n                        else:\n                            if dgt == 0:\n                                res += dp(pos + 1, new_tight, True, True, 0, 0, 0, 0, 0)\n                            else:\n                                new_sum = curr_sum + dgt\n                                fa, fb, fc, fd = fac[dgt]\n                                res += dp(pos + 1, new_tight, True, False, new_sum, a + fa, b + fb, c + fc, d + fd)\n                return res\n            return dp(0, True, False, False, 0, 0, 0, 0, 0)\n        return count_beautiful(r) - count_beautiful(l - 1)\n","author":"泰甯 廖","submissionId":"1575233628"},[]]},{"284":[{"id":"284","fileName":"1575234179.txt","sourceCode":"from functools import lru_cache\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        @lru_cache(None)\n        def dp(pos, tight, digit_sum, digit_product, N, leading_zero):\n            digits = list(map(int, str(N)))\n            if pos == len(digits):\n                return 1 if digit_sum > 0 and digit_product % digit_sum == 0 else 0\n\n            limit = digits[pos] if tight else 9\n            count = 0\n\n            for d in range(0, limit + 1):\n                new_tight = tight and (d == limit)\n                new_sum = digit_sum + d\n                new_product = digit_product * d if not leading_zero or d > 0 else digit_product\n                count += dp(pos + 1, new_tight, new_sum, new_product, N, leading_zero and d == 0)\n\n            return count\n\n        return dp(0, True, 0, 1, r, True) - dp(0, True, 0, 1, l-1, True)","author":"gambler147","submissionId":"1575234179"},[]]},{"285":[{"id":"285","fileName":"1575233294.txt","sourceCode":"function beautifulNumbers(L, R) {\n  if (L > R) return 0;\n  return countBeautiful(R) - countBeautiful(L - 1);\n}\n\nfunction countBeautiful(x) {\n  if (x < 1) return 0;\n  let total = x;\n  let noZero = countNoZero(x);\n  let noZeroDiv = countNoZeroDivisible(x);\n  return total - noZero + noZeroDiv;\n}\n\nfunction countNoZero(x) {\n  if (x < 1) return 0;\n  let d = getDigits(x);\n  let n = d.length;\n  const DP_SIZE = (n + 1) * 2 * 2;\n  let dp = new Int32Array(DP_SIZE).fill(-1);\n\n  function idx(pos, leading, tight) {\n    return (pos << 2) | (leading << 1) | tight;\n  }\n\n  function solve(pos, leading, tight) {\n    if (pos === n) {\n      return leading ? 0 : 1;\n    }\n    let dpIndex = idx(pos, leading ? 1 : 0, tight ? 1 : 0);\n    let memoVal = dp[dpIndex];\n    if (memoVal !== -1) return memoVal;\n\n    let limit = tight ? d[pos] : 9;\n    let ways = 0;\n    for (let dig = 0; dig <= limit; dig++) {\n      if (!leading && dig === 0) continue;\n      let nLeading = leading && dig === 0;\n      let nTight = tight && dig === limit;\n      ways += solve(pos + 1, nLeading, nTight);\n    }\n    dp[dpIndex] = ways;\n    return ways;\n  }\n\n  return solve(0, true, true);\n}\n\nfunction countNoZeroDivisible(x) {\n  if (x < 1) return 0;\n  let digits = getDigits(x);\n  let n = digits.length;\n  let maxSum = 9 * n;\n  let ans = 0;\n\n  for (let S = 1; S <= maxSum; S++) {\n    ans += countNoZeroDivSum(digits, S);\n  }\n  return ans;\n}\n\nfunction countNoZeroDivSum(d, S) {\n  let n = d.length;\n  const SUM_SIZE = S + 1;\n  const REM_SIZE = S;\n  const DP_SIZE = n * SUM_SIZE * REM_SIZE * 2 * 2;\n  let dp = new Int32Array(DP_SIZE).fill(-1);\n\n  function idx(pos, sumSoFar, rem, started, tight) {\n    let stride1 = SUM_SIZE * REM_SIZE * 4;\n    let stride2 = REM_SIZE * 4;\n    let stride3 = 4;\n    return (\n      pos * stride1 +\n      sumSoFar * stride2 +\n      rem * stride3 +\n      (started << 1) +\n      tight\n    );\n  }\n\n  function solve(pos, sumSoFar, rem, started, tight) {\n    if (pos === n) {\n      if (!started) return 0;\n      return sumSoFar === S && rem === 0 ? 1 : 0;\n    }\n    if (sumSoFar > S) {\n      return 0;\n    }\n    let dpIndex = idx(pos, sumSoFar, rem, started ? 1 : 0, tight ? 1 : 0);\n    let memoVal = dp[dpIndex];\n    if (memoVal !== -1) return memoVal;\n\n    let limit = tight ? d[pos] : 9;\n    let ways = 0;\n\n    for (let dig = 0; dig <= limit; dig++) {\n      if (started && dig === 0) continue;\n\n      let nStarted = started,\n        nSum = sumSoFar,\n        nRem = rem,\n        nTight = tight && dig === limit;\n      if (!nStarted) {\n        if (dig > 0) {\n          nStarted = true;\n          nSum += dig;\n          if (nSum > S) break;\n          nRem = dig % S;\n        }\n      } else {\n        nSum += dig;\n        if (nSum > S) break;\n        nRem = (nRem * dig) % S;\n      }\n      ways += solve(pos + 1, nSum, nRem, nStarted, nTight);\n    }\n\n    dp[dpIndex] = ways;\n    return ways;\n  }\n\n  return solve(0, 0, 0, false, true);\n}\n\nfunction getDigits(num) {\n  return String(num).split(\"\").map(Number);\n}\n","author":"Yuriy","submissionId":"1575233294"},[]]},{"286":[{"id":"286","fileName":"1575234164.txt","sourceCode":"class Solution {\n    public int beautifulNumbers(int l, int r) {\n        /*sounds like that one digit dp problem by the name, also desc makes it seem like one\n        from product of digits to be divisible by sum look at properties.\n        \n        Trivial cases:\n            all 1 digit numbers are both their  product and sum so trivially beaut\n            all number with a 0 in their digits have a product of 0, which is trivially divisible by everything and thus beaut\n            \n        beyond\n        non-trivials:\n        22, 36, 44, 63, 66, 88, 123, 132, 138, 145, 154, .....\n        \n        note: since prod and sum both commute, if one permutation of digiits is beaut, all are\n        so really just looking at digit choices\n        \n        for all n digit numbers, can go through all possible \n            \n        ehh screew these properties, I'll just try digit dp with the sum and product.\n        \n        */\n        String leftStr = String.valueOf(l-1), rightStr = String.valueOf(r);\n        Map<Integer, Integer>[][][] memo1 = new HashMap[leftStr.length()][2][leftStr.length() * 9 + 1];\n        Map<Integer, Integer>[][][] memo2 = new HashMap[rightStr.length()][2][rightStr.length() * 9 + 1];\n        for(int i = 0; i < memo1.length; i++) {\n            for(int j = 0; j < memo1[i].length; j++) for(int k = 0; k < memo1[i][j].length; k++) memo1[i][j][k] = new HashMap<>();\n        }\n        for(int i = 0; i < memo2.length; i++) {\n            for(int j = 0; j < memo2[i].length; j++) for(int k = 0; k < memo2[i][j].length; k++) memo2[i][j][k] = new HashMap<>();\n        }\n   \n        return dp(rightStr, 0, true, 0, 1, memo2) - dp(leftStr, 0, true, 0, 1, memo1);\n    }\n    \n    private int dp(String num, int index, boolean tight, int sum, int product, Map<Integer, Integer>[][][] memo) {\n        if(index == num.length()) {\n            return (sum > 0 && product % sum == 0) ? 1 : 0;\n        }\n        if(memo[index][tight ? 1 : 0][sum].containsKey(product)) {\n            return memo[index][tight ? 1 : 0][sum].get(product);\n        }\n        int res = 0;\n        for(int d = 0; d <= (tight ? num.charAt(index)-'0' : 9); d++) {\n            int nextSum = d + sum;\n            int nextProduct = nextSum == 0 ? 1 : product*d; //stay 1 if sum is 0, as no digits have been chosen so am in leading zeros\n            res += dp(num, index + 1, tight && d == num.charAt(index)-'0', nextSum, nextProduct, memo);\n        }\n        \n        memo[index][tight ? 1 : 0][sum].put(product, res);\n        return res;\n    }\n}","author":"Nicholas Ulman","submissionId":"1575234164"},[]]},{"288":[{"id":"288","fileName":"1575234768.txt","sourceCode":"class Solution {\npublic:\n    long long f(int i, int s, int P, bool T, bool U, const vector<int>& v, \n                map<tuple<int, int, int, int, int>, long long>& M) {\n        if(i == v.size()) {\n            if(!U) return 0;\n            return (P % s == 0 ? 1LL : 0LL);\n        }\n        auto K = make_tuple(i, s, P, T, U);\n        if(M.find(K) != M.end()) return M[K];\n        \n        long long r = 0;\n        int L = (T ? v[i] : 9);\n        for (int d = 0; d <= L; d++) {\n            bool T2 = T && (d == L);\n            if(!U && d == 0)\n                r += f(i + 1, s, P, T2, false, v, M);\n            else {\n                int s2 = s + d;\n                int P2 = (U ? P * d : d);\n                r += f(i + 1, s2, P2, T2, true, v, M);\n            }\n        }\n        M[K] = r;\n        return r;\n    }\n    \n    \n    long long g(int a) {\n        if(a < 1) return 0;\n        vector<int> v;\n        while(a > 0) {\n            v.push_back(a % 10);\n            a /= 10;\n        }\n        reverse(v.begin(), v.end());\n        map<tuple<int, int, int, int, int>, long long> M;\n        return f(0, 0, 1, true, false, v, M);\n    }\n\n    int beautifulNumbers(int a, int b) {\n        long long c = g(b) - g(a - 1);\n        return (int)c;\n    }\n};\n","author":"Ritik Thakur","submissionId":"1575234768"},[]]},{"289":[{"id":"289","fileName":"1575235166.txt","sourceCode":"import math\nfrom functools import lru_cache\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def cb(num):\n            digits = list(map(int, str(num)))\n            n = len(digits)\n            @lru_cache(None)\n            def dp(pos, prod, summ, is_tight, lzero):\n                if pos == n:\n                    return 1 if summ > 0 and prod % summ == 0 else 0\n                \n                limit = digits[pos] if is_tight else 9\n                total = 0\n                \n                for d in range(0, limit + 1):\n                    new_prod = (prod * d) if d != 0 or not lzero else prod\n                    new_summ = summ + d\n                    total += dp(pos + 1, new_prod, new_summ, is_tight and (d == limit), lzero and d == 0)\n                \n                return total\n\n            return dp(0, 1, 0, True, True)\n\n        return cb(r) - cb(l - 1)","author":"Sid4306","submissionId":"1575235166"},[]]},{"290":[{"id":"290","fileName":"1575235555.txt","sourceCode":"public class Solution {\n    public int BeautifulNumbers(int l, int r) \n    {\n        return Beautiful(r) - Beautiful(l - 1);\n    }\n\n    private int Beautiful(int x)\n        {\n            if (x < 1) return 0;  // no positive numbers below 1\n            string s = x.ToString();\n            //int n = s.Length;\n            // memoization\n            var memo = new Dictionary<(int pos, bool tight, bool started, bool hasZero, int sum, int prod), int>();\n            return DP(0, true, false, false, 0, 1, s, memo);\n        }\n\n    private int DP(int pos, bool tight, bool started, bool hasZero, int sum, int prod, string s, Dictionary<(int, bool, bool, bool, int, int), int> memo)\n        {\n            if (pos == s.Length)\n            {\n                if (!started) return 0;\n                if (hasZero) return 1;\n                return (sum != 0 && prod % sum == 0) ? 1 : 0;\n            }\n\n            var key = (pos, tight, started, hasZero, sum, prod);\n            if (memo.ContainsKey(key))\n                return memo[key];\n\n            int limit = tight ? s[pos] - '0' : 9;\n            int res = 0;\n\n            for (int d = 0; d <= limit; d++)\n            {\n                bool newTight = tight && (d == limit);\n                if (!started)\n                {\n                    if (d == 0) res += DP(pos + 1, newTight, false, false, 0, 1, s, memo);\n                    else res += DP(pos + 1, newTight, true, false, d, d, s, memo);\n                }\n                else\n                {\n                    if (d == 0) res += DP(pos + 1, newTight, true, true, sum, 0, s, memo);\n                    else\n                    {\n                        if (hasZero) res += DP(pos + 1, newTight, true, true, sum + d, 0, s, memo);\n                        else res += DP(pos + 1, newTight, true, false, sum + d, prod * d, s, memo);\n                    }\n                }\n            }\n\n            memo[key] = res;\n            return res;\n        }\n}","author":"Irine","submissionId":"1575235555"},[]]},{"291":[{"id":"291","fileName":"1575235684.txt","sourceCode":"class Solution(object):\n    def __init__(self):\n        self.dp = {}\n\n    def rec(self, pos, tight, started, hasZero, sum_digits, e2, e3, e5, e7, s):\n        if pos == len(s):\n            if not started:\n                return 0\n            if hasZero:\n                return 1\n            prod = 1\n            for _ in range(e2):\n                prod *= 2\n            for _ in range(e3):\n                prod *= 3\n            for _ in range(e5):\n                prod *= 5\n            for _ in range(e7):\n                prod *= 7\n            return 1 if sum_digits != 0 and prod % sum_digits == 0 else 0\n\n        key = (pos, tight, started, hasZero, sum_digits, e2, e3, e5, e7)\n        if key in self.dp:\n            return self.dp[key]\n\n        res = 0\n        limit = int(s[pos]) if tight else 9\n        for d in range(limit + 1):\n            ntight = tight and (d == limit)\n            if not started:\n                if d == 0:\n                    res += self.rec(pos + 1, ntight, False, False, 0, 0, 0, 0, 0, s)\n                else:\n                    new_sum = d\n                    new_e2 = new_e3 = new_e5 = new_e7 = 0\n                    temp = d\n                    while temp % 2 == 0:\n                        new_e2 += 1\n                        temp /= 2\n                    while temp % 3 == 0:\n                        new_e3 += 1\n                        temp /= 3\n                    while temp % 5 == 0:\n                        new_e5 += 1\n                        temp /= 5\n                    while temp % 7 == 0:\n                        new_e7 += 1\n                        temp /= 7\n                    res += self.rec(pos + 1, ntight, True, False, new_sum, new_e2, new_e3, new_e5, new_e7, s)\n            else:\n                if hasZero:\n                    new_sum = sum_digits + d\n                    res += self.rec(pos + 1, ntight, True, True, new_sum, 0, 0, 0, 0, s)\n                else:\n                    if d == 0:\n                        new_sum = sum_digits\n                        res += self.rec(pos + 1, ntight, True, True, new_sum, 0, 0, 0, 0, s)\n                    else:\n                        new_sum = sum_digits + d\n                        new_e2, new_e3, new_e5, new_e7 = e2, e3, e5, e7\n                        temp = d\n                        while temp % 2 == 0:\n                            new_e2 += 1\n                            temp /= 2\n                        while temp % 3 == 0:\n                            new_e3 += 1\n                            temp /= 3\n                        while temp % 5 == 0:\n                            new_e5 += 1\n                            temp /= 5\n                        while temp % 7 == 0:\n                            new_e7 += 1\n                            temp /= 7\n                        res += self.rec(pos + 1, ntight, True, False, new_sum, new_e2, new_e3, new_e5, new_e7, s)\n\n        self.dp[key] = res\n        return res\n\n    def countBeautiful(self, x):\n        if x < 1:\n            return 0\n        s = str(x)\n        self.dp.clear()\n        return self.rec(0, True, False, False, 0, 0, 0, 0, 0, s)\n\n    def beautifulNumbers(self, l, r):\n        return int(self.countBeautiful(r) - self.countBeautiful(l - 1))\n","author":"ShirotoMahiru","submissionId":"1575235684"},[]]},{"292":[{"id":"292","fileName":"1575236032.txt","sourceCode":"class Solution {\n    static String digits;\n    static int n;\n    static HashMap<String, Long> memo;\n    \n    public int beautifulNumbers(int l, int r) {\n        return (int) (countBeautiful(r) - countBeautiful(l - 1));\n    }\n    \n    long countBeautiful(long X) {\n        digits = Long.toString(X);\n        n = digits.length();\n        memo = new HashMap<>();\n        return countBeautifulHelper(0, true, false, false, 0, 1);\n    }\n    \n    public static long countBeautifulHelper(int pos, boolean tight, boolean started, boolean hasZero, int sum, long product) {\n        if (pos == n) {\n            if (!started) return 0;\n            if (hasZero) return 1;\n            return (sum != 0 && product % sum == 0) ? 1 : 0;\n        }\n        \n        // Build a key for memoization based on our state.\n        String key = pos + \",\" + tight + \",\" + started + \",\" + hasZero + \",\" + sum + \",\" + product;\n        if (memo.containsKey(key)) {\n            return memo.get(key);\n        }\n        \n        long count = 0;\n        int limit = tight ? digits.charAt(pos) - '0' : 9;\n        for (int d = 0; d <= limit; d++) {\n            boolean newTight = tight && (d == limit);\n            if (!started) {\n                if (d == 0) {\n                    // Still in leading zeros.\n                    count += countBeautifulHelper(pos + 1, newTight, false, false, 0, 1);\n                } else {\n                    // Start the number with nonzero digit d.\n                    count += countBeautifulHelper(pos + 1, newTight, true, false, d, d);\n                }\n            } else {\n                if (d == 0) {\n                    // Once we add a 0, mark hasZero true and product becomes 0.\n                    count += countBeautifulHelper(pos + 1, newTight, true, true, sum, 0);\n                } else {\n                    // If we already encountered a zero, product remains 0.\n                    if (hasZero) {\n                        count += countBeautifulHelper(pos + 1, newTight, true, true, sum + d, 0);\n                    } else {\n                        // Multiply product by d and add d to sum.\n                        count += countBeautifulHelper(pos + 1, newTight, true, false, sum + d, product * d);\n                    }\n                }\n            }\n        }\n        \n        memo.put(key, count);\n        return count;\n    }\n}","author":"Terry","submissionId":"1575236032"},[]]},{"293":[{"id":"293","fileName":"1575236647.txt","sourceCode":"\"\"\"/*\nclass Solution {\npublic:\n    bool isBeautiful(int num) {\n        int sum = 0;\n        int mul = 1;\n        int temp = num;\n        \n        while (temp > 0) \n        {\n            int digit = temp % 10;\n            sum += digit;\n            \n            if (digit == 0) \n            {\n                mul = 0;\n            } \n            else \n            {\n                mul *= digit;\n            }\n            \n            temp /= 10;\n        }\n        \n        return sum > 0 && mul % sum == 0;\n    }\n    int beautifulNumbers(int l, int r) {\n        int maxi = 100000;\n        vector<bool> beaut(maxi + 1, false);\n        for (int i = 1; i <= maxi; i++) \n        {\n            beaut[i] = isBeautiful(i);\n        }\n        int count = 0;\n        for (int num = l; num <= min(r, maxi); num++) \n        {\n            if (beaut[num]) \n            {\n                count++;\n            }\n        }\n        if (r > maxi) \n        {\n            for (int num=max(l,maxi+1); num <= r; num++) \n            {\n                if (isBeautiful(num)) \n                {\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n};\n*/\n\nwhy not \n\n\n\n\"\"\"\n\n\nclass Solution:\n    def __init__(self):\n        self.memo = {}\n        self.num_str = \"\"\n\n    def solve(self, idx, limit, has_started, has_zero, total_sum, pow2, pow3, pow5, pow7):\n        if idx == len(self.num_str):\n            if not has_started:\n                return 0\n            if has_zero:\n                return 1\n            product = (2 ** pow2) * (3 ** pow3) * (5 ** pow5) * (7 ** pow7)\n            return 1 if total_sum != 0 and product % total_sum == 0 else 0\n\n        state = (idx, limit, has_started, has_zero, total_sum, pow2, pow3, pow5, pow7)\n        if state in self.memo:\n            return self.memo[state]\n\n        res = 0\n        max_digit = int(self.num_str[idx]) if limit else 9\n\n        for digit in range(max_digit + 1):\n            new_limit = limit and (digit == max_digit)\n\n            if not has_started:\n                if digit == 0:\n                    res += self.solve(idx + 1, new_limit, 0, 0, 0, 0, 0, 0, 0)\n                else:\n                    temp, count2, count3, count5, count7 = digit, 0, 0, 0, 0\n                    while temp % 2 == 0:\n                        count2 += 1\n                        temp //= 2\n                    while temp % 3 == 0:\n                        count3 += 1\n                        temp //= 3\n                    while temp % 5 == 0:\n                        count5 += 1\n                        temp //= 5\n                    while temp % 7 == 0:\n                        count7 += 1\n                        temp //= 7\n                    res += self.solve(idx + 1, new_limit, 1, 0, digit, count2, count3, count5, count7)\n            else:\n                if has_zero:\n                    res += self.solve(idx + 1, new_limit, 1, 1, total_sum + digit, 0, 0, 0, 0)\n                else:\n                    if digit == 0:\n                        res += self.solve(idx + 1, new_limit, 1, 1, total_sum, 0, 0, 0, 0)\n                    else:\n                        temp, count2, count3, count5, count7 = digit, pow2, pow3, pow5, pow7\n                        while temp % 2 == 0:\n                            count2 += 1\n                            temp //= 2\n                        while temp % 3 == 0:\n                            count3 += 1\n                            temp //= 3\n                        while temp % 5 == 0:\n                            count5 += 1\n                            temp //= 5\n                        while temp % 7 == 0:\n                            count7 += 1\n                            temp //= 7\n                        res += self.solve(idx + 1, new_limit, 1, 0, total_sum + digit, count2, count3, count5, count7)\n\n        self.memo[state] = res\n        return res\n\n    def count_beautiful(self, num):\n        if num < 1:\n            return 0\n        self.num_str = str(num)\n        self.memo.clear()\n        return self.solve(0, 1, 0, 0, 0, 0, 0, 0, 0)\n\n    def beautifulNumbers(self, left, right):\n        return self.count_beautiful(right) - self.count_beautiful(left - 1)\n","author":"Utkarsh Tyagi","submissionId":"1575236647"},[]]},{"294":[{"id":"294","fileName":"1575237132.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        @cache\n        def dp(s,ln,i,tight,pro,sm,lead):\n            if i==ln:return [0,1][sm and pro%sm==0]\n            limit=9 if not tight else int(s[i])\n            ans=0\n            for d in range(limit+1):\n                new_pro = pro if lead and d == 0 else pro * d\n                ans+=dp(s,ln,i+1,tight and d==limit, new_pro, sm+d, lead and (d==0))\n            return ans\n        l,r=str(l-1),str(r)\n        a1=dp(l,len(l),0,True,1,0,True)\n        a2=dp(r,len(r),0,True,1,0,True)\n        return a2-a1","author":"alright4869","submissionId":"1575237132"},[]]},{"295":[{"id":"295","fileName":"1575237222.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def pre(n):\n            digits = [int(d) for d in str(n)]\n\n            @lru_cache(None)\n            def helper(pos, tight, curr_sum, curr_product, started=False):\n                if pos == len(digits):\n                    return 1 if started and curr_sum > 0 and curr_product % curr_sum == 0 else 0\n\n                result = 0\n                limit = digits[pos] if tight else 9\n                \n                for d in range(limit + 1):\n                    new_product = curr_product\n                    if started:\n                        new_product = 0 if d == 0 else curr_product * d\n                    elif d > 0:\n                        new_product = d\n                        \n                    result += helper(\n                        pos + 1,\n                        tight and d == digits[pos],\n                        curr_sum + d,\n                        new_product,\n                        started or d > 0\n                    )\n                return result\n\n            return helper(0, True, 0, 1, False)\n\n        r = pre(r)\n        l = pre(l - 1)\n        return r - l","author":"hufflepuffpastry","submissionId":"1575237222"},[]]},{"296":[{"id":"296","fileName":"1575237151.txt","sourceCode":"\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T>\nusing max_pq = priority_queue<T>;\n\ntemplate<typename T1, typename T2>\nvoid chmax(T1 &x, T2 y) { if (x < y) x = y; }\ntemplate<typename T1, typename T2>\nvoid chmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T>\nvoid asort(vector<T> &a) {sort(a.begin(), a.end());}\ntemplate<typename T>\nvoid dsort(vector<T> &a) {sort(a.rbegin(), a.rend());}\n\ntemplate<typename T>\nvector<T> get_unique(vector<T> a) {\n    asort(a);\n    a.erase(unique(a.begin(), a.end()), a.end());\n    return a;\n}\n\nusing ll = long long;\nusing vi = vector<ll>;\nusing vvi = vector<vi>;\nusing pii = pair<ll,ll>;\nusing vp = vector<pii>;\nusing ti3 = tuple<ll,ll,ll>;\nusing vti3 = vector<ti3>;\nusing vs = vector<string>;\n\n\nconst int sz2 = 6, sz3 = 4, sz5 = 2, sz7 = 2, lim = 85;\n\nvi primes = {2,3,5,7};\n\n\nint dp[11][2][2][sz2+1][sz3+1][sz5+1][sz7+1][2][lim];\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        auto f = [&] (int x) {\n            string s = to_string(x);\n            int n = s.size();\n            vi a(n);\n            for (int i=0; i<n; i++) a[i] = s[i] - '0';\n            int ans = 0;\n            if (x == 0) return ans;\n\n            // int sz2 = 7, sz3 = 5, sz5 = 3, sz7 = 3;\n            // int lim = 90;\n            // Vec<9,int> dp(n+1,2,2,sz2+1,sz3+1,sz5+1,sz7+1,2,lim);\n            for (int i=0; i<=n; i++) \n                for (int tb=0; tb<2; tb++) \n                    for (int lz=0; lz<2; lz++) \n                        for (int j2=0; j2<=sz2; j2++) \n                            for (int j3=0; j3<=sz3; j3++) \n                                for (int j5=0; j5<=sz5; j5++) \n                                    for (int j7=0; j7<=sz7; j7++) \n                                        for (int j0=0; j0<2; j0++) \n                                            for (int cum=0; cum<lim; cum++) \n                                                dp[i][tb][lz][j2][j3][j5][j7][j0][cum] = 0;\n\n            dp[0][0][0][0][0][0][0][0][0] = 1;\n            for (int i=0; i<n; i++) {\n                for (int tb=0; tb<2; tb++) {\n                    for (int lz=0; lz<2; lz++) {\n                        for (int j2=0; j2<=sz2; j2++) {\n                            for (int j3=0; j3<=sz3; j3++) {\n                                for (int j5=0; j5<=sz5; j5++) {\n                                    for (int j7=0; j7<=sz7; j7++) {\n                                        for (int j0=0; j0<2; j0++) {\n                                            for (int cum=0; cum<lim; cum++) {\n                                                ll val = dp[i][tb][lz][j2][j3][j5][j7][j0][cum];\n                                                if (val == 0) continue;\n                                                for (int d=0; d<=(tb?9:a[i]); d++) {\n                                                    int ntb = tb | (d < a[i]);\n                                                    int nlz = lz | (d != 0);\n                                                    int nj2 = j2;\n                                                    int nj3 = j3;\n                                                    int nj5 = j5;\n                                                    int nj7 = j7;\n                                                    int nj0 = j0 | (d==0 && lz == 1);\n                                                    int ncum = cum + d;\n                                                    int x = d;\n                                                    if (x > 0) {\n                                                        for (auto p : primes) {\n                                                            while (x % p == 0) {\n                                                                x /= p;\n                                                                if (p == 2) nj2 = min(nj2+1,sz2);\n                                                                if (p == 3) nj3 = min(nj3+1,sz3);\n                                                                if (p == 5) nj5 = min(nj5+1,sz5);\n                                                                if (p == 7) nj7 = min(nj7+1,sz7);\n                                                            }\n                                                        }\n                                                    }\n                                                    dp[i+1][ntb][nlz][nj2][nj3][nj5][nj7][nj0][ncum] += val;\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            for (int tb=0; tb<2; tb++) {\n                for (int lz=0; lz<2; lz++) {\n                    for (int j2=0; j2<=sz2; j2++) {\n                        for (int j3=0; j3<=sz3; j3++) {\n                            for (int j5=0; j5<=sz5; j5++) {\n                                for (int j7=0; j7<=sz7; j7++) {\n                                    for (int j0=0; j0<2; j0++) {\n                                        for (int cum=0; cum<lim; cum++) {\n                                            ll v = dp[n][tb][lz][j2][j3][j5][j7][j0][cum];\n                                            if (v == 0) continue;\n                                            if (cum == 0) continue;\n                                            if (j0) {\n                                                ans += v;\n                                                continue;\n                                            }\n                                            vi cnt(8);\n                                            int x = cum;\n                                            for (auto p : primes) {\n                                                while (x % p == 0) {\n                                                    x /= p;\n                                                    cnt[p]++;\n                                                }\n                                            }\n                                            chmin(cnt[2],sz2);\n                                            chmin(cnt[3],sz3);\n                                            chmin(cnt[5],sz5);\n                                            chmin(cnt[7],sz7);\n\n                                            if (x == 1) {\n                                                if (j2 >= cnt[2] && j3 >= cnt[3] && j5 >= cnt[5] && j7 >= cnt[7]) {\n                                                    ans += v;\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            return ans;\n\n        };\n        // debug(f(10));\n        // debug(f(1));\n        return f(r) - f(l-1);\n    }\n};","author":"umeshbahadur1729","submissionId":"1575237151"},[]]},{"297":[{"id":"297","fileName":"1575237361.txt","sourceCode":"class Solution:\n    # digit DP, time and space O(9L^2*9^L) = constant, when L = number of digits = log(r) < 10\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_lt_eq(n: int) -> int:\n            n_str = str(n)\n\n            @cache\n            def dp(\n                pos: int,  # current digit index\n                tight: bool,  # whether number’s prefix = n's prefix\n                non_leading_zero: bool,  # whether placed a non–leading–zero digit\n                has_zero: bool,  # whether a `0` is used \n                cur_sum: int,  # current digits sum\n                cur_product: int,  # current digits product\n            ) -> int:\n                if pos == len(n_str):\n                    if not non_leading_zero:\n                        return 0\n                    if has_zero:\n                        return 1\n                    return cur_product % cur_sum == 0\n                res = 0\n                limit = int(n_str[pos]) if tight else 9\n                for d in range(limit + 1):\n                    new_tight = tight and d == limit\n                    if not non_leading_zero and d == 0:\n                        res += dp(pos + 1, new_tight, False, False, 0, 1)\n                    else:\n                        new_has_zero = has_zero or d == 0\n                        res += dp(\n                            pos + 1, \n                            new_tight, \n                            True, \n                            new_has_zero, \n                            cur_sum + d, \n                            0 if new_has_zero else cur_product * d\n                        )\n                return res\n\n            return dp(0, True, False, False, 0, 1)\n\n        return count_lt_eq(r) - count_lt_eq(l - 1)","author":"Sam Chen","submissionId":"1575237361"},[]]},{"298":[{"id":"298","fileName":"1575238494.txt","sourceCode":"class Solution {\n    unordered_map<string, int> hash;\n    \n    string genKey(int pos, bool tight, bool started, bool hasZero, int sum, int prod) {\n        return to_string(pos) + \"_\" + to_string(tight) + \"_\" + to_string(started) + \"_\" + to_string(hasZero)\n               + \"_\" + to_string(sum) + \"_\" + to_string(prod);\n    }\n\n    int dp(int pos, bool tight, bool started, bool hasZero, int sum, int prod, string &s) {\n        if (pos == s.size()) {\n            if (!started) return 0;\n            if (hasZero) return 1;\n            return (prod % sum == 0) ? 1 : 0;\n        }\n        \n        string key = genKey(pos, tight, started, hasZero, sum, prod);\n        if(hash.count(key)) return hash[key];\n        \n        int ans = 0;\n        int upperLimit = tight ? s[pos] - '0' : 9;\n        for (int i = 0; i <= upperLimit; i++) {\n            bool newStarted = started || (i != 0), newHasZero = hasZero;\n            int newSum = sum, newProd = prod;\n            if (newStarted) {\n                if (started == false && i == 0) {\n                    newStarted = false;\n                } else {\n                    newSum += i;\n                    newProd = newProd * i;\n                    newHasZero = i == 0 ? true : newHasZero;\n                }\n            }\n            ans += dp(pos + 1, tight && (i == upperLimit), newStarted, newHasZero, newSum, newProd, s);\n        }\n        \n        hash[key] = ans;\n        return ans;\n    }\n    \n    int countBeautiful(int x) {\n        if(x < 1) return 0;\n        string s = to_string(x);\n        hash.clear();\n        return dp(0, true, false, false, 0, 1, s);\n    }\n    \npublic:\n    int beautifulNumbers(int l, int r) {\n        return countBeautiful(r) - countBeautiful(l-1);\n    }\n};","author":"tsigave","submissionId":"1575238494"},[]]},{"300":[{"id":"300","fileName":"1575237937.txt","sourceCode":"fac = {\n                1: (0, 0, 0, 0),\n                2: (1, 0, 0, 0),\n                3: (0, 1, 0, 0),\n                4: (2, 0, 0, 0),\n                5: (0, 0, 1, 0),\n                6: (1, 1, 0, 0),\n                7: (0, 0, 0, 1),\n                8: (3, 0, 0, 0),\n                9: (0, 2, 0, 0)\n            }\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def cnt(x: int) -> int:\n            if x < 1:\n                return 0\n            s = str(x)\n            n = len(s)\n            digits = list(map(int, s))\n            @cache\n            def dp(i, tight, started, ssum, pf):\n                if i == n:\n                    if not started or ssum == 0:\n                        return 0\n                    if pf == -1:\n                        return 1\n                    p2, p3, p5, p7 = pf\n                    prod_mod = (pow(2, p2, ssum) * pow(3, p3, ssum) *\n                                pow(5, p5, ssum) * pow(7, p7, ssum)) % ssum\n                    return 1 if prod_mod == 0 else 0\n                ans = 0\n                lim = digits[i] if tight else 9\n                for d in range(lim + 1):\n                    ntight = tight and (d == lim)\n                    if not started:\n                        if d == 0:\n                            ans += dp(i + 1, ntight, False, 0, (0, 0, 0, 0))\n                        else:\n                            nsum = d\n                            npf = fac[d] if d != 0 else -1\n                            ans += dp(i + 1, ntight, True, nsum, npf)\n                    else:\n                        nsum = ssum + d\n                        if pf == -1 or d == 0:\n                            npf = -1\n                        else:\n                            f2, f3, f5, f7 = pf\n                            a2, a3, a5, a7 = fac[d]\n                            npf = (f2 + a2, f3 + a3, f5 + a5, f7 + a7)\n                        ans += dp(i + 1, ntight, True, nsum, npf)\n                return ans\n            return dp(0, True, False, 0, (0, 0, 0, 0))\n        return cnt(r) - cnt(l - 1)","author":"potatoyy","submissionId":"1575237937"},[]]},{"302":[{"id":"302","fileName":"1575238453.txt","sourceCode":"class Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        string digits;\n        int len;\n\n        vector<vector<vector<vector<map<int, int>>>>> dp(10, \n            vector<vector<vector<map<int, int>>>>(2, \n                vector<vector<map<int, int>>>(100, \n                    vector<map<int, int>>(2, map<int, int>()))\n            )\n        );\n        bool considerTight = false;\n        \n        auto go = [&](auto&& go, string& s, int pos, bool tight, int sum, int prod, bool allPrefZero) -> int {\n            if(pos == len) {\n                if(tight && considerTight == false)\n                    return 0;\n                if(sum == 0)\n                    return 0;\n                // cout << s << \" \" << prod << \" \" << sum << \" \" << (prod % sum == 0) << \"n\";\n                return prod % sum == 0;\n            }\n            if(dp[pos][tight][sum][allPrefZero].count(prod))\n                return dp[pos][tight][sum][allPrefZero][prod];\n\n            int ub = tight ? digits[pos] - '0' : 9;\n            int cnt = 0;\n            for(int d = 0; d <= ub; d++) {\n                bool newAllPrefZero = allPrefZero && d == 0;\n                int newProd = prod * (newAllPrefZero ? 1 : d);\n                s.push_back('0' + d);\n                cnt += go(go, s, pos + 1, tight && d == ub, sum + d, newProd, newAllPrefZero);\n                s.pop_back();\n            }\n            return dp[pos][tight][sum][allPrefZero][prod] = cnt;\n        };\n\n        string s = \"\";\n        digits = to_string(l);\n        len = digits.size();\n        int L = go(go, s, 0, true, 0, 1, true);\n\n        considerTight = true;\n        digits = to_string(r);\n        len = digits.size();\n        vector<vector<vector<vector<map<int, int>>>>> dp1(10, \n            vector<vector<vector<map<int, int>>>>(2, \n                vector<vector<map<int, int>>>(100, \n                    vector<map<int, int>>(2, map<int, int>()))\n            )\n        );\n        dp = dp1;\n        int R = go(go, s, 0, true, 0, 1, true);\n        // cout << L << \" \" << R << \"n\";\n        return R - L;\n    }\n};","author":"Atul","submissionId":"1575238453"},[]]},{"303":[{"id":"303","fileName":"1575238953.txt","sourceCode":"from functools import lru_cache\n\nclass Solution:\n    \n    @lru_cache(maxsize=None)\n    def digit_dp(self, pos, tight, started, hasZero, s, p):\n\n        if pos == len(self.digits):\n            if not started:\n                return 0\n            if hasZero:\n                return 1\n            else:\n                return 1 if (p % s == 0) else 0\n    \n        ans = 0\n        \n        up = self.digits[pos] if tight else 9\n        \n        for d in range(0, up + 1):\n            \n            new_tight = tight and (d == up)\n            new_started = started or (d != 0)\n            new_hasZero = hasZero or (new_started and d == 0)\n            \n            new_s = s\n            new_p = p\n            \n            if new_started:\n                new_s += d\n                if new_hasZero:\n                    new_p = 0\n                else:\n                    new_p *= d\n                    \n            ans += self.digit_dp(pos + 1, new_tight, new_started, new_hasZero, new_s, new_p)\n\n        return ans\n    \n    def count_valid(self, n):\n        self.digit_dp.cache_clear()\n        digits = list(map(int, str(n)))\n        self.digits = digits\n        return self.digit_dp(0, True, False, False, 0, 1)\n        \n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return self.count_valid(r) - self.count_valid(l - 1)","author":"tdserapio","submissionId":"1575238953"},[]]},{"304":[{"id":"304","fileName":"1575239117.txt","sourceCode":"def helper(l, r):\n    def c(x):\n        if x < 1: return 0\n        s = str(x)\n        @lru_cache(None)\n        def f(i,t,st,hz,ss,p):\n            if i == len(s):\n                return 0 if not st else (1 if hz else (1 if ss and p%ss == 0 else 0))\n            ans, lim = 0, (int(s[i]) if t else 9)\n            for d in range(lim+1):\n                nt = t and d == lim\n                if not st:\n                    ans += f(i+1, nt, d!=0, False, d, d if d else 1)\n                else:\n                    if hz: ans += f(i+1, nt, True, True, ss+d, p)\n                    else:\n                        if d == 0: ans += f(i+1, nt, True, True, ss, p)\n                        else: ans += f(i+1, nt, True, False, ss+d, p*d)\n            return ans\n        return f(0, True, False, False, 0, 1)\n    return c(r) - c(l-1)\n\n\n\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return helper(l,r)\n        ","author":"Eaten_zombie","submissionId":"1575239117"},[]]},{"305":[{"id":"305","fileName":"1575239706.txt","sourceCode":"public class Solution\n{\n    public int BeautifulNumbers(int l, int r)\n    {\n        Dictionary<(int, bool, bool, int, int), long> cache = new();\n        long high = helper(r.ToString(), 0, true, false, 0, 1);\n\n        cache = new();\n        long low = helper((l - 1).ToString(), 0, true, false, 0, 1);\n\n        return (int)(high - low);\n\n        long helper(string num, int index, bool isTight, bool isStarted, int digitSum, int digitProduct)\n        {\n            if (index == num.Length)\n            {\n                if (!isStarted)\n                {\n                    return 0;\n                }\n\n                return digitSum > 0 && digitProduct % digitSum == 0 ? 1 : 0;\n            }\n\n            var key = (index, isTight, isStarted, digitSum, digitProduct);\n            if (cache.TryGetValue(key, out var val))\n            {\n                return val;\n            }\n\n            long result = 0;\n            int currentDigit = num[index] - '0';\n            int maxDigit = isTight ? currentDigit : 9;\n\n            for (int i = 0; i <= maxDigit; i++)\n            {\n                bool newIsStarted = isStarted;\n                int nextDigitSum = digitSum;\n                int nextDigitProduct = digitProduct;\n\n                if (!isStarted)\n                {\n                    if (i != 0)\n                    {\n                        newIsStarted = true;\n                        nextDigitSum = digitSum + i;\n                        nextDigitProduct = i;\n                    }\n                }\n                else\n                {\n                    nextDigitSum = digitSum + i;\n                    nextDigitProduct = digitProduct * i;\n                }\n\n                bool isNextTight = isTight && (i == currentDigit);\n                result += helper(num, index + 1, isNextTight, newIsStarted, nextDigitSum, nextDigitProduct);\n            }\n\n            cache[key] = result;\n            return result;\n        }\n    }\n}","author":"chrisTris","submissionId":"1575239706"},[]]},{"306":[{"id":"306","fileName":"1575239743.txt","sourceCode":"class Solution {\nprivate:\n    #define INF (int)1e18\n    #define all(x) (x).begin(), (x).end()\n\n    using i64 = long long;\n    using u64 = unsigned long long;\n    \n    #ifdef LOCAL_RUN\n    #define Error(x...) { cout << \"(\" << #x << \")\" << \" = ( \"; printIt(x); }\n    #else\n    #define Error(x...) 42\n    #endif\n    template <typename T1> void printIt(T1 t1) { cout << t1 << \" )\" << endl; }\n    template <typename T1, typename... T2>\n    void printIt(T1 t1, T2... t2) { cout << t1 << \" , \"; printIt(t2...); }\n    // zx :)\n    #define popcount __builtin_popcountll\n\nprivate:\n    i64 count(int n) {\n        if (n < 1) {\n            return 0;\n        }\n        string digits = to_string(n);\n        unordered_map<string, i64> memo;\n        return digitDP(0, true, false, 0, 1LL, digits, memo);\n    }\n\n    i64 digitDP(int pos, bool tight, bool started, int sum, i64 prod, const string &digits, unordered_map<string, i64> &memo) {\n        if (pos == digits.size()) {\n            return (started && sum > 0 && prod % sum == 0) ? 1 : 0;\n        }\n        string key = to_string(pos) + \",\" + to_string(tight) + \",\" + to_string(started) + \",\" + to_string(sum) + \",\" + to_string(prod);\n        if (memo.count(key)) return memo[key];\n        \n        int limit = tight ? (digits[pos] - '0') : 9;\n        i64 total = 0;\n        \n        for (int d = 0; d <= limit; d++) {\n            bool nextTight = tight && (d == limit), nextStarted = started || (d != 0);\n            int nextSum = sum;\n            i64 nextProd = prod;\n            \n            if (nextStarted) {\n                if (!started) {\n                    nextSum = d;\n                    nextProd = d;\n                } \n                else {\n                    nextSum += d;\n                    nextProd *= d;\n                }\n            }\n            total += digitDP(pos + 1, nextTight, nextStarted, nextSum, nextProd, digits, memo);\n        }\n        \n        return memo[key] = total;\n    }\n    \npublic:\n    int beautifulNumbers(int l, int r) {\n        return count(r) - count(l - 1);\n    }\n};","author":"Heisenberg","submissionId":"1575239743"},[]]},{"307":[{"id":"307","fileName":"1575239708.txt","sourceCode":"#include <bits/stdc++.h> \n\n// #define MAIN_ACTIVE\n// #define IO_ON_FILE\n#define MY_DEBUG\n\nusing namespace std;\n#define int64_t wadwafesfesfes21321300242142104210321\nusing int64_t = long long;\nusing pii = pair<int,int>;\nusing pil = pair<int,int64_t>;\nusing pli = pair<int64_t,int>;\nusing pll = pair<int64_t,int64_t>;\n// #define DISABLE_SANITIZER __attribute__((no_sanitize(\"address\", \"thread\")))\n#define umap unordered_map\n#define uset unordered_set\n#define all(x) x.begin(), x.end()\n#define allr(x) x.rbegin(), x.rend()\n#define emp_back emplace_back\n#define bitcount(x) __builtin_popcount((x))\n#define PQ(x, y) priority_queue<x, vector<x>, y<x>>\n// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>\n#ifdef MY_DEBUG\n    #define imie(...) cout << \"[ \" << #__VA_ARGS__ << \" ]: [\"; \n    dfs_imie(__VA_ARGS__); cout << \"]n\";\n    #define imiec(x) cout << \"[ \" << #x << \" ]: [\", show(all(x), \", \", false), cout << \"]n\";\n    #define e_ cout << \"n\";\n#else  \n    #define imie(...);\n    #define imiec(x);\n    #define e_\n#endif\ntemplate <typename T> void dfs_imie(const T& t) { cout << t; }\ntemplate <typename T, typename... Args> void dfs_imie(const T& t, const Args&... args) { cout << t << \", \"; dfs_imie(args...); }\ntemplate <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << \"(\" << duo.first << \", \" << duo.second << \")\"; }\ntemplate <typename Iter> void show(Iter begin, Iter end, const char* sep = \" \", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : \"\") << *it; if(is_end) cout << \"n\"; }\ntemplate<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }\nmt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());\ntemplate <typename T>\nT mrand(T begin, T end) {\n   if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } \n   else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }\n}\n\ntemplate <typename U, typename... Vs>\nbool mmax(U& lhs, const Vs&... rhs) {\n    bool updated = false;\n    ((updated |= (rhs > lhs ? (lhs = rhs, true) : false)), ...);\n    return updated;\n}\n\ntemplate <typename U, typename... Vs>\nbool mmin(U& lhs, const Vs&... rhs) {\n    bool updated = false;\n    ((updated |= (rhs < lhs ? (lhs = rhs, true) : false)), ...);\n    return updated;\n}\n\n//0up, 1down, 2left, 3right, 4upleft, 5downright, 6upright, 7downleft, 8stay\nconstexpr int dy[9] = {-1, 1, 0, 0, -1, 1, -1, 1, 0};\nconstexpr int dx[9] = {0, 0, -1, 1, -1, 1, 1, -1, 0};\nenum DIR { eup, edown, eleft, eright, eupleft, edownright, eupright, edownleft, estay };\n\ntemplate <typename... Args>\nvoid report(const Args&... args) {\n    ((std::cout << args << \" \"), ...) << \"n\";\n}\n\ntemplate <typename... Args>\nvoid read(Args&... args) {\n    (std::cin >> ... >> args);\n}\n\nint fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();\n\nint64_t dp1[91][91];\nint64_t dp2[91][91];\nint64_t dp3[11][91][91][2];\nint64_t pre[11][91];\n\nint init = []{\n\n    memset(pre, 0, sizeof(pre));\n    const int n = 10;\n    for(int len = 1; len < n; len++)\n        for(int tar = 1; tar <= 9 * len; tar++){\n            for(int i = 0; i <= tar; i++)\n                for(int j = 0; j <= tar; j++)\n                    dp1[i][j] = 0;\n\n            for(int v = 1; v <= min(9, tar); v++)\n                dp1[v][v % tar]++;\n\n            for(int i = 1; i < len; i++){\n                for(int x = 0; x <= tar; x++)\n                    for(int y = 0; y <= tar; y++)\n                        dp2[x][y] = 0;\n\n                for(int rs = 0; rs <= tar; rs++)\n                    for(int v1 = 0; v1 < tar; v1++)\n                        for(int v2 = 0; v2 <= 9; v2++){\n                            if(rs + v2 > tar)\n                                break;\n                            dp2[rs + v2][(v1 * v2) % tar] += dp1[rs][v1];\n                        }\n                swap(dp1, dp2);\n            }\n\n            // imie(len, tar, dp[tar][0])\n            pre[len][tar] += dp1[tar][0];\n        }\n\n    return 0;\n}();\n\n\nclass Solution {\nprivate:\n    int64_t calc(int max_val) {\n        string s = to_string(max_val);\n        const int n = s.size();\n\n        int64_t ans = 0;\n        for(int i = 1; i < n; i++)\n            for(int t = 1; t <= i * 9; t++)\n                ans += pre[i][t];\n\n        // imie(s, ans)\n        //index, sum, rem, is_lower\n        for(int tar = 1; tar <= 9 * n; tar++){\n            // memset(dp, 0, sizeof(dp));\n            for(int i = 0; i < n; i++)\n                for(int rs = 0; rs <= tar; rs++)\n                    for(int v1 = 0; v1 <= tar; v1++)\n                        for(int ok = 0; ok <= 1; ok++)\n                        dp3[i][rs][v1][ok] = 0;\n\n            for(int v = 1; v <= min(9, tar); v++){\n                const int me = s[0] - '0';\n                if(v > me)\n                    break;\n                dp3[0][v][v % tar][v < me]++;\n            }\n\n            for(int i = 1; i < n; i++)\n                for(int rs = 0; rs <= tar; rs++)\n                    for(int v1 = 0; v1 < tar; v1++)\n                        for(int ok = 0; ok <= 1; ok++)\n                            if(dp3[i - 1][rs][v1][ok])\n                                for(int v2 = 0; v2 <= 9; v2++){\n                                    if(rs + v2 > tar)\n                                        break;\n                                    const int me = s[i] - '0';\n                                    if(v2 > me && !ok)\n                                        break;\n                                    dp3[i][rs + v2][(v1 * v2) % tar][ok | (v2 < me)] += dp3[i - 1][rs][v1][ok];\n                                }\n\n            ans += dp3[n - 1][tar][0][0] + dp3[n - 1][tar][0][1];\n        }\n\n        // imie(s, ans)\n        return ans;\n    }\n\npublic:\n    int beautifulNumbers(int l, int r) {\n        return calc(r) - calc(l - 1);\n    }\n};\n\n#ifdef MAIN_ACTIVE\n// #include <Str_manip.cpp>\n// #include <Format_Print.cpp>\n// #include <Timer.cpp>\n// #include <Matrix.cpp>\n\nvoid solve() {\n}\n\nint main() { \n\n#ifdef IO_ON_FILE\n    const string FILENAME = \"user\";\n    freopen((FILENAME + \".in\").c_str(), \"r\", stdin);\n    ofstream clearFile((FILENAME + \".out\").c_str(), ios::out);\n    clearFile.close();\n    freopen((FILENAME + \".out\").c_str(), \"w\", stdout);\n#endif\n\n    solve();\n\n   return EXIT_SUCCESS;\n}\n#endif","author":"Binary_Mong","submissionId":"1575239708"},[]]},{"309":[{"id":"309","fileName":"1575240034.txt","sourceCode":"import java.util.Arrays;\n\nclass Solution {\n  private void reset(int[][][][][] dp) {\n    for (int[][][][] x : dp) for (int[][][] d : x) for (int[][] a : d) for (int[] b : a) Arrays.fill(b, -1);\n  }\n\n  private int solve(int ini, int index, int tight, int sumTillHere, int modTillHere, final int must, String s, final int n,\n                    int[][][][][] dp) {\n    if (index == n) {\n      return sumTillHere == must && modTillHere == 0 ? 1 : 0;\n    }\n    if (dp[ini][tight][index][sumTillHere][modTillHere] != -1) return dp[ini][tight][index][sumTillHere][modTillHere];\n    int limit = tight == 1 ? s.charAt(index) - '0' : 9;\n    int res = 0;\n    if (ini == 0) {\n      for (int i = 0; i <= limit; ++i) {\n        int nini = i == 0 ? 0 : 1;\n        if (nini == 0) {\n          res += solve(0, index + 1, 0, sumTillHere, modTillHere, must, s, n, dp);\n        } else {\n          int ntight = tight == 1 && i == limit ? 1 : 0;\n          int nrem = (i);\n          nrem %= must;\n          res += solve(nini, index + 1, ntight, sumTillHere + i, nrem, must, s, n, dp);\n        }\n      }\n    } else {\n      for (int i = 0; i <= limit; ++i) {\n        int ntight = tight == 1 && i == limit ? 1 : 0;\n        int nrem = (modTillHere * i);\n        nrem %= must;\n        res += solve(ini, index + 1, ntight, sumTillHere + i, nrem, must, s, n, dp);\n      }\n    }\n\n    return dp[ini][tight][index][sumTillHere][modTillHere] = res;\n  }\n\n  public int beautifulNumbers(int l, int r) {\n    String right = Integer.toString(r);\n    int adder = 0;\n    int maxSum = 9 * (right.length());\n    int[][][][][] dp = new int[2][2][right.length()][maxSum][maxSum];\n    for (int i = 1; i <= maxSum; ++i) {\n      reset(dp);\n      /*\n      ini , index, tight, sum, residue,\n       */\n      int here = solve(0, 0, 1, 0, 0, i, right, right.length(), dp);\n      adder += here;\n    }\n    if (l == 1) return adder;\n    l -= 1;\n    String left = Integer.toString(l);\n    int sub = 0;\n    maxSum = 9 * (left.length());\n    int[][][][][] dp2 = new int[2][2][left.length()][maxSum][maxSum];\n    for (int i = 1; i <= maxSum; ++i) {\n      reset(dp);\n      sub += solve(0, 0, 1, 0, 0, i, left, left.length(), dp);\n    }\n    return adder - sub;\n  }\n}","author":"Ujjwal Agnihotri","submissionId":"1575240034"},[]]},{"310":[{"id":"310","fileName":"1575239940.txt","sourceCode":"/*\n * Author: aappyy07\n * Handle: aappyy07\n * Date: 16-03-25\n * \"God, I have humbled myself before the court\n    Drop my ego when confidence was my last resort\n    I know, I know He got a plan, I know I'm on Your beams\n    One set of footsteps, You was carryin' me\"\n */\n#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\ntypedef long long ll;\nusing namespace std;\n\n#define DEBUG(x) cout << '>' << #x << ':' << x << endl;\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, a, b) for (int i = (a); i <= (b); i++)\n#define FORD(i, a, b) for (int i = (a); i >= (b); i--)\ninline bool EQ(double a, double b) { return fabs(a - b) < 1e-9; }\n\nconst int INF = 1 << 29;\ntypedef long long ll;\n\ninline int two(int n) { return 1 << n; }\ninline int test(int n, int b) { return (n >> b) & 1; }\ninline void set_bit(int& n, int b) { n |= two(b); }\ninline void unset_bit(int& n, int b) { n &= ~two(b); }\ninline int last_bit(int n) { return n & (-n); }\ninline int ones(int n) {\n    int res = 0;\n    while (n && ++res)\n        n -= n & (-n);\n    return res;\n}\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\ntemplate <typename T>\nvector<T> merge(const vector<T>& left, const vector<T>& right) {\n    vector<T> result;\n    size_t i = 0, j = 0;\n\n    while (i < left.size() && j < right.size()) {\n        if (left[i] <= right[j]) {\n            result.push_back(left[i]);\n            i++;\n        } else {\n            result.push_back(right[j]);\n            j++;\n        }\n    }\n\n    while (i < left.size()) {\n        result.push_back(left[i]);\n        i++;\n    }\n\n    while (j < right.size()) {\n        result.push_back(right[j]);\n        j++;\n    }\n\n    return result;\n}\n\ntemplate <typename T> vector<T> mergeSort(const vector<T>& arr) {\n    if (arr.size() <= 1) {\n        return arr;\n    }\n\n    size_t mid = arr.size() / 2;\n    vector<T> left(arr.begin(), arr.begin() + mid);\n    vector<T> right(arr.begin() + mid, arr.end());\n\n    left = mergeSort(left);\n    right = mergeSort(right);\n\n    return merge(left, right);\n}\nvoid file() {\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n}\nclass Solution {\npublic:\n    string numStr;\n    unordered_map<ll, ll> memo;\n\n    ll calculate(int idx, int bound, int begin, int containsZero, int total,\n                 int count2, int count3, int count5, int count7) {\n        if (idx == numStr.size()) {\n            if (!begin)\n                return 0;\n            if (containsZero)\n                return 1;\n            int result = 1;\n\n            int i = 0;\n            while (i < count2) {\n                result *= 2;\n                i++;\n            }\n\n            i = 0;\n            while (i < count3) {\n                result *= 3;\n                i++;\n            }\n\n            i = 0;\n            while (i < count5) {\n                result *= 5;\n                i++;\n            }\n\n            i = 0;\n            while (i < count7) {\n                result *= 7;\n                i++;\n            }\n\n            return (total != 0 && result % total == 0) ? 1LL : 0LL;\n        }\n        ll hash = 0;\n        hash =\n            ((((((((ll)idx * 2LL + bound) * 2LL + begin) * 2LL + containsZero) *\n                    128LL +\n                total) *\n                   64LL +\n               count2) *\n                  64LL +\n              count3) *\n                 32LL +\n             count5) *\n                32LL +\n            count7;\n\n        return (memo.find(hash) != memo.end())\n                   ? memo[hash]\n                   : memo[hash] =\n                         computeResult(idx, bound, begin, containsZero, total,\n                                       count2, count3, count5, count7);\n    }\n\n    ll computeResult(int idx, int bound, int begin, int containsZero, int total,\n                     int count2, int count3, int count5, int count7) {\n        ll ans = 0;\n        int maxDigit = bound ? numStr[idx] - '0' : 9;\n\n        int digit = 0;\n        while (digit <= maxDigit) {\n            int newBound = bound && (digit == maxDigit);\n\n            if (!begin) {\n                if (digit == 0) {\n                    ans += calculate(idx + 1, newBound, 0, 0, 0, 0, 0, 0, 0);\n                } else {\n                    int newTotal = digit;\n                    int new2 = 0, new3 = 0, new5 = 0, new7 = 0;\n                    int val = digit;\n\n                    int p = 2;\n                    while (p <= 7 && val > 1) {\n                        if (p == 2 || p == 3 || p == 5 || p == 7) {\n                            while (val % p == 0) {\n                                val /= p;\n                                if (p == 2)\n                                    new2++;\n                                else if (p == 3)\n                                    new3++;\n                                else if (p == 5)\n                                    new5++;\n                                else if (p == 7)\n                                    new7++;\n                            }\n                        }\n                        p += (p == 2 ? 1 : 2);\n                    }\n\n                    ans += calculate(idx + 1, newBound, 1, 0, newTotal, new2,\n                                     new3, new5, new7);\n                }\n            } else {\n                if (containsZero) {\n                    ans += calculate(idx + 1, newBound, 1, 1, total + digit, 0,\n                                     0, 0, 0);\n                } else {\n                    if (digit == 0) {\n                        ans += calculate(idx + 1, newBound, 1, 1, total, 0, 0,\n                                         0, 0);\n                    } else {\n                        int newTotal = total + digit;\n                        int new2 = count2, new3 = count3, new5 = count5,\n                            new7 = count7;\n                        int val = digit;\n\n                        int p = 2;\n                        while (p <= 7 && val > 1) {\n                            if (p == 2 || p == 3 || p == 5 || p == 7) {\n                                while (val % p == 0) {\n                                    val /= p;\n                                    if (p == 2)\n                                        new2++;\n                                    else if (p == 3)\n                                        new3++;\n                                    else if (p == 5)\n                                        new5++;\n                                    else if (p == 7)\n                                        new7++;\n                                }\n                            }\n                            p += (p == 2 ? 1 : 2);\n                        }\n\n                        ans += calculate(idx + 1, newBound, 1, 0, newTotal,\n                                         new2, new3, new5, new7);\n                    }\n                }\n            }\n            digit++;\n        }\n        return ans;\n    }\n\n    ll countBeautiful(ll x) {\n        return x < 1 ? 0\n                     : (numStr = to_string(x), memo.clear(),\n                        calculate(0, 1, 0, 0, 0, 0, 0, 0, 0));\n    }\n\n    int beautifulNumbers(int l, int r) {\n        pair<int, int> range = {l, r};\n        return (int)(countBeautiful(r) - countBeautiful((ll)l - 1));\n    }\n};\n/*\n * Author: aappyy07\n * Handle: aappyy07\n * Date: 16-03-25\n * \"God, I have humbled myself before the court\n    Drop my ego when confidence was my last resort\n    I know, I know He got a plan, I know I'm on Your beams\n    One set of footsteps, You was carryin' me\"\n */\n","author":"Anurag Kumar","submissionId":"1575239940"},[]]},{"311":[{"id":"311","fileName":"1575239939.txt","sourceCode":"from functools import lru_cache\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_beautiful(num):\n            digits = list(map(int, str(num)))  # Convert number to digit array\n            n = len(digits)\n\n            @lru_cache(None)\n            def dp(pos, tight, sum_digits, product_digits, has_nonzero):\n                if pos == n:\n                    return 1 if has_nonzero and product_digits % sum_digits == 0 else 0\n\n                limit = digits[pos] if tight else 9\n                total = 0\n\n                for d in range(0, limit + 1):\n                    new_sum = sum_digits + d\n                    new_product = product_digits * d if has_nonzero else d  # Start product correctly\n                    total += dp(pos + 1, tight and (d == limit), new_sum, new_product, has_nonzero or d > 0)\n\n                return total\n\n            return dp(0, True, 0, 1, False)  # Start with sum = 0, product = 1, and no nonzero digits\n\n        return count_beautiful(r) - count_beautiful(l - 1)\n","author":"Sanjeev","submissionId":"1575239939"},[]]},{"312":[{"id":"312","fileName":"1575240441.txt","sourceCode":"\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    string s;\n    unordered_map<string, int> dp;\n\n    int check(int sum, int product) {\n        return (sum > 0 && product % sum == 0);\n    }\n\n    int solve(int pos, int sum, int product, int tight, int leadZero) {\n        if (pos == s.size()) return check(sum, product);\n\n        string key = to_string(pos) + \",\" + to_string(sum) + \",\" + to_string(product) + \",\" + to_string(tight);\n        if (dp.find(key) != dp.end()) return dp[key];\n\n        int limit = (tight) ? (s[pos] - '0') : 9;\n        int count = 0;\n\n        for (int digit = 0; digit <= limit; digit++) {\n            int newSum = sum + digit;\n            int newProduct = (leadZero && digit == 0) ? 1 : product * digit;\n            count += solve(pos + 1, newSum, newProduct, tight && (digit == limit), leadZero && (digit == 0));\n        }\n\n        return dp[key] = count;\n    }\n\n    int countB(int num) {\n        if (num == 0) return 0;\n        dp.clear();\n        s = to_string(num);\n        return solve(0, 0, 1, 1, 1);\n    }\n\n    int beautifulNumbers(int l, int r) {\n        return countB(r) - countB(l - 1);\n    }\n};\n","author":"SleeperGains","submissionId":"1575240441"},[]]},{"313":[{"id":"313","fileName":"1575241189.txt","sourceCode":"class Solution {\npublic:\n    int dp[10][82][82][2]; \n    \n    int solve(string &s, int i, int sum, int product, bool tight, int fixed_sum) {\n        if (sum > fixed_sum) return 0;  \n        \n        if (i == s.size()) {\n            return (sum == fixed_sum && product % fixed_sum == 0);\n        }\n\n        if (dp[i][sum][product][tight] != -1) return dp[i][sum][product][tight];\n\n        int limit = tight ? (s[i] - '0') : 9;\n        int ans = 0;\n\n        for (int digit = 0; digit <= limit; digit++) {\n            int new_product = (sum == 0 && digit == 0) ? 1 : (product * digit) % fixed_sum;  \n            ans += solve(s, i + 1, sum + digit, new_product, tight && (digit == limit), fixed_sum);\n        }\n\n        return dp[i][sum][product][tight] = ans;\n    }\n\n    int countBeautiful(int x) {\n        if (x < 1) return 0;  \n\n        string s = to_string(x);\n        int ans = 0;\n        \n        for (int fixed_sum = 1; fixed_sum <= 81; fixed_sum++) {\n            memset(dp, -1, sizeof(dp)); \n            ans += solve(s, 0, 0, 1, 1, fixed_sum); \n        }\n        \n        return ans;\n    }\n\n    int beautifulNumbers(int l, int r) {\n        return countBeautiful(r) - countBeautiful(l - 1);  \n    }\n};\n","author":"Vivek Katkar","submissionId":"1575241189"},[]]},{"314":[{"id":"314","fileName":"1575240197.txt","sourceCode":"    map<tuple<int, bool, int, int>, int> dp;\nclass Solution {\npublic:\n\n    int digitDP(int pos, bool tight, int sumD, int prodD, string &num, bool nonZeroStarted) {\n        if (pos == num.size()) {\n            return (sumD > 0 && prodD % sumD == 0);\n        }\n\n        tuple<int, bool, int, int> state = {pos, tight, sumD, prodD};\n        if (dp.find(state) != dp.end()) return dp[state];\n\n        int limit = (tight) ? (num[pos] - '0') : 9;\n        int ans = 0;\n\n        for (int d = 0; d <= limit; d++) {\n            bool newTight = tight && (d == limit);\n            int newSum = sumD + d;\n            int newProd = (nonZeroStarted) ? (prodD * d) : d;\n\n            if (!nonZeroStarted && d == 0) {\n                newProd = 1;\n            }\n\n            ans += digitDP(pos + 1, newTight, newSum, newProd, num, nonZeroStarted || (d > 0));\n        }\n\n        return dp[state] = ans;\n    }\n\n    int countBeautiful(int x) {\n        if (x == 0) return 0;\n        string num = to_string(x);\n        dp.clear();\n        return digitDP(0, 1, 0, 1, num, false);\n    }\n\n    int beautifulNumbers(int l, int r) {\n        dp.clear() ; \n        return countBeautiful(r) - countBeautiful(l - 1);\n    }\n};","author":"Abhishek12115047","submissionId":"1575240197"},[]]},{"316":[{"id":"316","fileName":"1575240894.txt","sourceCode":"def create_key(position, is_tight, current_sum, product_modulo, has_leading_zero):\n    return (position, is_tight, current_sum, product_modulo, has_leading_zero)\n\ndef convert(number):\n    digits = []\n    if number == 0:\n        return [0]\n    while number > 0:\n        digits.append(number % 10)\n        number //= 10\n    digits.reverse()\n    return digits\n\ndef f(position, is_tight, current_sum, product_modulo, has_leading_zero, digits, target_sum, cache):\n    if position == len(digits):\n        return 1 if (current_sum == target_sum and product_modulo == 0 and not has_leading_zero) else 0\n    \n    if not has_leading_zero:\n        remaining_digits = len(digits) - position\n        max_addition = 9 * remaining_digits\n        if current_sum > target_sum or current_sum + max_addition < target_sum:\n            return 0\n    \n    key = create_key(position, is_tight, current_sum, product_modulo, has_leading_zero)\n    if key in cache:\n        return cache[key]\n    \n    result = 0\n    upper_limit = digits[position] if is_tight else 9\n    \n    for digit in range(0, upper_limit + 1):\n        new_is_tight = is_tight and (digit == upper_limit)\n        new_has_leading_zero = has_leading_zero and (digit == 0)\n        new_sum = current_sum\n        new_product = product_modulo\n        \n        if has_leading_zero:\n            if digit != 0:\n                new_sum = digit\n                new_product = digit % target_sum\n                new_has_leading_zero = False\n        else:\n            new_sum += digit\n            new_product = (product_modulo * digit) % target_sum\n        \n        if not new_has_leading_zero and new_sum > target_sum:\n            continue\n        \n        result += f(position + 1, new_is_tight, new_sum, new_product, new_has_leading_zero, digits, target_sum, cache)\n    \n    cache[key] = result\n    return result\n\ndef count_beautiful_numbers(number):\n    if number < 0:\n        return 0\n    digits = convert(number)\n    tot = 0\n    \n    for target_sum in range(1, 9 * len(digits) + 1):\n        tot += f(0, True, 0, 1, True, digits, target_sum, {})\n    \n    return tot\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        lower_count = count_beautiful_numbers(l - 1) if l > 0 else 0\n        upper_count = count_beautiful_numbers(r)\n        return upper_count - lower_count if upper_count - lower_count >= 0 else -1","author":"qirunzeng","submissionId":"1575240894"},[]]},{"317":[{"id":"317","fileName":"1575240984.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def beautiful_dp(limit):\n            s = str(limit)\n            n = len(s)\n            @lru_cache(maxsize=None)\n            def dp(pos, tight, started, current_sum, current_product):\n                if pos == n:\n                    return 1 if started and current_sum and current_product % current_sum == 0 else 0\n                res = 0\n                upper = int(s[pos]) if tight else 9\n                for d in range(upper + 1):\n                    new_tight = tight and (d == upper)\n                    if not started:\n                        if d == 0:\n                            res += dp(pos + 1, new_tight, False, 0, 1)\n                        else:\n                            res += dp(pos + 1, new_tight, True, d, d)\n                    else:\n                        res += dp(pos + 1, new_tight, True, current_sum + d, current_product * d)\n                return res\n            return dp(0, True, False, 0, 1)\n        def count_upto(x):\n            return beautiful_dp(x) if x >= 1 else 0\n    \n        return count_upto(r) - count_upto(l - 1)","author":"Max Chang","submissionId":"1575240984"},[]]},{"318":[{"id":"318","fileName":"1575242533.txt","sourceCode":"class Solution {\npublic:\n    unordered_map<string,int>mp;\n    int get(int idx,string& num,int tight,int lead,int sum,int p){\n        if(idx==num.size()){\n            if(sum==0) return 0;\n            return p%sum==0;\n        }\n        string key=to_string(idx)+\"*\"+to_string(tight)+\"*\"+to_string(lead)+\"*\"+to_string(sum)+\"*\"+to_string(p);\n        if(mp.count(key)) return mp[key];\n        int ans=0;\n        int ub=tight?(num[idx]-'0'):9;\n        for(int d=0;d<=ub;d++){\n            if(lead & (d==0)){\n                ans=(ans+get(idx+1,num,tight & (d==ub),1,sum,p));\n            }\n            else\n            {\n                ans=(ans+get(idx+1,num,tight & (d==ub),0,sum+d,(p*d)));\n            }\n        }\n        return mp[key]=ans;\n    }\n    int beautifulNumbers(int l, int r) {\n        mp.clear();\n        string R=to_string(r);\n        string L=to_string(l-1);\n        int ans1=get(0,R,1,1,0,1);\n        mp.clear();\n        int ans2=get(0,L,1,1,0,1);\n        return ans1-ans2;\n    }\n};","author":"Anurag Vaibhav","submissionId":"1575242533"},[]]},{"319":[{"id":"319","fileName":"1575241502.txt","sourceCode":"class Solution {\npublic:\nusing Key = tuple<int, int, int, int, long long>;\n\nmap<Key,long long> dpMemo;\n \nstring s;\nlong long dp(int pos, int tight, int started, int sum, long long prod) {\n    if (pos == s.size()) {\n        if (started && sum > 0 && (prod % sum == 0))\n            return 1;\n        return 0;\n    }\n \n    Key state = make_tuple(pos, tight, started, sum, prod);\n    if (dpMemo.find(state) != dpMemo.end())\n        return dpMemo[state];\n \n    long long res = 0;\n    int limit = tight ? (s[pos] - '0') : 9;\n    for (int d = 0; d <= limit; d++) {\n        int ntight = (tight && (d == limit)) ? 1 : 0;\n        int nstarted = started;\n        int nsum = sum;\n        long long nprod = prod;\n \n        if (!started) {\n            if (d == 0) {\n            } else {\n                nstarted = 1;\n                nsum = d;\n                nprod = d;\n            }\n        } else {\n            nsum += d;\n            nprod *= d;\n        }\n \n        res += dp(pos + 1, ntight, nstarted, nsum, nprod);\n    }\n \n    dpMemo[state] = res;\n    return res;\n}\n\n int beautifulNumbers(int l, int r) {\n         long long ans1=0,ans2=0;\n         s=to_string(r);\n         ans1=dp(0,1,0,0,1);\n         dpMemo.clear();\n         s=to_string(l-1);\n         ans2=dp(0,1,0,0,1);\n        return ans1-ans2;\n    }\n};","author":"SUPERMAN44","submissionId":"1575241502"},[]]},{"320":[{"id":"320","fileName":"1575242054.txt","sourceCode":"import sys\nsys.setrecursionlimit(10000)\nfrom functools import lru_cache\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        \n        def cb(x):\n            digits = list(map(int, str(x)))\n            n = len(digits)\n            \n            @lru_cache(maxsize=None)\n            def dp(pos, tight, started, s, prod, has_zero):\n    \n                if pos == n:\n                    if not started:\n                        return 0\n                    if has_zero:\n                        return 1\n                    return 1 if prod % s == 0 else 0\n                \n                total = 0\n                limit = digits[pos] if tight else 9\n                for d in range(limit + 1):\n                    new_tight = tight and (d == limit)\n                    if not started:\n                        if d == 0:\n                            total += dp(pos + 1, new_tight, False, 0, 1, False)\n                        else:\n                            total += dp(pos + 1, new_tight, True, d, d, False)\n                    else:\n                        new_s = s + d\n                        if has_zero or d == 0:\n                            total += dp(pos + 1, new_tight, True, new_s, 0, True)\n                        else:\n                            total += dp(pos + 1, new_tight, True, new_s, prod * d, False)\n                return total\n    \n            return dp(0, True, False, 0, 1, False)\n    \n        result = cb(r) - cb(l - 1)\n        return result","author":"That Panda","submissionId":"1575242054"},[]]},{"321":[{"id":"321","fileName":"1575241971.txt","sourceCode":"class Solution {\npublic:\n    int dp[83][83][10][2][2];\n    \n    int f(string& s,int rem, int sum,int p=1,int i=0,bool high = 1, bool zero = 1) {\n        \n        if(rem < 0) {\n            return 0;\n        }\n        \n        if(i == s.size()) {\n            if(rem == 0 && p%sum == 0) {\n                return 1;\n            }\n            return 0;\n        }\n        \n        if(dp[rem][p][i][high][zero] != -1) {\n            return dp[rem][p][i][high][zero];\n        }\n        \n        int start = 0;\n        int end = (high == 1 ? s[i] - '0' : 9);\n        int cnt = 0;\n        \n        for(int j = start; j <= end;j++) {\n            bool newHigh = (high && (j==end));\n            bool newZero = (zero && j==0);\n            \n            int p1 = newZero ? 1 : (p*j)%sum;\n            \n            cnt += f(s,rem-j,sum,p1,i+1,newHigh, newZero);\n        }\n        return dp[rem][p][i][high][zero] = cnt;\n    }\n    \n    int beautifulNumbers(int l, int r) {\n        string s = to_string(r);\n        string t = to_string(l-1);\n        int ans = 0;\n        \n        for(int i=1;i<=81;i++) {\n            \n            memset(dp, -1,sizeof(dp));\n            ans += f(s,i,i);\n            \n            memset(dp, -1,sizeof(dp));\n            ans -= f(t,i,i);\n        }\n        return ans;\n    }\n};","author":"Yuu","submissionId":"1575241971"},[]]},{"322":[{"id":"322","fileName":"611235760.txt","sourceCode":"class Solution {\npublic:\n    int d[11], top, f[11][91][91];\n    void split(int x) {\n        top = 0;\n        for(; x; x /= 10) d[++top] = x % 10;\n    }\n    int dfs(int u, int sum, int rem, int mul, bool is0, bool lim) {\n        if(u == 0) return rem == 0 && mul == 0;\n        if(!is0 && !lim && f[u][rem][mul] != -1) return f[u][rem][mul];\n        int now = 0, k = lim ? d[u] : 9;\n        for(int c = 0; c <= k; ++c) {\n            if(c > rem) break;\n            int nxt_rem = rem - c;\n            int nxt_mul = ((is0 && c == 0) ? 1 : (mul * c)) % sum;\n            now += dfs(u - 1, sum, nxt_rem, nxt_mul, is0 && c == 0, lim && c == k);\n        }\n        if(!is0 && !lim) f[u][rem][mul] = now;\n        return now;\n    }\n    int calc(int x, int sum) {\n        split(x);\n        for(int i = 0; i <= top; ++i) {\n            for(int j = 0; j <= sum; ++j) {\n                for(int k = 0; k <= sum; ++k) {\n                    f[i][j][k] = -1;\n                }\n            }\n        }\n        return dfs(top, sum, sum, 1, true, true);\n    }\n    int beautifulNumbers(int l, int r) {\n        int ans = 0;\n        for(int i = 1; i <= 81; ++i) {\n            ans += calc(r, i) - calc(l - 1, i);\n        }\n        return ans;\n    }\n};","author":"rui_er","submissionId":"611235760"},[]]},{"323":[{"id":"323","fileName":"611240413.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n\n        def gao(n: int) -> int:\n            ds = list(map(int, str(n)))\n            N = len(ds)\n\n            @cache\n            def dp(pos, tight, started, s, p):\n                if pos == N:\n                    if not started:\n                        return 0\n                    return 1 if s > 0 and p % s == 0 else 0\n                limit = ds[pos] if tight else 9\n                res = 0\n                for d in range(limit + 1):\n                    nxt_lim = tight and (d == limit)\n                    if not started:\n                        if d == 0:\n                            res += dp(pos + 1, nxt_lim, False, 0, 1)\n                        else:\n                            res += dp(pos + 1, nxt_lim, True, d, d)\n                    else:\n                        res += dp(pos + 1, nxt_lim, True, s + d, p * d)\n                return res\n\n            return dp(0, True, False, 0, 1)\n\n        return gao(r) - gao(l - 1)","author":"不造轮子","submissionId":"611240413"},[]]},{"324":[{"id":"324","fileName":"611240680.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_beautiful(x: int) -> int:\n            s = str(x)\n            n = len(s)\n            @lru_cache(maxsize=None)\n            def dp(pos, v, p, sum, prod):\n                if pos == n:\n                    return 1 if p and (prod % sum == 0) else 0\n                j = int(s[pos]) if v else 9\n                t = 0\n                for d in range(j + 1):\n                    nt = v and (d == j)\n                    if not p:\n                        if d == 0:\n                            t += dp(pos + 1, nt, False, 0, 1)\n                        else:\n                            t += dp(pos + 1, nt, True, d, d)\n                    else:\n                        t += dp(pos + 1, nt, True, sum + d, prod * d)\n                return t\n            return dp(0, True, False, 0, 1)\n        return count_beautiful(r) - count_beautiful(l - 1)\n","author":"mywaythere","submissionId":"611240680"},[]]},{"325":[{"id":"325","fileName":"611235860.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def calc(n):\n            t = str(n)\n            @cache\n            def dfs(i, ishigh, isnum, p, s):\n                if i == len(t):\n                    return s != 0 and p % s == 0\n                ans = 0\n                hi = 9\n                if ishigh:\n                    hi = int(t[i])\n                for d in range(hi + 1):\n                    if d == 0 and not isnum:\n                        ans += dfs(i + 1, ishigh and d == hi, False, 1, 0)\n                    else:\n                        ans += dfs(i + 1, ishigh and d == hi, isnum or d != 0, p * d, s + d)\n                return ans\n            return dfs(0, True, False, 1, 0)\n        return calc(r) - calc(l - 1)\n        ","author":"一只包zi","submissionId":"611235860"},[]]},{"328":[{"id":"328","fileName":"611240546.txt","sourceCode":"package main\n\nimport \"strconv\"\n\n// https://space.bilibili.com/206214\nfunc beautifulNumbers(low int, high int) (ans int) {\n\tlowS := strconv.Itoa(low)\n\thighS := strconv.Itoa(high)\n\tn := len(highS)\n\tdiffLH := n - len(lowS)\n\t\n\tfor tar := 1; tar <= n*9; tar++ {\n\t\tmemo := make([][][]int, n)\n\t\tfor i := range memo {\n\t\t\tmemo[i] = make([][]int, tar)\n\t\t\tfor j := range memo[i] {\n\t\t\t\tmemo[i][j] = make([]int, tar+1)\n\t\t\t\tfor k := range memo[i][j] {\n\t\t\t\t\tmemo[i][j][k] = -1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar dfs func(int, int, int, bool, bool) int\n\t\tdfs = func(i, mul, s int, limitLow, limitHigh bool) (res int) {\n\t\t\tif s > tar {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif i == n {\n\t\t\t\tif s != tar || mul%s > 0 {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn 1\n\t\t\t}\n\t\t\tif !limitLow && !limitHigh {\n\t\t\t\tdv := &memo[i][mul][s]\n\t\t\t\tif *dv >= 0 {\n\t\t\t\t\treturn *dv\n\t\t\t\t}\n\t\t\t\tdefer func() { *dv = res }()\n\t\t\t}\n\n\t\t\tlo := 0\n\t\t\tif limitLow && i >= diffLH {\n\t\t\t\tlo = int(lowS[i-diffLH] - '0')\n\t\t\t}\n\t\t\thi := 9\n\t\t\tif limitHigh {\n\t\t\t\thi = int(highS[i] - '0')\n\t\t\t}\n\n\t\t\td := lo\n\t\t\tif limitLow && i < diffLH {\n\t\t\t\tres = dfs(i+1, mul, 0, true, false)\n\t\t\t\td++\n\t\t\t}\n\t\t\tfor ; d <= hi; d++ {\n\t\t\t\tres += dfs(i+1, mul*d%tar, s+d, limitLow && d == lo, limitHigh && d == hi)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tres := dfs(0, 1%tar, 0, true, true)\n\t\tans += res\n\t}\n\t\n\treturn\n}\n","author":"灵茶山艾府","submissionId":"611240546"},[]]},{"330":[{"id":"330","fileName":"611241826.txt","sourceCode":"import string\nfrom sortedcontainers import SortedList\nfrom collections import defaultdict, deque, Counter\nfrom bisect import bisect_left, bisect_right\nfrom typing import List, Set, Tuple, Optional\nfrom itertools import pairwise, permutations, combinations, groupby\nfrom heapq import heappush, heappop\nfrom random import shuffle\nfrom functools import cmp_to_key, lru_cache\nfrom fractions import Fraction\nfrom math import gcd, lcm\n\nrecord = {}\n\n\ndef core(n: int):\n    if n in record.keys():\n        return record[n]\n\n    a = list(map(int, str(n)))\n    m = len(a)\n    f = [[defaultdict(int), defaultdict(int)] for _ in range(m)]\n    for i in range(1, a[0]):\n        f[0][0][i, i] = 1\n    f[0][1][a[0], a[0]] = 1\n    for i in range(m - 1):\n        for (s, m), val in f[i][0].items():\n            for d in range(10):\n                f[i + 1][0][s + d, m * d] += val\n        for (s, m), val in f[i][1].items():\n            for d in range(a[i + 1]):\n                f[i + 1][0][s + d, m * d] += val\n            d = a[i + 1]\n            f[i + 1][1][s + d, m * d] += val\n    ans = 0\n    for mp in f[-1]:\n        for (s, m), val in mp.items():\n            if m % s == 0:\n                ans += val\n    record[n] = ans\n    return ans\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def solve(n) -> int:\n            if n == 0:\n                return 0\n            s = str(n)\n            m = len(s)\n            ans = 0\n            for i in range(1, m):\n                ans += core(10 ** i - 1)\n            ans += core(n)\n            return ans\n\n        return solve(r) - solve(l - 1)\n","author":"Ujimatsu_Chiya","submissionId":"611241826"},[]]},{"331":[{"id":"331","fileName":"611234230.txt","sourceCode":"constexpr int N = 100;\nconstexpr int MOD = 1e9 + 7;\nconstexpr int ALPHA_SIZE = 10, MIN_ALPHA = '0';\nlong long dp[N][ALPHA_SIZE][2][2];\nlong long solve(const vector<int>& digits) {\n    fill(&dp[0][0][0][0], &dp[N - 1][ALPHA_SIZE - 1][1][1] + 1, -1LL);\n    int n = digits.size();\n    const auto dfs = [&](const auto& dfs, int i, int c, bool eq,\n                         bool nonzero) -> long long {\n        if (i == n) {\n            return nonzero;\n        }\n        if (dp[i][c][eq][nonzero] != -1) {\n            return dp[i][c][eq][nonzero];\n        }\n        int lim = eq ? digits[i] : ALPHA_SIZE - 1;\n        long long res = 0;\n        for (int d = 0; d <= lim; ++d) {\n            res += dfs(dfs, i + 1, d, eq && d == lim, nonzero || d > 0);\n        }\n        return dp[i][c][eq][nonzero] = res;\n    };\n    return dfs(dfs, 0, 0, true, false);\n}\nvector<int> get_digits(const string& x) {\n    vector<int> digits;\n    for (auto c : x) {\n        digits.push_back(c - MIN_ALPHA);\n    }\n    return digits;\n}\nvector<int> get_digits(long long x) {\n    vector<int> digits;\n    while (x > 0) {\n        digits.push_back(x % ALPHA_SIZE);\n        x /= ALPHA_SIZE;\n    }\n    reverse(digits.begin(), digits.end());\n    return digits;\n}\nvector<int> subtract_one(vector<int> digits) {\n    int n = digits.size(), i = n - 1;\n    for (; i >= 0; --i) {\n        if (digits[i] != 0) {\n            break;\n        }\n    }\n    --digits[i++];\n    for (; i < n; ++i) {\n        digits[i] = ALPHA_SIZE - 1;\n    }\n    return digits;\n}\ntemplate <typename T> long long perform_dp(const T& high, const T& low) {\n    auto parsed_high = get_digits(high), parsed_low = get_digits(low);\n    auto high_count = solve(parsed_high);\n    auto need_low = any_of(parsed_low.begin(), parsed_low.end(),\n                           [&](auto x) { return x != MIN_ALPHA; });\n    auto low_count = need_low ? solve(subtract_one(parsed_low)) : 0;\n    return high_count - low_count;\n}\nvector<int> get_digits_ll(long long x) {\n    vector<int> digits;\n    while (x > 0) {\n        digits.push_back(x % 10);\n        x /= 10;\n    }\n    if (digits.empty())\n        digits.push_back(0);\n    reverse(digits.begin(), digits.end());\n    return digits;\n}\nstruct state_hash {\n    size_t operator()(const array<int, 6>& s) const {\n        size_t res = 0;\n        for (auto v : s) {\n            res = res * 31u + (unsigned)v;\n        }\n        return res;\n    }\n};\nunordered_map<array<int, 6>, long long, state_hash> memo;\nlong long dp_dfs(int pos, int tight, int started, int has_zero, int sum,\n                 int prod, const vector<int>& digits) {\n    if (pos == digits.size()) {\n        if (!started)\n            return 0;\n        if (has_zero)\n            return 1;\n        return (prod % sum == 0) ? 1 : 0;\n    }\n    array<int, 6> st = {pos, tight, started, has_zero, sum, prod};\n    if (memo.find(st) != memo.end())\n        return memo[st];\n    int lim = tight ? digits[pos] : 9;\n    long long res = 0;\n    for (int d = 0; d <= lim; d++) {\n        int ntight = (tight && d == lim);\n        int nstarted = started || (d > 0);\n        int nhas_zero = has_zero;\n        int nsum = sum;\n        int nprod = prod;\n        if (!started) {\n            if (d == 0) {\n                res += dp_dfs(pos + 1, ntight, nstarted, nhas_zero, nsum, nprod,\n                              digits);\n            } else {\n                nsum = d;\n                nprod = d;\n                res += dp_dfs(pos + 1, ntight, 1, 0, nsum, nprod, digits);\n            }\n        } else {\n            if (has_zero) {\n                res += dp_dfs(pos + 1, ntight, 1, 1, 0, 0, digits);\n            } else {\n                if (d == 0) {\n                    nhas_zero = 1;\n                    res += dp_dfs(pos + 1, ntight, 1, 1, 0, 0, digits);\n                } else {\n                    nsum = sum + d;\n                    nprod = prod * d;\n                    res += dp_dfs(pos + 1, ntight, 1, 0, nsum, nprod, digits);\n                }\n            }\n        }\n    }\n    memo[st] = res;\n    return res;\n}\nlong long count_beautiful(long long x) {\n    if (x <= 0)\n        return 0;\n    vector<int> digits = get_digits_ll(x);\n    memo.clear();\n    return dp_dfs(0, 1, 0, 0, 0, 1, digits);\n}\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        long long res = count_beautiful(r) - count_beautiful(l - 1);\n        return res;\n    }\n};","author":"farmer","submissionId":"611234230"},[]]},{"332":[{"id":"332","fileName":"611245289.txt","sourceCode":"#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#include \"algo/debug_lc.h\"\n#else\n#define debug(...) 42\n#endif\n\nusing namespace std;\n\nint __fast_io__ = []() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    return 0;\n}();\n\nconstexpr int N = 105;\nlong long dp1[12][82][82][82], dp2[12][82], A[N];\n\nlong long dfs(int pos, int pre1, int pre2, int sum, bool is_limit, bool is_valid) {\n    if (pos < 0)\n        return is_valid && !pre1 && pre2 == sum;\n    long long &val = is_valid ? dp1[pos][sum][pre1][pre2] : dp2[pos][sum];\n    if (!is_limit && val != -1)\n        return val;\n    long long ret = 0;\n    if (!is_valid)\n        ret += dfs(pos - 1, 1, 0, sum, 0, 0);\n\n    // 这里改成想要的样子\n    for (int cur = 0; cur < 10; ++cur) {\n        if (is_valid || !is_valid && cur) {\n            if (is_limit && cur > A[pos])\n                break;\n            ret += dfs(pos - 1, pre1 * cur % sum, pre2 + cur, sum, is_limit && cur == A[pos], true);\n        }\n    }\n\n    if (!is_limit)\n        val = ret;\n    return ret;\n}\n\nauto __init_digit_dp__ = ([]() -> int {\n    memset(dp1, -1, sizeof dp1);\n    memset(dp2, -1, sizeof dp2);\n    return 1;\n})();\n\nstring prev_number(string s, char low = '0', char high = '9') {\n    reverse(s.begin(), s.end());\n    for (auto &c : s) {\n        if (c != low) {\n            --c;\n            break;\n        } else {\n            c = high;\n        }\n    }\n    reverse(s.begin(), s.end());\n    return s;\n}\n\nlong long f(string s, int sum) {\n    reverse(s.begin(), s.end());\n    for (int i = 0; i < s.size(); ++i)\n        A[i] = s[i] - '0';\n    return dfs(s.size() - 1, 1, 0, sum, true, false);\n}\n\nlong long f(int x, int s) {\n    if (!x)\n        return 0;\n    return f(to_string(x), s);\n}\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        int ans = 0;\n        for (int s = 1; s <= 81; ++s)\n            ans += int(f(r, s) - f(l - 1, s));\n        return ans;\n    }\n};\n\n#ifdef LOCAL\n\nint main() {\n    int T;\n    string s;\n    getline(cin, s);\n    T = stoi(s);\n    while (T--) {\n        Solution sol;\n        test<int, int>(sol, &Solution::beautifulNumbers);\n    }\n    return 0;\n}\n\n#endif\n","author":"5cm/s 🌸","submissionId":"611245289"},[]]},{"333":[{"id":"333","fileName":"611243922.txt","sourceCode":"MX = 90\nmemo = [[[[-1] * target for _ in range(target+1)] for _ in range(10)] for target in range(90)]\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        hidigits = list(map(int, str(r)))\n        n = len(hidigits)\n        lodigits = list(map(int, str(l).zfill(n)))\n        def dfs(target, i, s, p, lolim, hilim):\n            if s > target:\n                return 0\n            if i == -1:\n                return s == target and p == 0\n            if not lolim and not hilim and memo[target][i][s][p] != -1:\n                return memo[target][i][s][p]\n            res = 0\n            lod = lodigits[n-1-i] if lolim else 0\n            hid = hidigits[n-1-i] if hilim else 9\n            for d in range(lod, hid+1):\n                res += dfs(target, i-1, s+d, (p*d)%target if s or d else 1, lolim and d == lod, hilim and d == hid)\n            if not lolim and not hilim:\n                memo[target][i][s][p] = res\n            return res\n\n        ans = 0\n        for target in range(1, n*9+1):\n            ans += dfs(target, n-1, 0, 1, True, True)\n        return ans","author":"FatalError","submissionId":"611243922"},[]]},{"334":[{"id":"334","fileName":"611245321.txt","sourceCode":"const int N = 90;\nint dp[10][N][N][N];\nint len, val[10];\n\nauto init = [](){\n    memset(dp, -1, sizeof(dp));\n    return 0;\n}();\n\nint solve(int p, bool limit, int s, int f, int m){\n    if(p < 0){\n        if(s == m && f == 0){\n            return 1;\n        }\n        return 0;\n    }\n    if(s > m){\n        return 0;\n    }\n    if(!limit && f != -1 && dp[p][s][f][m] != -1){\n        return dp[p][s][f][m];\n    }\n    int ret = 0;\n    for(int i=0; i<10; ++i){\n        if(limit && i > val[p])  continue;\n        int g;\n        if(f == -1){\n            if(i == 0)  g = -1;\n            else  g = i % m;\n        } else {\n            g = f * i % m;\n        }\n        ret += solve(p - 1, limit && i == val[p], s + i, g, m);\n    }\n    if(!limit && f != -1){\n        dp[p][s][f][m] = ret;\n    }\n    return ret;\n}\n\nint query(int v){\n    if(v == 0)  return 0;\n    len = 0;\n    while(v > 0){\n        val[len++] = v % 10;\n        v /= 10;\n    }\n    int ans = 0;\n    for(int i=1; i<=81; ++i){\n        ans += solve(len - 1, 1, 0, -1, i);\n    }\n    return ans;\n}\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        return query(r) - query(l - 1);\n    }\n};","author":"Hongrock","submissionId":"611245321"},[]]},{"335":[{"id":"335","fileName":"611244824.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        res=0\n        s=\"\"\n        now=0\n        @cache\n        def dfs(i:int,limit:bool,num:bool,a:int,b:int)->int:\n            if b<0 or b-9*(len(s)-i)>0:return 0\n            if i==len(s):\n                if a==0 and b==0:return 1\n                else:return 0\n            res=0\n            if not num:\n                res=dfs(i+1,False,False,-1,b)\n            up = int(s[i]) if limit else 9\n            di=0\n            if not num:di=1\n            for d in range(di,up+1):\n                if a==-1:res+=dfs(i+1,limit and d==up,True,(d)%now,b-d)\n                else:res+=dfs(i+1,limit and d==up,True,(d*a)%now,b-d)\n            return res\n        \n        for i in range(1,82):#90\n            s=str(r)\n            now=i\n            res+=dfs(0,True,False,-1,i)\n            dfs.cache_clear()\n            now=i\n            s=str(l-1)\n            if l-1>=1:\n                res-=dfs(0,True,False,-1,i)\n                dfs.cache_clear()\n            \n        return res","author":"zouyu","submissionId":"611244824"},[]]},{"336":[{"id":"336","fileName":"611245735.txt","sourceCode":"import java.util.Arrays;\n\nclass Solution {\n    public int beautifulNumbers(int l, int r) {\n        int res=0;\n        char[] sr = String.valueOf(r).toCharArray();\n        char[]sl1 = String.valueOf(l-1).toCharArray();\n        for(int sum = 1; sum<=81 && sum<=9*sr.length; ++sum){\n            res += help(sr, r, sum) - help(sl1, l-1, sum);\n        }\n\n        return res;\n    }\n    int N = 82;\n    // i 位 剩余j 需要k倍数\n    int[][][] memo = new int[10][N][N];\n    int help(char[]sl, int l, int sum){\n        if(l==0)return 0;\n        for (int[][] m1 : memo) {\n            for (int[] m2 : m1) {\n                Arrays.fill(m2, -1);\n            }\n        }\n\n        return dp(sl,l, sum, 0, sum, true, true);\n    }\n    int dp(char[]sl, int l, int sum, int index, int mul,\n           boolean first, boolean limit){\n        int n = sl.length;\n        // mul记录还需要的倍数\n        if(index==n){\n            if(mul==1 && sum==0){\n                return 1;\n            }\n            return 0;\n        }\n        // 后面全0\n        if(sum==0){\n            return 1;\n        }\n        if(!first && !limit &&memo[index][sum][mul]!=-1)return memo[index][sum][mul];\n\n        int res=0;\n\n        int up = limit ? sl[index]-'0' :9;\n\n        for(int i=0;i<=up && i<=sum;++i){\n            int nMul = mul;\n            if(i==0){\n                if(!first)nMul = 1;\n            }else{\n                if(nMul>1)nMul /= gcd(mul, i);\n            }\n\n            res += dp(sl, l,sum-i,index+1, nMul,\n                    first&&i==0,limit&&i==up);\n\n        }\n\n        return memo[index][sum][mul] = res;\n    }\n\n    int gcd(int a, int b){\n        while(b!=0){\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}","author":"nickname","submissionId":"611245735"},[]]},{"337":[{"id":"337","fileName":"611245941.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        r=str(r)\n        l=str(l-1)\n        @cache\n        def fun(s,pos,pre_x,pre_add,is_limit,is_num):\n            if pos==len(s):\n                if not is_num:return 0\n                if pre_x%pre_add==0:return 1\n                return 0\n            res=0\n            up=(ord(s[pos])-ord('0')) if is_limit else 9\n            for i in range(up+1):\n                if False if i==0 and (not is_num) else True:\n                    temp=pre_x*i\n                else:\n                    temp=1\n                res+=fun(s,pos+1,temp,pre_add+i,True if is_limit and i==up else False,False if i==0 and (not is_num) else True)\n            return res\n        return fun(r,0,1,0,1,0)-fun(l,0,1,0,1,0)\n                ","author":"audience","submissionId":"611245941"},[]]},{"338":[{"id":"338","fileName":"611246156.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        r = str(r)\n        n = len(r)\n        l = str(l).zfill(n)\n        @cache\n        def dfs(i: int, pre_pro: int, pre_sum: int, is_num: bool, is_min: bool, is_max: bool):\n            if i == n:\n                return int(pre_pro % pre_sum == 0)\n            res = 0\n            d_min = int(l[i]) if is_min else 0\n            d_max = int(r[i]) if is_max else 9\n            for d in range(d_min, d_max + 1):\n                res += dfs(i + 1, pre_pro * (d if is_num or d > 0 else 1), pre_sum + d, is_num or d > 0, is_min and d == d_min, is_max and d == d_max)\n            return res\n        return dfs(0, 1, 0, False, True, True)","author":"DBaker","submissionId":"611246156"},[]]},{"339":[{"id":"339","fileName":"611246210.txt","sourceCode":"//#define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const multiset<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntemplate <class T> auto vect(const T& v, int n) { return vector<T>(n, v); }\ntemplate <class T, class... D> auto vect(const T& v, int n, D... m) {\n  return vector<decltype(vect(v, m...))>(n, vect(v, m...));\n}\n\nusing int64 = long long;\nusing int128 = __int128_t;\nusing ii = pair<int, int>;\n#define SZ(x) (int)((x).size())\ntemplate <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nmt19937_64 mrand(random_device{}());\nint64 rnd(int64 x) { return mrand() % x; }\nconstexpr inline int lg2(int64 x) { return x == 0 ? -1 : sizeof(int64) * 8 - 1 - __builtin_clzll(x); }\nconstexpr inline int64 p2ceil(int64 x) { return 1LL << (lg2(x - 1) + 1); }\ntemplate <class T> void out(const vector<T>& a) { for (int i = 0; i < SZ(a); ++i) cout << a[i] << \" n\"[i + 1 == SZ(a)]; }\ntemplate <class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate <class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\ntemplate <class T> void dedup(vector<T>& v) { sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); }\ninline void add_mod(int& x, int y) { x += y; if (x >= MOD) x -= MOD; }\ninline void sub_mod(int& x, int y) { x += MOD - y; if (x >= MOD) x -= MOD; }\ninline int mod(int x) { return x >= MOD ? x - MOD : x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nconst int M = 10;\nconst int S = 82;\nint dp[M][2][S][S];\n\nclass Solution {\npublic:\n    int beautifulNumbers(int L, int R) {\n        int ret = 0;\n        for (int s = 1; s <= 81; ++s) {\n            auto solve = [&](int n) {\n                if (n == 0) return 0;\n                vector<int> digit;\n                for (int t = n; t; t /= 10) digit.push_back(t % 10);\n                reverse(digit.begin(), digit.end());\n                int m = digit.size();\n                for (int i = 0; i < m; ++i) {\n                  for (int j = 0; j < 2; ++j) {\n                    for (int u = 0; u <= s; ++u) {\n                      for (int v = 0; v < s; ++v) {\n                        dp[i][j][u][v] = -1;\n                      }\n                    }\n                  }\n                }\n                // auto dp = vect<int>(-1, m, 2, s + 1, s);\n                function<int(int, int, int, int)> rec =\n                    [&](int pos, int tight, int sum, int r) -> int {\n                      // trace(pos, tight, sum, r, m, digit);\n                    if ((m - pos) * 9 + sum < s) return 0;\n                    if (pos == m) return sum == s && r == 0;\n                    int& ret = dp[pos][tight][sum][r];\n                    // trace(pos, ret);\n                    if (ret >= 0) return ret;\n                    ret = 0;\n                    for (int x = 0; x < 10; ++x) {\n                        if (tight && x > digit[pos]) continue;\n                        int nsum = sum + x;\n                        int nr = x > 0 ? (r * x) % s : (sum == 0 ? r : 0);\n                        int ntight = tight && (x == digit[pos]);\n                        // trace(x, nsum, nr, ntight);\n                        if (nsum > s) continue;\n                        // trace(x, nsum, nr, ntight);\n                        ret += rec(pos + 1, ntight, nsum, nr);\n                    }\n                    return ret;\n                };\n                int ret = rec(0, 1, 0, 1 % s);\n                // if (ret) trace(n, s, digit, ret);\n                return ret;\n            };\n            ret += solve(R) - solve(L - 1);\n        }\n        return ret;\n    }\n};\n\n","author":"cuiaoxiang","submissionId":"611246210"},[]]},{"340":[{"id":"340","fileName":"611246598.txt","sourceCode":"typedef unordered_map<int, unordered_map<int, int>> Mp;\nunordered_map<int, unordered_map<int, Mp>> jyh;\nclass Solution {\n    int Sum(const Mp& last) {\n        int res = 0;\n        for (const auto& [he, mp] : last) {\n            for (const auto& [ji, x] : mp) {\n                if (he && ji % he == 0) {\n                    res += x;\n                }\n            }\n        }\n        return res;\n    }\n    // he and ji\n    Mp Btf(int n, int wei) {\n        if (wei == -1) {\n            return {{0, {{1, 1}}}};\n        }\n        auto& res = jyh[n][wei];\n        if (res.size()) {\n            return res;\n        }\n        int base = pow(10, wei) + 0.5;\n        int cur = n / base;\n        Mp last = Btf(n % base, wei - 1);\n        // cout << n << ',' << wei << ',' << base << ',' << cur << endl;\n        for (const auto& [he, mp] : last) {\n            for (const auto& [ji, x] : mp) {\n                res[he + cur][ji * cur] += x;\n            }\n        }\n        if (cur > 0) {\n            Mp last9 = Btf(base - 1, wei - 1);\n            for (const auto& [he, mp] : last9) {\n                for (const auto& [ji, x] : mp) {\n                    for (int i = 0; i < cur; i++) {\n                        res[he + i][ji * i] += x;\n                    }\n                }\n            }\n        }\n        // cout << n << ',' << wei << ':' << endl;\n        // for (const auto& [he, mp] : res) {\n        //     for (const auto& [ji, x] : mp) {\n        //         cout << he << ',' << ji << ',' << x << endl;\n        //     }\n        // }\n        return res;\n    }\n    int Beautiful(int n) {\n        int base = 1;\n        int wei = 0;\n        int res = 0;\n        while (true) {\n            if (base * 10 > n) {\n                res += Sum(Btf(n, wei)) - Sum(Btf(base - 1, wei));\n                return res;\n            }\n            res += Sum(Btf(base * 10 - 1, wei)) - Sum(Btf(base - 1, wei));\n            wei++;\n            base *= 10;\n        }\n    }\n\npublic:\n    int beautifulNumbers(int l, int r) {\n        return Beautiful(r) - Beautiful(l - 1);\n    }\n};","author":"Hack_Others","submissionId":"611246598"},[]]},{"341":[{"id":"341","fileName":"611243329.txt","sourceCode":"unordered_map<long long, int> f;\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        auto calcMsk = [&](int pos, int prod, int sm) {\n            long long ret = pos;\n            ret = ret * ((long long) 1e9) + prod;\n            ret = ret * 100 + sm;\n            return ret;\n        };\n\n        vector<int> A;\n        auto dp = [&](this auto &&dp, int pos, int prod, int sm, bool full) {\n            if (pos < 0) {\n                if (sm == 0) return 0;\n                return prod % sm == 0 ? 1 : 0;\n            }\n            long long msk = calcMsk(pos, prod, sm);\n            if (!full && f.count(msk)) return f[msk];\n            int ret = 0;\n\n            int R = (full ? A[pos] : 9);\n            for (int i = 0; i <= R; i++) {\n                int nxtProd = prod * i;\n                if (sm == 0 && i == 0) nxtProd = prod;\n                ret += dp(pos - 1, nxtProd, sm + i, full && i == R);\n            }\n            if (!full) f[msk] = ret;\n            return ret;\n        };\n\n        auto gao = [&](int x) {\n            if (x == 0) return 0;\n            A.clear();\n            for (; x; x /= 10) A.push_back(x % 10);\n            return dp(A.size() - 1, 1, 0, true);\n        };\n        return gao(r) - gao(l - 1);\n    }\n};","author":"TsReaper","submissionId":"611243329"},[]]},{"343":[{"id":"343","fileName":"611247442.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        high = str(r)\n        n = len(high)\n        low = str(l)\n        low = '0' * (n - len(low)) + low\n        diff = len(str(r)) - len(str(l))\n\n        @cache\n        def dfs(i: int, limit_hi: bool, limit_lo: bool, valid: bool, n1: int, n2: int) -> int:\n            if i == n:\n                return n1 % n2 == 0 and valid\n\n            lo = int(low[i]) if limit_lo else 0\n            up = int(high[i]) if limit_hi else 9\n\n            res = 0\n            for x in range(lo, up + 1):\n                res += dfs(i + 1, limit_hi and x == up, limit_lo and x == lo, valid or x != 0, n1 * x if valid or x != 0 else n1, n2 + x)\n            return res\n\n        return dfs(0, True, True, False, 1, 0)","author":"magiccircle","submissionId":"611247442"},[]]},{"344":[{"id":"344","fileName":"611247400.txt","sourceCode":"class Solution {\npublic:\n  int top, num[12];\n  int m;\n  int dp[12][82][82][2][2];\n  bool vis[12][82][82][2][2];\n  int dfs(int now, int x, int s, bool up, bool zz) {\n    if (now == 0) {\n      return x == 0 && s == 0;\n    }\n    if (vis[now][x][s][up][zz])\n      return dp[now][x][s][up][zz];\n    vis[now][x][s][up][zz] = true;\n    int &ans = dp[now][x][s][up][zz];\n    ans = 0;\n    int lim = up ? num[now] : 9;\n    for (int j = 0; j <= lim && j <= s; ++j) {\n      ans = (ans + dfs(now - 1, (zz || j) ? x * j % m : x, s - j,\n                       up && j == lim, zz || (j != 0)));\n    }\n    return ans;\n  }\n  int sol(int xx) {\n    int x = xx;\n    int ans = 0;\n    top = 0;\n    while (x) {\n      num[++top] = x % 10;\n      x /= 10;\n    }\n    for (int i = 1; i <= 81; ++i) {\n      m = i;\n      memset(vis, false, sizeof(vis));\n      ans = (ans + dfs(top, 1, i, 1, 0));\n    }\n    return ans;\n  }\n  int beautifulNumbers(int l, int r) { return sol(r) - sol(l - 1); }\n};","author":"TangJing","submissionId":"611247400"},[]]},{"345":[{"id":"345","fileName":"611247467.txt","sourceCode":"class Solution {\npublic:\n    int f(int x){\n        string s = to_string(x);\n        unordered_map<string, long long> memo;\n        function<long long(int, int, int, int, int)> dfs = [&](int pos, int tight, int started, int sum, int prod) -> long long {\n            if(pos == s.size()){\n                if(!started) return 0;\n                return (prod % sum == 0) ? 1LL : 0LL;\n            }\n            string key = to_string(pos) + \"_\" + to_string(tight) + \"_\" + to_string(started) + \"_\" + to_string(sum) + \"_\" + to_string(prod);\n            if(memo.count(key))\n                return memo[key];\n            \n            long long res = 0;\n            int up = tight ? (s[pos] - '0') : 9;\n            for(int dig = 0; dig <= up; dig++){\n                int ntight = tight;\n                if(tight && dig < up) ntight = 0;\n                int nstarted = started;\n                int nsum = sum;\n                int nprod = prod;\n                if(!started && dig == 0){\n                } else if(!started && dig > 0){\n                    nstarted = 1;\n                    nsum = dig;\n                    nprod = dig;\n                } else {\n                    nsum = sum + dig;\n                    nprod = prod * dig;\n                }\n                res += dfs(pos + 1, ntight, nstarted, nsum, nprod);\n            }\n            memo[key] = res;\n            return res;\n        };\n        \n        return dfs(0, 1, 0, 0, 1);\n    }\n    int beautifulNumbers(int l, int r) {\n        return f(r)-f(l-1);\n    }\n};","author":"nihonge","submissionId":"611247467"},[]]},{"346":[{"id":"346","fileName":"611247654.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        low = str(l)\n        high = str(r)\n        n = len(high)\n        diff = len(low) != n\n        low = '0' * (n - len(low)) + low  # 补前导零，和 high 对齐\n\n        @cache\n        def dfs(i: int, limit_low: bool, limit_high: bool, pre: bool, prod: int, s: int) -> int:\n            if i == n:\n                return 1 if (not pre and prod % s == 0) else 0\n\n            # 第 i 个数位可以从 lo 枚举到 hi\n            # 如果对数位还有其它约束，应当只在下面的 for 循环做限制，不应修改 lo 或 hi\n            lo = int(low[i]) if limit_low else 0\n            hi = int(high[i]) if limit_high else 9\n\n            res = 0\n            for d in range(lo, hi + 1):\n                res += dfs(i + 1, limit_low and d == lo, limit_high and d == hi, pre and not d, 1 if (pre and not d) else prod * d, s + d)\n            return res\n\n        return dfs(0, True, True, diff, 1, 0)","author":"刘蛋蛋","submissionId":"611247654"},[]]},{"347":[{"id":"347","fileName":"611247822.txt","sourceCode":"import java.util.HashMap;\nimport java.util.Map;\n\nclass Solution {\n    public int beautifulNumbers(int l, int r) {\n        int ans = dfs(String.valueOf(r).toCharArray(), 0, true, false, 1, 0);\n        memo.clear();\n        ans -= dfs(String.valueOf(l - 1).toCharArray(), 0, true, false, 1, 0);\n        return ans;\n    }\n\n    Map<Long, Integer> memo = new HashMap<>();\n\n    int dfs(char[] s, int i, boolean isLimit, boolean isNum, long mul, int sum) {\n        if (i == s.length) {\n            if (isNum && mul % sum == 0) {\n                int aa = 0;\n            }\n            return isNum && mul % sum == 0 ? 1 : 0;\n        }\n        long mask = mul << 15 | (long) sum << 5 | i;\n        if (!isLimit && isNum && memo.containsKey(mask)) {\n            return memo.get(mask);\n        }\n        int res = 0;\n        if (!isNum) {\n            res += dfs(s, i + 1, false, false, 1, 0);\n        }\n        for (int d = isNum ? 0 : 1, up = isLimit ? s[i] - '0' : 9; d <= up; d++) {\n            res += dfs(s, i + 1, isLimit && d == up, true, mul * d, sum + d);\n        }\n        if (!isLimit && isNum) {\n            memo.put(mask, res);\n        }\n        return res;\n    }\n}","author":"Itsuki","submissionId":"611247822"},[]]},{"348":[{"id":"348","fileName":"611246865.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        ll = [int(c) for c in str(l-1)]\n        lr = [int(c) for c in str(r)]\n        \n        def deal_value(in_value) :\n            if in_value == 0 :\n                return in_value\n            out_value = 1\n            while in_value % 2 == 0 and not out_value % 64 == 0 :\n                in_value /= 2\n                out_value *= 2\n            while in_value % 3 == 0 and not out_value % 81 == 0 :\n                in_value /= 3\n                out_value *= 3\n            while in_value % 5 == 0 and not out_value % 25 == 0 :\n                in_value /= 5\n                out_value *= 5\n            while in_value % 7 == 0 and not out_value % 49 == 0 :\n                in_value /= 7\n                out_value *= 7\n            return out_value\n        \n        # case=0 表示<=ll， case=1表示<=lr\n        @functools.lru_cache(None)\n        def solve(case=0, lastm=1, lasts=0, eq=True, pt=0, isstart=True) :\n            listt = ll if case == 0 else lr\n            if pt == len(listt) :\n                if isstart :\n                    return 0\n                # print(case, lastm, lasts, eq, pt)\n                # print(1 if lastm % lasts == 0 else 0, '!')\n                return 1 if lastm % lasts == 0 else 0\n            \n            minv = 0 \n            maxv = 9 if not eq else listt[pt]\n            to_ret = 0\n            for vnow in range(minv, maxv+1) :\n                neq = eq and vnow == listt[pt]\n                if isstart and vnow == 0 :\n                    newm, news = lastm, lasts\n                    new_start=True\n                else :\n                    newm, news = deal_value(lastm*vnow), lasts+vnow\n                    new_start=False\n                to_ret += solve(case, newm, news, neq, pt+1, new_start)\n            # print(case, lastm, lasts, eq, pt)\n            # print(to_ret)\n            return to_ret\n        \n    \n        v1 = solve(case=0)\n        v2 = solve(case=1)\n        return v2-v1\n                \n            ","author":"pku_erutan","submissionId":"611246865"},[]]},{"349":[{"id":"349","fileName":"611247626.txt","sourceCode":"#include<bits/stdc++.h>\n// #pragma GCC optimize(\"Ofast,no-stack-protector,fast-math\",3)\n#define cln cerr<<\"Line:   \"<<__LINE__<<\"    \"\n#define pct __builtin_popcountll\n#define ctz __builtin_ctzll\n#define mkp make_pair\n#define MST(x) memset(x,0,sizeof(x))\n#define all(x) x.begin(),x.end()\nusing namespace std;\nconstexpr int N=(1<<21)+100,_g=3,M1=1e9+7,M2=1e9+9,M=M1;\nusing ll=long long;\nnamespace fast_io{\n    char buf[N+10],*p1,*p2,c;\n#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2))?EOF:*p1++\ntemplate<typename _Tp>\n    void read(_Tp &x){\n        int f=0;for(c=gc;c<48;c=gc)f^=c=='-';\n        for(x=0;c>47;x=(x<<1)+(x<<3)+(48^c),c=gc);\n        if(f)x=-x;\n    }\ntemplate<typename _Tp,typename..._tps>\n    void read(_Tp &x,_tps&...y){read(x),read(y...);}\n    char ob[N+100],stk[505];int tp,ot;\n    void fls(){fwrite(ob,1,ot,stdout),ot=0;}\n    int cntt;\ntemplate<typename _Tp>\n    static inline void write(_Tp x,char c){\n        if(!cntt)atexit(fls),cntt=1;\n        while(x>9)stk[++tp]=48^(x%10),x/=10;\n        for(ob[ot++]=48^x;tp;ob[ot++]=stk[tp--]);\n        ob[ot++]=c;if(ot>N)fls();\n    }\n}using fast_io::read;\nusing fast_io::write;\n#define pli pair<ll,int>\n#define pii pair<int,int>\nusing ul=unsigned long long;\ntemplate<typename tp1,typename tp2>\n    void ckmx(tp1 &x,const tp2 &y){if(x<y)x=y;}\ntemplate<typename tp1,typename tp2>\n    void ckmn(tp1 &x,const tp2 &y){x>y?x=y:0;}\nvoid add(int &x,int y){(x+=y)>=M?x-=M:0;}\nvoid del(int &x,int y){(x-=y)<0?x+=M:0;}\nvoid add(int &x,ul y,int z){x=(y*z+x)%M;}\nvoid del(int &x,ul y,int z){(x-=y*z%M)<0&&(x+=M);}\nconstexpr int qp(ll a,ll x=M-2){\n    int res=1;for(;x;x>>=1,a=a*a%M)\n        (x&1)&&(res=a*res%M);return res;\n}\nconstexpr int qp(ll a,ll x,int M){\n    int res=1;for(;x;x>>=1,a=a*a%M)\n        (x&1)&&(res=a*res%M);return res;\n}\nstruct NTP{};\ntemplate<typename tp1,typename tp2,int N>\nstruct Htb{\n    static constexpr int M=1e7+19;\n    int hd[M+3],to[N],ct;\n    tp1 ed[N];tp2 w[N];\n    static int hc(ul v){\n        v^=v<<13,v^=v>>7;\n        return (v^(v<<17))%M;\n    }\n    void ins(tp1 x,tp2 y){\n        int &p=hd[hc(x)];\n        ed[++ct]=x,to[ct]=p;\n        w[p=ct]=y;\n    }\n    int count(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return 1;\n        return 0;\n    }\n    pair<tp2,bool>find(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return mkp(w[i],true);\n        return mkp(tp2(),false);\n    }\n    int operator[](tp1 x){\n        int &p=hd[hc(x)];\n        for(int i=p;i;i=to[i])\n            if(ed[i]==x)return i;\n        ed[++ct]=x,to[ct]=p;\n        return p=ct;\n    }\n    void clear(){while(ct)hd[hc(ed[ct--])]=0;}\n};\nnamespace MATH{\n    vector<int>jc,nv,_nv;\n    int dv2(int x){return x&1?x+M>>1:x>>1;}\n    int C(int n,int m){\n        assert(m<=n);\n        return 1ll*jc[n]*nv[m]%M*nv[n-m]%M;\n    }\n    int P(int n,int m){\n        return 1ll*jc[n]*nv[n-m]%M;\n    }\n    int D(int n,int m){\n        if(n<0||m<0)return 0;\n        if(!n)return 1;\n        if(!m)return 0;\n        return C(n+m-1,m-1);\n    }\n    void init(int n){\n        int x;\n        jc.resize(n+2);\n        jc[0]=jc[1]=1;\n        nv=_nv=jc;\n        for(x=2;x<=n;++x){\n            jc[x]=1ll*x*jc[x-1]%M;\n            _nv[x]=ll(M-M/x)*_nv[M%x]%M;\n            nv[x]=1ll*nv[x-1]*_nv[x]%M;\n        }\n    }\n}\nstruct DET{\n    int a[3005][3005],n;\n    int run(){\n        if(!n)return 1;\n        int x,y,z,k,res=1;\n        for(x=1;x<=n;++x){\n            for(y=x;y<=n&&!a[y][x];++y);\n            if(y>n)return 0;\n            if(y>x){\n                for(k=1;k<=n;++k)swap(a[x][k],a[y][k]);\n                res&&(res=M-res); \n            }\n            k=qp(a[x][x]);\n            res=1ll*res*a[x][x]%M;\n            for(z=1;z<=n;++z)\n                a[x][z]=1ll*a[x][z]*k%M;\n            for(y=1;y<=n;++y)\n                if(x!=y){\n                    k=a[y][x];\n                    for(z=1;z<=n;++z)\n                        del(a[y][z],a[x][z],k);\n                }\n        }\n        for(x=1;x<=n;++x)\n            res=1ll*res*a[x][x]%M;\n        return res;\n    }\n}det;\nll Gcd(ll x,ll y){\n    if(!x||!y)return x|y;\n    int k=min(ctz(x),ctz(y));\n    ll d;y>>=ctz(y);\n    while(x){\n        x>>=ctz(x),d=x-y;\n        if(x<y)y=x;\n        if(d<0)x=-d;\n        else x=d;\n    }return y<<k;\n}\nusing ll=long long;\nusing ul=unsigned long long;\nconstexpr int bceil(int n){return 1<<(std::__lg(n-1)+1);}\ntemplate<int mod>struct NTT{\n    constexpr int dil(int x){return x>>31?x+mod:x;}\n    constexpr int mul(ul x,int y){return x*y%mod;}\n    constexpr int qpow(int a,int b,int r=1){for(;b;a=mul(a,a),b>>=1){r=b&1?mul(r,a):r;}return r;}\n    int w[N>>1],wI[N>>1];\n    void init(int n){\n        int l=bceil(n)>>1;w[0]=wI[0]=1;\n        for(int i=1;i<l;i<<=1){w[i]=qpow(_g,((mod-1)>>2)/i),wI[i]=qpow(_g,mod-1-((mod-1)>>2)/i);}\n        for(int i=1;i<l;++i){w[i]=mul(w[i&(i-1)],w[i&-i]),wI[i]=mul(wI[i&(i-1)],wI[i&-i]);}\n    }\n    void dif(int *f,int lim){\n        for(int l=lim>>1,r=lim;l;l>>=1,r>>=1)\n            for(int*j=f,*o=w;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    (x=*k)>=mod&&(x-=mod),y=mul(k[l],*o),*k=x+y,k[l]=x-y+mod;\n    }\n    void dit(int *f,int lim){\n        for(int l=1,r=2;l<lim;l<<=1,r<<=1)\n            for(int*j=f,*o=wI;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    x=*k,y=mod-k[l],(*k=x-y)<0&&(*k+=mod),k[l]=mul(x+y,*o);\n        for(int i=0,p=mod-(mod-1)/lim;i<lim;++i)f[i]=1ll*f[i]*p%mod;\n    }\n    void mul(int *f,int *g,int n){\n        dif(f,n),dif(g,n);\n        for(int i=0;i<n;++i)f[i]=1ll*f[i]*g[i]%M;\n        dit(f,n);\n    }\n    void mul(int *f,int n){\n        dif(f,n);int i;\n        for(i=0;i<n;++i)f[i]=1ll*f[i]*f[i]%M;\n        dit(f,n);\n    }\n};\nNTT<M>ntt;\nusing namespace MATH;\nmt19937_64 rg(random_device{}());\nusing LL=__int128_t;\nusing vt=vector<int>;\nusing vl=vector<ll>;\nusing ld=double;\nconst ll INF=1e18;\nint T,n,m,K,a[N],b[N],to[N];\n// int main(){\n//     ios::sync_with_stdio(false),cin.tie(0);\n//     int i,j,k,l,r,x,y,z;\n//     dfs(0,0,0,1);\n//     return 0;\n// }\nint f[11][82][82],g[11][82][82];\nchar vf[11][82][82],vg[11][82][82];\nint F(int k,int p,int q);\nint G(int k,int p,int q){\n    if(!k)return p==K&&q==0;\n    if(vg[k][p][q])return g[k][p][q];\n    int i,res=0;vg[k][p][q]=1;\n    for(i=0;i<10;++i){\n        if(i||p)res+=G(k-1,p+i,q*i%K);\n        else res+=G(k-1,p,q);\n    }return g[k][p][q]=res;\n}\nint F(int k,int p,int q){\n    if(!k)return p==K&&q==0;\n    if(vf[k][p][q])return f[k][p][q];\n    int i,res=0;vf[k][p][q]=1;\n    for(i=0;i<b[k];++i){\n        if(i||p)res+=G(k-1,p+i,q*i%K);\n        else res+=G(k-1,p,q);\n    }if(i||p)res+=F(k-1,p+i,q*i%K);\n    else res+=F(k-1,p,q);\n    return f[k][p][q]=res;\n}\nint sol(){\n    b[m=1]=n%10,n/=10;\n    while(n)b[++m]=n%10,n/=10;\n    int res=0;\n    for(K=1;K<=81;++K){\n        memset(vf,0,sizeof(vf));\n        memset(vg,0,sizeof(vg));\n        res+=F(m,0,1);\n    }return res;\n}\nclass Solution {\n    public:\n        int beautifulNumbers(int l, int r) {\n            n=r;int res=sol();\n            n=l-1;res-=sol();\n            return res;\n        }\n    };","author":"EnofTaiPeople","submissionId":"611247626"},[]]},{"350":[{"id":"350","fileName":"611248029.txt","sourceCode":"# pmx=defaultdict(int)\n# for i in range(1,82):\n#     for j in [2,3,5,7]:\n#         cj=0\n#         while i%j==0:\n#             i//=j\n#             cj+=1\n#         pmx[j]=max(pmx[j],cj)\n# print(pmx)\n#{2: 6, 3: 4, 5: 2, 7: 2})\n#{64,81,25,49}\nt1=[128,243,125,343]\nt2=[2,3,5,7]\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        high=str(r)\n        n=len(high)\n        low=str(l)\n        low=low.zfill(n)\n        @cache\n        def dfs(i,sm,pd,limlow,limhigh,isnum):\n            if i==n:\n                if isnum and pd%sm==0:\n                    return 1\n                return 0\n            ans=0\n            up=int(high[i]) if limhigh else 9\n            down=int(low[i]) if limlow else 0\n            for j in range(down,up+1):\n                if j==0:\n                    if isnum:\n                        ans+=dfs(i+1,sm,0,limlow and j==down,limhigh and j==up,isnum)\n                    else:\n                        ans+=dfs(i+1,sm,pd,limlow and j==down,limhigh and j==up,isnum)\n                else:\n                    npd=pd*j\n                    if npd!=0:\n                        for a,b in zip(t1,t2):\n                            while npd%a==0:\n                                npd//=b\n                    ans+=dfs(i+1,sm+j,npd,limlow and j==down,limhigh and j==up,True)\n            return ans\n            \n        res=dfs(0,0,1,True,True,0)\n        return res","author":"凉薄一夏","submissionId":"611248029"},[]]},{"351":[{"id":"351","fileName":"611249128.txt","sourceCode":"mem_cache = collections.defaultdict(int)\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        ds = []\n        def dfs(p, isNum, isEqual, py, sm, rm):\n            if p == -1:\n                if isNum and py == 0 and sm == rm:\n                    return 1\n                return 0\n            key = (p, isNum, py, sm, rm)\n            if not isEqual and key in mem_cache:\n                return mem_cache[key]\n            mx = 9\n            if isEqual:\n                mx = ds[p]\n            ans = 0\n            for i in range(mx+1):\n                nxt_is_num = (isNum or i)\n                nxt_is_equal = (isEqual and i == ds[p])\n                nxt_py = (py*i) % rm\n                if not isNum and nxt_is_num:\n                    nxt_py = i % rm\n                nxt_sm = (sm+i)\n                if nxt_sm > rm:\n                    break\n                ans += dfs(p-1, nxt_is_num, nxt_is_equal, nxt_py, nxt_sm, rm)\n            if not isEqual:\n                mem_cache[key] = ans\n            return ans\n\n        ans = 0\n        cl = l-1\n        ds = []\n        while cl:\n            ds.append(cl % 10)\n            cl //= 10\n        for i in range(1, 9*len(ds)+1):\n            ans -= dfs(len(ds)-1, False, True, 0, 0, i)\n\n        cr = r\n        ds = []\n        # dfs.cache_clear()\n        while cr:\n            ds.append(cr % 10)\n            cr //= 10\n        for i in range(1, 9*len(ds)+1):\n            ans += dfs(len(ds)-1, False, True, 0, 0, i)\n        return ans","author":"孙慢慢","submissionId":"611249128"},[]]},{"352":[{"id":"352","fileName":"611249485.txt","sourceCode":"class Solution {\n  public:\n    unordered_map<uint64_t, int> memo;\n    string s;\n\n    // digit dp\n    int dp(uint8_t pos, bool tight, bool started, bool zerofound, uint32_t sum,\n           uint32_t prod) {\n        if (pos == s.size()) {\n            if (!started) {\n                return 0;\n            }\n            if (zerofound) {\n                return 1;\n            }\n            return (prod % sum == 0 ? 1 : 0);\n        }\n\n        auto key = (static_cast<uint64_t>(pos)) | // pos max 9, use 4 bits\n                   (static_cast<uint64_t>(tight) << 4) |\n                   (static_cast<uint64_t>(started) << 5) |\n                   (static_cast<uint64_t>(zerofound) << 6) |\n                   (static_cast<uint64_t>(sum) << 7) | // sum max 81, use 7 bits\n                   (static_cast<uint64_t>(prod) << 16);\n\n        if (auto it = memo.find(key); it != memo.end()) {\n            return it->second;\n        }\n\n        int ans = 0;\n        int limit = (tight ? s[pos] - '0' : 9);\n        for (int d = 0; d <= limit; d++) {\n            bool ntight = (tight && d == limit);\n            if (!started) {\n                if (d == 0) {\n                    ans += dp(pos + 1, ntight, false, false, 0, 1);\n                } else {\n                    ans += dp(pos + 1, ntight, true, false, d, d);\n                }\n            } else {\n                if (!zerofound) {\n                    if (d == 0) {\n                        ans += dp(pos + 1, ntight, true, true, 0, 0);\n                    } else {\n                        ans +=\n                            dp(pos + 1, ntight, true, false, sum + d, prod * d);\n                    }\n                } else {\n                    ans += dp(pos + 1, ntight, true, true, 0, 0);\n                }\n            }\n        }\n\n        memo[key] = ans;\n        return ans;\n    }\n\n    int check(long long x) {\n        s = to_string(x);\n        memo.clear();\n        return dp(0, true, false, false, 0, 1);\n    }\n\n    int beautifulNumbers(int l, int r) { return check(r) - check(l - 1); }\n};","author":"丁真今天写什么","submissionId":"611249485"},[]]},{"353":[{"id":"353","fileName":"611248595.txt","sourceCode":"class Solution {\n    fun beautifulNumbers(l: Int, r: Int): Int {\n        fun toDigits(n: Int): List<Int> = n.toString().map { it - '0' }\n\n        fun dp(digits: List<Int>): Long {\n            val n = digits.size\n\n            data class State(\n                val pos: Int,\n                val tight: Boolean,\n                val started: Boolean,\n                val s: Int,\n                val p: Int,\n                val hasZero: Boolean\n            )\n\n            val seen = HashMap<State, Long>()\n\n            fun dfs(pos: Int, tight: Boolean, started: Boolean, s: Int, p: Int, hasZero: Boolean): Long {\n                if (pos == n) {\n                    if (!started) return 0L\n                    return if (hasZero || (s != 0 && p % s == 0)) 1L else 0L\n                }\n                val key = State(pos, tight, started, s, p, hasZero)\n                if (key in seen) return seen[key]!!\n\n                var res = 0L\n                val limit = if (tight) digits[pos] else 9\n                for (d in 0..limit) {\n                    val newTight = tight && (d == limit)\n                    if (!started && d == 0) {\n                        res += dfs(pos + 1, newTight, false, 0, 1, false)\n                    } else {\n                        val newStarted = true\n                        if (d == 0) {\n                            res += dfs(pos + 1, newTight, newStarted, s + d, 0, true)\n                        } else {\n                            val newP = if (!started) d else p * d\n                            res += dfs(pos + 1, newTight, newStarted, s + d, newP, hasZero)\n                        }\n                    }\n                }\n                seen[key] = res\n                return res\n            }\n            return dfs(0, tight = true, started = false, s = 0, p = 1, hasZero = false)\n        }\n\n        fun countUpTo(x: Int): Long = if (x < 0) 0L else dp(toDigits(x))\n        return (countUpTo(r) - countUpTo(l - 1)).toInt()\n    }\n}","author":"HaKu","submissionId":"611248595"},[]]},{"354":[{"id":"354","fileName":"611247983.txt","sourceCode":"class Solution {\npublic:\n#define ll int  \nint a[12];\nll dp[12][90][90];\n\nll dfs(int pos,int isu,int lead,int ndsum,int pro,int sum){\n\tif(pos<0 && ndsum==sum && pro==0) return 1;\n    else if(pos<0) return 0;\n\tif(!isu&&dp[pos][pro][sum]!=-1&&!lead) return dp[pos][pro][sum];\n\n\tint up=isu ? a[pos]:9;\n\tll ans=0;\n\tfor(int i=0;i<=up;i++){\n        int x;\n        if(lead && i==0) x=pro;\n        else x=pro*i%ndsum;\n\t\tans+=dfs(pos-1,isu&&i==up,lead&&i==0,ndsum,x,sum+i);\n\t}\n\tif(!isu&&!lead) dp[pos][pro][sum]=ans;\n\treturn ans;\n}\n\nll cal(ll x,int ndsum){\n\tif(x==0) return 0;\n\tint cnt=0;\n\twhile(x){\n\t\ta[cnt++]=x%10;\n\t\tx=x/10;\n\t}\n\treturn dfs(cnt-1,1,1,ndsum,1%ndsum,0);\n}\n\nint beautifulNumbers(int l, int r) {\n    \n\tint ans=0;\n\tfor(int i=1;i<90;i++){\n\t\tmemset(dp,-1,sizeof dp);\n\t\tans+=cal(r,i)-cal(l-1,i);\n        // cout<<i<<\" \"<<cal(r,i)<<\" \"<<cal(l-1,i)<<endl; \n\t}\n\treturn ans;\n}\n};","author":"Lucky7","submissionId":"611247983"},[]]},{"355":[{"id":"355","fileName":"611249666.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def ff(x):\n            s=str(x)\n            @cache \n            def f(i: int, is_limit: bool, is_num: bool,su,ch) -> int:\n                # if ch==0:\n                #     return 1\n                if i == len(s):\n                     if int(is_num) and ch%su==0:\n                         return 1\n                     return 0\n                res = 0\n                if not is_num: \n                    res = f(i + 1, False, False,0,1)\n                    \n                low = 0 if is_num else 1 \n                up = int(s[i]) if is_limit else 9 \n                \n                for d in range(low, up + 1):  \n                    res += f(i + 1, is_limit and d == up, True,su+d,ch*d)\n                return res\n            ans=f(0,True,False,0,1)\n            f.cache_clear()\n            return ans\n        return ff(r)-ff(l-1)\n        ","author":"月耑","submissionId":"611249666"},[]]},{"356":[{"id":"356","fileName":"611250130.txt","sourceCode":"constexpr long long inf = INT_MAX >> 1;\nconstexpr double eps = 1e-9;\n\nconstexpr int N = 2e5 + 10;\nconstexpr int M = 1000000007; // 998244343;\n\nint lc_init = ([]() {\n}(), 0);\n#define eput(...) 218\n\n#line 10\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        static pair<int, int> f[9][2][2][81][81];\n        int n, a[9];\n        int m;\n        static int timestamp = 0;\n        auto dp = [&](this auto& dp, int i, int limit, int pos, int r, int s) -> int {\n            if (s < 0) return 0;\n            if (i == n) return r == 0 && s == 0;\n            auto &[ret, t] = f[i][limit][pos][r][s];\n            if (t == timestamp) return ret;\n            ret = 0;\n            int D = limit ? a[i] : 9;\n            for (int d = 0; d <= D && s >= 0; ++d) {\n                ret += dp(i + 1, limit && d == D, pos || d > 0, pos ? r * d % m : d % m, s);\n                --s;\n            }\n            t = timestamp;\n            return ret;\n        };\n        auto gao = [&](int x) {\n            if (x == 0) return 0;\n            n = 0;\n            for (; x > 0; x /= 10) a[n++] = x % 10;\n            reverse(a, a + n);\n            ++timestamp;\n            return dp(0, 1, 0, 0, m);\n        };\n        int ans = 0;\n        for (int s = 1; s <= 81; ++s) {\n            m = s;\n            ans += gao(r);\n            ans -= gao(l - 1);\n        }\n        return ans;\n    }\n};","author":"sfiction","submissionId":"611250130"},[]]},{"357":[{"id":"357","fileName":"611249606.txt","sourceCode":"const int MAXN = 11 * 9;\n\nint dp[2][2][MAXN][MAXN];\n\nclass Solution {\n    public:\n        int beautifulNumbers(int l, int r) {\n            \n            auto calc = [&](int N) {\n                string s = to_string(N);\n                int n = (int) s.length();\n\n                int M = n * 9;\n\n                auto reset = [&](int m, int t) {\n                    for (int k = 0; k < 2; ++k) {\n                        for (int i = 0; i <= m; ++i) {\n                            for (int j = 0; j <= m; ++j) {\n                                dp[t][k][i][j] = 0;\n                            }\n                        }\n                    }\n                };\n\n                long long res = 0;\n                for (int m = 1; m <= M; ++m) {\n\n                    reset(m, 0);\n                    int t = 0;\n                    for (int i = 0; i < n; ++i, t ^= 1) {\n                        int d = s[i] - '0';\n                        \n                        int from = t;\n                        int to = from ^ 1;\n\n                        auto& cur = dp[from];\n                        auto& nxt = dp[to];\n                        reset(m, to);\n\n                        for (int j = 0; j < 2; ++j) {\n                            for (int k = 0; k <= m; ++k) {\n                                for (int l = 0; l < m; ++l) {\n                                    if (cur[j][k][l] == 0) {\n                                        continue;\n                                    }\n\n                                    int ll = 0, rr = j == 0 ? d : 9;\n                                    for (int dd = ll; dd <= rr && dd + k <= m; ++dd) {\n                                        int nj = j;\n                                        if (dd < d) {\n                                            nj = 1;\n                                        }\n\n                                        int nk = k + dd;\n                                        int nl = l * dd % m;\n                                        nxt[nj][nk][nl] += cur[j][k][l];\n                                    }\n                                }\n                            }\n                        }\n\n\n                        for (int dd = 1; dd <= (i == 0 ? d : 9) && dd <= m; ++dd) {\n                            int nj = 0;\n                            if (i > 0 || dd < d) {\n                                nj = 1;\n                            }\n                            nxt[nj][dd][dd % m] += 1;\n                        }\n                    }\n\n                    res += dp[t][1][m][0];\n                }\n                return res;\n            };\n\n\n            auto res = calc(r + 1) - calc(l);\n            return res;\n        }\n    };\n","author":"gooday","submissionId":"611249606"},[]]},{"358":[{"id":"358","fileName":"611251507.txt","sourceCode":"class Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        auto query = [&] (int p) -> int {\n            if(p == 0) return 0;\n            vector<int> digits;\n            int tmp = p;\n            while(tmp) {\n                digits.push_back(tmp % 10);\n                tmp /= 10;\n            }\n            reverse(digits.begin(), digits.end());\n//             for(int i : digits) {\n//                 cout << i << \" \";\n                \n//             }\n//             cout << \"n\";\n            map<array<int, 4>, int> dp;\n            auto dfs = [&] (auto &&dfs, int step, int upper, int mul, int add) -> int {\n                if(step == digits.size()) {\n                    // cout << step << \" \" << upper << \" \" << mul << \" \" << add << \"n\";\n                    if(add == 0) return 0;\n                    if(mul % add == 0) {\n                        return 1;\n                    } else {\n                        return 0;\n                    }\n                }\n                if(dp.count({step, upper, mul, add})) return dp[{step, upper, mul, add}];\n                auto &ans = dp[{step, upper, mul, add}] = 0;\n                for(int i = 0; i <= (upper ? digits[step] : 9); i++) {\n                    ans += dfs(dfs, step + 1, upper & (i == digits[step]), (add == 0 && i == 0 ? mul : mul * i), add + i);\n                }\n                return ans;\n                \n            };\n            return dfs(dfs, 0, 1, 1, 0);\n        };\n        // cout << query(9) << 'n';\n        return query(r) - query(l - 1);\n        return 1;\n    }\n};","author":"Khoray","submissionId":"611251507"},[]]},{"359":[{"id":"359","fileName":"611250475.txt","sourceCode":"using namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vll> vvll;\ntypedef vector<vvll> vvvll;\ntypedef vector<pii> vpii;\ntypedef vector<vpii> vvpii;\ntypedef vector<pll> vpll;\ntypedef vector<vpll> vvpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<vd> vvd;\n#define yn(ans) printf(\"%sn\", (ans)?\"Yes\":\"No\");\n#define YN(ans) printf(\"%sn\", (ans)?\"YES\":\"NO\");\ntemplate<class T> bool chmax(T &a, T b) {\n\tif (a >= b) return false;\n\ta = b; return true;\n}\ntemplate<class T> bool chmin(T &a, T b) {\n\tif (a <= b) return false;\n\ta = b; return true;\n}\n#define FOR(i, s, e, t) for ((i) = (s); (i) < (e); (i) += (t)) \n#define REP(i, e) for (int i = 0; i < (e); ++i) \n#define REP1(i, s, e) for (int i = (s); i < (e); ++i)\n#define RREP(i, e) for (int i = (e); i >= 0; --i)\n#define RREP1(i, e, s) for (int i = (e); i >= (s); --i)\n#define all(v) v.begin(), v.end()\n#define pb push_back\n#define qb pop_back\n#define pf push_front\n#define qf pop_front\n#define maxe max_element\n#define mine min_element\nll inf = 1e18;\n#define DEBUG printf(\"%dn\", __LINE__); fflush(stdout);\ntemplate<class T> void print(vector<T> &v, bool withSize = false) {\n\tif (withSize) cout << v.size() << endl;\n\tREP(i, v.size()) cout << v[i] << \" \"; \n\tcout << endl;\n}\nmt19937_64 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\nint pt[82][82][82], pt2[82][82][82];\nclass Solution {\npublic:\n    int solve(int N) {\n        if (N == 0) return 0;\n        string s = to_string(N);\n        int M = s.size();\n        auto &dp = pt, &dp2 = pt2;\n        REP(i, M * 9 + 1) REP(j, M * 9 + 1) REP(k, i) dp[i][j][k] = 0;\n\n        int eqsum = 0;\n        ll eqprod = 1;\n        \n        REP(i, s.size()) {\n            int d = s[i] - '0';\n            REP(k, M * 9 + 1) REP(l, k + 1) REP(m, k) dp2[k][l][m] = 0;\n            REP(j, 10) {\n                REP1(k, 1, M * 9 + 1) REP(l, k + 1 - j) REP(m, k) {\n                    dp2[k][l + j][m * j % k] += dp[k][l][m];\n                }\n                if (j < d && (i > 0 || j > 0)) {\n                    REP1(k, 1, M * 9 + 1) {\n                        if (eqsum + j <= k) dp2[k][eqsum + j][eqprod * j % k]++;\n                    }\n                }\n                if (i > 0 && j > 0) {\n                    REP1(k, 1, M * 9 + 1) {\n                        if (j <= k) dp2[k][j][j % k]++;\n                    }\n                }\n            }\n            eqsum += d, eqprod *= d;\n            swap(dp, dp2);\n        }\n\n        int ans = 0;\n        REP1(i, 1, M * 9 + 1) ans += dp[i][i][0];\n        ans += eqprod % eqsum == 0;\n\n        return ans;\n    }\n\n    int beautifulNumbers(int l, int r) {\n        return solve(r) - solve(l - 1);\n    }\n};","author":"Relaxed Visvesvaraya","submissionId":"611250475"},[]]},{"362":[{"id":"362","fileName":"611251540.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, low: int, high: int) -> int:\n        def calc(s: str) -> int:\n            @cache  # 记忆化搜索\n            def f(i: int, tot: int, mut: int, is_limit: bool, is_num: bool) -> int:\n                if i == len(s):\n                    return int(is_num and mut % tot == 0)\n                res = 0\n                if not is_num:  # 可以跳过当前数位\n                    res = f(i + 1, tot, mut, False, False)\n\n                low = 0 if is_num else 1  # 如果前面没有填数字，必须从 1 开始（因为不能有前导零）\n                up = int(s[i]) if is_limit else 9  # 如果前面填的数字都和 s 的一样，那么这一位至多填 s[i]（否则就超过 s 啦）\n                for d in range(low, up + 1):  # 枚举要填入的数字 d\n                    res += f(i + 1, tot + d, mut * d, is_limit and d == up, True)\n                return res\n            return f(0, 0, 1, True, False)\n        return calc(str(high)) - calc(str(int(low) - 1))\n\n","author":"stargazy","submissionId":"611251540"},[]]},{"363":[{"id":"363","fileName":"611249979.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n#define all(a) a.begin(), a.end()\nvoid print() { cout << 'n'; }\ntemplate <typename T, typename...Args>\nvoid print(T t, Args...args) { cout << t << ' '; print(args...); }\nusing ll = long long;\nconst int N = 82;\n\nint dir[4][2] = {\n    {1, 0}, {0, 1}, {-1, 0}, {0, -1}\n};\n\ntemplate <typename T> bool chmax(T &x, T y) { if (y > x) { x = y; return true; } return false; }\ntemplate <typename T> bool chmin(T &x, T y) { if (y < x) { x = y; return true; } return false; }\n\ntemplate <typename T = int>\nvector<T> readVector(int n) {\n    vector<T> a(n);\n    for(T &x: a) cin >> x;\n    return a;\n} \n\nint dp[10][N][N];\nint a[10], idx;\n\nint dfs(int pos, int sum, int mod, int s, bool num, bool lim) {\n\tif (pos == 0) {\n\t\treturn num && sum == s && mod == 0;\n\t}\n\tif (num && !lim && ~dp[pos][sum][mod]) {\n\t\treturn dp[pos][sum][mod];\n\t}\n\tint res = 0;\n\tif (!num) {\n\t\tres += dfs(pos - 1, 0, 0, s, false, false);\n\t}\n\tint upper = lim ? a[pos] : 9;\n\tfor (int i = 1 - num; i <= upper; i ++) {\n\t\tint new_mod = (!num ? i : mod * i) % s;\n\t\tres += dfs(pos - 1, sum + i, new_mod, s, true, lim && (i == a[pos]));\n\t} \n\tif (num && !lim) {\n\t\tdp[pos][sum][mod] = res;\n\t}\n\treturn res;\n}\n\nint cal (int n) {\n\tif (n == 0) {\n\t\treturn 0;\n\t}\n\tidx = 0;\n\twhile (n) {\n\t\ta[++ idx] = n % 10;\n\t\tn /= 10;\n\t}\n\tint ans = 0;\n\tfor (int s = 1; s <= 81; s ++) {\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tans += dfs(idx, 0, 0, s, false, true);\n\t}\n\treturn ans;\n}\n\nclass Solution {\npublic:\n\tint beautifulNumbers(int l, int r) {\n\t\treturn cal(r) - cal(l - 1);\n\t}\n};","author":"hhhhyf","submissionId":"611249979"},[]]},{"364":[{"id":"364","fileName":"611251869.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n\n        def count(num):\n            s  = str(num)\n            n = len(s)\n\n            @cache\n            def f(i,is_limit,is_num,acc,sm):\n                if i ==len(s):\n                    return int(is_num and acc%sm ==0)\n                res =0\n                if not is_num:\n                    res = f(i+1,False,False,1,0) ##计算 0-9，10-99，100-999，1000-9999\n                up = int(s[i]) if is_limit else 9\n                for d in range(0 if is_num else 1, up +1):\n                    res += f(i+1,is_limit and d ==up, True,acc*d,sm+d)\n                return res\n            return f(0,True,False,1,0)\n        return count(r) -count(l-1)","author":"Tao Zhou","submissionId":"611251869"},[]]},{"365":[{"id":"365","fileName":"611252052.txt","sourceCode":"class Solution {\npublic:\n    long long r[10]={},pp[20]={},p10[20]={},p9[20]={};\n    long long k;\n    int dp(long long p, int s, int x, int c){\n        if(c==0){\n            if(p%s==0){\n                return k;\n            }\n            return 0;\n        }\n        if(x>=10){\n            return 0;\n        }\n        int res=0;\n        long long np=p;\n        int ns=s;\n        for(int i=0;i<=c;++i){\n            k/=pp[i];\n            res+=dp(np,ns,x+1,c-i);\n            k*=pp[i];\n            np*=x;\n            ns+=x;\n        }\n        return res;\n    }\n    int g(long long p, int s, int c){\n        // cout<<\"g \"<<p<<\" \"<<s<<\" \"<<c<<endl;\n        if(c==0){\n            return p%s==0;\n        }\n        if(p==0){\n            return p10[c];\n        }\n        k=pp[c];\n        int res=p10[c]-p9[c];\n        res+=dp(p,s,1,c);\n        return res;\n    }\n    int f(int x){\n        if(!x){\n            return 0;\n        }\n        vector<int> a;\n        int t=x;\n        while(t){\n            a.push_back(t%10);\n            t/=10;\n        }\n        int n=a.size();\n        int res=0;\n        long long p=1;\n        int s=0;\n        for(int i=n-1;i>=0;--i){\n            for(int j=1;j<a[i];++j){\n                res+=g(p*j,s+j,i);\n            }\n            if(i!=n-1){\n                if(a[i]){\n                    res+=g(0,s,i);    \n                }\n                for(int j=1;j<=9;++j){\n                    res+=g(j,j,i);\n                }\n            }\n            p*=a[i];\n            s+=a[i];\n        }\n        res+=p%s==0;\n        // cout<<\"f(\"<<x<<\")=\"<<res<<endl;\n        return res;\n    }\n    int beautifulNumbers(int l, int r) {\n        pp[0]=1;\n        p9[0]=1;\n        p10[0]=1;\n        for(int i=1;i<=10;++i){\n            pp[i]=pp[i-1]*i;\n            p9[i]=p9[i-1]*9;\n            p10[i]=p10[i-1]*10;\n        }\n        // for(int i=l;i<=r;++i){\n        //     f(i);\n        // }\n        return f(r)-f(l-1);\n    }\n};","author":"w285714","submissionId":"611252052"},[]]},{"368":[{"id":"368","fileName":"611252440.txt","sourceCode":"class Solution:  \n    def beautifulNumbers(self, left: int, right: int) -> int:  \n        def count_up_to(upper_bound: int) -> int:  \n            digits = str(upper_bound)  \n            length = len(digits)  \n            \n            @cache  \n            def dp(position: int, is_tight: bool, has_started: bool,   \n                   has_zero: bool, digit_sum: int, digit_product: int) -> int:  \n                if position == length:  \n                    if not has_started:\n                        return 0  \n                    if has_zero:\n                        return 1 if digit_sum > 0 else 0  \n                    return 1 if digit_sum > 0 and digit_product % digit_sum == 0 else 0  \n                \n                count = 0  \n                max_digit = int(digits[position]) if is_tight else 9  \n                \n                for d in range(max_digit + 1):  \n                    new_tight = is_tight and (d == max_digit)  \n                    \n                    if not has_started:  \n                        if d == 0:\n                            count += dp(position + 1, new_tight, False, False, 0, 1)  \n                        else:\n                            count += dp(position + 1, new_tight, True, False, d, d)  \n                    else:  \n                        if d == 0:\n                            count += dp(position + 1, new_tight, True, True, digit_sum, 0)  \n                        else:  \n                            if has_zero:\n                                count += dp(position + 1, new_tight, True, True, digit_sum + d, 0)  \n                            else:\n                                count += dp(position + 1, new_tight, True, False,   \n                                           digit_sum + d, digit_product * d)  \n                \n                return count  \n            \n            return dp(0, True, False, False, 0, 1)  \n         \n        return count_up_to(right) - count_up_to(left - 1)","author":"OverclockedIvan","submissionId":"611252440"},[]]},{"369":[{"id":"369","fileName":"611253850.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        \n        l = str(l)\n        r = str(r)\n        n = len(r)\n        \n        l = \"0\" * (n - len(l)) + l\n            \n        @cache\n        def f2(idx, is_num, is_limit1, is_limit2, ji, he):\n            if idx == n:\n                if is_num is True and ji % he == 0:\n                    return 1\n                else:\n                    return 0\n\n            if is_limit2 is True:\n                max_value = int(r[idx])\n            else:\n                max_value = 9\n            \n            if is_limit1 is True:\n                min_value = int(l[idx])\n            else:\n                min_value = 0\n\n            res = 0\n            for i in range(min_value, max_value + 1):\n                if is_num is True or i != 0:\n                    res += f2(idx + 1, is_num or i != 0, is_limit1 is True and i == min_value,is_limit2 is True and i == max_value, ji * i, he + i)\n                else:\n                    res += f2(idx + 1, is_num or i != 0, is_limit1 is True and i == min_value,is_limit2 is True and i == max_value, ji, he)\n            return res\n                \n            \n        return f2(0, False, True, True, 1, 0)\n        # return res\n\n        ","author":"Admiring ShockleyZns","submissionId":"611253850"},[]]},{"370":[{"id":"370","fileName":"611253556.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def calc(high: str) -> int:\n            high = str(high)\n            @cache  # 记忆化搜索\n            def f(i: int, s: int, m: int, is_limit : bool, is_num: bool) -> int:\n                if i == len(high):\n                    return int(is_num and m % s == 0)\n                res = 0\n                if not is_num:  # 可以跳过当前数位\n                    res = f(i + 1, s, m, False, False)\n                low = 0 if is_num else 1  # 如果前面没有填数字，必须从 1 开始（因为不能有前导零）\n                up = int(high[i]) if is_limit else 9\n                for d in range(low, up + 1):  # 枚举要填入的数字 d\n                    res += f(i + 1, s + d, m * d,  is_limit and d == up, True)\n                return res\n            return f(0,0,1,True,False)\n        # print(calc(11))\n        # # print(calc('0'))\n        return (calc(str(r)) - calc(str(l-1)))","author":"Misaka Mikoto","submissionId":"611253556"},[]]},{"371":[{"id":"371","fileName":"611252219.txt","sourceCode":"import sys\nsys.setrecursionlimit(10**7)\nfrom functools import lru_cache\nfrom bisect import bisect_left\n\ndef bs(a,x):\n    l,r=0,len(a)-1\n    while l<=r:\n        m=(l+r)//2\n        if a[m]==x:return m\n        if a[m]<x:l=m+1\n        else:r=m-1\n    return -1\n\ndef st(a):\n    n=len(a); s=1\n    while s<n:s*=2\n    t=[0]*(2*s)\n    for i in range(n): t[s+i]=a[i]\n    for i in range(s-1,0,-1): t[i]=t[2*i]+t[2*i+1]\n    def q(l,r):\n        l+=s; r+=s; tot=0\n        while l<=r:\n            if l&1:\n                tot+=t[l]; l+=1\n            if not(r&1):\n                tot+=t[r]; r-=1\n            l//=2; r//=2\n        return tot\n    return t,q\n\ndef gd(x):\n    return list(map(int,str(x)))\n\ndef pf(x,full=False):\n    if x==0:return (0,0,0,0) if not full else None\n    t=x; c2=c3=c5=c7=0\n    while t%2==0:\n        c2+=1; t//=2\n    while t%3==0:\n        c3+=1; t//=3\n    while t%5==0:\n        c5+=1; t//=5\n    while t%7==0:\n        c7+=1; t//=7\n    return (c2,c3,c5,c7) if (not full or t==1) else (-1,-1,-1,-1)\nfd=[pf(d) for d in range(10)]\nM2,M3,M5,M7=6,4,2,2\ndef cl(x,m):\n    return x if x<=m else m\nsF=[(-1,-1,-1,-1) if s==0 else pf(s,True) for s in range(82)]\n\n@lru_cache(None)\ndef dp(p,L,tight,e2,e3,e5,e7,s,digs):\n    if p==L:\n        sx2,sx3,sx5,sx7=sF[s]\n        return (1,1 if sx2!=-1 and e2>=sx2 and e3>=sx3 and e5>=sx5 and e7>=sx7 else 0)\n    lim=digs[p] if (tight and digs) else 9; A,B=0,0\n    for d in range(1,lim+1):\n        nt=tight and (d==lim)\n        ne2=cl(e2+fd[d][0],M2)\n        ne3=cl(e3+fd[d][1],M3)\n        ne5=cl(e5+fd[d][2],M5)\n        ne7=cl(e7+fd[d][3],M7)\n        ns=s+d\n        if ns>81: break\n        a,b=dp(p+1,L,nt,ne2,ne3,ne5,ne7,ns,digs if (tight and digs) else tuple([9]*L))\n        A+=a; B+=b\n    return (A,B)\n\ndef cnt(N):\n    if N<1:return (0,0)\n    digs=tuple(gd(N)); L=len(digs); A,B=0,0\n    for l in range(1,L):\n        a,b=dp(0,l,False,0,0,0,0,0,tuple([9]*l))\n        A+=a; B+=b\n    a,b=dp(0,L,True,0,0,0,0,0,tuple(digs))\n    A+=a; B+=b\n    return (A,B)\n\ndef sol(x):\n    if x<1:return 0\n    tot,beaut=cnt(x)\n    return beaut+(x-tot)\n\nclass Solution:\n    def beautifulNumbers(self, l:int, r:int) -> int:\n        return sol(r)-sol(l-1)","author":"Cranky 6agarinizJ","submissionId":"611252219"},[]]},{"372":[{"id":"372","fileName":"611254538.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        '''\n        数位dp\n        乘积 9 ^ 9\n        和 9 * 9 = 81\n        '''\n        # 10 ^ k\n        ten = [1]\n        while len(ten) < 20:\n            ten.append(ten[-1] * 10)\n        \n        # s 字符串， total 和，is_limit \n        @cache\n        def dfs(i,s,is_limit,is_num,tgt,t,mod):\n            if i == len(s):\n                if is_num and not mod and t == tgt:\n                    return 1\n                return 0\n\n            res = 0\n            # 取 0 \n            if not is_num:\n                res += dfs(i+1,s,False,is_num,tgt,t,mod)\n\n            if not is_num:\n                start = 1\n            else:\n                start = 0\n\n            if is_limit:\n                end = int(s[i])\n            else:\n                end = 9\n\n            # 剪枝\n            rest = len(s) - i\n            if t + rest * 9 < tgt:\n                return 0\n            \n            for d in range(start,end+1):\n                # 剪枝\n                if t + d > tgt:\n                    break\n\n                # 继续limit\n                if is_limit and d == end:\n                    res += dfs(i+1,s,True,True,tgt,t+d,(mod*d) % tgt)\n                else:\n                    res += dfs(i+1,s,False,True,tgt,t+d,(mod*d) % tgt)\n\n            return res\n\n        res = 0\n        r = str(r)\n        l = str(l-1)\n        for tgt in range(1,100):\n            res += dfs(0,r,True,False,tgt,0,1) - dfs(0,l,True,False,tgt,0,1)\n\n        dfs.cache_clear()\n        return res\n        ","author":"mipha","submissionId":"611254538"},[]]},{"373":[{"id":"373","fileName":"611254111.txt","sourceCode":"using ll=long long;\nclass Solution {\npublic:\n\tstruct ST{\n\t\tint pos,tight,st,f,s;ll p;\n\t\tbool operator==(const ST& other)const{\n\t\t\treturn pos==other.pos&&tight==other.tight&&st==other.st&&\n\t\t\t\tf==other.f&&s==other.s&&p==other.p;\n\t\t}\n\t};\n\tstruct Hash{\n\t\tsize_t operator()(const ST& s)const{\n\t\t\tsize_t res=17;\n\t\t\tres=res*31+std::hash<int>()(s.pos);\n\t\t\tres=res*31+std::hash<int>()(s.tight);\n\t\t\tres=res*31+std::hash<int>()(s.st);\n\t\t\tres=res*31+std::hash<int>()(s.f);\n\t\t\tres=res*31+std::hash<int>()(s.s);\n\t\t\tres=res*31+std::hash<ll>()(s.p);\n\t\t\treturn res;\n\t\t}\n\t};\n\tunordered_map<ST,ll,Hash>mp;\n\tll dp(int pos,bool tight,bool st,bool f,int s,ll p,const vector<int>&digits){\n\t\tif(pos==digits.size()){\n\t\t\tif(!st)return 0;\n\t\t\tif(f)return 1;\n\t\t\treturn (p%s==0)?1LL:0LL;\n\t\t}\n\t\tST cur={pos,tight,st,f,s,p};\n\t\tif(mp.find(cur)!=mp.end())return mp[cur];\n\t\tll c=0;\n\t\tint lim=tight?digits[pos]:9;\n\t\tfor(int i=0;i<=lim;i++){\n\t\t\tbool newTight=tight&&(i==lim);\n\t\t\tif(!st){\n\t\t\t\tif(i==0)c+=dp(pos+1,newTight,false,false,0,1,digits);\n\t\t\t\telse c+=dp(pos+1,newTight,true,false,i,(ll)i,digits);\n\t\t\t}else{\n\t\t\t\tint newSum=s+i;bool newZeroFound=f||(i==0);\n\t\t\t\tll newProd=(f||i==0)?0LL:p*i;\n\t\t\t\tc+=dp(pos+1,newTight,true,newZeroFound,newSum,newProd,digits);\n\t\t\t}\n\t\t}mp[cur]=c;\n\t\treturn c;\n\t}\n\tll cal(ll x){\n\t\tif(x<1)return 0;vector<int>digits;\n\t\twhile(x>0){\n\t\t\tdigits.push_back(static_cast<int>(x%10));x/=10;\n\t\t}reverse(digits.begin(),digits.end());mp.clear();\n\t\treturn dp(0,true,false,false,0,1,digits);\n\t}\n\tint beautifulNumbers(int l,int r){\n\t\tll cnt=cal(r)-cal(l-1);\n\t\treturn static_cast<int>(cnt);\n\t}\n};\n","author":"forgo","submissionId":"611254111"},[]]},{"374":[{"id":"374","fileName":"611253655.txt","sourceCode":"\n# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, DefaultDict\nfrom collections import deque, Counter\nfrom queue import PriorityQueue\nimport math\nfrom functools import lru_cache\nfrom sortedcontainers import SortedDict, SortedSet\nimport random\nimport copy\nimport sys\n\nMOD = 10**9 + 7\n\n\nINF = 0x7f7f7f7f7f7f7f7\n\n\n\n\n\n\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n\n\n        def get_cnt(R):\n            if R == 0:\n                return 0\n\n            arr = []\n            t = R\n            while t:\n                arr.append(t % 10)\n                t //= 10\n            arr = arr[::-1]\n            n = len(arr)\n\n            # print(arr)\n\n            @lru_cache(typed=False, maxsize=128000)\n            def dp(ii, all_max, all_zero, sum_val, mul_val):\n                if ii == n:\n                    if all_zero:\n                        return 0\n\n                    if sum_val != 0 and mul_val % sum_val == 0:\n                        return 1\n                    return 0\n\n                bound = arr[ii] if all_max else 9\n\n                ans = 0\n                for cur in range(0, bound+1):\n                    new_mul = mul_val\n                    if not (all_zero and cur == 0):\n                        new_mul *= cur\n\n                    ans += dp(ii+1, all_max and cur == arr[ii], all_zero and cur == 0, sum_val+cur, new_mul)\n                return ans\n\n\n            return dp(0, True, True, 0, 1)\n\n\n        # print(get_cnt(50))\n\n        vr = get_cnt(r)\n        vl = get_cnt(l-1)\n        # print(vr, vl)\n        return vr - vl\n","author":"皓首不倦.GRH","submissionId":"611253655"},[]]},{"375":[{"id":"375","fileName":"611255285.txt","sourceCode":"\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def f(n):\n            s = str(n)\n            @cache\n            def dfs(i, limit, P, S):\n                if i == len(s): return S and P % S == 0\n                res = 0\n                up = int(s[i]) if limit else 9\n                for d in range(up + 1):\n                    res += dfs(i + 1, limit and d == up, P * d if S + d else P, S + d)\n                return res\n            res = dfs(0, True, 1, 0)\n            dfs.cache_clear()\n            return res\n        return f(r) - f(l - 1)","author":"cheng-liang-yu","submissionId":"611255285"},[]]},{"376":[{"id":"376","fileName":"611254563.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        # 每一位上的数字的乘积可以被这些数字之和整除\n        def calc(upper: int) -> int:\n            s = str(upper)\n            @cache\n            def f(i: int, mul: int, add: int, is_limit: bool, is_num: bool) -> int:\n                if i == len(s):\n                    return int(is_num and mul % add == 0)\n                res = 0\n                if not is_num:\n                    res += f(i + 1, mul, add, False, False)\n                low = 0 if is_num else 1\n                up = int(s[i]) if is_limit else 9\n                for d in range(low, up + 1):\n                    res += f(i + 1, mul * d, add + d, is_limit and d == up, True)\n                return res\n            return f(0, 1, 0, True, False)\n        return calc(r) - calc(l - 1)","author":"surpass-w","submissionId":"611254563"},[{"id":"421","similarity":0.8813559322033898,"totOverlap":104,"longestOverlap":41}]],"421":[{"id":"421","fileName":"611265482.txt","sourceCode":"class Solution:\n\n    def beautifulNumbers(self, l: int, r: int) -> int:\n\n        def calc(high: int) -> int:\n\n            s = str(high)\n\n            @cache\n            def dfs(i: int, prod: int, _sum: int, is_limit: bool, is_num: bool) -> int:\n                if i == len(s):\n                    return int(is_num and prod % _sum == 0)\n                res = 0\n                if not is_num:\n                    res = dfs(i + 1, prod, _sum, False, False)\n                d0 = 0 if is_num else 1\n                up = int(s[i]) if is_limit else 9\n                for d in range(d0, up + 1):\n                    res += dfs(i + 1, prod * d, _sum + d, is_limit and d == up, True)\n\n                return res\n\n            return dfs(0, 1, 0, True, False)\n\n        return calc(r) - calc(l - 1)\n","author":"喜乐","submissionId":"611265482"},[{"id":"376","similarity":0.8813559322033898,"totOverlap":104,"longestOverlap":41}]]},{"377":[{"id":"377","fileName":"611255372.txt","sourceCode":"dp0 = [[-1]*100 for _ in range(32)]\ndp1 = [[[[-1]*100 for _ in range(100)] for z in range(11)] for x in range(100)]\nclass Solution:\n    def beautifulNumbers(self, lv: int, rv: int) -> int:\n        # 2222 2, 3, 5, 7  22233 2*3+3*2\n        dd = [0]*32\n        # dp = [[[-1]*100 for _ in range(100)] for z in range(32)]\n        \n        def dfs1(n, p, s, m):\n            if s>m: return 0\n            if n==0:\n                if p==0 and s==m:  return 1\n                return 0\n            if dp1[m][n][p][s]!=-1: return dp1[m][n][p][s]\n            r = 0\n            for d in range(10):\n                r+=dfs1(n-1, (p*d)%m, s+d, m)\n            dp1[m][n][p][s]=r\n            return r\n        def dfs0(n, m):\n            if n==0: return 0\n            if dp0[n][m]!=-1: return dp0[n][m]\n            r = 0\n            for d in range(1, 10):\n                r+=dfs1(n-1, d%m, d, m)\n            dp0[n][m]=r\n            return r\n        def count2(v, s):\n            d=0\n            vv=v\n            r=0\n            while vv:\n                dd[d]=vv%10\n                d+=1\n                vv//=10\n            if s>9*d: return 0\n            for i in range(d-1):\n                r+=dfs0(i+1, s)\n            p = 1\n            xs = 0\n            i = d-1\n            while i>=0:\n                x = 0\n                cd = dd[i]\n                if i==d-1: x=1\n                while x<cd:\n                    r+=dfs1(i, (p*x)%s, x+xs, s)\n                    x+=1\n                xs +=cd\n                p*=cd\n                p%=s\n                if xs>s: break\n                i-=1\n            if xs==s and p==0: r+=1\n            return r\n            \n        def count(v):\n            r = 0 \n            for d in range(1, 100):\n                r+=count2(v, d)\n            return r\n        r = count(rv)\n        if lv>1: r-=count(lv-1)\n        return r\n                \n        ","author":"82年的muggle","submissionId":"611255372"},[]]},{"380":[{"id":"380","fileName":"611254683.txt","sourceCode":"class Solution {\n    public int beautifulNumbers(int l, int r) {\n        DigitalDp digitalDp = new DigitalDp();\n        long ans = digitalDp.dfs(String.valueOf(r), 0, 0, true, true);\n        DigitalDp digitalDp2 = new DigitalDp();\n        ans -= digitalDp2.dfs(String.valueOf(l - 1), 0, 0, true, true);\n        return (int) ans;\n    }\n\n    public class DigitalDp {\n\n        private Map<Long, Long> map = new HashMap<>();\n\n        // 模板：计算0到n中2出现的次数(包含0和n)\n        // idx从0开始，表示当前考虑的地方是num.charAt(idx)\n        // isLimit表示是否有上界限制\n        // allZero表示前面的数字是否都是0\n        public long dfs(String num, int idx, long status, boolean isLimit, boolean allZero) {\n            long key = getKey(idx, status, isLimit, allZero);\n            if (map.containsKey(key)) {\n                return map.get(key);\n            }\n            // 计算\n            if (idx == num.length()) {\n\n                // 直接计算\n                long chengji = status / 200;\n                long he = status % 200;\n                if (he !=0 && chengji % he == 0) {\n                    map.put(key, 1L);\n                    return 1L;\n                } else {\n                    map.put(key, 0L);\n                }\n                return 0L;\n            }\n            int up = num.charAt(idx) - '0';\n            int max = isLimit ? up : 9;\n            long count = 0;\n            for (int i = 0; i <= max; i++) {\n                boolean nextLimit = isLimit && up == i;\n                boolean nextAllZero = allZero & i == 0;\n\n                long he = status % 200;\n                long chengji = status / 200;\n                // TODO status的含义不同,newStatus的计算逻辑不同\n                long newHe = he + i;\n                // 判断乘还是加\n                boolean jia = allZero; // 前面全是0，没有别的\n                long newChengji = jia ? chengji + i : chengji * i;\n                long newStatus = getStatus(newChengji, newHe);\n                count += dfs(num, idx + 1, newStatus, nextLimit, nextAllZero);\n            }\n            map.put(key, count);\n            return count;\n        }\n\n        private long getStatus(long chengji, long he) {\n            return chengji * 200 + he;\n        }\n\n        private long getKey(int idx, long status, boolean isLimit, boolean allZero) {\n            // TODO 设置好status的取值范围\n            long res = idx * 1000000000L * 2 * 2;\n            res += status * 2 * 2;\n            res += isLimit ? 2 : 0;\n            res += allZero ? 1 : 0;\n            return res;\n        }\n    }\n}","author":"欧海","submissionId":"611254683"},[]]},{"381":[{"id":"381","fileName":"611255740.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def dfs(x):\n            s=str(x)\n            n=len(s)\n            @cache\n            def dp(pos,x,y,tsum,pro):\n                if pos==n:\n                    if not y:\n                        return 0\n                    return 1 if (pro%tsum==0) else 0\n                l=int(s[pos]) if x else 9\n                total=0\n                for d in range(0,l+1):\n                    newx=x and (d==l)\n                    if not y and d==0:\n                        total+=dp(pos+1,newx,False,tsum,pro)\n                    else:\n                        newy=True\n                        newtsum=tsum+d\n                        newpro=(pro*d) if (y or d!=0) else d\n                        total+=dp(pos+1,newx,newy,newtsum,newpro)\n                return total\n            return dp(0,True,False,0,1)\n        return dfs(r)-dfs(l-1)","author":"Alx","submissionId":"611255740"},[]]},{"382":[{"id":"382","fileName":"611255860.txt","sourceCode":"int FLAG = 0 ;\n\nint dp[15][90][90][90][2] ;\nint a[15] ;\n\nint dfs(int pos, int sum, int now_add, int now_mul, bool flag, bool iszero)\n{\n    if(pos == 0) return now_add == sum && now_mul == 0 ;\n    if(flag && ~dp[pos][sum][now_add][now_mul][iszero]) return dp[pos][sum][now_add][now_mul][iszero] ;\n    \n    int x = flag ? 9 : a[pos], ans = 0 ;\n    for(int i = 0; i <= x; ++ i)\n        if(now_add + i <= sum)\n        {\n            if(iszero && i == 0)\n                ans += dfs(pos - 1, sum, now_add + i, now_mul, flag || i < x, iszero && i == 0) ;\n            else ans += dfs(pos - 1, sum, now_add + i, now_mul * i % sum, flag || i < x, iszero && i == 0) ;\n        }\n            \n\n    if(flag) dp[pos][sum][now_add][now_mul][iszero] = ans ;\n    return ans ;\n}\n\nint calc(int x)\n{\n    if(x == 0) return 0 ;\n    int num = 0 ;\n    while(x) a[++ num] = x % 10, x /= 10 ;\n\n    // for(int i = num; i >= 1; -- i)\n    //     printf(\"%d \", a[i]) ;\n    // printf(\"n\") ;\n    int ans = 0 ;\n    for(int i = 1; i <= 81; ++ i)\n    {\n        ans += dfs(num, i, 0, i == 1 ? 0 : 1, false, 1) ;\n        // if(i <= 3) printf(\"%d %dn\", i, ans) ;\n    }\n        \n    // printf(\"ans =  %dn\", ans) ;\n    return ans ;\n}\n\nint beautifulNumbers(int l, int r) {\n    if(!FLAG) memset(dp, -1, sizeof(dp)), FLAG = 1 ;\n\n    // for(int i = 1; i <= 100; ++ i)\n    //     if(calc(i) - calc(i - 1) == 1)\n    //         printf(\"%dn\", i) ;\n    //     else if(calc(i) - calc(i - 1) != 0)\n    //         printf(\"NO! %d %d %dn\", i, calc(i), calc(i - 1)) ;\n    return calc(r) - calc(l - 1) ;\n}","author":"半城烟沙","submissionId":"611255860"},[]]},{"383":[{"id":"383","fileName":"611255882.txt","sourceCode":"class Solution {\npublic:\n    int n;\n    string L, R;\n    int f[10][100][100];\n    int mod = 0;\n    int dfs(int i, int isLow, int isHigh, int s, int ys) {\n        if(i == n) return (ys == 0 && s == mod) ? 1 : 0;\n        if(!isLow && !isHigh && ~f[i][s][ys]) return f[i][s][ys]; \n        int res = 0;\n        // if(isZero) res += dfs(i + 1, isLow && L[i] == '0', isHigh && R[i] == '0', 1, 0, 0);\n        int l = isLow ? L[i] - '0' : 0;\n        int r = isHigh ? R[i] - '0' : 9;\n        // if(isZero) l = max(1, l);\n        for(int d = l; d <= r; d ++) {\n            res += dfs(i + 1, isLow && (L[i] - '0' == d), isHigh && (R[i] - '0' == d), s + d, (s == 0 && d) ? (d % mod) : (ys * d) % mod);\n        }\n        if(!isLow && !isHigh) f[i][s][ys] = res;\n        return res;\n    }\n    int beautifulNumbers(int l, int r) {\n        R = to_string(r);\n        n = R.size();\n        L = to_string(l);\n        L = string(n - L.size(), '0') + L;\n        // cout << L << endl << R << endl;\n        int res = 0;\n        for(int i = 1; i <= 81; i ++) {\n            memset(f, -1, sizeof f);\n            mod = i;\n            res += dfs(0, 1, 1, 0, 0);\n        }\n        // mod = 3;\n        // cout << dfs(0, 1, 1, 0, 0) << endl;\n        return res;\n    }\n};","author":"Stupefied Pare6Le","submissionId":"611255882"},[]]},{"384":[{"id":"384","fileName":"611256719.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def check(s):\n            s = str(s)\n            @cache\n            def f(i, isLimit, isNum, p, su):\n                if i == len(s):\n                    return 1 if su and p % su == 0 else 0\n        \n                res = 0\n                if not isNum:\n                    res = f(i + 1, False, False, 0, 0)\n        \n                up = int(s[i]) if isLimit else 9\n                for k in range(0 if isNum else 1, up + 1):\n                    res += f(i + 1,  isLimit and k == up, True, (k if not isNum else k*p), su+k)\n                return res\n            return f(0, True, False, 0, 0)\n            \n        return check(r) - check(l-1)","author":"活力喵饭","submissionId":"611256719"},[]]},{"385":[{"id":"385","fileName":"611255114.txt","sourceCode":"fn solve(n: u64) -> u64 {\n    if n == 0 {\n        return 0;\n    }\n    \n    let ub: Vec<u8> = n.to_string().chars().map(|c| c as u8 - b'0').collect();\n    let m = ub.len();\n    let max_sum = 9 * m;\n    let mut ans = 0;\n\n    for s in 1..=max_sum {\n        let mut lt = vec![vec![0u64; s]; s + 1];\n        let mut eq = vec![vec![0u64; s]; s + 1];\n        eq[0][0] = 1;\n\n        for i in 0..m {\n            let mut nlt = vec![vec![0u64; s]; s + 1];\n            let mut neq = vec![vec![0u64; s]; s + 1];\n\n            for j in 0..=s {\n                for d in 0..10 {\n                    if j + d > s {\n                        break;\n                    }\n                    for k in 0..s {\n                        if j == 0 {\n                            nlt[j + d][d % s] += lt[j][k];\n                        } else {\n                            nlt[j + d][k * d % s] += lt[j][k];\n                        }\n                        if d < ub[i] as usize {\n                            if j == 0 {\n                                nlt[j + d][d % s] += eq[j][k];\n                            } else {\n                                nlt[j + d][k * d % s] += eq[j][k];\n                            }\n                        }\n                        if d == ub[i] as usize {\n                            if j == 0 {\n                                neq[j + d][d % s] += eq[j][k];\n                            } else {\n                                neq[j + d][k * d % s] += eq[j][k];\n                            }\n                        }\n                    }\n                }\n            }\n            \n            lt = nlt;\n            eq = neq;\n        }\n\n        ans += lt[s][0] + eq[s][0];\n    }\n    ans\n}\n\nimpl Solution {\n    pub fn beautiful_numbers(l: i32, r: i32) -> i32 {\n        (solve(r as u64) - solve((l as u64).saturating_sub(1))) as i32\n    }\n}\n","author":"牧瀬 紅莉栖","submissionId":"611255114"},[]]},{"386":[{"id":"386","fileName":"611258608.txt","sourceCode":"template <>\nstruct std::hash<std::pair<int, int>> {\n    std::size_t operator()(const std::pair<int, int>& p) const noexcept {\n        auto hash1 = std::hash<int>{}(p.first);\n        auto hash2 = std::hash<int>{}(p.second);\n        return hash1 ^ (hash2 << 1);\n    }\n};\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        string low = to_string(l);\n        string high = to_string(r);\n        int n = high.size();\n        low = string(n - low.size(), '0') + low; // 补前导零，和 high 对齐\n\n        vector<unordered_map<pair<int, int>, int>> memo(n);\n\n        function<long long(int, int, int, bool, bool)> dfs = [&](int i, int mul, int cs, bool limit_low, bool limit_high) -> long long {\n            if (i == n) {\n                return mul % cs == 0;\n            }\n\n            if (!limit_low && !limit_high && memo[i].count({ mul, cs })) {\n                return memo[i][{ mul, cs }];\n            }\n\n            // 第 i 个数位可以从 lo 枚举到 hi\n            // 如果对数位还有其它约束，应当只在下面的 for 循环做限制，不应修改 lo 或 hi\n            int lo = limit_low ? low[i] - '0' : 0;\n            int hi = limit_high ? high[i] - '0' : 9;\n\n            long long ans = 0;\n            for (int d = lo; d <= hi; ++d) {\n                if (cs == 0 && d == 0)\n                    ans += dfs(i + 1, mul, cs + d, limit_low && d == lo, limit_high && d == hi);\n                else\n                    ans += dfs(i + 1, mul * d, cs + d, limit_low && d == lo, limit_high && d == hi);\n            }\n\n            if (!limit_low && !limit_high) {\n                memo[i][{ mul, cs }] = ans;\n            }\n            return ans;\n        };\n\n        return dfs(0, 1, 0, true, true);\n    }\n};","author":"Sariabell","submissionId":"611258608"},[]]},{"387":[{"id":"387","fileName":"611258810.txt","sourceCode":"from functools import cache\nfrom math import inf\nfrom typing import List\nfrom sortedcontainers import SortedList\n\ndef fmax(a, b):\n    return a if a > b else b\ndef fmin(a, b):\n    return a if a < b else b\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n\n        def cal(x):\n            x=[int(v) for v in str(x)]\n            n=len(x)\n            ans=0\n            for t in range(1,n*10+1):\n                @cache\n                def dfs(i,s,r,lim,posi):\n                    if s>t: return 0\n                    if (n-i)*10+s<t: return 0\n                    if i==n:\n                        if s==t and r==0:\n                            # print(t)\n                            return 1\n                        else:\n                            return 0\n                    res=0\n                    for j in range(10):\n                        if lim and j>x[i]:break\n                        ns=s+j\n                        nr=(r*j)%t if j>0 or posi else r\n                        res+=dfs(i+1,ns,nr,lim and j==x[i], posi or j>0)\n                    return res\n                v=dfs(0,0,1,True,False)\n                dfs.cache_clear()\n                #print(x,t,v)\n                ans+=v\n            return ans\n        r1=cal(r)\n        r2=cal(l-1)\n        # print(r1,r2)\n        return r1-r2\n","author":"nnl","submissionId":"611258810"},[]]},{"388":[{"id":"388","fileName":"611255870.txt","sourceCode":"\nfunc beautifulNumbers(l int, r int) int {\n\tget := func(n int) int {\n\t\ts := strconv.Itoa(n)\n\t\tm := len(s)\n\t\ttype pair struct {\n\t\t\tn1, n2 int\n\t\t}\n\t\tmemo := make([][1 << 10]map[pair]int, m)\n\t\tfor i := range memo {\n\t\t\tfor j := range memo[i] {\n\t\t\t\tmemo[i][j] = make(map[pair]int)\n\t\t\t}\n\t\t}\n\t\tvar f func(int, int, int, int, bool, bool) int\n\t\tf = func(i, mask, sm, ss int, isLimit, isNum bool) (res int) {\n\t\t\tif i == m {\n\t\t\t\tif isNum && sm%ss == 0 {\n\t\t\t\t\treturn 1 \n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tpa := pair{n1: sm, n2: ss}\n\t\t\tif !isLimit && isNum {\n\t\t\t\tif w, ok := memo[i][mask][pa]; ok {\n\t\t\t\t\treturn w\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !isNum { \n\t\t\t\tres += f(i+1, mask, sm, ss, false, false)\n\t\t\t}\n\t\t\td := 0\n\t\t\tif !isNum {\n\t\t\t\td = 1 \n\t\t\t}\n\t\t\tup := 9\n\t\t\tif isLimit {\n\t\t\t\tup = int(s[i] - '0') \n\t\t\t}\n\t\t\tfor ; d <= up; d++ { \n\t\t\t\tres += f(i+1, mask|1<<d, sm*d, ss+d, isLimit && d == up, true)\n\t\t\t}\n\t\t\tmemo[i][mask][pa] = res\n\t\t\treturn\n\t\t}\n\t\treturn f(0, 0, 1, 0, true, false)\n\t}\n\treturn get(r) - get(l-1)\n}\n","author":"djzzwx","submissionId":"611255870"},[]]},{"389":[{"id":"389","fileName":"611258936.txt","sourceCode":"using ll = long long;\n\nint a[123];\nunordered_map<ll, ll> f[123][123][2][2];\n\nll dfs(int pos, ll prod, ll sum, int up, int zero) {\n    if (pos == -1) {\n        if (sum == 0) return 0;\n        return prod % sum == 0;\n    }\n    if (f[pos][sum][up][zero].find(prod) != f[pos][sum][up][zero].end()) {\n        return f[pos][sum][up][zero][prod];\n    }\n    ll& ans = f[pos][sum][up][zero][prod];\n    ans = 0;\n    for (int x = 0; x <= (up ? a[pos] : 9); x++) {\n        ans += dfs(pos - 1, prod * (zero && x == 0 ? 1 : x), sum + x,\n                   up && x == a[pos], zero && x == 0);\n    }\n    return ans;\n}\n\nvoid clear() {\n    for (int i = 0; i < 123; i++)\n        for (int j = 0; j < 123; j++)\n            for (int k = 0; k < 2; k++)\n                f[i][j][k][0].clear(), f[i][j][k][1].clear();\n}\n\nll solve(int x) {\n    int ox = x;\n    if (x == 0) return 0;\n    clear();\n    int pos = 0;\n    while (x) {\n        a[pos] = x % 10;\n        x /= 10;\n        pos++;\n    }\n    ll ans = dfs(pos - 1, 1, 0, 1, 1);\n    // cout << ox << ' ' << ans << endl;\n    return ans;\n}\n\nclass Solution {\n   public:\n    int beautifulNumbers(int l, int r) {\n        clear();\n        return solve(r) - solve(l - 1);\n    }\n};","author":"sdcgvhgj","submissionId":"611258936"},[]]},{"390":[{"id":"390","fileName":"611258902.txt","sourceCode":"class Solution:\n    def calc(self, num: int) -> int:\n        if not num:\n            return 0\n        nums = list(map(int, str(num)))\n        n = len(nums)\n\n        @cache\n        def dfs(i: int, sums: int, muls: int, limit: bool, pre: bool):\n            if i >= n:\n                return muls % sums == 0 if sums else 0\n\n            ans = 0\n            mx = nums[i] if limit else 9\n            for j in range(mx + 1):\n                muls_c = muls if not j and pre else muls * j\n                limit_c, pre_c = limit and j == mx, pre and not j\n                ans += dfs(i + 1, sums + j, muls_c, limit_c, pre_c)\n\n            return ans\n\n        ans = dfs(0, 0, 1, True, True)\n        return ans\n\n        \n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return self.calc(r) - self.calc(l - 1)","author":"老麻子8号","submissionId":"611258902"},[]]},{"391":[{"id":"391","fileName":"611259039.txt","sourceCode":"from functools import cache\n\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_f(n: int) -> int:\n            s = str(n)\n            contrib = {\n                1: (0, 0, 0, 0),\n                2: (1, 0, 0, 0),\n                3: (0, 1, 0, 0),\n                4: (2, 0, 0, 0),  # 4 = 2^2\n                5: (0, 0, 1, 0),\n                6: (1, 1, 0, 0),  # 6 = 2*3\n                7: (0, 0, 0, 1),\n                8: (3, 0, 0, 0),  # 8 = 2^3\n                9: (0, 2, 0, 0)   # 9 = 3^2\n            }\n            @cache\n            def dfs1(pos, lim, started, seen_zero):\n                if pos == len(s):\n                    return 1 if started and seen_zero else 0\n                limit = int(s[pos]) if lim else 9\n                tot = 0\n                for dig in range(0, limit + 1):\n                    new_lim = lim and (dig == limit)\n                    if not started:\n                        if dig == 0:\n                            tot += dfs1(pos + 1, new_lim, False, False)\n                        else:\n                            tot += dfs1(pos + 1, new_lim, True, False)\n                    else:\n                        if dig == 0:\n                            tot += dfs1(pos + 1, new_lim, True, True)\n                        else:\n                            tot += dfs1(pos + 1, new_lim, True, seen_zero)\n                return tot\n\n            @cache\n            def dfs2(pos, lim, started, sum_val, e2, e3, e5, e7):\n                if pos == len(s):\n                    if started and sum_val > 0:\n                        prod = (2 ** e2) * (3 ** e3) * (5 ** e5) * (7 ** e7)\n                        return 1 if prod % sum_val == 0 else 0\n                    return 0\n                limit = int(s[pos]) if lim else 9\n                tot = 0\n                for dig in range(0, limit + 1):\n                    new_lim = lim and (dig == limit)\n                    if not started:\n                        if dig == 0:\n                            tot += dfs2(pos + 1, new_lim, False, 0, 0, 0, 0, 0)\n                        else:\n                            c2, c3, c5, c7 = contrib[dig]\n                            tot += dfs2(pos + 1, new_lim, True, dig, c2, c3, c5, c7)\n                    else:\n                        if dig == 0:\n                            continue\n                        c2, c3, c5, c7 = contrib[dig]\n                        tot += dfs2(pos + 1, new_lim, True, sum_val + dig, e2 + c2, e3 + c3, e5 + c5, e7 + c7)\n                return tot\n        \n            return dfs1(0, True, False, False) + dfs2(0, True, False, 0, 0, 0, 0, 0)\n    \n        result = count_f(r) - count_f(l - 1)\n        return result\n","author":"shi_logic","submissionId":"611259039"},[]]},{"392":[{"id":"392","fileName":"611259141.txt","sourceCode":"from functools import cache, lru_cache\n\ndef fmax(x, y):\n    if x > y:\n        return x\n    return y\n\ndef get_digits(val):\n    digits = []\n    while val:\n        digits.append(val % 10)\n        val //= 10\n    return digits[::-1]\n\ndef count_beautiful_numbers(l: int, r: int) -> int:\n    return count_beautiful_upto(r) - count_beautiful_upto(l - 1)\n\ndef count(n: int) -> int:\n    digits = get_digits(n)\n    if n == 0:\n        return 0\n    @cache\n    def dfs(ss, pp, idx, is_bound, zero):\n        if idx == len(digits):  \n            return ss > 0 and (not (pp % ss))\n        limit = digits[idx] if is_bound else 9\n        total = 0\n\n        for d in range(0, limit + 1):\n            new_ss = ss + d\n            new_pp = pp * d\n            if zero and (not d):\n                new_pp = pp\n            total += dfs(new_ss, new_pp, idx + 1, is_bound and (d == limit), zero and (not d))\n\n        return total\n\n    return dfs(0, 1, 0, True, True)\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        if l == 1:\n            return count(r)\n        return count(r) - count(l - 1)\n        ","author":"ikun","submissionId":"611259141"},[]]},{"393":[{"id":"393","fileName":"611258222.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def f(a):\n            if a == 0:\n                return 0\n            t = str(a)\n            n = len(t)\n\n            @cache\n            def f(i,p,s,is_limit):\n                if i == n:\n                    return int(s>0 and p%s==0)\n                up = int(t[i]) if is_limit else 9 \n                down = 0 if s>0 else 1 \n                ans = 0 \n                if s == 0:\n                    ans += f(i+1, 1,0, False)\n                for j in range(down,up+1):\n                    ans += f(i+1,p*j,s+j,is_limit and j == up)\n                return ans\n            return f(0,1,0,True)\n        # print(f(100),f(20))\n        return f(r) - f(l-1)\n        ","author":"陆鸢","submissionId":"611258222"},[]]},{"394":[{"id":"394","fileName":"611259244.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        @lru_cache(None)\n        def dfs(i,s,is_limit,is_zero,a,b):\n            if i == len(s):\n                # if b != 0 and a % b == 0:\n                #     print(a,b)\n                return a % b == 0 if b != 0 else 0\n            max_val = int(s[i]) + 1 if is_limit else 10\n            ans = 0\n            for j in range(max_val):\n                if is_zero and j == 0:\n                    c = 1\n                elif is_zero:\n                    c = j\n                else:\n                    c = a * j\n                ans += dfs(i+1,s,is_limit and j == max_val-1,is_zero and j==0,c,b+j)\n            return ans\n\n        right = dfs(0,str(r),True,True,1,0)\n        left = dfs(0,str(l-1),True,True,1,0)\n        return right - left","author":"风痕依旧","submissionId":"611259244"},[]]},{"395":[{"id":"395","fileName":"611259478.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        sl, sr = str(l), str(r)\n        n = len(sr)\n        while n > len(sl):\n            sl = '0'+sl\n\n        lo = [int(v) for v in sl]\n        hi = [int(v) for v in sr]\n        print(lo,hi)\n\n        @cache\n        def dfs(pos, tlo, pd, thi, mx, ms):\n            #print('dfs', pos, tlo, thi, mx, ms)\n            if pos >= n:\n                return 1 if mx%ms == 0 else 0\n\n            l, r = 0, 9\n            if tlo:\n                l = lo[pos]\n            if thi:\n                r = hi[pos]\n            \n            res = 0\n            for i in range(l,r+1):\n                if i > 0:\n                    pd = True\n                res += dfs(pos+1, tlo and i == l, pd, thi and i == r, mx*i if pd else mx, ms+i)\n            return res\n\n        ret = dfs(0, True, False, True, 1, 0)\n        dfs.cache_clear()\n        return ret","author":"cpp20","submissionId":"611259478"},[]]},{"396":[{"id":"396","fileName":"611259254.txt","sourceCode":"\nstruct State {\n    bool started;\n    bool hasZero;\n    int sum;\n    int e2, e3, e5, e7;\n    bool operator==(const State &other) const {\n        return started == other.started && hasZero == other.hasZero &&\n               sum == other.sum && e2 == other.e2 && e3 == other.e3 &&\n               e5 == other.e5 && e7 == other.e7;\n    }\n};\n\nstruct StateHash {\n    size_t operator()(const State &s) const {\n        size_t res = 17;\n        res = res * 31 + hash<bool>()(s.started);\n        res = res * 31 + hash<bool>()(s.hasZero);\n        res = res * 31 + hash<int>()(s.sum);\n        res = res * 31 + hash<int>()(s.e2);\n        res = res * 31 + hash<int>()(s.e3);\n        res = res * 31 + hash<int>()(s.e5);\n        res = res * 31 + hash<int>()(s.e7);\n        return res;\n    }\n};\n\nclass Solution {\npublic:\n    vector<array<int,4>> factor = {\n        {0,0,0,0},\n        {0,0,0,0},\n        {1,0,0,0},\n        {0,1,0,0},\n        {2,0,0,0},\n        {0,0,1,0},\n        {1,1,0,0},\n        {0,0,0,1},\n        {3,0,0,0},\n        {0,2,0,0}\n    };\n\n    vector<tuple<int,int,int,int,bool>> sumFactor;\n    void init() {\n        sumFactor.resize(91);\n        for (int s = 0; s <= 90; s++) {\n            if(s == 0) {\n                sumFactor[s] = make_tuple(0,0,0,0,true);\n                continue;\n            }\n            int temp = s, cnt2 = 0, cnt3 = 0, cnt5 = 0, cnt7 = 0;\n            while(temp % 2 == 0) { cnt2++; temp /= 2; }\n            while(temp % 3 == 0) { cnt3++; temp /= 3; }\n            while(temp % 5 == 0) { cnt5++; temp /= 5; }\n            while(temp % 7 == 0) { cnt7++; temp /= 7; }\n            bool bad = (temp == 1);\n            sumFactor[s] = make_tuple(cnt2, cnt3, cnt5, cnt7, bad);\n        }\n    }\n    \n    long long countBeautiful(const string &s) {\n        int n = s.size();\n        vector<unordered_map<State, long long, StateHash>> dp(2);\n        State init{false, false, 0, 0, 0, 0, 0};\n        dp[1][init] = 1;\n        for (int pos = 0; pos < n; pos++) {\n            vector<unordered_map<State, long long, StateHash>> newdp(2);\n            int curDigit = s[pos]-'0';\n            for (int tightFlag = 0; tightFlag < 2; tightFlag++) {\n                for (auto &entry : dp[tightFlag]) {\n                    State st = entry.first;\n                    long long cnt = entry.second;\n                    int limit = (tightFlag == 1 ? curDigit : 9);\n                    for (int d = 0; d <= limit; d++) {\n                        int newTight = (tightFlag==1 && d==limit) ? 1 : 0;\n                        State ns = st;\n                        if (!st.started && d==0) {\n                            // do nothing\n                        } else {\n                            ns.started = true;\n                            ns.sum += d;\n                            if(d==0) {\n                                ns.hasZero = true;\n                            } else {\n                                ns.e2 += factor[d][0];\n                                ns.e3 += factor[d][1];\n                                ns.e5 += factor[d][2];\n                                ns.e7 += factor[d][3];\n                            }\n                        }\n                        newdp[newTight][ns] += cnt;\n                    }\n                }\n            }\n            dp = move(newdp);\n        }\n        long long res = 0;\n        for (int tightFlag = 0; tightFlag < 2; tightFlag++) {\n            for (auto &entry : dp[tightFlag]) {\n                State st = entry.first;\n                if (!st.started) continue;\n                if(st.hasZero) {\n                    res += entry.second;\n                } else {\n                    auto [req2, req3, req5, req7, bad] = sumFactor[st.sum];\n                    if(!bad) continue;\n                    if(st.e2 >= req2 && st.e3 >= req3 &&\n                       st.e5 >= req5 && st.e7 >= req7)\n                        res += entry.second;\n                }\n            }\n        }\n        return res;\n    }\n    \n    int f(int x) {\n        if(x < 1) return 0;\n        string s = to_string(x);\n        init();\n        return (int) countBeautiful(s);\n    }\n    \n    int beautifulNumbers(int l, int r) {\n        return f(r) - f(l - 1);\n    }\n};\n","author":"discipline","submissionId":"611259254"},[]]},{"397":[{"id":"397","fileName":"611260124.txt","sourceCode":"int dp[10][82][82];\nclass Solution {\npublic:\n  int beautifulNumbers(int l, int r) {\n    string lo = to_string(l), hi = to_string(r);\n    int n = (int)hi.size();\n    lo = string(n-(int)lo.size(), '0')+lo;\n    int ans = 0;\n    for (int target = 1; target <= 81; target++) {\n      memset(dp, -1, n*sizeof(dp[0]));\n      auto dfs = [&] (auto &&self, int i, int prod, int sum, int leading_zero, int lo_limit, int hi_limit) -> int {\n        if (i == n) {\n          return sum == target && prod == 0;\n        }\n        if (!leading_zero && !lo_limit && !hi_limit && dp[i][prod][sum] != -1) {\n          return dp[i][prod][sum];\n        }\n        int res = 0;\n        int low = (lo_limit ? lo[i]-'0' : 0), hig = (hi_limit ? hi[i]-'0' : 9);\n        for (int d = low; d <= hig; d++) {\n          res += self(self, i+1, (leading_zero && d == 0 ? prod : prod*d%target), sum+d, leading_zero && d == 0, lo_limit && d == low, hi_limit && d == hig);\n        }\n        if (!leading_zero && !lo_limit && !hi_limit) dp[i][prod][sum] = res;\n        return res;\n      };\n      ans += dfs(dfs, 0, 1, 0, true, true, true);\n    }\n    return ans;\n  }\n};","author":"upk1_dwk2","submissionId":"611260124"},[]]},{"398":[{"id":"398","fileName":"611259750.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count_beautiful(n):\n            if n < 1:\n                return 0            \n            digits = list(map(int, str(n)))\n            length = len(digits)\n            \n            @lru_cache(None)\n            def dp(pos, tight, sum_digits, product_digits, leading_zero):\n                if pos == length:\n                    return 1 if sum_digits > 0 and product_digits % sum_digits == 0 else 0\n                limit = digits[pos] if tight else 9\n                res = 0\n                for d in range(0, limit + 1):\n                    new_tight = tight and (d == limit)\n                    new_sum = sum_digits + d\n                    new_product = product_digits * d if not leading_zero else d  \n                    res += dp(pos + 1, new_tight, new_sum, new_product, leading_zero and d == 0)\n                return res\n                \n            return dp(0, True, 0, 1, True)\n\n        return count_beautiful(r) - count_beautiful(l - 1)\n","author":"终不负少年游","submissionId":"611259750"},[]]},{"399":[{"id":"399","fileName":"611260641.txt","sourceCode":"from typing import *\n\n\nimport math\n\n\ndef f(n: int) -> int:\n    s = list(map(int, str(n)))\n    res = 0\n    for m in range(1, 82):\n        cm = m\n        for i in range(2, 10):\n            while cm % i == 0:\n                cm //= i\n        if cm != 1:\n            p = [0] * (2 * (m + 1) * 2)\n            for i in range(len(s)):\n                q = [0] * (2 * (m + 1) * 2)\n                for j in range(2 * (m + 1) * 2):\n                    if not p[j]:\n                        continue\n                    u, w, v = j // 2 // (m + 1), j // 2 % (m + 1), j % 2\n                    for d in range(10):\n                        if v and d > s[i]:\n                            continue\n                        uu = u or d == 0\n                        ww = w + d\n                        vv = v and d == s[i]\n                        if ww <= m:\n                            q[uu * 2 * (m + 1) + ww * 2 + vv] += p[j]\n                for d in range(1, 10):\n                    if i == 0 and d > s[i]:\n                        continue\n                    uu = 0\n                    ww = d\n                    vv = i == 0 and d == s[i]\n                    if ww <= m:\n                        q[uu * 2 * (m + 1) + ww * 2 + vv] += 1\n                p = q\n            res += p[(m + 1) * 2 + m * 2] + p[(m + 1) * 2 + m * 2 + 1]\n            continue\n\n        p = [0] * (m * (m + 1) * 2)\n        for i in range(len(s)):\n            q = [0] * (m * (m + 1) * 2)\n            for j in range(m * (m + 1) * 2):\n                if not p[j]:\n                    continue\n                u, w, v = j // 2 // (m + 1), j // 2 % (m + 1), j % 2\n                if w + 9 * (len(s) - i) < m:\n                    continue\n                for d in range(10):\n                    if v and d > s[i]:\n                        continue\n                    uu = math.gcd(u * d, m)\n                    if uu == m:\n                        uu = 0\n                    ww = w + d\n                    vv = v and d == s[i]\n                    if ww <= m:\n                        q[uu * 2 * (m + 1) + ww * 2 + vv] += p[j]\n            for d in range(1, 10):\n                if i == 0 and d > s[i]:\n                    continue\n                uu = math.gcd(d, m)\n                if uu == m:\n                    uu = 0\n                ww = d\n                vv = i == 0 and d == s[i]\n                if ww <= m:\n                    q[uu * 2 * (m + 1) + ww * 2 + vv] += 1\n            p = q\n        res += p[m * 2] + p[m * 2 + 1]\n    return res\n\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return f(r) - f(l - 1)\n","author":"PyIsBestLang","submissionId":"611260641"},[]]},{"400":[{"id":"400","fileName":"611261842.txt","sourceCode":"class Solution {\n    private int k;\n\n    public int beautifulNumbers(int l, int r) {\n        // 数字之和 [1, 9*9] = [1,81]\n        int ans = 0;\n        for (int k = 1; k <= 81; k++) {\n            int res = numberOfBeautifulIntegers(l, r, k);\n//            System.out.println(String.format(\"k=%d, res=%d\", k, res));\n            ans += res;\n        }\n        return ans;\n    }\n\n    public int numberOfBeautifulIntegers(int low, int high, int k) {\n        this.k = k;\n        int ans1 = count(low - 1);\n        int ans2 = count(high);\n        return ans2 - ans1;\n    }\n\n    private char[] s;\n    private int[][][] dp;\n\n    private int count(int num) {\n        s = String.valueOf(num).toCharArray();\n        int n = String.valueOf(num).length();\n        dp = new int[n][k][82];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < k; j++) {\n                Arrays.fill(dp[i][j], -1);\n            }\n        }\n        return f(0, 1, 0, true, false);\n    }\n\n    // remain:%k的余数\n    private int f(int i, int remain, int digitSum, boolean isLimit, boolean isNum) {\n        if (i == s.length) {\n            return (isNum && remain == 0 && digitSum == k) ? 1 : 0;\n        }\n        if (!isLimit && isNum && dp[i][remain][digitSum] != -1) {\n            return dp[i][remain][digitSum];\n        }\n        int ans = 0;\n        if (!isNum) {\n            ans += f(i + 1, remain, digitSum, false, false);\n        }\n        int down = isNum ? 0 : 1;\n        int up = isLimit ? s[i] - '0' : 9;\n        for (int d = down; d <= up; d++) {\n            ans += f(i + 1, remain * d % k, digitSum + d, isLimit && d == up, true);\n        }\n        if (!isLimit && isNum) {\n            dp[i][remain][digitSum] = ans;\n        }\n        return ans;\n    }\n}","author":"ning1ing","submissionId":"611261842"},[]]},{"401":[{"id":"401","fileName":"611260527.txt","sourceCode":"//Timestamp: 2025-03-16 11:33:08\n#define DROP\n#ifdef ONLINE\n#undef LOCAL\n#endif\n#ifndef LOCAL\n#undef _GLIBCXX_DEBUG\n#undef _DEBUG\n#endif\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <deque>\n#include <fstream>\n//#include <ext/pb_ds/assoc_container.hpp>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <type_traits>\n#include <chrono>\n#include <random>\n#include <complex>\n#include <bitset>\n#include <set>\n#include <list>\n#include <array>\n//#include \"compiler_hint.cpp\"\ntemplate <class T, int S>\nstruct MDVecDef {\n  using Type = std::vector<typename MDVecDef<T, S - 1>::Type>;\n  template <typename... Args>\n  static Type Make(int n, Args... args) {\n    return Type(n, MDVecDef<T, S - 1>::Make(args...));\n  }\n};\ntemplate <class T>\nstruct MDVecDef<T, 0> {\n  using Type = T;\n  static Type Make(T val = T()) { return val; }\n};\ntemplate <class T, int S = 1>\nusing MDVec = typename MDVecDef<T, S>::Type;\n#ifndef M_PI\n#define M_PI 3.14159265358979323851280895940618620443274267017841L\n#endif\n#ifndef M_E\n#define M_E 2.718281828459045235428168107993940338928950950503355L\n#endif\n#ifdef LOCAL\n#define Assert(x) assert(x)\n#define DebugRun(X) X\n#define DebugPoint int _x_ = 0; _x_++;\n#else\n#define Debug(...) 42\n#define DebugFmtln(...) 42\n#define Assert(x) 42\n#define DebugRun(X)\n#define DebugPoint\n#endif\n#define Trace(x) DebugFmtln(\"Line %d: %s\", __LINE__, #x)\ntemplate<class T>\ninline T DebugRet(T x) {\n    Debug(x);\n    return x;\n}\n#define const_ref(T) const T &\n#define mut_ref(T) T &\n#define let auto\n#define var auto\n#define varr var&\n#define MEMSET0(X) std::memset(&X, 0, sizeof(X)) \n#define Size(T) int((T).size())\n#define All(data) data.begin(), data.end()\n#define MakeUnique(data) data.resize(std::unique(All(data)) - data.begin())\n#define MakeUniqueAndSort(data) Sort(All(data)); MakeUnique(data) \n#define MakeAttribute(struct_name, Type, attr_name)               \n  struct struct_name {                                            \n    using attr_name ## _type = Type;                              \n    Type attr_name;                                               \n    mut_ref(Type) get_##attr_name() { return attr_name; }         \n    const_ref(Type) get_##attr_name() const { return attr_name; } \n  };\n#define MakeTemplateAttribute(struct_name, attr_name)          \n  template <class T>                                           \n  struct struct_name {                                         \n    using attr_name##_type = T;                             \n    T attr_name;                                               \n    mut_ref(T) get_##attr_name() { return attr_name; }         \n    const_ref(T) get_##attr_name() const { return attr_name; } \n  };\n#define ImplDefaultEq(name)                        \n  bool operator==(const name &a, const name &b) {  \n    return std::memcmp(&a, &b, sizeof(name)) == 0; \n  }                                                \n  bool operator!=(const name &a, const name &b) { return !(a == b); }\n#define ImplDefaultComparision(name)                                \n  bool operator>(const name &rhs) const { return rhs < *this; }     \n  bool operator<=(const name &rhs) const { return !(*this > rhs); } \n  bool operator>=(const name &rhs) const { return !(*this < rhs); }\n#define ImplArithmeticAssignOperation(name)                                 \n  name &operator+=(const name &rhs) { return *this = (*this) + rhs; } \n  name &operator-=(const name &rhs) { return *this = (*this) - rhs; } \n  name &operator*=(const name &rhs) { return *this = (*this) * rhs; } \n  name &operator/=(const name &rhs) { return *this = (*this) / rhs; }\n#define IsType(Type, param, ret_type)                                        \n  template <typename OnlyWhenArg = param>                                    \n  enable_if_t<is_same_v<OnlyWhenArg, param> && is_same_v<OnlyWhenArg, Type>, \n              ret_type>\n#define IsBool(param, ret_type)       \n  template <bool OnlyWhenArg = param> \n  enable_if_t<OnlyWhenArg == (param) && OnlyWhenArg, ret_type>\n#define IsBoolStatic(param, ret_type) \n  template <bool OnlyWhenArg = param> \n  static enable_if_t<OnlyWhenArg == (param) && OnlyWhenArg, ret_type>\n#define MakeAnnotation(name)         \n  template <class T>                 \n  struct is_##name {                 \n    static const bool value = false; \n  };                                 \n  template <class T>                 \n  inline constexpr bool is_##name##_v = is_##name<T>::value;\n#define AssignAnnotation(cls, annotation) \n  template <>                             \n  struct is_##annotation<cls> {           \n    static const bool value = true;       \n  };\n#define AssignAnnotationTemplate(cls, annotation, type) \n  template <type T>                                     \n  struct is_##annotation<cls<T>> {                      \n    static const bool value = true;                     \n  };\n#define FunctionAlias(from, to)                       \n  template <typename... Args>                         \n  inline auto to(Args &&...args)                      \n      ->decltype(from(std::forward<Args>(args)...)) { \n    return from(std::forward<Args>(args)...);         \n  }\n#define CastToScalar(field, type) \n  operator type() const { return type(field); }\n#define CastToAllScalar(field) \n  CastToScalar(field, i8);     \n  CastToScalar(field, u8);     \n  CastToScalar(field, i16);    \n  CastToScalar(field, u16);    \n  CastToScalar(field, i32);    \n  CastToScalar(field, u32);    \n  CastToScalar(field, i64);    \n  CastToScalar(field, u64);    \n  CastToScalar(field, f32);    \n  CastToScalar(field, f64);    \n  CastToScalar(field, f80);\n#define COMMA ,\n#ifndef LOCAL\nstd::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());\n#else\nstd::mt19937 rng(0);\n#endif\ntemplate <class T> T random_choice(T l, T r, std::mt19937 &gen = rng) {\n  std::uniform_int_distribution<T> random(l, r);\n  return random(gen);\n}\nnamespace dalt {\n#ifndef LOCAL\nstruct Timer {explicit Timer(const char* m) {}void stop() const {}};\n#else\n#endif\n}\nusing i8 = char;\nusing i16 = short;\nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u16 = unsigned short;\nusing u32 = unsigned int;\nusing u64 = unsigned long long;\nusing usize = size_t;\nusing f32 = float;\nusing f64 = double;\n// 16 exp, 64 precision\nusing f80 = long double;\nFunctionAlias(std::lower_bound, LowerBound);\nFunctionAlias(std::upper_bound, UpperBound);\nFunctionAlias(std::unique, Unique);\nFunctionAlias(std::swap, Swap);\nFunctionAlias(std::min, Min);\nFunctionAlias(std::max, Max);\nFunctionAlias(std::abs, Abs);\nFunctionAlias(std::sin, Sin);\nFunctionAlias(std::asin, Asin);\nFunctionAlias(std::cos, Cos);\nFunctionAlias(std::acos, Acos);\nFunctionAlias(std::tan, Tan);\nFunctionAlias(std::atan, Atan);\nFunctionAlias(std::sort, Sort);\nFunctionAlias(std::fill, Fill);\nFunctionAlias(std::move, Move);\nFunctionAlias(std::reverse, Reverse);\nFunctionAlias(std::max_element, MaxElement);\nFunctionAlias(std::min_element, MinElement);\nFunctionAlias(std::make_tuple, MakeTuple);\nFunctionAlias(std::make_pair, MakePair);\nFunctionAlias(std::clamp, Clamp);\nFunctionAlias(std::shuffle, Shuffle);\nFunctionAlias(std::to_string, ToString);\nFunctionAlias(std::tie, Tie);\nFunctionAlias(std::get<0>, Get0);\nFunctionAlias(std::get<1>, Get1);\nFunctionAlias(std::get<2>, Get2);\nFunctionAlias(std::get<3>, Get3);\nFunctionAlias(std::get<4>, Get4);\ntemplate <typename _Signature>\nusing Function = std::function<_Signature>;\ntemplate <typename _Signature>\nusing Func = Function<_Signature>;\nusing Str = std::string;\nusing String = Str;\nusing StringStream = std::stringstream;\nusing IStream = std::istream;\nusing OStream = std::ostream;\nusing std::enable_if;\nusing std::enable_if_t;\nusing std::is_base_of;\nusing std::is_base_of_v;\nusing std::is_floating_point;\nusing std::is_floating_point_v;\nusing std::is_integral;\nusing std::is_integral_v;\nusing std::is_arithmetic;\nusing std::is_arithmetic_v;\nusing std::is_same;\nusing std::is_same_v;\nusing std::tie;\nauto &Stderr = std::cerr;\nauto &Stdin = std::cin;\nauto &Stdout = std::cout;\ntemplate <class T>\nusing Less = std::less<T>;\ntemplate <class T>\nusing Greater = std::greater<T>;\ntemplate <typename _Key, typename _Tp, typename _Compare = Less<_Key>>\nusing TreeMap = std::map<_Key, _Tp, _Compare>;\ntemplate <typename _Key, typename _Compare = Less<_Key>>\nusing TreeSet = std::set<_Key, _Compare>;\ntemplate <typename _Key, typename _Compare = std::less<_Key>,\n          typename _Alloc = std::allocator<_Key>>\nusing MultiTreeSet = std::multiset<_Key, _Compare, _Alloc>;\ntemplate <class T>\nusing Deque = std::deque<T>;\ntemplate <class T>\nusing Queue = std::queue<T>;\ntemplate <class T>\nusing Vec = std::vector<T>;\ntemplate <class T>\nusing Reducer = Func<T(const T &, const T &)>;\ntemplate <class T>\nusing Comparator = Func<bool(const T &, const T &)>;\ntemplate <class T>\nusing Indexer = Func<T(i32)>;\ntemplate <class T>\nusing Indexer2 = Func<T(i32, i32)>;\ntemplate <class A, class B = A, class C = A>\nusing Adder = Func<C(const A &, const B &)>;\ntemplate <class I>\nusing Checker = Func<bool(const I &)>;\ntemplate <class A, class B>\nusing BiChecker = Func<bool(const A &, const B &)>;\ntemplate <class T>\nusing Consumer = Func<void(const T &)>;\nusing Action = Func<void()>;\ntemplate<class T>\nusing Supplier = Func<T()>;\ntemplate <class FIRST, class SECOND>\nusing BiConsumer = Func<void(const FIRST &, const SECOND &)>;\ntemplate <class F, class T = F>\nusing Mapper = Func<T(const F &)>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, Vec<T>, Greater<T>>;\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T, Vec<T>, Less<T>>;\ntemplate <class T, usize S>\nusing Array = std::array<T, S>;\ntemplate <typename... _Elements>\nusing Tuple = std::tuple<_Elements...>;\ntemplate <class T, class = enable_if_t<is_floating_point_v<T>>>\nusing Complex = std::complex<T>;\ntemplate <class A, class B>\nusing Pair = std::pair<A, B>;\nnamespace dalt {\ntemplate <class T>\nIStream& operator>>(IStream& is, Vec<T>& val) {\n  for (auto& v : val) {\n    is >> v;\n  }\n  return is;\n}\n#define VEC_OP(op)                         \n  template <class T>                       \n  Vec<T>& operator op(Vec<T>& data, T x) { \n    for (auto& v : data) {                 \n      v op x;                              \n    }                                      \n    return data;                           \n  }\nVEC_OP(+=)\nVEC_OP(-=)\nVEC_OP(*=)\nVEC_OP(/=)\nVEC_OP(%=)\nVEC_OP(^=)\nVEC_OP(&=)\nVEC_OP(|=)\nVEC_OP(==)\nVEC_OP(!=)\ntemplate <class T>\nint Compare(const Vec<T>& lhs, const Vec<T>& rhs) {\n  for(int i = 0; i < Size(lhs) && i < Size(rhs); i++) {\n    if(lhs[i] != rhs[i]) {\n      return lhs[i] < rhs[i] ? -1 : 1;\n    }\n  }\n  return Size(lhs) < Size(rhs) ? -1 : Size(lhs) > Size(rhs) ? 1 : 0;\n}\ntemplate <class T>\nbool operator<(const Vec<T>& lhs, const Vec<T>& rhs) {\n  return Compare(lhs, rhs) < 0;\n}\ntemplate <class T>\nbool operator>(const Vec<T>& lhs, const Vec<T>& rhs) {\n  return Compare(lhs, rhs) > 0;\n}\ntemplate <class T>\nbool operator<=(const Vec<T>& lhs, const Vec<T>& rhs) {\n  return Compare(lhs, rhs) <= 0;\n}\ntemplate <class T>\nbool operator>=(const Vec<T>& lhs, const Vec<T>& rhs) {\n  return Compare(lhs, rhs) >= 0;\n}\n}  // namespace dalt\n//#include \"array_adder.cpp\"\n#ifndef _builtin_clz\ninline i32 _builtin_clz(u32 i) {\n  // HD, Count leading 0's\n  if (i <= 0) return i == 0 ? 32 : 0;\n  int n = 31;\n  if (i >= 1 << 16) {\n    n -= 16;\n    i >>= 16;\n  }\n  if (i >= 1 << 8) {\n    n -= 8;\n    i >>= 8;\n  }\n  if (i >= 1 << 4) {\n    n -= 4;\n    i >>= 4;\n  }\n  if (i >= 1 << 2) {\n    n -= 2;\n    i >>= 2;\n  }\n  return n - (i >> 1);\n}\n#endif\n#ifndef _builtin_clzll\ninline i32 _builtin_clzll(u64 i) {\n  u32 x = u32(i >> 32);\n  return x == 0 ? 32 + _builtin_clz((int)i) : _builtin_clz(x);\n}\n#endif\n#ifndef _builtin_ctz\ninline i32 _builtin_ctz(u32 i) {\n  // HD, Figure 5-14\n  int y;\n  if (i == 0) return 32;\n  int n = 31;\n  y = i << 16;\n  if (y != 0) {\n    n = n - 16;\n    i = y;\n  }\n  y = i << 8;\n  if (y != 0) {\n    n = n - 8;\n    i = y;\n  }\n  y = i << 4;\n  if (y != 0) {\n    n = n - 4;\n    i = y;\n  }\n  y = i << 2;\n  if (y != 0) {\n    n = n - 2;\n    i = y;\n  }\n  return n - ((i << 1) >> 31);\n}\n#endif\n#ifndef _builtin_ctzll\ninline i32 _builtin_ctzll(u64 i) {\n  // HD, Figure 5-14\n  int x, y;\n  if (i == 0) return 64;\n  int n = 63;\n  y = (int)i;\n  if (y != 0) {\n    n = n - 32;\n    x = y;\n  } else\n    x = (int)(i >> 32);\n  y = x << 16;\n  if (y != 0) {\n    n = n - 16;\n    x = y;\n  }\n  y = x << 8;\n  if (y != 0) {\n    n = n - 8;\n    x = y;\n  }\n  y = x << 4;\n  if (y != 0) {\n    n = n - 4;\n    x = y;\n  }\n  y = x << 2;\n  if (y != 0) {\n    n = n - 2;\n    x = y;\n  }\n  return n - ((x << 1) >> 31);\n}\n#endif\n#ifndef _builtin_popcount\ninline i32 _builtin_popcount(u32 i) {\n  // HD, Figure 5-2\n  i = i - ((i >> 1) & 0x55555555);\n  i = (i & 0x33333333) + ((i >> 2) & 0x33333333);\n  i = (i + (i >> 4)) & 0x0f0f0f0f;\n  i = i + (i >> 8);\n  i = i + (i >> 16);\n  return i & 0x3f;\n}\n#endif\n#ifndef _builtin_popcountll\ninline i32 _builtin_popcountll(u64 i) {\n  // HD, Figure 5-2\n  i = i - ((i >> 1) & 0x5555555555555555ll);\n  i = (i & 0x3333333333333333ll) + ((i >> 2) & 0x3333333333333333ll);\n  i = (i + (i >> 4)) & 0x0f0f0f0f0f0f0f0fll;\n  i = i + (i >> 8);\n  i = i + (i >> 16);\n  i = i + (i >> 32);\n  return (int)i & 0x7f;\n}\n#endif\nnamespace dalt {\ninline i32 LeadingZeroNumber(u32 x) {\n  if (x == 0) return 32;\n  return _builtin_clz(x);\n}\ninline i32 LeadingZeroNumber(i32 x) { return LeadingZeroNumber(u32(x)); }\ninline i32 LeadingZeroNumber(u64 x) {\n  if (x == 0) return 64;\n  return _builtin_clzll(x);\n}\ninline i32 LeadingZeroNumber(i64 x) { return LeadingZeroNumber(u64(x)); }\ninline i32 TrailingZeroNumber(u32 x) {\n  if (x == 0) return 32;\n  return _builtin_ctz(x);\n}\ninline i32 TrailingZeroNumber(i32 x) { return TrailingZeroNumber(u32(x)); }\ninline i32 TrailingZeroNumber(u64 x) {\n  if (x == 0) return 64;\n  return _builtin_ctzll(x);\n}\ninline i32 TrailingZeroNumber(i64 x) { return TrailingZeroNumber(u64(x)); }\ninline i32 Log2Ceil(u32 x) {\n  if (x == 0) {\n    return 0;\n  }\n  return 32 - LeadingZeroNumber(x - 1);\n}\ninline i32 Log2Ceil(u64 x) {\n  if (x == 0) {\n    return 0;\n  }\n  return 64 - LeadingZeroNumber(x - 1);\n}\ninline i32 Log2Floor(u32 x) {\n  if (x == 0) {\n    return -1;\n  }\n  return 31 - LeadingZeroNumber(x);\n}\ninline i32 Log2Floor(u64 x) {\n  if (x == 0) {\n    return -1;\n  }\n  return 63 - LeadingZeroNumber(x);\n}\ninline i32 Log2Ceil(i32 x) { return Log2Ceil(u32(x)); }\ninline i32 Log2Ceil(i64 x) { return Log2Ceil(u64(x)); }\ninline i32 Log2Floor(i32 x) { return Log2Floor(u32(x)); }\ninline i32 Log2Floor(i64 x) { return Log2Floor(u64(x)); }\ninline i32 CountBit(u32 x) { return _builtin_popcount(x); }\ninline i32 CountBit(i32 x) { return CountBit(u32(x)); }\ninline i32 CountBit(u64 x) { return _builtin_popcountll(x); }\ninline i32 CountBit(i64 x) { return CountBit(u64(x)); }\ninline i32 HighestOneBitOffset(u32 x) { return Log2Floor(x); }\ninline i32 HighestOneBitOffset(i32 x) { return HighestOneBitOffset(u32(x)); }\ninline i32 HighestOneBitOffset(u64 x) { return Log2Floor(x); }\ninline i32 HighestOneBitOffset(i64 x) { return HighestOneBitOffset(u64(x)); }\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, T> LowestOneBit(T x) {\n  return x & -x;\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, T> HighestOneBit(T x) {\n  if (x == 0) {\n    return x;\n  }\n  return T(1) << HighestOneBitOffset(x);\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, i32> LowestOneBitOffset(T x) {\n  if (x == 0) {\n    return -1;\n  }\n  return HighestOneBitOffset(LowestOneBit(x));\n}\ninline u32 HighestKOnes32(i32 k) {\n  if (k == 0) {\n    return 0;\n  }\n  return (~u32()) << (32 - k);\n}\ninline u64 HighestKOnes64(i32 k) {\n  if (k == 0) {\n    return 0;\n  }\n  return (~u64()) << (64 - k);\n}\ninline u32 LowestKOnes32(i32 k) {\n  if (k == 0) {\n    return 0;\n  }\n  return (~u32()) >> (32 - k);\n}\ninline u64 LowestKOnes64(i32 k) {\n  if (k == 0) {\n    return 0;\n  }\n  return (~u64()) >> (64 - k);\n}\ninline u64 IntervalOnes64(i32 l, i32 r) {\n  if (l > r) {\n    return 0;\n  }\n  u64 high = r < 63 ? (u64(-1) << r + 1) : 0;\n  u64 low = u64(-1) << l;\n  return high ^ low;\n}\ninline u32 IntervalOnes32(i32 l, i32 r) {\n  if (l > r) {\n    return 0;\n  }\n  u32 high = r < 31 ? (u32(-1) << r + 1) : 0;\n  u32 low = u32(-1) << l;\n  return high ^ low;\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, i32> KthBit(T x, i32 k) {\n  return (x >> k) & 1;\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, T> SetBit(T x, i32 k) {\n  return x | (T(1) << k);\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, T> ClearBit(T x, i32 k) {\n  return x & ~(T(1) << k);\n}\n}  // namespace dalt\n// #include \"binary_search.cpp\"\nusing namespace dalt;\n// #include \"collection.cpp\"\n// #include \"combination.cpp\"\n// #include \"function.cpp\"\n//#include \"graph.cpp\"\n//#include \"shortest_path.cpp\"\n// #include \"math.cpp\"\n// #include \"radix.cpp\"\n//#include \"modint.cpp\"\n//using Mi = ModInt1000000007;\n//#include \"prefixsum.cpp\"\nusing namespace std;\n//using namespace graph;\nnamespace dalt {\ntemplate <class T>\nstruct Optional {\n  using Self = Optional<T>;\n private:\n  T val;\n  bool show_up;\n public:\n  Optional(const T &arg_val) : val(arg_val), show_up(true) {}\n  Optional(const T &&arg_val) : val(arg_val), show_up(true) {}\n  Optional() : show_up(false) {}\n  const T &value() const {\n    Assert(show_up);\n    return val;\n  }\n  T &value() {\n    Assert(show_up);\n    return val;\n  }\n  T &operator*() { return value(); }\n  const T &operator*() const { return value(); }\n  bool is_some() const { return show_up; }\n  bool is_none() const { return !show_up; }\n  const T *operator->() const {\n    return &value();\n  }\n  T *operator->() { return &value(); }\n  inline operator T() const { return value(); }\n  T or_else(T def) const {\n    if (is_some()) {\n      return val;\n    } else {\n      return def;\n    }\n  }\n  template <class E>\n  Optional<E> map(const Mapper<T, E> &mapper) const {\n    if (is_some()) {\n      return mapper(value());\n    } else {\n      return Optional<E>();\n    }\n  }\n  bool operator==(const Self &b) const {\n    return show_up == b.show_up && (!show_up || val == b.val);\n  }\n};\ntemplate <class E>\nbool operator!=(const Optional<E> &a, const Optional<E> &b) {\n  return !(a == b);\n}\ntemplate <class E>\nOStream &operator<<(OStream &os, const Optional<E> &v) {\n  if (v.is_none()) {\n    os << \"{}\";\n  } else {\n    os << '{' << v.value() << '}';\n  }\n  return os;\n}\n}  // namespace dalt\nnamespace dalt {\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, T> Gcd(T a, T b) {\n  while (b != 0) {\n    a %= b;\n    Swap(a, b);\n  }\n  return a;\n}\n// ret_value = [x, y, gcd(a,b)] that x * a + y * b = gcd(a, b)\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, Array<T, 3>> ExtGcd(T a, T b) {\n  if (b == 0) {\n    return Array<T, 3>{1, 0, a};\n  }\n  auto div = a / b;\n  auto ans = ExtGcd(b, a - b * div);\n  auto x = ans[0];\n  auto y = ans[1];\n  return Array<T, 3>{y, x - a / b * y, ans[2]};\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, Optional<T>> PossibleModInverse(\n    T a, T modulus) {\n  auto res = ExtGcd(a, modulus);\n  if (res[2] == 1) {\n    auto ans = res[0] % modulus;\n    if (ans < 0) {\n      ans += modulus;\n    }\n    return ans;\n  }\n  return {};\n}\n}  // namespace dalt\n// #include \"dsu.cpp\"\n//   #include \"segtree.cpp\"\nusing namespace dalt;\nnamespace dalt {\ntemplate <class T, class C>\nIndexer<T> MakeIndexer(const C &data) {\n  return [&](auto i) -> T { return data[i]; };\n}\ntemplate <class T, class C>\nIndexer<T> MakeReverseIndexer(const C &data) {\n  return [&](auto i) -> T { return data[Size(data) - 1 - i]; };\n}\ntemplate <class T>\nVec<T> ExpandIndexer(int n, const Indexer<T> &indexer) {\n  Vec<T> ans;\n  ans.reserve(n);\n  for (int i = 0; i < n; i++) {\n    ans.push_back(indexer(i));\n  }\n  return ans;\n}\nIndexer<i32> SelfIndexer() {\n  return [](auto i) { return i; };\n}\ntemplate <class T>\nIndexer<T> ConstantIndexer(const T &val) {\n  return [=](auto i) { return val; };\n}\ntemplate <class A, class B>\nMapper<A, B> ConstructorMapper() {\n  return [&](auto a) { return B(a); };\n}\ntemplate <class T>\nAdder<T> NaturalAdder() {\n  return [](auto a, auto b) { return a + b; };\n}\ntemplate <class A, class B, class C>\nconstexpr Adder<A, B, C> EmptyAdder() {\n  return [](auto a, auto b) { return C(); };\n}\ntemplate <class A, class B = A>\nconstexpr Adder<A, B, A> ReturnLeftAdder() {\n  return [](auto a, auto b) { return a; };\n}\ntemplate <class A, class B = A>\nconstexpr Adder<A, B, B> ReturnRightAdder() {\n  return [](auto a, auto b) { return b; };\n}\ntemplate <class T>\nIndexer<int> BinaryIndexer(const T& val) {\n  return [=](int i) {return int((val >> i) & 1);};\n}\ntemplate <class T>\nIndexer<int> ReverseIndexer(int n, Indexer<T> indexer) {\n  return [=](int i) {return indexer(n - 1 - i);};\n}\nVec<int> MakeIndexVec(int n) {\n  Vec<int> ans(n);\n  for(int i = 0; i < n; i++) ans[i] = i;\n  return ans;\n}\n}  // namespace dalt\n//#include \"kmp.cpp\"\n// #include \"interval_map.cpp\"\n//#include \"matrix.cpp\"\n// #include \"hash_range.cpp\"\n// #include \"hashmap.cpp\"\n//#include \"binary_tree.cpp\"\n#ifdef LOCAL\nstruct TreeNode\n{\n  int val;\n  TreeNode *left;\n  TreeNode *right;\n  TreeNode()\n      : val(0),\n        left(nullptr), right(nullptr) {}\n  TreeNode(int x)\n      : val(x),\n        left(nullptr),\n        right(nullptr) {}\n  TreeNode(int x, TreeNode *left, TreeNode *right)\n      : val(x),\n        left(left), right(right) {}\n};\n#endif\n// #include \"interval_map.cpp\"\n// #include \"hash_range.cpp\"\n//#include \"segtree_beat.cpp\"\n//#include \"sparse_table.cpp\"\n//#include \"binary.cpp\"\n//#include \"fenwick_tree.cpp\"\n//#include \"segtree.cpp\"\n//#include \"operand.cpp\"\n//#include \"limit_value.cpp\"\n//using Lv = LimitValue<i64>;\n//#include \"min_cost_flow.cpp\"\n//#include \"binary_tree.cpp\"\n//#include \"treap.cpp\"\n//#include \"hashmap.cpp\"\n// #include \"segtree_beat.cpp\"\n// #include \"prefixsum.cpp\"\nnamespace dalt {\ntemplate <class A, class B>\ninline A& Chmin(A& a, const B& b) {\n  if (a > b) {\n    a = b;\n  }\n  return a;\n}\ntemplate <class T>\ninline T& Chmin(T& a, const T& b, const Comparator<T> &comp) {\n  if (comp(b, a)) {\n    a = b;\n  }\n  return a;\n}\ntemplate <class A, class B>\ninline A& Chmax(A& a, const B& b) {\n  if (a < b) {\n    a = b;\n  }\n  return a;\n}\ntemplate <class T>\ninline T& Chmax(T& a, const T& b, const Comparator<T>& comp) {\n  if (comp(a, b)) {\n    a = b;\n  }\n  return a;\n}\ntemplate <class T>\ninline T& AddTo(T& a, const T& b) {\n  a = a + b;\n  return a;\n}\ntemplate <class T>\ninline T& MulTo(T& a, const T& b) {\n  a = a * b;\n  return a;\n}\ntemplate <class T>\ninline T& SubFrom(T& a, const T& b) {\n  a = a - b;\n  return a;\n}\ntemplate <class T>\ninline T& DivFrom(T& a, const T& b) {\n  a = a / b;\n  return a;\n}\ntemplate <class T, class E>\nconstexpr enable_if_t<is_integral_v<E>, T> PowBinaryLift(T x, E n) {\n  if (n == E(0)) {\n    return T(1);\n  }\n  auto ans = PowBinaryLift(x, n >> 1);\n  ans = ans * ans;\n  if (n & 1) {\n    ans = ans * x;\n  }\n  return ans;\n}\ntemplate <class T>\ninline T MulLimit(T a, T b, T max, T def) {\n  if (a == T(0) || b == T(0)) {\n    return T(0);\n  }\n  // a * b <= max\n  // a <= max / b\n  // a <= floor(max / b)\n  if (a <= max / b) {\n    return a * b;\n  } else {\n    return def;\n  }\n}\ntemplate <class T>\ninline T MulLimit(T a, T b, T max) {\n  return MulLimit(a, b, max, max);\n}\ntemplate <class T>\ninline T AddLimit(T a, T b, T max, T def) {\n  if (a <= max - b) {\n    return a + b;\n  } else {\n    return def;\n  }\n}\ntemplate <class T>\ninline T AddLimit(T a, T b, T max) {\n  return AddLimit(a, b, max, max);\n}\ni64 Round(f32 x) { return roundf(x); }\ni64 Round(f64 x) { return round(x); }\ni64 Round(f80 x) { return roundl(x); }\n//l + ... + r\ntemplate<class T>\nT SumOfInterval(T l, T r) {\n  if(l > r) {\n    return T(0);\n  }\n  return (l + r) * (r - l + 1) / T(2);\n}\ntemplate<class T>\nT Pow2(T x) {\n  return x * x;\n}\n}  // namespace dalt\nnamespace dalt {\n  template<class T>\n  struct Radix {\n    Vec<T> base;\n    Radix(T x) {\n      static const T MAX_VALUE =\n          std::numeric_limits<T>::max();\n      base.push_back(1);\n      T y;\n      while((y = MulLimit(base.back(), x, MAX_VALUE, T(0))) != T(0)) {\n        base.push_back(y);\n      }\n    }\n    T get(T x, int kth) const {\n      if(kth >= Size(base)) {\n        return T(0);\n      }\n      return x / base[kth] % base[1];\n    }\n    T set(T x, int kth, T val) const {\n      return x + (val - get(x, kth)) * base[kth];\n    }\n  };\n}\nclass Solution\n{\npublic:\n  int beautifulNumbers(int l, int r) {\n    Radix<int> radix(10);\n    int maxSum = 0;\n    int numOfDigit = 0;\n    for(int i = 0; i < 10; i++) {\n      if(radix.get(r, i) > 0) {\n        maxSum = 9 * (i + 1);\n        numOfDigit = i;\n      }\n    }\n    int ans = 0;\n    var mem = MDVecDef<int, 5>::Make(2, 2, numOfDigit + 1, maxSum + 1, maxSum + 1, -1);\n    var defaultMem = MDVecDef<int, 5>::Make(2, 2, numOfDigit + 1, maxSum + 1, maxSum + 1, -1);\n    for(int mod = 1; mod <= maxSum; mod++) {\n      mem = defaultMem;\n      var dp = [&](var &rec, int sum, int remainder, int index, int c, int f) -> int {\n        if(index < 0) {\n          return int(remainder == 0 && sum == mod);\n        }\n        if(sum > mod) {\n          return 0;\n        }\n        //DebugFmtln(\"dp(%d, %d, %d, %d, %d, %d)\", mod, sum, remainder, index, c, f);\n        var &ans = mem[c][f][index][remainder][sum];\n        if(ans == -1) {\n          ans = 0;\n          int lval = radix.get(l, index);\n          int rval = radix.get(r, index);\n          for(int i = 0; i < 10; i++) {\n            if(lval > i && f) {\n              continue;\n            }\n            if(rval < i && c) {\n              continue;\n            }\n            ans += rec(rec, sum + i, sum + i == 0 ? 1 : (remainder * i % mod), index - 1, c && rval == i, f && lval == i);\n          }\n          DebugFmtln(\"dp(%d, %d, %d, %d, %d, %d) = %d\", mod, sum, remainder, index, c, f, ans);\n        }\n        return ans;\n      };\n      ans += dp(dp, 0, 1, numOfDigit, 1, 1);\n    }\n    return ans;\n  }\n};\n#ifdef LOCAL\nint main()\n{\n  Solution().beautifulNumbers(11, 11);\n  return 0;\n}\n#endif","author":"天塘","submissionId":"611260527"},[]]},{"402":[{"id":"402","fileName":"611261295.txt","sourceCode":"int f[10][82][82][82], a[10];\n\nclass Solution {\npublic:\n    int calc(int p) {\n        if (p == 0) return 0;\n        int n = 0;\n        while (p) {\n            a[n++] = p%10;\n            p /= 10;\n        }\n        int ret = 0;\n        for (int i = n-1; i > 0; --i) {\n            for (int j = 1; j < 82; ++j) {\n                for (int x = 1; x < 10; ++x) {\n                    for (int t = 0; t < 82; ++t) {\n                        if (j >= x && t*x%j == 0) {\n                            ret += f[i-1][j][j-x][t];\n                        }\n                    }\n                }\n            }\n        }\n        // printf(\"ret=%dn\", ret);\n        int s = 0, d = 1;\n        for (int i = n-1; i >= 0; --i) {\n            int y = a[i];\n            int x = 0;\n            if (i == n-1) x = 1;\n            for (; x < y; ++x) {\n                for (int j = s+x; j < 82; ++j) {\n                    for (int t = 0; t < j; ++t) {\n                        if (1LL*d*x*t%j == 0) {\n                            ret += f[i][j][j-s-x][t];\n                        }\n                    }\n                }\n            }\n            s += y;\n            d = d*y;\n            // printf(\"ret=%dn\", ret);\n        }\n        if (d%s == 0) ret += 1;\n        return ret;\n    }\n\n    int beautifulNumbers(int l, int r) {\n        if (f[0][1][0][0] == 0) {\n            for (int j = 1; j < 82; ++j) {\n                f[0][j][0][1%j] = 1;\n            }\n            for (int i = 1; i < 10; ++i) {\n                for (int j = 1; j < 82; ++j) {\n                    for (int k = 0; k < 82; ++k) {\n                        for (int t = 0; t < 82; ++t) {\n                            for (int x = 0; x < 10; ++x) {\n                                if (k-x >= 0) f[i][j][k][t*x%j] += f[i-1][j][k-x][t];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // printf(\"%d %dn\", calc(r), calc(l-1));\n        return calc(r)-calc(l-1);\n    }\n};","author":"summerdaway","submissionId":"611261295"},[]]},{"403":[{"id":"403","fileName":"611262199.txt","sourceCode":"class Solution {\npublic:\n    vector<unordered_map<int, unordered_map<int, int>>> cache;\n    void init(int digit) {\n        cache = vector<unordered_map<int, unordered_map<int, int>>>(10,\n            unordered_map<int, unordered_map<int, int>>{});\n\n        cache[0][0][1] = 1;\n        for (int i = 0; i < 10; ++i) {\n            cache[1][i][i] = 1;\n        }\n\n        for (int i = 2; i < digit; ++i) {\n            for (int j = 0; j < 10; ++j) {\n                for (auto& pr : cache[i - 1]) {\n                    auto sum = pr.first;\n                    for (auto& pr2 : pr.second) {\n                        auto product = pr2.first;\n                        cache[i][j + sum][j * product] += pr2.second;\n                    }\n                }\n            }\n        }\n    }\n    int count(int x) {\n        //cout << \"x = \" << x << endl;\n        int result = 0;\n        if (x == 1000000001) {\n            --x;\n            ++result;\n        }\n        if (x == 1000000000) {\n            --x;\n            ++result;\n        }\n        vector<int> digits;\n        while (x > 0) {\n            digits.push_back(x % 10);\n            x /= 10;\n        }\n\n        for (int len = 1; len < digits.size(); ++len) {\n            for (int i = 1; i < 10; ++i) {\n                for (auto& pr : cache[len - 1]) {\n                    for (auto& pr2 : pr.second) {\n                        if ((pr2.first * i) % (pr.first + i) == 0) {\n                            result += pr2.second;\n                        }\n                    }\n                }\n            }\n        }\n\n        int sum_r = 0, product_r = 1;\n        for (int i = digits.size() - 1; i >= 0; --i) {\n            int d = 0;\n            if (i == digits.size() - 1) d = 1;\n            for (; d < digits[i]; ++d) {\n                for (auto& pr : cache[i]) {\n                    for (auto& pr2 : pr.second) {\n                        if ((pr2.first * d * product_r) % (pr.first + d + sum_r) == 0) {\n                            //cout << i << \" \" << d << \" \" << (pr2.first * d * product_r) << \" \" << (pr.first + d + sum_r) << \" \" <<  pr2.second << endl;\n                            result += pr2.second;\n                        }\n                    }\n                }\n            }\n\n            sum_r += d;\n            product_r *= d;\n\n            //cout << sum_r << \" * \" << product_r << endl;\n        }\n        //cout << \"result = \" << result << endl;\n        return result;\n    }\n    int beautifulNumbers(int l, int r) {\n        ++r;\n        int x = r;\n        vector<int> digits;\n        while (x > 0) {\n            digits.push_back(x % 10);\n            x /= 10;\n        }\n        init(min(9, (int)digits.size()));\n        return count(r) - count(l);\n    }\n};","author":"Haocheng","submissionId":"611262199"},[]]},{"404":[{"id":"404","fileName":"611261795.txt","sourceCode":"class Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        auto solve = [](string x) -> int\n        {\n            if (x == \"0\") return 0;\n            int n = x.length();\n            map<array<int, 5>, int> mp;\n            auto dfs = [&](auto &dfs, int cur, int mul, int add, int lim, int leading_zero) -> int\n            {\n                if (mp.count({cur, mul, add, lim, leading_zero}))\n                    return mp[{cur, mul, add, lim, leading_zero}];\n                if (cur == n) {\n                    if (leading_zero) return 0;\n                    assert(add > 0);\n                    return mul % add == 0;\n                }\n                int res = 0;\n                for (int c = 0; c <= (lim ? x[cur] - '0' : 9); c++) {\n                    int _mul = mul * (leading_zero and c == 0 ? 1 : c);\n                    int _add = add + c;\n                    int _lim = lim && c == x[cur] - '0';\n                    int _leading_zero = leading_zero && c == 0;\n                    res += dfs(dfs, cur + 1, _mul, _add, _lim, _leading_zero);\n                }\n                return mp[{cur, mul, add, lim, leading_zero}] = res;\n            };\n            return dfs(dfs, 0, 1, 0, 1, 1);\n        };\n\n        return solve(to_string(r)) - solve(to_string(l - 1));\n    }\n};","author":"tobo","submissionId":"611261795"},[]]},{"405":[{"id":"405","fileName":"611262024.txt","sourceCode":"@cache\ndef calculate(val):\n    arr = [int(x) for x in str(val)]\n    n = len(arr)\n    \n    @cache\n    def dp(idx, curprod, cursum, at_limit=True):\n        \n        if idx == n:\n            if cursum == 0:\n                return 0\n            if curprod % cursum == 0:\n                return 1\n            return 0\n\n        res = 0\n        for val in range(10):\n            if val == 0 and idx == 0:\n                continue\n            if at_limit and val == arr[idx]:\n                res += dp(idx + 1, curprod * val, cursum + val, True)\n                break\n            res += dp(idx + 1, curprod * val, cursum + val, False)\n        \n        return res\n    \n    res = dp(0, 1, 0, True)\n    return res\n\ndef actual_calculate(val):\n    if val == 0:\n        return 0\n    res = 0\n    for i in range(1, 10):\n        if val >= 10**i:\n            res += calculate(10**i - 1)\n        else:\n            res += calculate(val)\n            break\n    return res\n\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        # iterate over digit multiset\n        # add zeros, permute order, and count, and limit value\n        \n        return actual_calculate(r) - actual_calculate(l-1)\n        \n                ","author":"涂汇康","submissionId":"611262024"},[]]},{"406":[{"id":"406","fileName":"611262837.txt","sourceCode":"use std::collections::HashMap;\n\nimpl Solution {\n    fn digit_dp(\n        digits: &[i32],\n        low_digits: &[i32],\n        r_nums: &[i32],\n        l_nums: &[i32],\n        powers: &[i32],\n        memo: &mut HashMap<(usize, bool, bool, i32, i32), i32>,\n        pos: usize,\n        is_upper: bool,\n        is_lower: bool,\n        product: i32,\n        sum: i32,\n    ) -> i32 {\n        if pos == digits.len() {\n            return if sum != 0 && product % sum == 0 { 1 } else { 0 };\n        }\n\n        if let Some(&ans) = memo.get(&(pos, is_upper, is_lower, product, sum)) {\n            return ans;\n        }\n\n        let mut ans = 0;\n        let upper_bound = if is_upper { digits[pos] } else { 9 };\n        let lower_bound = if is_lower { low_digits[pos] } else { 0 };\n        for i in lower_bound..=upper_bound {\n            if i == 0 && sum != 0 {\n                let mut remaining = 0;\n                if is_upper && i == upper_bound {\n                    remaining = r_nums[pos + 1] + 1;\n                    //for j in pos + 1..digits.len() {\n                    //    remaining = remaining * 10 + digits[j];\n                    //}\n                    //remaining += 1;\n                } else {\n                    //remaining += 10_i32.pow((digits.len() - pos - 1) as u32);\n                    remaining += powers[(digits.len() - pos - 1) as usize];\n                }\n\n                let mut deduction = 0;\n                if is_lower && i == lower_bound {\n                    deduction = l_nums[pos + 1];\n                    //for j in pos + 1..low_digits.len() {\n                    //    deduction = deduction * 10 + low_digits[j];\n                    //}\n                }\n                ans += remaining - deduction;\n                continue;\n            }\n            ans += Self::digit_dp(\n                digits,\n                low_digits,\n                r_nums,\n                l_nums,\n                powers,\n                memo,\n                pos + 1,\n                is_upper && i == upper_bound,\n                is_lower && i == lower_bound,\n                product * if sum == 0 && i == 0 { 1 } else { i },\n                sum + i,\n            );\n        }\n\n        memo.insert((pos, is_upper, is_lower, product, sum), ans);\n        ans\n    }\n\n    pub fn beautiful_numbers(mut l: i32, mut r: i32) -> i32 {\n        let mut r_digits = Vec::new();\n        while r != 0 {\n            r_digits.push(r % 10);\n            r /= 10;\n        }\n        r_digits.reverse();\n\n        let mut r_nums = vec![0; r_digits.len() + 1];\n        let mut r = 1;\n        for i in (0..r_digits.len()).rev() {\n            r_nums[i] = r * r_digits[i] + r_nums[i + 1];\n            r *= 10;\n        }\n\n        //println!(\"{:?}\", r_nums);\n\n        let mut l_digits = Vec::new();\n        if l == 0 {\n            l_digits.push(0);\n        } else {\n            while l != 0 {\n                l_digits.push(l % 10);\n                l /= 10;\n            }\n        }\n        while l_digits.len() < r_digits.len() {\n            l_digits.push(0);\n        }\n        l_digits.reverse();\n\n        let mut l_nums = vec![0; l_digits.len() + 1];\n        let mut l = 1;\n        for i in (0..l_digits.len()).rev() {\n            l_nums[i] = l * l_digits[i] + l_nums[i + 1];\n            l *= 10;\n        }\n\n        //println!(\"{:?}\", l_nums);\n\n        let mut powers = vec![1; r_digits.len()];\n        for i in (0..r_digits.len() - 1) {\n            powers[i + 1] = powers[i] * 10;\n        }\n\n        //println!(\"{:?}\", powers);\n\n        let mut memo = HashMap::new();\n\n        Self::digit_dp(\n            &r_digits, &l_digits, &r_nums, &l_nums, &powers, &mut memo, 0, true, true, 1, 0,\n        )\n    }\n}","author":"weiqizheng","submissionId":"611262837"},[]]},{"407":[{"id":"407","fileName":"611263376.txt","sourceCode":"class Solution:\n\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        @lru_cache(None)\n        def dfs(s, index, cheng, now_sum, limit, chose):\n            if index == len(s):\n                if not chose:\n                    return 0\n                return cheng % now_sum == 0\n            ans = 0            \n            if not chose:\n                ans += dfs(s, index + 1, 1, 0, False, False)\n            left = 0 if chose else 1\n            right = int(s[index]) if limit else 9\n            for i in range(left, right + 1):\n                ans += dfs(s, index + 1, cheng * i, now_sum + i, limit and i == right, True)\n            return ans\n        return dfs(str(r), 0, 1, 0, True, False) - dfs(str(l - 1), 0, 1, 0, True, False)","author":"BUG_MAKER","submissionId":"611263376"},[]]},{"408":[{"id":"408","fileName":"611263369.txt","sourceCode":"@cache\ndef calc(pos, n, num, tot, r):\n    if pos == 0:\n        return 1 if r == 0 and tot == 0 else 0\n    start = 1 if pos == n else 0\n    res = 0\n    for digit in range(start, 10):\n        if digit > tot:\n            break\n        nr = r * digit % num\n        res += calc(pos-1, n, num, tot - digit, nr)\n    return res\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:        \n        def calc2(target):\n            if not target:\n                return 0\n            d = [int(ch) for ch in str(target)][::-1]\n            n = len(d)\n            m = n * 9\n            res = 0\n            for L in range(1, n):\n                for num in range(1, L * 9 + 1):\n                    res += calc(L, L, num, num, 1)\n            for num in range(1, m + 1):\n                acc = num\n                product = 1\n                valid = True\n                for pos in range(n-1, -1, -1):\n                    start = 1 if pos == n - 1 else 0\n                    for digit in range(start, d[pos]):\n                        if digit > acc:\n                            break\n                        r = product * digit % num\n                        val = calc(pos, n, num, acc - digit, r)\n                        #print(target, ':', pos, n, num, acc - digit, r, '->', val)\n                        res += val\n                    if d[pos] > acc:\n                        break\n                    acc -= d[pos]\n                    product = product * d[pos] % num\n            num = sum(d)\n            product = 1\n            for digit in d:\n                product *= digit\n            if product % num == 0:\n                res += 1\n            return res\n\n        n = len(str(r))\n        for i in range(1, n + 1):\n            m = i * 9\n            for tot in range(1, m + 1):\n                calc(i, i, tot, tot, 1)\n        \n        return calc2(r) - calc2(l - 1)\n        ","author":"lee0560","submissionId":"611263369"},[]]},{"409":[{"id":"409","fileName":"611263583.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        low, high = str(l), str(r)\n        n = len(high)\n        diff = n - len(low)\n        low = '0' * diff + low\n        \n        @lru_cache(None)\n        def dfs(i: int, limit_low: bool, limit_high: bool, is_num: bool, s: int, mul: int) -> int:\n            if i == len(high):\n                return int(mul % s == 0)\n            res = 0\n        \n            if i < diff and not is_num:  # 可以跳过当前数位\n                res += dfs(i + 1, True, False, False, s, mul)\n        \n            lo = int(low[i]) if limit_low else 0\n            hi = int(high[i]) if limit_high else 9\n        \n            for d in range(max(lo, 1 - is_num), hi + 1):\n                res += dfs(i + 1, limit_low and d == lo, limit_high and d == hi, True, s + d, mul * d)\n            return res\n        return dfs(0, True, True, False, 0, 1)","author":"小爱仙尊","submissionId":"611263583"},[]]},{"410":[{"id":"410","fileName":"611263678.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        l, r = str(l), str(r)\n        tt = len(l)\n        n = len(r)\n        l = (n - len(l)) * '0' + l\n        @cache\n        def dfs(i, is_num, pre_mul, pre_sum, limit_low, limit_high):\n            if i == n:\n                return 1 if pre_mul % pre_sum == 0 else 0\n            res = 0\n            # if not is_num and i < (n - len(l)):\n            #     res = dfs(i + 1, False, 1, 0, True, True)\n            lo = int(l[i]) if limit_low else 0\n            hi = int(r[i]) if limit_high else 9\n            for d in range(lo, hi + 1):\n                if not is_num and d == 0:\n                    res += dfs(i + 1, False, pre_mul, pre_sum, limit_low and d == lo, limit_high and d == hi)\n                    continue\n                res += dfs(i + 1, True, pre_mul * d, pre_sum + d, limit_low and d == lo, limit_high and d == hi)\n            return res\n\n        return dfs(0, False, 1, 0, True, True)\n        \n\n\n\n\n\n\n        \n        ","author":"Beautiful Shawsfr","submissionId":"611263678"},[]]},{"411":[{"id":"411","fileName":"611263873.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n\n        def cal1(x):\n            ds = [int(d) for d in str(x)]\n            n = len(ds)\n\n            @cache\n            def dp(idx, f, has, s, p) -> int:\n                if idx == n:\n                    if not has:\n                        return 0\n                    return 1 if (s != 0 and p % s == 0) else 0\n                res = 0\n                limit = ds[idx] if f else 9\n                for d in range(0, limit + 1):\n                    f1 = f and (d == limit)\n                    if not has:\n                        if d == 0:\n                            res += dp(idx + 1, f1, 0, s, p)\n                        else:\n                            res += dp(idx + 1, f1, 1, s + d, p * d)\n                    else:\n                        if d != 0:\n                            res += dp(idx + 1, f1, 1, s + d, p * d)\n                return res\n\n            return dp(0, 1, 0, 0, 1)\n\n        def cal0(x):\n            ds = [int(d) for d in str(x)]\n            n = len(ds)\n\n            @cache\n            def dp(idx, f, has):\n                if idx == n:\n                    return 1 if has else 0\n                res = 0\n                limit = ds[idx] if f else 9\n                for d in range(limit + 1):\n                    f1 = f and (d == limit)\n                    if not has:\n                        if d == 0:\n                            res += dp(idx + 1, f1, 0)\n                        else:\n                            res += dp(idx + 1, f1, 1)\n                    else:\n                        if d == 0:\n                            continue\n                        res += dp(idx + 1, f1, 1)\n                return res\n\n            return dp(0, 1, 0)\n\n        def cal(x):\n            if x <= 0:\n                return 0\n            return x - cal0(x) + cal1(x)\n\n        return cal(r) - cal(l - 1)","author":"Perlman","submissionId":"611263873"},[]]},{"412":[{"id":"412","fileName":"611263659.txt","sourceCode":"class Solution:\n    def beautifulNumber(self,num:int) -> int:\n        s = str(num)\n        n = len(s)\n        @lru_cache(None)\n        def dfs(i:int,is_pre:bool,is_zero:bool,total:int,ctotal:int) -> int:\n            if i == n:\n                if total == 0:\n                    return 0\n                if ctotal % total == 0:\n                    return 1\n                return 0\n            pre = int(s[i]) if is_pre else 9\n            res = 0\n            for k in range(pre + 1):\n                if k == 0 and is_zero:\n                    res += dfs(i + 1,(int(s[i]) == k) and is_pre,True,total + k,ctotal)\n                else:\n                    res += dfs(i + 1,(int(s[i]) == k) and is_pre,False,total + k,ctotal * k)\n            return res\n        return dfs(0,True,True,0,1)\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return self.beautifulNumber(r) - self.beautifulNumber(l - 1)","author":"一只真昼","submissionId":"611263659"},[]]},{"413":[{"id":"413","fileName":"611263896.txt","sourceCode":"class Solution {\npublic:\n    int f[11][101][101];\n    int s[11];\n    int dfs(int pos,int sum,int prod, bool limit,bool leader, int be)\n    {\n        if(!pos)return (sum== be && prod == 0);\n        if(!limit && !leader && f[pos][sum][prod]!=-1)return f[pos][sum][prod];\n        int up=limit?s[pos]:9;\n        int ans=0;\n        for(int i=0;i<=up;i++){\n            if(leader && i==0)ans+=dfs(pos-1,sum,prod,limit&&i==s[pos],1,be);\n            else ans+=dfs(pos-1,sum+i,(prod*i)%be,limit&&i==s[pos],leader&&i==0,be);\n        }\n        if(!limit && !leader)f[pos][sum][prod]=ans;\n        return ans;\n    }\n    int calc(int x ,int be){\n        memset(f,-1,sizeof f);\n    \tint len=0;\n    \twhile(x)s[++len]=x%10,x/=10;\n    \treturn dfs(len,0,1,1,1,be);\n    }\n    int beautifulNumbers(int l, int r) {\n        int ans = 0;\n        for(int i = 1; i <= 100; i++){\n            ans += calc(r, i) - calc(l - 1, i) ;\n        }\n        return ans;\n    }\n};","author":"ppaker","submissionId":"611263896"},[]]},{"414":[{"id":"414","fileName":"611263797.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def helper(num: int) -> int:\n            digs = list(map(int, str(num)))\n            n = len(digs)\n            @cache\n            def dp(pos: int, fit: bool, null: bool, has0: bool, sum: int, mul: int) -> int:\n                if pos == n:\n                    if null:\n                        return 0\n                    if has0:\n                        return 1\n                    return 1 if mul % sum == 0 else 0\n                res = 0\n                lim = digs[pos] if fit else 9\n                for d in range(lim + 1):\n                    nfit = fit and d == lim\n                    if null:\n                        if d == 0:\n                            res += dp(pos + 1, nfit, True, False, 0, 1)\n                        else:\n                            res += dp(pos + 1, nfit, False, False, d, d)\n                    else:\n                        if not has0:\n                            if d == 0:\n                                res += dp(pos + 1, nfit, False, True, 0, 0)\n                            else:\n                                res += dp(pos + 1, nfit, False, False, sum + d, mul * d)\n                        else:\n                            res += dp(pos + 1, nfit, False, True, 0, 0)\n                return res\n            return dp(0, True, True, False, 0, 1)\n        return helper(r) - helper(l - 1)","author":"悖谬","submissionId":"611263797"},[]]},{"415":[{"id":"415","fileName":"611264007.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        m = len(str(r))\n\n        def helper(s):\n            n = len(s)\n\n            @functools.lru_cache(None)\n            def dfs(idx, isLimit, isPre, cur_sum, cur_mod, target_sum):\n                if idx == n:\n                    return cur_sum == target_sum and cur_mod == 0\n                if (n - idx) * 9 + cur_sum < target_sum:\n                    return 0\n                res = 0 if isPre else dfs(idx + 1, False, isPre, cur_sum, cur_mod, target_sum)\n                low = 0 if isPre else 1\n                up = int(s[idx]) if isLimit else 9\n                for d in range(low, up + 1):\n                    if d + cur_sum > target_sum:\n                        break\n                    res += dfs(idx + 1, isLimit and int(s[idx]) == d, True, d + cur_sum, ((cur_mod * d) if isPre else d) % target_sum, target_sum)\n                return res\n\n            res = 0\n            for t in range(m * 9 + 1):\n                res += dfs(0, True, False, 0, 0, t)\n            dfs.cache_clear()\n            return res\n\n        return helper(str(r)) - helper(str(l - 1))\n","author":"Fzldq","submissionId":"611264007"},[]]},{"416":[{"id":"416","fileName":"611264184.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def calc(v):\n            s = str(v)\n\n            @cache\n            def helper(i: int, is_limit: bool, is_num: bool, add, mult) -> int:\n                if i == len(s):\n                    if not is_num: return 0\n                    if add and mult % add == 0: return 1\n                    return 0\n                ans = 0\n                if not is_num:\n                    ans = helper(i + 1, False, False, 0, 1)\n                upper = int(s[i]) if is_limit else 9  # 判断当前位是否受约束\n                lower = 0 if is_num else 1\n                for j in range(lower, upper + 1):\n                    ans += helper(i + 1, is_limit and j == upper, True, add + j, mult * j)\n                return ans\n\n            return helper(0, True, False, 0, 1)\n\n        if l == 1:\n            return calc(r)\n        return calc(r) - calc(l - 1)\n        ","author":"Sun","submissionId":"611264184"},[]]},{"417":[{"id":"417","fileName":"611264638.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        @cache\n        def dp(p, s, k):\n            if p == 0:\n                return 10 ** k\n            if k == 0:\n                return 1 if p % s == 0 else 0\n            res = 0\n            for d in range(10):\n                res += dp(p * d, s + d, k - 1)\n            return res\n\n        def f(a):\n            if a == 0:\n                return 0\n\n            A = list(map(int, str(a)))\n            n = len(A)\n            dp.cache_clear()\n            res = 0\n            for d in range(1, A[0]):\n                res += dp(d, d, n - 1)\n            p = s = A[0]\n            for i in range(1, n):\n                for d in range(A[i]):\n                    res += dp(p * d, s + d, n - i - 1)\n                for d in range(1, 10):\n                    res += dp(d, d, n - i - 1)\n                p *= A[i]\n                s += A[i]\n            res += p % s == 0\n            return res\n\n        return f(r) - f(l - 1)","author":"Han3000","submissionId":"611264638"},[]]},{"418":[{"id":"418","fileName":"611264553.txt","sourceCode":"const int64_t MOD = 1e9+7;\nusing Key = std::tuple<int, int, int, int, int, int>;\nstruct KeyHash {\n  std::size_t operator()(const Key & key) const {\n    auto [a,b,c,d,e,f] = key;\n    return a*31l+b*MOD+c*97+d*7+e*11+f*113;\n  }\n};\nunordered_map<Key, int, KeyHash> M;\nclass Solution {\npublic:\n\n  int dfs(const string &s, bool firstUse, int cur, int remain, int mod) {\n    if (remain<0) return 0;\n    if (s.size()*9<remain) return 0;\n    if (s.size() == 0) return remain ==0 && cur == 0;\n    Key k = {stoi(s), s.size(), (int)firstUse, cur, remain, mod};\n    if (M.count(k)) return M[k];\n    int tot = 0;\n    int ss = s[0]-'0';\n    string s9 = string(s.size()-1, '9');\n    if (firstUse) {\n      for (int i = 0; i <= ss; i++) {\n        tot += dfs(i==ss?s.substr(1):s9, firstUse, cur*i%mod, remain-i, mod);\n      }\n    } else {\n      tot += dfs(string(s.size()-1, '9'), false, cur, remain, mod);\n      for (int i = 1; i <= ss; i++) {\n        tot += dfs(i==ss?s.substr(1):s9, true, cur*i%mod, remain-i, mod);\n      }\n    }\n    return M[k]=tot;\n  }\n  \n\n  int gao(int n) {\n    int tot = 0;\n    for (int i = 1; i <= 81; i++) {\n      tot += dfs(to_string(n), false, 1, i, i);\n    }\n    return tot;\n  }\n\n\n  int beautifulNumbers(int l, int r) {\n    return gao(r)-gao(l-1);\n  }\n};","author":"Darren Hp","submissionId":"611264553"},[]]},{"419":[{"id":"419","fileName":"611264620.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        num1 = str(l)\n        num2 = str(r)\n        n = len(num2)\n        num1 = '0' * (n - len(num1)) + num1\n        @cache\n        def dfs(i, is_num, limit_low, limit_high, s, mul):\n            if i == n:\n                return mul % s == 0\n            \n            lo = int(num1[i]) if limit_low else 0\n            hi = int(num2[i]) if limit_high else 9\n\n            res = 0\n            for x in range(lo, hi + 1):\n                if is_num:\n                    res += dfs(i + 1, is_num, limit_low and lo == x, limit_high and hi == x, s + x, mul * x)\n                else:\n                    if x == 0:\n                        res += dfs(i + 1, is_num, limit_low and lo == x, limit_high and hi == x, s, mul)\n                    else:\n                        res += dfs(i + 1, not is_num, limit_low and lo == x, limit_high and hi == x, s + x, mul * x)\n            return res\n        return dfs(0, False, True, True, 0, 1)","author":"沐浴阳光","submissionId":"611264620"},[]]},{"420":[{"id":"420","fileName":"611264895.txt","sourceCode":"int f[10][82][82];\n\nclass Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        string s1 = to_string(l), s2 = to_string(r);\n        s1 = string(s2.size() - s1.size(), '0') + s1;\n        int ret = 0;\n        for (int s = 1; s <= 81; s++) {\n            memset(f, -1, sizeof(f));\n            auto dfs = [&](auto &&dfs, int u, int low, int high, int lead, int p, int sum) {\n                if (u == s1.size()) return int(!lead && !p && sum == s);\n                if (!low && !high && !lead && f[u][p][sum] != -1) return f[u][p][sum];\n                int l = low ? s1[u] - '0' : 0, r = high ? s2[u] - '0' : 9, ret = 0;\n                if (lead && s1[u] == '0') ret = dfs(dfs, u + 1, 1, 0, 1, p, sum);\n                for (int i = max(l, lead); i <= r; i++) {\n                    ret += dfs(dfs, u + 1, low && i == l, high && i == r, 0, p * i % s, sum + i);\n                }\n                if (!low && !high && !lead) f[u][p][sum] = ret;\n                return ret;\n            };\n            ret += dfs(dfs, 0, 1, 1, 1, 1, 0);\n        }\n        return ret;\n    }\n};","author":"onlyblues","submissionId":"611264895"},[]]},{"422":[{"id":"422","fileName":"611266155.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n\n        def comp(n):\n            ss = str(n)\n            @cache\n            def dfs(i,s,p,mk=True):\n                if i==len(ss):\n                    return 1 if s!=0 and p%s==0 else 0\n                res = dfs(i+1,s,p,False) if s==0 else 0\n                lo = 0 if s!=0 else 1\n                mx = 9 if not mk else int(ss[i])\n                # print(i,s,p,mk,len(ss),mx)\n                for j in range(lo,mx+1):\n                    res+=dfs(i+1,s+j,p*j,mk and j==mx)\n                return res\n            return dfs(0,0,1)\n        # print(comp(r),comp(l-1))\n        return comp(r)-comp(l-1)\n                \n            ","author":"乾杯 []~（￣▽￣）~*","submissionId":"611266155"},[]]},{"423":[{"id":"423","fileName":"611267052.txt","sourceCode":"typedef long long LL;\n\nclass Solution {\npublic:\n    int n;\n    string s;\n    vector<unordered_map<LL,int>>mp;\n    \n    \n    int dfs(int pos,int sum,LL mul,int limit,int num){\n        if(pos==n){\n            if(sum==0)  return 0;\n            return mul%sum==0;\n        }\n        \n        LL bas=(mul<<32)|(sum<<5)|(limit<<2)|num;\n        if(mp[pos].count(bas)) return mp[pos][bas];\n        int res=0;\n        if(!num){\n            res=dfs(pos+1,0,1,0,0);\n        }\n        int up=limit?s[pos]-'0':9;\n        for(int i=num?0:1;i<=up;i++){\n            res+=dfs(pos+1,sum+i,mul*i,limit&&i==up,1);\n        }\n        \n        \n        return mp[pos][bas]=res;\n    }\n    \n    int beautifulNumbers(int l, int r) {\n        s=std::to_string(r);\n        n=s.size(); mp.resize(n);\n        int ans=dfs(0,0,1,1,0);\n        \n        // cout<<ans<<endl;\n        s=to_string(l-1);\n        for(int i=0;i<n;i++)    mp[i].clear();\n        n=s.size(); mp.resize(n);\n        \n        \n        ans-=dfs(0,0,1,1,0);\n        return ans;\n    }\n};\n\n/*\n\n*/","author":"hover","submissionId":"611267052"},[]]},{"424":[{"id":"424","fileName":"611268877.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def solve(x: int) -> int:\n            sx = str(x)\n            @cache\n            def dfs(i: int, s: int, m: int, is_num: bool, is_limit: bool) -> int:\n                if i == len(sx):\n                    return int(is_num and (m % s == 0))\n                res = 0\n                if not is_num:\n                    res += dfs(i+1, s, m, False, False)\n                b = 0 if is_num else 1\n                u = int(sx[i]) if is_limit else 9\n                for d in range(b, u + 1):\n                    res += dfs(i + 1, s + d, m * d, True, d == u and is_limit)\n                return res\n            return dfs(0, 0, 1, False, True)\n\n        return solve(r) - solve(l-1)","author":"山风土豆","submissionId":"611268877"},[]]},{"425":[{"id":"425","fileName":"611267582.txt","sourceCode":"int sum[2][2][100][100];\nint a[10];\nclass Solution {\npublic:\n    int gcd(int x,int y){\n        if(x < y)swap(x,y);\n        if(y == 0)return x;\n        while(x % y){\n            int z = x % y;\n            x = y;\n            y = z;\n        }\n        return y;\n    }\n\n    int getsum(int mx){\n        if(mx == 0)return 0;\n        memset(sum,0,sizeof(sum));\n        int top = 0;\n        \n        while(mx){\n            a[top++] = mx % 10;\n            mx /= 10;\n        }\n        int ans = 0;\n        for(int ii=1;ii<=90;++ii){\n            memset(sum,0,sizeof(sum));\n            int x = a[top-1];\n            int m0 = 0;\n            int m1 = 1;\n            for(int i=1;i<x;++i){\n                if(ii >= i){\n                    sum[m0][0][ii-i][ii / gcd(ii,i)] = 1;\n                }\n            }\n\n            if(ii >= x){\n                sum[m0][1][ii-x][ii / gcd(ii,x)] = 1;\n            }\n\n            \n            for(int i=top-2;i>=0;--i){\n                memset(sum[m1],0,sizeof(sum[m1]));\n                for(int j=0;j<=ii;++j){\n                    for(int k=1;k<=ii;++k){\n                        \n                        if(sum[m0][0][j][k] + sum[m0][1][j][k] == 0)continue;\n                        //if(ii == 13)printf(\"debug1: %d %d %d %d %dn\",i, j, k, sum[m0][0][j][k], sum[m0][1][j][k]);\n                        for(int z = 0; z < 10;++z){\n                            if(j < z)break;\n                            \n                            if(z < a[i]){\n                                sum[m1][0][j-z][k/(gcd(z,k))] += sum[m0][0][j][k] + sum[m0][1][j][k];\n                            }else if(z == a[i]){\n                                sum[m1][0][j-z][k/(gcd(z,k))] += sum[m0][0][j][k];\n                            //    if(i == 0 && j == 0 && z == 0 && ii == 13)printf(\"debug3 : %d %dn\", k/(gcd(z,k)), sum[m0][1][j][k]);\n                                sum[m1][1][j-z][k/(gcd(z,k))] += sum[m0][1][j][k];\n                            }else{\n                                sum[m1][0][j-z][k/(gcd(z,k))] += sum[m0][0][j][k];\n                            }\n                            \n                        }\n                        \n                        /*if(sum[0][j][k]){\n                            for(int z=0;z<10;++z){\n                                if(j < z)break;\n                                sum[0][j-z][k/(gcd(z,k))] += sum[0][j][k];\n                            }\n                        }\n\n                        if(sum[1][j][k]){\n                            for(int z=0;z<a[i];++z){\n                                if(j < z)break;\n                                sum[0][j-z][k/(gcd(z,k))] += sum[1][j][k];\n                            }                 \n\n                            int z = a[i];\n                            if(j >= z){\n                                sum[1][j-z][k/(gcd(z,k))] += sum[1][j][k];\n                            }\n                        }*/\n                    }\n                }\n                for(int j=1;j<10;++j){\n                    if(j <= ii) sum[m1][0][ii-j][ii/gcd(ii,j)] ++;\n                }\n                swap(m0,m1);\n             //   if(ii == 13)printf(\"debug2: %d %d %d %d %dn\",i, 0, 1, sum[m0][0][0][1], sum[m0][1][0][1]);\n            }\n            ans += sum[m0][0][0][1];\n            ans += sum[m0][1][0][1];      \n            \n        //    if(sum[m0][0][0][1] + sum[m0][1][0][1] > 0)printf(\"ans : %d %d %dn\", x, ii, sum[m0][0][0][1] + sum[m0][1][0][1]);\n        }\n     //   printf(\"num : %d %dn\", a[top-1], ans);\n     //   printf(\"============n\");\n        return ans;\n    }\n\n    int beautifulNumbers(int l, int r) {\n\n        return getsum(r) - getsum(l-1);\n\n        \n    }\n};","author":"Milesian","submissionId":"611267582"},[]]},{"426":[{"id":"426","fileName":"611270071.txt","sourceCode":"class Solution {\n    int f(int k) {\n        string s = to_string(k);\n        int n = s.size();\n        vector<map<pair<int,int>, int>> memo(n);\n        auto dfs = [&](auto&& dfs, int i, int prod, int mod, bool is_limit, bool is_num) -> int {\n            if(i == n) {\n                bool check = (mod != 0 && (prod % mod) == 0);\n                return check ? 1 : 0;\n            }\n            \n            if(!is_limit && is_num && memo[i].contains({prod,mod})) {\n                return memo[i][{prod, mod}];\n            }\n            int res = !is_num ? dfs(dfs, i+1, prod, mod, false, false) : 0;\n            int upper = is_limit ? s[i] - '0' : 9;\n            for(int d=1-is_num; d<=upper; d++) {\n                int new_prod = prod * d;\n                int new_mod = mod * d;\n                res += dfs(dfs, i+1, prod * d, mod + d, is_limit && d == upper, true);\n            }\n            if(!is_limit) {\n                memo[i][{prod, mod}] = res;\n            }\n            return res;\n        };\n        return dfs(dfs, 0, 1, 0, true, false);\n    }\npublic:\n    int beautifulNumbers(int l, int r) {\n        cout << l-1 << \" \" << f(l-1) << endl;\n        cout << r << \" \" << f(r) << endl;\n        return f(r) - f(l-1);\n    }\n};","author":"OHNO","submissionId":"611270071"},[]]},{"427":[{"id":"427","fileName":"611269338.txt","sourceCode":"class Solution {\npublic:\n    using INT = __int128;\n    int P = 28;\n    int pw[10];\n    int pos[20], mp[10]{7,5,3,2};\n    int cd[10];\n    unordered_map<int, int> f[10][100][2];\n    vector<int> nums;\n    INT fpow(INT a, int b) {\n        INT r = 1;\n        while(b) {\n            if(b & 1) r = a * r;\n            b >>= 1;\n            a = a * a;\n        } return r;\n    }\n    int modify(int p, int v, int c) {\n        return c + pw[p] * v;\n    }\n    int G(int p, int c) {\n        return c / pw[p] % P;\n    }\n    int check(int add, int c) {\n        INT mul = 1;\n        for(int i = 0; i < 4; ++i) mul *= fpow(mp[i], G(pos[mp[i]], c));\n        return mul % add == 0;\n    }\n    int dfs(int p, int add, int c0, int c, int lmt, int is_num) {\n        if(!~p) {\n            if(!is_num) return 0;\n            if(c0) return 1;\n            return check(add, c);\n        }\n        if(!lmt && is_num && f[p][add][c0].count(c)) return f[p][add][c0][c];\n        int res = 0;\n        if(!is_num) res = dfs(p - 1, add, c0, c, 0, 0);\n        int ed = lmt ? nums[p] : 9;\n        for(int i = !is_num; i <= ed; ++i) {\n            int t = c;\n            res += dfs(p - 1, add + i, c0 || !i, c + cd[i], lmt && i == ed, 1);\n        }\n        if(!lmt && is_num) f[p][add][c0][c] = res;\n        return res;\n    }\n    int dp(int v) {\n        if(!v) return 0;\n        nums.clear();\n        while(v) nums.push_back(v % 10), v /= 10;\n        for(int i = 0; i < 10; ++i)\n            for(int j = 0; j < 100; ++j)\n                for(int k = 0; k < 2; ++k)\n                    unordered_map<int, int>().swap(f[i][j][k]);\n        return dfs(nums.size() - 1, 0, 0, 0, 1, 0);\n    }\n    int beautifulNumbers(int l, int r) {\n        memset(pos, 0xff, sizeof pos);\n        pos[7] = 0, pos[5] = 1, pos[3] = 2, pos[2] = 3;\n        pw[0] = 1;\n        for(int i = 1; i <= 4; ++i) pw[i] = pw[i - 1] * P;\n        for(int i = 1; i <= 9; ++i) {\n            for(int j = 0; j < 4; ++j) {\n                int t = i, c = 0;\n                while(t % mp[j] == 0) t /= mp[j], c++;\n                cd[i] += modify(j, c, 0);\n            }\n        }\n        return dp(r) - dp(l - 1);\n    }\n};","author":"0xffffffff","submissionId":"611269338"},[]]},{"428":[{"id":"428","fileName":"611268638.txt","sourceCode":"typedef long long ll;\nstring s;\nunordered_map<string, int> memo;\nclass Solution {\npublic:\n    ll dfs(int po, int t, bool fir, int sum, ll pr) {\n        if (po == s.size()) {\n            if (!fir) return 0;\n            return (pr % sum == 0) ? 1LL : 0LL;\n        }\n        string k = to_string(po) + \" \" + to_string(t) + \" \" + to_string(fir) +  \" \" + to_string(sum) + \" \" + to_string(pr);\n        if (memo.count(k)) return memo[k];\n        ll res = 0;\n        int lit = t ? s[po] - '0' : 9;\n        for (int d = 0; d <= lit; d++) {\n            int nt = t && (d == lit);\n            bool nfir = fir || (d != 0);\n            int nsum = sum;\n            ll npr = pr;\n            if (nfir) {\n                nsum += d;\n                if (npr == 0 || d == 0) npr = 0;\n                else npr *= d;\n            }\n            res += dfs(po + 1, nt, nfir, nsum, npr);\n        }\n        memo[k] = res;\n        return res;\n    }\n    ll beautycnt(ll n) {\n        s = to_string(n);\n        memo.clear();\n        return dfs(0, 1, 0, 0, 1);\n    }\n\n    int beautifulNumbers(int l, int r) {\n        return (int)(beautycnt(r) - beautycnt(l - 1));\n    }\n};","author":"Frakkland","submissionId":"611268638"},[]]},{"429":[{"id":"429","fileName":"611270259.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        @lru_cache(None)\n        def dp(index, islimit, preSum, preProd, numStr):\n            if index == len(numStr):\n                return int(preProd%preSum == 0) if preSum != 0 else 0\n            limit = int(numStr[index]) if islimit else 9\n            total = 0\n            for v in range(0, limit+1):\n                if v != 0:\n                    curProd = v if preProd is None else preProd*v\n                else:\n                    curProd = None if preProd is None else preProd*v\n                total += dp(index+1, islimit and (v == limit), preSum+v, curProd, numStr)\n            return total\n        return dp(0, True, 0, None, str(r)) - dp(0, True, 0, None, str(l-1))","author":"速冻小鹿包","submissionId":"611270259"},[]]},{"430":[{"id":"430","fileName":"611270286.txt","sourceCode":"class Solution {\npublic:\n    unordered_map<string, int> m;\n    int dfs(int i, string& bound, int le, string& cnt, int has1) {\n        if(i == bound.size()) {\n            if(cnt[0] > '0') {\n                return 1;\n            } else {\n                int m = 1, s = 0;\n                for(int i = 1; i < 10; ++i) {\n                    for(int j = 0; j < cnt[i] - '0'; ++j) {\n                        m *= i;\n                    }\n                    s += i * (cnt[i] - '0');\n                }\n                if(s == 0) return 1;\n                if(m % s == 0) return 1;\n                return 0;\n            }\n        }\n        cnt[11] = le + '0';\n        if(m.find(cnt) != m.end()) {\n            return m[cnt];\n        }\n        int res = 0;\n        for(int ne = 0; ne < 10; ++ne) {\n            if(le && ne > bound[i] - '0') {\n                break;\n            }\n            if(ne > 0 || has1)\n                cnt[ne]++;\n            cnt[10]++;\n            res += dfs(i + 1, bound, le && (ne == bound[i] - '0'), cnt, has1 || ne > 0);\n            if(ne > 0 || has1)\n                cnt[ne]--;\n            cnt[10]--;\n        }\n        m[cnt] = res;\n        return res;\n    }\n    \n    int f(int x) {\n        m.clear();\n        string cnt = \"000000000000\";\n        string bound = to_string(x);\n        return dfs(0, bound, 1, cnt, 0);\n    }\n    \n    int beautifulNumbers(int l, int r) {\n        return f(r) - f(l-1);\n    }\n};","author":"newhar","submissionId":"611270286"},[]]},{"431":[{"id":"431","fileName":"611270100.txt","sourceCode":"var s string\nvar n int\nvar memo map[string]int\nfunc beautifulNumbers(l int, r int) int {\n\tleftCount := 0\n\tif l > 1 {\n\t\tleftCount = countBeautiful(l - 1)\n\t}\n\treturn int(countBeautiful(r) - leftCount)\n}\nfunc countBeautiful(x int) int {\n\ts = strconv.Itoa(x)\n\tn = len(s)\n\tmemo = make(map[string]int)\n    return f(0, 0, 1, true, false)\n}\n//灵神数位 dp 模板\nfunc f(i, sum, prod int, isLimit, isNum bool) (res int) {\n    if i == n{\n        if isNum && sum > 0 && prod % sum == 0 {\n            return 1\n        }\n        return 0\n    }\n    if !isLimit && isNum {\n        key := fmt.Sprintf(\"%d_%d_%d_%t\", i, sum, prod, isNum)\n        if val, ok := memo[key]; ok {\n            return val\n        }\n    }\n    if !isNum {\n        res += f(i+1, sum, prod, false, false)\n    }\n    up := 9\n    if isLimit {\n        up = int(s[i] - '0')\n    }\n    start := 0\n    if !isNum {\n        start = 1\n    }\n    for d := start; d <= up ;d++ {\n        curIsLimit := isLimit && (d == up)\n        var newSum, newProd int\n        if !isNum {\n            newSum = d\n            newProd = d\n        }else{\n            newSum = sum + d\n            newProd = prod * d\n        }\n        res += f(i+1,newSum,newProd,curIsLimit,true)\n    }\n    if !isLimit && isNum {\n        key := fmt.Sprintf(\"%d_%d_%d_%t\",i, sum, prod, isNum)\n        memo[key] = res\n    }\n    return res\n}","author":"汪星银","submissionId":"611270100"},[]]},{"432":[{"id":"432","fileName":"611270861.txt","sourceCode":"class Solution {\n    public int beautifulNumbers(int l, int r) {\n        int v1 = calc(r);\n        int v2 = calc(l-1);\n        // System.out.println(String.format(\"%d %d\",v1,v2));\n        return v1-v2;\n    }\n    int calc(int num) {\n        HashMap<Integer,int[]> hm = new HashMap<>();\n        int L=82;\n        char[] ch = Integer.toString(num).toCharArray();\n        int n = ch.length;\n        int res = 0;\n        int m=1,s=0;\n        for(int i=0;i<n;i++) {\n            int d = ch[i]-'0';\n            HashMap<Integer,int[]> hm1 = new HashMap<>();\n            for(int j=0;j<10;j++) {\n                for(Integer key:hm.keySet()) {\n                    int v = key*j;\n                    int[] arr1 = hm.get(key);\n                    int[] arr2 = hm1.getOrDefault(v,new int[L]);\n                    for(int k=j;k<L;k++) {\n                        arr2[k] += arr1[k-j];\n                    }\n                    hm1.put(v,arr2);\n                }\n                if(j<d && (i!=0 || j>0)) {\n                    int key = m*j;\n                    int[] arr = hm1.getOrDefault(key,new int[L]);\n                    arr[s+j] += 1;\n                    hm1.put(key,arr);\n                }\n                if(i>0 && j>0) {\n                    int key = j;\n                    int[] arr = hm1.getOrDefault(key,new int[L]);\n                    arr[j] += 1;\n                    hm1.put(key,arr);\n                }\n            }                \n            m *= d;\n            s += d;\n            hm = hm1;\n        }\n        int[] arr = hm.getOrDefault(m,new int[L]);\n        arr[s] += 1;\n        hm.put(m,arr);\n        for(Integer key:hm.keySet()) {\n            int[] t = hm.get(key);\n            for(int i=1;i<L;i++) {\n                if(key % i==0 && t[i]>0) {\n                    res += t[i];\n                    // System.out.println(String.format(\"%d %d %d\",key,i,t[i]));\n                }\n            }\n        }\n        // System.out.println(String.format(\"c%d %d\",num,res));\n        return res;\n    }\n}","author":"Knarf","submissionId":"611270861"},[]]},{"433":[{"id":"433","fileName":"611270856.txt","sourceCode":"class Solution {\n    private int[][] gcdDict=new int[82][10];\n    public int beautifulNumbers(int l, int r) {\n        for(int i=1;i<gcdDict.length;i++){\n            for(int j=0;j<10;j++){\n                if(j==0){\n                    gcdDict[i][j]=1;\n                }else {\n                    gcdDict[i][j]=i/gcd(i,j);\n                }\n            }\n        }\n        DigitDp digitDp = new DigitDp();\n        return digitDp.cal(l,r);\n    }\n\n    private int gcd(int a, int b) {\n        if (a <= b) {\n            a = a ^ b;\n            b = a ^ b;\n            a = a ^ b;\n        }\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    class DigitDp{\n        //{pos,sum,modLeft}\n        private int[][][][]cache;\n        private char[] charsHigh;\n        private char[] charsLow;\n\n        private int cal(int low,int high) {\n            String lowStr=String.valueOf(low);\n            String highStr=String.valueOf(high);\n\n            if (high == 0) {\n                return 0;\n            }\n            this.charsHigh = String.valueOf(high).toCharArray();\n            this.charsLow = new char[charsHigh.length];\n            int index = 0;\n            while (index < highStr.length() - lowStr.length()) {\n                charsLow[index++] = '0';\n            }\n            for (int i = 0; i < lowStr.length(); i++) {\n                charsLow[index++] = lowStr.charAt(i);\n            }\n            int min = 1, max = charsHigh.length * 9;\n            int res=0;\n            for (int i = min; i <= max; i++) {\n                this.cache = new int[charsHigh.length][i + 1][i + 1][2];\n                res+=doCal(0, i,i,false, false,true);\n            }\n            return res;\n        }\n\n        private int doCal(int pos,int sum,int leftMod, boolean hasSmall,boolean hasBig,boolean headZero) {\n            if (pos == charsHigh.length) {\n                if(sum==0&&leftMod==1){\n                    return 1;\n                }else {\n                    return 0;\n                }\n            }\n            int res=0;\n            if (hasSmall && hasBig) {\n                res = cache[pos][sum][leftMod][headZero ? 1 : 0];\n            }\n            if (res != 0) {\n                return res - 1;\n            }\n\n            for (int i = 0; i <= 9; i++) {\n                if (!hasBig && i < charsLow[pos] - '0') {\n                    continue;\n                }\n\n                if (!hasSmall && i > charsHigh[pos] - '0') {\n                    break;\n                }\n                int leftSum=sum-i;\n                if(leftSum<0){\n                    break;\n                }\n                boolean nextSmall = hasSmall || i < charsHigh[pos] - '0';\n                boolean nextBig = hasBig || i > charsLow[pos] - '0';\n                boolean nextHeadZero = headZero && i == 0 && pos != charsHigh.length - 1;\n                int nextGcd=nextHeadZero?leftMod:gcdDict[leftMod][i];\n                res+=doCal(pos+1,leftSum,nextGcd,nextSmall,nextBig,nextHeadZero);\n            }\n            if(hasSmall&&hasBig) {\n                cache[pos][sum][leftMod][headZero ? 1 : 0] = res + 1;\n            }\n            return res;\n        }\n    }\n}","author":"ReZero","submissionId":"611270856"},[]]},{"434":[{"id":"434","fileName":"611271271.txt","sourceCode":"class Solution {\npublic:\n\n    int beautifulNumbers(int l, int r) {\n        num.resize(10, vector<int>(4));\n        for(int y = 1; y <= 9; y++) {\n            int x = y;\n            for(int i=0; i<f.size(); i++) {\n                while(x % f[i] == 0) { num[y][i]++; x /= f[i]; }\n            }\n        }\n        return fun(r) - fun(l-1);\n    }\n    int fun(int n) {\n        memset(dp, -1, sizeof(dp)); memset(digit, 0, sizeof(digit)); m = 0;\n        for( ; n ; n/=10) digit[m++] = n%10;\n        return solve(m-1, 0, 1, 1, 0, 0, 0, 0, 0);\n    }\n    int solve(int pos, int sum, int lmt, int lz, int zero, int n2, int n3, int n5, int n7) {\n        if(pos == -1) {\n            if(sum == 0) return 0;\n            if(zero) return 1;\n            vector<int> num = {n2, n3, n5, n7}, tmp(4, 0);\n            for(int i =0; i< f.size(); i++) {\n                while(sum != 1 && sum % f[i] == 0) { tmp[i]++; sum /= f[i]; }\n            }\n            if(sum != 1) return 0;\n            for(int i=0; i<num.size(); i++) {\n                if(tmp[i] > num[i]) return 0;\n            }\n            return 1;\n        }\n        int pp = lmt << 2 | lz << 1 | zero;\n        int& ret = dp[pos][sum][pp][n2][n3][n5][n7];\n        if(ret != -1) return ret;\n        int up = lmt? digit[pos] : 9;  ret = 0;\n        for(int k = 0; k<=up; k++) {\n            ret += solve(pos-1, sum + k, lmt && k == digit[pos], lz && k==0 , (!lz && k==0) || zero, min(6, n2 + num[k][0]), min(4, n3 + num[k][1]), min(2, n5 + num[k][2]), min(2, n7 + num[k][3]));\n        }\n        return ret;\n    }\n    int dp[10][82][8][7][5][3][3], digit[11], m; vector<int> f = {2, 3, 5, 7}; vector<vector<int>> num;\n};","author":"nnKoala","submissionId":"611271271"},[]]},{"435":[{"id":"435","fileName":"611271456.txt","sourceCode":"def DigitalDP(n: int) -> int:\n    \"\"\"数位DP通用模板\"\"\"\n    s = str(n)\n\n    @cache\n    def dfs(i: int, is_limit: bool, is_num: bool, p: int, sx: int) -> int:\n        if i == len(s):\n            if not is_num:\n                return 0\n            else:\n                return p % sx == 0\n        ret = 0 if is_num else dfs(i + 1, False, False, 1, 0)\n        up = int(s[i]) if is_limit else 9\n        for j in range(1 - int(is_num), up + 1):\n            ret += dfs(i + 1, j == up and is_limit, True, p * j, sx + j)\n        return ret\n\n    return dfs(0, True, False, 1, 0)\n\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return DigitalDP(r) - DigitalDP(l - 1)","author":"星开祈灵","submissionId":"611271456"},[]]},{"438":[{"id":"438","fileName":"611271568.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        @cache\n        def dfs(num_str, pos, leading_zero, cur_sum, cur_product, tight):\n            if pos == len(num_str):\n                if leading_zero: return 0\n                return 1 if (cur_sum != 0 and cur_product % cur_sum == 0) else 0\n\n            limit = int(num_str[pos]) if tight else 9\n            count = 0\n\n            for digit in range(0, limit + 1):\n                new_tight = tight and (digit == limit)\n                new_leading_zero = leading_zero and (digit == 0)\n\n                if new_leading_zero:\n                    new_sum = cur_sum\n                    new_product = cur_product\n                else:\n                    new_sum = cur_sum + digit\n                    if leading_zero:\n                        new_product = digit\n                    else:\n                        new_product = cur_product * digit\n\n                count += dfs(num_str, pos + 1, new_leading_zero, new_sum, new_product, new_tight)\n\n            return count\n\n        def count_up_to(num):\n            if num < 0:\n                return 0\n            num_str = str(num)\n            return dfs(num_str, 0, True, 0, 1, True)\n\n        count_r = count_up_to(r)\n        dfs.cache_clear()\n        count_l = count_up_to(l - 1)\n\n        return count_r - count_l","author":"silvertint10","submissionId":"611271568"},[]]},{"439":[{"id":"439","fileName":"611271986.txt","sourceCode":"# for x in range(951,956):\n#     x=str(x)\n#     s=0\n#     p=1\n#     for t in x:\n#         p*=int(t)\n#         s+=int(t)\n#     if p%s==0:\n#         print(x)\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def get(num):\n            s=str(num)\n            mx=9*(len(s)-1)+int(s[0])\n            n=len(s)\n            ans=0\n            for k in range(1,mx+1):\n                @cache\n                def f(i,isLimit,is_Num,rem,sum_):\n                    if sum_ + 9*(n-i)<k:\n                        return 0\n                    if i==n:\n                        # if rem == 0 and sum_ == k:\n                        #     print(k,'ans=',tt,'....sum=',sum_)\n                        return int(rem == 0 and sum_ == k)\n                    up=int(s[i]) if isLimit else 9\n                    res=0\n                    for d in range(up+1):\n                        new_rem = d%k if sum_==0 else (rem*d)%k\n                        res+= f(i+1,isLimit and d==up,is_Num or d>0,new_rem,sum_+d)\n                    return res\n                res=f(0,True,False,0,0)\n                f.cache_clear()\n                ans +=res\n                # print(k,res)\n            return ans\n        # print('..!\",',get(r))\n        return get(r)-get(l-1)\n        \n        ","author":"krism","submissionId":"611271986"},[]]},{"440":[{"id":"440","fileName":"611272042.txt","sourceCode":"class Solution:\n    def cal(self, num):\n        num = str(num)\n        n = len(num)\n        @cache\n        def dfs(i, isUpper, isZero, m, s):\n            nonlocal n\n            if m == 0 and isUpper is False:\n                return 10 ** (n - i)\n\n            if i == n:\n                return int(s == 0 or m % s == 0)\n\n            res = 0\n            for k in range(10 if isUpper is False else int(num[i]) + 1):\n                res += dfs(i + 1,\n                           isUpper and k == int(num[i]),\n                           isZero and k == 0,\n                           m * (1 if isZero and k == 0 else k),\n                           s + k)\n\n            return res\n\n        return dfs(0, True, True, 1, 0)\n\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        return self.cal(r) - self.cal(l - 1)","author":"sishenzhimu","submissionId":"611272042"},[]]},{"441":[{"id":"441","fileName":"611271088.txt","sourceCode":"\n\nclass Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n\n        # def count(x):\n\n        def count(x: int) -> int:\n            s = str(x)\n            n = len(s)\n            \n            @cache\n            def dfs(i, sum, p, is_limit, is_num, has_zero):\n                if i == n:\n                    if not is_num:\n                        return 0\n                    if has_zero:\n                        return 1\n                    if sum != 0 and p % sum == 0:\n                        return 1\n                    return 0\n\n                res = 0\n                limit = int(s[i]) if is_limit else 9\n                for d in range(0, limit + 1):\n                    cur_limit = is_limit and (d == limit)\n                    if not is_num:\n                        if d == 0:\n                            res += dfs(i + 1, 0, 1, cur_limit, False, False)\n                        else:\n                            res += dfs(i + 1, d, d, cur_limit, True, False)\n                    else:\n                        if d == 0:\n                            res += dfs(i + 1, sum, 0, cur_limit, True, True)\n                        else:\n                            if has_zero:\n                                res += dfs(i + 1, sum + d, 0, cur_limit, True, True)\n                            else:\n                                res += dfs(i + 1, sum + d, p * d, cur_limit, True, False)\n                return res\n            return dfs(0, 0, 1, True, False, False)\n        \n        return count(r) - count(l - 1)\n            ","author":"硕风点点","submissionId":"611271088"},[]]},{"442":[{"id":"442","fileName":"611272642.txt","sourceCode":"func ok(num int) bool {\n\tn1, n2 := 0, 1\n\tfor i := num; i > 0; i /= 10 {\n\t\tj := i % 10\n\t\tn1 += j\n\t\tn2 *= j\n\t}\n\treturn n2 % n1 == 0\n}\n\nfunc getF(rsMap map[int]int, x int) int {\n    x0 := 0\n    for key, _ := range rsMap {\n        if key <= x {\n            x0 = max(x0, key)\n        }\n    }\n    rs := rsMap[x0]\n    for i := x0+1; i <= x; i++ {\n        if ok(i)  { rs += 1 } \n    }\n    return rs\n}\n\nfunc getRsMap() map[int]int {\n    rsMap :=map[int]int{0:0,10000000:5845532,20000000:12130749,30000000:18463924,40000000:24795187,50000000:31128600,60000000:37651026,70000000:43988395,80000000:50422159,90000000:56696849,100000000:62955907,110000000:72955907,120000000:79206545,130000000:85514715,140000000:91814353,150000000:98119653,160000000:104619367,170000000:110942601,180000000:117360798,190000000:123618884,200000000:129867304,210000000:139867304,220000000:146175474,230000000:152508887,240000000:158868605,250000000:165177617,260000000:171741637,270000000:178088434,280000000:184567579,290000000:190822976,300000000:197130769,310000000:207130769,320000000:213430407,330000000:219790125,340000000:226088343,350000000:232450476,360000000:239019237,370000000:245347819,380000000:251846362,390000000:258175007,400000000:264413913,410000000:274413913,420000000:280719213,430000000:287028225,440000000:293390358,450000000:299674729,460000000:306237756,470000000:312581466,480000000:319079252,490000000:325306727,500000000:331635764,510000000:341635764,520000000:348135478,530000000:354699498,540000000:361268259,550000000:367831286,560000000:374359942,570000000:380958612,580000000:387656516,590000000:394160421,600000000:400677787,610000000:410677787,620000000:417001021,630000000:423347818,640000000:429676400,650000000:436020110,660000000:442618780,670000000:448949064,680000000:455488633,690000000:461794017,700000000:468074643,710000000:478074643,720000000:484492840,730000000:490971985,740000000:497470528,750000000:503968314,760000000:510666218,770000000:517205787,780000000:523676108,790000000:530134017,800000000:536609810,810000000:546609810,820000000:552867896,830000000:559123293,840000000:565451938,850000000:571679413,860000000:578183318,870000000:584488702,880000000:590946611,890000000:597130993,900000000:603442755,910000000:613442755,920000000:619691175,930000000:625998968,940000000:632237874,950000000:638566911,960000000:645084277,970000000:651364903,980000000:657840696,990000000:664152458,1000000000:670349659}\n    return rsMap\n}\n\nfunc beautifulNumbers(l int, r int) int {\n    rsMap := getRsMap()\n    return getF(rsMap, r) - getF(rsMap, l-1)\n}","author":"我啊","submissionId":"611272642"},[]]},{"444":[{"id":"444","fileName":"611273286.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        low = str(l)\n        high = str(r)\n        low = '0'*(len(high)-len(low))+low\n        n = len(high)\n        @cache  # 记忆化搜索\n        def dfs(i,limit_down,limit_up,cnt1,cnt2,is0):\n            if i==n:\n               # print(cnt1,cnt2)\n                return 1 if cnt1%cnt2==0 and is0  else 0\n            res = 0\n            down = int(low[i]) if limit_down else 0#下界\n            up = int(high[i]) if limit_up else 9#上界\n            for d in range(down,up+1):\n                res+=dfs(i+1,limit_down and d==down,limit_up and d==up,cnt1*d if is0 or d!=0 else cnt1,cnt2+d,is0 or d!=0)\n            return res\n        return dfs(0,True,True,1,0,False)\n            \n\n        ","author":"只会暴力","submissionId":"611273286"},[]]},{"445":[{"id":"445","fileName":"611273543.txt","sourceCode":"class Solution {\npublic:\n    int beautifulNumbers(int l, int r) {\n        memo.assign(10, std::vector<std::vector<int>>(100, std::vector<int>(81, -1)));\n        return solve(r) - solve(l - 1);\n    }\n    string s;\n    vector<std::vector<std::vector<int>>> memo;\n    int target_sum;\n\n    int dfs(int pos, int digit_sum, int product_mod, bool is_limit, bool is_num) {\n        if (pos == s.length()) {\n            return is_num && digit_sum == target_sum && product_mod == 0;\n        }\n        if (!is_limit && is_num && memo[pos][digit_sum][product_mod] != -1) {\n            return memo[pos][digit_sum][product_mod];\n        }\n        int res = 0;\n        int up = is_limit ? (s[pos] - '0') : 9;\n        for (int digit = 0; digit <= up; ++digit) {\n            int new_digit_sum = digit_sum + digit;\n            int new_product_mod = digit != 0 ? (product_mod * digit) % target_sum : (is_num ? 0 : 1 % target_sum);\n            bool new_is_limit = is_limit && digit == up;\n            bool new_is_num = is_num || digit != 0;\n            res += dfs(pos + 1, new_digit_sum, new_product_mod, new_is_limit, new_is_num);\n        }\n\n        if (!is_limit && is_num) {\n            memo[pos][digit_sum][product_mod] = res;\n        }\n        return res;\n    }\n\n    int solve(int n) {\n        s = to_string(n);\n        int total = 0;\n        for (int i = 1; i < 82; ++i) {\n            target_sum = i;\n            for (int p = 0; p < s.length(); ++p) {\n                for (int d = 0; d < 100; ++d) {\n                    for (int m = 0; m < target_sum; ++m) {\n                        memo[p][d][m] = -1;\n                    }\n                }\n            }\n            total += dfs(0, 0, 1 % target_sum, true, false);\n        }\n        return total;\n    }\n};","author":"伏波落木","submissionId":"611273543"},[]]},{"446":[{"id":"446","fileName":"611274157.txt","sourceCode":"/**\n * @param {number} l\n * @param {number} r\n * @return {number}\n */\n\nfunction gcd(a, b) {\n  return b === 0 ? a : gcd(b, a % b);\n}\n\nvar beautifulNumbers = function (l, r) {\n  function getCnt(num) {\n    const n = String(num);\n    const cache = new Map();\n    const getKey = (i, isLimit, isNum, g, sum) => {\n      return `${i},${isLimit},${isNum},${g},${sum}`;\n    };\n\n    /**\n     * i: 数值的第i位\n     * isLimit: 是否要限制当前数值，如果i-1位数与n的前i-1位数都相同，就需要限制\n     * isNum: 前1位数是否填充了数字，没有填充的话，当前位可以跳过填充，或者只能填1以及1以上\n     * 留出s的长度\n     */\n    function dp(i, isLimit, isNum, g, sum) {\n      // \n      if (i >= n.length) {\n        return (((g % sum) == 0) && isNum) ? 1 : 0\n      }\n      const k = getKey(i, isLimit, isNum, g, sum);\n\n      // 记忆化搜索\n      if (cache.has(k)) {\n        return cache.get(k);\n      }\n\n      let ret = 0;\n      // 前面一个数不填时候，此数位上也可以不填。因为前面不填，那生成的数一定小于n，所以isLimit可以不限制，\n      if (!isNum) {\n        ret = dp(i + 1, false, false, g, sum);\n      }\n      // 最大的数\n      const max = isLimit ? Math.min(Number(n[i]), 9) : 9;\n      const min = isNum ? 0 : 1;\n      for (let j = min; j <= max; j++) {\n        ret += dp(i + 1, isLimit && j == n[i], true, g * j, sum + j);\n      }\n      cache.set(k, ret);\n      return ret;\n    }\n\n    return dp(0, true, false, 1, 0);\n  }\n\n  console.log(getCnt(r), getCnt(l - 1));\n\n  return getCnt(r) - getCnt(l - 1);\n};\n","author":"lihaoze","submissionId":"611274157"},[]]},{"447":[{"id":"447","fileName":"611273289.txt","sourceCode":"class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def count(r_val):\n            if r_val < 1:\n                return 0\n            r_str = str(r_val)\n            count_without_zero = self.count_without_zero(r_str)\n            count_contains_zero = r_val - count_without_zero\n            count_non_zero_valid = 0\n            max_s = 9 * len(r_str)\n            for s in range(1, max_s + 1):\n                cnt = self.count_s(s, r_str)\n                count_non_zero_valid += cnt\n            return count_contains_zero + count_non_zero_valid\n        return count(r) - count(l - 1)\n    def count_without_zero(self, n_str):\n        digits = list(map(int, n_str))\n        m = len(digits)\n        from functools import lru_cache\n        @lru_cache(maxsize=None)\n        def dp(pos, tight, is_num):\n            if pos == m:\n                return 1 if is_num else 0\n            limit = digits[pos] if tight else 9\n            total = 0\n            for d in range(0, limit + 1):\n                new_tight = tight and (d == limit)\n                new_is_num = is_num or (d != 0)\n                if new_is_num:\n                    if d == 0:\n                        continue \n                    total += dp(pos + 1, new_tight, new_is_num)\n                else:\n                    total += dp(pos + 1, new_tight, new_is_num)\n            return total\n        return dp(0, True, False)\n    def count_s(self, s, n_str):\n        if s == 0:\n            return 0\n        digits = list(map(int, n_str))\n        m = len(digits)\n        from functools import lru_cache\n        @lru_cache(maxsize=None)\n        def dp(pos, sum_so_far, prod_mod, tight, is_num):\n            if pos == m:\n                return 1 if (is_num and sum_so_far == s and prod_mod == 0) else 0\n            res = 0\n            max_d = digits[pos] if tight else 9\n            for d in range(0, max_d + 1):\n                new_tight = tight and (d == max_d)\n                new_is_num = is_num or (d != 0)\n                if not new_is_num:\n                    res += dp(pos + 1, sum_so_far, prod_mod, new_tight, new_is_num)\n                else:\n                    if d == 0:\n                        continue\n                    new_sum = sum_so_far + d\n                    new_prod_mod = (prod_mod * d) % s\n                    remaining = m - pos - 1\n                    if new_sum > s or (new_sum + remaining * 9 < s):\n                        continue\n                    res += dp(pos + 1, new_sum, new_prod_mod, new_tight, new_is_num)\n            return res\n\n        return dp(0, 0, 1, True, False)","author":"poiujhgdsd","submissionId":"611273289"},[]]}]}