{"data":[{"0":[{"id":"0","fileName":"1575088928.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        a = nums\n        n = len(a)\n        if all(x==0 for x in a):\n            return 0\n        d = [1]*n\n        for i, q in enumerate(queries):\n            x, y, z = q\n            for j in range(x, y+1):\n                d[j] |= d[j] << z\n            if all(d[j] & (1 << a[j]) for j in range(n)):\n                return i+1\n        return -1\n","author":"twitch_tv_patshelloworld","submissionId":"1575088928"},[]]},{"1":[{"id":"1","fileName":"1575083074.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        if all(x == 0 for x in nums):\n            return 0\n        dp = [1] * n\n        masks = [(1 << (num + 1)) - 1 for num in nums]\n        for k, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                dp[i] |= (dp[i] << val)\n                dp[i] &= masks[i]\n            if all(dp[i] & (1 << nums[i]) for i in range(n)):\n                return k + 1\n        return -1\n","author":"8iRTeedKTz","submissionId":"1575083074"},[]]},{"2":[{"id":"2","fileName":"1575089295.txt","sourceCode":"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Solution {\n    static PrintWriter out;\n    static int inf = (int) 1e9;\n    static int mod = (int) 1e9 + 7;\n\n    public static void main(String[] args) {\n        FastReader in = new FastReader();\n        out = new PrintWriter(System.out);\n        long t = in.nextInt();\n        long tc = 1;\n        while(tc <= t){\n            // Example usage:\n            // int n = in.nextInt();\n            // int[] a = in.readArray(n);\n            // int qn = in.nextInt();\n            // int[][] q = new int[qn][3];\n            // for(int i = 0; i < qn; i++){\n            //     q[i][0] = in.nextInt();\n            //     q[i][1] = in.nextInt();\n            //     q[i][2] = in.nextInt();\n            // }\n            // int ans = minZeroArray(a, q);\n            // out.println(ans);\n            tc++;\n        }\n        out.close();\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------------------*/\n    /*--------------------------------------------------------------------------------------------------------------------------------*/\n    private static int gcd(int a, int b){\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    static boolean[] sieveOfEratosthenes(int n){\n        boolean[] p = new boolean[n+1];\n        Arrays.fill(p, true);\n        p[0] = p[1] = false;\n        for(int i = 2; i * i <= n; i++){\n            if(p[i]){\n                for(int j = i * i; j <= n; j += i)\n                    p[j] = false;\n            }\n        }\n        return p;\n    }\n\n    static void sort(int[] a){\n        List<Integer> l = new ArrayList<>();\n        for(int x : a) l.add(x);\n        Collections.sort(l);\n        for(int i = 0; i < a.length; i++)\n            a[i] = l.get(i);\n    }\n\n    static long modPow(long a, long b, long m){\n        long r = 1;\n        a %= m;\n        while(b > 0){\n            if((b & 1) != 0)\n                r = r * a % m;\n            b >>= 1;\n            a = a * a % m;\n        }\n        return r;\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next(){\n            while(st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                } catch(IOException e){\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int[] readArray(int n){\n            int[] a = new int[n];\n            for(int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n        int nextInt(){\n            return Integer.parseInt(next());\n        }\n        long nextLong(){\n            return Long.parseLong(next());\n        }\n        double nextDouble(){\n            return Double.parseDouble(next());\n        }\n        String nextLine(){\n            String s = \"\";\n            try{\n                s = br.readLine();\n            } catch(IOException e){\n                e.printStackTrace();\n            }\n            return s;\n        }\n    }\n\n    public static int minZeroArray(int[] a, int[][] q) {\n        boolean z = true;\n        for (int x : a) {\n            if(x != 0) { z = false; break; }\n        }\n        if(z) return 0;\n        int l = 1, r = q.length, ans = -1;\n        while(l <= r) {\n            int mid = l + (r - l) / 2;\n            if(canZeroArray(a, q, mid)) {\n                ans = mid;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n\n    private static boolean canZeroArray(int[] a, int[][] q, int k) {\n        int n = a.length;\n        for (int j = 0; j < n; j++) {\n            int tgt = a[j];\n            boolean[] dp = new boolean[tgt + 1];\n            dp[0] = true;\n            for (int i = 0; i < k; i++) {\n                if(q[i][0] <= j && j <= q[i][1]) {\n                    int v = q[i][2];\n                    for (int s = tgt; s >= v; s--) {\n                        if(dp[s - v]) dp[s] = true;\n                    }\n                }\n            }\n            if(!dp[tgt]) return false;\n        }\n        return true;\n    }\n}\n","author":"mk17","submissionId":"1575089295"},[]]},{"3":[{"id":"3","fileName":"1575088938.txt","sourceCode":"\tclass Solution {\n\t\tpublic int minZeroArray(int[] nums, int[][] queries) {\n\t\t\tint n = nums.length;\n\t\t\tint max = 0;\n\t\t\touter:\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tint v = nums[i];\n\t\t\t\tboolean[] dp = new boolean[v+1];\n\t\t\t\tdp[0] = true;\n\t\t\t\tif(v == 0){\n\t\t\t\t\tmax = Math.max(max, 0);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int j = 0;j < queries.length;j++){\n\t\t\t\t\tint[] q = queries[j];\n\t\t\t\t\tif(q[0] <= i && i <= q[1]){\n\t\t\t\t\t\tfor(int k = v-q[2];k >= 0;k--){\n\t\t\t\t\t\t\tif(dp[k]){\n\t\t\t\t\t\t\t\tdp[k+q[2]] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[v]){\n\t\t\t\t\t\tmax = Math.max(max, j+1);\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn max;\n\t\t}\n\t}\n","author":"uwi","submissionId":"1575088938"},[]]},{"4":[{"id":"4","fileName":"1575098284.txt","sourceCode":"class Solution {\npublic:\n    int dp[15][1005], n, q, a[1005];\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        n = nums.size();\n        for(int i = 1; i <= n; ++i) a[i] = nums[i - 1];\n        for(int i = 1; i <= n; ++i) dp[i][0] = 1;\n        q = queries.size();\n        int zero = 0;\n        for(int i = 1; i <= n; ++i) if(a[i] == 0) ++zero;\n        if(zero == n) return 0;\n        for(int i = 0; i < q; ++i){\n            int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n            for(int j = l + 1; j <= r + 1; ++j){\n                for(int k = a[j]; k >= v; --k)\n                    dp[j][k] = std::max(dp[j][k], dp[j][k - v]);\n            }\n            int ok = 0;\n            for(int j = 1; j <= n; ++j)\n                if(dp[j][a[j]] == 1)\n                    ok += 1;\n            if(ok == n) return i + 1;\n        }\n        return -1;\n    }\n};","author":"Ethan","submissionId":"1575098284"},[]]},{"5":[{"id":"5","fileName":"1575090581.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, m = len(nums), len(queries)\n        def possible(k: int) -> bool:\n            for i in range(n):\n                target, dp = nums[i], 1\n                for j in range(k):\n                    l, r, v = queries[j]\n                    if l <= i <= r:\n                        dp |= dp << v\n                        if dp >> target & 1:\n                            break\n                if not (dp >> target & 1):\n                    return False\n            return True\n        lo, hi, ans = 0, m + 1, -1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if possible(mid):\n                ans, hi = mid, mid\n            else:\n                lo = mid + 1\n        return ans if ans != m + 1 else -1\n","author":"varshithchilukuri","submissionId":"1575090581"},[]]},{"6":[{"id":"6","fileName":"1575101651.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ok=1;\n        for(auto it:nums){\n            if(it)ok=0;\n        }\n        if(ok)return 0;\n        int val[10][1005];\n        memset(val,0,sizeof(val));\n        for(int i = 0;i<nums.size();i++)val[i][0]=1;\n        int cnt=0;\n        for(auto it:queries){\n            int l=it[0],r=it[1];\n            for(int i = l;i<=r;i++){\n                for(int j = 1000-it[2];j>=0;j--){\n                    if(val[i][j])val[i][j+it[2]]=1;\n                }\n            }\n            cnt++;\n            int ok=1;\n            for(int i=0;i<nums.size();i++){\n                if(val[i][nums[i]]);\n                else ok=0;\n            }\n            if(ok)return cnt;\n        }\n        return -1;\n    }\n};","author":"hank55663","submissionId":"1575101651"},[]]},{"7":[{"id":"7","fileName":"1575094621.txt","sourceCode":"class Solution {\n    fun minZeroArray(nums: IntArray, queries: Array<IntArray>): Int {\n        if (nums.isAllZero()) return 0\n    \n        val queryList = queries.map { Query(it[0], it[1], it[2]) }\n        var (low, high) = 1 to queryList.size\n        var result = -1\n        while (low <= high) {\n            val mid = (low + high) / 2\n            if (isAchievableAt(mid, nums, queryList)) {\n                result = mid\n                high = mid - 1\n            } else {\n                low = mid + 1\n            }\n        }\n        return result\n    }\n    \n    private data class Query(val start: Int, val end: Int, val value: Int)\n    \n    private fun IntArray.isAllZero() = all { it == 0 }\n    \n    private fun List<Int>.canSumToTarget(target: Int) =\n        fold(setOf(0)) { sums, num ->\n            sums.union(sums.map { it + num }.filter { it <= target })\n        }.contains(target)\n    \n    private fun isAchievableAt(\n        k: Int,\n        nums: IntArray,\n        queries: List<Query>\n    ): Boolean =\n        nums.indices.all { i ->\n            val available = (0..<k).mapNotNull { j ->\n                if (queries[j].start <= i && i <= queries[j].end) queries[j].value else null\n            }\n            available.sum() >= nums[i] && available.canSumToTarget(nums[i])\n        }\n\n}","author":"Mukhamed Issa","submissionId":"1575094621"},[]]},{"8":[{"id":"8","fileName":"1575102334.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        dp = [1 for _ in range(n)]\n        targets = nums[:]\n\n        if all(num == 0 for num in nums):\n            return 0\n\n        for k, (l, r, val) in enumerate(queries, start = 1):\n            for i in range(l, r + 1):\n                target = targets[i]\n                new_dp = dp[i] | (dp[i] << val)\n                mask = (1 << (target + 1)) - 1\n                dp[i] = new_dp & mask\n\n            if all((dp[i] >> targets[i]) & 1 for i in range(n)):\n                return k\n\n        return -1","author":"Keerthi Rao C","submissionId":"1575102334"},[]]},{"9":[{"id":"9","fileName":"1575102301.txt","sourceCode":"from functools import lru_cache\n\nclass Solution:\n    def minZeroArray(self, a: list[int], qs: list[list[int]]) -> int:\n        n = len(a)\n\n        def br():\n            rg = [[] for _ in range(n)]\n            for i, (L, R, c) in enumerate(qs):\n                for j in range(L, R + 1):\n                    rg[j].append(i)\n            return rg\n\n        def fm(qL, k):\n            @lru_cache(None)\n            def rec(i, k):\n                if k == 0:\n                    return i\n                if i == len(qL) or k < 0:\n                    return 10**9\n                return min(rec(i + 1, k), rec(i + 1, k - qs[qL[i]][2]))\n            return rec(0, k)\n\n        rg = br()\n        res = 0\n        for i in range(n):\n            tmp = fm(rg[i], a[i])\n            if tmp == 10**9:\n                return -1\n            if tmp > 0 and (tmp - 1) < len(rg[i]):\n                res = max(res, rg[i][tmp - 1] + 1)\n        return res","author":"All","submissionId":"1575102301"},[]]},{"10":[{"id":"10","fileName":"1575103402.txt","sourceCode":"#include <stdbool.h>\n\nint minZeroArray(int* arr, int n, int** q, int m, int* qc) {\nint i, j, k;\nbool z = true;\nfor (i = 0; i < n; i++) {\nif (arr[i] != 0) {\nz = false;\nbreak;\n}\n}\nif (z) return 0;\n\nfor (k = 0; k <= m; k++) {\nbool p = true;\nfor (i = 0; i < n; i++) {\nint t = arr[i];\nif (t == 0) continue;\n\nbool dp[1001] = { false };\ndp[0] = true;\n\nfor (j = 0; j < k; j++) {\nint l = q[j][0], r = q[j][1], v = q[j][2];\nif (i < l || i > r) continue;\nfor (int s = t; s >= v; s--) {\nif (dp[s - v]) dp[s] = true;\n}\n}\nif (!dp[t]) {\np = false;\nbreak;\n}\n}\nif (p) return k;\n}\nreturn -1;\n}\n","author":"kl2400032885","submissionId":"1575103402"},[]]},{"11":[{"id":"11","fileName":"1575097653.txt","sourceCode":"#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& A, vector<vector<int>>& B) {\n        int a = A.size();\n        bool b = true;\n        for (int c = 0; c < a; c++) {\n            if (A[c] != 0) {\n                b = false;\n                break;\n            }\n        }\n        if (b) {\n            return 0;\n        }\n        \n        vector<vector<bool>> d(a);\n        for (int e = 0; e < a; e++) {\n            d[e].resize(A[e] + 1, false);\n            d[e][0] = true;\n        }\n        \n        int f = B.size();\n        for (int g = 0; g < f; g++) {\n            int h = B[g][0];\n            int i = B[g][1];\n            int j = B[g][2];\n            \n            for (int k = h; k <= i; k++) {\n                int l = A[k];\n                vector<bool> m = d[k];\n                for (int n = 0; n <= l; n++) {\n                    if (d[k][n]) {\n                        if (n + j <= l) {\n                            m[n + j] = true;\n                        }\n                    }\n                }\n                d[k] = m;\n            }\n            \n            bool o = true;\n            for (int p = 0; p < a; p++) {\n                if (!d[p][A[p]]) {\n                    o = false;\n                    break;\n                }\n            }\n            if (o) {\n                return g + 1;\n            }\n        }\n        return -1;\n    }\n};\n","author":"ChangeofPace","submissionId":"1575097653"},[]]},{"12":[{"id":"12","fileName":"1575104673.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        auto canZero = [&](int k) -> bool {\n            for (int j = 0; j < n; j++) {\n                vector<bool> dp(nums[j] + 1, false);\n                dp[0] = true;\n                for (int i = 0; i < k; i++) {\n                    int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n                    if (j < l || j > r) continue;\n                    for (int s = nums[j]; s >= 0; s--) {\n                        if (dp[s] && s + val <= nums[j])\n                            dp[s + val] = true;\n                    }\n                }\n                if (!dp[nums[j]])\n                    return false;\n            }\n            return true;\n        };\n        if (canZero(0))\n            return 0;\n        for (int k = 1; k <= m; k++) {\n            if (canZero(k))\n                return k;\n        }\n        return -1;\n    }\n};","author":"IronSpidy","submissionId":"1575104673"},[]]},{"13":[{"id":"13","fileName":"1575099831.txt","sourceCode":"class Solution {\n    fun minZeroArray(a: IntArray, q: Array<IntArray>): Int {\n        val dp = q\n        val n = a.size\n        val L = Array(n) { mutableListOf<Pair<Int, Int>>() }\n        for(j in dp.indices){\n            val l = dp[j][0]\n            val r = dp[j][1]\n            val v = dp[j][2]\n            for(i in l..r) L[i].add(j to v)\n        }\n        fun ok(k: Int): Boolean {\n            for(i in 0 until n){\n                val t = a[i]\n                if(t == 0) continue\n                val arr = L[i].filter { it.first < k }.map { it.second }\n                val dp = BooleanArray(t + 1)\n                dp[0] = true\n                for(x in arr){\n                    for(s in t downTo x) if(dp[s - x]) dp[s] = true\n                    if(dp[t]) break\n                }\n                if(!dp[t]) return false\n            }\n            return true\n        }\n        if(a.all { it == 0 }) return 0\n        var lo = 1\n        var hi = dp.size\n        var ans = -1\n        while(lo <= hi){\n            val mid = (lo + hi) / 2\n            if(ok(mid)){\n                ans = mid\n                hi = mid - 1\n            } else lo = mid + 1\n        }\n        return ans\n    }\n}\n","author":"dkasd_12","submissionId":"1575099831"},[]]},{"14":[{"id":"14","fileName":"1575106521.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        \n        int[] ansz = nums.clone();\n        \n        boolean alrdyz = true;\n        for (int num : ansz) {\n            if (num != 0) {\n                alrdyz = false;\n                break;\n            }\n        }\n        if (alrdyz) return 0;\n        \n\n        boolean[][] dp = new boolean[n][];\n        for (int j = 0; j < n; j++) {\n            dp[j] = new boolean[ansz[j] + 1];\n            dp[j][0] = true;\n        }\n        \n\n        for (int i = 0; i < queries.length; i++) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for (int j = l; j <= r; j++) {\n\n                for (int s = ansz[j]; s >= val; s--) {\n                    if (!dp[j][s] && dp[j][s - val]) {\n                        dp[j][s] = true;\n                    }\n                }\n            }\n            \n            boolean allz = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j][ansz[j]]) {\n                    allz = false;\n                    break;\n                }\n            }\n            if (allz) {\n                return i + 1;\n            }\n        }\n        \n        return -1;\n    }\n}","author":"Ritik Kumar Sahoo","submissionId":"1575106521"},[]]},{"15":[{"id":"15","fileName":"1575107427.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n\n        if all(x == 0 for x in nums):\n            return 0\n        \n        vals = [[] for _ in range(n)]\n        \n        def subsumpos(vals: List[int], tar: int) -> bool:\n            dp = [False] * (tar + 1)\n            dp[0] = True\n            for val in vals:\n                for s in range(tar, val - 1, -1):\n                    if dp[s - val]:\n                        dp[s] = True\n                if dp[tar]:\n                    return True\n            return dp[tar]\n        \n        for k, query in enumerate(queries, start=1):\n            l, r, val = query\n            for i in range(l, r + 1):\n                vals[i].append(val)\n            \n            possible = True\n            for i in range(n):\n                if nums[i] == 0:\n                    continue\n                if not subsumpos(vals[i], nums[i]):\n                    possible = False\n                    break\n            \n            if possible:\n                return k\n        \n        return -1","author":"Cry Andrich","submissionId":"1575107427"},[]]},{"16":[{"id":"16","fileName":"1575107337.txt","sourceCode":"const int M = 1005;\n\nint dp[10][M];\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& qs) {\n        int n = a.size();\n        int q = qs.size();\n\n        int f = 1;\n        for (int i = 0; i < n; i++) {\n            if (a[i]) {\n                f = 0;\n                break;\n            }\n        }\n        if (f) return 0;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 1; j <= a[i]; j++) dp[i][j] = 0;\n            dp[i][0] = 1;\n        }\n\n        for (int ii = 0; ii < q; ii++) {\n            int l = qs[ii][0], r = qs[ii][1], v = qs[ii][2];\n\n            for (int i = l; i <= r; i++) {\n                for (int j = a[i]; j >= v; j--) {\n                    if (dp[i][j - v]) dp[i][j] = 1;\n                }\n            }\n\n            int f = 1;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i][a[i]]) {\n                    f = 0;\n                    break;\n                }\n            }\n            if (f) {\n                return ii + 1;\n            }\n        }\n\n        return -1;\n    }\n};","author":"OTTFF","submissionId":"1575107337"},[]]},{"17":[{"id":"17","fileName":"1575107641.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        \n        int n = a.size(), m = q.size(), ans = 0;\n        \n        for (int i = 0; i < n; i++) {\n            \n            int t = a[i];\n            vector<bool> dp(t + 1, false);\n            \n            dp[0] = true;\n            int cur = -1;\n            \n            if(t == 0) cur = 0;\n            else {\n                for (int j = 0; j < m; j++){\n                    if(q[j][0] <= i && i <= q[j][1]){\n                        int v = q[j][2];\n                        for (int k = t; k >= v; k--)\n                            dp[k] = dp[k] || dp[k - v];\n                    }\n                    if(dp[t]){\n                        cur = j + 1;\n                        break;\n                    }\n                }\n            }\n            if(cur == -1) return -1;\n            ans = max(ans, cur);\n        }\n        \n        return ans;\n    }\n};\n","author":"Ronak Gadhiya","submissionId":"1575107641"},[]]},{"18":[{"id":"18","fileName":"1575105912.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n            int target = nums[i];\n            bitset<1001> cur;\n            cur[0] = true;\n            \n            if (target == 0) continue;\n            \n            int at = -1;\n            for (int j = 0; j < queries.size(); ++j) {\n                if (i < queries[j][0] || i > queries[j][1]) continue;\n                cur = cur | (cur << queries[j][2]);\n                if (cur[target]) {\n                    at = j;\n                    break;\n                }\n            }\n            if (at == -1) return -1;\n            ans = max(ans, at + 1);\n        }\n        return ans;\n    }\n};","author":"Yang Xiao","submissionId":"1575105912"},[]]},{"19":[{"id":"19","fileName":"1575107030.txt","sourceCode":"#include<bits/stdc++.h>\nusing namespace std;\nclass Solution\n{\npublic:\nint minZeroArray(vector<int>&bhavdeep,vector<vector<int>>&singh)\n{\nvector<int>nijhawan=bhavdeep;\nbool pehleSeHi=true;\nfor(long long akshar:bhavdeep)\n{\nif(akshar!=0)\n{ \npehleSeHi=false; \nbreak; \n}\n}\nif(pehleSeHi)\n{\nreturn 0;\n}\nlong long zyada=0;\nfor(long long pehla:bhavdeep)\n{\nzyada=max(zyada,pehla);\n}\nvector<vector<bool>>kyaMumkinHai(bhavdeep.size(),\nvector<bool>(zyada+1,false));\nfor(long long pp=0;pp<bhavdeep.size();++pp)\n{\nkyaMumkinHai[pp][0]=true;\n// Platform: https://leetcode.com/\n// Profile: https://leetcode.com/u/kyaMumkinHaiSinghNijhawa\n// Contest: https://leetcode.com/contest/weekly-contest-441/\n// Question: https://leetcode.com/contest/weekly-contest-441/problems/zero-array-transformation-iv/\n// Time: 08:13\n}\nfor(long long oo=0;oo<singh.size();++oo)\n{\nlong long baayein=singh[oo][0];\nlong long daayein=singh[oo][1];\nlong long kitna=singh[oo][2];\nfor(long long pp=baayein;pp<=daayein;++pp)\n{\nfor(long long qq=zyada-kitna;qq>=0;--qq)\n{\nif(kyaMumkinHai[pp][qq]&&qq+kitna<=zyada)\n{\nkyaMumkinHai[pp][qq+kitna]=true;\n}\n}\n}\nbool pahunchGaye=true;\nfor (long long pp=0;pp<bhavdeep.size();++pp)\n{\nif(!kyaMumkinHai[pp][bhavdeep[pp]])\n{\npahunchGaye=false;\nbreak;\n}\n}\nif(pahunchGaye)\n{\nreturn oo+1;\n}\n}\nreturn -1;\n}\n};","author":"Bhavdeep Singh Nijhawan","submissionId":"1575107030"},[]]},{"20":[{"id":"20","fileName":"1575102953.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nbool f(int t, vector<int>& v) {\n    vector<bool> d(t + 1, false);\n    d[0] = true;\n    for (auto x : v)\n        for (int j = t; j >= x; j--)\n            if (d[j - x]) d[j] = true;\n    return d[t];\n}\n\nbool g(int k, vector<int>& v, vector<vector<int>>& q) {\n    int n=v.size();\n    for (int i = 0; i < n; i++) {\n        vector<int> x;\n        for (int j = 0; j < k; j++)\n            if (q[j][0] <= i && i <= q[j][1]) x.push_back(q[j][2]);\n        if (!f(v[i], x)) return 0;\n    }\n    return 1;\n}\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& v, vector<vector<int>>& q) {\n        int m=q.size();\n        for (int k = 0; k< m+1; k++)\n            if (g(k,v, q)) return k;\n        return -1;\n    }\n};\n","author":"PJ_ID","submissionId":"1575102953"},[]]},{"21":[{"id":"21","fileName":"1575108958.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        if all(x == 0 for x in nums):\n            return 0\n\n        def check(k):\n            for j in range(n):\n                dp = 1\n                for i in range(k):\n                    l, r, v = queries[i]\n                    if l <= j <= r:\n                        dp |= dp << v\n                if (dp >> nums[j]) & 1 == 0:\n                    return False\n            return True\n\n        low, high = 0, m + 1\n        while low < high:\n            mid = (low + high) // 2\n            if check(mid):\n                high = mid\n            else:\n                low = mid + 1\n        return low if low <= m else -1","author":"Varun Agnihotri","submissionId":"1575108958"},[]]},{"22":[{"id":"22","fileName":"1575108442.txt","sourceCode":"#include <vector>\n#include <bitset>\nusing namespace std;\n\nclass Solution {\npublic:\n    inline void cf(int &x) {\n        x = x | 0;\n        x = x & 1;\n        x = x ^ 0;\n    }\n\n    inline bool ca(const vector<int>& a, const vector<bitset<1001>>& b) {\n        int i = 0;\n        while(i < a.size()){\n            if(!b[i].test(a[i])) return false;\n            i++;\n        }\n        return true;\n    }\n\n    inline void init(vector<bitset<1001>> &b, int n) {\n        int i = 0;\n        while(i < n) {\n            b[i].reset();\n            b[i].set(0, true);\n            int dm = i;\n            cf(dm);\n            i++;\n        }\n    }\n\n    inline void extra() {\n        int t = 42;\n        t = t | 0;\n        t = t & 1;\n        t = t ^ 0;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        pair<vector<int>, vector<vector<int>>> p = {nums, queries};\n        extra();\n        vector<bitset<1001>> d(n);\n        init(d, n);\n        bool z = true;\n        int i = 0;\n        while(i < n) {\n            if(nums[i] != 0) { z = false; break; }\n            int r = i;\n            cf(r);\n            i++;\n        }\n        if(z) return 0;\n        int k = 0;\n        while(k < queries.size()) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int val = queries[k][2];\n            int j = l;\n            while(j <= r) {\n                d[j] |= (d[j] << val);\n                int pos = nums[j] + 1;\n                while(pos < 1001) {\n                    d[j].reset(pos);\n                    pos++;\n                }\n                int tmp = j;\n                cf(tmp);\n                j++;\n            }\n            if(ca(nums, d)) return k + 1;\n            k++;\n        }\n        return -1;\n    }\n};\n","author":"G123df","submissionId":"1575108442"},[]]},{"23":[{"id":"23","fileName":"1575107615.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size();\n        bool allZero = true;\n        for (int v : nums) { if(v!=0){ allZero=false; break; } }\n        if(allZero) return 0;\n        for (int k = 0; k <= q; k++){\n            bool ok = true;\n            for (int i = 0; i < n; i++){\n                int req = nums[i];\n                if(req == 0) continue;\n                vector<bool> dp(req+1,false);\n                dp[0]= true;\n                for (int j = 0; j < k; j++){\n                    int l = queries[j][0], r = queries[j][1], v = queries[j][2];\n                    if(l<= i && i <= r){\n                        for (int s = req; s >= v; s--){\n                            dp[s] = dp[s] || dp[s-v];\n                        }\n                    }\n                }\n                if(!dp[req]){ ok = false; break; }\n            }\n            if(ok) return k;\n        }\n        return -1;\n    }\n};","author":"I_Love_Ginger","submissionId":"1575107615"},[]]},{"24":[{"id":"24","fileName":"1575109814.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& qs) {\n        int mx = *max_element(a.begin(), a.end());\n        if (mx == 0) return 0;\n        \n        int n = a.size();\n        int m = qs.size();\n        const int C = 1024;\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            bitset<C> dp;\n            dp[0] = 1;\n            int c = a[i], qi = 0;\n            while (!dp[c] && qi < m) {\n                auto& q = qs[qi];\n                int l = q[0], r = q[1], v = q[2];\n                if (l <= i && i <= r) {\n                    dp |= dp << v;\n                }\n                qi++;\n            }\n            if (!dp[c]) return -1; \n            ans = max(ans, qi);\n        }\n        return ans;\n    }\n};","author":"Shik Chen","submissionId":"1575109814"},[]]},{"25":[{"id":"25","fileName":"1575110089.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        \n        n = len(nums)\n\n        if all(x == 0 for x in nums):\n            return 0\n\n        non_zero_indices = [j for j in range(n) if nums[j] > 0]\n        if not non_zero_indices:\n            return 0\n\n        MAX_SUM = 1000\n        CLAMP_MASK = (1 << (MAX_SUM + 1)) - 1  \n        bitset_of = [1 for _ in range(n)]  \n\n        for i, (left, right, val) in enumerate(queries):\n            for j in range(left, right + 1):\n                if nums[j] > 0:  \n                    bitset_of[j] |= (bitset_of[j] << val)\n                    bitset_of[j] &= CLAMP_MASK  \n\n            all_zero_possible = True\n            for j in non_zero_indices:\n                if not ((bitset_of[j] >> nums[j]) & 1):\n                    all_zero_possible = False\n                    break\n\n            if all_zero_possible:\n                return i + 1  \n\n        return -1\n\n        ","author":"yaominzh","submissionId":"1575110089"},[]]},{"26":[{"id":"26","fileName":"1575110159.txt","sourceCode":"class Solution {\npublic:\n    bool f[20][1005];\n    int minZeroArray(vector<int>& a, vector<vector<int>>& Q) {\n        int i, j, n = a.size(), st, ed, mid, x;\n        for (i = 0; i < n; ++i){\n            for (j = 0; j <= a[i]; ++j) f[i][j] = false;\n            f[i][0] = true;\n        }\n        \n        for (i = 0; i < n; ++i)\n            if (a[i] > 0) break;\n        if (i == n) return 0;\n        \n        for (int q = 0; q < Q.size(); ++q){\n            x = Q[q][2];\n            for (i = Q[q][0]; i <= Q[q][1]; ++i){\n                if (f[i][a[i]]) continue;\n                for (j = a[i] - x; j >= 0; --j)\n                    f[i][j + x] |= f[i][j];\n            }\n                \n            for (i = 0; i < n; ++i)\n                if (!f[i][a[i]])\n                    break;\n            if (i == n) return q + 1;\n        }\n        \n        return -1;\n    }\n};","author":"Ma Lin","submissionId":"1575110159"},[]]},{"27":[{"id":"27","fileName":"1575111038.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def getmin(idx):\n            if nums[idx] == 0:\n                return 0\n            f = set([nums[idx]])\n            for i, (l, r, v) in enumerate(queries):\n                if not l <= idx <= r:\n                    continue\n                f |= set(num - v for num in f if num - v >= 0)\n                if 0 in f:\n                    return i + 1\n            return -1\n        ans = -1\n        for i in range(len(nums)):\n            this = getmin(i)\n            if this == -1:\n                return -1\n            ans = max(ans, this)\n        return ans","author":"lihaicoder","submissionId":"1575111038"},[]]},{"28":[{"id":"28","fileName":"1575110392.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ln = 0;\n        int idx = 0;\n        while (idx < (int)nums.size()) {\n            ln++;\n            idx++;\n        }\n        int tot = 0;\n        idx = 0;\n        while (idx < (int)queries.size()) {\n            tot++;\n            idx++;\n        }\n        bool allNil = true;\n        idx = 0;\n        while (idx < (int)nums.size()) {\n            if (nums[idx] != 0) {\n                allNil = false;\n                break;\n            }\n            idx++;\n        }\n        if (allNil) {\n            int tmp = 0;\n            int res = (tmp * 2 - tmp);\n            return res;\n        }\n        auto canZero = [&](int cnt) -> bool {\n            int pos = 0;\n            while (pos < ln) {\n                int tgt = nums[pos];\n                vector<bool> bin;\n                int iter = 0;\n                while (iter <= tgt) {\n                    bin.push_back(false);\n                    iter++;\n                }\n                bin[0] = true;\n                int cur = 0;\n                while (cur < cnt && cur < tot) {\n                    int start = queries[cur][0], end = queries[cur][1], val = queries[cur][2];\n                    if (start <= pos && pos <= end) {\n                        int sumVal = tgt;\n                        while (sumVal >= val) {\n                            if (bin[sumVal - val]) {\n                                bin[sumVal] = true;\n                            }\n                            sumVal--;\n                        }\n                    }\n                    cur++;\n                }\n                if (!bin[tgt]) return false;\n                pos++;\n            }\n            return true;\n        };\n        int lo = 0;\n        int hi = tot + 1;\n        int ans = -1;\n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (canZero(mid)) {\n                ans = mid;\n                hi = mid;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        int fin = ans;\n        int ret = fin * 2 - fin;\n        return ret;\n    }\n};","author":"rokkc","submissionId":"1575110392"},[]]},{"29":[{"id":"29","fileName":"1575111237.txt","sourceCode":"class Solution(object):\n    def minZeroArray(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        ans = 0\n        \n        for i in range(n):\n            if nums[i] == 0:\n                continue \n                \n            dp = [False]*(nums[i]+1)\n            dp[0] = True\n            \n            for j in range(len(queries)):\n                if not queries[j][0] <= i <= queries[j][1]:\n                    continue \n                w = queries[j][2]\n                for k in range(nums[i],w-1,-1):\n                    if dp[k-w]:\n                        dp[k] = True\n                        \n            \n                if dp[nums[i]]==True:\n                    ans = max(ans, j + 1)\n                    break\n                    \n            if not dp[nums[i]]:\n                return -1\n        return ans\n    \n            \n            \n            \n            \n            \n            ","author":"hxu10","submissionId":"1575111237"},[]]},{"30":[{"id":"30","fileName":"1575110768.txt","sourceCode":"#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int x;\n    int y;\n} T;\n\n\nint sol2(T* P, int cnt, int m, int tar) {\n    char d[10001] = { 0 };\n    d[0] = 1;\n    for (int i = 0; i < cnt; i++) {\n        if (P[i].x < m) {\n            int v = P[i].y;\n            for (int j = tar; j >= v; j--) {\n                if (d[j - v]) d[j] = 1;\n            }\n        }\n    }\n    return d[tar];\n}\n\n\nint minZeroArray(int* A, int N, int** Q, int QS, int* QC) {\n    int i, j, f = 1;\n    for (i = 0; i < N; i++) {\n        if (A[i] != 0) { f = 0; break; }\n    }\n    if (f) return 0;\n    T** B = (T**)malloc(N * sizeof(T*));\n    int* C = (int*)malloc(N * sizeof(int));\n    for (i = 0; i < N; i++) {\n        B[i] = (T*)malloc(QS * sizeof(T));\n        C[i] = 0;\n    }\n    for (j = 0; j < QS; j++) {\n        int L = Q[j][0], R = Q[j][1], V = Q[j][2];\n        for (i = L; i <= R; i++) {\n            B[i][C[i]].x = j;\n            B[i][C[i]].y = V;\n            C[i]++;\n        }\n    }\n    int lo = 0, hi = QS, ans = -1;\n    while (lo <= hi) {\n        int mid = (lo + hi) / 2, ok = 1;\n        for (i = 0; i < N; i++) {\n            if (A[i] == 0) continue;\n            if (!sol2(B[i], C[i], mid, A[i])) { ok = 0; break; }\n        }\n        if (ok) { ans = mid; hi = mid - 1; }\n        else { lo = mid + 1; }\n    }\n    for (i = 0; i < N; i++) free(B[i]);\n    free(B); free(C);\n    return ans;\n}","author":"wjhbr","submissionId":"1575110768"},[]]},{"31":[{"id":"31","fileName":"1575111354.txt","sourceCode":"class Solution {\npublic:\n    bool can(vector<int>& vec, int n){\n        vector<bool> dp(n + 1, 0);\n        dp[n] = 1;\n        for(int x: vec)\n            for(int i = x; i <= n; i++)\n                if(dp[i]) dp[i - x] = 1;\n        return dp[0];\n    }\n    bool ok(vector<int>& a, vector<vector<int>>& qr, int k){\n        vector<vector<int>> vec(a.size(), vector<int>());\n        for(int i = 0; i < k; i++){\n            int l = qr[i][0];\n            int r = qr[i][1] + 1;\n            int x = qr[i][2];\n            for(int j = l; j < r; j++) vec[j].push_back(x);\n        }\n        bool res = 1;\n        for(int i = 0; i < a.size(); i++) res &= can(vec[i], a[i]);\n        return res;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int tl = -1, tr = queries.size() + 1;\n        while(tr - tl > 1){\n            int tm = tl + tr >> 1;\n            if(ok(nums, queries, tm)) tr = tm;\n            else tl = tm;\n        }\n        if(tr > queries.size()) return -1;\n        return tr;\n    }\n};","author":"Daulet","submissionId":"1575111354"},[]]},{"32":[{"id":"32","fileName":"1575111550.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        # so we want to sum up to something\n        # let's do something like subset sum\n        # works since small enough numbers\n        max_needed = -float('inf')\n        for i in range(len(nums)):\n            # figure out how many this needs\n            possible = [False for _ in range(nums[i]+1)]\n            possible[0] = True\n            possible_after = [float('inf') for _ in range(nums[i]+1)]\n            possible_after[0] = 0\n            for j in range(len(queries)):\n                l, r, val = queries[j]\n                if l <= i <= r:\n                    # can decrement\n                    for k in range(nums[i], val-1, -1):\n                        if possible[k-val]:\n                            possible[k] = True\n                            possible_after[k] = min(possible_after[k], j+1)\n            if not possible[-1]:\n                return -1\n            max_needed = max(max_needed, possible_after[-1])\n        return max_needed","author":"Eliot H","submissionId":"1575111550"},[]]},{"33":[{"id":"33","fileName":"1575110443.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        \n        for (int num : nums) {\n            if (num != 0) {\n                goto proceed;\n            }\n        }\n        return 0;\n        \n    proceed:\n        vector<vector<int>> a = queries;\n        \n        auto canZero = [&](int mid) -> bool {\n            for (int j = 0; j < n; j++) {\n                if (nums[j] == 0) continue;\n                \n                vector<int> decs;\n                for (int i = 0; i < mid; i++) {\n                    if (queries[i][0] <= j && j <= queries[i][1]) {\n                        decs.push_back(queries[i][2]);\n                    }\n                }\n                \n                bitset<1001> dp;\n                dp[0] = 1;\n                for (int d : decs) {\n                    dp |= (dp << d);\n                    if (nums[j] <= 1000 && dp[nums[j]]) break;\n                }\n                \n                if (!dp[nums[j]]) return false;\n            }\n            return true;\n        };\n        \n        int low = 1, high = q, ans = -1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (canZero(mid)) {\n                ans = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"Sarban Sah","submissionId":"1575110443"},[]]},{"34":[{"id":"34","fileName":"1575111777.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        int totSum = 1000;\n        \n        for(int k = 0; k <= q; k++){\n            bool poss = true;\n            for(int j = 0; j < n; j++){\n                if(nums[j] == 0) continue;\n                \n                bitset<1001> dp;\n                dp[0] = 1;\n                \n                for(int i = 0; i < k; i++){\n                    int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n                    if(j >= l && j <= r){\n                        dp |= (dp << v);\n                    }\n                }\n                \n                if(!dp.test(nums[j])){\n                    poss = false;\n                    break;\n                }\n            }\n            if(poss) return k;\n        }\n        return -1;\n    }\n};\n","author":"baliramkumar","submissionId":"1575111777"},[]]},{"35":[{"id":"35","fileName":"1575111769.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if not any(nums):\n            return 0\n        dp = [set([x]) for x in nums]\n        for i, (l, r, val) in enumerate(queries):\n            for j in range(l, r + 1):\n                s = dp[j]\n                if 0 not in s:\n                    new = set(x - val for x in s if x >= val)\n                    s.update(new)\n            if all(0 in s for s in dp):\n                return i + 1\n        return -1","author":"Chuan-Chih Chou","submissionId":"1575111769"},[]]},{"36":[{"id":"36","fileName":"1575107844.txt","sourceCode":"class Solution {\n    public static int min(int a, int b) {\n        return a < b ? a : b;\n    }\n    public static int max(int a, int b) {\n        return a > b ? a : b;\n    }\n    public int minZeroArray(int[] nums, int[][] queries) {\n        \n        int m = queries.length, n = nums.length;\n        int s = 0, high = m + 1;\n        int ans = queries[0][0];\n        \n        for (int i = 0; i < 100; i++) {\n            ans = (ans + 1) * 1;\n        } \n        ans -= 1;\n        System.out.println(ans);\n        \n        while (s < high) {\n            int mid = (s + high) / 2;\n            if (solve(nums, queries, mid)) {\n                high = mid;\n            } else {\n                s = mid + 1;\n            }\n        }\n        return s > m ? -1 : s;\n        \n    }\n    public static boolean solve(int[] nums, int[][] mat, int k) {\n        for (int i = 0; i < nums.length; i++) {\n            int tar = nums[i];\n            boolean[] dp = new boolean[tar + 1];\n            dp[0] = true;\n            for (int j = 0; j < k; j++) {\n                if (mat[j][0] <= i && i <= mat[j][1]) {\n                    int val = mat[j][2];\n                    for (int s = tar; s >= val; s--) {\n                        dp[s] = dp[s] || dp[s - val];\n                    }\n                }\n            }\n            if (!dp[tar]) return false;\n        }\n        return true;\n    }\n    public static boolean coinChangeCF(int[] coins, int index, int target, int[][] dp) {\n\n        if (target == 0) {\n            return true;\n        }\n\n        if (index == coins.length) {\n            return false;\n        }\n\n        if (dp[index][target] != -1) {\n            return dp[index][target] == 1;\n        }\n\n        boolean Pick = false;\n\n        if (target >= coins[index]) {\n            Pick = coinChangeCF(coins, index, target - coins[index], dp);\n        }\n        boolean notPick = coinChangeCF(coins, index + 1, target, dp);\n\n        boolean res = Pick || notPick;\n        dp[index][target] = res ? 1 : 0;\n        return res;\n    }\n    public static int coinChangeLC(int[] coins, int index, int target, int[][] dp) {\n\n        if (index == coins.length - 1) return target % coins[index] == 0 ? target / coins[index] : (int) 1e9;\n\n        if (dp[index][target] != -1) {\n            return dp[index][target];\n        }\n\n        int Pick = (int) 1e9;\n\n        if (target >= coins[index]) {\n            Pick = 1 + coinChangeLC(coins, index, target - coins[index], dp);\n        }\n        int notPick = 0 + coinChangeLC(coins, index + 1, target, dp);\n\n        return dp[index][target] = Math.min(Pick, notPick);\n    }\n    public static int coinChangeGFG(int[] coins, int index, int target, int[][] dp) {\n\n        if (index == coins.length - 1) return target % coins[index] == 0 ? 1 : 0;\n\n        if (dp[index][target] != -1) {\n            return dp[index][target];\n        }\n\n        int Pick = 0;\n\n        if (target >= coins[index]) {\n            Pick = 1 + coinChangeGFG(coins, index, target - coins[index], dp);\n        }\n        int notPick = 0 + coinChangeGFG(coins, index + 1, target, dp);\n\n        return dp[index][target] = Pick + notPick;\n    }\n    public static int minJumps(int[] nums, int index) {\n\n        if (index >= nums.length - 1) {\n            return 0;\n        }\n\n        int minJumps = 99999;\n\n        for (int i = 1; i <= nums[index]; i++) {\n            minJumps = min(minJumps, 1 + minJumps(nums, index + i));\n        }\n        return minJumps;\n    }\n\n    public static int knapSack(int w, int[] values, int[] weights, int index, int[] dp) {\n\n        if (index >= values.length) {\n            return 0;\n        }\n\n        if (w <= 0) {\n            return 0;\n        }\n\n        if (dp[index] != -1) {\n            return dp[index];\n        }\n\n        int Pick = 0;\n        if (w >= weights[index]) {\n            Pick = values[index] + knapSack(w - weights[index], values, weights, index + 1, dp);\n        }\n        int notPick = 0 + knapSack(w, values, weights, index + 1, dp);\n\n        return dp[index] = max(Pick, notPick);\n    }\n    \n}","author":"Good_wealth","submissionId":"1575107844"},[]]},{"37":[{"id":"37","fileName":"1575112144.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        auto check = [&](int k) -> bool {\n            for (int i = 0; i < n; i++) {\n                if (nums[i] == 0) continue;\n                bitset<1001> dp;\n                dp[0] = 1;\n                for (int j = 0; j < k; j++) {\n                    int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                    if (l <= i && i <= r)\n                        dp |= (dp << val);\n                }\n                if (!dp[nums[i]])\n                    return false;\n            }\n            return true;\n        };\n        int low = 0, high = m + 1;\n        while (low < high) {\n            int mid = (low + high) / 2;\n            if (check(mid))\n                high = mid;\n            else\n                low = mid + 1;\n        }\n        return low <= m ? low : -1;\n    }\n};\n","author":"nadoor_7","submissionId":"1575112144"},[]]},{"38":[{"id":"38","fileName":"1575112529.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if all(n == 0 for n in nums):\n            return 0\n            \n        possible = [set([n]) for n in nums]\n        for (ans, (l, r, v)) in enumerate(queries):\n            done = True\n            for i in range(len(possible)):\n                if l <= i <= r:\n                    cur = list(possible[i])\n                    for p in cur:\n                        if p - v >= 0:\n                            possible[i].add(p - v)\n                if 0 not in possible[i]:\n                    done = False\n            if done:\n                return ans + 1\n        return -1","author":"allen_nie","submissionId":"1575112529"},[]]},{"39":[{"id":"39","fileName":"1575111796.txt","sourceCode":"class Solution\n{\npublic:\n  int minZeroArray(vector<int> &n, vector<vector<int>> &q)\n  {\n    bool b1 = true, ok = true;\n\n    for (auto &it : n)\n    {\n      if (it > 0)\n      {\n        b1 = false;\n        break;\n      }\n    }\n\n\n    if (b1)\n    {\n      return 0;\n    }\n\n    for (int k = 0; k <= q.size(); k++)\n    {\n      ok = true;\n\n      for (int i = 0; i < n.size(); i++)\n      {\n        bitset<1001> dp1;\n        dp1[0] = 1;\n\n        for (int j = 0; j < k; j++)\n        {\n          if (q[j][0] <= i)\n          {\n            if (i <= q[j][1])\n            {\n              dp1 = dp1 | (dp1 << q[j][2]);\n            }\n          }\n        }\n\n        if (!dp1.test(n[i]))\n        {\n          ok = false;\n          break;\n        }\n\n      }\n      if (ok)\n      {\n        return k;\n      }\n    }\n    \n    return -1;\n  }\n};","author":"Khushal Midha","submissionId":"1575111796"},[]]},{"40":[{"id":"40","fileName":"1575112413.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int N = nums.size();\n        const int K = 1005;\n        vector<vector<bool>> can(N, vector<bool>(K,0));\n\n        for (int i = 0; i < N; ++i) can[i][nums[i]] = 1;\n\n\n        int qn = 0;\n        auto can_zero = [&]() -> bool {\n            for (int i = 0; i < N; ++i) if (!can[i][0]) return false;\n            return true;\n        };\n        for (vector<int>& qq : queries) {\n            if (can_zero()) return qn;\n            ++qn;\n            int l = qq[0];\n            int r = qq[1];\n            int val = qq[2];\n\n            for (int i = l; i <= r; ++ i) {\n                for (int j = 0; j+val < K; ++j) {\n                    can[i][j] = can[i][j] || can[i][j+val];\n                }\n            }\n            \n        }\n        if (can_zero()) return qn;\n        return -1;\n    }\n};","author":"SirTechnical","submissionId":"1575112413"},[]]},{"41":[{"id":"41","fileName":"1575114568.txt","sourceCode":"#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n//#include <atcoder/all>\n//using mint = atcoder::modint998244353;\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<class key, class cmp = std::less<key>>\nusing ordered_set = tree<key, null_type, cmp, rb_tree_tag,tree_order_statistics_node_update>;\ntemplate<class key, class value, class cmp = std::less<key>>\nusing ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;\n\nusing lint = long long;\nusing ii = pair<int, int>;\nusing il = pair<int, lint>;\nusing li = pair<lint, int>;\nusing ll = pair<lint, lint>;\n\nconst int mxn = 1000100, mxp = 1000001;\nconst int MOD = 998244353, inf = -1e9 - 7, INF = 1e9 + 1;\nconst lint lnf = -4e18, LNF = 5e18;\nconst double eps = 1e-10;\nconst int sqrtN = 200;\n\n#define sz(x) int(size(x))\n#define all(x) (x).begin(),(x).end()\n#define compress(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())\n#define lb(x, v) (lower_bound(all(x), v) - (x).begin())\n#define ub(x, v) (upper_bound(all(x), v) - (x).begin())\n#define eb emplace_back\n#define pb push_back\n#define getName(var)  #var\nvector<lint> xl, yl;\n\n#define Yes \"Yesn\"\n#define No \"Non\"\n\nconst int dr[] = {-1, 0, 1, 0};\nconst int dc[] = {0, -1, 0, 1};\n\ninline int inRange(int r, int c, int R, int C) {\n    return 0 <= r && r < R && 0 <= c && c < C;\n}\n\nlint N, M, Q, R, C, H, K, T;\n\nvoid init() {\n\n}\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& queries) {\n        int ret = -1, n = sz(a), m = sz(queries);\n        \n        auto f = [&](int idx) {\n            int x = a[idx];\n            if(!x) return 0;\n            vector<int> d(x+1);\n            d[x] = 1;\n            for(int i = 0; i < m; i++) {\n                int l = queries[i][0], r = queries[i][1], w = queries[i][2];\n                auto nd = d;\n                 if((l <= idx && idx <= r) && x >= w) {\n                     for(int c = x; c >= w; c--) {\n                         nd[c-w] |= d[c];\n                     }\n                 }\n                 \n                 swap(d, nd);\n                 if(d[0]) return i+1;\n            }\n            return INF;\n        };\n        \n        for(int i = 0; i < n; i++) {\n            ret = max(ret, f(i));\n        }\n        \n        \n        if(ret == INF) ret = -1;\n        return ret;\n    }\n};\n","author":"raararaara","submissionId":"1575114568"},[]]},{"42":[{"id":"42","fileName":"1575114223.txt","sourceCode":"impl Solution {\n    pub fn min_zero_array(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> i32 {\n        let n = nums.len();\n        let len = queries.len();\n        let mut f = |m: usize| -> bool {\n            for j in 0..n {\n                let r = nums[j] as usize;\n                if r != 0 {\n                    let mut dp = vec![false; r + 1];\n                    dp[0] = true;\n                    for i in 0..m {\n                        if queries[i][0] as usize <= j && j <= queries[i][1] as usize {\n                            let v = queries[i][2] as usize;\n                            for s in (v..=r).rev() {\n                                dp[s] |= dp[s - v];\n                            }\n                        }\n                    }\n                    if !dp[r] {\n                        return false;\n                    }\n                }\n            }\n            true\n        };\n        // println!(\"{}\", f(0));\n        // println!(\"{}\", f(1));\n        // println!(\"{}\", f(2));\n        let mut low = 0;\n        let mut high = len + 1;\n        while low < high {\n            let mid = (low + high) / 2;\n            if f(mid) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        let ans: i32 = if low == len + 1 { -1 } else { low as i32 };\n        // println!(\"{}\", ans);\n\n        ans\n    }\n}","author":"parallel_stream","submissionId":"1575114223"},[]]},{"43":[{"id":"43","fileName":"1575114219.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        q = len(queries)\n        beg = 0\n        end = q\n        res = -1\n        while beg <= end:\n            mid = (beg + end) // 2\n            vals = [[] for _ in range(n)]\n            for i in range(mid):\n                l, r, v = queries[i]\n                for j in range(l, r + 1):\n                    vals[j].append(v)\n            pos = True\n            for i in range(n):\n                s = {0}\n                for v in vals[i]:\n                    s |= {x + v for x in s}\n                if nums[i] not in s:\n                    pos = False\n                    break\n            if pos:\n                res = mid\n                end = mid - 1\n            else:\n                beg = mid + 1\n        return res","author":"Abhishek Choudhary","submissionId":"1575114219"},[]]},{"44":[{"id":"44","fileName":"1575112333.txt","sourceCode":"const A: usize = 16;\n\nimpl Solution {\n    pub fn min_zero_array(b: Vec<i32>, c: Vec<Vec<i32>>) -> i32 {\n        let d = (b.clone(), c.clone());\n        let e = b.len();\n        let f = c.len();\n        let mut g: Vec<Vec<(usize, i32)>> = vec![Vec::new(); e];\n        \n        let mut arr1: Vec<i32> = Vec::new();\n        let mut aa = 0;\n        let mut bb = 0;\n        let mut cc = 0;\n        \n        for (h, i) in c.iter().enumerate() {\n            let j = i[0] as usize;\n            let k = i[1] as usize;\n            let l = i[2];\n            for m in j..=k {\n                g[m].push((h, l));\n            }\n        }\n\n        fn n(o: &[u64; A], p: usize) -> [u64; A] {\n            let mut q = [0u64; A];\n            let r = p / 64;\n            let s = p % 64;\n            for t in r..A {\n                let u = o[t - r] << s;\n                let v = if s > 0 && t - r > 0 {\n                    o[t - r - 1] >> (64 - s)\n                } else {\n                    0\n                };\n                q[t] = u | v;\n            }\n            q\n        }\n\n        fn w(x: usize, y: &Vec<i32>, z: &Vec<Vec<(usize, i32)>>, arr1: &mut Vec<i32>, aa: &mut i32, bb: &mut i32, cc: &mut i32) -> bool {\n            for (aa_idx, &bb_val) in y.iter().enumerate() {\n                let mut arr2: Vec<i32> = Vec::new();\n                let mut aa1 = 0;\n                let mut bb2 = 0;\n                let mut cc3 = 0;\n                cc3 += 3;\n                arr2.push(cc3);\n                let cc_idx = bb_val as usize;\n                cc3 += 3;\n                arr2.push(cc3);\n                let mut dd = [0u64; A];\n                cc3 += bb2;\n                arr2.push(cc3);\n                dd[0] = 1;\n                cc3 += aa1;\n                arr2.push(cc3);\n                *aa += 1;\n                arr1.push(*aa);\n                \n                for &(ee, ff) in z[aa_idx].iter() {\n                    if ee >= x {\n                        break;\n                    }\n                    let gg = ff as usize;\n                    let hh = n(&dd, gg);\n                    for ii in 0..A {\n                        dd[ii] |= hh[ii];\n                    }\n                }\n                \n                *bb += 2;\n                arr1.push(*bb);\n                \n                let jj = cc_idx / 64;\n                let kk = cc_idx % 64;\n                if ((dd[jj] >> kk) & 1) == 0 {\n                    return false;\n                }\n            }\n            true\n        }\n\n        let mut ll = 0;\n        let mut mm = f + 1;\n        cc += aa;\n        arr1.push(cc);\n        let mut nn = f + 1;\n        bb += 3;\n        arr1.push(bb);\n        while ll < mm {\n            let oo = ll + ((mm - ll) / 2);\n            if w(oo, &d.0, &g, &mut arr1, &mut aa, &mut bb, &mut cc) {\n                nn = oo;\n                mm = oo;\n            } else {\n                ll = oo + 1;\n            }\n        }\n\n        cc += 3;\n        arr1.push(cc);\n        \n        if nn > f {\n            -1\n        } else {\n            nn as i32\n        }\n    }\n}\n","author":"dom9090","submissionId":"1575112333"},[]]},{"45":[{"id":"45","fileName":"1575115088.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        q = len(queries)\n        dp = [1] * n\n        if all(num == 0 for num in nums):\n            return 0\n        for i in range(q):\n            l, r, val = queries[i]\n            for j in range(l, r + 1):\n                dp[j] |= dp[j] << val\n                if nums[j] > 0:\n                    dp[j] &= (1 << (nums[j] + 1)) - 1\n            if all(((dp[j] >> nums[j]) & 1) for j in range(n)):\n                return i + 1\n        return -1\n","author":"ianCheng","submissionId":"1575115088"},[]]},{"46":[{"id":"46","fileName":"1575114694.txt","sourceCode":"\nclass Solution {\npublic:\n    bool isZeroAchievable(const vector<int>& nums, const vector<vector<int>>& queries, int qCount) {\n        int n = nums.size();\n        vector<vector<int>> coinBuckets(n);\n        for (int i = 0; i < qCount; i++) {\n            int l = queries[i][0], r = queries[i][1], coin = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                coinBuckets[j].push_back(coin);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            vector<bool> dp(target + 1, false);\n            dp[0] = true;\n            for (int c : coinBuckets[i]) {\n                for (int s = target; s >= c; s--) {\n                    if (dp[s - c]) dp[s] = true;\n                }\n            }\n            if (!dp[target]) return false;\n        }\n        return true;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int low = 0, high = queries.size() + 1, ans = -1;\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            if (isZeroAchievable(nums, queries, mid)) {\n                ans = mid;\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"Keshav__2006","submissionId":"1575114694"},[]]},{"47":[{"id":"47","fileName":"1575115112.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ret = 0;\n        for (int i = 0; i < nums.size(); i++) if (nums[i] > 0) {\n            int ans = -1;\n\n            int u = nums[i];\n            vector<bool> cur(u + 1), nxt(u + 1);\n            \n            for (int z = 0; z <= u; z++) {\n                cur[z] = nxt[z] = false;\n            }\n            cur[0] = true;\n            \n            for (int idx = 0; idx < queries.size(); idx++) {\n                int l = queries[idx][0], r = queries[idx][1], val = queries[idx][2];\n                if (i < l || r < i) {\n                    continue;\n                }\n                \n                for (int x = 0; x <= u; x++) if (cur[x]) {\n                    nxt[x] = true;\n                    if (x + val <= u) {\n                        nxt[x + val] = true;                    \n                    }\n                }\n                                \n                if (nxt[u]) {\n                    ans = idx + 1;\n                    break;\n                }\n                \n                for (int x = 0; x <= u; x++) {\n                    cur[x] = nxt[x];\n                    nxt[x] = false;\n                }\n            }\n            \n            if (ans < 0) {\n                return ans;\n            }\n            ret = max(ret, ans);\n        }\n        return ret;\n    }\n};","author":"Linh Nguyen","submissionId":"1575115112"},[]]},{"48":[{"id":"48","fileName":"1575115107.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    // Checks if 'target' can be formed as a sum of a subset of values[] (each used at most once)\n    bool canFormSum(int target, const vector<int>& values) {\n        // If target < 0, impossible\n        if (target < 0) return false;\n        // A quick check: if sum of all values < target, no point in DP\n        int sumVals = 0;\n        for (int v : values) sumVals += v;\n        if (sumVals < target) return false;\n        \n        // Classic bitset-based subset-sum: dp[s] = can we make sum = s ?\n        static const int MAX_SUM = 10000 * 100; // placeholder if needed\n        // Actually, we will use target + 1 as the bitset range\n        vector<bool> dp(target + 1,false);\n        dp[0] = true; \n        for (int v : values) {\n            // Go backward so we don't reuse 'v' more than once\n            for (int s = target; s >= v; s--) {\n                if (dp[s - v]) dp[s] = true;\n            }\n        }\n        return dp[target];\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = (int)nums.size();\n        int m = (int)queries.size();\n        \n        // For k from 0..m, check if we can become zero\n        for (int k = 0; k <= m; k++) {\n            bool canBeZero = true;\n            \n            // For each index j, gather all query-values that cover j among first k queries\n            for (int j = 0; j < n; j++) {\n                int needed = nums[j];\n                if (needed == 0) continue;  // already zero, no subset needed\n                \n                vector<int> vals;\n                // Collect vali for i in [0..k-1] if j in [l_i, r_i]\n                for (int i = 0; i < k; i++) {\n                    int li = queries[i][0], ri = queries[i][1], val = queries[i][2];\n                    if (li <= j && j <= ri) {\n                        vals.push_back(val);\n                    }\n                }\n                \n                // Now check if we can form 'needed' from subset of vals\n                if (!canFormSum(needed, vals)) {\n                    canBeZero = false;\n                    break;\n                }\n            }\n            \n            if (canBeZero) {\n                return k;  // The first k that works is our answer\n            }\n        }\n        \n        // If none worked:\n        return -1;\n    }\n};\n","author":"ItsMe","submissionId":"1575115107"},[]]},{"49":[{"id":"49","fileName":"1575115272.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int ans = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int val = nums[i];\n            int rounds = 0;\n            boolean[] dp = new boolean[val + 1];\n            dp[val] = true;\n            for (int j = 0; j < queries.length && !dp[0]; j++) {\n                if (i >= queries[j][0] && i <= queries[j][1]) {\n                    int delta = queries[j][2];\n                    for (int k = delta; k <= val; k++) {\n                        if (dp[k]) dp[k - delta] = true;\n                    }\n                }\n                rounds++;\n            }\n            if (!dp[0]) return -1;\n            ans = Math.max(ans, rounds);\n        }\n        return ans;\n    }\n}","author":"sahasrad","submissionId":"1575115272"},[]]},{"50":[{"id":"50","fileName":"1575115903.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int res = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            int q = f(nums[i], i, queries);\n            // cout << q<< endl;\n            if (q == -1) return -1;\n            res = max(res, q);\n        }\n        return res;\n    }\n    \nprivate:\n    int f(int n, int i, vector<vector<int>>& queries) {\n        if (n == 0) return 0;\n        vector<bool> dp(n + 1);\n        dp[0] = true;\n        for (int j = 0; j < queries.size(); j++) {\n            auto& q = queries[j];\n            if (q[0] > i || q[1] < i) continue;\n            int v = q[2];\n            for (int t = n; t >= v; t--) {\n                dp[t] = dp[t] || dp[t - v];\n            }\n            if (dp[n]) return j + 1;\n        }\n        return -1;\n    }\n};","author":"raincoat911","submissionId":"1575115903"},[]]},{"51":[{"id":"51","fileName":"1575115173.txt","sourceCode":"#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define sz(s) (int)(s).size()\n#define all(s) s.begin(),s.end()\n\nvoid Speed() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n}\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = sz(a);\n        auto check = [&](int m) -> bool{\n            vector<vector<int>> v(n);\n            for(int i = 0; i < m; i++){\n                int l = q[i][0], r = q[i][1], x = q[i][2];\n                for(int j = l; j <= r; j++){\n                    v[j].push_back(x);\n                }\n            }\n            \n            for(int i = 0; i < n; i++){\n                vector<vector<int>> dp(1001, vector<int>(sz(v[i]), -1));\n                auto rec = [&](auto& self, int x, int j) -> int{\n                    if(x == 0) return 1;\n                    if(x < 0 || j == sz(v[i])) return 0;\n                    int& ret = dp[x][j];\n                    if(~ret) return ret;\n                    ret = self(self, x, j + 1);\n                    ret = max(ret, self(self, x - v[i][j], j + 1));\n                    return ret;\n                };\n                if(rec(rec, a[i], 0)) continue;\n                return 0;\n            }\n            return 1;\n        };\n\n\n        int start = 0, end = sz(q), mid, ans = -1;\n        while(start <= end){\n            mid = start + end >> 1;\n            if(check(mid)) ans = mid, end = mid - 1;\n            else start = mid + 1;\n        }\n        return ans;\n    }\n};","author":"Anas Maged","submissionId":"1575115173"},[]]},{"52":[{"id":"52","fileName":"1575116878.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if len(set(nums)) == 1 and nums[0] == 0:\n            return 0\n            \n        n = len(nums)\n        dp = [1 for _ in range(n)]\n        qsums = [(2 << nums[i]) - 1 for i in range(n)]\n\n        for k, (l, r, v) in enumerate(queries):\n            for i in range(l, r + 1):\n                dp[i] = dp[i] | ((dp[i] << v) & qsums[i])\n            if all(((dp[i] >> nums[i]) & 1) > 0 for i in range(n)):\n                return k + 1\n        return -1","author":"Siddh","submissionId":"1575116878"},[]]},{"53":[{"id":"53","fileName":"1575114875.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int m = queries.size();\n        int lo = 0, hi = m + 1;\n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (check(mid, nums, queries)) hi = mid;\n            else lo = mid + 1;\n        }\n        return lo <= m ? lo : -1;\n    }\n    bool check(int k, vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        for (int j = 0; j < n; j++) {\n            vector<int> vals;\n            for (int i = 0; i < k; i++) {\n                if (queries[i][0] <= j && j <= queries[i][1])\n                    vals.push_back(queries[i][2]);\n            }\n            if (!subset(vals, nums[j])) return false;\n        }\n        return true;\n    }\n    bool subset(vector<int>& vals, int t) {\n        vector<bool> taans2(t + 1, false);\n        taans2[0] = true;\n        for (int v : vals) {\n            for (int s = t - v; s >= 0; s--) {\n                if (taans2[s]) taans2[s + v] = true;\n            }\n        }\n        return taans2[t];\n    }\n};\n","author":"Tarun V","submissionId":"1575114875"},[]]},{"54":[{"id":"54","fileName":"1575116724.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        N = len(nums)\n        Q = len(queries)\n\n        def f(x, vs):\n            dp = [False] * (x + 1)\n            dp[0] = True\n            for v in vs:\n                for y in range(x, -1, -1):\n                    if y + v <= x:\n                        dp[y + v] |= dp[y]\n            return dp[x]\n\n        def check(nq):\n            vs = [[] for _ in range(N)]\n            for q in range(nq):\n                l, r, v = queries[q]\n                for j in range(l, r + 1):\n                    vs[j].append(v)\n\n            for i in range(N):\n                if not f(nums[i], vs[i]):\n                    return False\n\n            return True\n\n        if check(0):\n            return 0\n        if not check(Q):\n            return -1\n        lo, hi = 0, Q\n        while hi - lo > 1:\n            mid = (lo + hi) // 2\n            if check(mid):\n                hi = mid\n            else:\n                lo = mid\n        return hi\n","author":"HardCoreSWE","submissionId":"1575116724"},[]]},{"55":[{"id":"55","fileName":"1575117488.txt","sourceCode":"class Solution {\n    bool isdone(vector<vector<bool>> &dp) {\n        for(auto &d : dp) if(!d[0]) return false;\n        return true;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<bool>> dp(n, vector<bool>(1100));\n        for(int i=0;i<n;i++) dp[i][nums[i]] = true;\n        if(isdone(dp)) return 0;\n        \n        int k = 0;\n        for(const auto &q : queries) {\n            ++k;\n            for(int pos=q[0];pos<=q[1];++pos) {\n                auto ndp = dp[pos];\n                for(int t=nums[pos]-q[2];t>=0;t--) {\n                    ndp[t] = ndp[t] || dp[pos][t+q[2]];\n                }\n                dp[pos] = ndp;\n            }\n            if(isdone(dp)) return k;\n        }\n        return -1;\n    }\n};","author":"facelessvoid","submissionId":"1575117488"},[]]},{"56":[{"id":"56","fileName":"1575117309.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        auto ok = [&](int x) {\n            for (int i = 0; i < n; i++) {\n                bitset<1005> possible;\n                possible[0] = 1;\n                for (int j = 0; j < x; j++) {\n                    auto &q = queries[j];\n                    if (q[0] <= i && i <= q[1]) {\n                        possible = possible | possible << q[2];\n                    }\n                }\n                if (!possible[nums[i]]) return false;\n            }\n            return true;\n        };\n        int m = queries.size();\n        if (!ok(m)) return -1;\n\n        int l = 0, r = m;\n        while (l < r) {\n            int m = l + (r - l) / 2;\n            if (!ok(m)) l = m + 1;\n            else r = m;\n        }\n        return l;\n        \n    }\n};","author":"enip2473","submissionId":"1575117309"},[]]},{"57":[{"id":"57","fileName":"1575117358.txt","sourceCode":"#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define pb push_back\n//#define int long long\n#define sz(a) (int)a.size()\n#define all(a) begin(a),end(a)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nusing ll = long long;\nusing vi = vector<int>;\nusing ar2 = array<int,2>;\nusing ar3 = array<int,3>;\n\nconst int mxN = (int)2e5+10;\nconst int INF = (int)2e9;\nconst ll LINF = (ll)2e18;\nconst int MOD = (int)1e9+7;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int ans = 0;\n        int n = sz(a);\n        for(int i = 0; i < n; i++){\n            if(!a[i]) continue;\n            vi v; v.clear();\n            for(int j = 0; j < sz(q); j++)\n                if(q[j][0]<=i and i<=q[j][1])\n                    v.pb(j);\n            if(!sz(v)) return -1;\n            bool dp[1010], ok = 0;\n            memset(dp,0,sizeof(dp));\n            dp[0] = 1;\n            for(int j = 0; j < sz(v); j++){\n                int x = q[v[j]][2];\n                for(int k = a[i]; k>=x; k--) dp[k]|=dp[k-x];\n                if(dp[a[i]]){\n                    ans = max(ans, v[j]+1);ok = 1;\n                    break;\n                }\n            }\n            if(!ok) return -1;\n        }\n        return ans;\n    }\n};","author":"Daniel Emeka-Ilozor","submissionId":"1575117358"},[]]},{"58":[{"id":"58","fileName":"1575117730.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = 0;\n        for(int i = 0; i < nums.size(); i++) {\n            vector<int> minturn(1001, 1);\n            int doneat = -1;\n            int num = nums[i];\n            minturn[num] = 0;\n            if (num == 0) continue;\n            int qc = 0;\n            for(auto &q : queries) {\n                qc++;\n                // for(int i = 0; i < 30; i++) cout << minturn[i] << ' '; cout << endl;\n                int l = q[0], r = q[1], d = q[2];\n                if (l <= i && i <= r) {\n                    for(int i = d; i <= 1000; i++) {\n                        if (minturn[i] != 1) {\n                            minturn[i - d] = 0;\n                            if (i - d == 0) {\n                                doneat = qc;\n                                break;\n                            }\n                        }\n                    }\n                    if (doneat != -1) break;\n                }\n            }\n            // cout << i << ' ' << doneat << endl;\n            if (doneat == -1) return -1;\n            else {\n                ans = max(ans, doneat);\n            }\n        }\n        return ans;\n    }\n};","author":"Ian McKibben","submissionId":"1575117730"},[]]},{"59":[{"id":"59","fileName":"1575116876.txt","sourceCode":"//████████╗██╗███╗░░██╗  ██╗░░░░░███████╗\n//╚══██╔══╝██║████╗░██║  ██║░░░░░██╔════╝\n//░░░██║░░░██║██╔██╗██║  ██║░░░░░█████╗░░\n//░░░██║░░░██║██║╚████║  ██║░░░░░██╔══╝░░\n//░░░██║░░░██║██║░╚███║  ███████╗███████╗\n//░░░╚═╝░░░╚═╝╚═╝░░╚══╝  ╚══════╝╚══════╝\n//   __________________\n//  | ________________ |\n//  ||          ____  ||\n//  ||   /    |      ||\n//  ||  /__   |      ||\n//  || /      |____  ||\n//  ||________________||\n//  |__________________|\n//  ###################\n//   ###################\n//            ____       \n//     _________________\n// An AC a day keeps the doctor away.\n\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <iomanip>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <array>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\ntemplate<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n#define vt vector\n#define all(x) begin(x), end(x)\n#define allr(x) rbegin(x), rend(x)\n#define ub upper_bound\n#define lb lower_bound\n#define db double\n#define ld long db\n#define ll long long\n#define ull unsigned long long\n#define vll vt<ll>  \n#define vvll vt<vll>\n#define pll pair<ll, ll>    \n#define vpll vt<pll>\n#define vvpll vt<vpll>\n#define vc vt<char> \n#define vvc vt<vc>\n#define vi vt<int>\n#define vvi vt<vi>\n#define vvvi vt<vvi>\n#define pii pair<int, int>\n#define vpii vt<pii>\n#define vs vt<string>\n#define vvs vt<vs>\n#define vb vt<bool>\n#define vvb vt<vb>\n#define vvpii vt<vpii>\n#define vd vt<db>\n#define ar(x) array<int, x>\n#define var(x) vt<ar(x)>\n#define vvar(x) vt<var(x)>\n#define al(x) array<ll, x>\n#define vall(x) vt<al(x)>\n#define vvall(x) vt<vall(x)>\n#define mset(m, v) memset(m, v, sizeof(m))\n#define pb push_back\n#define ff first\n#define ss second\n#define sv string_view\n#define MP make_pair\n#define MT make_tuple\n#define rsz resize\n#define sum(x) (ll)accumulate(all(x), 0LL)\n#define srt(x) sort(all(x))\n#define srtR(x) sort(allr(x))\n#define srtU(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())\n#define SORTED(x) is_sorted(all(x))\n#define rev(x) reverse(all(x))\n#define MAX(a) *max_element(all(a)) \n#define MIN(a) *min_element(all(a))\n#define ROTATE(a, p) rotate(begin(a), begin(a) + p, end(a))\n#define i128 __int128\n\n//SGT DEFINE\n#define lc i * 2 + 1\n#define rc i * 2 + 2\n#define lp lc, left, middle\n#define rp rc, middle + 1, right\n#define entireTree 0, 0, n - 1\n#define midPoint left + (right - left) / 2\n#define pushDown push(i, left, right)\n#define iter int i, int left, int right\n\n#define IOS ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n\nstruct custom {\n    static const uint64_t C = 0x9e3779b97f4a7c15; const uint32_t RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();\n    size_t operator()(uint64_t x) const { return __builtin_bswap64((x ^ RANDOM) * C); }\n    size_t operator()(const std::string& s) const { size_t hash = std::hash<std::string>{}(s); return hash ^ RANDOM; } };\ntemplate <class K, class V> using umap = std::unordered_map<K, V, custom>; template <class K> using uset = std::unordered_set<K, custom>;\ntemplate<class T> using max_heap = priority_queue<T>;\ntemplate<class T> using min_heap = priority_queue<T, vector<T>, greater<T>>;\n    \n    \ntemplate <typename T1, typename T2>  istream &operator>>(istream& in, pair<T1, T2>& input) {    return in >> input.ff >> input.ss; }\n    \ntemplate <typename T> istream &operator>>(istream &in, vector<T> &v) { for (auto &el : v) in >> el; return in; }\n\ntemplate<class T>\nvoid output_vector(vt<T>& a, int off_set = 0) {\n    int n = a.size();\n    for(int i = off_set; i < n; i++) {\n        cout << a[i] << (i == n - 1 ? 'n' : ' ');\n    }\n}\n\ntemplate<typename T, typename Compare>\nvi closest_left(const vt<T>& a, Compare cmp) {\n    int n = a.size(); vi closest(n); iota(all(closest), 0);\n    for (int i = 0; i < n; i++) {\n        auto& j = closest[i];\n        while(j && cmp(a[i], a[j - 1])) j = closest[j - 1];\n    }\n    return closest;\n}\n\ntemplate<typename T, typename Compare> // auto right = closest_right<int>(a, std::less<int>());\nvi closest_right(const vt<T>& a, Compare cmp) {\n    int n = a.size(); vi closest(n); iota(all(closest), 0);\n    for (int i = n - 1; i >= 0; i--) {\n        auto& j = closest[i];\n        while(j < n - 1 && cmp(a[i], a[j + 1])) j = closest[j + 1];\n    }\n    return closest;\n}\n\ntemplate<typename T, typename V = string>\nvt<pair<T, int>> encode(const V& s) {\n    vt<pair<T, int>> seg;\n    for(auto& ch : s) {\n        if(seg.empty() || ch != seg.back().ff) seg.pb({ch, 1});\n        else seg.back().ss++;\n    }\n    return seg;\n}\n\n    \ntemplate<typename K, typename V>\nauto operator<<(std::ostream &o, const std::map<K, V> &m) -> std::ostream& {\n    o << \"{\"; int i = 0;\n    for (const auto &[key, value] : m) { if (i++) o << \" , \"; o << key << \" : \" << value; }\n    return o << \"}\";\n}\n\n#ifdef LOCAL\n#define debug(x...) debug_out(#x, x)\nvoid debug_out(const char* names) { std::cerr << std::endl; }\ntemplate <typename T, typename... Args>\nvoid debug_out(const char* names, T value, Args... args) {\n    const char* comma = strchr(names, ',');\n    std::cerr << \"[\" << (comma ? std::string(names, comma) : names) << \" = \" << value << \"]\";\n    if (sizeof...(args)) { std::cerr << \", \"; debug_out(comma + 1, args...); }   \n    else { std::cerr << std::endl; }\n}\ntemplate<typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& o, const std::pair<T1, T2>& p) { return o << \"{\" << p.ff << \" , \" << p.ss << \"}\"; }\nauto operator<<(auto &o, const auto &x) -> decltype(end(x), o) {\n    o << \"{\"; int i = 0; for (const auto &e : x) { if (i++) o << \" , \"; o << e; } return o << \"}\";\n} // remove for leetcode\n#include <sys/resource.h>\n#include <sys/time.h>\nvoid printMemoryUsage() {\n    struct rusage usage;\n    getrusage(RUSAGE_SELF, &usage);\n    double memoryMB = usage.ru_maxrss / 1024.0;\n    cerr << \"Memory usage: \" << memoryMB << \" MB\" << \"n\";\n}\n\n#define startClock clock_t tStart = clock();\n#define endClock std::cout << std::fixed << std::setprecision(10) << \"nTime Taken: \" << (double)(clock() - tStart) / CLOCKS_PER_SEC << \" seconds\" << std::endl;\n#else\n#define debug(...)\n#define startClock\n#define endClock\n\n#endif\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define eps 1e-9\n#define M_PI 3.14159265358979323846\nconst static string pi = \"3141592653589793238462643383279\";\nconst static ll INF = 1LL << 62;\nconst static int inf = 1e9 + 100;\nconst static int MK = 20;\nconst static int MX = 1e5 + 5;\nconst static int MOD = 1e9 + 7;\nll gcd(ll a, ll b) { while (b != 0) { ll temp = b; b = a % b; a = temp; } return a; }\nll lcm(ll a, ll b) { return (a / gcd(a, b)) * b; }\nint pct(ll x) { return __builtin_popcountll(x); }\nll have_bit(ll x, int b) { return x & (1LL << b); }\nint min_bit(ll x) { return __builtin_ctzll(x); }\nint max_bit(ll x) { return 63 - __builtin_clzll(x); } \nconst vvi dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {1, 1}, {-1, -1}, {1, -1}, {-1, 1}}; // UP, DOWN, LEFT, RIGHT\nconst vc dirChar = {'U', 'D', 'L', 'R'};\nint modExpo(ll base, ll exp, ll mod) { ll res = 1; base %= mod; while(exp) { if(exp & 1) res = (res * base) % mod; base = (base * base) % mod; exp >>= 1; } return res; }\nint modExpo_on_string(ll a, string exp, int mod) { ll b = 0; for(auto& ch : exp) b = (b * 10 + (ch - '0')) % (mod - 1); return modExpo(a, b, mod); }\nll sum_even_series(ll n) { return (n / 2) * (n / 2 + 1);} \nll sum_odd_series(ll n) {return n - sum_even_series(n);} // sum of first n odd number is n ^ 2\nll sum_of_square(ll n) { return n * (n + 1) * (2 * n + 1) / 6; } // sum of 1 + 2 * 2 + 3 * 3 + 4 * 4 + ... + n * n\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& Q) {\n        int n = a.size(); \n        vt<bitset<1001>> dp(n);\n        for(int i = 0; i < n; i++) {\n            dp[i].set(0);\n        }\n        auto check = [&]() -> bool {\n            for(int i = 0; i < n; i++) {\n                if(!dp[i].test(a[i])) return false;\n            }\n            return true;\n        };\n        if(check()) return 0;\n        int q = Q.size();\n        for(int i = 0; i < q; i++) {\n            int l = Q[i][0], r = Q[i][1], v = Q[i][2];\n            for(int i = l; i <= r; i++) {\n                dp[i] |= dp[i] << v;\n            }\n            if(check()) return i + 1;\n        }\n        return -1;\n    }\n};\n\n#ifdef LOCAL\nvoid solve() {\n}\n\nsigned main() {\n    // careful for overflow, check for long long, use unsigned long long for random generator\n    // when mle, look if problem require read in file, typically old problems\n    IOS;\n    startClock\n    //generatePrime();\n\n    int t = 1;\n    //cin >> t;\n    for(int i = 1; i <= t; i++) {   \n        //cout << \"Case #\" << i << \": \";  \n        solve();\n    }\n\n    endClock\n    #ifdef LOCAL\n      printMemoryUsage();\n    #endif\n\n    return 0;\n}\n#endif\n\n//███████████████████████████████████████████████████████████████████████████████████████████████████████\n//█░░░░░░░░░░░░░░█░░░░░░██████████░░░░░░█░░░░░░░░░░░░███░░░░░░░░░░█░░░░░░██████████░░░░░░█░░░░░░░░░░░░░░█\n//█░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀░░░░░░░░░░██░░▄▀░░█░░▄▀▄▀▄▀▄▀░░░░█░░▄▀▄▀▄▀░░█░░▄▀░░░░░░░░░░██░░▄▀░░█░░▄▀▄▀▄▀▄▀▄▀░░█\n//█░░▄▀░░░░░░░░░░█░░▄▀▄▀▄▀▄▀▄▀░░██░░▄▀░░█░░▄▀░░░░▄▀▄▀░░█░░░░▄▀░░░░█░░▄▀▄▀▄▀▄▀▄▀░░██░░▄▀░░█░░▄▀░░░░░░░░░░█\n//█░░▄▀░░█████████░░▄▀░░░░░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░███░░▄▀░░███░░▄▀░░░░░░▄▀░░██░░▄▀░░█░░▄▀░░█████████\n//█░░▄▀░░░░░░░░░░█░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░███░░▄▀░░███░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░█████████\n//█░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░███░░▄▀░░███░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░██░░░░░░█\n//█░░▄▀░░░░░░░░░░█░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░███░░▄▀░░███░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░█\n//█░░▄▀░░█████████░░▄▀░░██░░▄▀░░░░░░▄▀░░█░░▄▀░░██░░▄▀░░███░░▄▀░░███░░▄▀░░██░░▄▀░░░░░░▄▀░░█░░▄▀░░██░░▄▀░░█\n//█░░▄▀░░░░░░░░░░█░░▄▀░░██░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀░░░░▄▀▄▀░░█░░░░▄▀░░░░█░░▄▀░░██░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀░░░░░░▄▀░░█\n//█░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀░░██░░░░░░░░░░▄▀░░█░░▄▀▄▀▄▀▄▀░░░░█░░▄▀▄▀▄▀░░█░░▄▀░░██░░░░░░░░░░▄▀░░█░░▄▀▄▀▄▀▄▀▄▀░░█\n//█░░░░░░░░░░░░░░█░░░░░░██████████░░░░░░█░░░░░░░░░░░░███░░░░░░░░░░█░░░░░░██████████░░░░░░█░░░░░░░░░░░░░░█\n//███████████████████████████████████████████████████████████████████████████████████████████████████████\n","author":"tin_le","submissionId":"1575116876"},[]]},{"60":[{"id":"60","fileName":"1575117969.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, n) for (lli i = (a); i < (n); ++i)\n#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define sz(a) ((int)a.size())\n#define YES cout << \"YES\" << endl;\n#define NO cout << \"NO\" << endl;\n// #define endl 'n'\n#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);\n#define pb push_back\n#define pp pop_back()\n#define fi first\n#define si second\n#define v(a) vector<int>(a)\n#define vv(a) vector<vector<int>>(a)\n#define present(c, x) ((c).find(x) != (c).end())\n#define set_bits __builtin_popcountll\n#define MOD 1000000007\n// #define int long long\n\ntypedef long long lli;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<lli, lli> pll;\ntypedef pair<int, int> pii;\ntypedef unordered_map<int, int> umpi;\ntypedef map<int, int> mpi;\ntypedef vector<pii> vp;\ntypedef vector<lli> vll;\ntypedef vector<vll> vvll;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = sz(nums);\n        bool ff = true;\n        for (int v : nums) {\n            if(v != 0) {\n                ff = false;\n                break;\n            }\n        }\n        if(ff) return 0;\n        vector<bitset<1001>> dp(n);\n        for (int j = 0; j < n; j++) {\n            dp[j].reset();\n            dp[j].set(0, true);\n        }\n        \n        int m = sz(queries);\n        loop(i,0,m) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for (int j = l; j <= r; j++)  dp[j] |= (dp[j] << val);\n            bool check = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j].test(nums[j])) {\n                    check = false;\n                    break;\n                }\n            }\n            if (check) return i + 1;\n        }\n        return -1;\n    }\n};\n\n","author":"Aaryan Saraswat","submissionId":"1575117969"},[]]},{"61":[{"id":"61","fileName":"1575117532.txt","sourceCode":"\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<bitset<1001>> dp(n);\n        for (int i = 0; i < n; i++) {\n            dp[i].reset();\n            dp[i].set(0);\n        }\n        auto valid = [&]() -> bool {\n            for (int i = 0; i < n; i++)\n                if (!dp[i].test(nums[i]))\n                    return false;\n            return true;\n        };\n        if (valid()) return 0;\n        for (int j = 0; j < m; j++) {\n            int l = queries[j][0], r = queries[j][1], v = queries[j][2];\n            for (int i = l; i <= r; i++) {\n                dp[i] |= (dp[i] << v);\n            }\n            if (valid()) return j + 1;\n        }\n        return -1;\n    }\n};\n","author":"Divyansh Deshmukh","submissionId":"1575117532"},[{"id":"550","similarity":0.87248322147651,"totOverlap":130,"longestOverlap":26}]],"550":[{"id":"550","fileName":"1575175070.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        int MAX_SUM = 1000;\n\n        vector<bitset<1001>> dp(n);\n        for (int i = 0; i < n; i++) {\n            dp[i].reset();\n            dp[i].set(0, true);\n        }\n        auto checkZero = [&]() -> bool {\n            for (int i = 0; i < n; i++) {\n                if (!dp[i].test(nums[i]))\n                    return false;\n            }\n            return true;\n        };\n        if (checkZero())\n            return 0;\n        \n        for (int k = 0; k < m; k++) {\n            int l = queries[k][0], r = queries[k][1], val = queries[k][2];\n            for (int i = l; i <= r; i++) {\n                dp[i] |= (dp[i] << val);\n            }\n            if (checkZero())\n                return k + 1;\n        }\n        return -1;\n    }\n};","author":"coder1227","submissionId":"1575175070"},[{"id":"61","similarity":0.87248322147651,"totOverlap":130,"longestOverlap":26}]]},{"62":[{"id":"62","fileName":"1575117844.txt","sourceCode":"# not all in range have to be used\n\"\"\"\nval ranges from 1 to 10, does this mean only the 10 highest values need to be considered?\n\"\"\"\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        ans = 0\n        for i in range(n):\n            if nums[i] != 0:\n                vals = [0]\n                t = nums[i]\n                flag = True\n                for j in range(m):\n                    if queries[j][0] <= i <= queries[j][1]:\n                        nvals = {}\n                        for v in vals:\n                            nvals[v] = 1\n                            nvals[v+queries[j][2]] = 1\n                        vals = list(nvals.keys())\n                        vals.sort()\n                        while vals[-1] > t:\n                            vals.pop()\n                        vals = vals[-10:]\n                        if vals[-1] == t:\n                            ans = max(ans,j+1)\n                            flag = False\n                            break\n                if flag: return -1\n        return ans","author":"Alexander Wen","submissionId":"1575117844"},[]]},{"63":[{"id":"63","fileName":"1575118472.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        if (*max_element(nums.begin(), nums.end())==0) return 0;\n        vector<bitset<1001>> c(n, bitset<1001>());\n        for (int i = 0; i < n; i++){\n            c[i][nums[i]] = 1;\n        }\n        auto check = [&] () -> bool{\n            for (int i = 0; i < n; i++){\n                if (c[i][0]==0) return false;\n            }\n            return true;\n        };\n        for (int i = 0; i < queries.size(); i++){\n            for (int j = queries[i][0]; j <= queries[i][1]; j++){\n                c[j] |= (c[j] >> queries[i][2]);\n            }\n            if (check()) return i + 1;\n        }\n        return -1;\n    }\n};","author":"jacobj2","submissionId":"1575118472"},[]]},{"64":[{"id":"64","fileName":"1575118839.txt","sourceCode":"class Solution {\npublic:\n  int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    const int n = nums.size();\n    int r = n - count(nums.begin(), nums.end(), 0);\n    if (r == 0) {\n      return 0;\n    }\n\n    vector<bitset<1001>> dp(n, bitset<1001>(1));\n    for (int k = 0; k < (int)queries.size(); ++k) {\n      const int from = queries[k][0], to = queries[k][1], val = queries[k][2];\n      for (int i = from; i <= to; ++i) {\n        if (dp[i][nums[i]]) {\n          continue;\n        }\n        dp[i] |= dp[i] << val;\n        if (dp[i][nums[i]]) {\n          --r;\n        }\n      }\n      if (r == 0) {\n        return k + 1;\n      }\n    }\n    return -1;\n  }\n};","author":"Zejun Wu","submissionId":"1575118839"},[]]},{"65":[{"id":"65","fileName":"1575118437.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int cnt = 0;\n        for(int x: nums) cnt += (x == 0);\n        if (cnt == n) return 0;\n        vector<vector<int>> dp(n, vector<int>(1001, 0));\n        for(int i = 0; i < n; i++) dp[i][nums[i]] = true;\n        for(int k = 0; k < queries.size(); k++) {\n            auto& q = queries[k];\n            int val = q[2];\n            for(int i = q[0]; i <= q[1]; i++) {\n                for(int j = val; j <= 1000; j++) {\n                    dp[i][j - val] |= dp[i][j];\n                }\n            }\n            cnt = 0;\n            for(int i = 0; i < n; i++) {\n                cnt += dp[i][0];\n            }\n            if (cnt == n) return k + 1;\n        }\n        return -1;\n    }\n};","author":"Yucheng Dai","submissionId":"1575118437"},[]]},{"66":[{"id":"66","fileName":"1575116938.txt","sourceCode":"class Solution {\npublic:\n    bool subsetSum(vector<int>& nums, int target) \n    {\n        int n = nums.size();\n        vector<bool> dp(target + 1, false);\n        dp[0] = true;  \n\n        for (int num : nums) \n        {\n            for (int j = target; j >= num; j--) \n            {  \n                dp[j] = dp[j] || dp[j - num];\n            }\n        }\n    \n        return dp[target];\n    }\n\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) \n    {\n        int n = nums.size();\n        int l = 0;\n        int r = queries.size();\n        int ans = -1;\n\n        while(l<=r)\n            {\n                int mid = l + (r - l)/2;\n\n                vector<vector<int>>lineSweep(n+1);\n\n                for(int i = 0; i<mid; i++)\n                    {\n                        auto&q = queries[i];\n                        int l = q[0], r = q[1], val = q[2];\n\n                        for(int j = l; j<=r; j++)\n                            {\n                                lineSweep[j].push_back(val);\n                            }\n                    }\n\n                bool cond = true;\n                for(int i = 0; i<n; i++)\n                    {\n                        vector<int>v = lineSweep[i];\n                        int sum = nums[i];\n                        if(!subsetSum(v,sum))\n                        {\n                            cond = false;\n                            break;\n                        }\n                    }\n\n                if(cond)\n                {\n                    r = mid - 1;\n                    ans = mid;\n                }\n                else l = mid+1;\n            }\n\n        return ans;\n        \n    }\n};","author":"Rohan Trivedi","submissionId":"1575116938"},[]]},{"67":[{"id":"67","fileName":"1575118985.txt","sourceCode":"#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define sz(a) (int)(a).size()\n#define all(a) begin(a),end(a)\ntypedef vector<int> vi;\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=sz(nums);\n        vector<int>f(n,1e9);\n        rep(i,0,n)if(!nums[i])f[i]=0;\n        vector<bitset<1001>>b(n);\n        rep(i,0,n)b[i][nums[i]]=1;\n        rep(q,0,sz(queries)){\n            auto v=queries[q];\n            rep(i,v[0],v[1]+1){\n                b[i]|=b[i]>>v[2];\n                if(b[i][0]&&f[i]>1e8)f[i]=q+1;\n            }\n        }\n        int res=*max_element(all(f));\n        if(res>1e8)res=-1;\n        return res;\n    }\n};","author":"TKTYI","submissionId":"1575118985"},[]]},{"68":[{"id":"68","fileName":"1575119375.txt","sourceCode":"class Solution:    \n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        \n        if all(x == 0 for x in nums):\n            return 0\n        \n        for k in range(1, m + 1):\n            feasible = True\n            for j in range(n):\n                available = []\n                for i in range(k):\n                    li, ri, vali = queries[i]\n                    if li <= j <= ri:\n                        available.append(vali)\n                \n                target = nums[j]\n                \n                dp = [False] * (target + 1)\n                dp[0] = True\n                for v in available:\n                    for s in range(target, v - 1, -1):\n                        if dp[s - v]:\n                            dp[s] = True\n                    if dp[target]:\n                        break\n                \n                if not dp[target]:\n                    feasible = False\n                    break\n            \n            if feasible:\n                return k\n        \n        return -1","author":"Mohak Acharya","submissionId":"1575119375"},[]]},{"69":[{"id":"69","fileName":"1575120213.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        int[] arr = Arrays.copyOf(nums, n);\n        int l = 0, h = m + 1; \n        while (l < h) {\n            int md = l + (h - l) / 2;\n            if (canZero(md, arr, queries)) {\n                h = md;\n            } else {\n                l = md + 1;\n            }\n        }\n        return (l <= m) ? l : -1;\n    }\n\n     public boolean canZero(int k, int[] nums, int[][] queries) {\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            int t = nums[i];\n            List<Integer> arr = new ArrayList<>();\n            for (int j = 0; j < k; j++) {\n                if (queries[j][0] <= i && i <= queries[j][1]) {\n                    arr.add(queries[j][2]);\n                }\n            }\n            if (t == 0) {\n                continue;\n            }\n            if (!subsetSum(arr, t)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private boolean subsetSum(List<Integer> arr, int t) {\n        boolean[] dp = new boolean[t + 1];\n        dp[0] = true;\n        for (int v : arr) {\n            for (int s = t; s >= v; s--) {\n                if (dp[s - v]) {\n                    dp[s] = true;\n                }\n            }\n        }\n        return dp[t];\n    }\n}","author":"MONISH REDDY","submissionId":"1575120213"},[]]},{"70":[{"id":"70","fileName":"1575118892.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        boolean[][] dp = new boolean[n][];\n        for(int i = 0; i < n; i++){\n            int target = nums[i];\n            dp[i] = new boolean[target + 1];\n            dp[i][0] = true;\n        }\n        boolean isZero = true;\n        for(int num : nums){\n            if(num != 0){\n                isZero = false;\n                break;\n            }\n        }\n        if(isZero) return 0;\n        for(int k = 0; k < queries.length; k++){\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int val = queries[k][2];\n            \n            for(int i = l; i <= r; i++){\n                if(nums[i] == 0) continue;\n                for(int s = dp[i].length - 1; s >= val; s--){\n                    if(!dp[i][s] && dp[i][s - val]) dp[i][s] = true;\n                }\n            }\n            boolean isSatisfied = true;\n            for(int i = 0; i < n; i++){\n                if(!dp[i][nums[i]]){\n                    isSatisfied = false;\n                    break;\n                }\n            }\n            if(isSatisfied){\n                return k + 1;\n            }\n        }\n        return -1;\n    }\n}","author":"Md Yusuf","submissionId":"1575118892"},[]]},{"71":[{"id":"71","fileName":"1575119809.txt","sourceCode":"#define lli long long\nclass Solution {\npublic:\n    lli fuc(lli i,lli j,lli ind,vector<vector<lli>>&dp,vector<vector<int>>& queries){\n        lli n=queries.size();\n        if(i==n){\n            if(j==0){\n                return n;\n            }\n            return 1e18;\n        }\n        if(dp[i][j]!=-1){\n            return dp[i][j];\n        }\n        if(j==0){\n            return dp[i][j]=i;\n        }\n        lli ans=fuc(i+1,j,ind,dp,queries);\n        if(ind>=queries[i][0]&&ind<=queries[i][1]&&j>=queries[i][2]){\n            ans=min(ans,fuc(i+1,j-queries[i][2],ind,dp,queries));\n        }\n        return dp[i][j]=ans;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        int ans=0;\n        for(int i=0;i<nums.size();i++){\n            vector<vector<lli>>dp(queries.size(),vector<lli>(nums[i]+1,-1));\n            lli t=fuc(0,nums[i],i,dp,queries);\n            if(t>queries.size()){\n                return -1;\n            }\n            ans=max(ans,(int)(t));\n        }\n        return ans;\n    }\n};","author":"Fookin_Blinders","submissionId":"1575119809"},[]]},{"72":[{"id":"72","fileName":"1575118426.txt","sourceCode":"class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, m = len(nums), len(queries)\n\n        if all(x == 0 for x in nums):\n            return 0\n\n        maxs = 1100  \n        dp = [set() for i in range(n)]\n\n        for j in range(n):\n            dp[j].add(0)\n\n        for k, (l, r, val) in enumerate(queries):\n            for j in range(l, r + 1):\n                nsum = {s + val for s in dp[j] if s + val < maxs}\n                dp[j].update(nsum)\n\n            if all(nums[j] in dp[j] for j in range(n)):\n                return k + 1\n\n        return -1\n","author":"invisible","submissionId":"1575118426"},[]]},{"73":[{"id":"73","fileName":"1575120518.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def solve(target, vals):\n            if target == 0:\n                return 0\n            store = {-target}\n            for i, x in vals:\n                store1 = list(store)\n                for y in store1:\n                    store.add(x + y)\n                if 0 in store:\n                    return i + 1\n            return inf\n        mapping = [[] for _ in nums]\n        for i, (l, r, val) in enumerate(queries):\n            for j in range(l, r+1):\n                mapping[j].append((i, val))\n        ans = 0\n        for num, vals in zip(nums, mapping):\n            ans = max(ans, solve(num, vals))\n        if ans == inf:\n            return -1\n        else:\n            return ans","author":"Haoyu Weng","submissionId":"1575120518"},[]]},{"74":[{"id":"74","fileName":"1575120373.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int v = *max_element(nums.begin(), nums.end());\n        vector<vector<bool>> dp(n, vector<bool>(v+1, 0));\n        int re = 0;\n        \n        bool ok = 1;\n        for(int i : nums) if(i != 0) ok = 0;\n        if(ok) return 0;\n        \n        for(int i = 0; i < n; i++) dp[i][0] = 1;\n        for(int i = 0; i < queries.size(); i++){\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            \n            for(int i = l; i<= r; i++){\n                for(int j = v; j >= val; j--) \n                    dp[i][j] = dp[i][j] || dp[i][j - val];\n            }\n            \n            bool ok = 1;\n            for(int i = 0; i < n; i++){\n                if(!dp[i][nums[i]]) ok = 0;\n            }\n            if(ok) return i+1;\n        }\n        \n        return -1;\n        \n    }\n};","author":"lukewu28","submissionId":"1575120373"},[]]},{"75":[{"id":"75","fileName":"1575119625.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int l = 0;\n        int r = queries.length;\n        int n = nums.length;\n        while (l < r) {\n            int mid = (l + r) / 2;\n            int[][] freq = new int[n][11];\n            for (int i = 0; i < mid; i++) {\n                for (int j = queries[i][0]; j <= queries[i][1]; j++) {\n                    freq[j][queries[i][2]]++;\n                }\n            }\n            boolean good = true;\n            for (int i = 0; i < n; i++) {\n                boolean[] dp = new boolean[nums[i] + 1];\n                dp[0] = true;\n                ArrayList<Integer> temp = new ArrayList<>();\n                for (int j = 0; j < 11; j++) {\n                    for (int a = 0; a < freq[i][j]; a++) temp.add(j);\n                }\n                for (int j = 0; j < temp.size(); j++) {\n                    for (int k = nums[i]; k >= 0; k--) {\n                        if (dp[k] && k + temp.get(j) <= nums[i]) dp[k + temp.get(j)] = true;\n                    }\n                }\n                good &= dp[nums[i]];\n            }\n            if (good) {\n                r = mid;\n            }\n            else {\n                l = mid + 1;\n            }\n        }\n        int mid = l;\n        int[][] freq = new int[n][11];\n            for (int i = 0; i < mid; i++) {\n                for (int j = queries[i][0]; j <= queries[i][1]; j++) {\n                    freq[j][queries[i][2]]++;\n                }\n            }\n            boolean good = true;\n            for (int i = 0; i < n; i++) {\n                boolean[] dp = new boolean[nums[i] + 1];\n                dp[0] = true;\n                ArrayList<Integer> temp = new ArrayList<>();\n                for (int j = 0; j < 11; j++) {\n                    for (int a = 0; a < freq[i][j]; a++) temp.add(j);\n                }\n                for (int j = 0; j < temp.size(); j++) {\n                    for (int k = nums[i]; k >= 0; k--) {\n                        if (dp[k] && k + temp.get(j) <= nums[i]) dp[k + temp.get(j)] = true;\n                    }\n                }\n                good &= dp[nums[i]];\n            }\n        if (!good) return -1;\n        return l;\n    }\n}","author":"Victor Liu","submissionId":"1575119625"},[]]},{"76":[{"id":"76","fileName":"1575121591.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        curr = [set([0]) for _ in nums]\n        if all([v==0 for v in nums]):\n            return 0\n        for i, [l,r,v] in enumerate(queries):\n            for j in range(l,r+1):\n                old_set = curr[j]\n                new_set = old_set.copy()\n                # print(old_set, new_set, v)\n                for vv in old_set:\n                    # print(vv, v)\n                    if v+vv <= nums[j]:\n                        new_set.add(v+vv)\n                curr[j] = new_set\n            if all([v in s for v,s in zip(nums, curr)]):\n                return i+1\n        return -1","author":"peichaoD","submissionId":"1575121591"},[]]},{"77":[{"id":"77","fileName":"1575121356.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        ans = -1\n        for i in range(n):\n            if nums[i] == 0:\n                ans = max(ans, 0)\n                continue\n            x = 1 << nums[i]\n            for j,q in enumerate(queries):\n                if q[0] <= i <= q[1]:\n                    x |= (x >> q[2])\n                if x & 1 == 1:\n                    ans = max(ans, j+1)\n                    break\n            if x & 1 == 0:\n                ans = -1\n                break\n        return ans","author":"xlx2","submissionId":"1575121356"},[]]},{"78":[{"id":"78","fileName":"1575121618.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(queries)\n        l, r = 0, n + 1\n        def ok(k):\n            for i, v in enumerate(nums):\n                s = {0}\n                for l, r, vv in queries[:k]:\n                    if l <= i <= r:\n                        s |= {x + vv for x in s if x + vv <= v}\n                        if v in s: break\n                if v not in s: return False\n            return True\n        while l < r:\n            m = (l + r) // 2\n            if ok(m): r = m\n            else: l = m + 1\n        return l if l <= n else -1","author":"LTHW","submissionId":"1575121618"},[]]},{"79":[{"id":"79","fileName":"1575120281.txt","sourceCode":"\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int a = nums.size();\n        bool b = true;\n        for (int c : nums) {\n            if (c != 0) { b = false; break; }\n        }\n        if (b) return 0;\n        int d = queries.size();\n        int e = 0, f = d + 1;\n        while (e < f) {\n            int g = e + (f - e) / 2;\n            vector<int> h = nums;\n            bool i = true;\n            for (int j = 0; j < a; j++) {\n                vector<int> k;\n                for (int l = 0; l < g; l++) {\n                    int m = queries[l][0], n = queries[l][1], o = queries[l][2];\n                    if (m <= j && j <= n)\n                        k.push_back(o);\n                }\n                int p = h[j];\n                bitset<1100> q;\n                q.reset();\n                q[0] = 1;\n                for (int r : k)\n                    q |= (q << r);\n                if (!q[p]) {\n                    i = false;\n                    break;\n                }\n            }\n            if (i)\n                f = g;\n            else\n                e = g + 1;\n        }\n        return (e <= d ? e : -1);\n    }\n};\n","author":"adarsh","submissionId":"1575120281"},[]]},{"80":[{"id":"80","fileName":"1575121922.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n\n        bool alreadyZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                alreadyZero = false;\n                break;\n            }\n        }\n        if (alreadyZero)\n            return 0;\n\n        int low = 1, high = m, ans = -1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (feasible(nums, queries, mid)) {\n                ans = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    bool feasible(const vector<int>& nums, const vector<vector<int>>& queries,\n                  int k) {\n        int n = nums.size();\n\n        for (int j = 0; j < n; j++) {\n            int target = nums[j];\n\n            bitset<1001> dp;\n            dp.reset();\n            dp[0] = 1;\n\n            for (int i = 0; i < k; i++) {\n                int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n                if (l <= j && j <= r) {\n\n                    dp |= (dp << v);\n                }\n            }\n            if (!dp[target])\n                return false;\n        }\n        return true;\n    }\n};","author":"diyashah2904","submissionId":"1575121922"},[{"id":"147","similarity":0.995049504950495,"totOverlap":201,"longestOverlap":87}]],"147":[{"id":"147","fileName":"1575133541.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int m = q.size();\n        int n = a.size();\n        bool zero = true;\n        \n        for (int x : a) {\n            if (x != 0) { \n                zero = false; \n                break; \n            }\n        }\n        if (zero) return 0;\n\n        int lo = 1, hi = m, res = -1;\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (canMakeZero(a, q, mid)) {\n                res = mid;\n                hi = mid - 1;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        return res;\n    }\n\nprivate:\n    bool canMakeZero(const vector<int>& a, const vector<vector<int>>& q, int k) {\n        int n = a.size();\n        for (int j = 0; j < n; j++) {\n            int tgt = a[j];\n            bitset<1001> dp;\n            dp.reset();\n            dp[0] = 1;\n            \n            for (int i = 0; i < k; i++) {\n                int l = q[i][0], r = q[i][1], v = q[i][2];\n                if (l <= j && j <= r) {\n                    dp |= (dp << v);\n                }\n            }\n            if (!dp[tgt]) return false;\n        }\n        return true;\n    }\n};\n","author":"uJMQbJwlnP","submissionId":"1575133541"},[{"id":"80","similarity":0.995049504950495,"totOverlap":201,"longestOverlap":87}]]},{"81":[{"id":"81","fileName":"1575120068.txt","sourceCode":"#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> q(n);\n\n        for (int j = 0; j < queries.size(); ++j) {\n            for (int i = queries[j][0]; i <= queries[j][1]; ++i) {\n                q[i].push_back(j);\n            }\n        }\n\n        vector<int> result(n, -1);\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == 0) continue;\n\n            vector<int>& curr_queries = q[i];\n            if (curr_queries.empty()) return -1;\n\n            int total = 0;\n            for (int j : curr_queries) total += queries[j][2];\n            if (total < nums[i]) return -1;\n\n            unordered_map<int, int> dp;\n            dp[0] = -1;\n            bool found = false;\n            int earliest = INT_MAX;\n\n            for (int pos = 0; pos < curr_queries.size(); ++pos) {\n                int j = curr_queries[pos];\n                int value = queries[j][2];\n                unordered_map<int, int> new_dp = dp;\n\n                for (auto& entry : dp) {\n                    int sum = entry.first;\n                    int new_sum = sum + value;\n                    if (new_sum == nums[i]) {\n                        earliest = min(earliest, j);\n                        found = true;\n                    }\n                    if (new_sum <= nums[i] && new_dp.find(new_sum) == new_dp.end()) {\n                        new_dp[new_sum] = j;\n                    }\n                }\n                dp = new_dp;\n                if (found) break;\n            }\n\n            if (found) result[i] = earliest;\n            else if (dp.find(nums[i]) != dp.end()) result[i] = dp[nums[i]];\n            else return -1;\n        }\n\n        vector<int> ks;\n        for (int i = 0; i < n; ++i) {\n            if (result[i] != -1) ks.push_back(result[i] + 1);\n        }\n        return ks.empty() ? 0 : *max_element(ks.begin(), ks.end());\n    }\n};\n","author":"Ayush Shahi","submissionId":"1575120068"},[]]},{"82":[{"id":"82","fileName":"1575122091.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        dp = {}\n        res = []\n        need = len(nums)\n        for i, num in enumerate(nums):\n            if num == 0:\n                res.append(True)\n                need -= 1\n            else:\n                res.append(False)\n                dp[i] = set([0])\n\n        if need == 0:\n            return 0\n\n        for idx in range(len(queries)):\n            l, r, val = queries[idx]\n            for i in range(l, r + 1):\n                if not res[i]:\n                    \n                    ncands = set()\n                    for cand in dp[i]:\n                        if cand + val == nums[i]:\n                            res[i] = True\n                            need -= 1\n                            break\n                        if cand + val < nums[i]:\n                            ncands.add(cand + val)\n\n                    dp[i] |= ncands\n\n            if need == 0:\n                return idx + 1\n        return -1\n                    ","author":"Shuqi Shang","submissionId":"1575122091"},[]]},{"83":[{"id":"83","fileName":"1575123055.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if all(x==0 for x in nums):\n            return 0\n        n=len(nums)\n        ps=[1]*n\n        for k,(l,r,val) in enumerate(queries,1):\n            for i in range(l,r+1):\n                ps[i]|=(ps[i]<<val)\n            if all(((ps[i]>>nums[i])&1)==1 for i in range(n)):\n                return k\n        return -1","author":"jacksonc","submissionId":"1575123055"},[]]},{"84":[{"id":"84","fileName":"1575123185.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        \n        if all(x == 0 for x in nums):\n            return 0\n            \n        dp = [1] * n\n        target = nums[:]\n        for k, (l, r, val) in enumerate(queries):\n            \n            for i in range(l, r + 1):\n                dp[i] |= dp[i] << val\n                dp[i] &= (1 << (target[i] + 1)) - 1\n            if all((dp[i] >> target[i]) & 1 for i in range(n)):\n                return k + 1\n        return -1","author":"Cryptic-Technomage","submissionId":"1575123185"},[]]},{"85":[{"id":"85","fileName":"1575122734.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& qry) {\n        int n = nums.size(), m = qry.size();\n        bool ok = true;\n        for (int i = 0; i < n; i++) { if(nums[i] != 0){ ok = false; break; } }\n        if(ok) return 0;\n        int lo = 0, hi = m + 1;\n        while(lo < hi) {\n            int mid = (lo + hi) / 2;\n            if(check(nums, qry, mid)) hi = mid; else lo = mid + 1;\n        }\n        return (lo > m ? -1 : lo);\n    }\nprivate:\n    bool check(const vector<int>& nums, const vector<vector<int>>& qry, int k) {\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            vector<int> arr;\n            for (int j = 0; j < k; j++) {\n                int l = qry[j][0], r = qry[j][1], v = qry[j][2];\n                if(l <= i && i <= r) arr.push_back(v);\n            }\n            if(!sub(nums[i], arr)) return false;\n        }\n        return true;\n    }\n    bool sub(int tar, const vector<int>& arr) {\n        vector<bool> dp(tar + 1, false);\n        dp[0] = true;\n        for (int v : arr) {\n            for (int s = tar; s >= v; s--) {\n                if(dp[s - v]) dp[s] = true;\n            }\n        }\n        return dp[tar];\n    }\n};\n","author":"Ekambareswar","submissionId":"1575122734"},[]]},{"86":[{"id":"86","fileName":"1575123465.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        res = 0\n        for i, num in enumerate(nums):\n            if num == 0:\n                continue\n            dp, mask = 1, (1<<num+1) - 1\n            for k, (l, r, val) in enumerate(queries):\n                if l <= i <= r:\n                    dp |= dp << val\n                    dp &= mask\n                    if dp & (1<<num):\n                        res = max(res, k+1)\n                        break\n            else:\n                return -1\n        return res","author":"zsq007","submissionId":"1575123465"},[]]},{"87":[{"id":"87","fileName":"1575123744.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def get_min_k(num_index):\n            infinity = len(queries) + 1\n\n            @cache\n            def dp(value, i):\n                if value == 0:\n                    return i\n\n                if i == len(queries):\n                    return infinity\n\n                result = dp(value, i + 1)\n                l, r, val = queries[i]\n                if l <= num_index <= r and val <= value:\n                    result = min(result, dp(value - val, i + 1))\n                \n                return result\n\n            min_k = dp(nums[num_index], 0)\n            return min_k if min_k != infinity else -1\n\n        max_index = 0\n\n        for i in range(len(nums)):\n            min_index = get_min_k(i)\n            if min_index == -1:\n                return -1\n            max_index = max(max_index, min_index)\n\n        return max_index","author":"Ivan Vasilenko","submissionId":"1575123744"},[]]},{"88":[{"id":"88","fileName":"1575123794.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        const int n = nums.size();\n        const int q = queries.size();\n        if (*max_element(nums.begin(), nums.end()) == 0) return 0;\n        vector<vector<bool>> v(n);\n        for (int i = 0; i < n; ++i) {\n            v[i].resize(nums[i] + 1);\n            v[i][0] = true;\n        }\n        for (int i = 0; i < q; ++i) {\n            for (int j = queries[i][0]; j <= queries[i][1]; ++j) {\n                for (int k = nums[j]; k >= queries[i][2]; --k) {\n                    v[j][k] = (v[j][k] || v[j][k - queries[i][2]]);\n                }\n            }\n            bool ok = true;\n            for (int i = 0; i < n; ++i) {\n                if (!v[i][nums[i]]) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) return i + 1;\n        }\n        return -1;\n    }\n};","author":"JeffreyLC","submissionId":"1575123794"},[]]},{"89":[{"id":"89","fileName":"1575124149.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if all([num == 0 for num in nums]):\n            return 0\n        if not self.works(nums, queries, len(queries)):\n            return -1\n        low_guess = 1\n        high_guess = len(queries)\n        while low_guess < high_guess:\n            mid_guess = (low_guess + high_guess) // 2\n            if self.works(nums, queries, mid_guess):\n                high_guess = mid_guess\n            else:\n                low_guess = mid_guess + 1\n        return low_guess\n\n    def works(self, nums, queries, guess):\n        #print(\"\")\n        #print(\"procing guess {}\".format(guess))\n        n = len(nums)\n        counts = [\n            [\n                0 for j in range(0, 11)\n            ] for i in range(0, n)\n        ]\n        for k in range(0, guess):\n            l, r, v = queries[k]\n            for i in range(l, r+1):\n                counts[i][v] += 1\n        #for row in counts:\n        #    print(row)\n        for i in range(0, n):\n            reached = [False] * (nums[i] + 1)\n            reached[0] = True\n            for v in range(0, 11):\n                for c in range(0, counts[i][v]):\n                    for j in range(nums[i], -1, -1):\n                        if reached[j] and j + v <= nums[i]:\n                            reached[j+v] = True\n            #print(reached)\n            if not reached[-1]:\n                return False\n        return True\n            ","author":"swrush98","submissionId":"1575124149"},[]]},{"90":[{"id":"90","fileName":"1575124717.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        c = [[] for _ in range(n)]\n        for j, (l, r, v) in enumerate(queries):\n            for i in range(l, r + 1):\n                c[i].append((j, v))\n        r = [0] * n\n        for i in range(n):\n            if nums[i] == 0:\n                r[i] = 0\n                continue\n            cc = sorted(c[i], key=lambda x: x[0])\n            target = nums[i]\n            dp = [False] * (target + 1)\n            dp[0] = True\n            found = None\n            for (j, v) in cc:\n                new_dp = dp[:]\n                for s in range(target - v, -1, -1):\n                    if dp[s]:\n                        new_dp[s + v] = True\n                dp = new_dp\n                if dp[target]:\n                    found = j + 1\n                    break\n            if not dp[target]:\n                return -1\n            r[i] = found\n        return max(r)","author":"ceaxyz002","submissionId":"1575124717"},[]]},{"91":[{"id":"91","fileName":"1575124514.txt","sourceCode":"#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <set>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cassert>\n#include <string>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i = a; i < b; i++)\n#define S(x) scanf(\"%d\",&x)\n#define S2(x,y) scanf(\"%d%d\",&x,&y)\n#define P(x) printf(\"%dn\",x)\n#define all(v) v.begin(),v.end()\n#define FF first\n#define SS second\n#define pb push_back\n#define mp make_pair\n\ntypedef long long int LL;\ntypedef pair<int, int > pii;\ntypedef vector<int > vi;\n\nconst int INF = 10001;\nconst int N = 1001;\nint dp[N][N];\n\nint solve(int val, int idx, vector<vector<int>>& q, int id) {\n    if(val < 0) {\n        return INF;\n    }\n    if(val == 0) {\n        return idx;\n    }\n    if(idx == q.size()) {\n        return INF;\n    }\n    int &res = dp[val][idx];\n    if(res != -1) return res;\n    res = solve(val, idx + 1, q, id);\n    if(id >= q[idx][0] && id <= q[idx][1]) {\n        res = min(res, solve(val - q[idx][2], idx + 1, q, id));\n    }\n    return res;\n}\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = 0;\n        rep(i,0,nums.size()) {\n            memset(dp, -1, sizeof(dp));\n            int x = solve(nums[i], 0, queries, i);\n            if(x == INF) return -1;\n            ans = max(ans, x);\n        }\n        return ans;\n    }\n};","author":"__shadow","submissionId":"1575124514"},[]]},{"92":[{"id":"92","fileName":"1575125299.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if all(x == 0 for x in nums):\n            return 0\n        \n        lo, hi = 1, len(queries) + 1  \n        ans = -1\n        \n        while lo < hi:\n            mid = (lo + hi) // 2\n            if self.can_zero(nums, queries[:mid]):\n                ans = mid\n                hi = mid\n            else:\n                lo = mid + 1\n                \n        return ans if ans != -1 else -1\n\n    def can_zero(self, nums: List[int], queries: List[List[int]]) -> bool:\n        \n        n = len(nums)\n        for i in range(n):\n            target = nums[i]\n            available = [val for l, r, val in queries if l <= i <= r]\n            if not self.subset_sum(available, target):\n                return False\n        return True\n\n    def subset_sum(self, arr: List[int], target: int) -> bool:\n        \n        dp = 1  \n        for x in arr:\n            dp |= dp << x\n        return (dp >> target) & 1 == 1","author":"anish ramesh","submissionId":"1575125299"},[]]},{"93":[{"id":"93","fileName":"1575125378.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        nq = len(queries)\n        dec = [[0] * nq for _ in range(n)]\n        for i, query in enumerate(queries):\n            l, r, val = query\n            for j in range(l, r+1):\n                dec[j][i] = val\n        max_k = 0\n        for i in range(n):\n            max_k = max(max_k, self.find_min(dec[i], nums[i]))\n        return max_k if max_k != nq + 1 else -1\n    \n    def find_min(self, array, target) -> int:\n        if target == 0:\n            return 0\n        prev = set()\n        prev.add(0)\n        for i, num in enumerate(array):\n            \n            temp = set()\n            for p in prev:\n                temp.add(p)\n                temp.add(p+num)\n            if target in temp:\n                return i + 1\n            prev = temp\n        return len(array) + 1\n            ","author":"juggernutx","submissionId":"1575125378"},[]]},{"94":[{"id":"94","fileName":"1575124969.txt","sourceCode":"class Solution {\n\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int max = -1;\n        for (int i = 0; i < nums.length; i++) {\n            max = Math.max(max, minZeroArray(i, nums[i], queries));\n        }\n        return max == Integer.MAX_VALUE ? -1 : max;\n    }\n\n    private int minZeroArray(int i, int num, int[][] queries) {\n        if (num == 0) {\n            return 0;\n        }\n        boolean[] dp = new boolean[1010];\n        dp[0] = true;\n        for (int j = 0; j < queries.length; j++) {\n            if (i >= queries[j][0] && i <= queries[j][1]) {\n                for (int k = 1009; k >= queries[j][2]; k--) {\n                    dp[k] |= dp[k - queries[j][2]];\n                }\n                if (dp[num]) {\n                    return j + 1;\n                }\n            }\n        }\n        return Integer.MAX_VALUE;\n    }\n}","author":"arignote","submissionId":"1575124969"},[]]},{"95":[{"id":"95","fileName":"1575126145.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = size(nums);\n        int q = size(queries);\n        int l = 0, r = q;\n        while (l < r) {\n            int m = (l + r - 1) / 2;\n            //cout << m << endl;\n            \n            bool good = 1;\n            for (int i = 0; i < n && good; i++) {\n                vector<bool> dp(1005);\n                dp[0] = 1;\n                for (int j = 0; j < m; j++) {\n                    auto v = queries[j];\n                    if (i >= v[0] && i <= v[1]) {\n                        for (int k = 1000 - dp[2]; k >= 0; k--)\n                            if (dp[k])\n                                dp[k + v[2]] = 1;\n                    }\n                }\n                //cout << m << \"    \" << dp[nums[i]] << endl;\n                good &= dp[nums[i]];\n            }\n            if (good) r = m;\n            else l = m + 1;\n        }\n        if (l == q) {\n            int m = q;\n            bool good = 1;\n            for (int i = 0; i < n && good; i++) {\n                vector<bool> dp(1005);\n                dp[0] = 1;\n                for (int j = 0; j < m; j++) {\n                    auto v = queries[j];\n                    if (i >= v[0] && i <= v[1]) {\n                        for (int k = 1000 - dp[2]; k >= 0; k--)\n                            if (dp[k])\n                                dp[k + v[2]] = 1;\n                    }\n                }\n                //cout << m << \"    \" << dp[nums[i]] << endl;\n                good &= dp[nums[i]];\n            }\n            return good ? q : -1;\n        }\n        return r;\n    }\n};","author":"cole","submissionId":"1575126145"},[]]},{"96":[{"id":"96","fileName":"1575125595.txt","sourceCode":"constexpr int MAXN = 16;\nconstexpr int MAXM = 1024;\n\nint a[MAXN], l[MAXM], r[MAXM], w[MAXM], dp[MAXM];\n\nbool CheckCol(int n, int k) {\n  int m = a[k];\n  fill(dp, dp + m + 1, 0);\n  dp[0] = 1;\n  for (int i = 0; i < n; ++i) {\n    if (k < l[i] || k > r[i]) {\n      continue;\n    }\n    for (int j = m; j >= w[i]; --j) {\n      dp[j] |= dp[j - w[i]];\n    }\n  }\n  return dp[m];\n}\n\nbool Check(int n, int m) {\n  for (int i = 0; i < n; ++i) {\n    if (!CheckCol(m, i)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n      int n = nums.size(), m = queries.size();\n      copy(nums.begin(), nums.end(), a);\n      for (int i = 0; i < m; ++i) {\n        l[i] = queries[i][0];\n        r[i] = queries[i][1];\n        w[i] = queries[i][2];\n      }\n      int l = 0, r = m + 1, ret = -1;\n      while (l < r) {\n        int mid = l + (r - l) / 2;\n        if (Check(n, mid)) {\n          ret = mid;\n          r = mid;\n        } else {\n          l = mid + 1;\n        }\n      }\n      return ret;\n    }\n};","author":"Xiaomeng Yang","submissionId":"1575125595"},[]]},{"97":[{"id":"97","fileName":"1575126389.txt","sourceCode":"\n#ifdef LOCAL_RUN\n#include \"debug_leet.h\"\n    #else\n    #define trace(...) ;\n    #define dbg(...) ;\n    #define dbgc(...) ;\n    #define debug(x) ;\n    #define debuga(a, n) ;\n    #define debug2(x, y) ;\n    #define debug3(x, y, z) ;\n    #define debug4(x, y, z, w) ;\n    #define debug5(a,b,c,d,e) ;\n    #define lassert(x) ;\n    #define dassert(x, ...) ;\n    int recur_depth = 0; bool rec_indent = true;\n    const bool isLocal = false;\n    template <typename Arg, typename... Args>\n    void display(TreeNode* root) {}\n    #endif\n\n    #define pb push_back\n    #define eb emplace_back\n    #define popb pop_back\n    #define all(v) begin(v), end(v)\n    #define rall(v) (v).rbegin(),(v).rend()\n    #define make_unique(v) (v).erase(unique(all(v)), (v).end())\n    #define sz(c) ((int) c.size())\n    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)\n    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)\n    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)\n    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)\n    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n    #define mem(a,b) memset(a,b,sizeof(a))\n    #define abs(x) (((x) < 0) ? -(x) : (x))\n    #define sqr(x) ((x) * (x))\n    #define sqrt(x) sqrt(abs(x))\n    #define has(c,x) (c.find(x) != c.end())\n    #define pw(x) (1LL << (x))\n    #define ibit(x,i) (((x) >> (i)) & 1)\n    #define data(v) v.data(), sz(v) // vi -> vai\n    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)\n\n    typedef stringstream sstr;\n    typedef long long ll;\n    typedef long double ld;\n    typedef pair<int, int> pii;\n    typedef pair<ll,ll> pll;\n    typedef pair<ld,ld> pdd;\n    typedef vector<int> vi;\n    typedef vector<ll> vll;\n    typedef vector<pii> vpii;\n    typedef vector<vi> vvi;\n    typedef vector<vll> vvll;\n    typedef valarray<int> vai;\n    template <class T>\n    using min_pq = priority_queue<T, vector<T>, greater<T>>;\n    template <class T>\n    using vc = vector<T>;\n    template <class T>\n    using vvc = vector<vc<T>>;\n    template <class T>\n    using vvvc = vector<vvc<T>>;\n    template <class T>\n    using vvvvc = vector<vvvc<T>>;\n    template <class T>\n    using vvvvvc = vector<vvvvc<T>>;\n\n    template<class F>\n    struct y_comb{\n        F f;\n        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }\n        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }\n    };\n    template<class F>\n    decltype(auto) yf(F &&f){\n        return y_comb<decay_t<F>>(forward<F>(f));\n    }\n\n    inline int ni(){ int x; cin >> x;   return x; }\n    inline ll  nl() { ll  x; cin >> x; return x; }\n\n    template <class T> void mmin(T& a, const T& b) {\n        a = (a) < (b) ? (a) : (b);\n    }\n    template <class T> void mmax(T& a, const T& b) {\n        a = (a) > (b) ? (a) : (b);\n    }\n    template <class T> int LB(vc<T> &a, T x){\n        return int(lower_bound(all(a), x) - a.begin());\n    }\n    template <class T> int UB(vc<T> &a, T x){\n        return int(upper_bound(all(a), x) - a.begin());\n    }\n    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){\n        if(r < 0) r = sz(a);\n        return *max_element(a.begin()+l, a.begin()+r);\n    }\n    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){\n        if(r < 0) r = sz(a);\n        return *min_element(a.begin()+l, a.begin()+r);\n    }\n    template <class T> auto vv(int d1, T x){\n        return vc<T>(d1, x);\n    }\n    template <class T> auto vv(int d1, int d2, T x){\n        return vc<vc<T>>(d1, vc<T>(d2, x));\n    }\n    template <class T> auto vv(int d1, int d2, int d3, T x){\n        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));\n    }\n    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){\n        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));\n    }\n    void outv(auto &v){\n        for(auto &x: v) {cout<< x <<\" \";} cout<<endl;\n    }\n    void rvec(int &n, auto &v){\n        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);\n    }\n    template <typename Arg, typename... Args>\n    void read(Arg&& arg, Args&&... args){\n        cin >> std::forward<Arg>(arg); using expander = int[];\n        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};\n    }\n    template <typename Arg, typename... Args>\n    void out(Arg&& arg, Args&&... args){\n        cout << std::forward<Arg>(arg); using expander = int[];\n        (void)expander{0, (void(cout << \" \" << std::forward<Args>(args)),0)...};\n        cout << endl;\n    }\n    namespace tuple_utils{\n        template<class ...Ts, size_t ...Is>\n        ostream& println_tuple_impl(ostream& os, tuple<Ts...> tuple, index_sequence<Is...>){\n            static_assert(sizeof...(Is)==sizeof...(Ts),\"Indices must have same number of elements as tuple types!\");\n            static_assert(sizeof...(Ts)>0, \"Cannot insert empty tuple into stream.\");\n            auto last = sizeof...(Ts) - 1; // assuming index sequence 0,...,N-1\n            return ((os << get<Is>(tuple) << (Is != last ? \", \" : \")\")),...);\n        }\n    }\n    template<class ...Ts> ostream& operator<<(ostream& os, const tuple<Ts...> & tuple) {\n        os << \"(\";\n        return tuple_utils::println_tuple_impl(os, tuple, index_sequence_for<Ts...>{});\n    }\n    template <class Integer, class F>\n    Integer find_first_false(Integer l, Integer r, F&& f) {\n        --l; // ++r;\n        while (r - l > 1) {\n            Integer m = midpoint(l, r);\n            if (f(m)) l = m;\n            else r = m;\n        }\n        return r;\n    }\n    template <class Integer, class F>\n    Integer find_last_true(Integer l, Integer r, F &&f) {\n        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;\n    }\n    template <class Integer, class F>\n    Integer find_first_true(Integer l, Integer r, F &&f) {\n        return find_first_false(l, r, [&f](Integer i) { return !f(i); });\n    }\n    template <class T, class F>\n    T last_true(T lo, T hi, F&& f) { \n        lo--; // if all are false, return lo-1\n        while(lo < hi){\n            T mid = lo + (hi - lo + 1) / 2;\n            if(f(mid)) lo = mid; \n            else hi = mid - 1;\n        }\n        return lo;\n    }\n    template <class T, class F>\n    T first_true(T lo, T hi, F&& f) { \n        // return last_true(lo, hi, [&](T x){ return !f(x); }) + 1;\n        hi++; // if all are false, return hi+1\n        while(lo < hi){\n            T mid = lo + (hi - lo) / 2;\n            if(f(mid)) hi = mid; \n            else lo = mid + 1;\n        }\n        return lo;\n    }\n    auto init = []() {\n        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';\n    }();\n\n    ll pwr(ll base, ll p, ll mod){\n        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;\n            base=(base*base)%mod; p/=2;}\n        return ans;\n    }\n    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }\n    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }\n\n    const long double PI = (long double)(3.1415926535897932384626433832795);\n    const ll  mx_ll   = numeric_limits<ll> :: max();\n    const int mx_int  = numeric_limits<int> :: max();\n\n    const int oo = 0x3f3f3f3f;\n    const ll  OO = 0x3f3f3f3f3f3f3f3fll;\n    const double eps = 1e-9;\n    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};\n    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};\n\nconst int maxn = 1e5 + 3;\nconst int mod = 1e9+7;\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& queries) {\n        int n = sz(a);\n        vc<bitset<1001>> bs(n);\n        forn(i, n) bs[i].set(0);\n        bool ok = 1;\n        forn(i, n) if(!bs[i].test(a[i])) ok = 0;\n        if(ok) return 0;\n        forn(q, sz(queries)) {\n            int l = queries[q][0], r = queries[q][1], val = queries[q][2];\n            fornn(i, l, r+1) bs[i] |= bs[i] << val;\n            ok = 1;\n            forn(i, n) if(!bs[i].test(a[i])) ok = 0;\n            if(ok) return q+1;\n        }\n        return -1;\n    }\n};\n\n#ifdef LOCAL_RUN\nvoid _solve(){\n    Solution sol;\n\n}\n\n\n/*************************************************************************/\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    //cout.precision(15);\n    // return 0;\n    while(cin.peek() == 32 or cin.peek() == 10) cin.get();\n    while(cin.peek() != EOF){\n        _solve();\n        while(cin.peek() == 32 or cin.peek() == 10) cin.get();\n    }\n}\n#endif\n","author":"Jose Coves","submissionId":"1575126389"},[]]},{"98":[{"id":"98","fileName":"1575126534.txt","sourceCode":"class Solution {\npublic:\n    bool ispossible(vector<int>& nums, vector<vector<int>>& queries,int q)\n    {\n        int n=nums.size();\n        vector<vector<int>> vp(n);\n        for(int i=0;i<q;i++)\n            {\n                for(int j=queries[i][0];j<=queries[i][1];j++)\n                    {\n                        vp[j].push_back(queries[i][2]);\n                    }\n            }\n        for(int i=0;i<nums.size();i++)\n            {\n                if(nums[i]==0) continue;\n                if(vp[i].size()==0) return 0;\n                int sz=vp[i].size();\n                vector<vector<int>> dp(sz+1,vector<int> (nums[i]+1,0));\n                 for(int j=0;j<=sz;j++) dp[j][0]=1;\n                int target=nums[i];\n                vector<int> arr;\n                for(auto j : vp[i]) arr.push_back(j);\n                for(int ii=1;ii<=sz;ii++)\n                {\n            for(int j=1;j<=target;j++)\n            {\n                dp[ii][j]=dp[ii-1][j];\n                if(j>=arr[ii-1])\n                dp[ii][j]|=dp[ii-1][j-arr[ii-1]];\n            }\n                  \n        }\n                  if(dp[sz][target]==0) return 0;\n            }\n\n\n        return 1;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int q=queries.size();\n        bool f=1;\n        for(auto j : nums) f=f&(j==0);\n        if(f) return 0;\n        int st=1,end=q;\n        int ans=-1;\n        while(st<=end)\n            {\n                int mid=(st+end)/2;\n                if(ispossible(nums,queries,mid))\n                {\n                    ans=mid;\n                    end=mid-1;\n                }\n                else\n                    st=mid+1;\n            }\n        return ans;\n    }\n};","author":"Neel Y Tandel","submissionId":"1575126534"},[]]},{"99":[{"id":"99","fileName":"1575126079.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        answer = -1\n        \n        for i, x in enumerate(nums):\n            dp = [0] + [-1] * x\n            \n            for j, (l, r, val) in enumerate(queries):\n                is_found = False\n                \n                if l <= i <= r:\n                    temp = dp.copy()\n                    \n                    for y in range(x + 1 - val):\n                        if dp[y] != -1 and dp[y + val] == -1:\n                            temp[y + val] = j + 1\n                            \n                    dp = temp\n                    if dp[x] != -1:\n                        is_found = True\n                        answer = max(answer, dp[x])\n                        \n            # print(dp, i, x)\n                        \n            if dp[x] == -1:\n                return -1\n            \n        return answer","author":"Maruzensky","submissionId":"1575126079"},[]]},{"100":[{"id":"100","fileName":"1575125065.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        @lru_cache(None)\n        def check(v, count):\n            if v==0: return True\n            if len(count)<=1 or v<0: return False\n            x = len(count)-1\n            for mul in range(count[x], -1, -1):\n                if check(v - mul*x, count[:x]): return True\n            return False\n                \n        def feasible(x):\n            data=[[0]*11 for _ in range(n)]\n            for l,r,v in queries[:x]:\n                for i in range(l,r+1):\n                    data[i][v] += 1\n            # print(x, nums, data)\n            return all(check(v, tuple(d)) for v,d in zip(nums,data))\n        l,r,res = 0, len(queries), -1\n        while l<=r:\n            mid=(l+r)//2\n            if feasible(mid): res, r = mid, mid-1\n            else: l=mid+1\n        return res","author":"Nguyễn Thảo","submissionId":"1575125065"},[]]},{"101":[{"id":"101","fileName":"1575126999.txt","sourceCode":"int minZeroArray(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize) {\n\n    int all_zero = 1;\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] != 0) {\n            all_zero = 0;\n            break;\n        }\n    }\n    if (all_zero) {\n        return 0;\n    }\n\n    int max_k = -1;\n\n    for (int i = 0; i < numsSize; i++) {\n        int target = nums[i];\n        if (target == 0) {\n            continue; \n        }\n\n        int* covering_j = (int*)malloc(queriesSize * sizeof(int));\n        int* covering_val = (int*)malloc(queriesSize * sizeof(int));\n        int count = 0;\n\n        for (int j = 0; j < queriesSize; j++) {\n            int l = queries[j][0];\n            int r = queries[j][1];\n            if (i >= l && i <= r) {\n                covering_j[count] = j;\n                covering_val[count] = queries[j][2];\n                count++;\n            }\n        }\n\n        for (int a = 0; a < count; a++) {\n            for (int b = a + 1; b < count; b++) {\n                if (covering_j[a] > covering_j[b]) {\n                    int temp_j = covering_j[a];\n                    int temp_val = covering_val[a];\n                    covering_j[a] = covering_j[b];\n                    covering_val[a] = covering_val[b];\n                    covering_j[b] = temp_j;\n                    covering_val[b] = temp_val;\n                }\n            }\n        }\n\n        int* dp = (int*)calloc(target + 1, sizeof(int));\n        dp[0] = 1;\n        int earliest_j = -1;\n\n        for (int q = 0; q < count; q++) {\n            int val = covering_val[q];\n            int j = covering_j[q];\n\n            for (int s = target; s >= val; s--) {\n                if (dp[s - val] && !dp[s]) {\n                    dp[s] = 1;\n                    if (s == target && earliest_j == -1) {\n                        earliest_j = j;\n                    }\n                }\n            }\n\n            if (earliest_j != -1) {\n                break;\n            }\n        }\n\n        free(covering_j);\n        free(covering_val);\n\n        if (!dp[target]) {\n            free(dp);\n            return -1;\n        }\n\n        if (earliest_j > max_k) {\n            max_k = earliest_j;\n        }\n\n        free(dp);\n    }\n\n    if (max_k == -1) {\n        return 0;\n    }\n\n    return max_k + 1;\n}","author":"Samrach","submissionId":"1575126999"},[]]},{"102":[{"id":"102","fileName":"1575126674.txt","sourceCode":"function minZeroArray(nums: number[], queries: number[][]): number {\n    const n = nums.length;\n    if (n === 0) return -1;\n    if (nums.every(x => x === 0)) return 0;\n    \n    const maxVal = 1000;\n    const dp: boolean[][] = [];\n    \n    for (let i = 0; i < n; i++) {\n        dp[i] = new Array(maxVal + 1).fill(false);\n        dp[i][0] = true;\n    }\n    \n    for (let k = 1; k <= queries.length; k++) {\n        const [l, r, val] = queries[k - 1];\n        \n        for (let i = l; i <= r; i++) {\n            for (let s = maxVal; s >= val; s--) {\n                if (dp[i][s - val]) dp[i][s] = true;\n            }\n        }\n        \n        let allZero = true;\n        for (let i = 0; i < n; i++) {\n            if (nums[i] <= maxVal && !dp[i][nums[i]]) {\n                allZero = false;\n                break;\n            }\n        }\n        \n        if (allZero) return k;\n    }\n    \n    return -1;\n}\n","author":"Swayam","submissionId":"1575126674"},[]]},{"103":[{"id":"103","fileName":"1575127040.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int mini = 0;\n        for(int i = 0; i < nums.size(); i++){\n            if(nums[i] == 0)\n                continue;\n            set<int> s;\n            s.insert(0);\n            int index = 1;\n            for(vector<int> q: queries){\n                if(q[0] <= i && q[1] >= i){\n                    set<int> ss;\n                    for(int x: s){\n                        ss.insert(x);\n                        if(x + q[2] > nums[i])\n                            continue;\n                        ss.insert(x+q[2]);\n                    }\n                    s = ss;\n                }\n                if(s.find(nums[i]) != s.end()){\n                    mini = max(mini, index);\n                    break;\n                }\n                index++;\n            }\n            if(index == queries.size() + 1)\n                return -1;\n        }\n        return mini;\n    }\n};","author":"hero777","submissionId":"1575127040"},[]]},{"104":[{"id":"104","fileName":"1575127142.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        dp = [[False] * (nums[i] + 1) for i in range(len(nums))]\n        for i in range(len(dp)): dp[i][-1] = True\n        if set(nums) == {0}: return 0\n        for i in range(len(queries)):\n            # print(dp)\n            for j in range(queries[i][0], queries[i][1] + 1):\n                for k in range(len(dp[j]) - queries[i][2]):\n                    dp[j][k] = dp[j][k] or dp[j][k + queries[i][2]]\n            yes = True\n            for j in range(len(dp)):\n                if not dp[j][0]:\n                    yes = False\n            # print(dp, not dp[-1][0], yes)\n            if yes: return i + 1\n        return -1","author":"LouisCheng","submissionId":"1575127142"},[]]},{"105":[{"id":"105","fileName":"1575127302.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& Q) {\n        int n = a.size(), q = Q.size();\n        int sum = 0;\n\n        for(int i=0; i<n; i++) sum += a[i];\n        if(sum == 0) return 0;\n\n        vector<bitset<1001>> b(n);\n        for(int i=0; i<n; i++) b[i].set(a[i]);\n\n        for(int i=0; i<q; i++)\n        {\n            int l = Q[i][0], r = Q[i][1], v = Q[i][2];\n            sum = 0;\n\n            for(int j=l; j<=r; j++)\n                {\n                    b[j] |= b[j] >> v;\n                }\n\n            for(int i = 0; i < n; i++) sum += b[i][0];\n            if(sum == n) return i + 1;\n        }\n\n        return -1;\n    }\n};","author":"champ36","submissionId":"1575127302"},[]]},{"106":[{"id":"106","fileName":"1575127570.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        int pos = 0;\n        for (int i = 0; i < n; i++) {\n            int x = nums[i];\n            vector<bool> d(x + 1, false);\n            d[0] = true;\n            int j = 0;\n            while (j < m && d[x] == false) {\n                int l = queries[j][0];\n                int r = queries[j][1];\n                int v = queries[j][2];\n                if (i >= l && i <= r) {\n                    for (int k = x; k >= v; k--) {\n                        if (d[k - v] == true) d[k] = true;\n                    }\n                }\n                j++;\n            }\n            if (d[x] == false) return -1;\n            if (j > pos) pos = j;\n        }\n        return pos;\n    }\n};","author":"Lpl","submissionId":"1575127570"},[]]},{"107":[{"id":"107","fileName":"1575127515.txt","sourceCode":"const int M = 1001;\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size(), m = q.size();\n        \n        bool ok = true;\n        for (int i = 0; i < n; i++){\n            if (nums[i] != 0) ok = false;\n        }\n        if (ok) return 0;\n        \n        vector<bitset<M>> bits(n);\n        for (int i = 0; i < n; i++){\n            bits[i][0] = 1;\n        }\n        vector<int> best(n, m + 1);\n        \n        for (int i = 0; i < m; i++){\n            int l = q[i][0], r = q[i][1], v = q[i][2];\n            for (int j = l; j <= r; j++){\n                bits[j] |= (bits[j] << v);\n                if (bits[j][nums[j]] == 1) best[j] = min(best[j], i + 1);\n            }\n        }\n        auto x = *max_element(best.begin(), best.end());\n        if (x == m + 1) return -1;\n        return x;\n        \n    }\n};","author":"xymabinogi","submissionId":"1575127515"},[]]},{"108":[{"id":"108","fileName":"1575127576.txt","sourceCode":"// import java.util.*;\n// import java.util.function.*;\n\n// public class Main {\n//     public static void main(String[] args) throws Exception {\n//         System.out.println(new Solution().solve());\n//     }\n// }\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            boolean[] dp = new boolean[nums[i] + 1];\n            dp[0] = true;\n\n            for (int q = 0; q < queries.length; q++) {\n                int l = queries[q][0], r = queries[q][1], v = queries[q][2];\n\n                if (dp[nums[i]]) {\n                    ans = Math.max(ans, q);\n                    break;\n                }\n\n                if (l <= i && i <= r) {\n                    for (int j = nums[i]; j >= v; j--)\n                        dp[j] |= dp[j - v];\n                }\n\n                if (dp[nums[i]]) {\n                    ans = Math.max(ans, q + 1);\n                    break;\n                }\n            }\n            \n            if (!dp[nums[i]])\n                return -1;\n        }\n\n        return ans;\n    }\n}\n","author":"Sarthak Mathur","submissionId":"1575127576"},[]]},{"109":[{"id":"109","fileName":"1575127759.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<vector<pair<int, int>>> for_j(n); \n\n        for (int i = 0; i < m; ++i) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            for (int j = l; j <= r; ++j) {\n                for_j[j].emplace_back(val, i);\n            }\n        }\n\n        int max_k = 0;\n\n        for (int j = 0; j < n; ++j) {\n            int target = nums[j];\n            if (target == 0) continue;\n\n            vector<int> dp(target + 1, m); \n            dp[0] = -1;\n\n            for (const auto& [val, idx] : for_j[j]) {\n                vector<int> temp = dp;\n                for (int s = 0; s <= target; ++s) {\n                    if (temp[s] <= m) {\n                        int new_sum = s + val;\n                        if (new_sum > target) continue;\n                        int new_max = max(temp[s], idx);\n                        if (new_max < dp[new_sum]) {\n                            dp[new_sum] = new_max;\n                        }\n                    }\n                }\n            }\n            if (dp[target] == m) {\n                return -1;\n            }\n            max_k = max(max_k, dp[target] + 1);\n        }\n        return (max_k <= m) ? max_k : -1;\n    }\n};\n","author":"Manish Upreti","submissionId":"1575127759"},[]]},{"110":[{"id":"110","fileName":"1575128078.txt","sourceCode":"using vi = vector<int>;\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& qr) {\n        int q = qr.size();\n        const int inf = 1e9;\n\n        auto f = [&] (int i) {\n            int x = a[i];\n            vi dp(x+1);\n            dp[0] = 1;\n            int ret = inf;\n            if (dp[x]) return ret = 0;\n            for (int j=0; j<q; j++) {\n                int l = qr[j][0], r = qr[j][1], w = qr[j][2];\n                if (l <= i && i <= r) {\n                    for (int l=x; l>=0; l--) {\n                        if (l+w <= x && dp[l]) {\n                            dp[l+w] = 1;\n                        }\n                    }\n                }\n                if (dp[x]) return ret = j+1;\n            }\n            return ret;\n        };\n\n        int ans = 0, n = a.size();\n        for (int i=0; i<n; i++) {\n            ans = max(ans, f(i));\n        }\n        if (ans == inf) ans = -1;\n        return ans;\n    }\n};","author":"umeshbahadur1729","submissionId":"1575128078"},[]]},{"111":[{"id":"111","fileName":"1575128761.txt","sourceCode":"class Solution {\npublic:\n    void updateDP(vector<bool>& dp, int target, int val) {\n        for (int s = target; s >= val; s--)\n            if (dp[s - val])\n                dp[s] = true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<bool>> dp(n);\n        for (int i = 0; i < n; i++) {\n            dp[i].resize(nums[i] + 1, false);\n            dp[i][0] = true;\n        }\n        auto allZero = [&]() -> bool {\n            for (int i = 0; i < n; i++)\n                if (!dp[i][nums[i]])\n                    return false;\n            return true;\n        };\n        if (allZero()) return 0;\n        for (int q = 0; q < queries.size(); q++) {\n            int l = queries[q][0], r = queries[q][1], v = queries[q][2];\n            for (int i = l; i <= r; i++)\n                if (nums[i] >= v)\n                    updateDP(dp[i], nums[i], v);\n            if (allZero()) return q + 1;\n        }\n        return -1;\n    }\n};\n","author":"SRIRAM G","submissionId":"1575128761"},[]]},{"112":[{"id":"112","fileName":"1575128027.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        if (*max_element(nums.begin(), nums.end()) == 0) {\n            return 0;\n        }\n        \n        int n = (int) nums.size();\n        int cnt = 0;\n        vector<vector<bool>> dp(n);\n\n        for (int i = 0; i < n; i++) {\n            dp[i] = vector<bool>(nums[i] + 1, false);\n            dp[i][0] = true;\n        }\n\n        for (auto& query: queries) {\n            cnt++;\n            int l = query[0];\n            int r = query[1];\n            int w = query[2];\n\n            for (int i = l; i <= r; i++) {\n                if (dp[i].back()) continue;\n                \n                for (int j = nums[i]; j >= w; j--) {\n                    dp[i][j] = dp[i][j] || dp[i][j - w];\n                }\n            }\n\n            bool can = true;\n\n            for (int i = 0; i < n; i++) {\n                if (!dp[i].back()) {\n                    can = false;\n                    break;\n                }\n            }\n\n            if (can) {\n                return cnt;\n            }\n        }\n        \n        return -1;\n    }\n};","author":"Ajay Singh Deopa","submissionId":"1575128027"},[]]},{"113":[{"id":"113","fileName":"1575128795.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    int n = nums.size();\n    // If nums is already a Zero Array, return 0.\n    bool allZero = true;\n    for (int x : nums) {\n        if (x != 0) { allZero = false; break; }\n    }\n    if(allZero) return 0;\n    \n    int q = queries.size();\n    int lo = 1, hi = q, ans = -1;\n    \n    while(lo <= hi) {\n        int mid = lo + (hi - lo) / 2;\n        bool feasible = true;\n        // For each index, check if we can achieve exactly nums[i] using queries[0..mid-1]\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            // Build the list of available values for index i.\n            vector<int> vals;\n            for (int j = 0; j < mid; j++) {\n                if (queries[j][0] <= i && i <= queries[j][1])\n                    vals.push_back(queries[j][2]);\n            }\n            // Subset-sum DP (using reverse iteration to avoid reuse in same query)\n            vector<bool> dp(target + 1, false);\n            dp[0] = true;\n            for (int v : vals) {\n                for (int s = target; s >= v; s--) {\n                    if (dp[s - v]) dp[s] = true;\n                }\n            }\n            if (!dp[target]) { \n                feasible = false; \n                break; \n            }\n        }\n        if(feasible) {\n            ans = mid;\n            hi = mid - 1;\n        } else {\n            lo = mid + 1;\n        }\n    }\n    return ans;\n}\n};","author":"Maverick","submissionId":"1575128795"},[]]},{"114":[{"id":"114","fileName":"1575127797.txt","sourceCode":"class Solution {\npublic:\n    bool solve(int n, vector<int>& ct){\n        vector<bool>vis(n+1, false);\n        vis[0] = true;\n        for(int i=1;i<=10;i++){\n            for(int j=0;j<ct[i];j++){\n                for(int k=n-i;k>=0;k--){\n                    if(vis[k])vis[k+i] = true;\n                }\n                if(vis[n])break;\n            }\n            if(vis[n])break;\n        }\n        return vis[n];\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        if(*min_element(nums.begin(), nums.end()) == 0 && *max_element(nums.begin(), nums.end()) == 0)return 0;\n        vector<vector<int>>ct(n, vector<int>(11, 0));\n        vector<bool>good(n, false);\n        for(int i=0;i<m;i++){\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for(int j=l;j<=r;j++)ct[j][val]++;\n            bool found = true;\n            for(int j=0;j<n;j++){\n                if(good[j])continue;\n                good[j] = solve(nums[j], ct[j]);\n                if(!good[j])found = false;\n            }\n            if(found)return i+1;\n        }\n        return -1;\n    }\n};","author":"tonyli00000","submissionId":"1575127797"},[]]},{"115":[{"id":"115","fileName":"1575128283.txt","sourceCode":"class Solution {\npublic:\n    bool canTransformToZeroArray(int numberOfProcessedQueries, const vector<int>& originalArray, const vector<vector<int>>& queryList) {\n        int arraySize = originalArray.size();\n        for (int j = 0; j < arraySize; j++) {\n            if (originalArray[j] == 0) continue;\n            bitset<1001> memo;\n            memo.reset();\n            memo[0] = 1;\n            for (int i = 0; i < numberOfProcessedQueries; i++) {\n                int leftBoundary = queryList[i][0];\n                int rightBoundary = queryList[i][1];\n                int decrementAmount = queryList[i][2];\n                if (j >= leftBoundary && j <= rightBoundary) {\n                    memo |= (memo << decrementAmount);\n                }\n            }\n            if (!memo.test(originalArray[j])) return false;\n        }\n        return true;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int totalQueries = queries.size();\n        bool isAlreadyZero = true;\n        for (int value : nums) {\n            if (value != 0) { isAlreadyZero = false; break; }\n        }\n        if (isAlreadyZero) return 0;\n        \n        int low = 0, high = totalQueries, minimumQueriesNeeded = -1;\n        while (low <= high) {\n            int midPoint = (low + high) / 2;\n            if (canTransformToZeroArray(midPoint, nums, queries)) {\n                minimumQueriesNeeded = midPoint;\n                high = midPoint - 1;\n            } else {\n                low = midPoint + 1;\n            }\n        }\n        return minimumQueriesNeeded;\n    }\n};\n","author":"singlanitinsn","submissionId":"1575128283"},[]]},{"116":[{"id":"116","fileName":"1575128996.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        if (*max_element(nums.begin(), nums.end()) == 0)\n            return 0;\n        int n = nums.size();\n        vector<vector<bool>> dp(n, vector<bool>(1001));\n        for (int j = 0; j < n; j++) \n            dp[j][0] = 1;\n        for (int i = 0; i < queries.size(); i++) {\n            for (int j = queries[i][0]; j <= queries[i][1]; j++) \n                for (int k = 1000 - queries[i][2]; k >= 0; k--) \n                    if (dp[j][k])\n                        dp[j][k + queries[i][2]] = 1;\n            bool ok = 1;\n            for (int j = 0; j < n; j++) \n                if (!dp[j][nums[j]]) {\n                    ok = 0;\n                    break;\n                }\n            if (ok)\n                return i + 1;\n        }\n        return -1;\n    }\n};","author":"Abhishek Srivastava","submissionId":"1575128996"},[]]},{"117":[{"id":"117","fileName":"1575129340.txt","sourceCode":"\n\n \nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<vector<vector<int>>> vec; \n       \n        vector<vector<int>> vec1 = queries; \n        for (int k = 0; k <= m; k++) {\n            bool b = true;\n            for (int i = 0; i < n; i++) {\n                int curr = nums[i];\n                vector<bool> dp(curr + 1, 0);\n                dp[0] = 1;\n                for (int j = 0; j < k; j++) {\n                    if (i <= queries[j][1]  && i >= queries[j][0] ) {\n                        int v = queries[j][2];\n                        for (int s = curr - v; s >= 0; s--) {\n                            if (dp[s]) dp[s + v] = 1;\n                        }\n                    }\n                }\n                if (!dp[curr]) { b = false; break; }\n            }\n            if (b) return k;\n        }\n        return -1;\n    }\n};","author":"KUMAR ANISH","submissionId":"1575129340"},[]]},{"118":[{"id":"118","fileName":"1575129358.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        bool allZero = true;\n        for (int x : nums) {\n            if (x != 0) { allZero = false; break; }\n        }\n        if (allZero) return 0;\n        vector<set<int>> dp(n);\n        for (int i = 0; i < n; i++) dp[i].insert(0);\n        int k = 0;\n        for (auto &query : queries) {\n            k++;\n            int l = query[0], r = query[1], v = query[2];\n            for (int i = l; i <= r; i++) {\n                set<int> newSums;\n                for (int sum : dp[i]) {\n                    if (sum + v <= nums[i]) newSums.insert(sum + v);\n                }\n                dp[i].insert(newSums.begin(), newSums.end());\n            }\n            bool possible = true;\n            for (int i = 0; i < n; i++) {\n                if (dp[i].find(nums[i]) == dp[i].end()) { possible = false; break; }\n            }\n            if (possible) return k;\n        }\n        return -1;\n    }\n};","author":"lozy219","submissionId":"1575129358"},[]]},{"119":[{"id":"119","fileName":"1575129100.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        m = len(nums)\n        dp = [set([nums[i]]) for i in range(m)]\n        checked = 0\n        for i in range(m):\n            if nums[i] == 0:\n                dp[i] = None\n                checked += 1\n        if checked == m:\n            return 0\n        for i, (l,r,x) in enumerate(queries):\n            for j in range(l, r+1):\n                if dp[j] is None:\n                    continue\n                dp[j].update([t-x for t in dp[j] if t >= x])\n                if 0 in dp[j]:\n                    checked += 1\n                    dp[j] = None\n            # print(dp)\n            if checked == m:\n                return i + 1\n        return -1","author":"xy-li","submissionId":"1575129100"},[]]},{"120":[{"id":"120","fileName":"1575129355.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int sum = 0;\n        for (int i: nums) sum += i;\n        if (sum == 0) return 0;\n        \n        boolean [][] knap = new boolean[nums.length][1001];\n        for (int i = 0; i < nums.length; i++) knap[i][0] = true;\n        for (int i = 0; i < queries.length; i++) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                for (int k = nums[j]; k >= 0; k--) {\n                    if (k - val >= 0) knap[j][k] |= knap[j][k - val];\n                }\n            }\n            boolean works = true;\n            for (int j = 0; j < nums.length; j++) {\n                if (!knap[j][nums[j]]) works = false;\n            } if (works) return i + 1;\n        } return -1;\n    }\n}","author":"anthonyli633a","submissionId":"1575129355"},[]]},{"121":[{"id":"121","fileName":"1575129519.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n    \n        def solve(mid):\n            maxs = 1100\n            for i in range(n):\n                dp = [False] * maxs\n                dp[0] = True\n                for k in range(mid):\n                    l, r, val = queries[k]\n                    if l <= i <= r:\n                        for s in range(maxs - 1, val - 1, -1):\n                            if dp[s - val]:\n                                dp[s] = True\n                if not dp[nums[i]]:\n                    return False\n            return True\n    \n        lo, hi = 0, m + 1\n        while lo < hi:\n            mid = lo + (hi - lo) // 2\n            if solve(mid):\n                hi = mid\n            else:\n                lo = mid + 1\n    \n        return lo if lo <= m else -1\n","author":"srujan","submissionId":"1575129519"},[]]},{"122":[{"id":"122","fileName":"1575129909.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n=nums.size(), m=q.size();\n        auto flag = [&](int k) -> bool {\n            for (int i=0; i<n; i++) {\n                bitset<1100> dp;\n                dp.reset();\n                dp[0] = 1;\n                for(int j=0; j<k; j++){\n                    int l = q[j][0], r = q[j][1],\n                        val = q[j][2];\n                    if(i >= l && i <= r)\n                        dp |= (dp << val);\n                }\n                if (!dp.test(nums[i]))\n                    return false;\n            }\n            return true;\n        };\n        int lo = 0, hi = m, ans = -1;\n        while (lo <= hi) {\n            int mid = (lo + hi) / 2;\n            if(flag(mid)){\n                ans = mid;\n                hi = mid - 1;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"parnikaamathur","submissionId":"1575129909"},[]]},{"123":[{"id":"123","fileName":"1575130113.txt","sourceCode":"typedef long long ll;\nconst static auto _ = [] { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr; }();\n// Don't forget long long due to overflow !!!!!!!!!\n\nclass Solution {\npublic:\n\n    vector<vector<int>> qu;\n    int q;\n\n    vector<vector<vector<int>>> dp;\n    int func(int idx, int v, int q_idx) {\n        if(v < 0) return 0;\n        if(q_idx == -1) return v == 0;\n\n        if(~dp[idx][v][q_idx]) return dp[idx][v][q_idx];\n        int ch1 = func(idx, v, q_idx - 1);\n        int ch2 = 0;\n        if(idx >= qu[q_idx][0] && idx <= qu[q_idx][1]) {\n            ch2 = func(idx, v - qu[q_idx][2], q_idx - 1);\n        }\n        return dp[idx][v][q_idx] = (ch1 || ch2);\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        qu = queries;\n        q = qu.size();\n\n        int mx = *max_element(nums.begin(), nums.end());\n        dp.assign(nums.size(), vector<vector<int>>(mx + 1, vector<int>(queries.size(), -1)));\n        int ans = -1;\n        for (int i = 0; i < nums.size(); ++i) {\n            if(!func(i, nums[i], (int)qu.size() - 1)) return -1;\n            for (int j = -1; j < (int)qu.size(); ++j) {\n                if(func(i, nums[i], j)) {\n                    ans = max(ans, j + 1);\n                    break;\n                }\n            }\n        }\n\n        return ans;\n    }\n\n};","author":"Kareem Elgoker","submissionId":"1575130113"},[]]},{"124":[{"id":"124","fileName":"1575129879.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        r = [[] for _ in range(len(nums))]\n        res = [+float('inf') if num else 0 for i,num in enumerate(nums)]\n        for i in range(len(nums)):\n            dp =[False for _ in range(nums[i]+1)]\n            dp[0] = True\n            if nums[i] == 0:\n                continue\n            \n            for j in range(len(queries)):\n                u,v,val =queries[j]\n                if u<=i<=v:\n                    if val <= nums[i]:\n                        r[i].append([val,j])\n\n            for j,el in enumerate(r[i]):\n                u,idx = el\n                for vv in range(len(dp)-1,-1,-1):\n                    if vv - u >= 0:\n                        dp[vv] |= dp[vv- u]\n                if dp[-1]:\n                    res[i] = idx+1\n                    break\n            if dp[-1] is False:\n                return -1\n        return max(res)","author":"lebron87","submissionId":"1575129879"},[]]},{"125":[{"id":"125","fileName":"1575130400.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int q = queries.size();\n        int l = 0, r = q, ans = -1;\n        while(l <= r) {\n            int mid = (l + r) / 2;\n            bool ok = true;\n            for (int i = 0; i < nums.size() && ok; i++) {\n                int target = nums[i];\n                bitset<1001> dp;\n                dp.reset();\n                dp[0] = 1;\n                for (int j = 0; j < mid; j++) {\n                    if (queries[j][0] <= i && i <= queries[j][1])\n                        dp |= (dp << queries[j][2]);\n                }\n                if (!dp[target]) ok = false;\n            }\n            if (ok) { ans = mid; r = mid - 1; }\n            else { l = mid + 1; }\n        }\n        return ans;\n    }\n};\n","author":"Jacob Ma","submissionId":"1575130400"},[]]},{"126":[{"id":"126","fileName":"1575129718.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        def possible(k):\n            poss = defaultdict(list)\n            for l, r, val in queries[:k]:\n                for i in range(l, r + 1):\n                    poss[i].append(val)\n\n            for i in range(n):\n                dp = 1\n                for j in poss[i]:\n                    # print(poss[i], dp, dp << j, j)\n                    dp |= (dp << j) \n\n                if not ((dp >> nums[i]) & 1):\n                    return False\n            return True\n\n        if not possible(len(queries)):\n            return -1\n        \n        res =  bisect_left(range(len(queries)), True, key = possible)\n        return res\n                ","author":"rukt","submissionId":"1575129718"},[]]},{"127":[{"id":"127","fileName":"1575129223.txt","sourceCode":"class Solution {\npublic:\n    bool D[20][1600];\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        for(int i=0; i<nums.size(); i++){\n            D[i][nums[i]] = true;\n        }\n        bool OK=false;\n        for(int i=0; i<nums.size(); i++){\n            if(D[i][0] == false) OK=true;\n        }\n        if(!OK){\n            return 0;\n        }\n        int ans=100000;\n        for(int i=0; i<queries.size(); i++){\n            int l =queries[i][0];\n            int r =queries[i][1];\n            int val =queries[i][2];\n            for(int j=l; j<=r; j++){\n                for(int k = val; k<=nums[j]; k++){\n                    if(D[j][k] == true) D[j][k-val] = true;\n                }\n            }\n            bool OK = true;\n            for(int j=0; j<nums.size(); j++){\n                if(D[j][0] == false) OK=false;\n            }\n            if(OK){\n                ans = i;\n                break;\n            }\n        }\n        if(ans==100000) ans=-2;\n        return ans+1;\n    }\n};","author":"Huy Phước","submissionId":"1575129223"},[]]},{"128":[{"id":"128","fileName":"1575130249.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if not sum(nums):\n            return 0\n        dp = []\n        for x in nums:\n            dp.append([True] + [False] * x)\n        for k, (l, r, v) in enumerate(queries):\n            for x in range(l, r + 1):\n                for i in range(len(dp[x]) - 1, -1 , -1):\n                    if i - v >= 0 and dp[x][i - v]:\n                        dp[x][i] = True\n            if all(x[-1] for x in dp):\n                return k + 1\n        return -1","author":"henrysux","submissionId":"1575130249"},[]]},{"129":[{"id":"129","fileName":"1575130553.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        int maxVal = 0;\n        for (int x : nums)\n            maxVal = max(maxVal, x);\n        vector<bool> vis;\n        vector<int> val(n, q+1);\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) {\n                val[i] = 0;\n                continue;\n            }\n            vis = vector<bool>(nums[i]+1);\n            vis[0] = true;\n            for (int j = 0; j < q; j++) {\n                if (i >= queries[j][0] && i <= queries[j][1])\n                    for (int k = nums[i]; k >= queries[j][2]; k--)\n                        vis[k] = (vis[k] || vis[k-queries[j][2]]);\n                if (vis[nums[i]]) {\n                    val[i] = j+1;\n                    break;\n                }\n            }\n        }\n        int ans = 0;\n        for (int x : val)\n            ans = max(ans, x);\n        return (ans == q+1) ? -1 : ans;\n    }\n};","author":"Abhishek Sajwan","submissionId":"1575130553"},[]]},{"130":[{"id":"130","fileName":"1575131030.txt","sourceCode":"#include <vector>\n#include <bitset>\nusing namespace std;\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& b) {\n        int n = a.size();\n        bool iszero = true;\n        for (int i = 0; i < n; i++) {\n            if(a[i] != 0) { \n                iszero = false; \n                break; \n            }\n        }\n        if(iszero) return 0;\n        \n        vector<int> mid = a;\n        vector<bitset<1001>> dp(n);\n        for (int i = 0; i < n; i++) {\n            dp[i].reset();\n            dp[i][0] = 1;\n        }\n        \n        for (int j = 0; j < b.size(); j++) {\n            int l = b[j][0], r = b[j][1], x = b[j][2];\n            for (int i = l; i <= r; i++) {\n                dp[i] |= (dp[i] << x);\n            }\n            bool ok = true;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i].test(a[i])) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) return j + 1;\n        }\n        return -1;\n    }\n};\n","author":"Madhavan_shree","submissionId":"1575131030"},[]]},{"131":[{"id":"131","fileName":"1575130819.txt","sourceCode":"class Solution {\npublic:\n    bitset<1001> dp;\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        if(*max_element(begin(nums), end(nums)) == 0) return 0;\n        const int n = nums.size(),  q = queries.size();\n        int ans = INT_MIN;\n        for(int i=0;i<n;++i)if(nums[i]){\n            for(int j=0;j<1001;++j) dp[j] = 0;\n            dp[0] = 1;\n            bool ok = false;\n            \n            for(int j=0;j<q;++j)if(queries[j][0] <= i && i <= queries[j][1]){\n                dp |= dp<<queries[j][2];\n                if(dp[nums[i]]){\n                    ok = true;\n                    ans  = max(ans, j+1);\n                    break;\n                }\n            }\n\n            if(!ok) return -1;\n        }\n        return ans;\n    }\n};","author":"Ayush Saluja","submissionId":"1575130819"},[]]},{"132":[{"id":"132","fileName":"1575130697.txt","sourceCode":"class Solution {\npublic:\n    bool isPossible(int k,vector<int>& nums,vector<vector<int>>&qrs) {\n        for (int i = 0; i < nums.size(); i++) {\n            vector<int>dp(nums[i] + 1,0);\n            dp[0]=1;\n            for (int j = 0; j < k; j++){\n                if (i < qrs[j][0] || i > qrs[j][1]) continue;\n                for (int val = nums[i]; val >= qrs[j][2]; val--)if(dp[val - qrs[j][2]])dp[val] = 1;\n            }\n            if (!dp[nums[i]])return 0;\n        }\n        return 1;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int cnt=0;\n        for(auto&i:nums)cnt+=(!i);\n        if(cnt==nums.size())return 0;\n        int i = 0, j = queries.size(), ans = -1;\n        while (i <= j) {\n            int m = i+(j-i)/2;\n            if (isPossible(m, nums, queries))ans = m,j = m - 1;\n            else i = m + 1;\n        }\n        return ans;\n    }\n};\n","author":"Shubham Jha","submissionId":"1575130697"},[]]},{"133":[{"id":"133","fileName":"1575131354.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        if all(x == 0 for x in nums):\n            return 0\n        \n        def good(k):\n            for i in range(n):\n                mask = 1\n                for l, r, val in queries[:k]:\n                    if l <= i <= r:\n                        mask |= (mask << val)\n                        if (mask & (1 << nums[i])):\n                            break\n                if (mask & (1 << nums[i])) == 0:\n                    return False\n            \n            return True\n        \n        l, r = 1, 10 ** 10\n        while l < r:\n            mid = l + (r - l) // 2\n            if good(mid):\n                r = mid\n            else:\n                l = mid + 1\n        \n        return l if good(l) else -1","author":"Anchor Being","submissionId":"1575131354"},[]]},{"134":[{"id":"134","fileName":"1575131357.txt","sourceCode":"class Solution:\n    def minZeroArray(self, a: List[int], queries: List[List[int]]) -> int:\n        n = len(a)\n\n        \n\n        # query = [l, r, val]\n\n        # ANYTHING IN THE SUBRANGE [l,r]\n        # ^ EITHER decrement by exactly val, or do nothing\n\n        # this might require DP\n\n        # NUMS IS REALLY SMALL (n <= 10)\n\n        # VAL is REALLY SMALL (val 1 <-> 10)\n\n        # you could do an outer binary search over the what length of query array is sufficient?\n\n        # n*max_val * log(Q) ??? or something. I think it could pass\n\n        # limited to 1000\n\n        # YOU DON'T NEED TO BINARY SEARCH\n        # its just kinda brute force\n\n        # SPLAY using each query (possible additional values you can reach)\n        # its like 1E7\n\n        # then just check if you can achieve zero array after SPLAYING using every query\n\n\n        # EDGE CASE: already a zero-array\n        if all(x == 0 for x in a):\n            return 0\n\n        \n        max_val = max(a)\n\n        dp = [[False]*(max_val+1) for _ in range(n)]\n\n        for i,x in enumerate(a):\n            dp[i][x] = True\n\n        for I,(l,r,sh) in enumerate(queries):\n            for i in range(l, r+1):\n                column = dp[i]\n\n                # walking upwards prevents self-leech\n                for x in range(len(column)):\n                    if column[x]:\n                        y = x - sh\n                        if y >= 0:\n                            column[y] = True\n\n            # check if its enough to solve\n            if all(dp[i][0] for i in range(n)):\n                return I+1\n\n        # print(dp)\n\n        # zero-array is unreachable even w/ all queries processed\n        return -1\n","author":"david_hoengy","submissionId":"1575131357"},[]]},{"135":[{"id":"135","fileName":"1575131228.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums,vector<vector<int>>& queries) {\n        int n=nums.size(),q=queries.size();\n        bool az=true;\n        for(int x:nums) {\n            if(x!=0){\n                az=false;\n                break;\n            }\n        }\n        if(az)return 0;\n        int l=1,h=q,ans=-1;\n        while(l<=h){\n            int mid=(l+h)/2;\n            bool poss=true;\n            for(int i=0;i<n;i++){\n                int tgt=nums[i],tot=0;\n                for(int j=0;j<mid;j++){\n                    int l=queries[j][0],r=queries[j][1],v=queries[j][2];\n                    if(i>=l && i<=r) tot+=v;\n                }\n                if(tot<tgt){poss=false;break;}\n                bitset<1001> dp;\n                dp[0]=1;\n                for(int j=0;j<mid;j++){\n                    int l=queries[j][0],r=queries[j][1],v=queries[j][2];\n                    if(i>=l && i<=r) dp|=(dp<<v);\n                }\n                if(!dp[tgt]){\n                    poss=false;break;\n                }\n            }\n            if(poss){\n                ans=mid;h=mid-1;\n            }\n            else{\n                l=mid+1;\n            }\n        }\n        return ans;\n    }\n};","author":"Kaju Takli","submissionId":"1575131228"},[]]},{"136":[{"id":"136","fileName":"1575131510.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int outstanding = nums.size();\n        vector<vector<bool>> memo(nums.size(), vector<bool>(1001, false));\n        for (int i = 0; i < nums.size(); i++) {\n            memo[i][nums[i]] = true;\n            if (!nums[i]) outstanding--;\n        }\n        if (outstanding == 0) return 0;\n\n        int n = queries.size();\n        for (int k = 0; k < n; k++) {\n            int l = queries[k][0], r = queries[k][1], val = queries[k][2];\n            for (int i = l; i <= r; i++) {\n                if (memo[i][0]) continue;\n                for (int j = val; j <= nums[i]; j++) {\n                    if (memo[i][j]) memo[i][j-val] = true;\n                }\n                if (memo[i][0]) {\n                    outstanding--;\n                    if (!outstanding) return k+1;\n                }\n            }\n        }\n\n        return -1;\n    }\n};","author":"Edward","submissionId":"1575131510"},[]]},{"137":[{"id":"137","fileName":"1575132157.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int max = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int num = nums[i];\n            boolean[] dp = new boolean[num+1];\n            dp[0] = true;\n            int k = 0;\n            for (; k < queries.length && !dp[num]; k++) {\n                if (i >= queries[k][0] && i <= queries[k][1]) {\n                    for (int j = num; j - queries[k][2] >= 0; j--) {\n                        dp[j] |= dp[j - queries[k][2]];\n                    }\n                }\n            }\n            if (!dp[num]) return -1;\n            max = Integer.max(max, k);\n        }\n        return max;\n    }\n}\n","author":"Samuel","submissionId":"1575132157"},[]]},{"138":[{"id":"138","fileName":"1575131705.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(),k=queries.size(),id=0;\n        vector<vector<int>>dp(1001,vector<int>(1001));\n        vector<vector<int>>vis(1001,vector<int>(1001));\n        auto rec=[&](auto &self,int i,int rem,int idx)->int{\n            if(rem==0)return i;\n            if(rem<0)return 1e6;\n            if(i==k)return 1e6;\n            int &ret=dp[i][rem];\n            if(vis[i][rem]==id)return ret;\n            vis[i][rem]=id;\n            ret=1e6;\n            int l=queries[i][0],r=queries[i][1], x=queries[i][2];\n            if(idx<l || idx>r)x=0;\n            ret=min(ret,self(self,i+1,rem-x,idx));\n            ret=min(ret,self(self,i+1,rem,idx));\n            return ret;\n        };\n        int mx=0;\n        for (int i = 0; i < n; ++i) {\n            id++;\n            mx=max(mx,rec(rec,0,nums[i],i));\n            if(mx>k)break;\n        }\n        if(mx>k)return -1;\n        return mx;\n    }\n};","author":"Ahmed_Ashraf","submissionId":"1575131705"},[]]},{"139":[{"id":"139","fileName":"1575130201.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def check2(target, blocks):\n            blocks.sort()\n\n            @cache\n            def f(target, i):\n                if target == 0:\n                    return True\n                if i == len(blocks):\n                    return False\n                if target < blocks[i]:\n                    return False\n\n                return f(target - blocks[i], i+1) or f(target, i+1)\n\n            return f(target, 0)\n                \n                    \n                    \n        \n        def check(k):\n            qs = queries[:k]\n            n = len(nums)\n\n            \n            for i in range(n):\n                target = nums[i]\n                blocks = []\n                for l, r, val in qs:\n                    if l<=i<=r:\n                        blocks.append(val)\n                if not check2(target, blocks):\n                    return False\n\n            return True\n                \n                        \n                        \n                        \n\n        l = last_k_that_worked = 0\n        r = len(queries) + 1\n        while l <= r:\n            m = (l+r)//2\n            if check(m):\n                last_k_that_worked = m\n                r = m - 1\n            else:\n                l = m + 1\n\n        if not check(last_k_that_worked) or last_k_that_worked == len(queries) + 1:\n            return -1\n\n        return last_k_that_worked \n        \n\n\n","author":"Saguaro Cactus","submissionId":"1575130201"},[]]},{"140":[{"id":"140","fileName":"1575132427.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        numsets = [{num} for num in nums]\n        if all(0 in numset for numset in numsets):\n            return 0\n        for k, (left, right, val) in enumerate(queries, 1):\n            for i in range(left, right + 1):\n                if 0 not in numsets[i]:\n                    numsets[i] |= {v - val for v in numsets[i] if val <= v}\n            if all(0 in numset for numset in numsets):\n                return k\n        return -1\n","author":"Mikko","submissionId":"1575132427"},[]]},{"141":[{"id":"141","fileName":"1575132952.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if max(nums) == 0:\n            return 0\n        n = len(nums)\n        dp = [[0] * (x + 1) for x in nums]\n        for i in range(n):\n            dp[i][0] = 1\n\n        k = 0\n        for l, r, v in queries:\n            k += 1\n            while l <= r:\n                for t in range(nums[l], v - 1, -1):\n                    dp[l][t] |= dp[l][t - v]\n                l += 1\n            ok = 1\n            for i in range(n):\n                if dp[i][-1] != 1:\n                    ok = 0\n            if ok == 1:\n                return k\n        return -1","author":"fovait","submissionId":"1575132952"},[]]},{"142":[{"id":"142","fileName":"1575131301.txt","sourceCode":"#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\nint minZeroArray(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize) {\n    bool isZero = true;\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] != 0) { isZero = false; break; }\n    }\n    if (isZero) return 0;\n    int lo = 1, hi = queriesSize, ans = -1;\n    while (lo <= hi) {\n        int mid = (lo + hi) / 2;\n        bool possible = true;\n        for (int i = 0; i < numsSize; i++) {\n            int target = nums[i];\n            int dpSize = target + 1;\n            bool* possibleSum = (bool*)calloc(dpSize, sizeof(bool));\n            possibleSum[0] = true;\n            for (int q = 0; q < mid; q++) {\n                if (i >= queries[q][0] && i <= queries[q][1]) {\n                    int dec = queries[q][2];\n                    for (int s = target; s >= dec; s--) {\n                        if (possibleSum[s - dec]) possibleSum[s] = true;\n                    }\n                }\n            }\n            if (!possibleSum[target]) { possible = false; }\n            free(possibleSum);\n            if (!possible) break;\n        }\n        if (possible) { ans = mid; hi = mid - 1; } else { lo = mid + 1; }\n    }\n    return ans;\n}\n","author":"kl2400031478","submissionId":"1575131301"},[]]},{"143":[{"id":"143","fileName":"1575132675.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n=len(nums)\n        if nums==[0]*n:return 0\n        ss=[1]*n\n        ans=0\n        for l,r,v in queries:\n            for i in range(l,r+1):ss[i]|=ss[i]<<v\n            ans+=1\n            if all(ss[i]>>nums[i]&1 for i in range(n)):return ans\n        return -1\n","author":"M Kawa","submissionId":"1575132675"},[]]},{"144":[{"id":"144","fileName":"1575133374.txt","sourceCode":"import java.util.*;\n\nclass Util {\n    public static int m(int a, int b) {\n        if(a < b) return a;\n        return b;\n    }\n    \n    public static int abs(int a) {\n        if(a < 0) return -a;\n        return a;\n    }\n}\n\nclass ok {\n    public boolean canSum(int t, int[] arr) {\n        if(t == 0) return true;\n        int l = t + 1;\n        boolean[] dp = new boolean[l];\n        dp[0] = true;\n        int i = 0;\n        while(i < arr.length) {\n            int x = arr[i];\n            int j = t;\n            while(j >= x) {\n                if(dp[j - x]) {\n                    dp[j] = true;\n                }\n                j--;\n            }\n            i++;\n        }\n        return dp[t];\n    }\n}\n\nclass QueryChecker {\n    public boolean check(int[] a, int[][] q, int k) {\n        int n = a.length;\n        ok sss = new ok();\n        int i = 0;\n        while(i < n) {\n            ArrayList<Integer> al = new ArrayList<>();\n            int j = 0;\n            while(j < k && j < q.length) {\n                int l = q[j][0];\n                int r = q[j][1];\n                int v = q[j][2];\n                if(i >= l && i <= r) {\n                    al.add(v);\n                }\n                j++;\n            }\n            int sz = al.size();\n            int[] arr = new int[sz];\n            int t = 0;\n            while(t < sz) {\n                arr[t] = al.get(t);\n                t++;\n            }\n            if(!sss.canSum(a[i], arr)) return false;\n            i++;\n        }\n        return true;\n    }\n}\n\nclass ZeroArrayChecker {\n    public boolean isZero(int[] a) {\n        int i = 0;\n        while(i < a.length) {\n            if(a[i] != 0) return false;\n            i++;\n        }\n        return true;\n    }\n}\n\nclass BinarySearchSolver {\n    public int search(int[] a, int[][] q) {\n        int l = 0;\n        int h = q.length;\n        int res = -1;\n        QueryChecker qc = new QueryChecker();\n        while(l <= h) {\n            int m = (l + h) / 2;\n            if(qc.check(a, q, m)) {\n                res = m;\n                h = m - 1;\n            } else {\n                l = m + 1;\n            }\n        }\n        return res;\n    }\n}\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        ZeroArrayChecker zc = new ZeroArrayChecker();\n        if(zc.isZero(nums)) return 0;\n        BinarySearchSolver bss = new BinarySearchSolver();\n        return bss.search(nums, queries);\n    }\n}\n","author":"nobita_10","submissionId":"1575133374"},[]]},{"145":[{"id":"145","fileName":"1575133495.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, n) for (ll i = (a); i < (n); ++i)\n#define loopD(i, a, n) for (ll i = (a); i >= (n); --i)\n#define sz(a) ((int)a.size())\n#define pb push_back\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nclass Solution {\npublic:\n    bool isPossible(int idx, int k, vi& arr, vvi& ops) {\n        int tgt = arr[idx];\n        vector<bool> dp(tgt + 1, false);\n        dp[0] = true;\n\n        loop(j, 0, k) {\n            int l = ops[j][0], r = ops[j][1], val = ops[j][2];\n            if (idx >= l && idx <= r) {\n                loopD(s, tgt, val) {\n                    dp[s] = dp[s] || dp[s - val];\n                }\n            }\n        }\n        return dp[tgt];\n    }\n\n    bool solve(int k, vi& arr, vvi& ops) {\n        loop(i, 0, sz(arr)) {\n            if (!isPossible(i, k, arr, ops))\n                return false;\n        }\n        return true;\n    }\n\n    int minZeroArray(vi& arr, vvi& ops) {\n        int low = 0, high = sz(ops) + 1;\n\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            if (solve(mid, arr, ops))\n                high = mid;\n            else\n                low = mid + 1;\n        }\n        return (low == sz(ops) + 1) ? -1 : low;\n    }\n};","author":"Nimish","submissionId":"1575133495"},[]]},{"146":[{"id":"146","fileName":"1575133529.txt","sourceCode":"#define vi vector<int>\n#define vvi vector<vi>\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\n#define F(i, a, b) for (int i = a; i < b; i++)\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = sz(a), m = sz(q);\n        vector<vector<bool>> dp(n, vector<bool>(1005, false));\n        F(i, 0, n) dp[i][0] = true;\n        bool chk = 1;\n        F(i, 0, n) if (a[i] != 0) { chk = 0; break; }\n        if (chk) return 0;\n        F(k, 0, m) {\n            int l = q[k][0], r = q[k][1], v = q[k][2];\n            F(i, l, r + 1) {\n                for (int j = 1000; j >= v; j--) {\n                    dp[i][j] = dp[i][j] || dp[i][j - v];\n                }\n            }\n            bool ok = 1;\n            F(i, 0, n) if (!dp[i][a[i]]) { ok = 0; break; }\n            if (ok) return k + 1;\n        }\n        return -1;\n    }\n};","author":"Ayan","submissionId":"1575133529"},[]]},{"148":[{"id":"148","fileName":"1575132204.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        if all(x == 0 for x in nums):\n            return 0\n\n        def subset_sum(goal, nums):\n            dp = [False] * (goal + 1)\n            dp[0] = True\n            for n in nums:\n                if n > goal:\n                    continue\n                for i in range(goal, n-1, -1):\n                    dp[i] |= dp[i-n]\n            return dp[goal]\n        def check(limit):\n            options = defaultdict(list)\n\n            for j in range(limit+1):\n                l,r,v = queries[j]\n                for i in range(l, r+1):\n                    options[i].append(v)\n\n            return all(subset_sum(n, options[i]) for i,n in enumerate(nums))\n\n        left = 0\n        right = len(queries)-1\n        while left <= right:\n            mid = (left+right)//2\n\n            if check(mid):\n                right = mid - 1\n            else:\n                left = mid + 1\n        if left == len(queries):\n            left = -1\n        return left + 1 if left != -1 else left\n\n            \n            \n\n        \n            ","author":"Kyle","submissionId":"1575132204"},[]]},{"149":[{"id":"149","fileName":"1575133785.txt","sourceCode":"\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int opr[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};\n        int qsize = queries.size();\n        for (int i = 0; i < n; ++i) {\n            vector<int> x(nums[i]+1, 0);\n            if (nums[i] == 0) {\n                opr[i] = 0;\n                continue;\n            }\n            x[nums[i]] = 1;\n            for (int qi = 0; qi < qsize; ++qi) {\n                int l = queries[qi][0], r = queries[qi][1], val = queries[qi][2];\n                if (l <= i && i <= r) {\n                    for (int j = 0; j <= nums[i]-val; j++) {\n                        x[j] |= x[j+val];\n                    }\n                }\n                if (x[0] == 1) {\n                    // cout << qi+1 << endl;\n                    opr[i] = qi+1;\n                    break;\n                }\n            }\n            // for (int j = 0; j <= nums[i]; j++) {\n            //     cout << x[j];\n            // }\n            // cout << endl;\n        }\n        int ret = -1;\n        for (int i = 0; i < n; ++i) {\n            if (opr[i] == -1) {\n                return -1;\n            }\n            ret = max(ret, opr[i]);\n        }\n        return ret;\n    }\n};","author":"qirunzeng","submissionId":"1575133785"},[]]},{"150":[{"id":"150","fileName":"1575134218.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size(); bool alZero = true;\n        for(int i = 0; i < n; i++){if(nums[i] != 0){alZero = false; break;}}\n        if (alZero) return 0;\n        auto canZero = [&](int k)->bool{\n            for(int j = 0; j < n; j++){\n                int target = nums[j]; bitset<1001> dp; dp.reset(); dp[0] = 1;\n                for(int i = 0; i < k; i++){if(queries[i][0] <= j && j <= queries[i][1]){int coin = queries[i][2]; dp |= (dp << coin);}}\n                if(!dp[target]) return false;\n            }\n            return true;\n        };\n        int low = 0, high = m, ans = -1;\n        while(low <= high){\n            int mid = low+(high-low)/2;\n            if(canZero(mid)){ans = mid; high = mid - 1;} \n            else low = mid + 1;\n        }\n        return ans;\n    }\n};","author":"TLE","submissionId":"1575134218"},[]]},{"151":[{"id":"151","fileName":"1575133160.txt","sourceCode":"class Solution:\n    def minZeroArray(self, A: List[int], Q: List[List[int]]) -> int:\n        if all(x == 0 for x in A): return 0\n            \n        def check(idx, x, qi=0):\n            s = {0}\n            for i in range(qi+1):\n                if Q[i][0] <= idx <= Q[i][1]:\n                    for y in s.copy():\n                        t = y + Q[i][2]\n                        if t <= x: s.add(t)\n            while qi+1 < len(Q) and x not in s:\n                qi += 1\n                l, r, v = Q[qi]\n                if Q[qi][0] <= idx <= Q[qi][1]:\n                    for y in s.copy():\n                        t = y + v\n                        if t <= x: s.add(t)\n            return qi if x in s else -1\n        qimx = 0\n        for i, x in enumerate(A):\n            qimx = check(i, x, qimx)\n            if qimx == -1: return -1\n        return qimx + 1","author":"delphih","submissionId":"1575133160"},[]]},{"152":[{"id":"152","fileName":"1575134398.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int> res(nums.size(), -1);\n        for (int i = 0; i < nums.size(); i++) {\n            int target = nums[i];\n            if (target == 0) {\n                res[i] = 0;\n                continue;\n            }\n            \n            vector<int> dp(target+1);\n            dp[0] = 1;\n            int cnt = 1;\n            for (auto & q : queries) {\n                if (q[0] <= i && i <= q[1]) {\n                    for (int w = target; w >= q[2]; w--) {\n                        dp[w] = dp[w] || dp[w-q[2]];\n                    }\n                }\n                \n                if (dp[target]) {\n                    break;\n                }\n                cnt++;\n            }\n            \n            if (dp[target])\n                res[i] = cnt;\n        }\n            \n        int ans = 0;\n        for (int i = 0; i < res.size(); i++) {\n            if (res[i] == -1)\n                return -1;\n            \n            ans = max(ans, res[i]);\n        }\n        return ans;\n    }\n};","author":"NaoJoeMiao","submissionId":"1575134398"},[]]},{"153":[{"id":"153","fileName":"1575134371.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n  int n = nums.size();\n\n        auto canMakeZeroArray = [&](int k) -> bool {\n            vector<vector<int>> indexVals(n);\n            for (int i = 0; i < k; ++i) {\n                int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n                for (int j = l; j <= r; ++j) {\n                    indexVals[j].push_back(val);\n                }\n            }\n\n            for (int i = 0; i < n; ++i) {\n                int target = nums[i];\n                if (target == 0) continue;\n\n                // Use subset sum DP with bitset\n                bitset<10001> dp;\n                dp[0] = 1;\n                for (int val : indexVals[i]) {\n                    dp |= (dp << val);\n                }\n\n                if (!dp[nums[i]]) return false;\n            }\n            return true;\n        };\n\n        if (all_of(nums.begin(), nums.end(), [](int x) { return x == 0; })) return 0;\n\n        int left = 1, right = queries.size();\n        if (!canMakeZeroArray(right)) return -1;\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (canMakeZeroArray(mid)) right = mid;\n            else left = mid + 1;\n        }\n\n        return left;\n    }\n};","author":"vivekpal24","submissionId":"1575134371"},[]]},{"154":[{"id":"154","fileName":"1575134954.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& queries) {\n        int have = 0, N = a.size();\n        vector dp(N, vector<bool>(1001, false));\n        for (int i = 0; i < N; i++) {\n            dp[i][a[i]] = 1;\n            if (a[i] == 0) have++;\n        }\n        if (have == N) return 0;\n        for (int q = 0; q < queries.size(); q++) {\n            int l = queries[q][0], r = queries[q][1], val = queries[q][2];\n            for (int i = l; i <= r; i++) {\n                if (!dp[i][0] && dp[i][val]) have++;\n                for (int j = val; j <= 1000; j++) if (dp[i][j]) dp[i][j - val] = 1;\n            }\n\n            if (have == N) return q + 1;\n        }\n        return -1;\n    }\n};","author":"__keep_it_simple__","submissionId":"1575134954"},[]]},{"155":[{"id":"155","fileName":"1575134993.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        n, q = len(nums), len(queries)\n        # Treat each number separately: look how many to get it to zero! (binary)\n        if all(nums[i] == 0 for i in range(n)):\n            return 0\n\n        def mink(i: int) -> int:\n            if nums[i] == 0:\n                return 0\n            vals = {nums[i]}\n            for j in range(q):\n                l, r, v = queries[j]\n                if not l <= i <= r:\n                    continue\n                newvals = set()\n                for val in vals:\n                    if val == v:\n                        return j\n                    if val > v:\n                        newvals.add(val-v)\n                vals.update(newvals)\n            return -1\n\n        ks = [mink(i) for i in range(n)]\n        # print(\"ksks\", ks)\n        if -1 in ks:\n            return -1\n        else:\n            return max(ks) + 1\n","author":"louissito","submissionId":"1575134993"},[]]},{"156":[{"id":"156","fileName":"1575135176.txt","sourceCode":"class Solution {\npublic:\n\n\nbool is_good(vector<int>& nums, vector<vector<int>>& queries, int n, int m, int mid)\n{\n    unordered_map<int, vector<int>> mp;\n    for(int i = 0; i < mid; ++i)\n        {\n            int val = queries[i][2];\n            for(int j = queries[i][0]; j <= queries[i][1]; ++j)\n                {\n                    mp[j].push_back(val);\n                }\n        }\n    int flag = 1;\n    for(int i = 0; i < n; ++i)\n        {\n            int a = nums[i];\n\n            vector<int> dp(a+1);\n            dp[0] = 1;\n            for(auto it : mp[i])\n                {\n                    int b = it;\n\n                    for(int j = a; j >= 0; --j)\n                        {\n                            if(j-b >= 0)\n                            {\n                                dp[j] = dp[j] | dp[j-b];\n                            }\n                        }\n                }\n\n            if(dp[a]==0)\n            {\n                flag = 0;\n            }\n        }\n    return flag;\n}\n\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n       int n = nums.size();\n        int m = queries.size();\n        int start = 0;\n        int end = m;\n\n        for(int i = 0; i < 30; ++i)\n            {\n                int mid = (start+end)/2;\n                if(is_good(nums, queries, n, m, mid))\n                {\n                    end = mid;\n                }\n                else\n                {\n                    start = mid;\n                }\n            }\n\n        if(is_good(nums, queries, n, m, m) == 0)\n        {\n            return -1;\n        }\n        return end;\n    }\n};","author":"Neerav","submissionId":"1575135176"},[]]},{"157":[{"id":"157","fileName":"1575134015.txt","sourceCode":"class Solution {\npublic:\n    bool valid(vector<int> &nums,vector<bool> &done,vector<set<int>> &v){\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            if(nums[i]==0) continue;\n            if(done[i]) continue; \n            if(v[i].count(nums[i])) {\n                done[i]=true;\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        vector<bool> done(n,false);\n        vector<set<int>> v(n);\n        if(valid(nums,done,v)) return 0;\n        int sz=queries.size();\n        for(int i=0;i<sz;i++){\n            int l=queries[i][0];\n            int r=queries[i][1];\n            int val=queries[i][2];\n            for(int k=l;k<=r;k++){\n                if(done[k]) {\n                    continue;\n                }\n                vector<int> tmp;\n                tmp.push_back(val);\n                for(auto i:v[k]){\n                    tmp.push_back(i+val);\n                }\n                while(!tmp.empty()){\n                    v[k].insert(tmp.back());\n                    tmp.pop_back();\n                }\n            }\n            if(valid(nums,done,v)) return i+1;\n        }\n        return -1;\n    }\n};","author":"Ritik Arora","submissionId":"1575134015"},[]]},{"158":[{"id":"158","fileName":"1575135417.txt","sourceCode":"#define f first\n#define s second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (long long)(x).size()\n#define pii pair<long long, long long>\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = sz(nums);\n        int K = 0;\n        vector<bitset<1001>> dp(n);\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = 1;\n        }\n\n        auto is_good = [&]() {\n            bool good = true;\n            for (int i = 0; i < n; i++) {\n                if (dp[i][nums[i]] == 0) {\n                    good = false;\n                    break;\n                }\n            }\n            return good;\n        };\n\n        for (auto x : queries) {\n            if (is_good()) {\n                return K;\n            }\n            K++;\n            int l = x[0], r = x[1];\n            int val = x[2];\n            for (int i = l; i <= r; i++) {\n                dp[i] = (dp[i] | (dp[i] << val));\n                dp[i][val] = 1;\n            }\n        }\n        if (is_good()) {\n            return K;\n        }\n        return -1;\n    }\n};","author":"Siddharth Joshi","submissionId":"1575135417"},[]]},{"159":[{"id":"159","fileName":"1575135591.txt","sourceCode":"#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, x) for(int i = 0; i < int(x); i++)\n#define all(x) (x).begin(), (x).end()\n\ntemplate<class T> inline bool chmax(T &a, T b){if (a < b) {a = b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T &a, T b){if (a > b) {a = b;return 1;}return 0;}\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size();\n        int m = q.size();\n        \n        auto judge = [&](int k) -> bool {\n            rep(i, n){\n                bitset<1101> dp;\n                dp.reset();\n                dp[0] = 1;\n                rep(j, k){\n                    if (q[j][0] <= i && i <= q[j][1]){\n                        dp |= dp << q[j][2];\n                    }\n                }\n                if (!dp.test(a[i])) return false;\n            }\n            return true;\n        };\n        \n        int lo = 0, hi = m+1;\n        while (lo < hi){\n            int mid = lo+(hi-lo)/2;\n            if(judge(mid)) hi = mid;\n            else lo = mid+1;\n        }\n        \n        return (lo == m+1 ? -1:lo);\n    }\n};","author":"t38178","submissionId":"1575135591"},[]]},{"160":[{"id":"160","fileName":"1575135716.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n\n        // base case\n        bool flag = true;\n        for(int i = 0 ; i < n ; i++){\n            if(nums[i] != 0){\n                flag = false;\n                break;\n            }\n        }\n\n        if(flag) return 0;\n\n\n        const int maxi = 1200;\n\n        for(int k = 0 ; k <= q ; k++){\n            bool all = true;\n\n            for(int i = 0 ; i < n ;i++){\n                bitset<maxi> dp;\n                dp.reset();\n                dp[0] = 1;\n\n                for(int j = 0 ; j < k ; j++){\n                    int l = queries[j][0];\n                    int r = queries[j][1];\n                    int val = queries[j][2];\n\n                    if(l <= i && i <= r){\n                        dp |= (dp << val);\n                    }\n                }\n\n                if(!dp[nums[i]]){\n                    all = false;\n                    break;\n                }\n            }\n            if(all) return k;\n        }\n        return -1;\n    }\n};","author":"Karan","submissionId":"1575135716"},[{"id":"1238","similarity":0.8547486033519553,"totOverlap":153,"longestOverlap":33}]],"1238":[{"id":"1238","fileName":"1575220500.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        bool az = true;\n        for (int i = 0; i < n; i++) {\n            if(nums[i] != 0) {\n                az = false;\n                break;\n            }\n        }\n        if(az) return 0;\n        \n        \n        for (int k = 1; k <= m; k++) {\n            bool ac = true;\n            for (int i = 0; i < n; i++) {\n                if(nums[i] == 0) continue;\n                \n                int target = nums[i];\n                bitset<1001> dp; \n                dp[0] = 1;\n                \n                for (int j = 0; j < k; j++) {\n                    int l = queries[j][0];\n                    int r = queries[j][1];\n                    int v = queries[j][2];\n                    if(i >= l && i <= r) {\n                        dp |= (dp << v);\n                    }\n                }\n                if (!dp[target]) {\n                    ac = false;\n                    break;\n                }\n            }\n            if(ac) return k;\n        }\n        return -1;\n    }\n};","author":"ch1","submissionId":"1575220500"},[{"id":"160","similarity":0.8547486033519553,"totOverlap":153,"longestOverlap":33}]]},{"161":[{"id":"161","fileName":"1575135931.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        k = -1\n        @cache\n        def solve(c, p, i):\n            if c == 0:\n                return 0\n            if i>=len(queries):\n                return float('Inf')\n\n            if queries[i][0]<=p and queries[i][1]>=p and c>=queries[i][2]:\n                return min(1+solve(c-queries[i][2], p, i+1), 1+solve(c, p, i+1))\n            return 1+solve(c, p, i+1)\n\n        for i, num in enumerate(nums):\n            curr = solve(num, i, 0)\n            if curr != float(\"inf\"):\n                k = max(k, curr)\n            else:\n                return -1\n        return k\n            \n        ","author":"Chitraksh Kumar","submissionId":"1575135931"},[]]},{"162":[{"id":"162","fileName":"1575136023.txt","sourceCode":"class Solution:\n    def minZeroArray(self, a: List[int], queries: List[List[int]]) -> int:\n        n = len(a)\n        d = defaultdict(list)\n        m = len(queries)\n        if a.count(0) == n:\n            return 0\n        for l, r, val in queries:\n            for i in range(l, r + 1):\n                d[i].append(val)\n            for i in range(l):\n                d[i].append(0)\n            for i in range(r + 1, n):\n                d[i].append(0)\n        ans = 0\n        for i in range(n):\n            v = a[i]\n            if not v:\n                continue\n            dp = [[10 ** 18 for i in range(v + 1)] for i in range(m + 1)]\n            dp[0][0] = 1\n            f = 0\n            for j in range(1, m + 1):\n                for val in range(v + 1):\n                    dp[j][val] = dp[j - 1][val]\n                    if val - d[i][j - 1] >= 0:\n                        dp[j][val] = min(dp[j][val], dp[j - 1][val - d[i][j - 1]])\n                    if val == v and dp[j][val] == 1:\n                        ans = max(ans, j)\n                        f = 1\n                        break\n                if f:\n                    break\n            if not f:\n                ans = -1\n                break\n        return ans","author":"Manan Rathod","submissionId":"1575136023"},[]]},{"163":[{"id":"163","fileName":"1575135746.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        List<Integer>[] covered = new List[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            covered[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < queries.length; i++) {\n            int[] q = queries[i];\n            for (int l = q[0]; l <= q[1]; l++) {\n                covered[l].add(i);\n            }\n        }\n        int min = -1;\n        for (int i = 0; i < nums.length; i++) {\n            int currMin = minZero(nums[i], covered[i], queries);\n            if (currMin == -1) {\n                return -1;\n            }\n            min = Math.max(min, currMin);\n        }\n        return min;\n    }\n\n    private int minZero(int target, List<Integer> covered, int[][] queries) {\n        if (target == 0) {\n            return 0;\n        }\n        boolean[] dp = new boolean[target + 1];\n\n        for (int ind : covered) {\n            int val = queries[ind][2];\n            if (val > target) {\n                continue;\n            }\n            boolean[] ndp = dp.clone();\n            for (int j = 0; j + val < dp.length; j++) {\n                if (dp[j] && j + val < dp.length) {\n                    ndp[j + val] = true;\n                }\n            }\n            ndp[val] = true;\n            if (ndp[target]) {\n                return ind + 1;\n            }\n            dp = ndp;\n        }\n\n        return -1;\n    }\n}","author":"Feng W","submissionId":"1575135746"},[]]},{"164":[{"id":"164","fileName":"1575136121.txt","sourceCode":"bool DP[1001];\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        bool allGood = true;\n        for (int i : nums) {\n            if (i) {\n                allGood = false;\n                break;\n            }\n        }\n        if (allGood) {\n            return 0;\n        }\n        vector <vector <int>> numbers(nums.size());\n        vector <int> sums(nums.size());\n        for (int i = 0; i != queries.size(); ++i) {\n            for (int j = queries[i][0]; j <= queries[i][1]; ++j) {\n                numbers[j].push_back(queries[i][2]);\n                sums[j] += queries[i][2];\n            }\n            allGood = true;\n            for (int j = 0; j != nums.size(); ++j) {\n                if (sums[j] < nums[j]) {\n                    allGood = false;\n                    break;\n                }\n                memset(DP, false, sizeof(DP));\n                DP[0] = true;\n                for (int k : numbers[j]) {\n                    for (int x = nums[j]; x >= k; --x) {\n                        DP[x] |= DP[x - k];\n                    }\n                }\n                if (!DP[nums[j]]) {\n                    allGood = false;\n                    break;\n                }\n            }\n            if (allGood) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"Peter Lin","submissionId":"1575136121"},[]]},{"165":[{"id":"165","fileName":"1575134246.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def chk(k):\n            for i, t in enumerate(nums):\n                if t == 0: continue\n                dp, m = 1, (1 << (t + 1)) - 1\n                for j in range(k):\n                    l, r, v = queries[j]\n                    if l <= i <= r:\n                        dp |= (dp << v) & m\n                if not ((dp >> t) & 1):\n                    return False\n            return True\n\n        lo, hi = 0, len(queries) + 1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if chk(mid):\n                hi = mid\n            else:\n                lo = mid + 1\n\n        return lo if lo <= len(queries) else -1","author":"G8QN4k9HON","submissionId":"1575134246"},[]]},{"166":[{"id":"166","fileName":"1575136060.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        if sum(nums) == 0:\n            return 0\n\n        dp = []\n        for i in range(n):\n            target = nums[i]\n            temp = [False] * (target + 1)\n            temp[0] = True\n            dp.append(temp)\n\n        for k, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                target = nums[i]\n                for s in range(target - val, -1, -1):\n                    if dp[i][s]:\n                        dp[i][s + val] = True\n            if all(dp[i][nums[i]] for i in range(n)):\n                return k + 1\n        return -1\n","author":"mmb L","submissionId":"1575136060"},[]]},{"167":[{"id":"167","fileName":"1575136164.txt","sourceCode":"class Solution {\npublic:\n    const int lim = 1010;\n    const int inf = 1010;\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int> dp(lim,0);\n        int ans = -1;\n        for(int i=0; i<nums.size(); i++){\n            for(int j=0; j<lim; j++) dp[j] = inf;\n            dp[nums[i]] = 0;\n            for(int j=0; j<queries.size(); j++){\n                int l = queries[j][0];\n                int r = queries[j][1];\n                int val = queries[j][2];\n                if(!(l <= i && i <= r)) continue;\n                for(int k=0; k<=nums[i]-val; k++) if(dp[k+val] != inf) dp[k] = min(dp[k], j+1);\n            }\n            // cout << dp[0] << ' ';\n            ans = max(ans, dp[0]);\n        }\n        return (ans == inf ? -1 : ans);\n    }\n};","author":"Felipe Sabino","submissionId":"1575136164"},[]]},{"168":[{"id":"168","fileName":"1575136496.txt","sourceCode":"#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAXN 400005\n\ntypedef struct {\n    int Shubh[MAXN], shub[MAXN];\n    int SHub;\n} Shubhra;\n\nvoid init(Shubhra *tree, int ShUb) {\n    tree->SHub = ShUb;\n    for (int i = 0; i < 4 * ShUb; i++) {\n        tree->Shubh[i] = 0;\n        tree->shub[i] = 0;\n    }\n}\n\nvoid build(Shubhra *tree, int *shubhr, int shubH, int shUbh, int shubh) {\n    if (shUbh == shubh) {\n        tree->Shubh[shubH] = shubhr[shUbh];\n        return;\n    }\n    int shUbH = (shUbh + shubh) / 2;\n    build(tree, shubhr, 2 * shubH + 1, shUbh, shUbH);\n    build(tree, shubhr, 2 * shubH + 2, shUbH + 1, shubh);\n    tree->Shubh[shubH] = tree->Shubh[2 * shubH + 1] + tree->Shubh[2 * shubH + 2];\n}\n\nvoid rangeUpdate(Shubhra *tree, int shubH, int shUbh, int shubh, int ShUbH, int shubHr, int SHubH) {\n    if (tree->shub[shubH] != 0) {\n        tree->Shubh[shubH] += (shubh - shUbh + 1) * tree->shub[shubH];\n        if (shUbh != shubh) {\n            tree->shub[2 * shubH + 1] += tree->shub[shubH];\n            tree->shub[2 * shubH + 2] += tree->shub[shubH];\n        }\n        tree->shub[shubH] = 0;\n    }\n    if (shUbh > shubHr || shubh < ShUbH)\n        return;\n    if (shUbh >= ShUbH && shubh <= shubHr) {\n        tree->Shubh[shubH] += (shubh - shUbh + 1) * SHubH;\n        if (shUbh != shubh) {\n            tree->shub[2 * shubH + 1] += SHubH;\n            tree->shub[2 * shubH + 2] += SHubH;\n        }\n        return;\n    }\n    int shUbH = (shUbh + shubh) / 2;\n    rangeUpdate(tree, 2 * shubH + 1, shUbh, shUbH, ShUbH, shubHr, SHubH);\n    rangeUpdate(tree, 2 * shubH + 2, shUbH + 1, shubh, ShUbH, shubHr, SHubH);\n    tree->Shubh[shubH] = tree->Shubh[2 * shubH + 1] + tree->Shubh[2 * shubH + 2];\n}\n\nlong long binExp(long long shubh, long long shubH, long long SHubH) {\n    long long shUb = 1;\n    while (shubH > 0) {\n        if (shubH & 1)\n            shUb = (shUb * shubh) % SHubH;\n        shubh = (shubh * shubh) % SHubH;\n        shubH >>= 1;\n    }\n    return shUb;\n}\n\nbool *sieve(int shubhr) {\n    bool *shUbH = (bool *)malloc((shubhr + 1) * sizeof(bool));\n    memset(shUbH, true, (shubhr + 1) * sizeof(bool));\n    shUbH[0] = shUbH[1] = false;\n    for (int shubh = 2; shubh * shubh <= shubhr; shubh++) {\n        if (shUbH[shubh]) {\n            for (int shubH = shubh * shubh; shubH <= shubhr; shubH += shubh) {\n                shUbH[shubH] = false;\n            }\n        }\n    }\n    return shUbH;\n}\n\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\n#define A 1000\n\nint minZeroArray(int* C, int D, int** E, int F, int* G) {\n    long long H[11][1001];\n    long long I[11];\n\n    long long J = 9876543210;\n    long long K = 1234567890;\n    long long L[100] = {0};\n    long long M[20][20] = {0};\n    long long N[200] = {0};\n    long long O[300] = {0};\n    long long P[50] = {0};\n    long long Q[50] = {0};\n    long long R[60] = {0};\n\n    long long S = 0;\n    while (S < D) {\n        long long T = 0;\n        while (T <= A) {\n            H[S][T] = 0;\n            T++;\n        }\n        H[S][0] = 1;\n        I[S] = -1;\n        S++;\n    }\n\n    for (S = 0; S < D; S++) {\n        if (C[S] == 0) {\n            I[S] = 0;\n        }\n    }\n\n    long long U;\n    for (U = 0; U < F; U++) {\n        long long V = E[U][0];\n        long long W = E[U][1];\n        long long X = E[U][2];\n\n        S = V;\n        while (S <= W) {\n            long long Y;\n            long long Z[1001];\n            for (Y = 0; Y <= A; Y++) {\n                Z[Y] = H[S][Y];\n            }\n\n            Y = 0;\n            while (Y <= A - X) {\n                if (H[S][Y] && !Z[Y + X]) {\n                    Z[Y + X] = 1;\n                }\n                Y++;\n            }\n\n            for (Y = 0; Y <= A; Y++) {\n                H[S][Y] = Z[Y];\n            }\n\n            if (I[S] == -1 && C[S] <= A && H[S][C[S]]) {\n                I[S] = U + 1;\n            }\n            S++;\n        }\n    }\n\n    long long a = 0;\n    S = 0;\n    while (S < D) {\n        if (!H[S][C[S]]) {\n            return -1;\n        }\n        if (I[S] > a) {\n            a = I[S];\n        }\n        S++;\n    }\n    return a;\n}\n\n\n","author":"Shubhra Awasthi","submissionId":"1575136496"},[]]},{"169":[{"id":"169","fileName":"1575136710.txt","sourceCode":"class Solution {\n    bool fn(vector<vector<int>> &temp, vector<int> &nums){\n        for (int i = 0; i < nums.size(); i++) {\n            if(nums[i]==0) continue;\n            vector<int> dp(nums[i]+1,0);\n            dp[0] = 1;\n            for(auto c : temp[i]){\n                for(int j = nums[i]; j>=c; --j){\n                    if(dp[j]==0) dp[j] = dp[j-c];\n                }\n            }   \n            if(dp[nums[i]]==0) return 0;\n        }            \n        return 1;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int s = 0, e = q.size(), ans  = -1, n = nums.size();\n        while(s<=e){\n            int m = (s+e)/2;\n            vector<vector<int>> temp(n);\n            for (int i = 0; i < m; ++i) {\n                for (int j = q[i][0]; j <= q[i][1]; ++j) {\n                    temp[j].push_back(q[i][2]);\n                }\n            }\n            if(fn(temp,nums)){\n                ans = m;\n                e = m-1;\n            }\n            else s = m+1;\n        }\n        return ans;\n    }\n};","author":"Swapnil Tyagi","submissionId":"1575136710"},[]]},{"170":[{"id":"170","fileName":"1575136826.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define R cin>>\n#define ll long long\n#define ln cout<<'n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10fn\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}\ntemplate<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?\" \":\"\");pr(b...);}\ntemplate<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nconst ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};\ntypedef pair<ll,ll> P;\n\nclass Solution {\npublic:\n  int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n    ll n=a.size();\n    ll d[n];fill(d,d+n,MAX);\n    rep(i,n) {\n      ll dp[a[i]+1];fill(dp,dp+a[i]+1,MAX);\n      dp[a[i]]=0;\n      rep(j,q.size()) {\n        ll l=q[j][0],r=q[j][1],z=q[j][2];\n        if(l<=i&&i<=r) {\n          rep(k,a[i]+1) {\n            if(k-z>=0&&dp[k]!=MAX) dp[k-z]=min(dp[k-z],j+1);\n          }\n        }\n      }\n      d[i]=dp[0];\n    }\n    ll ans=0;\n    rep(i,n) ans=max(ans,d[i]);\n    if(ans==MAX) ans=-1;\n    return ans;\n  }\n};\n","author":"kzyKT","submissionId":"1575136826"},[]]},{"171":[{"id":"171","fileName":"1575136729.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\n        int m = queries.size();\n        int times = 0;\n        for (int i = 0; i < nums.size(); ++i)\n            {\n                int val = nums[i];\n                vector<int> dp(1001, 0);\n                dp[0] = 1;\n\n                int k = 0;\n                for (k = 0; k < queries.size(); ++k)\n                    {\n                        if (dp[val] == 1)\n                        {\n                            times = max(times, k);\n                            break;\n                        }\n                        vector<int>& q = queries[k];\n                        if (q[0] > i || q[1] < i) continue;\n                        \n                        for (int t = val; t >= 0; --t)\n                        {\n                           if (t - q[2] < 0) continue;                           \n                           dp[t] = dp[t] | dp[t - q[2]]; \n                        }\n                        \n                    }\n            //    cout << k << endl;\n                \n                if (k == m)\n                {\n                    if (dp[val] == 1) times = max(times, m);\n                    else return -1;\n                }                 \n            }\n\n        return times;\n    }\n};","author":"pandapower","submissionId":"1575136729"},[]]},{"172":[{"id":"172","fileName":"1575137094.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = (int)nums.size();\n        int Q = (int)queries.size();\n        int lo = 0;\n        int hi = Q;\n        while (lo < hi) {\n            int k = (lo + hi) / 2;\n            bool allwork = true;\n            for (int i = 0; i < n; i++) {\n                int num = nums[i];\n                vector<bool> dp(num + 1);\n                dp[0] = true;\n                for (int q = 0; q < k; q++) {\n                    if (queries[q][0] <= i && i <= queries[q][1]) {\n                        int val = queries[q][2];\n\n                        for (int i = num; i >= val; i--) {\n                            dp[i] = dp[i] | dp[i-val];\n                        }\n                    }\n                }\n                if (!dp[num]) {\n                    allwork = false;\n                    break;\n                }\n            }\n\n            if (allwork) {\n                hi = k;\n            } else {\n                lo = k+1;\n            }\n        }\n        if (lo < Q) return lo;\n\n        bool allwork = true;\n        for (int i = 0; i < n; i++) {\n            int num = nums[i];\n            vector<bool> dp(num + 1);\n            dp[0] = true;\n            for (int q = 0; q < Q; q++) {\n                if (queries[q][0] <= i && i <= queries[q][1]) {\n                    int val = queries[q][2];\n    \n                    for (int i = num; i >= val; i--) {\n                        dp[i] = dp[i] | dp[i-val];\n                    }\n                }\n            }\n            if (!dp[num]) {\n                allwork = false;\n                break;\n            }\n        }\n\n        if (allwork) return Q;\n        return -1;\n    }\n};","author":"Shiva Oswal","submissionId":"1575137094"},[]]},{"173":[{"id":"173","fileName":"1575137549.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        \n        def min_k(i):\n            if nums[i] == 0:\n                return 0\n            \n            dct = {nums[i]}\n            n = 0\n            \n            for l, r, v in queries:\n                n += 1\n                if l <= i <= r:\n                    if v in dct:\n                        return n\n                    for x in list(dct):                        \n                        if (y := x - v) > 0:\n                            dct.add(y)\n            return -1\n        \n        ret = 0\n        \n        for i in range(len(nums)):\n            k = min_k(i)\n            if k == -1:\n                return -1\n            else:\n                ret = max(ret, k)\n        \n        return ret\n                ","author":"Only My Railgun","submissionId":"1575137549"},[]]},{"174":[{"id":"174","fileName":"1575137771.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] q) {\n        int ans = -1;\n        int n = nums.length;\n        int m = q.length;\n        for(int i = 0; i < n; i++) {\n            int[][] dp = new int[nums[i]+1][m];\n            for(int[] x : dp) {\n                Arrays.fill(x, 1000000);\n            }\n            int temp = rec(nums[i], q, 0, dp, i);\n            if(temp == 100000) return -1;\n            ans = Math.max(ans, temp);\n        }\n        return ans;\n    }\n\n    public int rec(int curr, int[][] q, int idx, int[][] dp, int m) {\n        if(curr == 0) return idx;\n        if(idx == q.length) return 100000;\n        if(dp[curr][idx] != 1000000) return dp[curr][idx];\n        dp[curr][idx] = rec(curr, q, idx+1, dp, m);\n        if(q[idx][0] <= m && m <= q[idx][1] && curr >= q[idx][2]) {\n            dp[curr][idx] = Math.min(dp[curr][idx], rec(curr - q[idx][2], q, idx+1, dp, m));\n        }\n        return dp[curr][idx];\n    }\n}","author":"chubbyseal","submissionId":"1575137771"},[]]},{"175":[{"id":"175","fileName":"1575138034.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        \n        maxElement = max(nums)\n        dp = [[[-1]*len(nums) for i in range(len(queries))] for j in range((maxElement+1))]\n        \n        def solve(num, i, j):\n            if num == 0: return i\n            elif i == len(queries): return inf\n            elif dp[num][i][j] != -1: return dp[num][i][j]\n            ans = solve(num, i+1, j)\n            l, r, val = queries[i]\n            if num >= val and l <= j <= r:\n                ans = min(ans, solve(num-val, i+1, j))\n            dp[num][i][j] = ans\n            return ans\n        ans = 0\n        for j in range(len(nums)):\n            ans = max(ans, solve(nums[j], 0, j))\n        if ans == inf: ans = -1\n        return ans\n        ","author":"Pankaj","submissionId":"1575138034"},[]]},{"176":[{"id":"176","fileName":"1575138129.txt","sourceCode":"def fun(n, k, arr):\n    # Initialize a 2D DP table with False values.\n    dp = [[False for j in range(k + 1)] for i in range(n)]\n    for i in range(n):\n        dp[i][0] = True\n    if arr[0] <= k:\n        dp[0][arr[0]] = True\n    \n    for ind in range(1, n):\n        for target in range(1, k + 1):\n            notTaken = dp[ind - 1][target]\n            taken = False\n            if arr[ind] <= target:\n                taken = dp[ind - 1][target - arr[ind]]\n            dp[ind][target] = notTaken or taken  \n    return dp[n - 1][k]\n\n\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        lo = 0\n        hi = len(queries)\n        \n        ans = -1\n        while(lo<=hi):\n            mid = (lo+hi)//2\n            def check(mid):\n                p = queries[:mid]\n                d = defaultdict(list)\n                for a,b,val in p:\n                    for k in range(a,b+1):\n                        d[k].append(val)\n                for i in range(len(nums)):\n                    req = d[i]\n                    if not req:\n                        if nums[i]==0:\n                            continue\n                        else:\n                            return False\n                    if not fun(len(req),nums[i],req):\n                        return False\n                return True\n            if check(mid):\n                ans = mid\n                hi = mid-1\n            else:\n                lo = mid+1\n        return ans","author":"Shivam Kumar","submissionId":"1575138129"},[]]},{"177":[{"id":"177","fileName":"1575138436.txt","sourceCode":"// -------------------------------------------------------------------\n// Shrishhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\n#define ll long long\n#define ld long double\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define vll vector<ll>\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define F first\n#define S second\n#define sz(x) ((int)(x).size())\n#define rep(i,a,b) for (int i = a; i < b; i++)\n#define per(i,a,b) for (int i = a; i >= b; i--)\n#define FOR(i,a,b) for (int i = a; i <= b; i++)\n#define ROF(i,a,b) for (int i = a; i >= b; i--)\n#define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\n// #define endl \"n\"\n#define mod 1000000007\n#define pi 3.14159265358979323846\n#define eps 1e-9\n\nclass Solution {\npublic:\n    int dfs(int i, int p, int c, int t, vector<vector<int>>& Q, int q, vector<vector<int>>& M) {\n        if(c==t)\n        {\n            return p;\n        }\n        if(p==q) \n        {\n            return q+1;\n        }\n        if (M[p][c]!=-1)\n        {\n            return M[p][c];\n        }\n        int b=q+1;\n        if(Q[p][0]<=i && i<=Q[p][1]) \n        {\n            int ns = c+ Q[p][2];\n            if (ns<=t) {\n                if (ns==t)\n                {\n                    b=min(b,p+1);\n                }\n                else \n                {\n                    b=min(b,dfs(i,p + 1,ns,t,Q,q,M));\n                }\n            }\n        }\n        b = min(b,dfs(i,p+1,c,t,Q,q,M));\n        M[p][c] = b;\n        return b;\n    }\n\n    int solve(int i, int t, vector<vector<int>>& Q, int q) {\n        vector<vector<int>> M(q + 1, vector<int>(t + 1, -1));\n        return dfs(i, 0, 0, t, Q, q, M);\n    }\n\n    int minZeroArray(vector<int>& N, vector<vector<int>>& Q) {\n        int n = N.size();\n        int q = Q.size();\n        auto v = mp(N, Q);\n        int ans = 0;\n        for (int i = 0; i < n; i++) \n        {\n            int t = N[i];\n            int e = solve(i,t,Q,q);\n            if (e > q) \n            {\n                return -1;\n            }\n            ans = max(ans, e);\n        }\n        return ans;\n    }\n};\n","author":"Shrishti Dubey","submissionId":"1575138436"},[]]},{"178":[{"id":"178","fileName":"1575138421.txt","sourceCode":"class Solution {\npublic:\n    bool is_zero(const vector<set<int>>& nums) {\n        for (const auto& s : nums) {\n            if (!s.contains(0))\n                return false;\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int k = 0;\n\n        const int l = nums.size();\n        vector<set<int>> nums2(l);\n        for (int i = 0; i < l; i++) {\n            int v = nums[i];\n            nums2[i].insert(v);\n        }\n        if (is_zero(nums2))\n            return k;\n\n        for (auto& v : queries) {\n            int li = v[0];\n            int ri = v[1];\n            int dv = v[2];\n\n            for (int i = li; i <= ri; i++) {\n                vector<int> new_vals;\n                for (int v : nums2[i]) {\n                    if (v >= dv)\n                        new_vals.push_back(v - dv);\n                }\n                for (int v : new_vals)\n                    nums2[i].insert(v);\n            }\n            k++;\n            if (is_zero(nums2))\n                return k;\n        }\n        return -1;\n    }\n};","author":"oserres","submissionId":"1575138421"},[]]},{"179":[{"id":"179","fileName":"1575138613.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        @cache\n        def solve(index, value, query):\n            if value < 0:\n                return inf\n            if value == 0:\n                return query\n            if query == len(queries):\n                return inf\n            k = solve(index, value, query + 1)\n            l, r, val = queries[query]\n            if l <= index <= r:\n                k = min(k, solve(index, value - val, query + 1))\n            return k\n        k = max((solve(i, nums[i], 0), solve.cache_clear())[0] for i in range(len(nums)))\n        return k if k < inf else -1","author":"Michael Yu","submissionId":"1575138613"},[]]},{"180":[{"id":"180","fileName":"1575138789.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ret=0, flag=0, l, r, d;\n        int dp[10][1001];\n        int n=nums.size();\n        for(int i=0; i<n; i++){\n            for(int j=0; j<1001; j++){\n                dp[i][j]=0;\n            }\n            dp[i][0]=1;\n            \n        }\n        \n        bool ifz=1;\n        for(int i=0; i<n; i++){\n            if(nums[i]){\n                ifz=0;\n            }\n        }\n        if(ifz){\n            return 0;\n        }\n\n        \n        for(auto u: queries){\n            l=u[0]; r=u[1]; d=u[2];\n            for(int i=l; i<=r; i++){\n                for(int j=1000; j>=d; j--){\n                    dp[i][j]|=dp[i][j-d];\n                }\n            }\n\n            ifz=1;\n            for(int i=0; i<n; i++){\n                if(!dp[i][nums[i]]){\n                    ifz=0;\n                }\n            }\n            ret++;\n            if(ifz){\n                flag=1;\n                break;\n            }\n        }\n\n        if(flag){\n            return ret;\n        }\n        else{\n            return -1;\n        }\n    }\n};","author":"coldspeed","submissionId":"1575138789"},[]]},{"181":[{"id":"181","fileName":"1575139110.txt","sourceCode":"#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef priority_queue<int> pq;\ntypedef priority_queue<int, vector<int>, greater<int>> pqg;\n#define fastio ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define sz(x) (int)(x).size()\n#define rep(i, a, b) for(int i = a; i < b; ++i)\n#define repr(i, a, b) for(int i = a; i >= b; --i)\n#define deb(x) cout << #x << \" = \" << x << endl;\n#define INF 1e9\n#define LINF 1e18\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int m = queries.size();\n        int lo = 0, hi = m, ans = -1;\n        while (lo <= hi) {\n            int mid = (lo + hi) / 2;\n            bool valid = true;\n            int n = nums.size();\n            for (int j = 0; j < n; j++) {\n                vector<int> vals;\n                for (int i = 0; i < mid; i++) {\n                    if (j >= queries[i][0] && j <= queries[i][1])\n                        vals.push_back(queries[i][2]);\n                }\n                int target = nums[j];\n                if (target == 0)\n                    continue;\n                int total = 0;\n                for (int d : vals)\n                    total += d;\n                if (total < target) {\n                    valid = false;\n                    break;\n                }\n                vector<bool> dp(target + 1, false);\n                dp[0] = true;\n                for (int d : vals) {\n                    for (int k = target; k >= d; k--)\n                        dp[k] = dp[k] || dp[k - d];\n                }\n                if (!dp[target]) {\n                    valid = false;\n                    break;\n                }\n            }\n            if (valid) {\n                ans = mid;\n                hi = mid - 1;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"miku","submissionId":"1575139110"},[]]},{"182":[{"id":"182","fileName":"1575139013.txt","sourceCode":"class Solution {\npublic:\n    int calculateEachNum(int val, int idx, vector<vector<int>>& queries) {\n        unordered_set<int> mySet;\n        mySet.insert(val);\n            \n        int ans = 0;\n        for(auto &query : queries) {\n            ans++;\n            \n            if(query[0] > idx || query[1] < idx) {\n                continue;\n            }\n                \n            auto decrement = query[2];\n            auto toAdd = vector<int>();\n            \n            for(auto i : mySet) {\n                if(i - decrement == 0) {\n                    return ans;\n                } else if (i - decrement > 0) {\n                    toAdd.push_back(i - decrement);\n                }\n            }\n            \n            for(auto i : toAdd) {\n                mySet.insert(i);\n            }\n        }\n        \n        return -1;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = 0;\n        \n        for(int idx = 0; idx < nums.size(); idx++) {\n            auto val = nums[idx];\n            if(val == 0) continue;\n            \n            auto t = calculateEachNum(val, idx, queries);\n            if(t < 0) {\n                return -1;\n            }\n            \n            ans = max(ans, t);\n        }\n        \n        return ans;\n    }\n};","author":"zxxxxy1998","submissionId":"1575139013"},[]]},{"183":[{"id":"183","fileName":"1575137576.txt","sourceCode":"class Solution {\npublic:\n    bitset<10001> dp;\n    bool canSum(vector<int>& f, int t){\n        if(t>10000) return false;\n        long long s=0;\n        for(int i=1;i<=10;i++) s+=1LL*i*f[i];\n        if(s<t) return false;\n        dp.reset();\n        dp[0]=1;\n        for(int i=1;i<=10;i++){\n            int c=f[i],base=1;\n            while(c>0){\n                int use=min(base,c);\n                int cost=use*i;\n                dp|=(dp<<cost);\n                c-=use;\n                base<<=1;\n            }\n        }\n        return dp[t];\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        \n        //algorithm\n        for(int x : nums){\n            if(x < 0 && x != 0) return -1;\n        }\n        bool allZero = true;\n        for(int x : nums){\n            if(x != 0){\n                allZero = false;\n                break;\n            }\n        }\n        if(allZero) return 0;\n\n        //ultinate algorithm\n        vector<vector<int>> freq(n,vector<int>(11,0));\n        for(int i=0; i<m; i++){\n            int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n            for(int j=l; j<=r; j++) freq[j][v]++;\n            bool flag = true;\n            for(int j=0; j<n; j++){\n                if(nums[j] > 0){\n                    if(!canSum(freq[j], nums[j])){\n                        flag = false;\n                        break;\n                    }\n                }\n            }\n            if(flag) return i+1;\n        }\n        return -1;\n    }\n};","author":"Koushik Debnath","submissionId":"1575137576"},[]]},{"184":[{"id":"184","fileName":"1575139179.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        // for each value, find the minimum number of queries we can use to reduce it\n        // O(n * max(nums[i]) * queries)\n        // O(queries * n * )\n        int n = nums.size(), k = 0;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0)\n                continue;\n            \n            set<int> visited;\n            visited.insert(0);\n            \n            for (int j = 0; j < queries.size(); j++) {\n                if (queries[j][0] > i || queries[j][1] < i)\n                    continue;\n                \n                set<int> nextVisited;\n                for (auto it = visited.rbegin(); it != visited.rend(); it++) {\n                    nextVisited.insert(*it + queries[j][2]);\n                    nextVisited.insert(*it);\n                }\n\n                visited = nextVisited;\n                \n                if (visited.find(nums[i]) != visited.end()) {\n                    k = max(k, j + 1);\n                    break;\n                }\n            }\n\n            if (visited.find(nums[i]) == visited.end())\n                return -1;\n        }\n\n        return k;\n    }\n};","author":"Matt Akin","submissionId":"1575139179"},[]]},{"185":[{"id":"185","fileName":"1575138853.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<int> required_k(n, -1);\n\n        for (int j = 0; j < n; ++j) {\n            int target = nums[j];\n            if (target < 0) return -1;\n            if (target == 0) {\n                required_k[j] = -1;\n                continue;\n            }\n\n            vector<pair<int, int>> Q_j;\n            for (int i = 0; i < m; ++i) {\n                int l = queries[i][0];\n                int r = queries[i][1];\n                int val = queries[i][2];\n                if (l <= j && j <= r) {\n                    Q_j.emplace_back(i, val);\n                }\n            }\n\n            if (Q_j.empty()) {\n                return -1;\n            }\n\n            sort(Q_j.begin(), Q_j.end());\n            unordered_map<int, int> dp;\n            dp[0] = -1;\n\n            for (auto& [i, val] : Q_j) {\n                unordered_map<int, int> new_dp = dp;\n                for (auto& [s, max_idx] : dp) {\n                    int new_s = s + val;\n                    if (new_s > target) continue;\n                    int new_max = max(max_idx, i);\n                    if (new_dp.find(new_s) == new_dp.end() || new_max < new_dp[new_s]) {\n                        new_dp[new_s] = new_max;\n                    }\n                }\n                dp.swap(new_dp);\n            }\n\n            if (dp.find(target) == dp.end()) {\n                return -1;\n            }\n            required_k[j] = dp[target];\n        }\n\n        int ans = 0;\n        for (int j = 0; j < n; ++j) {\n            if (nums[j] == 0) continue;\n            int current_k = required_k[j] + 1;\n            ans = max(ans, current_k);\n        }\n\n        if (ans == 0) {\n            for (int num : nums) {\n                if (num != 0) return -1;\n            }\n            return 0;\n        }\n\n        return ans;\n    }\n};","author":"Temp05","submissionId":"1575138853"},[]]},{"186":[{"id":"186","fileName":"1575139471.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, arr: List[int], ops: List[List[int]]) -> int:\n        size = len(arr)\n        op_count = len(ops)\n        def check_zero(k: int) -> bool:\n            idx = 0\n            while idx < size:\n                goal = arr[idx]\n                op_vals = []\n                q = 0\n                while q < k:\n                    a, b, c = ops[q]\n                    if a <= idx <= b:\n                        op_vals.append(c)\n                    q += 1\n                achievable = [False] * (goal + 1)\n                achievable[0] = True\n                v = 0\n                while v < len(op_vals):\n                    cur = op_vals[v]\n                    s = goal\n                    while s >= cur:\n                        if achievable[s - cur]:\n                            achievable[s] = True\n                        s -= 1\n                    v += 1\n                if not achievable[goal]:\n                    return False\n                idx += 1\n            return True\n\n        low_bound = 0\n        high_bound = op_count\n        result = -1\n        while low_bound <= high_bound:\n            mid = (low_bound + high_bound) // 2\n            if check_zero(mid):\n                result = mid\n                high_bound = mid - 1\n            else:\n                low_bound = mid + 1\n        return result","author":"Sujith Kumar K","submissionId":"1575139471"},[]]},{"187":[{"id":"187","fileName":"1575138954.txt","sourceCode":"\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n       \n        int[][] query = queries;\n        \n        int low = 0, high = queries.length;\n        int result = -1;\n        \n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (canSatisfy(nums, query, mid)) {\n                result = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        \n        return result;\n    }\n\n    private boolean canSatisfy(int[] nums, int[][] queries, int k) {\n        int n = nums.length;\n       \n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n\n            ArrayList<Integer> values = new ArrayList<>();\n            for (int j = 0; j < k; j++) {\n                int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                if (i >= l && i <= r) {\n                    values.add(val);\n                }\n            }\n         \n            boolean[] dp = new boolean[target + 1];\n            dp[0] = true;\n            for (int val : values) {\n                for (int s = target; s >= val; s--) {\n                    dp[s] = dp[s] || dp[s - val];\n                }\n            }\n            if (!dp[target]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n","author":"Aaditya Sehgal","submissionId":"1575138954"},[]]},{"188":[{"id":"188","fileName":"1575139670.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        # determine for each element, what's the minium k such that element becomes 0\n        n = len(nums)\n        kArr = [-1 for _ in range(n)]\n        for i in range(n):\n            if nums[i] == 0:\n                kArr[i] = 0\n                continue\n                \n            s = set([nums[i]])\n            for k, [l, r, val] in enumerate(queries, 1):\n                if l <= i <= r:\n                    # update cur\n                    new_s = set()\n                    for v in s:\n                        new_s.add(v)\n                        new_s.add(v - val)\n                    s = new_s\n                    if 0 in s:\n                        kArr[i] = k\n                        break\n\n        return max(kArr) if -1 not in kArr else -1\n                        \n                    ","author":"gambler147","submissionId":"1575139670"},[]]},{"189":[{"id":"189","fileName":"1575140021.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        k = 0\n        for i,x in enumerate(nums):\n            if x:\n                d = {x:True}\n                for j,q in enumerate(queries):\n                    l,r,v = q\n                    if l <= i <= r:\n                        if v in d:\n                            k = max(k,j+1)\n                            break\n                        for val in list(d.keys()):\n                            if val > v:\n                                d[val-v] = True\n                else:\n                    return -1\n        return k","author":"Carisa-Li","submissionId":"1575140021"},[]]},{"190":[{"id":"190","fileName":"1575139389.txt","sourceCode":"class Solution:\n    def solveFunc(self):\n        class FenwickTree:\n            def __init__(self, n):\n                self.farr = [0] * (n + 1)\n\n            def prefixSum(self, idx):\n                s = 0\n                while idx > 0:\n                    s += self.farr[idx]\n                    idx -= (idx & -idx)\n                return s\n\n            def update(self, idx, val):\n                while idx < len(self.farr):\n                    self.farr[idx] += val\n                    idx += (idx & -idx)\n\n            def find(self, k):\n                curr = 0\n                ans = 0\n                prevSum = 0\n                for i in range(log2(k), -1, -1):\n                    if self.farr[curr + (i << i)] + prevSum < k:\n                        curr += (1 << i)\n                        prevSum += self.farr[curr]\n                return curr + 1\n\n\n    def can_z(self, n, q, k, i, t):\n        d, m = 1, (1 << (t + 1)) - 1\n        for j in range(k):\n            l, r, v = q[j]\n            if l <= i <= r:\n                d |= (d << v) & m\n        return (d >> t) & 1\n\n    def zFunction(self, patt, txt):\n        st = patt + \"#\" + txt\n        zArray = [0] * len(st)\n        l, r = 0, 0\n        for i in range(1, len(st)):\n            if r >= i:\n                zArray[i] = min(r - i + 1, zArray[i - l])\n            while i + zArray[i] < len(st) and st[zArray[i]] == st[zArray[i] + i]:\n                zArray[i] += 1\n            if zArray[i] + i - 1 > r:\n                l, r = i, i + zArray[i] - 1\n        return zArray.count(len(patt))\n\n    \n\n    def minZeroArray(self, nums, queries):\n        return self.bs(nums, queries)\n\n    def kmp(self, txt, patt):\n        newString = patt + '#' + txt\n        freqCount = 0\n        freqArray = [0] * len(newString)\n        i, length = 1, 0\n        while i < len(newString):\n            if newString[i] == newString[length]:\n                length += 1\n                freqArray[i] = length\n                i += 1\n            else:\n                length = freqArray[length - 1] if length > 0 else 0\n                if length == 0:\n                    freqArray[i] = 0\n                    i += 1\n        return freqArray.count(len(patt))\n\n    \n\n    def bs(self, n, q):\n        lo, hi = 0, len(q) + 1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if self.apply_q(n, q, mid):\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo if lo <= len(q) else -1\n\n    def countVisibleTowers(self, heights):\n        n = len(heights)\n\n        def nsr(arr):\n            ans, stack = [], []\n            for i in range(len(arr) - 1, -1, -1):\n                while stack and stack[-1][1] <= arr[i]:\n                    stack.pop()\n                ans.append(stack[-1][0] if stack else len(arr))\n                stack.append([i, arr[i]])\n            return ans[::-1]\n\n        def nsl(arr):\n            ans, stack = [], []\n            for i in range(len(arr)):\n                while stack and stack[-1][1] <= arr[i]:\n                    stack.pop()\n                ans.append(stack[-1][0] if stack else -1)\n                stack.append([i, arr[i]])\n            return ans\n\n        left, right = nsl(heights), nsr(heights)\n        return [(i - left[i] - 1 + right[i] - i - 1) for i in range(n)]\n\n    def apply_q(self, n, q, k):\n        for i, t in enumerate(n):\n            if t == 0: continue\n            if not self.can_z(n, q, k, i, t):\n                return False\n        return True\n","author":"4bP7qaO8Qi","submissionId":"1575139389"},[]]},{"191":[{"id":"191","fileName":"1575140092.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums,vector<vector<int>>& queries) {\n        int n=nums.size();\n        vector<vector<int>>dp(n);\n        for(int i=0;i<n;++i)\n        {\n            dp[i].assign(nums[i]+1,0),dp[i][0]=1;\n        }\n        if(ranges::all_of(nums,[](int x){return x==0;}))return 0;\n        for(int k=0;k<queries.size();++k)\n        {\n            int l=queries[k][0],r=queries[k][1],q=queries[k][2];\n            for(int i=l;i<=r;++i)\n            {\n                for(int j=max(0,nums[i]-q);~j;--j)\n                {\n                    if(dp[i][j] && j+q<=nums[i])dp[i][j+q]=1;\n                }\n            }\n            int ok=1;\n            for(int i=0;i<n;++i)\n            {\n                if(!dp[i][nums[i]])\n                {\n                    ok=0;\n                    break;\n                }\n            }\n            if(ok)return k+1;\n        }\n        return -1;\n    }\n};","author":"Rajat","submissionId":"1575140092"},[]]},{"192":[{"id":"192","fileName":"1575139338.txt","sourceCode":"class Solution {\npublic:\n  int minZeroArray(vector<int>& a, vector<vector<int>>& b) {\n    int n = (int) a.size();\n    if (count(a.begin(), a.end(), 0) == n) {\n      return 0;\n    }\n    int m = (int) b.size();\n    vector<vector<pair<int, int>>> ops(n);\n    for (int j = 0; j < m; j++) {\n      for (int k = b[j][0]; k <= b[j][1]; k++) {\n        ops[k].emplace_back(b[j][2], j);\n      }\n    }\n    const int INF = (int) 1e9;\n    int ans = -1;\n    auto Work = [&](int x, vector<pair<int, int>>& a) -> int {\n      if (x == 0) {\n        return 0;\n      }\n      if ((int) a.size() == 0) {\n        return INF;\n      }\n      int n = (int) a.size();\n      vector<vector<bool>> dp(n + 1, vector<bool>(x + 1));\n      dp[0][0] = true;\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= x; j++) {\n          if (dp[i][j]) {\n            dp[i + 1][j] = true;\n            if (j + a[i].first <= x) {\n              dp[i + 1][j + a[i].first] = true;\n            }\n          }\n        }\n      }\n      for (int i = 0; i <= n; i++) {\n        if (dp[i][x]) {\n          assert(i > 0);\n          return a[i - 1].second;\n        }\n      }\n      return INF;\n    };\n    for (int i = 0; i < n; i++) {\n      ans = max(ans, Work(a[i], ops[i]));\n    }\n    return ans == INF ? -1 : ans + 1;\n  }\n};","author":"C0ldSmi1e","submissionId":"1575139338"},[]]},{"193":[{"id":"193","fileName":"1575140418.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length, m = 10005, ans = -1;\n        if (Arrays.stream(nums).max().getAsInt() == 0) return 0;\n        boolean[][] dp = new boolean[n][m + 1];\n        for (int i = 0; i < queries.length; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[j][0] = true;\n            }\n            boolean flg = true;\n            for (int j = queries[i][0]; j <= queries[i][1]; j++) {\n                int v = queries[i][2];\n                for (int l = nums[j]; l >= v; l--) {\n                    dp[j][l] |= dp[j][l - v];\n                }\n            }\n            for (int j = 0; j < n; j++) {\n                if (!dp[j][nums[j]]) flg = false;\n            }\n            if (flg) return i + 1;\n        }\n        return -1;\n    }\n}","author":"alicezhangmeijun","submissionId":"1575140418"},[]]},{"194":[{"id":"194","fileName":"1575140446.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size();\n        \n        int fl = 1;\n        for(int i=0; i<n; i++){\n            if(a[i] != 0){\n                fl = 0;\n                break;\n            }\n        }\n        \n        if(fl) return 0;\n        \n        int m = q.size();\n        vector<vector<int>> dp(n, vector<int>(1010, 0));\n        for(int j=0; j<n; j++) dp[j][0] = 1;\n        \n        for(int i=0; i<m; i++){\n            int l = q[i][0], r = q[i][1], val = q[i][2];\n            for(int j=l; j<=r; j++) {\n                for(int p=1000-val; p>=0; p--){\n                    if(dp[j][p]) dp[j][p+val] = 1;\n                    // cout << dp[j][p] << \" \";\n                }\n            }\n            \n            int f = 1;\n            for(int j=0; j<n; j++){\n                if(!dp[j][a[j]]){\n                    f = 0;\n                    break;\n                }\n                // cout << dp[j][a[j]] << \" \";\n            }\n            if(f) return i+1;\n        }\n        return -1;\n    }\n};","author":"Ashutosh Kumar","submissionId":"1575140446"},[]]},{"195":[{"id":"195","fileName":"1575140611.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size();\n        bool cc = false;\n        for(auto &x : a)if(x)cc = true;\n        if(!cc)return 0;\n        int lo = 0, hi = q.size()-1, mid;\n        while(lo<=hi) {\n            mid = (lo+hi)/2;\n            vector<vector<int>> add(n+1);\n            for(int i=0; i<=mid; i++) {\n                for(int j = q[i][0]; j<=q[i][1]; j++)add[j].push_back(q[i][2]);\n            }\n            auto find = [&](int val, vector<int> &temp) -> bool {\n                vector<vector<int>> dp(1+temp.size(), vector<int>(val+1));\n                for(int i = 1; i<=temp.size(); i++) {\n                    dp[i-1][val] = 1;\n                    for(int j = 0; j<=val; j++) {\n                        dp[i][j] = dp[i-1][j];\n                        if(temp[i-1]+j<=val)dp[i][j] = max(dp[i-1][j+temp[i-1]], dp[i][j]);\n                    }\n                }\n                return (dp[temp.size()][0]>=1);\n            };\n            \n            bool f = true;\n            for(int i = 0; i<n; i++) {\n                if(!find(a[i], add[i])) {\n                    f=false;\n                    break;\n                }\n            }\n            if(f) {\n                hi = mid-1;\n            } else lo = mid+1;\n        }\n        if(lo == q.size())return -1;\n        return lo+1;\n    }\n    \n};","author":"Divyansh Bisht","submissionId":"1575140611"},[]]},{"196":[{"id":"196","fileName":"1575140509.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        ans, lf, rg = -1, 0, len(queries)\n        while lf <= rg:\n            mid = (lf + rg) // 2\n            if self._feasible(nums, queries, mid):ans,rg = mid, mid - 1\n            else:lf = mid + 1\n        return ans\n    def _feasible(self, nums: List[int], queries: List[List[int]], k: int) -> bool:\n        n = len(nums)\n        cose = [[] for _ in range(n)]\n        list(map(lambda q: [cose[i].append(q[2]) for i in range(q[0], q[1] + 1)], queries[:k]))\n        for i in range(n):\n            if not self._subset_sum_possible(cose[i], nums[i]): return False\n        return True\n    def _subset_sum_possible(self, arr: List[int], target: int) -> bool:\n        ach = {0}\n        for x in arr:\n            nach = set(ach)\n            for s in ach:\n                s2 = s + x\n                if s2 == target:return True\n                if s2 < target:nach.add(s2)\n            ach = nach\n        return (target in ach)","author":"cosmic-striker","submissionId":"1575140509"},[]]},{"197":[{"id":"197","fileName":"1575140736.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n               \n        def works(mid):\n            q = queries[:mid]\n            for i in range(n):\n                dp = 1\n                for l,r,v in q:\n                    if l <= i <= r:\n                        dp |= dp << v\n                if not dp & (1 << nums[i]):\n                    return False\n            return True\n                \n        \n        low = 0\n        high = len(queries)\n        ans = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if works(mid):\n                high = mid - 1\n                ans = mid\n            else:\n                low = mid + 1\n        return ans","author":"Patchy","submissionId":"1575140736"},[]]},{"198":[{"id":"198","fileName":"1575140132.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n       \n        int n=nums.size();\n        int sz=queries.size();\n        \n        int lo=0,hi=sz,ret=sz+1;\n        \n        while(hi>=lo){\n            int mid=(hi+lo)/2;\n            \n            set<int> poss[n];\n            for(int i=0;i<n;i++){\n                poss[i].insert(0);\n            }\n            \n            for(int i=0;i<mid;i++){\n                \n                int l=queries[i][0];\n                int r=queries[i][1];\n                int val=queries[i][2];\n                \n                \n                for(int j=l;j<=r;j++){\n                    \n                    if(poss[j].find(nums[j]) != poss[j].end()){\n                        continue;\n                    }\n                    \n                    set<int> ex;\n                    \n                    for(auto p:poss[j]){\n                        if(p + val <= nums[j]){\n                            ex.insert(p+val);\n                        }\n                    }\n                    \n                    for(auto p:ex){\n                        poss[j].insert(p);\n                    }\n                    \n                }\n                \n                \n                \n            }\n            \n            int f=1;\n            for(int i=0;i<n;i++){\n                if(poss[i].find(nums[i]) == poss[i].end()){\n                    f=0;\n                    break;\n                }\n            }\n            \n            if(f){\n                ret=min(ret,mid);\n                hi=mid-1;\n            }else{\n                lo=mid+1;\n            }\n        }\n        \n        \n        if(ret==sz+1){\n            ret=-1;\n        }\n        \n        return ret;\n    }\n};","author":"Harikrishna Shenoy","submissionId":"1575140132"},[]]},{"199":[{"id":"199","fileName":"1575140827.txt","sourceCode":"class Solution {\n  // needs to compute possible range\n  // n <= 10, val <= 1000, qs.length <= 1000\n  // for each index, do the computation\n  // do a dp\n  public int minZeroArray(int[] nums, int[][] qs) {\n    int n = nums.length;\n\n    int res = 0;\n    for (int i = 0; i < n; i++) {\n      int tmp = compute(i, nums[i], qs);\n      if (tmp == -1) return tmp;\n\n      res = Math.max(res, tmp);\n    }\n    return res;\n  }\n\n  private int compute(int idx, int val, int[][] qs) {\n    if (val == 0) return 0;\n    \n    boolean[] dp = new boolean[val + 1];\n    dp[val] = true;\n\n    for (int i = 0; i < qs.length; i++) {\n      int[] q = qs[i];\n      if (q[1] < idx || q[0] > idx) continue;\n\n      boolean[] cur = dp.clone();\n      for (int j = val; j >= q[2]; j--) if (dp[j]) {\n        cur[j - q[2]] = true;\n      }\n      if (cur[0]) return i + 1;\n\n      dp = cur;\n    }\n    return -1;\n  }\n}","author":"DCDC","submissionId":"1575140827"},[]]},{"200":[{"id":"200","fileName":"1575140839.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        bool all_zero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                all_zero = false;\n                break;\n            }\n        }\n        if (all_zero) {\n            return 0;\n        }\n        int min_queries = 0;\n        vector<bool> possible_values(1005, false);\n        for (int num_idx=0; num_idx < nums.size(); ++num_idx) {\n            int num = nums[num_idx];\n            // how many queries until we can reach 0?\n            std::fill(possible_values.begin(), possible_values.end(), false);\n            possible_values[num] = true;\n            for (int k=0; k < queries.size(); ++k) {\n                int left = queries[k][0];\n                int right = queries[k][1];\n                int val = queries[k][2];\n                if (left <= num_idx && num_idx <= right) {\n                    for (int j=val; j <= num; ++j) {\n                        if (possible_values[j]) {\n                            possible_values[j-val] = true;\n                        }\n                    }\n                }\n                if (possible_values[0]) {\n                    min_queries = max(min_queries, k+1);\n                    break;\n                }\n            }\n            if (!possible_values[0]) {\n                // never possible\n                return -1;\n            }\n        }\n        return min_queries;\n    }\n};","author":"Daniel Keyes","submissionId":"1575140839"},[]]},{"201":[{"id":"201","fileName":"1575140912.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums, queries):\n        if all(x==0 for x in nums): return 0\n        n=len(nums)\n        c=[[] for _ in range(n)]\n        for i, (l, r, v) in enumerate(queries):\n            for j in range(l, r+1):\n                c[j].append((i, v))\n        for j in range(n):\n            c[j].sort(key=lambda x: x[0])\n        b=[1 for _ in range(n)]\n        p=[0] * n\n        for k in range(len(queries) + 1):\n            ok = True\n            for j in range(n):\n                while p[j] < len(c[j]) and c[j][p[j]][0] < k:\n                    v = c[j][p[j]][1]\n                    b[j] = b[j] | (b[j] << v)\n                    p[j] += 1\n                if nums[j] < 0 or nums[j] >= b[j].bit_length() or not(b[j] & (1<<nums[j])):\n                    ok = False\n                    break\n            if ok: return k\n                \n        return -1\n","author":"lydxlx","submissionId":"1575140912"},[]]},{"202":[{"id":"202","fileName":"1575140848.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        List<List<int[]>> elementQueries = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            elementQueries.add(new ArrayList<>());\n        }\n\n        for (int qIdx = 0; qIdx < m; qIdx++) {\n            int[] q = queries[qIdx];\n            int l = q[0];\n            int r = q[1];\n            int val = q[2];\n            for (int i = l; i <= r; i++) {\n                elementQueries.get(i).add(new int[]{qIdx, val});\n            }\n        }\n\n        int[] k_i = new int[n];\n        Arrays.fill(k_i, -1);\n\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) {\n                continue;\n            }\n\n            List<int[]> qList = elementQueries.get(i);\n            Map<Integer, Integer> dp = new HashMap<>();\n            dp.put(0, -1);\n\n            for (int[] q : qList) {\n                int qIdx = q[0];\n                int val = q[1];\n                Map<Integer, Integer> newDp = new HashMap<>(dp);\n\n                for (Map.Entry<Integer, Integer> entry : dp.entrySet()) {\n                    int s = entry.getKey();\n                    int currentK = entry.getValue();\n                    int newS = s + val;\n\n                    if (newS > nums[i] || val > (nums[i] - s)) {\n                        continue;\n                    }\n\n                    int newK = Math.max(currentK, qIdx);\n                    if (!newDp.containsKey(newS) || newK < newDp.get(newS)) {\n                        newDp.put(newS, newK);\n                    }\n                }\n\n                dp = newDp;\n            }\n\n            if (dp.containsKey(nums[i])) {\n                k_i[i] = dp.get(nums[i]);\n            } else {\n                return -1;\n            }\n        }\n\n        int maxK = -1;\n        for (int k : k_i) {\n            maxK = Math.max(maxK, k);\n        }\n\n        if (maxK == -1) {\n            return 0;\n        } else {\n            return maxK + 1;\n        }\n    }\n}","author":"Suraj Chaudhary","submissionId":"1575140848"},[]]},{"203":[{"id":"203","fileName":"1575141257.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int q = queries.size();\n        int n = nums.size();\n        vector<int> limits;\n        for (int i = 0; i < n; i++) {\n            vector<bool> vis;\n            for (int j = 0; j <= nums[i]; j++) {\n                vis.push_back(false);\n            }\n            vis[0] = true;\n            int ans = -1;\n            for (int j = 0; j < q; j++) {\n                if (vis[nums[i]] == true) {\n                    ans = j;\n                    break;\n                }\n                int l = queries[j][0];\n                int r = queries[j][1];\n                int v = queries[j][2];\n                if (l > i || r < i) {\n                    continue;\n                }\n                for (int k = nums[i]; k >= v; k--) {\n                    vis[k] = vis[k] || vis[k - v];\n                }\n                // for (int k = 0; k <=nums[i]; k++) {\n                //     printf(\"%d\", vis[k]?1:0);\n                // }\n                // printf(\" %d n\", ans);\n            }            \n            if (ans == -1 && vis[nums[i]] == true) {\n                ans = q;\n            }\n            limits.push_back(ans);\n        }\n\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (limits[i] == -1) {\n                return -1;\n            }\n            res = max(res, limits[i]);\n        }\n\n\n        return res;\n    }\n};","author":"loriex","submissionId":"1575141257"},[]]},{"204":[{"id":"204","fileName":"1575141490.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        dp = [[False] * 1005 for _ in range(len(nums))]\n        for i in range(len(nums)):\n            dp[i][0] = True\n\n        resolve = len([d for d in nums if d > 0])\n        good = [True if d == 0 else False for d in nums]\n        if resolve == 0:\n            return 0\n            \n        for i, (l, r, v) in enumerate(queries):\n            for j in range(l, r+1):\n                if good[j]:\n                    continue\n                n = nums[j]\n                if n-v >= 0 and dp[j][n-v]:\n                    good[j] = True\n                    resolve -= 1\n                else:\n                    for k in range(n-v, -1, -1):\n                        if dp[j][k]:\n                            dp[j][k+v] = True\n            \n            if resolve == 0:\n                return i + 1\n\n        return -1\n            ","author":"Andrei Cioara","submissionId":"1575141490"},[]]},{"205":[{"id":"205","fileName":"1575142206.txt","sourceCode":"class Solution {\npublic:\n  int minZeroArray(vector<int> &a, vector<vector<int>> &q) {\n    int n = a.size(), m = q.size();\n    int lb = -1, rb = m + 1;\n    while (rb - lb > 1) {\n      int mb = (lb + rb) >> 1;\n      vector<vector<int>> d(n + 1);\n      vector<int> cur;\n      for (int i = 0; i < mb; i++) {\n        d[q[i][0]].push_back(q[i][2]);\n        d[q[i][1] + 1].push_back(-q[i][2]);\n      }\n      bool ok = true;\n      multiset<int> st;\n      for (int i = 0; i < n; i++) {\n        for (int v : d[i]) {\n          if (v < 0) {\n            st.erase(st.find(-v));\n          } else {\n            st.insert(v);\n          }\n        }\n        vector<int> dp(a[i] + 1);\n        dp[a[i]] = true;\n        for (int v : st) {\n          for (int sum = v; sum <= a[i]; sum++) {\n            dp[sum - v] |= dp[sum];\n          }\n        }\n        ok &= dp[0];\n      }\n      if (ok) {\n        rb = mb;\n      } else {\n        lb = mb;\n      }\n    }\n    return rb > m ? -1 : rb;\n  }\n};","author":"Sam Huang","submissionId":"1575142206"},[]]},{"206":[{"id":"206","fileName":"1575141344.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:        \n        n, m = len(nums), len(queries)\n        l, r = 0, m + 1\n        \n        def possible(k):\n            if not k:\n                return all(not num for num in nums)\n\n            for i, num in enumerate(nums):\n                candidates = []\n                for j in range(k):\n                    start, end, delta = queries[j]\n                    if start <= i <= end:\n                        candidates.append(delta)\n                \n                candidates.sort()\n                t = len(candidates)\n                \n                dp = [[False] * (num + 1) for _ in range(t + 1)]\n                dp[0][0] = True\n                \n                for x in range(1, t + 1):\n                    for y in range(num + 1):\n                        dp[x][y] |= dp[x - 1][y]\n                        if y - candidates[x - 1] >= 0:\n                            dp[x][y] |= dp[x - 1][y - candidates[x - 1]]\n\n                if not dp[t][num]:\n                    return False\n            \n            return True\n        \n        while l < r:\n            mid = (l + r) // 2\n            if not possible(mid):\n                l = mid + 1\n            else:\n                r = mid\n        \n        if l == m + 1:\n            return -1\n        return l\n                ","author":"gan14008","submissionId":"1575141344"},[]]},{"207":[{"id":"207","fileName":"1575141602.txt","sourceCode":"/*\n  JAI JAGANNATH!\n*/\n//@Author : zanj0\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ff              first\n#define ss              second\n#define pb              push_back\n#define MOD             1000000007\n#define inf             1e18\n\ntypedef long long int lli;\n\n\nclass Solution {\npublic:\n  lli n;\n  bool Check(lli required, vector<lli>& v) {\n    vector<lli> dp(required + 1);\n    dp[0] = 1;\n    for (auto& it : v) {\n      for (lli i = required; i - it >= 0; i--) {\n        dp[i] = max(dp[i], dp[i - it]);\n          if(dp[required]) return true;\n      }\n    }\n    return dp[required];\n  }\n  bool Ok(lli k, vector<vector<int>>& queries, vector<int>& nums) {\n\n    vector<vector<lli>> v(n);\n    lli take = k + 1;\n    for (auto& it : queries) {\n        if (take == 0) break;\n      take--;\n      \n      for (lli i = it[0]; i <= it[1]; i++) {\n        v[i].pb(it.back());\n      }\n    }\n\n    bool ret = true;\n    for (lli i = 0; i < n; i++) {\n      ret = ret && Check(nums[i], v[i]);\n    }\n    return ret;\n  }\n  lli minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    lli ret = inf;\n      n = nums.size();\n      bool all_zero = true;\n      for(auto& it : nums){\n          if(it) all_zero= false;\n      }\n      if(all_zero) return 0;\n    lli low = 0, high = queries.size() - 1;\n      // cout << Ok(0, queries, nums) << endl;\n    while (low <= high) {\n      lli mid = low + (high - low) / 2;\n      if (Ok(mid, queries, nums)) {\n        ret = min(ret, mid + 1);\n        high = mid - 1;\n      } else low = mid + 1;\n    }\n    if (ret == inf) ret = -1;\n    return ret;\n  }\n};\n\n\n#ifdef LOCAL\nlli main() {\n  freopen(\"output.txt\", \"w\", stdout);\n  cout << \"Compiled!\" << endl;\n}\n#endif\n\n","author":"Agnibha Chakraborty","submissionId":"1575141602"},[]]},{"208":[{"id":"208","fileName":"1575142660.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        q = len(queries)\n        dp = [1 for _ in range(n)]\n        m = [(1 << (nums[j]+1)) - 1 for j in range(n)]\n        v = (nums,queries)\n        if all(nums[j] == 0 for j in range(n)):\n            return 0\n        for k in range(q):\n            l,r,val = queries[k]\n            for j in range(l,r+1):\n                dp[j] |= (dp[j]<<val)\n                dp[j]&= m[j]\n            a = True\n            for j in range(n):\n                if ((dp[j] >> nums[j])& 1) == 0:\n                    a = False\n                    break\n            if a:\n                return k+1\n        return -1","author":"Gokulan N","submissionId":"1575142660"},[]]},{"209":[{"id":"209","fileName":"1575142616.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector <vector<pair<int,int>>> v(n);\n        for(int i=0;i<queries.size();i++){\n            int l=queries[i][0],r=queries[i][1],val=queries[i][2];\n            for(int j=l;j<=r;j++){\n                v[j].push_back({val,i});\n            }\n        }\n        int l=-1,r=queries.size()-1;\n        int ans=-1;\n        while(l<=r){\n            int mid = (l+r)/2;\n            bool poss=true;\n            for(int i=0;i<n;i++){\n              vector <bool> dp(1005,false);\n              dp[0]=true;\n              for(int j=0;j<v[i].size();j++){\n                  if(v[i][j].second <= mid){\n                    int val=v[i][j].first;\n                    for(int j=1000-val;j>=0;j--){\n                        if(dp[j]){\n                          dp[j+val]=true;\n                        }\n                    }  \n                  }else{\n                      break;\n                  }\n              }\n              if(!dp[nums[i]]){\n                  poss=false;\n                  break;\n              }\n            }\n            if(poss){\n                ans=mid+1;\n                r=mid-1;\n            }else{\n                l=mid+1;\n            }\n        }\n        return ans;\n    }\n};","author":"gok_2001","submissionId":"1575142616"},[]]},{"210":[{"id":"210","fileName":"1575142789.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        res = 0\n        for i, num in enumerate(nums):\n            if num == 0:\n                continue\n            poss = set()\n            poss.add(num)\n            found = False\n            for j, (l, r, val) in enumerate(queries):\n                if l <= i <= r:\n                    if val in poss:\n                        found = True\n                        break\n                    to_add = set(p - val for p in poss)\n                    poss |= to_add\n            if not found:\n                return -1\n            res = max(res, j + 1)\n        return res\n                    ","author":"thedude7181","submissionId":"1575142789"},[]]},{"211":[{"id":"211","fileName":"1575142476.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& v, vector<vector<int>>& q) {\n        int n=v.size();\n        vector<vector<bool>>dp(n,vector<bool>(1001,false));\n        for(int i=0;i<n;i++)dp[i][0]=1;\n        bool a=1;\n        for(auto i:v)if(i!=0)a=0;\n        if(a)return 0;\n        for(int i=0;i<q.size();i++){\n            vector<vector<bool>>ndp=dp;\n            for(int j=q[i][0];j<=q[i][1];j++){\n                for(int k=q[i][2];k<=1000;k++){\n                    ndp[j][k]=ndp[j][k]|dp[j][k-q[i][2]];\n                }\n            }\n            dp=ndp;\n            bool ans=true;\n            for(int j=0;j<n;j++){\n                if(!dp[j][v[j]])ans=false;\n            }\n            if(ans)return i+1;\n        }\n        return -1;\n    }\n};","author":"LevelUp","submissionId":"1575142476"},[]]},{"212":[{"id":"212","fileName":"1575142889.txt","sourceCode":"class Solution {\nvector<vector<int>> dp;\nint solve(int index, int el, vector<pair<int,int>> &v){\n    if(el == 0) return 0;\n    if (index == v.size() || el < 0) return 1e9;\n\n    if(dp[index][el] != -1) return dp[index][el];\n        int cur = v[index].first;\n    if(cur == el){\n        return dp[index][el] = v[index].second;\n    }\n    int ans = 1e9;\n    if(cur < el) ans = min(ans, solve(index+1, el-cur, v));\n    ans = min(ans, solve(index+1, el, v));\n    return dp[index][el] = ans;\n}\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        map<int, vector<pair<int,int>>> mpp;\n\n        int cnt = 1;\n        for(auto &it: queries){\n            for(int i=it[0]; i<=it[1]; i++){\n                mpp[i].push_back({it[2], cnt});\n            }\n            cnt++;\n        }\n        \n        int ans = -1;\n        for(auto &it: mpp){\n            int max_el = nums[it.first]; \n            dp.assign(it.second.size(), vector<int>(max_el + 1, -1)); \n            ans = max(ans, solve(0, nums[it.first], it.second));\n        }\n\n        for(int i=0; i<nums.size(); i++){\n            if(mpp.find(i) ==mpp.end()){\n                if(nums[i] != 0) ans = 1e9;\n                break;\n            }\n        }\n        if(ans >= 1e9) return -1;\n        return ans;\n    }\n};","author":"Jashanpreet Singh","submissionId":"1575142889"},[]]},{"213":[{"id":"213","fileName":"1575143208.txt","sourceCode":"class Solution {\n    boolean g(int[] cnt, int s) {\n        ArrayList<Integer> a = new ArrayList<>();\n        for (int i = 1; i <= 10; i++) {\n            int c = cnt[i];\n            for (int b = 1; b <= c; b *= 2) {\n                a.add(b * i);\n                c -= b;\n            }\n            if (c > 0)\n                a.add(c * i);\n        }\n        int n = a.size();\n        boolean[] dp = new boolean[s + 1];\n        dp[0] = true;\n        for (int i = 0; i < n; i++)\n            for (int j = s; j >= 0; j--)\n                if (j >= a.get(i) && dp[j - a.get(i)])\n                    dp[j] = true;\n        return dp[s];\n    }\n    boolean f(int[] nums, int[][] qs, int k) {\n        int n = nums.length;\n        int[][] cnt = new int[n][11];\n        for (int i = 0; i < k; i++)\n            for (int j = qs[i][0]; j <= qs[i][1]; j++)\n                cnt[j][qs[i][2]]++;\n        for (int i = 0; i < n; i++)\n            if (!g(cnt[i], nums[i]))\n                return false;\n        return true;\n    }\n    public int minZeroArray(int[] nums, int[][] qs) {\n        int m = qs.length, p = 0, q = m;\n        while (p < q) {\n            int mid = p + (q - p) / 2;\n            if (f(nums, qs, mid))\n                q = mid;\n            else\n                p = mid + 1;\n        }\n        return f(nums, qs, p) ? p : -1;\n    }\n}","author":"liyangzi6p626","submissionId":"1575143208"},[]]},{"214":[{"id":"214","fileName":"1575143073.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int q = queries.size();\n        int n = nums.size();\n        \n        int lo = 0, hi = q + 1;\n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (canAchieve(nums, queries, mid))\n                hi = mid;\n            else\n                lo = mid + 1;\n        }\n        return (lo > q ? -1 : lo);\n    }\n    bool canAchieve(const vector<int>& nums, const vector<vector<int>>& queries, int k) {\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            if (target == 0)\n                continue;\n            \n            vector<int> relevant;\n            for (int j = 0; j < k; j++) {\n                if (queries[j][0] <= i && i <= queries[j][1]) {\n                    relevant.push_back(queries[j][2]);\n                }\n            }\n          \n            unordered_map<int, unordered_map<int, bool>> memo;\n            if (!subsetSum(relevant, 0, 0, target, memo))\n                return false;\n        }\n        return true;\n    }\n   \n    bool subsetSum(vector<int>& vals, int index, int curr, int target,\n                   unordered_map<int, unordered_map<int, bool>>& memo) {\n        if (curr == target)\n            return true;\n        if (index >= vals.size() || curr > target)\n            return false;\n        \n        if (memo.count(index) && memo[index].count(curr))\n            return memo[index][curr];\n        \n        bool res = subsetSum(vals, index + 1, curr, target, memo);\n        if (curr + vals[index] <= target)\n            res = res || subsetSum(vals, index + 1, curr + vals[index], target, memo);\n        \n        memo[index][curr] = res;\n        return res;\n    }\n};","author":"Adithya Hegde Kota","submissionId":"1575143073"},[]]},{"215":[{"id":"215","fileName":"1575143284.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        std::ios_base::sync_with_stdio(false);\n        std::cin.tie(NULL);\n        \n        int n = nums.size();\n        int m = queries.size();\n\n        int l=0,r=m;\n        int ans=-1;\n        while(l<=r){\n            int k=l + (r-l)/2;\n            if (isPossible(nums, queries, k)) {\n                ans=k;\n                r=k-1;\n            }\n            else{\n                l=k+1;\n            }\n        }\n        \n        return ans;\n    }\n    \nprivate:\n    bool isPossible(const vector<int>& nums, const vector<vector<int>>& queries, int k) {\n        int n = nums.size();\n        vector<int> possible(n, true);\n        \n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == 0) continue; \n            \n            vector<int> allowed;\n            for (int j = 0; j < k; ++j) {\n                int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                if (l <= i && i <= r) {\n                    allowed.push_back(val);\n                }\n            }\n            \n            if (!isSubset(allowed, nums[i])) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    bool isSubset(vector<int>& values, int target) {\n        int n = values.size();\n        vector<bool> dp(target + 1, false);\n        dp[0] = true;\n        \n        for (int val : values) {\n            for (int j = target; j >= val; --j) {\n                if (dp[j - val]) {\n                    dp[j] = true;\n                }\n            }\n        }\n        \n        return dp[target];\n    }\n};","author":"lakshitjainn","submissionId":"1575143284"},[]]},{"216":[{"id":"216","fileName":"1575141565.txt","sourceCode":"class Solution {\npublic:\n    \n    bool f(const std::vector<int>& arr, int n, int sum) {\n    // Create a boolean array to store results of subproblems\n    std::vector<std::vector<bool>> dp(n + 1, std::vector<bool>(sum + 1));\n\n    // If sum is 0, then answer is true (empty subset)\n    for (int i = 0; i <= n; i++) {\n        dp[i][0] = true;\n    }\n\n    // Fill the dp array\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= sum; j++) {\n            // If current element is greater than sum, ignore it\n            if (arr[i - 1] > j) {\n                dp[i][j] = dp[i - 1][j];\n            } else {\n                // Check if sum can be obtained by including or excluding the current element\n                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - arr[i - 1]];\n            }\n        }\n    }\n\n    return dp[n][sum];\n}\n\n    \n    \n    \n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int ans=-1;\n        int l=1,h=q.size();\n        int n=a.size();\n        \n        bool flagg=true;\n        for(auto i:a){\n            if(i > 0)flagg=false;\n        }\n        if(flagg)return 0;\n\n        \n        while(l<=h){\n            int m=l+h;\n            m>>=1;\n            \n            map<int,vector<int>> mp;\n            int c=m;\n            for(auto i:q){\n                int f=i[0],s=i[1],val=i[2];\n                for(int j=f;j<=s;j++){\n                    mp[j].push_back(val);\n                }\n                c--;\n                if(c == 0)break;\n            }\n\n            bool flag=true;\n            for(int i=0;i<a.size();i++){\n                if(f(mp[i],mp[i].size(),a[i]))continue;\n                flag=false;\n            }\n            \n            if(flag){\n                ans=m;\n                h=m-1;\n            }else{\n                l=m+1;\n            }\n        }\n        \n        return ans;\n    }\n};","author":"stackenqueue2","submissionId":"1575141565"},[]]},{"217":[{"id":"217","fileName":"1575143621.txt","sourceCode":"class Solution {\npublic:\n    int f(int target,int j,int i,vector<vector<int>>& q,int m,vector<vector<int>>&dp)\n    {\n        if(i==m)\n        return m;\n        \n        if(dp[target][i]!=-1)\n        return dp[target][i];\n        \n        int ans=f(target,j,i+1,q,m,dp);\n        if(q[i][0]<=j && q[i][1]>=j && target>=q[i][2])\n        {\n            if(target==q[i][2])\n            ans=i;\n            \n            ans=min(ans,f(target-q[i][2],j,i+1,q,m,dp));\n        }\n        return dp[target][i]=ans;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n=nums.size();\n        int m=q.size();\n        vector<int>ans(n,-1);\n        for(int i=0;i<n;i++)\n        {\n            if(nums[i]==0)\n            ans[i]=0;\n            else\n            {\n                vector<vector<int>>dp(nums[i]+5,vector<int>(m+1,-1));\n                int res=f(nums[i],i,0,q,m,dp);\n                if(res==m)\n                ans[i]=-1;\n                else ans[i]=res;\n                \n            }\n        }\n        int res=0;\n        for(int i=0;i<n;i++)\n        {\n            if(ans[i]==-1)\n            return -1;\n            \n            if(nums[i]!=0)\n            res=max(res,ans[i]+1);\n        }\n        return res;\n    }\n};","author":"kushal46","submissionId":"1575143621"},[]]},{"218":[{"id":"218","fileName":"1575143563.txt","sourceCode":"#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\npublic:\n    int f(vector<int>& a, vector<vector<pair<int, int>>>& v, int i) {\n        if (a[i] == 0) return 0;\n        auto& q = v[i];\n        if (q.empty()) return -1;\n        unordered_map<int, int> d;\n        d[0] = -1;\n        for (auto& [j, x] : q) {\n            unordered_map<int, int> t = d;\n            for (auto& [s, k] : d) {\n                int ns = s + x, nk = max(k, j);\n                if (!t.count(ns) || nk < t[ns]) t[ns] = nk;\n            }\n            swap(d, t);\n        }\n        return d.count(a[i]) ? d[a[i]] + 1 : -1;\n    }\n\n    int g(vector<int>& a) {\n        for (int x : a) if (x) return 0;\n        return 1;\n    }\n\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size(), m = q.size(), r = 0;\n        vector<vector<pair<int, int>>> v(n);\n        for (int j = 0; j < m; ++j) \n            for (int i = q[j][0]; i <= q[j][1]; ++i) \n                v[i].emplace_back(j, q[j][2]);\n        for (int i = 0; i < n; ++i) {\n            int t = f(a, v, i);\n            if (t == -1) return -1;\n            r = max(r, t);\n        }\n        return r ? r : (g(a) ? 0 : -1);\n    }\n};\n","author":"Angshuman_Chh","submissionId":"1575143563"},[]]},{"219":[{"id":"219","fileName":"1575143997.txt","sourceCode":"class Solution {\npublic:\n\n    bool check(vector<vector<int>>& queries, vector<int> nums, int k){\n        //for first k queries, at each index what are the possible answers\n        vector<unordered_set<int>> possible(nums.size());\n        for(int i = 0; i < nums.size(); ++i){\n            possible[i].insert(nums[i]);\n        }\n        for(int i = 0; i < k; ++i){\n            int a = queries[i][0];\n            int b = queries[i][1];\n            int val = queries[i][2];\n            for(int j = a; j <= b; ++j){\n                vector<int> add;\n                for(auto &x:possible[j]){\n                    if(x-val >= 0){\n                        add.push_back(x-val);\n                    }\n                }\n                for(auto &temp:add){\n                    possible[j].insert(temp);\n                }\n                \n            }\n        }\n        // for(auto &x:possible){\n        //     for(auto &y:x){\n        //         cout << y << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        // cout << endl;\n        for(int i = 0; i < nums.size(); ++i){\n            if(!possible[i].count(0))return false;\n        }\n        return true;\n    }\n\n    int binSearch(int l, int r, vector<vector<int>>& queries, vector<int> nums){\n        if(l > r)return -1;\n        int mid = (l+r)/2;\n        if(!check(queries, nums, mid)){\n            //try more\n            return binSearch(mid+1, r, queries, nums);\n        }else{\n            int temp = binSearch(l, mid-1, queries, nums);\n            if(temp != -1)return temp;\n            return mid;\n        }\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        //apply all queries\n        return binSearch(0, (int)queries.size(), queries, nums);\n    }\n};","author":"Arghadeep Das","submissionId":"1575143997"},[]]},{"220":[{"id":"220","fileName":"1575143629.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        int ans = 0;\n        for (int i=0; i<n; i++) {\n            Set<Integer> s = new HashSet<>();\n            s.add(0);\n            int j = 0;\n            while (j < m && !s.contains(nums[i])) {\n                if (queries[j][0] <= i && queries[j][1] >= i) {\n                    Set<Integer> t = new HashSet<>();\n                    for (int k : s) {\n                        t.add(k);\n                        int z = k + queries[j][2];\n                        if (z <= nums[i])\n                            t.add(z);\n                    }\n                    s = t;\n                }\n                j++;\n            }\n            if (!s.contains(nums[i]))\n                return -1;\n            ans = Math.max(ans, j);\n        }\n        return ans;\n    }\n}","author":"yge2","submissionId":"1575143629"},[]]},{"221":[{"id":"221","fileName":"1575144026.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        total_queries = len(queries)\n        ways = [set([0]) for _ in range(len(nums))]\n        columns = set()\n        for i, v in enumerate(nums):\n            if v != 0:\n                columns.add(i)\n\n        i = 0\n        while i < total_queries:\n            if not columns:\n                return i\n\n            l, r, v = queries[i]\n            for col in range(l, r + 1):\n                if col not in columns:\n                    continue\n                \n                for x in list(ways[col]):\n                    if x + v == nums[col]:\n                        columns.discard(col)\n                        break\n                    \n                    ways[col].add(x + v)\n\n            i += 1\n\n        if columns:\n            return -1\n        else:\n            return total_queries","author":"Yiping","submissionId":"1575144026"},[]]},{"222":[{"id":"222","fileName":"1575144079.txt","sourceCode":"class Solution {\npublic:\nbool canZeroArray(const vector<int>& nums, const vector<vector<int>>& queries, int k) {\n    int n = nums.size();\n    for (int j = 0; j < n; j++) {\n        int target = nums[j];\n        vector<bool> dp(target + 1, false);\n        dp[0] = true;\n        for (int i = 0; i < k; i++) {\n            int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n            if (j >= l && j <= r) { \n                for (int t = target; t >= v; t--) {\n                    if (dp[t - v])\n                        dp[t] = true;\n                }\n            }\n        }\n        if (!dp[target])\n            return false;\n    }\n    return true;\n}\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        int ans = -1;\n        for (int k = 0; k <= q; k++) {\n            if (canZeroArray(nums, queries, k)) {\n                ans = k;\n                break;\n            }\n        }\n        return ans;\n    }\n};","author":"glorious","submissionId":"1575144079"},[]]},{"223":[{"id":"223","fileName":"1575144096.txt","sourceCode":"class Solution {\npublic:\n  int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    auto test = [&](int k) {\n      for (int i = 0; i < nums.size(); ++i) {\n        int x = nums[i];\n        vector<bool> a(x + 1);\n        a[0] = true;\n        for (int u = 0; u < k; ++u) {\n          const auto& q = queries[u];\n          if (q[0] <= i && i <= q[1]) {\n            int y = q[2];\n            for (int j = x - y; j >= 0; --j) if (a[j]) a[j + y] = true;\n            if (a[x]) break;\n          }\n        }\n        if (!a[x]) return false;\n      }\n      return true;\n    };\n\n    int lo = 0, hi = queries.size() + 1;\n    while (lo < hi) {\n      int mid = (lo + hi) / 2;\n      if (test(mid)) hi = mid; else lo = mid + 1;\n    }\n    return lo > queries.size() ? -1 : lo;\n  }\n};","author":"Neal@阳谷县","submissionId":"1575144096"},[]]},{"224":[{"id":"224","fileName":"1575144302.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length, m = queries.length;\n        int[] w = new int[n];\n        Arrays.fill(w, -1);\n        \n        for (int i = 0; i < n; i++) {\n            int x = nums[i];\n            if (x == 0) {\n                w[i] = 0;\n                continue;\n            }\n            boolean[] f = new boolean[x + 1];\n            f[0] = true;\n            for (int j = 0; j < m; j++) {\n                int l = queries[j][0], r = queries[j][1], v = queries[j][2];\n                if (i >= l && i <= r) {\n                    for (int k = x - v; k >= 0; k--) {\n                        if (f[k] && k + v <= x) f[k + v] = true;\n                    }\n                }\n                if (f[x]) {\n                    w[i] = j + 1;\n                    break;\n                }\n            }\n            if (w[i] == -1) return -1;\n        }\n        int res = 0;\n        for (int x : w) res = Math.max(res, x);\n        return res;\n    }\n}","author":"happydreamer","submissionId":"1575144302"},[]]},{"225":[{"id":"225","fileName":"1575144493.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        k = 0\n        for i in range(len(nums)):\n            dp = {0}\n            num = nums[i]\n            if num == 0:\n                continue\n            for j in range(len(queries)):\n                if queries[j][0] > i or queries[j][1] < i:\n                    continue\n                dec = queries[j][2]\n                for val in list(dp):\n                    dp.add(val + dec)\n                if num in dp:\n                    # print(dp)\n                    if j + 1 > k:\n                        k = j + 1\n                    break\n            else:\n                return -1\n        return k","author":"jyhuang2005","submissionId":"1575144493"},[]]},{"226":[{"id":"226","fileName":"1575144406.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& v, vector<vector<int>>& q) {\n        int n = v.size(), m = q.size();\n        bool k = true;\n        if (count(v.begin(), v.end(), 0) == n) {\n            return 0;\n        }\n\n        auto helper = [&](int k) -> bool {\n            for (int i = 0; i < n; i++) {\n                vector<int> dp(v[i] + 1, false);\n                dp[0] = true;\n                for (int j = 0; j < k; j++) {\n                    int res = q[j][2];\n                    if (q[j][0] <= i && i <= q[j][1]) {\n                        for (int p = v[i] - res; p >= 0; p--) {\n                            if (dp[p]) {\n                                dp[p + res] = true;\n                            }\n                        }\n                    }\n                }\n                if (!dp[v[i]]) {\n                    return false;\n                }\n            }\n            return true;\n            };\n\n        int low = 1, high = m, ans = -1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (helper(mid)) {\n                ans = mid;\n                high = mid - 1;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"Divyansh Saxena","submissionId":"1575144406"},[]]},{"227":[{"id":"227","fileName":"1575144623.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        Q = len(queries)\n\n        @cache\n        def go(x, i, q):\n            if x == 0:\n                return q\n            if q == Q:\n                return inf\n\n            # skip\n            best = go(x, i, q + 1)\n            l, r, v = queries[q]\n            if l <= i <= r and v <= x:\n                best = min(best, go(x - v, i, q + 1))\n\n            return best\n\n        best = 0\n        for i, n in enumerate(nums):\n            r = go(n, i, 0)\n            # print(i, n, r)\n            if r == inf:\n                return -1\n            best = max(r, best)\n        go.cache_clear()\n        return best","author":"Tim Lu","submissionId":"1575144623"},[]]},{"228":[{"id":"228","fileName":"1575144909.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, m = len(nums), len(queries)\n        if all(x == 0 for x in nums):\n            return 0\n        dp = [set([0]) for _ in range(n)]\n        for k in range(m):\n            l, r, v = queries[k]\n            for i in range(l, r + 1):\n                new_set = {s + v for s in dp[i] if s + v <= nums[i]}\n                dp[i].update(new_set)\n            if all(nums[i] in dp[i] for i in range(n)):\n                return k + 1\n        return -1\n","author":"Subiksha20","submissionId":"1575144909"},[]]},{"229":[{"id":"229","fileName":"1575144792.txt","sourceCode":"#include<bits/stdc++.h>\nusing namespace std ; \nusing int64 = long long ; \nconstexpr int64 INF = 1e18 ; \n\n\nclass DP {\npublic:\n    //01背包，背包容量， 每个物品价值 以及体重，一个物品只能是 选择 或者不选择\n    int64 dp( int M , vector< int > &info  ) {\n\n        int n = info.size() ; \n        vector<int64> f ( M + 1 , 0 ) ; \n        f[0] = 1 ; \n        for( int i = 0 ; i < n ; i++ ) { \n            auto  W = info[i] ; \n\n            for( int j = M ; j >= W ; --j ) {\n                if( f[j-W]  ) {\n                    f[j] = 1 ; \n                }\n            }\n        }\n        return f[ M ] ; \n    }\n};\n\nclass Solution {\npublic:\n    vector<int> a ; \n    int n ; \n    vector< vector<int>> info ; \n    vector<vector<int>> queries ; \n    int m ; \n\n    void init(  int tm  ) { \n        info.assign( n , {} ) ; \n        for( int i = 0 ; i <= tm ; i++ ) {\n            auto &p = queries[i] ;\n            int L = p[0] , R = p[1] , val = p[2] ; \n\n            for( int j = L ; j <= R ; j++ ) {\n                info[j].emplace_back( val ) ;\n            }\n        }\n    }\n\n    bool check( int mid ) {\n\n        init( mid ) ; \n        \n        for( int i = 0 ; i < n ; i++ ) {\n            int val = a[i] ; \n            DP t ; \n            auto ret = t.dp( val , info[i] ) ; \n            if( ! ret ) {\n                return false ; \n            }\n        }\n        return true ; \n    }\n    int solve( ) { \n\n        int low = 0 ,  high = m - 1 ; \n        int ret = -1 ; \n        while( low <= high ) {\n            int mid = ( low + high ) >> 1 ; \n            if( check( mid )) { \n                ret = mid ; \n                high = mid - 1 ; \n            }\n            else {\n                low = mid + 1 ; \n            }\n        }\n        if( ret == -1 ) {\n            return -1 ;\n        }\n        return ret + 1 ; \n    }\n    bool is_all0() {\n        for( int i = 0 ; i < n ; i++ ) {\n            if( a[i] != 0 ) {\n                return false  ; \n            }\n        }\n        return true ; \n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        a = nums ; \n        n = a.size() ; \n\n        if( is_all0()) { \n            return 0 ;\n        }\n        \n\n        this->queries = queries ; \n        m = queries.size() ; \n        \n        return solve() ; \n    }\n};\n\nint mai2n( )  { \n    Solution  t; \n\n    vector<int> a , nums  ;\n    vector< vector<int >> queries ; \n    int n ; \n\n    a = {} ; \n    n = 14 ; \n    nums = {2,0,2}, queries = {{0,2,1},{0,2,1},{1,1,3} } ; \n    // }\n\n    nums = {4,3,2,1}, queries = {{1,3,2},{0,2,1}} ;  ; \n\n\n    nums = {1,2,3,2,1}, queries = {{0,1,1},{1,2,1},{2,3,2},{3,4,1},{4,4,1}} ;  \n\n\n    nums = {1,2,3,2,6}, queries = {{0,1,1},{0,2,1},{1,4,2},{4,4,4},{3,4,1},{4,4,5}} ;  ; \n\n    nums = { 0 , 0 , 0 , 0 , 0 }, queries = {{0,1,1},{0,2,1},{1,4,2},{4,4,4},{3,4,1},{4,4,5}} ;  ; \n\n\n    auto ans = t.minZeroArray( nums ,  queries ) ; \n    cout << ans << \"n\" ;\n\n    return 0 ; \n}\n","author":"luck","submissionId":"1575144792"},[]]},{"230":[{"id":"230","fileName":"1575144694.txt","sourceCode":"class Solution {\npublic:\n    int maxi = 0;\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l = 0 , r = queries.size();\n        maxi = *max_element(nums.begin(), nums.end());\n        while(l < r){\n            int k = ( r - l ) / 2 + l;\n            if(val(nums, queries, k)){\n                r = k;\n            }else{\n                l =k+1;\n            }\n        }\n        if(l == queries.size() && !val(nums, queries, l))\n            return -1;\n        return l;\n    }\n    bool val(vector<int>& nums, vector<vector<int>>& queries, int k){\n        //cout<<k<<endl;\n        int n = nums.size();\n        vector<vector<bool>>v(n, vector<bool>(maxi + 1, false));\n        for(int i =0 ; i <n; i++){\n            v[i][nums[i]] = true;\n        }\n        for(int i = 0; i < k; i++){\n            int l = queries[i][0] , r = queries[i][1];\n            int val = queries[i][2];\n            for(int j = l; j<= r; j++){\n                for(int x = 0; x + val <= maxi; x++){\n                    v[j][x] = v[j][x] || v[j][x + val];\n                }\n            }\n        }\n        int res = true;\n        for(int i = 0; i < n; i++){\n            res  = res && v[i][0];\n        }\n        return res;\n    }\n};","author":"qianyifan010203","submissionId":"1575144694"},[]]},{"231":[{"id":"231","fileName":"1575145224.txt","sourceCode":"class Solution {\n\n    static final int INF = Integer.MAX_VALUE;\n    \n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int result = 0;\n        for(int i = 0; i < n; ++i) {\n            result = Math.max(result, helper(nums[i], i, queries));\n        }\n        return result == INF ? -1 : result;\n    }\n\n    static int helper(int target, int i, int[][] queries) {\n        if (target == 0) {\n            return 0;\n        }\n        var dp = new boolean[target+1];\n        dp[0] = true;\n        int result = 0;\n        for(var query : queries) {\n            ++result;\n            if (i >= query[0] && i <= query[1]) {\n                int v = query[2];\n                for(int j = target; j - v >= 0; --j) {\n                    dp[j] = dp[j] || dp[j - v];\n                }\n            }\n            if (dp[target]) {\n                return result;\n            }\n        }\n        return INF;\n    }\n}","author":"heshan1234","submissionId":"1575145224"},[]]},{"232":[{"id":"232","fileName":"1575144483.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if not any(nums):\n            return 0\n        reachable = [{n} for n in nums]\n        done = [n == 0 for n in nums]\n        count = sum(done)\n        for k,(l,r,v) in enumerate(queries,1):\n            for i in range(l,r+1):\n                if done[i]:\n                    continue\n                if v in reachable[i]:\n                    done[i] = True\n                    count += 1\n                    if count == len(nums):\n                        return k\n                    continue\n                new = set()\n                for x in reachable[i]:\n                    if x > v:\n                        new.add(x-v)\n                reachable[i] |= new\n        return -1","author":"dirigibility","submissionId":"1575144483"},[]]},{"233":[{"id":"233","fileName":"1575145487.txt","sourceCode":"class Solution {\npublic:\n    vector<vector<int>> dp;\n    int dfs(int i, int val, int j, vector<vector<int>>& qs) {\n        if (val == 0)\n            return i;\n        if (val < 0 || i == qs.size())\n            return INT_MAX;\n        if (dp[i][val] == -1) {\n            dp[i][val] = dfs(i + 1, val, j, qs);\n            if (qs[i][0] <= j && j <= qs[i][1])\n                dp[i][val] = min(dp[i][val], dfs(i + 1, val - qs[i][2], j, qs));\n        }\n        return dp[i][val];\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int res = 0;\n        for (int i = 0; res != INT_MAX && i < nums.size(); ++i) {\n            dp = vector<vector<int>> (queries.size(), vector<int>(1001, -1));\n            res = max(res, dfs(0, nums[i], i, queries));\n        }\n        return res == INT_MAX ? -1 : res;\n    }\n};","author":"Vlad","submissionId":"1575145487"},[]]},{"234":[{"id":"234","fileName":"1575145892.txt","sourceCode":"var minZeroArray = function(nums, queries) {\n    const n = nums.length;\n    const achievable_sums = Array.from({length: n}, () => new Set([0]));\n    const achieved = Array(n).fill(false);\n    let achieved_count = 0;\n\n    // Check initial state\n    for (let j = 0; j < n; j++) {\n        if (nums[j] === 0) {\n            achieved[j] = true;\n            achieved_count++;\n        }\n    }\n    if (achieved_count === n) return 0;\n\n    // Process each query\n    for (let k = 0; k < queries.length; k++) {\n        const [left, right, value] = queries[k];\n        for (let j = left; j <= right; j++) {\n            if (achieved[j]) continue; // Skip if already achieved\n            const current_sums = achievable_sums[j];\n            const new_sums = new Set();\n            for (const sum of current_sums) {\n                const next_sum = sum + value;\n                if (next_sum <= nums[j]) {\n                    new_sums.add(next_sum);\n                    if (next_sum === nums[j]) {\n                        achieved[j] = true;\n                        achieved_count++;\n                    }\n                }\n            }\n            new_sums.forEach(sum => current_sums.add(sum));\n        }\n        if (achieved_count === n) return k + 1;\n    }\n\n    return -1;\n};\n//thanks for the given oppurtunity for the leetcode to upleveling  my carrer.","author":"tony stark","submissionId":"1575145892"},[]]},{"235":[{"id":"235","fileName":"1575145512.txt","sourceCode":"class Solution {\npublic:\n    bool check(vector<int>& nums, vector<vector<int>>& queries, int middle) {\n        vector<vector<int>> count(10, vector<int>(11, 0));\n        for (int i = 0; i < middle; ++i) {\n            for (int j = queries[i][0]; j <= queries[i][1]; ++j) {\n                count[j][queries[i][2]]++;\n            }\n        }\n        for (int i = 0; i < nums.size(); ++i) {\n            vector<int> dp(nums[i] + 1, 0);\n            dp[0] = 1;\n\n            for (int j = 1; j <= 10; ++j) {\n                int c = count[i][j];\n                for (int k = nums[i]; k >= 0; --k) {\n                    if (dp[k]) {\n                        for (int l = 1; l <= c; l++) {\n                            int newSum = k + j * l;\n                            if (newSum > nums[i]) break;\n                            dp[newSum] = true;\n                        }\n                    }\n                }\n            }\n            if (dp[nums[i]] == false) return false;\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size(), states = 1 << n;\n        int left = 0, right = queries.size();\n        while (left <= right) {\n            int middle = (left + right) / 2;\n            if (check(nums, queries, middle)) right = middle - 1;\n            else left = middle + 1;\n        }\n\n        return left > m ? -1 : left;\n    }\n};","author":"Mark Qi","submissionId":"1575145512"},[]]},{"236":[{"id":"236","fileName":"1575145243.txt","sourceCode":"#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<string> vs;\ntypedef vector<char> vc;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef pair<int, int> pii;\ntypedef tuple<int, int, int> ti;\ntypedef pair<double, double> pdd;\ntypedef pair<ll, ll> pll;\ntypedef vector<pii> vpii;\ntypedef vector<vpii> vvpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef tree<int, null_type, less<>, rb_tree_tag, tree_order_statistics_node_update>\n        ordered_set;\nconst int inf = 1e9;\nconst ll llinf = 4e18;\nconst int mod = 1e9 + 7;\nconst double EPS = 1e-9;\n#define all(a) a.begin(),a.end()\n#define read(n) vi arr(n);for(int&_:arr)cin>>_\n#define readarr(arr) for(auto&_:arr)cin>>_\n#define readpair(arr) for(auto&[_,__]:arr)cin>>_>>__\n#define rep(i, a, n) for(int i=a;i<n;i++)\n#define repr(i, a, n) for(int i=a;i>=n;i--)\n#define nl \"n\"\n#define sz(v) ((int)v.size())\n#define PQ priority_queue\n#define hmap unordered_map\n#define hset unordered_set\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n#define clz(i) __builtin_clz(i)\n#define ctz(i) __builtin_ctz(i)\n#define popcount(i) __builtin_popcount(i)\n#define lsb(i) (i&-i)\nmt19937_64 rnd(time(0));\n\n\ntemplate<typename T>\ninline void pr(const T &t) { cout << t << ' '; }\n\ntemplate<typename T, typename U>\ninline void pr(const pair<T, U> &pa) {\n    cout << '(';\n    pr(pa.first);\n    cout << ',';\n    pr(pa.second);\n    cout << \") \";\n}\n\ntemplate<typename... Args>\ninline void pr(const tuple<Args...> &tup) {\n    apply([](const auto &... args) {\n        pr('[');\n        (pr(args), ...);\n        pr(']');\n    }, tup);\n}\n\ntemplate<typename T>\ninline void pr(const vector<T> &v) {\n    for (auto i: v) pr(i);\n    cout << nl;\n}\n\ntemplate<typename T>\ninline void pr(const set<T> &s) {\n    for (auto t: s)pr(t);\n    cout << nl;\n}\n\ntemplate<typename T>\ninline void pr(const unordered_set<T> &s) {\n    for (auto t: s)pr(t);\n    cout << nl;\n}\n\ntemplate<typename T, typename U>\ninline void pr(const map<T, U> &m) {\n    for (auto [t, u]: m) {\n        cout << '(';\n        pr(t);\n        pr('-');\n        pr(u);\n        pr(')');\n    }\n    cout << nl;\n}\n\ntemplate<typename T, typename U>\ninline void pr(const unordered_map<T, U> &m) {\n    for (auto [t, u]: m) {\n        cout << '(';\n        pr(t);\n        pr('-');\n        pr(u);\n        pr(')');\n    }\n    cout << nl;\n}\n\ntemplate<typename T>\ninline void pr(const queue<T> &q) {\n    queue<T> copy(q);\n    while (!copy.empty()) {\n        pr(copy.front());\n        copy.pop();\n    }\n    cout << nl;\n}\n\ntemplate<typename T>\ninline void pr(const stack<T> &s) {\n    stack<T> copy(s);\n    while (!copy.empty()) {\n        pr(copy.top());\n        copy.pop();\n    }\n    cout << nl;\n}\n\ntemplate<typename T>\ninline void pr(const deque<T> &q) {\n    deque<T> copy(q);\n    while (!copy.empty()) {\n        pr(copy.top());\n        copy.pop();\n    }\n    cout << nl;\n}\n\ntemplate<typename T>\ninline void pr(const PQ<T> &pq) {\n    PQ<T> copy(pq);\n    vector<T> arr;\n    while (!copy.empty()) {\n        arr.pb(copy.top());\n        copy.pop();\n    }\n    pr(arr);\n    cout << nl;\n}\n\ntemplate<typename T>\ninline void pr(const PQ<T, vector<T>, greater<T>> &pq) {\n    auto copy(pq);\n    vector<T> arr;\n    while (!copy.empty()) {\n        arr.pb(copy.top());\n        copy.pop();\n    }\n    pr(arr);\n    cout << nl;\n}\n\ntemplate<typename T>\ninline void pnl(const T &t) {\n    pr(t);\n    cout << nl;\n}\n\ntemplate<typename... Args>\nvoid pr(const Args &... args) {\n    (pr(args), ...);\n    cout << nl;\n}\n\nbool dfs(int a, int L, vector<vi> &g, vi &btoa, vi &A, vi &B) {\n    if (A[a] != L) return 0;\n    A[a] = -1;\n    for (int b: g[a])\n        if (B[b] == L + 1) {\n            B[b] = 0;\n            if (btoa[b] == -1 || dfs(btoa[b], L + 1, g, btoa, A, B))\n                return btoa[b] = a, 1;\n        }\n    return 0;\n}\n\nint hopcroftKarp(vector<vi> &g, vi &btoa) {\n    int res = 0;\n    vi A(g.size()), B(btoa.size()), cur, next;\n    for (;;) {\n        fill(all(A), 0);\n        fill(all(B), 0);\n        /// Find the starting nodes for BFS (i.e. layer 0).\n        cur.clear();\n        for (int a: btoa) if (a != -1) A[a] = -1;\n        rep(a, 0, sz(g)) if (A[a] == 0) cur.push_back(a);\n        /// Find all layers using bfs.\n        for (int lay = 1;; lay++) {\n            bool islast = 0;\n            next.clear();\n            for (int a: cur)\n                for (int b: g[a]) {\n                    if (btoa[b] == -1) {\n                        B[b] = lay;\n                        islast = 1;\n                    } else if (btoa[b] != a && !B[b]) {\n                        B[b] = lay;\n                        next.push_back(btoa[b]);\n                    }\n                }\n            if (islast) break;\n            if (next.empty()) return res;\n            for (int a: next) A[a] = lay;\n            cur.swap(next);\n        }\n        /// Use DFS to scan for augmenting paths.\n        rep(a, 0, sz(g))res += dfs(a, 0, g, btoa, A, B);\n    }\n}\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=sz(nums),q=sz(queries);\n        bool have=1;\n        rep(i,0,n)if(nums[i]){\n            have=0;\n            break;\n        }\n        if(have)return 0;\n        typedef bitset<1001>bs;\n        vector<bs>arr(n);\n        rep(i,0,n)arr[i][0]=1;\n        rep(i,0,q){\n            rep(j,queries[i][0],queries[i][1]+1){\n                arr[j]|=arr[j]<<queries[i][2];\n            }\n            bool d=1;\n            rep(j,0,n)if(!arr[j][nums[j]]){\n                d=0;\n                break;\n            }\n            if(d)return i+1;\n        }\n        return -1;\n    }\n};\n//inline void solve() {\n//\n//}\n//\n//int32_t main() {\n//    ios_base::sync_with_stdio(false);\n//    cin.tie(nullptr);\n//    cout.tie(nullptr);\n//    cout << fixed << setprecision(10);\n//    int cases = 1;\n////    cin >> cases;\n//    while (cases--) solve();\n//    return 0;\n//}","author":"Choon Hean Lew","submissionId":"1575145243"},[]]},{"237":[{"id":"237","fileName":"1575145572.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        coverage = [[] for _ in range(n)]\n        for i, (l, r, val) in enumerate(queries):\n            for j in range(l, r + 1):\n                coverage[j].append((i, val))\n        max_i_list = []\n        for j in range(n):\n            if nums[j] == 0:\n                max_i_list.append(-1)\n                continue\n            target = nums[j]\n            queries_j = coverage[j]\n            dp = {0: -1}\n            for i, val in queries_j:\n                new_dp = {}\n                for s in dp:\n                    prev_max = dp[s]\n                    if s not in new_dp or prev_max < new_dp[s]:\n                        new_dp[s] = prev_max\n                    new_s = s + val\n                    new_max = max(prev_max, i)\n                    if new_s <= target:\n                        if new_s not in new_dp or new_max < new_dp.get(new_s, inf):\n                            new_dp[new_s] = new_max\n                dp = new_dp\n\n            if target in dp:\n                max_i_list.append(dp[target])\n            else:\n                return -1\n        max_i = max(max_i_list)\n        # print(max_i_list)\n        return max_i + 1        ","author":"bayibo","submissionId":"1575145572"},[]]},{"238":[{"id":"238","fileName":"1575145896.txt","sourceCode":"class Solution {\n    bool subsetSum(const vector<int>& arr, int target) {\n        int n = arr.size();\n        vector<vector<bool>> dp(n + 1, vector<bool>(target + 1, false));\n        for (int i = 0; i <= n; i++) dp[i][0] = true;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= target; j++) {\n                if (arr[i - 1] > j) {\n                    dp[i][j] = dp[i - 1][j];\n                } else {\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - arr[i - 1]];\n                }\n            }\n        }\n        return dp[n][target];\n    }\n    int minidx(int num, vector<int> idx, vector<vector<int>>& queries) {\n        int nq = queries.size();\n        int low = 0;\n        int high = nq+1;\n        while (low < high) {\n            int mid = (high - low) / 2 + low;\n            vector<int> arr;\n            for (int i: idx) {\n                if (i < mid) arr.push_back(queries[i][2]);\n            }\n            if (subsetSum(arr, num)) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int nq = queries.size();\n        unordered_map<int, vector<int>> m;\n        for (int i = 0; i < n; i++) {\n            m[i] = vector<int>{};\n        }\n        for (int j = 0; j < nq; j++) {\n            vector<int>& q = queries[j];\n            int l = q[0];\n            int r = q[1];\n            for (int i = l; i <= r; i++) {\n                m[i].push_back(j);\n            }\n        }\n        int ret = 0;\n        for (int i = 0; i < n; i++) {\n            ret = max(ret, minidx(nums[i], m[i], queries));\n        }\n        if (ret == nq+1) ret = -1;\n        return ret;\n        \n    }\n};","author":"Yi Yao","submissionId":"1575145896"},[]]},{"239":[{"id":"239","fileName":"1575146178.txt","sourceCode":"from functools import cache\ninf = float('inf')\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if sum(nums) == 0: return 0 \n        n = len(nums)\n        choices = [[] for i in range(n)]\n        for i,(l,r,val) in enumerate(queries):\n            for j in range(l,r+1):\n                choices[j].append((i,val))\n        \n        @cache\n        def DP(i,j,x):\n            if j == len(choices[i]):\n                return inf\n            \n            mn = DP(i,j+1,x)\n            k,v = choices[i][j]\n            if x > v:\n                mn = min(mn, DP(i,j+1,x-v))\n            elif x == v:\n                mn = min(mn, k+1)\n            return mn\n            \n        mx = 0\n        # print(\"---\"*n)\n        for i in range(n):\n            if nums[i] > 0:\n                # print()\n                mx = max(mx, DP(i,0,nums[i]))\n        \n        DP.cache_clear()\n        return -1 if mx == inf else mx\n            ","author":"abhishek vaish","submissionId":"1575146178"},[]]},{"240":[{"id":"240","fileName":"1575146316.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, m = len(nums), len(queries)\n        if all(x == 0 for x in nums):\n            return 0\n        seen = [{0} for _ in range(n)]\n        for i, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                news = [x + v for x in seen[j]]\n                seen[j].update(news)\n            if all(nums[j] in seen[j] for j in range(n)):\n                return i + 1\n        return -1","author":"Jiahao","submissionId":"1575146316"},[]]},{"241":[{"id":"241","fileName":"1575146173.txt","sourceCode":"import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\n\nclass Solution {\n    public static boolean valid(ArrayList<Integer> nums, int target) {\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n\n        for (int num : nums) {\n            for (int j = target; j >= num; j--) {\n                dp[j] = dp[j] || dp[j - num];\n            }\n        }\n        return dp[target];\n    }\n    public int minZeroArray(int[] nums, int[][] queries) {\n        HashMap<Integer, ArrayList<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.put(i, new ArrayList<>());\n        }\n        if (nums.length == 1) {\n            if (nums[0] == 0) {\n                return 0;\n            }\n        }\n        boolean isAllZero = true;\n        for (int i: nums) {\n            if (i != 0) {\n                isAllZero = false;\n            }\n        }\n        if (isAllZero) {\n            return 0;\n        }\n        boolean[] zArr = new boolean[nums.length];\n        for (int i = 0 ; i< queries.length; i++) {\n            int[] q = queries[i];\n            int l = q[0];\n            int r = q[1];\n            int v = q[2];\n            for (int j = l; j <= r; j++) {\n                map.get(j).add(v);\n            }\n            boolean failed = false;\n            for (int j = 0; j < nums.length; j++) {\n                if (zArr[j]) {\n                    continue;\n                }\n                failed = true;\n                zArr[j] = valid(map.get(j), nums[j]);\n            }\n            if (!failed) {\n                return i;\n            }\n        }\n        boolean f1 = true;\n        for (boolean g: zArr) {\n            if (g == false) {\n                f1 = false;\n            }\n        }\n        if (f1) {\n            return queries.length;\n        }\n        return -1;\n    }\n}","author":"Hastorius","submissionId":"1575146173"},[]]},{"242":[{"id":"242","fileName":"1575146257.txt","sourceCode":"class Solution {\n    bool subsetSum(int num,vector<int> &coins){\n        int n=coins.size();\n        bool dp[n+1][num+1];\n        for(int i=0;i<=n;i++){\n            dp[i][0]=true;\n        }\n        for(int j=1;j<=num;j++){\n            dp[n][j]=false;\n        }\n        for(int i=n-1;i>=0;i--){\n            for(int j=1;j<=num;j++){\n                dp[i][j]=dp[i+1][j];\n                if(j>=coins[i]){\n                    dp[i][j]=dp[i][j]||dp[i+1][j-coins[i]];\n                }\n            }\n        }\n        return dp[0][num];\n    }    \n\n    bool check(vector<int>& nums, vector<vector<int>>& queries,int ql){\n        int n=nums.size();\n        vector<int> vals[n];\n        for(int q=0;q<ql;q++){\n            for(int i=queries[q][0];i<=queries[q][1];i++){\n                vals[i].push_back(queries[q][2]);\n            }\n        }\n        bool ans=true;\n        for(int i=0;i<n;i++){\n            ans=ans&&subsetSum(nums[i],vals[i]);\n        }\n        return ans;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l=0,r=queries.size(),ans=-1;\n        while(l<=r){\n            int mid=l+(r-l)/2;\n            if(check(nums,queries,mid)){\n                ans=mid;\n                r=mid-1;\n            }\n            else l=mid+1;\n        }        \n        return ans;\n    }\n};","author":"Adithya G","submissionId":"1575146257"},[]]},{"243":[{"id":"243","fileName":"1575146778.txt","sourceCode":"int dp[1001][1001];\n\nclass Solution {\npublic:\n    bool solve(int i, int sum, int target, vector<int>& choice)\n    {\n        int n = choice.size();\n        if (sum == target)\n            return true;\n        if (i == n)\n            return false;\n        if (sum > target)\n            return false;\n        if (dp[i][sum] != -1)\n            return dp[i][sum];\n        bool res = solve(i + 1, sum, target, choice) || solve(i + 1, sum + choice[i], target, choice);\n        return dp[i][sum] = res;\n    }\n    \n    bool check(int x, vector<int>& nums, vector<vector<int>>& queries)\n    {\n        int n = nums.size();\n        int m = queries.size();\n        vector<vector<int>> choice(n);\n        for (int i = 0; i < x; i++)\n        {\n            auto& q = queries[i];\n            for (int i = q[0]; i <= q[1]; i++)\n                choice[i].push_back(q[2]);\n        }\n        int good = 0;\n        for (int i = 0; i < n; i++)\n        {\n            memset(dp, -1, sizeof(dp));\n            good += solve(0, 0, nums[i], choice[i]);\n        }\n        return good == n;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int m = queries.size();\n        int left = 0;\n        int right = m;\n        while (left <= right)\n        {\n            int mid = left + (right - left) / 2;\n            if (check(mid, nums, queries))\n                right = mid - 1;\n            else\n                left = mid + 1;\n        }\n        if (right + 1 == m + 1)\n            return -1;\n        return right + 1;\n    }\n};","author":"birds3345","submissionId":"1575146778"},[]]},{"244":[{"id":"244","fileName":"1575146637.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if all(x == 0 for x in nums):\n            return 0\n        \n        n = len(nums)\n        m = len(queries)\n        element_queries = [[] for _ in range(n)]\n        \n        for orig_idx, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                element_queries[i].append((val, orig_idx))\n        \n        max_k = 0\n        \n        for i in range(n):\n            if nums[i] == 0:\n                continue\n            \n            target = nums[i]\n            Q_i = element_queries[i]\n            \n            if not Q_i:\n                return -1\n            \n            dp = {0}\n            found = False\n            current_k = -1\n            \n            for val, orig_idx in Q_i:\n                new_s_possible = set()\n                for s in list(dp):\n                    new_s = s + val\n                    if new_s == target:\n                        current_k = orig_idx + 1\n                        found = True\n                        break\n                    if new_s < target:\n                        new_s_possible.add(new_s)\n                if found:\n                    break\n                \n                merged = dp.union(new_s_possible)\n                if target in merged:\n                    current_k = orig_idx + 1\n                    found = True\n                    break\n                dp = merged\n            \n            if not found:\n                return -1\n            \n            if current_k > max_k:\n                max_k = current_k\n        \n        return max_k if max_k != 0 else -1\n","author":"Sravanam Charan","submissionId":"1575146637"},[]]},{"245":[{"id":"245","fileName":"1575146798.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        int ret = 0;\n\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == 0) {\n                continue;\n            }\n\n            unordered_set<int> prev;    \n            unordered_set<int> curr;\n            prev.insert(nums[i]);\n            for (int j = 0; j < m; ++j) {\n                if (queries[j][0] > i || queries[j][1] < i) {\n                    continue;\n                }\n\n                int val = queries[j][2];\n                for (const auto p: prev) {\n                    if (p >= val) {\n                        curr.insert(p - val);\n                    }\n                }\n\n                prev.insert(curr.begin(), curr.end());\n                curr.clear();\n\n                if (prev.find(0) != prev.end()) {\n                    ret = max(ret, j + 1);\n                    break;\n                }\n            }\n\n            if (prev.find(0) == prev.end()) {\n                return -1;\n            }\n        }\n\n        return ret;\n    }\n};","author":"nick698715","submissionId":"1575146798"},[]]},{"246":[{"id":"246","fileName":"1575146463.txt","sourceCode":"from typing import List, Set\n\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        num_sets: List[Set[int]] = [set([num]) for num in (nums)]\n\n        def update_num_set(i: int, v: int):\n            s1 = num_sets[i]\n\n            if 0 in s1:\n                return\n\n            s2 = set([num - v for num in s1 if num - v >= 0])\n\n            num_sets[i] = s1 | s2\n\n        def is_zero_array():\n            for s in num_sets:\n                if 0 not in s:\n                    return False\n            return True\n\n        if is_zero_array():\n            return 0\n\n        for j, q in enumerate(queries):\n            l, r, v = q\n\n            for i in range(l, r + 1):\n                update_num_set(i, v)\n\n            if is_zero_array():\n                return j + 1\n\n        return -1\n\n ","author":"ocavue","submissionId":"1575146463"},[]]},{"247":[{"id":"247","fileName":"1575146867.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        left = 0\n        right = len(queries)\n        n = len(nums)\n\n        def can_be_zero(cur, target):\n            mask = 1 << 0\n            for num in cur:\n                mask |= (mask << num)\n                if (mask & (1 << target)) != 0:\n                    return True\n            return (mask & (1 << target)) != 0\n        \n        def check(k):\n            for i in range(n):\n                cur = []\n                for j in range(k):\n                    l, r, v = queries[j]\n                    if l <= i <= r:\n                        cur.append(v)\n                if not can_be_zero(cur, nums[i]):\n                    return False\n            return True\n            \n        if not check(right):\n            return -1\n        while left < right:\n            mid = (left + right) // 2\n            if check(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n            ","author":"svmh","submissionId":"1575146867"},[]]},{"248":[{"id":"248","fileName":"1575146999.txt","sourceCode":"#define ll long long\n#define ull unsigned long long\n#define sz(x) (int)x.size()\n#define pb(...) push_back(__VA_ARGS__)\n#define mp(x, y) make_pair(x, y)\n#define all(x) (x).begin(), (x).end()\n#define sort(x) sort(all(x))\n#define reverse(x) reverse(all(x))\n#define MIN(x) *min_element(all(x))\n#define MAX(x) *max_element(all(x))\n#define SUM(x) accumulate(all(x), 0)\n#define FOR(i, a, b, c) for(int i = a; i < b; i+=c)\n#define I(x) for(auto&i:x)cin>>i\n#define umap unordered_map\n#define uset unordered_set\n#define F first\n#define S second\n#define vll vector<ll>\n#define vvll vector<vector<ll>>\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define lb(x) lower_bound(x) // First element NOT LESS than val\n#define ub(x) upper_bound(x) // First element GREATER than val\n#define PI 3.1415926535897932384626433832795\n#define MOD 1000000007\n#define mod 998244353\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = sz(nums), Q = sz(queries);\n        vector<bitset<1001>> v(n);\n        for(int i = 0; i < n; ++i) v[i][nums[i]] = 1;\n        function<bool()> check = [&](){\n            bool work = 1;\n            for(int i = 0; i < n; ++i) work &= v[i][0];\n            return work;\n        };\n        for(int q = 0; q < Q; ++q){\n            if(check()) return q;\n            int l = queries[q][0], r = queries[q][1], val = queries[q][2];\n            for(int i = l; i <= r; ++i){\n                for(int j = 0; j <= nums[i]; ++j){\n                    if(j - val < 0) continue;\n                    v[i][j-val] = v[i][j-val] | v[i][j];\n                }\n            }\n        }\n        if(check()) return Q;\n        else return -1;\n    }\n};","author":"Sarthak Jain","submissionId":"1575146999"},[]]},{"249":[{"id":"249","fileName":"1575146198.txt","sourceCode":"class Solution {\npublic:\nbool chk2(int k, vector<int>&v) \n{\n    int n = v.size();\n    vector<vector<int>>dp(n, vector<int>(k + 1, 0));\n    for(int i = 0; i < n; i++) \n    {\n        dp[i][0] = 1;\n    }\n    if(v[0] <= k) \n    {\n        dp[0][v[0]] = 1;\n    }\n    for(int i = 1; i < n; i++) \n    {\n        for(int t = 1; t <= k; t++) \n        {\n            int skip = dp[i - 1][t];\n            int take = 0;\n            if (v[i] <= t) \n            {\n                take = dp[i - 1][t - v[i]];\n            }\n            dp[i][t] = (skip | take);\n        }\n    }\n    return dp[n - 1][k];\n}\n    bool check(int mid, vector<int>&v, vector<vector<int>>&q)\n    {\n        int n = v.size();\n        vector<vector<int>>sst(n); // elements for each\n        for(int i = 0; i <=  mid; i++)\n        {\n            int qst = q[i][0], qend = q[i][1], val = q[i][2];\n            for(int k = qst; k <= qend; k++)\n            {\n                sst[k].push_back(val);\n            }\n        }\n        for(int i = 0; i < n; i++)\n            {\n                if(!sst[i].empty())\n                {\n                    sort(sst[i].begin(), sst[i].end());\n                }\n            }\n        for(int i = 0; i < n; i++)\n        {\n            // vector<int>&tmp = sst[i];\n            if(sst[i].empty())\n            {\n                if(v[i] != 0) return 0;\n            }\n            else if(chk2(v[i], sst[i]) == 0)\n            {\n                return 0;\n            }\n        }\n        return 1;\n        \n    }\n    int minZeroArray(vector<int>& v, vector<vector<int>>& q) \n{\n    // vector<int>t = {1, 2, 3, 6};\n    // cout << chk2(9, t) << endl;\n    int n = v.size(), qs = q.size();\n    int ans = 1e9;\n    bool f = 0;\n    for(auto it : v)\n        {\n            if(it != 0) f= 1;\n        }\n    if(f == 0) return 0;\n    int low = 0, high = qs -1;\n    // while(low <= high)\n    //     {\n    //         int mid = (low + high)/2;\n    //         if(check(mid, v, q))\n    //         {\n    //             ans = mid; \n    //             high = mid -1;\n    //         }\n    //         else \n    //         {\n    //             low = mid + 1;\n    //         }\n    //     }\n    for(int i = 0; i <= high; i++)\n        {\n            if(check(i, v, q) == 1)\n            {\n                ans = i; break;\n            }\n        }\n    if(ans == 1e9) return -1;\n    return ans + 1;\n    \n        \n    }\n};","author":"Varun Damodaran","submissionId":"1575146198"},[]]},{"250":[{"id":"250","fileName":"1575147495.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def helper(i, num):\n            if num == 0:\n                return 0\n            curr = set([num])\n            for j, (l, r, val) in enumerate(queries, 1):\n                if l <= i <= r:\n                    for t in list(curr):\n                        if t == val:\n                            return j\n                        curr.add(t - val)\n            return -1\n        ans = 0\n        for i, num in enumerate(nums):\n            t = helper(i, num)\n            # print(i, num, t)\n            if t == -1:\n                return -1\n            ans = max(ans, t)\n        return ans","author":"chengxia you","submissionId":"1575147495"},[]]},{"251":[{"id":"251","fileName":"1575147354.txt","sourceCode":"// fn main() {\n//     // let mut stdin = LineSource::new(BufReader::new(io::stdin()));\n//     // macro_rules! input(($($tt:tt)*) => (proconio::input!(from &mut stdin, $($tt)*)));\n// }\n\n// #[allow(dead_code)]\n// struct Solution;\n\nimpl Solution {\n    pub fn min_zero_array(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> i32 {\n        if nums.iter().all(|&v| v == 0) {\n            return 0;\n        }\n        let mut ans = 0;\n        let n = nums.len();\n        'a: for i in 0..n {\n            let max = 1000;\n            let mut dp = vec![false; max + 1];\n            dp[0] = true;\n            for (j, q) in queries.iter().enumerate() {\n                let l = q[0] as usize;\n                let r = q[1] as usize;\n                let v = q[2] as usize;\n                if i < l || r < i {\n                    continue;\n                }\n                for k in (0..=max).rev() {\n                    if !dp[k] || k + v > max {\n                        continue;\n                    }\n                    dp[k + v] = true;\n                }\n                if dp[nums[i] as usize] {\n                    ans = ans.max(j);\n                    continue 'a;\n                }\n            }\n            return -1;\n        }\n        (ans + 1) as i32\n    }\n}\n","author":"nayo0513","submissionId":"1575147354"},[]]},{"252":[{"id":"252","fileName":"1575147499.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        d = [0] * n\n        k = [[] for _ in range(n)]\n        s = [[0] * 1001 for _ in range(n)]\n        for i in range(n):\n            s[i][0] = 1\n            \n        def chk():\n            for i in range(n):\n                if not s[i][nums[i]]:\n                    return False\n            return True\n        \n        if chk():\n            return 0\n        \n        for i in range(len(queries)):\n            v = queries[i][2]\n            for t in range(queries[i][0],queries[i][1]+1):\n                if s[t][nums[t]]:\n                    continue\n                for j in range(nums[t]-1,-1,-1):\n                    if s[t][j] and j + v <= nums[t]:\n                        s[t][j+v] = 1\n                \n            if chk():\n                return i + 1\n        return -1","author":"nemokwy","submissionId":"1575147499"},[]]},{"253":[{"id":"253","fileName":"1575147527.txt","sourceCode":"class Solution {\npublic:\n    bool f[11][1010];\n\n    void dp(int l, int r, int val) {\n        for (int i = l; i <= r; i ++) {\n            for (int j = 1000; j >= 0; j --)\n                if (f[i][j] && j + val <= 1000)\n                    f[i][j + val] = true;\n        }\n    }\n\n    int minZeroArray(vector<int>& a, vector<vector<int>>& que) {\n        memset(f, 0, sizeof(f));\n        for (int i = 0; i < a.size(); i ++)\n            f[i][0] = true;\n        int t = 0;\n        for (int i : a) {\n            t += i;\n        }\n        if (t == 0) return 0;\n\n\n        for (int i = 0; i < que.size(); i ++) {\n            dp(que[i][0], que[i][1], que[i][2]);\n            bool ok = true;\n            for (int i = 0; i < a.size(); i ++)\n                if (!f[i][a[i]]) ok = false;\n            if (ok) return i + 1;\n        }\n\n        return -1;\n    }\n};","author":"pipipi","submissionId":"1575147527"},[]]},{"254":[{"id":"254","fileName":"1575147593.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int ql = queries.length;\n        int low=0,high=ql-1,mid;\n        int ans=-1;\n        if(check(-1,nums,queries)) {\n            return 0;\n        }\n        while(low<=high) {\n            mid=(low+high)/2;\n            if(check(mid,nums,queries)) {\n                ans=mid;\n                high=mid-1;\n            } else {\n                low=mid+1;\n            }\n        }\n        return ans==-1 ? -1 : ans+1;\n    }\n    private boolean check(int k,int[] nums, int[][] queries) {\n        List<List<Integer>> lst = new ArrayList<>();\n        int len = nums.length;\n        for(int i=0;i<len;i++) {\n            lst.add(new ArrayList<>());\n        }\n        //\n        for(int idx=0;idx<=k;idx++) {\n            for(int i=queries[idx][0];i<=queries[idx][1];i++) {\n                lst.get(i).add(queries[idx][2]);\n            }\n        }\n        //\n        for(int i=0;i<len;i++) {\n            if(!subSetSum(nums[i],lst.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private boolean subSetSum(int val,List<Integer> nums) {\n        boolean dp[] = new boolean[val+1];\n        dp[0]=true;\n        for(int num : nums) {\n            for(int j=val;j>=num;j--) {\n                dp[j]|=dp[j-num];\n            }\n        }\n        return dp[val];\n    }\n}\n\n","author":"Jaydutt","submissionId":"1575147593"},[]]},{"255":[{"id":"255","fileName":"1575147587.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int start = 0;\n        int end = queries.length;\n        int ans = -1;\n        while(start<=end){\n            int mid = start + (end-start)/2;\n            if(poss(mid, nums, queries)){\n                ans = mid;\n                end = mid-1;\n            }else{\n                start = mid+1;\n            }\n        }\n\n        return ans;\n    }\n    \n    private boolean poss(int mid, int[] nums, int[][] queries){\n        int n = nums.length;\n        List<Integer>[] arr = new ArrayList[n];\n        Arrays.setAll(arr, i->new ArrayList<>());\n        for(int i = 0; i<mid; i++){\n            for(int j = queries[i][0]; j<=queries[i][1]; j++){\n                arr[j].add(queries[i][2]);\n            }\n        }\n        for(int i = 0; i<n; i++){\n            Boolean[][] dp = new Boolean[arr[i].size()][nums[i]+1];\n            if(!poss(0, nums[i], arr[i], dp)){\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    private boolean poss(int idx, int val, List<Integer> al, Boolean[][] dp){\n        if(val < 0) return false;\n        if(idx == al.size()){\n            return val == 0;\n        }else{\n            if(dp[idx][val]!=null) return dp[idx][val];\n            \n            return dp[idx][val] = poss(idx+1, val-al.get(idx), al, dp) || poss(idx+1, val, al, dp);\n        }\n    }\n}","author":"Dinesh Chandran","submissionId":"1575147587"},[]]},{"256":[{"id":"256","fileName":"1575148211.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if len(set(nums)) == 1 and nums[0] == 0:\n            return 0\n        \n        values = [{0} for _ in range(len(nums))]\n        for k in range(len(queries)):\n            l, r, v0 = queries[k]\n            covered = 0\n            for pos in range(len(nums)):\n                target = nums[pos]\n                if target in values[pos]:\n                    covered += 1\n                    continue\n                if l <= pos <= r:\n                    set1 = values[pos].copy()\n                    for v in values[pos]:\n                        if v + v0 > target:\n                            continue\n                        else:\n                            set1.add(v + v0)\n                            if v + v0 == target:\n                                covered += 1\n                    values[pos] = set1\n            \n            if covered == len(nums):\n                return k + 1\n        \n        return -1\n                        \n                    \n                    ","author":"John smith","submissionId":"1575148211"},[]]},{"257":[{"id":"257","fileName":"1575148359.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        \n        int n = nums.size();\n\n\n        \n        int high = 0;\n        \n        for(int i = 0; i < n; i++)\n        {\n            //cout << \"reading index \" << i << endl;\n            int x = nums[i];\n            vector<vector<int>> T;\n            int ctr = 0;\n            for(auto &v : queries)\n            {\n                ctr++;\n                int l = v[0];\n                int r = v[1];\n                int c = v[2];\n                if(l <= i && i <= r)\n                {\n                    T.push_back({ctr, c});\n                }\n            }\n            \n            vector<int> vis(x+1,-1);\n            vis[x] = 0;\n            for(auto &p : T)\n            {\n                int time = p[0];\n                int step = p[1];\n                //cout << \" \" << time << \" : \" << step << endl;\n                for(int k = 0; k < x; k++)\n                {\n                    if(vis[k] == -1 && k+step <= x && vis[k+step] != -1)\n                    {\n                        vis[k] = time;\n                    }\n                }\n                if(vis[0] != -1)\n                {\n                    break;\n                }\n            }\n            if(vis[0] == -1)\n            {\n                return -1;\n            }\n            high = max(high, vis[0]);\n        }\n        \n        return high;\n    }\n};","author":"Marmaduke","submissionId":"1575148359"},[]]},{"258":[{"id":"258","fileName":"1575148636.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int done = 0;\n        vector<vector<bool>> vec;\n        for (const int& i : nums) {\n            vec.push_back(vector<bool>(i + 1, false));\n            vec.back()[i] = true;\n            if (i == 0) done++;\n        }\n\n        int k = 0;\n        for (const vector<int>& q : queries) {\n            if (done == nums.size()) return k;\n            \n            for (int i = q[0]; i <= q[1]; i++) {\n                //for (const int j : vec[i]) cout << j << \" \";\n                //cout << endl;\n                if (vec[i][0]) continue;\n                for (int j = q[2]; j < vec[i].size(); j++) {\n                    if (vec[i][j]) {\n                        vec[i][j - q[2]] = true;\n                        if (j == q[2]) {\n                            done++;\n                            continue;\n                        }\n                    }\n                }\n            }\n            k++;\n        }\n        if (done == nums.size()) return k;\n        return -1;\n    }\n};\n/*\nEach num should record the numbers it could be at any given time, at each query, if a num is in the range, we can subtract val from each of the possible values of num\n*/","author":"nsmartinx","submissionId":"1575148636"},[]]},{"259":[{"id":"259","fileName":"1575149663.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def make_sum(vals, target):\n            if target < 0:\n                return False\n            possible = 1 << 0\n            max_sum = 0\n            for v in vals:\n                max_sum += v\n            if max_sum < target:\n                return False\n            \n            for v in vals:\n                possible |= (possible << v)\n            return (possible >> target) & 1 == 1\n            \n        def check(k):\n            n = len(nums)\n            cover_vals = [[] for _ in range(n)]\n            for idx in range(k):\n                l, r, val = queries[idx]\n                for i in range(l, r + 1):\n                    cover_vals[i].append(val)\n\n            for i in range(n):\n                if nums[i] == 0:\n                    continue\n                if not make_sum(cover_vals[i], nums[i]):\n                    return False\n            return True\n\n        m = len(queries)\n        \n        left, right = 0, m + 1\n        ans = -1\n        while left < right:\n            mid = (left + right) // 2\n            if check(mid):\n                ans = mid\n                right = mid\n            else:\n                left = mid + 1\n        return right if right < m + 1 else -1","author":"ziw0372","submissionId":"1575149663"},[]]},{"260":[{"id":"260","fileName":"1575148436.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n#define P push_back\n#define R(i, l, r) for (int i = (l); i < (r); i++)\ntemplate<typename T> using V = vector<T>;\n\nstruct T_ { \n    static int f(int x) { return ((x ^ 0)); } \n};\n\nstruct A_ {\n    static bool ck(V<int>& arr, V<V<int>>& qry, int n, int k) {\n        R(i, T_::f(0), T_::f(n)) {\n            int tar = T_::f(arr[i]);\n            bitset<99791> dp;\n            dp.reset();\n            dp[T_::f(0)] = 1;\n            R(j, T_::f(0), T_::f(k)) {\n                if(qry[j][T_::f(0)] <= i && i <= qry[j][T_::f(1)]) {\n                    int dec = T_::f(qry[j][T_::f(2)]);\n                    dp |= (dp << dec);\n                }\n            }\n            if(!dp[T_::f(tar)]) return false;\n        }\n        return true;\n    }\n    \n    static int bS(int lo, int hi, function<bool(int)> cond) {\n        return (lo >= hi) ? lo : cond(T_::f((lo + hi) / 2)) ? bS(lo, T_::f((lo + hi) / 2), cond)\n                                                            : bS(T_::f((lo + hi) / 2) + 1, hi, cond);\n    }\n};\n\nclass Solution {\npublic:\n    int minZeroArray(V<int>& arr, V<V<int>>& qry) {\n        int n = (int)arr.size(), tot = (int)qry.size();\n        bool allZero = true;\n        R(i, 0, n) { if(arr[i] != 0) { allZero = false; break; } }\n        if(allZero) return 0;\n        int ans = A_::bS(T_::f(1), T_::f(tot + 1), [&](int k) -> bool {\n            return A_::ck(arr, qry, n, k);\n        });\n        return (ans == tot + 1 ? -1 : ans);\n    }\n};\n","author":"Abhay Dixit","submissionId":"1575148436"},[]]},{"261":[{"id":"261","fileName":"1575148667.txt","sourceCode":"#include <vector>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        // Precompute for each index, the queries that cover it as (query_index, value)\n        vector<vector<pair<int, int>>> covers(n);\n        for (int j = 0; j < m; j++) {\n            int l = queries[j][0], r = queries[j][1], v = queries[j][2];\n            for (int i = l; i <= r; i++) {\n                covers[i].push_back({j, v});\n            }\n        }\n        // It is useful to sort each list by the query index\n        for (int i = 0; i < n; i++) {\n            sort(covers[i].begin(), covers[i].end());\n        }\n        \n        // Given a prefix size k, check if for every index we can form exactly nums[i] using queries with index < k.\n        auto feasible = [&](int k) -> bool {\n            for (int i = 0; i < n; i++) {\n                int target = nums[i];\n                if (target == 0) continue; // Already satisfied\n                \n                // dp[j] will be true if a sum j is achievable using some subset of available query values.\n                // Maximum target is at most 1000 so we use bitset<1001>.\n                bitset<1001> dp;\n                dp.reset();\n                dp[0] = 1;\n                // Process each query (in order) that covers index i and whose index is less than k.\n                for (auto &pr : covers[i]) {\n                    if (pr.first >= k) break;\n                    int val = pr.second;\n                    // Update dp: any sum that was reachable now can also reach sum+val.\n                    dp |= (dp << val);\n                    if (dp[target]) break;  // early exit if target is reachable\n                }\n                if (!dp[target])\n                    return false;\n            }\n            return true;\n        };\n        \n        // Binary search for the smallest k such that the prefix is feasible.\n        int left = 0, right = m + 1;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (feasible(mid))\n                right = mid;\n            else\n                left = mid + 1;\n        }\n        return (left <= m ? left : -1);\n    }\n};","author":"josbuttlerr","submissionId":"1575148667"},[]]},{"262":[{"id":"262","fileName":"1575149701.txt","sourceCode":"class Solution \n{\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) \n    {\n        if(*max_element(nums.begin(), nums.end()) == 0)\n        {\n            return 0;\n        }\n        int n = nums.size(), m = queries.size();\n        vector<vector<bool>> greed(n, vector<bool>(1001));\n        for(int i = 0; i < n; i++)\n        {\n            greed[i][0] = true;\n        }\n        for(int i = 0; i < m; i++)\n        {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            for(int j = l; j <= r; j++)\n            {\n                if(greed[j][nums[j]])\n                {\n                    continue;\n                }\n                for(int k = nums[j]; k - val >= 0; k--)\n                {\n                    greed[j][k] = greed[j][k] || greed[j][k - val];\n                }\n            }\n            bool fin = true;;\n            for(int j = 0; j < n && fin; j++)\n            {\n                if(!greed[j][nums[j]])\n                {\n                    fin = false;\n                }\n            }\n            if(fin)\n            {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"Chou","submissionId":"1575149701"},[]]},{"263":[{"id":"263","fileName":"1575147709.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int q = queries.size();\n        int l = 0, r = q;\n        while (l < r) {\n            int m = (l + r) / 2;\n            if (possible(m, nums, queries)) {\n                r = m;\n            } else {\n                l = m+1;\n            }\n        }\n        if (possible(l, nums, queries)) {\n            return l;\n        }\n        return -1;\n    }\n\n    bool possible(int m, vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> coins(n);\n        for (int i = 0; i < m; i++) {\n            auto q = queries[i];\n            for (int j = q[0]; j <= q[1]; j++) {\n                coins[j].push_back(q[2]);\n            }\n        }\n        for (int t = 0; t < n; t++) {\n            vector<bool> dp(nums[t]+1, false);\n            dp[0] = true;\n            for (int c : coins[t]) {\n                for (int i = nums[t]; i >= c; i--) {\n                    if (dp[i-c]) dp[i] = true;\n                }\n            }\n            if (!dp[nums[t]]) return false;\n        }\n        return true;\n    }\n};","author":"Ahmad Zaky","submissionId":"1575147709"},[]]},{"264":[{"id":"264","fileName":"1575149845.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        /*\n        can view in reverse, need each val modified from queries to sum up to target num in nums\n        so can hold all the potential modified evrsions of nums until get one that sums to target with it\n        if a query can impact nums, diverge state to hold num = 0 and num = queryVal\n        then for next diverge state again into 4 different staets can continue.\n        This sttate divergennce would be exponential, but sinnce nums[i] <= 1000 the targets we reach are bounded by 1000 annd \n        sttart at a min of 0, so no single idnex will ever have > 1001 being processed.\n        This bounds to 1e4 branchs in total att once, and with 1e3 queries might barely pass at 1e7, we'll see*/\n        \n        int n = nums.length, m = queries.length;\n        Set<Integer>[] possibleIndexStates = new HashSet[n];\n        for(int i = 0; i < n; i++) {\n            possibleIndexStates[i] = new HashSet<>();\n            possibleIndexStates[i].add(0);\n        }\n        \n        for(int i = 0; i < m; i++) {\n            boolean canZero = true;\n            for(int j = 0; j < n && canZero; j++) {\n                canZero = possibleIndexStates[j].contains(nums[j]);\n            }\n            if(canZero) return i;\n            for(int j = queries[i][0]; j <= queries[i][1]; j++) {\n                if(possibleIndexStates[j].contains(nums[j])) continue;\n                Set<Integer> newStates = new HashSet<>();\n                for(int cand : possibleIndexStates[j]) {\n                    if(cand + queries[i][2] <= nums[j]) {\n                        newStates.add(cand + queries[i][2]);\n                        if(cand + queries[i][2] == nums[j]) break;\n                    }\n                }\n                possibleIndexStates[j].addAll(newStates);\n            }\n            \n             \n        }\n        \n        \n        boolean canZero = true;\n        for(int j = 0; j < n && canZero; j++) {\n            canZero = possibleIndexStates[j].contains(nums[j]);\n        }\n        if(canZero) return m;\n        \n        \n        return -1;\n    }\n}","author":"Nicholas Ulman","submissionId":"1575149845"},[]]},{"265":[{"id":"265","fileName":"1575149777.txt","sourceCode":"import java.util.HashSet;\nimport java.util.Set;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length, m = queries.length;\n        boolean a = true;\n        for (int num : nums) {\n            if (num != 0) {\n                a = false;\n                break;\n            }\n        }\n        if (a) return 0;\n        Set<Integer>[] dp = new HashSet[n];\n        for (int i = 0; i < n; i++) {\n            dp[i] = new HashSet<>();\n            dp[i].add(0);\n        }\n        for (int k = 0; k < m; k++) {\n            int l = queries[k][0], r = queries[k][1], v = queries[k][2];\n            for (int i = l; i <= r; i++) {\n                Set<Integer> newSet = new HashSet<>();\n                for (int s : dp[i]) {\n                    int ns = s + v;\n                    if (ns <= nums[i]) newSet.add(ns);\n                }\n                dp[i].addAll(newSet);\n            }\n            boolean ok = true;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i].contains(nums[i])) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) return k + 1;\n        }\n        return -1;\n    }\n}\n","author":"Subash P","submissionId":"1575149777"},[]]},{"266":[{"id":"266","fileName":"1575149874.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int temp = 0;\n        vector<vector<bool>> dp(nums.size());\n        for (int i = 0; i < nums.size(); i++) {\n            dp[i] = vector<bool>(nums[i] + 1, false);\n            dp[i][0] = true;\n            if (nums[i] == 0) temp++;\n        }\n        if (temp == nums.size()) return 0;\n        for (int i = 0; i < queries.size(); i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int v = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                if (!dp[j][nums[j]]) {\n                    for (int k = nums[j]; k >= 0; k--) {\n                        if (dp[j][k]) {\n                            if (dp[j][k + v] <= nums[j]) {\n                                dp[j][k + v] = true;\n                            }\n                        }\n                    }\n                    if (dp[j][nums[j]]) {\n                        temp++;\n                    }\n                }\n            }\n            if (temp == nums.size()) return i + 1;\n        }\n        return -1;\n    }\n};","author":"嘉智 陈","submissionId":"1575149874"},[]]},{"267":[{"id":"267","fileName":"1575150115.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        dpd = [False] * len(nums)\n        dp = [set([0]) for _ in range(len(nums))]\n        if not any(nums):\n            return 0\n        for i in range(len(queries)):\n            for j in range(queries[i][0], queries[i][1] + 1):\n                if not dpd[j]:\n                    t = set()\n                    for k in dp[j]:\n                        t.add(k + queries[i][2])\n                    dp[j] |= t\n                    if nums[j] in dp[j]:\n                        dpd[j] = True\n            if all(dpd):\n                return i + 1\n        return -1\n        ","author":"dennis458","submissionId":"1575150115"},[]]},{"268":[{"id":"268","fileName":"1575149921.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        set<int> s;\n        for (auto &i : nums) {\n            s.insert(i);\n        }\n        if (s.size() == 1 && *s.begin() == 0) return 0;\n        const int MAX_VAL = 1000;\n        vector<vector<bool>> dp(nums.size(), vector<bool>(MAX_VAL + 1));\n        for (int i = 0; i < (int) nums.size(); i++) {\n            dp[i][0] = true;\n        }\n        for (int q = 0; q < (int) queries.size(); q++) {\n            int l = queries[q][0], r = queries[q][1], val = queries[q][2];\n            for (int i = l; i <= r; i++) {\n                for (int j = MAX_VAL; j >= val; j--) {\n                    if (dp[i][j - val]) dp[i][j] = true;\n                }\n            }\n            bool flag = true;\n            for (int i = 0; i < (int) nums.size(); i++) {\n                if (!dp[i][nums[i]]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) return q + 1;\n        }\n        return -1;\n    }\n};","author":"allforest01","submissionId":"1575149921"},[]]},{"269":[{"id":"269","fileName":"1575149898.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        \n        String path = \"\";\n        boolean found = true;\n        long ans = Integer.MAX_VALUE;\n        \n        for (int num : nums) {\n            if (num != 0) {\n                found = false;\n                break;\n            }\n            if (num == 0) {\n                ans = 0;\n            }\n        }\n        print(ans);\n        if (found) {\n            return 0;\n        }\n\n        int q = queries.length;\n        int lo = 0, hi = q + 1;\n        \n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (bsHelper(mid, nums, queries)) {\n                hi = mid;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        print(lo);\n        print(hi);\n        if (lo > q) {\n            return -1;\n        }\n        return lo;\n        \n    }\n    public static int min(int a, int b) {\n        if (a < b) {\n            return a;\n        }\n        return b;\n    }\n    public static int max(int a, int b) {\n        if (a > b) {\n            return a;\n        }\n        return b;\n    }\n    public static <E> void print(E res) {\n        System.out.println(res);\n    }\n    public static <E> void printArr(int[] arr) {\n        System.out.println(Arrays.toString(arr));\n    }\n\n    public static int houseRobber4(int[] nums, int index, int count, int k, int currentCap, int[][][] dp) {\n\n        if (count >= k) {\n            return currentCap;\n        }\n\n        if (index >= nums.length) {\n            return Integer.MAX_VALUE;\n        }\n\n        if (dp[index][count][currentCap] != -1) {\n            return dp[index][count][currentCap];\n        }\n\n        int skip = houseRobber4(nums, index + 1, count, k, currentCap, dp);\n\n        int newCap = Math.max(currentCap, nums[index]);\n        int pick = houseRobber4(nums, index + 2, count + 1, k, newCap, dp);\n\n        return dp[index][count][currentCap] = Math.min(skip, pick);\n    }\n\n    public static boolean coinChangeCF(int[] coins, int index, int target, int[][] dp) {\n\n        if (target == 0) {\n            return true;\n        }\n\n        if (index == coins.length) {\n            return false;\n        }\n\n        if (dp[index][target] != -1) {\n            return dp[index][target] == 1;\n        }\n\n        boolean Pick = false;\n\n        if (target >= coins[index]) {\n            Pick = coinChangeCF(coins, index, target - coins[index], dp);\n        }\n        boolean notPick = coinChangeCF(coins, index + 1, target, dp);\n\n        boolean res = Pick || notPick;\n        dp[index][target] = res ? 1 : 0;\n        return res;\n    }\n    \n    public static boolean bsHelper(int k, int[] nums, int[][] queries) {\n        \n        for (int i = 0; i < nums.length; i++) {\n            int t = nums[i];\n            boolean[] dp = new boolean[t + 1];\n            dp[0] = true;\n            for (int j = 0; j < k; j++) {\n                if (queries[j][0] <= i && i <= queries[j][1]) {\n                    int val = queries[j][2];\n                    for (int s = t; s >= val; s--) {\n                        dp[s] = dp[s] || dp[s - val];\n                    }\n                }\n            }\n            if (!dp[t]) return false;\n        }\n        return true;\n    }\n    \n    public static int coinChangeLC(int[] coins, int index, int target, int[][] dp) {\n\n        if (index == coins.length - 1) return target % coins[index] == 0 ? target / coins[index] : (int) 1e9;\n\n        if (dp[index][target] != -1) {\n            return dp[index][target];\n        }\n\n        int Pick = (int) 1e9;\n\n        if (target >= coins[index]) {\n            Pick = 1 + coinChangeLC(coins, index, target - coins[index], dp);\n        }\n        int notPick = 0 + coinChangeLC(coins, index + 1, target, dp);\n\n        return dp[index][target] = Math.min(Pick, notPick);\n    }\n    public static int coinChangeGFG(int[] coins, int index, int target, int[][] dp) {\n\n        if (index == coins.length - 1) return target % coins[index] == 0 ? 1 : 0;\n\n        if (dp[index][target] != -1) {\n            return dp[index][target];\n        }\n\n        int Pick = 0;\n\n        if (target >= coins[index]) {\n            Pick = 1 + coinChangeGFG(coins, index, target - coins[index], dp);\n        }\n        int notPick = 0 + coinChangeGFG(coins, index + 1, target, dp);\n\n        return dp[index][target] = Pick + notPick;\n    }\n    public static int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n    public static int lcm(int a, int b) {\n        return (a * b) / gcd(a, b);\n    }\n    \n    public static int frogJump(int[] arr) {\n            \n        int n = arr.length;\n        int[] dp = new int[n];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j <= i + 2 && j < n; j++) {\n                dp[j] = Math.min(dp[j], dp[i] + Math.abs(arr[i] - arr[j]));\n            }\n        }\n        return dp[n - 1];\n    }\n    \n    public static int minJumps(int[] nums, int index) {\n\n        if (index >= nums.length - 1) {\n            return 0;\n        }\n\n        int minJumps = 99999;\n\n        for (int i = 1; i <= nums[index]; i++) {\n            minJumps = min(minJumps, 1 + minJumps(nums, index + i));\n        }\n        return minJumps;\n    }\n\n    public static int knapSack(int w, int[] values, int[] weights, int index, int[] dp) {\n\n        if (index >= values.length) {\n            return 0;\n        }\n\n        if (w <= 0) {\n            return 0;\n        }\n\n        if (dp[index] != -1) {\n            return dp[index];\n        }\n\n        int Pick = 0;\n        if (w >= weights[index]) {\n            Pick = values[index] + knapSack(w - weights[index], values, weights, index + 1, dp);\n        }\n        int notPick = 0 + knapSack(w, values, weights, index + 1, dp);\n\n        return dp[index] = max(Pick, notPick);\n    }\n\n\n    public static boolean isPowerof2(int n) {\n        return (n & (n - 1)) == 0;\n    }\n    public static boolean containsAllOnes(int n) {\n        return (n & (n + 1)) == 0;\n    }\n\n    public static boolean isPowerof3(int n, int index) {\n\n        if (n == 0) {\n            return true;\n        }\n\n        if (n < 0 || Math.pow(3, index) > n) {\n            return false;\n        }\n\n        boolean Pick = isPowerof3(n - (int) Math.pow(3, index), index + 1);\n        boolean notPick = isPowerof3(n, index + 1);\n\n        return Pick || notPick;\n    }\n\n    public static String longestPalindrome(String s) {\n\n        int n = s.length();\n        Boolean[][] memo = new Boolean[n][n];\n        int maxLen = 0;\n        int start = 0;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                if (isPalindrome(s, i, j, memo)) {\n                    if (j - i + 1 > maxLen) {\n                        maxLen = j - i + 1;\n                        start = i;\n                    }\n                }\n            }\n        }\n        return s.substring(start, start + maxLen);\n    }\n\n    private static boolean isPalindrome(String s, int i, int j, Boolean[][] memo) {\n\n        if (i >= j) return true;\n\n        if (memo[i][j] != null) return memo[i][j];\n\n        if (s.charAt(i) == s.charAt(j)) {\n            memo[i][j] = isPalindrome(s, i + 1, j - 1, memo);\n        } else {\n            memo[i][j] = false;\n        }\n\n        return memo[i][j];\n    }\n\n    public static int MinCostClimbingStairs(int[] cost, int index, int[] dp) {\n\n        if (index >= cost.length) {\n            return 0;\n        }\n\n        if (dp[index] != 0) {\n            return dp[index];\n        }\n\n        int one = cost[index] + MinCostClimbingStairs(cost, index + 1, dp);\n        int two = cost[index] + MinCostClimbingStairs(cost, index + 2, dp);\n\n        return dp[index] = Math.min(one, two);\n    }\n    public static int climbingStairs(int n, int[] dp) {\n\n        if (n < 3) {\n            return n;\n        }\n\n        if (dp[n] != -1) {\n            return dp[n];\n        }\n\n        int one = climbingStairs(n - 1, dp);\n        int two = climbingStairs(n - 2, dp);\n\n        return dp[n] = one + two;\n    }\n    public static boolean isPalindrome(String s, int i, int j) {\n\n        if (i >= j) {\n            return true;\n        }\n\n        if (s.charAt(i) != s.charAt(j)) {\n            return false;\n        }\n\n        return isPalindrome(s, i + 1, j - 1);\n    }\n\n    public static boolean isPrime (int n) {\n\n        if (n == 1) {\n            return false;\n        }\n\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    public static boolean canEat(int[] piles, int h, int k) {\n\n        int hours = 0;\n\n        for (int pile : piles) {\n            int div = pile / k;\n            hours += div;\n            if (pile % k != 0) {\n                hours ++;\n            }\n        }\n        return hours <= h;\n    }\n\n    public static int abcAsSubString(String s) {\n\n        int[] count = new int[3];\n        int ans = 0;\n        int left = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            count[s.charAt(i) - 'a'] ++;\n            while (count[0] > 0 && count[1] > 0 && count[2] > 0) {\n                ans += s.length() - i;\n                count[s.charAt(left) - 'a'] --;\n                left ++;\n            }\n        }\n        return ans;\n    }\n\n    public static boolean abcfinder(String s) {\n        return s.contains(\"a\") && s.contains(\"b\") && s.contains(\"c\");\n    }\n    public static int longestPalindromicSubseq(String s, int i, int j, int[][] dp) {\n\n        if (i > j) {\n            return 0;\n        }\n\n        if (i == j) {\n            return 1;\n        }\n\n        if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n        if (s.charAt(i) == s.charAt(j)) {\n            return 2 + longestPalindromicSubseq(s, i + 1, j - 1, dp);\n        }\n\n        int a = longestPalindromicSubseq(s, i + 1, j, dp);\n        int b = longestPalindromicSubseq(s, i, j - 1, dp);\n\n        return dp[i][j] = Math.max(a, b);\n    }\n    public static void permutations1(int[] nums, int index, List<Integer> running, List<List<Integer>> ans) {\n\n        // base case\n        if (index >= nums.length) {\n            ans.add(new ArrayList<>(running));\n            return; \n        }\n\n        for (int i = 0; i < nums.length; i++) {\n            if (running.contains(nums[i])) continue;\n            running.add(nums[i]);\n            permutations1(nums, index + 1, running, ans);\n            running.remove(running.size() - 1);\n        }\n    }\n\n    public static int lcs(String s1, String s2, int i, int j, int[][] dp)  {\n\n        if (i == s1.length() || j == s2.length()) {\n            return 0;\n        }\n\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n\n        if (s1.charAt(i) == s2.charAt(j)) {\n            return 1 + lcs(s1, s2, i + 1, j + 1, dp);\n        }\n\n        int op1 = lcs(s1, s2, i + 1, j, dp);\n        int op2 = lcs(s1, s2, i, j + 1, dp);\n\n        return dp[i][j] = Math.max(op1, op2);\n    }\n\n    public static int[] dailyTemperatures(int[] temperatures) {\n\n\n        int n = temperatures.length;\n        int[] ans = new int[temperatures.length];\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && temperatures[stack.peek()] <= temperatures[i]) {\n                stack.pop();\n            }\n            if (stack.isEmpty()) {\n                ans[i] = 0;\n            } else {\n                ans[i] = stack.peek() - i;\n            }\n            stack.add(i);\n        }\n        return ans;\n    }\n    public static int[] NGE2(int[] nums) {\n\n        int n = nums.length;\n        int[] ans = new int[n];\n        int index = n - 1;\n\n        Stack<Integer> stack = new Stack<>();\n        for (int i = (2 * n) - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && stack.peek() <= nums[i % n]) {\n                stack.pop();\n            }\n            if (i < n) {\n                if (stack.isEmpty()) {\n                    ans[index--] = -1;\n                } else {\n                    ans[index--] = stack.peek();\n                }\n            }\n\n            stack.add(nums[i % n]);\n        }\n        return ans;\n    }\n    public static int[] NGE1 (int[] arr) {\n\n        int n = arr.length;\n        int index = n - 1;\n        int[] ans = new int[n];\n\n        Stack<Integer> stack = new Stack<>(); // []\n\n\n        for (int i = n - 1; i >= 0; i--) {\n\n            while (!stack.isEmpty() && stack.peek() <= arr[i]) {\n                stack.pop();\n            }\n            if (stack.isEmpty()) {\n                ans[index] = -1;\n            } else {\n                ans[index] = stack.peek();\n            }\n            stack.add(arr[i]);\n            index --;\n        }\n        return ans;\n    }\n    public static int maxAreaWater(int[] heights) {\n\n        int s = 0;\n        int e = heights.length - 1;\n\n        int nasDaily = 0;\n\n        while (s < e) {\n            int ans = Math.min(heights[s], heights[e]);\n            int idx = e - s;\n            nasDaily = Math.max(nasDaily, ans * idx);\n            if (heights[s] < heights[e]) {\n                s ++;\n            } else {\n                e --;\n            }\n        }\n        return nasDaily;\n    }\n    public static long coloredCell (int n) {\n\n        if (n == 1) {\n            return n;\n        }\n\n        return (n - 1) * 4 + coloredCell(n - 1);\n    }\n}","author":"Vel_Murugan","submissionId":"1575149898"},[]]},{"270":[{"id":"270","fileName":"1575150513.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        \n        maxx = []\n        \n        for p, v in enumerate(nums):\n            if v == 0:\n                maxx.append(0)\n                continue\n            \n            #print(p, v)\n            \n            seen = set()\n            \n            flag = False\n            for i in range(len(queries)):\n                #print(i)\n                l, r, val = queries[i]\n                if not (l <= p <= r):\n                    continue\n                seen1 = set([val])\n                for item in seen:\n                    if item + val <= 1000:\n                        seen1.add(item + val)\n                    seen1.add(item)\n                #print(seen1)\n                if v in seen1:\n                    flag = True\n                    break\n                seen = seen1\n            \n            if flag:\n                maxx.append(i+1)\n            else:\n                return -1\n        \n        return max(maxx)\n            \n        \n        \n        '''\n        arr = nums.copy()\n        for i in range(len(queries)):\n            l, r, val = queries[i]\n            for p in range(l, r+1):\n                arr[p] -= val\n            if all(x <= 0 for x in arr):\n                return i + 1\n        \n        return -1   \n        '''\n","author":"tinyfish1","submissionId":"1575150513"},[]]},{"271":[{"id":"271","fileName":"1575150962.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        if (all_of(nums.begin(), nums.end(), [](const int x) { return x == 0; })) {\n            return 0;\n        }\n        \n        vector<bitset<1001>> bitsets(nums.size());\n        for (int i = 0; i < bitsets.size(); ++i) {\n            bitsets[i][0] = true;\n        }\n\n        int count = 0;\n        for (const vector<int>& query : queries) {\n            count++;\n            const int start = query[0];\n            const int end = query[1];\n            const int val = query[2];\n\n            for (int i = start; i <= end; ++i) {\n                bitsets[i] |= (bitsets[i] << val);\n            }\n\n            bool ok = true;\n            for (int i = 0; i < nums.size(); ++i) {\n                if (not bitsets[i][nums[i]]) {\n                    ok = false;\n                    break;\n                } \n            }\n\n            if (ok) {\n                return count;\n            }\n        }\n        return -1;\n    }\n};","author":"timothyleong97","submissionId":"1575150962"},[]]},{"272":[{"id":"272","fileName":"1575150870.txt","sourceCode":"class Solution {\npublic:\n    vector<vector<int>>dp;\n    bool helper(int no,int ind,vector<int>&freq){\n        if(no == 0)return true;\n        else if(ind == 0)return false;\n        else if(dp[no][ind]!= -1)return dp[no][ind];\n        else{\n            int ans = 0;\n            for(int i = 0;i<=freq[ind] && no >= (i*ind )&& !ans;i++){\n                ans |= helper(no - i*ind,ind-1,freq);\n            }\n            return dp[no][ind] = ans;\n        }\n    }\n    bool isp(vector<int>& nums, vector<vector<int>>& queries,int mid,int n,int q){\n        // cout<<mid<<endl;\n        vector<vector<int>>frev(n+1,vector<int>(11,0));\n        for(int i = 0;i<mid;i++){\n            int l = queries[i][0],r = queries[i][1],v = queries[i][2];\n            frev[l][v]++;\n            frev[r+1][v]--;\n        }\n        for(int i = 1;i<n;i++){\n            for(int j = 1;j<=10;j++){\n                frev[i][j] += frev[i-1][j];\n            }\n        }\n        // if(mid == 5)\n        // for(int i = 0;i<n;i++){\n        //     for(int j = 1;j<=10;j++){\n        //         cout<<frev[i][j]<<\" \";\n        //     }\n        //     cout<<endl;\n        // }\n        for(int i = 0;i<n;i++){\n            if(nums[i]==0)continue;\n            for(int j = 0;j<=nums[i];j++)\n            fill(dp[j].begin(),dp[j].end(),-1);\n            if(!helper(nums[i],10,frev[i])){\n                // if(mid == 5)cout<<i<<endl;\n                return false;\n            }\n        }\n        return true;\n        \n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        dp.resize(1001,vector<int>(11,-1));\n        int n = nums.size();\n        int q = queries.size();\n        int l = 0,r = q,mid,ans = -1;\n        while(l <= r){\n            mid = (l + r)/2;\n            if(isp(nums,queries,mid,n,q)){\n                ans = mid;\n                r = mid - 1;\n            }\n            else l = mid + 1;\n        }\n        return ans;\n    }\n};","author":"Mayank Nichlani","submissionId":"1575150870"},[]]},{"273":[{"id":"273","fileName":"1575151204.txt","sourceCode":"class Solution:\n\n    def minKForEachIdx(self, idx, nums, queries):\n        if nums[idx]==0:\n            return 0\n        targetSum=nums[idx]\n        q=len(queries)\n        DP=[False for i in range(targetSum+1)]\n        DP[0]=True\n        for j in range(q):\n            if queries[j][0]>idx or queries[j][1]<idx:\n                continue\n            val = queries[j][2]\n            for i in range(targetSum,val-1,-1):\n                if DP[i-val]:\n                    DP[i]=True\n            \n            if DP[targetSum]:\n                return j+1\n\n        return 1001\n        \n\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        ans = 0\n        for i in range(len(nums)):\n            ans=max(ans,self.minKForEachIdx(i,nums,queries))\n\n        if ans==1001:\n            return -1\n        else:\n            return ans","author":"Sundeep Chenreddy","submissionId":"1575151204"},[]]},{"274":[{"id":"274","fileName":"1575150300.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        dp = [set() for _ in range(n)]\n        \n        for j in range(n):\n            dp[j].clear()\n            dp[j].add(0)\n\n        if all(num == 0 for num in nums):\n            return 0\n        \n        for k, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                new_vals = {x + v for x in dp[j]}\n                dp[j].update(new_vals)\n\n                for pos in range(nums[j] + 1, 1001):\n                    dp[j].discard(pos)\n\n            if all(nums[j] in dp[j] for j in range(n)):\n                return k + 1\n        \n        return -1","author":"Mithilesh Maddipati","submissionId":"1575150300"},[]]},{"276":[{"id":"276","fileName":"1575151485.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        N = len(nums)\n        Q = len(queries)\n        left = 0\n        right = Q\n        answer = -1\n\n        def can_reach(target, elements):\n            if target == 0:\n                return True\n            dp = [False] * (target + 1)\n            dp[0] = True\n            for num in elements:\n                for s in range(target, num - 1, -1):\n                    if dp[s - num]:\n                        dp[s] = True\n                        if s == target:\n                            return True\n            return dp[target]\n\n        def good(target):\n            index_vals = [[] for _ in range(N)]\n            for q in queries[:target]:\n                l, r, v = q\n                for i in range(l, r + 1):\n                    index_vals[i].append(v)\n            for i in range(N):\n                required = nums[i]\n                if required == 0:\n                    continue\n                vals = index_vals[i]\n                total = sum(vals)\n                if total < required:\n                    return False\n                if not can_reach(required, vals):\n                    return False\n            return True\n\n        while left <= right:\n            mid = (left + right) // 2\n            if good(mid):\n                answer = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        return answer if answer != -1 else -1\n","author":"Shyam Kumar Reddy K","submissionId":"1575151485"},[]]},{"277":[{"id":"277","fileName":"1575151425.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        result = -1\n        for i, v in enumerate(nums):\n            if v == 0:\n                result = max(result, 0)\n                continue\n            dp = [False] * (v + 1)\n            dp[0] = True\n            for j, (l, r, d) in enumerate(queries):\n                if l > i or r < i: \n                    continue\n                for k in range(v, d - 1, -1):\n                    dp[k] |= dp[k - d]\n                if dp[v]:\n                    result = max(result, j + 1)\n                    break\n            if not dp[v]:\n                return -1\n        return result\n                ","author":"Zhu","submissionId":"1575151425"},[]]},{"278":[{"id":"278","fileName":"1575150008.txt","sourceCode":"def subsetSumToK( k, arr):\n    if not arr and k==0:\n        return True\n    if not arr:\n        return False\n    n = len(arr)\n    dp = [[False for j in range(k + 1)] for i in range(n)]\n    for i in range(n):\n        dp[i][0] = True\n    if arr[0] <= k:\n        dp[0][arr[0]] = True\n    for ind in range(1, n):\n        for target in range(1, k + 1):\n            notTaken = dp[ind - 1][target] \n            taken = False\n            if arr[ind] <= target:\n                taken = dp[ind - 1][target - arr[ind]]\n            dp[ind][target] = notTaken or taken \n    return dp[n - 1][k]\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        def check(mid):\n            nq = queries[ : mid]\n            hmm = [[] for _ in range(n)]\n            for l,r,val in nq:\n                for j in range(l,r+1):\n                    hmm[j].append(val)\n            return all(subsetSumToK(nums[i],hmm[i]) for i in range(n))\n        l = 0\n        r = len(queries)\n        ans = -1\n        while l<=r:\n            mid = (l + r)//2\n            if check(mid):\n                ans = mid\n                r = mid - 1\n            else:\n                l = mid + 1\n        return ans","author":"Sasank Nasika","submissionId":"1575150008"},[]]},{"279":[{"id":"279","fileName":"1575152013.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            vector<int> dp(nums[i] + 1);\n            dp[0] = 1;\n            if (dp[nums[i]]) continue;\n            for (int j = 0; j < queries.size(); j++) {\n                if (queries[j][0] > i || queries[j][1] < i) continue;\n                for (int k = dp.size() - 1; k >= queries[j][2]; k--) {\n                    dp[k] |= dp[k - queries[j][2]];\n                }\n                if (dp[nums[i]]) {\n                    res = max(res, j + 1);\n                    break;\n                }\n            }\n            if (!dp[nums[i]]) return -1;\n        }\n        return res;\n    }\n};","author":"AegeanYU","submissionId":"1575152013"},[]]},{"281":[{"id":"281","fileName":"1575151585.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& queries) {\n        int l = 0, r = queries.size(), ans = -1;  // Fix binary search range\n        int n = a.size();\n        \n        while (l <= r) {\n            int mid = (l + r) / 2;\n            bool ok = true;\n\n            for (int i = 0; i < n; i++) {\n                vector<int> values;\n                int cnt = 0;\n                \n                for (auto& j : queries) {\n                    if (cnt >= mid) break;  // Only process 'mid' queries\n                    if (j[0] <= i && j[1] >= i) {\n                        values.push_back(j[2]);\n                    }\n                    cnt++;\n                }\n                \n                vector<int> sums(a[i] + 1, 0);  // Use 0 instead of -1\n                sums[0] = 1;\n\n                for (auto val : values) {\n                    for (int new_sum = a[i]; new_sum >= 0; new_sum--) {\n                        if (sums[new_sum]) {\n                            if (new_sum + val <= a[i])\n                                sums[new_sum + val] = 1;\n                        }\n                    }\n                }\n\n                if (!sums[a[i]]) ok = false;  // Check if sum is possible\n            }\n\n            if (ok) {\n                ans = mid;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n\n        return ans == -1 ? -1 : ans ;\n    }\n};\n","author":"Terror_404","submissionId":"1575151585"},[]]},{"282":[{"id":"282","fileName":"1575151350.txt","sourceCode":"bitset<1001> bt;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size();\n        int ans = -1;\n        for(int i=0; i<n; ++i){\n            if(nums[i]==0){\n                ans = max(ans,0);\n                continue;\n            }\n            bt = 1;\n            for(int j=0; j<q; ++j){\n                int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                if(l<=i && i<=r){\n                    bt |= (bt << val);\n                    if(bt[nums[i]]){\n                        ans = max(ans, j+1);\n                        break;\n                    }\n                }\n            }\n            if(bt[nums[i]]==0){\n                return -1;\n            }\n        }\n        return ans;\n    }\n};","author":"Ankush Balse","submissionId":"1575151350"},[]]},{"283":[{"id":"283","fileName":"1575152209.txt","sourceCode":"#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nlong double PI = acos(-1.0);\n#define fastio()ios_base::sync_with_stdio(false);cin.tie(NULL)\n#define pb push_back\n#define ppb pop_back\n#define pf push_front\n#define ppf pop_front\n#define all(x) (x).begin(), (x).end()\n#define ff(i, l, r) for(int i=l;i<r;i++)\n#define ffr(i, l, r) for(int i=l;i>=r;i--)\n#define F first\n#define S second\n#define vii vector<vector<int>>\n#define vi vector<int>\n#define pii pair<int, int>\n#define mem1(a) memset(a, -1, sizeof(a))\n#define mem0(a) memset(a, 0, sizeof(a))\n#define ppc __builtin_popcount\n#define ppcll __builtin_popcountll\nclass Solution {\npublic:\n\tint minZeroArray(vi& a, vii& que) {\n\n\t\tint n = a.size();\n\t\tint m = que.size();\n\n\t\tint l = 0, h = m + 1;\n\n\t\twhile (l < h) {\n\t\t\tint mid = l + (h - l) / 2;\n\t\t\tbool valid = 1;\n\t\t\tff(i, 0 && !valid, n) {\n\t\t\t\tbitset<1001> dp;\n\t\t\t\tdp[0] = 1;\n\t\t\t\tint flgh = 0;\n\t\t\t\tff(j, 0 && !flgh, mid) {\n\t\t\t\t\tint l = que[j][0], r = que[j][1], val = que[j][2];\n\t\t\t\t\t(i > l - 1 && i < r + 1) ? dp |= (dp << val) : dp = dp;\n\t\t\t\t}\n\t\t\t\tif (!dp[a[i]]) {\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (valid)h = mid;\n\t\t\telse l = mid + 1;\n\n\t\t}\n\t\treturn (l == m + 1) ? -1 : l;\n\t}\n};","author":"CallMeHaldey","submissionId":"1575152209"},[]]},{"284":[{"id":"284","fileName":"1575152379.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        @cache\n        def recurse(i, j, num):\n            if i >= len(queries):\n                return float('inf')\n            if j not in range(queries[i][0], queries[i][1] + 1) or queries[i][2] > num:\n                return recurse(i + 1, j, num)\n            elif queries[i][2] == num:\n                return i + 1\n            else:\n                return min(recurse(i + 1, j, num), recurse(i + 1, j, num - queries[i][2]))\n            \n        required = 0\n        for j, num in enumerate(nums):\n            if num == 0: continue\n            recurse.cache_clear()\n            temp = recurse(0, j, num)\n            if temp == float('inf'):\n                return -1\n            required = max(required, temp)\n        \n        return required\n            \n            ","author":"Richard","submissionId":"1575152379"},[]]},{"285":[{"id":"285","fileName":"1575152038.txt","sourceCode":"class Solution {\n    public boolean all(int[] nums){\n        for(int i : nums){\n            if(i!=0) return false;\n        }\n        return true;\n    }\n    public int minZeroArray(int[] nums, int[][] q) {\n        int len = nums.length;\n        int low = 0;\n        int high = q.length-1;\n        int ans =-1;\n        if(all(nums)){\n            return 0;\n        }\n        while(low<=high){\n            int mid = (low+high)/2;\n            if(fkn(nums,q,mid)){\n                ans = mid+1;\n                high=mid-1;\n            }else{\n                low=mid+1;\n            }\n        }\n        return ans;\n    }\n    public boolean fkn(int[] nums,int[][] qu,int mid){\n        for(int i =0 ;i<nums.length;i++){\n            Queue<Integer> q = new LinkedList<>();\n            HashSet<Integer> set = new HashSet<>();\n            q.add(0);\n            set.add(0);\n            boolean flag =false;\n            if(nums[i]==0) continue;\n            for(int j =0 ;j<=mid;j++){\n                if(qu[j][0]<= i && i<= qu[j][1]){\n                    int m = qu[j][2];\n                    int size = q.size();\n                    for(int k =0 ;k <size;k++){\n                        int top = q.poll();\n                        if(top==nums[i] || top + m ==nums[i] ){\n                            flag = true;\n                            break;\n                        }\n                        if(top+m<nums[i] && set.contains(top+m)==false ){\n                            set.add(top+m);\n                            q.add(top+m);\n                        }\n                        q.add(top);\n                    }\n                    if(flag){\n                        break;\n                    }\n                }\n            }\n            if(flag==false){\n                return false;\n            }\n        }\n        return true;\n    }\n}","author":"TechDeck","submissionId":"1575152038"},[]]},{"286":[{"id":"286","fileName":"1575152590.txt","sourceCode":"class Solution:\n    def minZeroArray(self, a: List[int], qs: List[List[int]]) -> int:\n        n,m=len(a),len(qs)\n\n        def check(b):\n            for i in range(n):\n                if a[i]==0:continue\n                dp=[False for _ in range(a[i]+1)]\n                dp[0]=True\n                mx=0\n                for v in b[i]:\n                    for j in range(mx,-1,-1):\n                        if dp[j] and j+v<=a[i]:\n                            dp[j+v]=True\n                            mx=max(mx,j+v)\n                    if dp[a[i]]:break\n                if not dp[a[i]]:return False\n            return True\n        lo=0\n        hi=m\n        mn=m+1\n        while lo<=hi:\n            mid=(lo+hi)//2\n            b=[[] for _ in range(n)]\n            for l,r,v in qs[:mid]:\n                for i in range(l,r+1):\n                    b[i].append(v)           \n            ok=check(b)\n            # print(f\"lo={lo}, hi={hi}, mid={mid}, ok={ok}, b={b}\")\n            if ok:\n                mn=min(mn,mid)\n                hi=mid-1\n            else:\n                lo=mid+1\n        return -1 if mn==m+1 else mn\n        ","author":"OuterRidgeSavage","submissionId":"1575152590"},[]]},{"287":[{"id":"287","fileName":"1575152794.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        \n        def check(k):\n            d = [[] for _ in range(n)]\n            for i in range(k):\n                l, r, v = queries[i]\n                for j in range(l, r + 1):\n                    d[j].append(v)\n                    \n            for i, num in enumerate(nums):\n                mask = 1\n                for v in d[i]:\n                    mask |= mask << v\n                if mask & (1 << num) == 0:\n                    return False\n            return True\n        \n        l, r = 0, len(queries)\n        res = -1\n\n        while l < r:\n            m = (l + r) // 2\n            if check(m):\n                res = m\n                r = m\n            else:\n                l = m + 1\n        if res == -1:\n            if check(l):\n                res = l\n        return res\n        ","author":"Remineva","submissionId":"1575152794"},[]]},{"288":[{"id":"288","fileName":"1575152439.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = 0;\n        int n = nums.size();\n        vector<set<int>> possible(n, set<int>());\n        vector<bool> done(n, false);\n        bool flag = true;\n        for (int i=0; i<n; i++) {\n            if (nums[i] == 0) done[i] = true;\n            else flag = false;\n        }\n        if (flag) return 0;\n        for (auto &query: queries) {\n            int l = query[0];\n            int r = query[1];\n            int val = query[2];\n\n            for (int i=l; i<=r; i++) {\n                if (done[i]) continue;\n                vector<int> newpos = {val};\n                for (auto it=possible[i].begin(); it!=possible[i].end(); it++) {\n                    newpos.push_back(val + (*it));\n                }\n                for (auto el: newpos) possible[i].insert(el);\n            }\n            ans++;\n            bool flag = true;\n            for (int i=0; i<n; i++) {\n                if (done[i]) continue;\n                if (possible[i].find(nums[i]) != possible[i].end()) {\n                    done[i] = true;\n                } else flag = false;\n            }\n            if (flag) return ans;\n        }\n        return -1;\n    }\n};","author":"Nagender","submissionId":"1575152439"},[]]},{"289":[{"id":"289","fileName":"1575152607.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        num_set = [set() for _ in nums]\n        vis = [False for _ in nums]\n        zero = 0\n        for i,n in enumerate(nums):\n            if n==0:\n                vis[i] = True\n                zero+=1\n            num_set[i].add(n)\n        counter = 0\n        if zero==len(nums):\n            return 0\n        for q in queries:\n            for j in range(q[0],q[1]+1):\n                if vis[j]:\n                    continue\n                \n                if q[2] in num_set[j]:\n                    vis[j] = True\n                    zero+=1\n                else:\n                    temp_list = list(num_set[j])\n                    for x in temp_list:\n                        num_set[j].add(x-q[2])\n            counter+=1\n            if zero == len(nums):\n                return counter\n        return -1\n                \n            \n        \n        ","author":"Rachit Yagnik","submissionId":"1575152607"},[]]},{"290":[{"id":"290","fileName":"1575152520.txt","sourceCode":"class Solution {\npublic:\n    bool f(vector<int>& s, int i, int t, vector<vector<int>>& memo) {\n        if (t == 0) {\n            return true;\n        }\n        if (i >= s.size()) {\n            return false;\n        }\n        if (memo[i][t] != -1) {\n            return memo[i][t];\n        }\n        bool a = f(s, i + 1, t, memo);\n        bool b = false;\n        if (s[i] <= t) {\n            b = f(s, i + 1, t - s[i], memo);\n        }\n        memo[i][t] = a || b;\n        return memo[i][t];\n    }\n    \n    bool possible(vector<int>& nums, vector<vector<int>>& queries, int k) {\n        int n = nums.size();\n        for (int j = 0; j < n; j++) {\n            int t = nums[j];\n            vector<int> s;\n            for (int i = 0; i < k; i++) {\n                if (queries[i][0] <= j && j <= queries[i][1]) {\n                    s.push_back(queries[i][2]);\n                }\n            }\n            if (t == 0) {\n                continue;\n            }\n            int z = s.size();\n            vector<vector<int>> memo(z, vector<int>(t + 1, -1));\n            if (!f(s, 0, t, memo)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int M = queries.size();\n        bool allZero = true;\n        for (int x : nums) {\n            if (x != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) {\n            return 0;\n        }\n        \n        int lo = 1, hi = M, ans = -1;\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (possible(nums, queries, mid)) {\n                ans = mid;\n                hi = mid - 1;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"1oPhytGbYO","submissionId":"1575152520"},[]]},{"291":[{"id":"291","fileName":"1575152805.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& qs) {\n        int n = nums.size();\n        vector<vector<int>> f(nums.size());\n        for (int i = 0; i < n; i++) { f[i].resize(nums[i] + 1); f[i][0] = 1;}\n        int res = 0;\n        auto check = [&]() {\n            for (int i = 0; i < n;i ++) {\n                if(!f[i][nums[i]]) return false;\n            }\n            return true;\n        };\n        if (check()) return res;\n                        \n        for (auto& q:  qs) {\n            int l = q[0], r =  q[1], val = q[2];\n            for (int i = l; i <= r; i++) {\n                for (int j = nums[i]; j >= val; j--) {\n                    f[i][j]  |= f[i][j - val];\n                }\n            }\n            res ++;\n            if (check()) return res;\n            \n        }\n        return -1;\n    }\n};","author":"jeemzz147","submissionId":"1575152805"},[]]},{"292":[{"id":"292","fileName":"1575152847.txt","sourceCode":"#include<bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\n    public:\n    bool can_zero(int target, vector<int>& temp)\n    {\n        if(target == 0)\n        {\n            return true;\n        }\n\n        vector<bool> dp(target + 1, false);\n        dp[0] = true;\n\n        for(int i = 0; i < temp.size(); i++)\n        {\n            for(int j = target; j >= temp[i]; j--)\n            {\n                dp[j] = dp[j] || dp[j - temp[i]];\n            }\n\n            if(dp[target])\n            {\n                return true;\n            }\n        }\n\n        return dp[target];\n    }\n\n    bool is_possible(int k, vector<int>& nums, vector<vector<int>>& queries)\n    {\n        int n = nums.size();\n        for(int i = 0; i < n; i++)\n        {\n            vector<int> temp;\n            for(int j = 0; j < k; j++)\n            {\n                if(queries[j][0] <= i && i <= queries[j][1])\n                {\n                    temp.push_back(queries[j][2]);\n                }\n            }\n\n            if(nums[i] != 0 && !can_zero(nums[i], temp))\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries)\n    {\n        int m = queries.size();\n        if(!is_possible(m, nums, queries))\n        {\n            return -1;\n        }\n\n        int l = 0, r = m, ans = m;\n        while(l <= r)\n        {\n            int mid = l + (r - l) / 2;\n            if(is_possible(mid, nums, queries))\n            {\n                ans = mid;\n                r = mid - 1;\n            }\n            else\n            {\n                l = mid + 1;\n            }\n        }\n\n        return ans;\n    }\n};","author":"Himal Rana","submissionId":"1575152847"},[]]},{"293":[{"id":"293","fileName":"1575152608.txt","sourceCode":"class Solution:\n    \n    def coinChange(self, currInd, currVal, currentlyProcessing):\n        \n        if currInd == len(self.queries) and currVal == 0:\n            return -1\n        elif currInd == len(self.queries):\n            return len(self.queries)\n        elif currVal < 0:\n            return len(self.queries)\n        \n        if (currInd, currVal) in self.memo:\n            return self.memo[(currInd, currVal)]\n\n        if self.queries[currInd][0] <= currentlyProcessing and currentlyProcessing <= self.queries[currInd][1]:\n            self.memo[(currInd, currVal)] = min(\n                self.coinChange(currInd + 1, currVal, currentlyProcessing),\n                max(currInd, self.coinChange(currInd + 1, currVal - self.queries[currInd][2], currentlyProcessing))\n            )\n        else:\n            self.memo[(currInd, currVal)] = self.coinChange(currInd + 1, currVal, currentlyProcessing)\n\n        return self.memo[(currInd, currVal)]\n        \n    def minZeroArray(self, nums, queries):\n        self.queries = queries\n        maxInd = -1\n        for i in range(len(nums)):\n            self.memo = dict()\n            maxInd = max(self.coinChange(0, nums[i], i), maxInd)\n        return maxInd + 1 if maxInd != len(self.queries) else -1","author":"tdserapio","submissionId":"1575152608"},[]]},{"294":[{"id":"294","fileName":"1575153228.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        int ans = -1;\n        \n        auto get_res = [&] (int idx) {\n            vector<vector<int>> dp(m, vector<int>(nums[idx]+1, -1));\n            auto dfs = [&] (this auto&& dfs, int i, int j) {\n                if(j == 0) {\n                    return i;\n                }\n                if(i == m) {\n                    return m + 1;\n                }\n                if(dp[i][j] != -1) return dp[i][j];\n                int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n                int res = dfs(i+1, j);\n                if(l <= idx && idx <= r && j >= val) {\n                    res = min(res, dfs(i+1, j - val));\n                }\n                dp[i][j] = res;\n                return res;\n            };\n            return dfs(0, nums[idx]);\n        };\n        for(int i=0; i<n; i++) {\n            int res = get_res(i);\n            // cout << res << ' ';\n            ans = max(ans, res);\n        }\n\n        return ans == m+1 ? -1 : ans;\n    }\n};","author":"jason7708","submissionId":"1575153228"},[]]},{"295":[{"id":"295","fileName":"1575153313.txt","sourceCode":"\n\n// COPY ALL MACROS BELOW\n\n\ntypedef long long LL;\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define LB lower_bound\n#define UB upper_bound\n#define SZ(x) ((int)x.size())\n#define LEN(x) ((int)x.length())\n#define ALL(x) begin(x), end(x)\n#define RSZ resize\n#define ASS assign\n#define REV(x) reverse(x.begin(), x.end());\n#define trav(a, x) for (auto& a : x)\ntypedef pair<LL, LL> PL;\ntypedef vector<LL> VL;\ntypedef vector<PL> VPL;\ntypedef vector<VL> VVL;\ntypedef vector<VVL> VVVL;\ntypedef vector<VVVL> VVVVL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PI;\ntypedef vector<int> VI;\ntypedef vector<PI> VPI;\ntypedef vector<vector<int>> VVI;\ntypedef vector<vector<PI>> VVPI;\n#define MAX(x) *max_element(ALL(x))\n#define MIN(x) *min_element(ALL(x))\n#define FOR(i, n) for (int i = 0; i < n; i++) \n#define FOR1(i, n) for (int i = 1; i <= n; i++) \n#define SORT(x) sort(x.begin(), x.end())\n#define RSORT(x) sort(x.rbegin(), x.rend())\n#define SUM(x) accumulate(x.begin(), x.end(), 0LL)\n#define MMAX(n, x)  n = max(n, x)\n#define MMIN(n, x)  n = min(n, x)\n\n\nclass Solution {\npublic:\n\tint minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\t\tint n = nums.size(), m = queries.size(), i, j, k, MAXX = 1002;\n\t\tvector<vector<bool>> d(n, vector<bool>(MAXX, 0));\n\t\tFOR(i, n) d[i][nums[i]] = 1;\n\n\t\tbool valid = true;\n\t\tFOR(i, n) {\n\t\t\tif (d[i][0] == 0) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (valid) return 0;\n\n\t\tFOR(k, m) {\n\t\t\tfor (i = queries[k][0]; i <= queries[k][1]; i++) {\n\t\t\t\tfor (j = 1; j <= nums[i]; j++) {\n\t\t\t\t\tif (d[i][j] && (j - queries[k][2] >= 0)) {\n\t\t\t\t\t\td[i][j - queries[k][2]] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbool valid = true;\n\t\t\tFOR(i, n) {\n\t\t\t\tif (d[i][0] == 0) {\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (valid) return k + 1;\n\t\t}\n\n\t\treturn -1;\n\t}\n};\n\n\n","author":"Wanjun Li","submissionId":"1575153313"},[]]},{"296":[{"id":"296","fileName":"1575153381.txt","sourceCode":"from typing import List\n\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n\n        def valid(k):\n            d = [[] for i in range(n)]\n            for i, j, v in queries[:k]:\n                for idx in range(i, j + 1):\n                    d[idx].append(v)\n            for idx in range(n):\n                target = nums[idx]\n                if target == 0:\n                    continue\n                a = d[idx]\n                s = {0}\n                valid = False\n                for x in a:\n                    if x > target:\n                        continue\n                    new_s = {0}\n                    for y in s:\n                        if x + y > target:\n                            continue\n                        if x + y == target:\n                            valid = True\n                            break\n                        new_s.add(x + y)\n                    if valid:\n                        break\n                    for v in new_s:\n                        s.add(v)\n                if not valid:\n                    return False\n            return True\n\n        l, r = 0, len(queries) + 1\n        while l < r:\n            m = (l + r) // 2\n            if valid(m):\n                r = m\n            else:\n                l = m + 1\n        return l if l <= len(queries) else -1","author":"pikapika","submissionId":"1575153381"},[]]},{"297":[{"id":"297","fileName":"1575153628.txt","sourceCode":"from typing import List\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        ans = 0\n        n = len(nums)\n        m = len(queries)\n        for i in range(n):\n            if nums[i]==0:\n                continue\n            s = set()\n            s.add(nums[i])\n            flag = False\n            for j in range(m):\n                l, r, v = queries[j]\n                if l<=i<=r:\n                    ns = set()\n                    for ss in s:\n                        if ss==v:\n                            flag = True\n                            break\n                        elif ss>v:\n                            ns.add(ss-v)\n                        ns.add(ss)\n                    if flag:\n                        ans = max(ans, j+1)\n                        break\n                    s = ns\n            if flag==False:\n                return -1\n        return ans\n\n            ","author":"miya145592","submissionId":"1575153628"},[]]},{"298":[{"id":"298","fileName":"1575153531.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        \n        auto possible = [&] (int k) -> bool {\n            if (k == 0) {\n                return *max_element(nums.begin(), nums.end()) == 0;\n            }\n            \n            vector<vector<int>> vals(n, vector<int> (1));\n            for (int i = 0; i < k; i++) {\n                int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n                for (int j = l; j <= r; j++) {\n                    vals[j].push_back(val);\n                }\n            }\n            \n            for (int idx = 0; idx < n; idx++) {\n                int sz = vals[idx].size();\n                vector<vector<bool>> dp(sz + 1, vector<bool> (nums[idx] + 1));\n                dp[sz][0] = true;\n                for (int i = sz - 1; i >= 0; i--) {\n                    for (int j = 0; j <= nums[idx]; j++) {\n                        dp[i][j] = dp[i + 1][j];\n                        if (vals[idx][i] <= j) {\n                            dp[i][j] = (dp[i][j] | dp[i + 1][j - vals[idx][i]]);\n                        }\n                    }\n                }\n                \n                if (!dp[0][nums[idx]]) return false;\n            }\n            \n            return true;\n        };\n        \n        int low = 0, high = m;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (possible(mid)) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        \n        return high + 1 <= m ? high + 1 : -1;\n    }\n};","author":"Pankaj Ananda Bhosale","submissionId":"1575153531"},[]]},{"299":[{"id":"299","fileName":"1575152717.txt","sourceCode":"#include <bits/stdc++.h>\n#define ll long long int\n#define FASTIO std::ios::sync_with_stdio(false);\n#define pb push_back\n#define mp make_pair\n#define pi pair <ll,ll>\n#define F first\n#define S second\n#define inf 1e18\n#define pi pair <ll,ll>\n#define g(x) cout<<x<<endl\n#define all(x) x.begin(),x.end()\n#define rall(a) a.rbegin(), a.rend()\n#define input_from_file  freopen(\"input.txt\", \"r\", stdin);\n#define mod 1000000007ll\n#define sz 400005\n#define bitcnt(x) __builtin_popcountll(x)\nusing namespace std;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = -1e9;\n        for(int i=0;i<nums.size();i++){\n\n        vector <ll> vals;\n        vector <int> validx;\n        int idx = 1;\n        for(auto v:queries){\n            int l = v[0];\n            int r = v[1];\n            int val = v[2];\n            \n            if(i>=l && i<=r){\n                vals.pb(val);\n                validx.pb(idx);\n            }\n            idx++;\n        }\n            // cout << nums[i] << endl;\n            // for(auto x:vals){\n            //     cout << x << \" \";\n            // }\n            // cout << endl;\n        map <ll,ll> dp;\n        dp[0] = 1;\n            bool got = false;\n\n        if(nums[i] == 0){\n            ans = max(ans,0);\n            got = true;\n        }else{\n            int j = 0;\n        for(auto v:vals){\n            map <ll,ll> ndp;\n            for(auto x:dp){\n                if(x.S == 0)continue;\n               // cout << x.F  << \" \" << v << endl;\n                ndp[x.F+v] = 1;\n                ndp[x.F] = 1;\n            }\n            swap(dp,ndp);\n            // cout << v << endl;\n            // for(auto x:dp){\n            //     cout << x.F << \" \";\n            // }\n            // cout << endl;\n            if(dp[nums[i]]){\n                // cout << validx[j] << endl;\n                ans = max(ans,validx[j]);\n                got = true;\n                break;\n            }\n            // idx++;\n            j+=1;\n        }\n        }\n            if(!got)return -1;\n        }\n        if(ans == -1e9){\n            return -1;\n        }\n        return ans;\n    }\n};","author":"saketw","submissionId":"1575152717"},[]]},{"300":[{"id":"300","fileName":"1575153770.txt","sourceCode":"class Solution {\nprivate:\n    bool isPos(vector<int>& v, int k) {\n        int n = v.size();\n        vector<vector<bool>> dp(n + 1, vector<bool>(k + 1, false));\n\n        for (int i = 0; i <= n; i++)\n            dp[i][0] = true;\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= k; j++) {\n                if (v[i - 1] <= j)\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - v[i - 1]];\n                else\n                    dp[i][j] = dp[i - 1][j];\n            }\n        }\n        return dp[n][k];\n    }\n\n    bool check(vector<int>& a, vector<vector<int>>& q, int k) {\n        int n = a.size();\n        vector<vector<int>> v(n);\n\n        for (int i = 0; i < k; i++) {\n            for (int j = q[i][0]; j <= q[i][1]; j++) {\n                v[j].push_back(q[i][2]);\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (!isPos(v[i], a[i]))\n                return false;\n        }\n        return true;\n    }\n\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size(), m = q.size();\n        int l = -1, r = m;\n\n        while (l + 1 < r) {\n            int mid = (l + r) / 2;\n\n            if (check(a, q, mid)) {\n                r = mid;\n            } else\n                l = mid;\n        }\n        if(!check(a, q, r))\n            r = -1;\n        \n        return r;\n    }\n};","author":"Pushkar Mourya","submissionId":"1575153770"},[]]},{"301":[{"id":"301","fileName":"1575153637.txt","sourceCode":"class Solution {\n    public boolean T(List<Integer> al, int target, int idx, Boolean dp[][]) {\n        if(idx==al.size()){\n            if(target==0) return true;\n            return false;\n        }\n        if(dp[idx][target]!=null) return dp[idx][target];\n        boolean ex = T(al, target, idx+1, dp);\n        boolean in = false;\n        if(al.get(idx)<=target){\n            in = T(al, target-al.get(idx), idx+1, dp);\n        }\n        return dp[idx][target] =ex || in;\n    }\n    public boolean is(int nums[], int [][]q, int k){\n        int n = nums.length;\n        // k = q.length;\n        List<List<Integer>> al = new ArrayList<>();\n        for(int i=0; i<=n; i++) {\n            al.add(new ArrayList<>());\n        }\n        // System.out.pritln\n        for(int i=0; i<k; i++) {\n            al.get(q[i][0]).add(q[i][2]);\n            al.get(q[i][1]+1).add(-q[i][2]);\n        }\n        int sum = 0;\n       // System.out.println(al);\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for(int i=0; i<n; i++) {\n            for(int el : al.get(i)){\n                if(el<0){\n                    map.put(-el, map.get(-el)-1);\n                }else{\n                    map.put(el, map.getOrDefault(el, 0)+1);\n                }\n            }\n            List<Integer> temp = new ArrayList<>();\n            for(int key : map.keySet()) {\n                for(int j=0; j<map.get(key); j++){\n                    temp.add(key);\n                }\n            }\n            Boolean dp[][] = new Boolean[temp.size()][nums[i]+1];\n            if(!T(temp, nums[i], 0, dp)) return false;\n        }\n        return true;\n    }\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int s=0, e=queries.length, ans=-1;\n        while(s<=e){\n            int m = s+(e-s)/2;\n            if(is(nums, queries, m)){\n                ans = m;\n                e = m-1;\n            }else{\n                s = m+1;\n            }\n        }\n        return ans;\n    }\n}","author":"Rudra Pratap Singh","submissionId":"1575153637"},[]]},{"302":[{"id":"302","fileName":"1575154006.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            int num = nums[i];\n            if (num == 0) {\n                continue;\n            }\n            boolean[] dp = new boolean[num + 1];\n            dp[num] = true;\n            for (int j = 0; j < m; j++) {\n                if (queries[j][0] > i || queries[j][1] < i) {\n                    continue;\n                }\n                for (int k = 0; k <= num; k++) {\n                    if (dp[k] && k >= queries[j][2]) {\n                        dp[k - queries[j][2]] = true;\n                    }\n                }\n                if (dp[0]) {\n                    res = Math.max(res, j + 1);\n                    break;\n                }\n            }\n            if (!dp[0]) {\n                return -1;\n            }\n        }\n        return res;\n    }\n}","author":"zheruilin","submissionId":"1575154006"},[]]},{"303":[{"id":"303","fileName":"1575154192.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        q = len(queries)\n        ans = 0 \n        for k, x in enumerate(nums): \n            dp = [[inf]*(x+1) for _ in range(q+1)] # dp[0][x]\n            dp[q][0] = q\n            for i in range(q-1, -1, -1): \n                dp[i][0] = i \n                l, r, v = queries[i]\n                for j in range(1, x+1): \n                    dp[i][j] = dp[i+1][j]\n                    if l <= k <= r and v <= j: dp[i][j] = min(dp[i][j], dp[i+1][j-v])\n            if dp[0][x] == inf: return -1 \n            ans = max(ans, dp[0][x])\n        return ans ","author":"bnlvv","submissionId":"1575154192"},[]]},{"304":[{"id":"304","fileName":"1575154268.txt","sourceCode":"class Solution\n{\n    public int minZeroArray(int[] as, int[][] qs)\n    {\n        if (Arrays.stream(as).max().orElse(0) == 0)\n        {\n            return 0;\n        }\n        int n = as.length;\n        Integer[] table = new Integer[n];\n        for (int i = 0; i < n; i++)\n        {\n            if (as[i] == 0)\n            {\n                table[i] = 0;\n            }\n        }\n        Map<Integer, Set<Integer>> map = new HashMap<>();\n        for (int j = 0; j < qs.length; j++)\n        {\n            int[] q = qs[j];\n            for (int i = q[0]; i <= q[1]; i++)\n            {\n                if (table[i] != null)\n                {\n                    continue;\n                }\n                Set<Integer> set1 = map.getOrDefault(i, new HashSet<>());\n                Set<Integer> set2 = new HashSet<>(set1);\n                for (int curr : set1)\n                {\n                    set2.add(curr + q[2]);\n                }\n                set2.add(q[2]);\n                if (set2.contains(as[i]))\n                {\n                    table[i] = j + 1;\n                }\n                map.put(i, set2);\n            }\n        }\n        int k = 0;\n        for (Integer need : table)\n        {\n            if (need == null)\n            {\n                return -1;\n            }\n            k = Math.max(k, need);\n        }\n        return k;\n    }\n}","author":"LeetCoding_Pro","submissionId":"1575154268"},[]]},{"305":[{"id":"305","fileName":"1575154308.txt","sourceCode":"class Solution(object):\n    def dfs(self, target, queries, i, start, m):\n        #print(target, i, start)\n        if (target,start) in m:\n            return m[(target,start)]\n        if start >= len(queries) and target > 0:\n            return -1\n        if target == 0:\n            return start\n        \n        if queries[start][0] > i or queries[start][1] < i:\n            m[(target,start)] = self.dfs(target, queries, i, start+1, m)\n            return m[(target,start)]\n\n        if queries[start][2] > target:\n            m[(target,start)] = self.dfs(target, queries, i, start+1, m)\n            return m[(target,start)]\n \n        tmp1 = self.dfs(target-queries[start][2], queries, i, start+1, m)\n        tmp2 = self.dfs(target, queries, i, start+1, m)\n        if tmp1 == -1:\n            m[(target,start)] = tmp2\n            return tmp2\n        if tmp2 == -1:\n            m[(target,start)] = tmp1\n            return tmp1\n        m[(target,start)] = min(tmp1,tmp2)\n        return m[(target,start)]\n    \n    def minZeroArray(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: int\n        \"\"\"\n        finalResult = 0\n        for i in range(0, len(nums)):\n            m = {}\n            k = self.dfs(nums[i], queries, i, 0, m)\n            if k == -1:\n                return -1\n            finalResult = max(finalResult, k)\n\n        return finalResult","author":"jimsshom","submissionId":"1575154308"},[]]},{"306":[{"id":"306","fileName":"1575153929.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        int max_k = 0;\n\n        for (int i = 0; i < n; ++i) {\n            int target = nums[i];\n            if (target == 0) continue;\n\n            vector<pair<int, int>> qs;\n            for (int j = 0; j < q; ++j) {\n                int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                if (l <= i && i <= r) {\n                    qs.emplace_back(j, val);\n                }\n            }\n\n            int sum_total = 0;\n            for (auto& p : qs) sum_total += p.second;\n            if (sum_total < target) return -1;\n\n            unordered_set<int> possible_sums = {0};\n            int sum_so_far = 0;\n            bool found = false;\n\n            for (auto& p : qs) {\n                int q_idx = p.first;\n                int val = p.second;\n                sum_so_far += val;\n\n                unordered_set<int> new_sums;\n                bool break_loop = false;\n\n                for (int s : possible_sums) {\n                    int new_s_val = s + val;\n                    if (new_s_val == target) {\n                        max_k = max(max_k, q_idx + 1);\n                        found = true;\n                        break_loop = true;\n                        break;\n                    } else if (new_s_val < target) {\n                        new_sums.insert(new_s_val);\n                    }\n                }\n\n                if (break_loop) break;\n\n                for (int s : new_sums) possible_sums.insert(s);\n\n                if (sum_so_far >= target && possible_sums.count(target)) {\n                    max_k = max(max_k, q_idx + 1);\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) return -1;\n        }\n\n        return max_k;\n    }\n};","author":"Aditya Kumar Ray","submissionId":"1575153929"},[]]},{"307":[{"id":"307","fileName":"1575154391.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        if all(nums[i] == 0 for i in range(n)): return 0 # all zero\n        dp = [[False]*(nums[i]+1) for i in range(n)]\n        for i in range(n):\n            dp[i][0] = True\n        for k, (l, r, val) in enumerate(queries, start=1):\n            for i in range(l, r+1):\n                for s in range(nums[i]-val, -1, -1):\n                    if dp[i][s]:\n                        dp[i][s+val] = True\n            if all(dp[i][nums[i]] for i in range(n)):\n                return k\n        return -1","author":"Yilun Wu","submissionId":"1575154391"},[]]},{"308":[{"id":"308","fileName":"1575154413.txt","sourceCode":"class Solution {\n\n    private boolean check(int[] nums, int[][] queries, int limit) {\n        boolean[] dp = new boolean[1010];\n        for (int i = 0;i < nums.length;i ++) {\n            int target = nums[i];\n            Arrays.fill(dp, false);\n            dp[0] = true;\n            boolean find = false;\n            for (int j = 0;j <= limit;j ++) {\n                int l = queries[j][0], r = queries[j][1], updateVal = queries[j][2];\n                if (l <= i && i <= r) {\n                    for (int val = target;val >= updateVal;val --) {\n                        if (dp[val - updateVal]) {\n                            dp[val] = true;\n                        }\n                        if (dp[target]) {\n                            break;\n                        }\n                    }\n                }\n                if (dp[target] == true) {\n                    find = true;\n                    break;\n                }\n            }\n            if (!find) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean allZeros(int[] nums) {\n        for (int val : nums) {\n            if (val != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public int minZeroArray(int[] nums, int[][] queries) {\n        if (allZeros(nums)) {\n            return 0;\n        }\n        int l = 0, r = queries.length;\n        while (l < r) {\n            int mid = (l + r) / 2;\n            if (check(nums, queries, mid)) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        if (l == queries.length) {\n            return - 1;\n        } else {\n            return l + 1;\n        }\n    }\n\n}","author":"Wei Liu","submissionId":"1575154413"},[]]},{"309":[{"id":"309","fileName":"1575154405.txt","sourceCode":"class Solution {\npublic:\n\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        // Check if the array is already zero\n        if (all_of(nums.begin(), nums.end(), [](int x) { return x == 0; })) {\n            return 0;\n        }\n        \n        int n = nums.size();\n        int q_size = queries.size();\n        \n        vector<vector<pair<int, int>>> Q(n); // (original index, val)\n        vector<vector<int>> original_indices(n);\n        vector<vector<bool>> can_reach(n);\n        \n        for (int j = 0; j < n; ++j) {\n            for (int i = 0; i < q_size; ++i) {\n                auto& q = queries[i];\n                int l = q[0], r = q[1], val = q[2];\n                if (l <= j && j <= r) {\n                    Q[j].emplace_back(i, val);\n                }\n            }\n            sort(Q[j].begin(), Q[j].end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n                return a.first < b.first;\n            });\n            original_indices[j].clear();\n            for (auto& p : Q[j]) {\n                original_indices[j].push_back(p.first);\n            }\n            can_reach[j].resize(Q[j].size() + 1, false);\n            unordered_set<int> current_sums;\n            current_sums.insert(0);\n            can_reach[j][0] = (current_sums.count(nums[j]) > 0);\n            for (int m = 1; m <= Q[j].size(); ++m) {\n                int val = Q[j][m-1].second;\n                unordered_set<int> new_sums(current_sums.begin(), current_sums.end());\n                for (int s : current_sums) {\n                    int new_s = s + val;\n                    if (new_s <= nums[j]) {\n                        new_sums.insert(new_s);\n                    }\n                }\n                current_sums = new_sums;\n                can_reach[j][m] = current_sums.count(nums[j]) > 0;\n            }\n        }\n        \n        for (int original_index = 0; original_index < q_size; ++original_index) {\n            bool all_ok = true;\n            for (int j = 0; j < n; ++j) {\n                if (Q[j].empty()) {\n                    if (nums[j] != 0) {\n                        all_ok = false;\n                        break;\n                    }\n                    continue;\n                }\n                auto& indices = original_indices[j];\n                auto it = upper_bound(indices.begin(), indices.end(), original_index);\n                int m_j = it - indices.begin();\n                if (!can_reach[j][m_j]) {\n                    all_ok = false;\n                    break;\n                }\n            }\n            if (all_ok) {\n                return original_index + 1;\n            }\n        }\n        \n        return -1;\n    }\n};","author":"MO_RAAFAT","submissionId":"1575154405"},[]]},{"310":[{"id":"310","fileName":"1575154718.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(),m = queries.size();\n        if(accumulate(nums.begin(),nums.end(),0ll)==0)return 0;\n        auto f = [&](int index,int value,vector<vector<int>>&dp,int x,int idx,auto &&self)->bool{\n            if(index==x){\n                return value==0?true:false;\n            }\n            if(dp[index][value]!=-1)return dp[index][value];\n            bool res = self(index+1,value,dp,x,idx,self);\n            if(res==true)return true;\n            int l = queries[index][0],r = queries[index][1],val = queries[index][2];\n            if(idx>=l && idx<=r && val<=value){\n                res = (res | self(index+1,value-val,dp,x,idx,self));\n            }\n            return dp[index][value] = res;\n        };\n        auto isPossible = [&](int x,int value,int idx)->bool{\n            vector<vector<int>>dp(x+1,vector<int>(value+1,-1));\n            return f(0,value,dp,x,idx,f);\n        };\n        auto check = [&](int value,int idx){\n            int start = 0,end = m,ans = -1;\n            while(start<=end){\n                int mid = (start + (end-start)/2);\n                if(isPossible(mid,value,idx)){\n                    ans = mid;\n                    end = mid-1;\n                }\n                else start = mid+1;\n            }\n            return ans;\n        };\n        int maxi = 0;\n        for(int i=0;i<n;i++){\n            int x = check(nums[i],i);\n            if(x==-1)return -1;\n            maxi = max(maxi,x);\n        }\n        return maxi;\n    }\n};","author":"neatHyperTxt","submissionId":"1575154718"},[]]},{"311":[{"id":"311","fileName":"1575155035.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        mods = [[] for _ in range(n + 1)]\n        l = 0\n        r = len(queries) + 1\n        modend = 0\n        def check(nums, mods):\n            c = []\n            for i, v in enumerate(nums):\n                for j in mods[i]:\n                    if j > 0:\n                        c.append(j)\n                    else:\n                        c.remove(-j)\n                if not c or len(c) == 0:\n                    if v != 0:\n                        return False\n                n = len(c)\n                b = [[False for _ in range(v + 1)] for _ in range(n + 1)]\n                for i in range(n + 1):\n                    b[i][0] = True\n                for i in range(1, v + 1):\n                    b[0][i] = False\n                for i in range(1, n + 1):\n                    for j in range(1, v + 1):\n                        if j < c[i - 1]:\n                            b[i][j] = b[i - 1][j]\n                        if j >= c[i - 1]:\n                            b[i][j] = (b[i - 1][j] or b[i - 1][j - c[i - 1]])\n                if not b[n][v]:\n                    return False\n            return True\n                \n\n        while l < r:\n            m = (l + r) // 2\n            if m > modend:\n                for a, b, v in queries[modend:m]:\n                    mods[a].append(v)\n                    mods[b + 1].append(-v)\n            elif m < modend:\n                for a, b, v in queries[m:modend]:\n                    mods[a].remove(v)\n                    mods[b + 1].remove(-v)\n            modend = m\n            if check(nums, mods):\n                r = m\n            else:\n                l = m + 1\n        if l > len(queries):\n            return -1\n        return l\n            \n                \n            \n        ","author":"Josh","submissionId":"1575155035"},[]]},{"312":[{"id":"312","fileName":"1575155148.txt","sourceCode":"class Solution {\n    public Integer dp[][];\n    // for each number, if I do a dp to find small index it becomes 0 at;\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int max = Integer.MIN_VALUE;\n\n        for(int i=0;i<nums.length;i++) {\n            dp = new Integer[1002][queries.length+1];\n            int ans = solve(nums[i], i, queries, 0);\n            // System.out.println(ans);\n            max = Math.max(max, ans);\n        }\n\n        return max == Integer.MAX_VALUE ? -1 : max;\n        \n    }\n\n    public int solve(int num, int numInd, int[][] queries, int i) {\n        int n = queries.length;\n        if(num == 0) return i; // at this i, num became 0;\n        if(i>=n) return Integer.MAX_VALUE; // num never became 0;\n\n        if(dp[num][i]!=null) return dp[num][i];\n        \n        int op1 = Integer.MAX_VALUE;\n        int op2 = Integer.MAX_VALUE;\n\n        int left = queries[i][0];\n        int right = queries[i][1];\n\n        if(numInd>=left && numInd<=right && num>=queries[i][2]) {\n            op1 = solve(num-queries[i][2], numInd, queries, i+1);\n        }\n\n        op2 = solve(num, numInd, queries, i+1);\n\n        return dp[num][i] = Math.min(op1, op2);\n        \n    }\n}","author":"Jagrit","submissionId":"1575155148"},[]]},{"313":[{"id":"313","fileName":"1575155104.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if sum(nums) == 0: return 0\n        nums = [a for a in nums if a]\n        n, nq = len(nums), len(queries)\n        def can_get_sum(s, vals):\n            dp = [False] * (s + 1)\n            dp[0] = True\n            for v in vals:\n                next_dp = dp[:]\n                for j in range(1, s + 1):\n                    if v <= j and dp[j - v]: next_dp[j] = True\n                dp = next_dp\n                if dp[-1]: return True\n            return False\n        def can(k):\n            for i in range(n):\n                vals = []\n                for l, r, val in queries[:k]:\n                    if l <= i <= r and val <= nums[i]: vals.append(val)\n                if not can_get_sum(nums[i], vals): return False\n            return True\n        if not can(nq): return -1\n        l, r = 1, nq\n        while l < r:\n            m = (l + r) // 2\n            if can(m):\n                r = m\n            else:\n                l = m + 1\n        return l","author":"echeresh","submissionId":"1575155104"},[]]},{"314":[{"id":"314","fileName":"1575154700.txt","sourceCode":"int dp[1005][1005];\nclass Solution {\npublic:\n    bool func(int i , int ind , int val , int mid , vector<vector<int>> &brr){\n        if(i == mid + 1) return (val == 0);\n        if(dp[i][val] != -1) return dp[i][val];\n        bool ans = 0;\n        if(ind >= brr[i][0] && ind <= brr[i][1]){\n            if(val >= brr[i][2]) ans |= func(i + 1 , ind , val - brr[i][2] , mid , brr);\n        }\n        ans |= func(i + 1 , ind , val , mid , brr);\n        return dp[i][val] = ans;\n    }\n    bool is_valid(int mid , vector<int> &arr , vector<vector<int>> &brr){\n        bool ans = 1;\n        for(int i = 0 ; i < arr.size() ; i++){\n            if(!arr[i]) continue;\n            for(int j = 0 ; j <= mid + 3 ; j++){\n                for(int k = 0 ; k <= arr[i] ; k++) dp[j][k] = -1;\n            }\n            ans &= func(0 , i , arr[i] , mid , brr);\n        }\n        return ans;\n    }\n    int minZeroArray(vector<int>& arr , vector<vector<int>>& q) {\n        bool flag = 0;\n        for(auto p : arr) if(p) flag = 1;\n        if(!flag) return 0;\n        int n = arr.size() , sz = q.size();\n        int high = sz - 1 , low = 0;\n        while(high - low > 1){\n            int mid = (high + low) >> 1;\n            if(is_valid(mid , arr , q)) high = mid;\n            else low = mid;\n        }\n        if(is_valid(low , arr , q)) return low + 1;\n        else if(is_valid(high , arr , q)) return high + 1;\n        return -1;\n    }\n};","author":"Raj Singh","submissionId":"1575154700"},[]]},{"315":[{"id":"315","fileName":"1575155259.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        bool alreadyZero = true;\n        for (int v : nums) {\n            if (v != 0) { \n                alreadyZero = false; \n                break;\n            }\n        }\n        if (alreadyZero) return 0;\n        \n        vector<vector<pair<int,int>>> canReduce(n);\n        for (int k = 0; k < queries.size(); k++) {\n            int l = queries[k][0], r = queries[k][1], val = queries[k][2];\n            for (int i = l; i <= r; i++) {\n                canReduce[i].push_back({val, k + 1});\n            }\n        }\n        \n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            bitset<1001> dp;\n            dp.reset();\n            dp[0] = 1;\n            int minK = -1;  \n            for (auto &p : canReduce[i]) {\n                int decrement = p.first;\n                int qno = p.second;\n                dp |= (dp << decrement);\n                if (dp[target]) {\n                    minK = qno;\n                    break;\n                }\n            }\n            if (minK == -1) return -1;\n            ans = max(ans, minK);\n        }\n        return ans;\n    }\n};\n","author":"Melon Musk","submissionId":"1575155259"},[]]},{"316":[{"id":"316","fileName":"1575155384.txt","sourceCode":"#include <bits/stdc++.h>\n#define rep(I, N) for (int I = 0; I < (N); ++I)\n#define ll long long\n#define pb push_back\n#define pii pair<int, int>\n#define vall(X) (X).begin(), (X).end()\n#define vi vector<int>\n#define vll vector<long long>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nconst int SIZE = 1e6 + 10;\nclass Solution {\npublic:\n    bool check(int amt,vector<int>& cnt)\n{\n            vi dp(amt+1,-1);\n            dp[0]=0;\n            for (int i=1;i<=10;i++) \n            {\n                int temp=cnt[i];\n                rep(s,amt+1) \n                {\n                    if (dp[s]>=0)\n                        dp[s]=temp;\n                    else if (s>=i && dp[s-i]>0)\n                        dp[s] = dp[s-i]-1;\n                    else\n                        dp[s]=-1;\n                }\n            }\n            if(dp[amt]>=0)\n                return true;\n            return false;\n        };\n    int helper(vi& nums, vector<vi>& queries, int n, int m) {\n        vector<vector<vi>> temp(n, vector<vi>(11, vector(m + 1, 0)));\n        rep(j,m) \n        {\n            int l=queries[j][0];\n            int r=queries[j][1];\n            int num=queries[j][2];\n            rep(i,n) \n            {\n                rep(k,11) \n                {\n                    temp[i][k][j+1] = temp[i][k][j];\n                }\n                if (i>=l && i<=r)\n                    temp[i][num][j + 1]++;\n            }\n        }\n        int low=0;\n        int high=m + 1;\n        while (low<high) \n        {\n            int mid=(low+high)/2;\n            bool flag=true;\n            rep(i,n)\n            {\n                vi cnt(11, 0);\n                rep(k,11) cnt[k] = temp[i][k][mid];\n                if (nums[i] == 0)\n                    continue;\n                if (check(nums[i],cnt)==false) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag==false)\n                low = mid+1;\n            else\n                high = mid;\n        }\n        if(low <= m)\n            return low;\n            return -1;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        int m=queries.size();\n        return helper(nums,queries,n,m);\n    }\n};","author":"uzer30","submissionId":"1575155384"},[]]},{"317":[{"id":"317","fileName":"1575154723.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> max_i(n, -1);\n        bool possible = true;\n\n        for (int j = 0; j < n; ++j) {\n            int target = nums[j];\n            if (target == 0) {\n                max_i[j] = -1;\n                continue;\n            }\n\n            vector<pair<int, int>> j_queries;\n            for (int i = 0; i < queries.size(); ++i) {\n                int li = queries[i][0];\n                int ri = queries[i][1];\n                if (li <= j && j <= ri) {\n                    j_queries.emplace_back(i, queries[i][2]);\n                }\n            }\n\n            sort(j_queries.begin(), j_queries.end());\n\n            unordered_map<int, int> dp;\n            dp[0] = -1;\n\n            for (auto& [idx, val] : j_queries) {\n                unordered_map<int, int> tmp;\n                for (auto& [s, m] : dp) {\n                    int new_sum = s + val;\n                    if (new_sum > target) continue;\n                    int new_max = max(m, idx);\n                    if (tmp.find(new_sum) == tmp.end() || new_max < tmp[new_sum]) {\n                        tmp[new_sum] = new_max;\n                    }\n                }\n                for (auto& [s, m] : tmp) {\n                    if (dp.find(s) == dp.end() || m < dp[s]) {\n                        dp[s] = m;\n                    }\n                }\n            }\n\n            if (dp.find(target) == dp.end()) {\n                possible = false;\n            } else {\n                max_i[j] = dp[target];\n            }\n        }\n\n        if (!possible) {\n            return -1;\n        }\n\n        int ans = 0;\n        for (int j = 0; j < n; ++j) {\n            if (nums[j] != 0) {\n                ans = max(ans, max_i[j] + 1);\n            }\n        }\n\n        return ans;\n    }\n};","author":"Rupesh ranjan","submissionId":"1575154723"},[]]},{"318":[{"id":"318","fileName":"1575155318.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        cache = {}\n        def dp(index, value, i):\n            key = (index, value)\n            if key in cache:\n                return cache[key]\n            if value == 0:\n                cache[key] = index\n                return index\n            if index == len(queries):\n                cache[key] = index+1\n                return index+1\n            if not (queries[index][0] <= i <= queries[index][1]):\n                return dp(index+1, value, i)\n            if queries[index][2] > value:\n                return dp(index+1, value, i)\n            val = min(dp(index+1, value-queries[index][2], i), dp(index+1, value, i))\n            cache[key] = val\n            return val\n\n        result = 0\n\n        for i, n in enumerate(nums):\n            cache = {}\n            if n == 0:\n                result = max(result, 0)\n            else:\n                result = max(result, dp(0, n, i))\n        if result >= len(queries)+1:\n            return -1\n        return result","author":"Kai Yang","submissionId":"1575155318"},[]]},{"319":[{"id":"319","fileName":"1575155074.txt","sourceCode":"#include <bits/stdc++.h> \n\n// #define MAIN_ACTIVE\n// #define IO_ON_FILE\n#define MY_DEBUG\n\nusing namespace std;\n#define int64_t wadwafesfesfes21321300242142104210321\nusing int64_t = long long;\nusing pii = pair<int,int>;\nusing pil = pair<int,int64_t>;\nusing pli = pair<int64_t,int>;\nusing pll = pair<int64_t,int64_t>;\n// #define DISABLE_SANITIZER __attribute__((no_sanitize(\"address\", \"thread\")))\n#define umap unordered_map\n#define uset unordered_set\n#define all(x) x.begin(), x.end()\n#define allr(x) x.rbegin(), x.rend()\n#define emp_back emplace_back\n#define bitcount(x) __builtin_popcount((x))\n#define PQ(x, y) priority_queue<x, vector<x>, y<x>>\n// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>\n#ifdef MY_DEBUG\n    #define imie(...) cout << \"[ \" << #__VA_ARGS__ << \" ]: [\"; \n    dfs_imie(__VA_ARGS__); cout << \"]n\";\n    #define imiec(x) cout << \"[ \" << #x << \" ]: [\", show(all(x), \", \", false), cout << \"]n\";\n    #define e_ cout << \"n\";\n#else  \n    #define imie(...);\n    #define imiec(x);\n    #define e_\n#endif\ntemplate <typename T> void dfs_imie(const T& t) { cout << t; }\ntemplate <typename T, typename... Args> void dfs_imie(const T& t, const Args&... args) { cout << t << \", \"; dfs_imie(args...); }\ntemplate <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << \"(\" << duo.first << \", \" << duo.second << \")\"; }\ntemplate <typename Iter> void show(Iter begin, Iter end, const char* sep = \" \", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : \"\") << *it; if(is_end) cout << \"n\"; }\ntemplate<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }\nmt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());\ntemplate <typename T>\nT mrand(T begin, T end) {\n   if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } \n   else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }\n}\n\ntemplate <typename U, typename... Vs>\nbool mmax(U& lhs, const Vs&... rhs) {\n    bool updated = false;\n    ((updated |= (rhs > lhs ? (lhs = rhs, true) : false)), ...);\n    return updated;\n}\n\ntemplate <typename U, typename... Vs>\nbool mmin(U& lhs, const Vs&... rhs) {\n    bool updated = false;\n    ((updated |= (rhs < lhs ? (lhs = rhs, true) : false)), ...);\n    return updated;\n}\n\n//0up, 1down, 2left, 3right, 4upleft, 5downright, 6upright, 7downleft, 8stay\nconstexpr int dy[9] = {-1, 1, 0, 0, -1, 1, -1, 1, 0};\nconstexpr int dx[9] = {0, 0, -1, 1, -1, 1, 1, -1, 0};\nenum DIR { eup, edown, eleft, eright, eupleft, edownright, eupright, edownleft, estay };\n\ntemplate <typename... Args>\nvoid report(const Args&... args) {\n    ((std::cout << args << \" \"), ...) << \"n\";\n}\n\ntemplate <typename... Args>\nvoid read(Args&... args) {\n    (std::cin >> ... >> args);\n}\n\nint fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        const int n = nums.size();\n        const int m = queries.size();\n        if(*max_element(all(nums)) == 0)\n            return 0;\n\n        int ans = -1;\n        for(int i = 0; i < n; i++){\n            vector<int> dp(nums[i] + 1, 0);\n            dp[0] = 1;\n            int whr = -1;\n            for(int j = 0; j < m; j++){\n                auto& q = queries[j];\n                int b = q[0], e = q[1], v = q[2];\n                if(i < b || i > e)\n                    continue;\n                vector<int> xdp = dp;\n                for(int s = 0; s + v <= nums[i]; s++)\n                    if(dp[s])\n                        xdp[s + v] = 1;\n\n                swap(dp, xdp);\n                if(dp[nums[i]]){\n                    whr = j;\n                    break;\n                }\n            }\n\n            if(whr == -1)\n                return -1;\n\n            mmax(ans, whr + 1);\n        }\n\n        return ans;\n    }\n};\n\n#ifdef MAIN_ACTIVE\n// #include <Str_manip.cpp>\n// #include <Format_Print.cpp>\n// #include <Timer.cpp>\n// #include <Matrix.cpp>\n\nvoid solve() {\n}\n\nint main() { \n\n#ifdef IO_ON_FILE\n    const string FILENAME = \"user\";\n    freopen((FILENAME + \".in\").c_str(), \"r\", stdin);\n    ofstream clearFile((FILENAME + \".out\").c_str(), ios::out);\n    clearFile.close();\n    freopen((FILENAME + \".out\").c_str(), \"w\", stdout);\n#endif\n\n    solve();\n\n   return EXIT_SUCCESS;\n}\n#endif","author":"Binary_Mong","submissionId":"1575155074"},[]]},{"320":[{"id":"320","fileName":"1575155279.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        max_k = 0\n        n = len(nums)\n        m = len(queries)\n        \n        for i in range(n):\n            num = nums[i]\n            if num == 0:\n                current_k = 0\n            else:\n                # Collect all queries that include the current index i\n                Q = []\n                for j in range(m):\n                    l, r, val = queries[j]\n                    if l <= i <= r:\n                        Q.append((j, val))\n                \n                if not Q:\n                    return -1\n                \n                # Subset sum dynamic programming\n                dp = {0: -1}\n                target = num\n                for (j, val) in Q:\n                    current_sums = list(dp.keys())\n                    for s in current_sums:\n                        new_sum = s + val\n                        if new_sum not in dp or j < dp.get(new_sum, m):\n                            dp[new_sum] = j\n                \n                if target not in dp:\n                    return -1\n                current_k = dp[target] + 1\n            \n            max_k = max(max_k, current_k)\n        \n        return max_k if max_k <= m else -1","author":"Abhyanand Sharma","submissionId":"1575155279"},[]]},{"321":[{"id":"321","fileName":"1575155737.txt","sourceCode":"class Solution {\npublic:\n    int dp[1001][1001];\n    int genv(int ind,int rem,vector<vector<int>>&queries,int index)\n   {\n       if(rem==0)\n       {\n           return ind;\n       }\n       if(ind==queries.size())\n       {\n           return 1e8;\n       }\n       if(dp[ind][rem]!=-1)\n       {\n           return dp[ind][rem];\n       }\n\n       int ans=1e8;\n       if(queries[ind][0]<=index && queries[ind][1]>=index)\n       {\n           if(queries[ind][2]<=rem)\n           {\n               ans=min(ans,genv(ind+1,rem-queries[ind][2],queries,index));\n           }\n       }\n     \n           ans=min(ans,genv(ind+1,rem,queries,index));\n       \n       return dp[ind][rem]=ans;\n   }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int maxi=0;\n        //finding for all numbers of nums\n        for(int i=0;i<nums.size();i++)\n            {\n                int val=nums[i];\n                if(val==0)\n                {\n                    \n                }\n                else\n                {\n                    for(int j=0;j<queries.size();j++)\n                        {\n                            for(int k1=0;k1<=val;k1++)\n                                {\n                                    dp[j][k1]=-1;\n                                }\n                        }\n                    int ans=genv(0,val,queries,i);\n                    if(ans==1e8)\n                    {\n                        return -1;\n                    }\n                    else\n                    {\n                        maxi=max(maxi,ans);\n                    }\n                }\n            }\n        return maxi;\n    }\n};","author":"Yash Singh","submissionId":"1575155737"},[]]},{"322":[{"id":"322","fileName":"1575155504.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\n        int ans = -1;\n        int cnt = 0;\n        for (auto val : nums) {\n            int q = queries.size();\n            int dp[q + 1][val + 1];\n            memset(dp, 0, sizeof(dp));\n\n            for (int i = 0; i <= q; i++) {\n                dp[i][0] = 1;\n            }\n            for (int i = 1; i <= q; i++) {\n                for (int j = 1; j <= val; j++) {\n                    dp[i][j] = dp[i - 1][j];\n                    if (j >= queries[i - 1][2] && cnt >= queries[i - 1][0] &&\n                        cnt <= queries[i - 1][1]) {\n                        dp[i][j] |= dp[i - 1][j - queries[i - 1][2]];\n                    }\n                    //cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n                }\n            }\n            int done = 0;\n            for (int i = 0; i <= q; i++) {\n                if (dp[i][val] == 1) {\n                    ans = max(ans, i);\n                    done = 1;\n                    break;\n                }\n            }\n            if (!done) {\n                return -1;\n            }\n            cnt++;\n        }\n        return ans;\n    }\n};","author":"ROHITAASX","submissionId":"1575155504"},[]]},{"323":[{"id":"323","fileName":"1575155817.txt","sourceCode":"class Solution:\n    def minZeroArray(self, a: List[int], q: List[List[int]]) -> int:\n        n = len(a)\n        s = [0] * n\n        p = [1 << 0 for _ in range(n)]  \n        \n        if all(x == 0 for x in a):\n            return 0\n        \n        for i, (l, r, v) in enumerate(q, 1):  \n            for j in range(l, r + 1):\n                s[j] += v\n                p[j] |= p[j] << v  \n            \n            f = True\n            for j in range(n):\n                if s[j] < a[j] or (p[j] & (1 << a[j])) == 0:\n                    f = False\n                    break\n            if f:\n                return i\n        \n        f = True\n        for j in range(n):\n            if s[j] < a[j] or (p[j] & (1 << a[j])) == 0:\n                f = False\n                break\n        return len(q) if f else -1","author":"Yash Singhal","submissionId":"1575155817"},[]]},{"324":[{"id":"324","fileName":"1575155962.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define FOR(i, a, b) for(ll i = a; i <= b; i++)\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        ll n = nums.size(), mx = 0;\n        FOR(i, 0, n - 1) if(nums[i]){\n            // cout << i << endl;\n            bool ps[1001] = {0};\n            ps[nums[i]] = 1;\n\n            ll qri = 0;\n            for(auto qr : queries) if(qr[0] <= i && i <= qr[1]){\n                // cout << \"QRU \" << endl;\n                FOR(j, 0, 1000 - qr[2]){\n                    ps[j] |= ps[j + qr[2]];\n                    // cout << \" \" << ps[j] << \" from \" << (j + qr[2]) << endl;\n                }\n                qri++;\n\n                if(ps[0]) break;\n            }else{\n                qri++;\n            }\n\n            // cout << \" => \" << qri << endl;\n\n            if(ps[0]){\n                mx = max(mx, qri);\n            }else{\n                return -1;\n            }\n        }\n\n        return mx;\n    }\n};","author":"Pearl Yu","submissionId":"1575155962"},[]]},{"325":[{"id":"325","fileName":"1575155832.txt","sourceCode":"class Solution:\n    def subset_sum(self, arr, target):\n        dp_prev = [False]*(target+1)\n        dp_prev[0] = True\n        for x in arr:\n            dp_next = list(dp_prev)\n            for v in range(target+1):\n                if not dp_prev[v] or v+x > target:\n                    continue\n                dp_next[v+x] = True\n            dp_prev = dp_next\n            \n        return dp_prev[target]\n        \n    def is_possible(self, nums, queries):\n        index_list = [[] for _ in range(len(nums))]\n        for l,r,val in queries:\n            for i in range(l, r+1):\n                index_list[i].append(val)\n\n        for i in range(len(nums)):\n            if not self.subset_sum(index_list[i], nums[i]):\n                return False\n        return True\n            \n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        left = 0\n        right = len(queries)\n        min_k = None\n        while left <= right:\n            mid = (left+right)//2\n            q_prefix = queries[0:mid]\n            if self.is_possible(nums, q_prefix):\n                right = mid-1\n                min_k = mid\n            else:\n                left = mid+1\n        return min_k if min_k is not None else -1\n                ","author":"Vihari Vemuri","submissionId":"1575155832"},[]]},{"326":[{"id":"326","fileName":"1575156052.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        \n        auto allZero = [&]() {\n            return all_of(nums.begin(), nums.end(), [](int x) { return x == 0; });\n        };\n        if (allZero()) return 0;\n\n        vector<bitset<1001>> dp(n, bitset<1001>().set(0));\n\n        for (int k = 0; k < queries.size(); k++) {\n            int l = queries[k][0], r = queries[k][1], v = queries[k][2];\n            for (int j = l; j <= r; j++) {\n                dp[j] |= (dp[j] << v);\n                for (int pos = nums[j] + 1; pos < 1001; pos++) dp[j].reset(pos);\n            }\n\n            auto allAchieved = [&]() {\n                for (int j = 0; j < n; j++) {\n                    if (!dp[j].test(nums[j])) return false;\n                }\n                return true;\n            };\n\n            if (allAchieved()) return k + 1;\n        }\n        return -1;\n    }\n};\n","author":"7saken","submissionId":"1575156052"},[]]},{"327":[{"id":"327","fileName":"1575156433.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        N = len(nums)\n        if all(val == 0 for val in nums):\n            return 0\n        ps = [{0} for _ in range(N)]\n        for ind, (s, e, inc) in enumerate(queries):\n            for pos in range(s, e + 1):\n                ns = {cur + inc for cur in ps[pos] if cur + inc <= nums[pos]}\n                ps[pos].update(ns)\n            if all(nums[i] in ps[i] for i in range(N)):\n                return ind + 1\n        return -1\n","author":"Rajitha_10","submissionId":"1575156433"},[]]},{"328":[{"id":"328","fileName":"1575155910.txt","sourceCode":"class Solution {\n        List<int[]>[] posQueries;\n\n        public int minZeroArray(int[] nums, int[][] queries) {\n            int n = nums.length, q = queries.length;\n            boolean alreadyZero = true;\n            for (int x : nums) {\n                if (x != 0) {\n                    alreadyZero = false;\n                    break;\n                }\n            }\n            if (alreadyZero) return 0;\n\n            posQueries = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                posQueries[i] = new ArrayList<>();\n            }\n            for (int j = 0; j < q; j++) {\n                int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                for (int i = l; i <= r; i++) {\n                    posQueries[i].add(new int[]{j, val});\n                }\n            }\n\n            int low = 0, high = q, ans = -1;\n            while (low <= high) {\n                int mid = (low + high) / 2;\n                if (checkIsTrue(mid, nums)) {\n                    ans = mid;\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n            return ans;\n        }\n\n        private boolean checkIsTrue(int k, int[] nums) {\n            int n = nums.length;\n            for (int i = 0; i < n; i++) {\n                if (nums[i] == 0) continue;\n                int target = nums[i];\n                boolean[] dp = new boolean[target + 1];\n                dp[0] = true;\n                for (int[] pair : posQueries[i]) {\n                    if (pair[0] >= k) break;\n                    int v = pair[1];\n                    for (int t = target; t >= v; t--) {\n                        if (dp[t - v]) {\n                            dp[t] = true;\n                        }\n                    }\n                }\n                if (!dp[target]) return false;\n            }\n            return true;\n        }\n    }","author":"Night1327","submissionId":"1575155910"},[]]},{"329":[{"id":"329","fileName":"1575156122.txt","sourceCode":"class Solution {\n    bool ok(vector<int> &v, vector<vector<bool> > &d, int n, bool f = false) {\n        for(int i = 0; i < n; ++i) {\n            if(v[i] == 0) { continue; }\n            if(d[i][v[i]] == false) { \n                // if(f) { cout << \"fail: \" << i << \", \" << v[i] << endl; }\n                return false; \n            }\n        }\n        return true;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& qs) {\n        int n = nums.size();\n        int m = qs.size();\n\n        vector<vector<bool> > d(n, vector<bool>(1001, false));\n        bool f = true;\n        for(int i = 0; i < n; ++i) { \n            if(nums[i] != 0) { f = false; }\n            d[i][0] = true; \n        }\n        if(f) { return 0; }\n        \n        for(int i = 0; i < m; ++i) {\n            int l = qs[i][0], r = qs[i][1], val = qs[i][2];\n            // cout << i << \": \" << l << \", \" << r << \", \" << val << endl;\n            for(int j = l; j <= r; ++j) {\n                for(int k = 1001; k >= val; --k) {\n                    d[j][k] = (d[j][k] || d[j][k-val]);\n                }\n            }\n            // if(i == 3) { cout << d[3][2] << endl; }\n            if(ok(nums, d, n)) { return i+1; }\n        }\n        \n        return -1;\n    }\n};","author":"ArthurCx","submissionId":"1575156122"},[]]},{"330":[{"id":"330","fileName":"1575156435.txt","sourceCode":"class Solution {\npublic:\n    int can(vector<int> &v, int targ){\n        if(targ==0) return -1;\n        vector<bool> dp(targ+1, false);\n        dp[0] =  true;\n        for(int I = 0 ; I < v.size() ; I++){\n            int val = v[I];\n            if(val>targ) continue;\n            \n            for(int i = targ ; i >= val ; i--){\n                if((dp[i-val])){\n                    dp[i] = true;\n                }\n            }\n            \n            if(dp.back()) return I+1;\n        }\n        return INT_MAX;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n        vector<vector<int>> v(n);\n        for(auto &val:q){\n            for(int i = val[0] ; i <= val[1] ; i++)\n                v[i].push_back(val[2]);\n        }\n        int Can = 0;\n        for(int i = 0 ; i < n ; i++){\n            int ind = can(v[i], nums[i]);\n            if(ind==-1) continue;\n            if(ind==INT_MAX) return -1;\n            for(int j = 0, l = 0 ; j < q.size(); j++){\n                if(q[j][0]<=i && q[j][1]>=i)\n                    l++;\n                if(l==ind)\n                {\n                    Can = max(Can, j+1);\n                    break;\n                }\n            }\n        }\n        return Can;\n    }\n};","author":"Dhiraj Patil","submissionId":"1575156435"},[]]},{"331":[{"id":"331","fileName":"1575156630.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def possible2(arr,val):\n            m = len(arr)\n            dp = [[False for j in range(val+1)] for i in range(m+1)]\n            for i in range(m+1):\n                dp[i][0]=True\n\n            arr.sort()\n\n            for i in range(1,m+1):\n                for j in range(val+1):\n                    dp[i][j] = dp[i-1][j]\n                    if j-arr[i-1]>=0:\n                        dp[i][j] = dp[i][j] or dp[i-1][j-arr[i-1]]\n\n            return dp[-1][val]\n            \n            \n        def possible(k):\n            dp=[[] for i in range(n)]\n            for [l,r,val] in queries[:k+1]:\n                for i in range(l,r+1):\n                    dp[i].append(val)\n\n            for i in range(n):\n                if not possible2(dp[i],nums[i]):\n                    return False\n            return True\n\n        n = len(nums)\n\n        if nums==[0]*n:\n            return 0\n            \n        q = len(queries)\n        low=0\n        high=q-1\n        ans = sys.maxsize\n        while low<=high:\n            mid = (low+high)//2\n            if possible(mid):\n                ans = min(ans,mid)\n                high = mid-1\n            else:\n                low=mid+1\n\n        if ans == sys.maxsize:\n            return -1\n        return ans+1\n        \n            \n            ","author":"wanderlust312","submissionId":"1575156630"},[]]},{"332":[{"id":"332","fileName":"1575156535.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        M = max(nums) + 1\n        min_k = 0\n        for j, v in enumerate(nums):\n            # find min k to make nums[i] -> 0\n            if v == 0:\n                continue\n            dp = [[0] * (len(queries)+1) for _ in range(M)]\n            dp[0][0] = 1\n            cur_k = -1\n            for i in range(1, len(queries)+1):\n                for m in range(M):\n                    dp[m][i] = dp[m][i-1]\n                    l,r,d = queries[i-1]\n                    if l <= j <= r and m >= d:\n                        dp[m][i] |= dp[m-d][i-1]\n                if dp[v][i] == 1:\n                    cur_k = i\n                    break\n            if cur_k == -1:\n                return -1\n            min_k = max(min_k, cur_k)\n        return min_k\n\"\"\"\n[2,0,2]\n[[0,2,1],[0,2,1],[1,1,3]]\n[4,3,2,1]\n[[1,3,2],[0,2,1]]\n[1,2,3,2,1]\n[[0,1,1],[1,2,1],[2,3,2],[3,4,1],[4,4,1]]\n[1,2,3,2,6]\n[[0,1,1],[0,2,1],[1,4,2],[4,4,4],[3,4,1],[4,4,5]]\n[2]\n[[0,0,6],[0,0,2],[0,0,9],[0,0,5],[0,0,10]]\n\"\"\"","author":"Persephone","submissionId":"1575156535"},[]]},{"333":[{"id":"333","fileName":"1575156875.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(queries)\n\n        def solve(idx, x):\n            if x == 0:\n                return 0\n            A = []\n            for i, (l, r, v) in enumerate(queries):\n                if l <= idx <= r:\n                    A.append((v, i))\n            if not A:\n                return -1\n            sm = set([0])\n            for v, i in A:\n                nsm = set()\n                for s in sm:\n                    if s + v == x:\n                        return i + 1\n                    nsm.add(s + v)\n                sm |= nsm\n            return -1\n\n        ans = -1\n        for i, x in enumerate(nums):\n            cur = solve(i, x)\n            if cur == -1:\n                return -1\n            ans = max(ans, cur)\n        return ans\n        \n        ","author":"Jack Chen","submissionId":"1575156875"},[]]},{"334":[{"id":"334","fileName":"1575156806.txt","sourceCode":"public class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length, q = queries.length;\n        \n\n        boolean alreadyZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                alreadyZero = false;\n                break;\n            }\n        }\n        if (alreadyZero) return 0;\n        \n\n        List<Integer>[] affects = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            affects[i] = new ArrayList<>();\n        }\n        for (int j = 0; j < q; j++) {\n            int l = queries[j][0], r = queries[j][1];\n            // For every index in [l, r], add query j.\n            for (int i = l; i <= r; i++) {\n                affects[i].add(j);\n            }\n        }\n        \n        // Binary search over the prefix length k of queries.\n        int lo = 1, hi = q + 1; // hi = q+1 means \"not possible\" if we exceed q.\n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (canZero(nums, queries, affects, mid)) {\n                hi = mid;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        return lo <= q ? lo : -1;\n    }\n    \n\n    private boolean canZero(int[] nums, int[][] queries, List<Integer>[] affects, int k) {\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n\n            if (target == 0) continue;\n            \n            List<Integer> coins = new ArrayList<>();\n\n            for (int j : affects[i]) {\n                if (j < k) {\n                    coins.add(queries[j][2]);\n                }\n            }\n\n            if (!subsetSum(coins, target)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean subsetSum(List<Integer> coins, int target) {\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n        for (int coin : coins) {\n            for (int s = target; s >= coin; s--) {\n                if (dp[s - coin]) {\n                    dp[s] = true;\n                }\n            }\n        }\n        return dp[target];\n    }\n}\n","author":"Arijit Debnath","submissionId":"1575156806"},[]]},{"335":[{"id":"335","fileName":"1575157120.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        int left = 0, right = m;\n\n        auto eval = [&](vector<int>& arr, int& num) -> bool {\n            int n = arr.size();\n            vector<vector<bool>> dp(n + 1, vector<bool>(num + 1));\n            for (int j = 0; j <= num; ++j) dp[n][j] = false;\n            for (int i = 0; i <= n; ++i) dp[i][num] = true;\n\n            for (int i = n - 1; i >= 0; --i) {\n                for (int j = num - 1; j >= 0; --j) {\n                    dp[i][j] = dp[i + 1][j];\n                    if (arr[i] + j <= num) dp[i][j] = dp[i][j] || dp[i + 1][j + arr[i]];\n                }\n            }\n            return dp[0][0];\n        };\n        \n        auto go = [&](int k) -> bool {\n            vector<int> arr = nums;\n            vector<vector<int>> choices(n);\n            for (int i = 0; i < k; ++i) {\n                for (int j = queries[i][0]; j <= queries[i][1]; ++j) {\n                    choices[j].push_back(queries[i][2]);\n                }\n            }\n            for (int i = 0; i < n; ++i) {\n                if (!eval(choices[i], nums[i])) return false;\n            }\n            return true;\n        };\n        \n        while (left != right) {\n            int mid = left + ((right - left) >> 1);\n            if (go(mid)) right = mid;\n            else left = mid + 1;\n        }\n        return go(left) ? left : -1;\n    }\n};\n/*\n(i, j)\nj == num: return true\nj > num || i == n: return false\n\ndp(i, j) = dp(i + 1, j + arr[i]) || dp(i + 1, j)\n\ndp[i][j] = false, for all j where i = n\ndp[i][j] = true, for all i where j = num\n\ndp[i][j] = dp[i + 1][j]\nif arr[i] + j <= num:\n    dp[i][j] = dp[i][j] || dp[i + 1][j + num]\n\n*/","author":"whitewale","submissionId":"1575157120"},[]]},{"336":[{"id":"336","fileName":"1575157073.txt","sourceCode":"import numpy as np\nfrom typing import List\nimport bisect\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, m = len(nums), len(queries)\n        ode = [(l, r, v) for l, r, v in queries]\n        fill = [[] for _ in range(n)]\n        for idx, (l, r, dec) in enumerate(ode):\n            for pos in range(l, r + 1):\n                fill[pos].append((idx, dec))\n        for i in range(n):\n            fill[i].sort(key=lambda x: x[0])\n        def possible(adha: int) -> bool:\n            for pos in range(n):\n                target = nums[pos]\n                if target == 0:\n                    continue\n                idx = bisect.bisect_left(fill[pos], (adha, ))\n                arr = [d for _, d in fill[pos][:idx] if d <= target]\n                dp = np.zeros(target + 1, dtype=bool)\n                dp[0] = True\n                for d in arr:\n                    shift = np.concatenate((np.zeros(d, dtype=bool), dp[:-d]))\n                    dp |= shift\n                    if dp[target]:\n                        break\n                if not dp[target]:\n                    return False\n            return True\n        a,mate= 0, m + 1\n        while a < mate:\n            adha = (a + mate) // 2\n            if possible(adha):\n                mate= adha\n            else:\n                a = adha + 1\n        return a if a <= m else -1","author":"coder","submissionId":"1575157073"},[]]},{"337":[{"id":"337","fileName":"1575157238.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        bool flag = true;\n        for(auto&i: nums){\n            if(i)flag = false;\n        }\n        if(flag)return 0;\n        int n = nums.size(), m = queries.size();\n        vector<bitset<1010>> v(n, 1);\n        for(int i = 1; auto& q: queries){\n            for(int j = q[0]; j <= q[1]; j++){\n                v[j] |= v[j] << q[2];\n            }\n            bool flag = true;\n            for(int j = 0; j < n; j++)if(v[j][nums[j]] == 0)flag = false;\n            if(flag)return i;\n            i++;\n        }\n        // for(auto&i: v)cout << i << endl;\n        \n        return -1;\n    }\n};","author":"Nehcled","submissionId":"1575157238"},[]]},{"338":[{"id":"338","fileName":"1575157170.txt","sourceCode":"class Solution {\n        static public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length, q = queries.length, start = 0, end = q - 1, mid = 0, ans = -1;\n        boolean allZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) return 0;\n        while (start <= end) {\n            mid = start + (end - start) / 2;\n            boolean x = canBe(nums, queries, mid);\n            if (x) {\n                ans = mid;\n                end = mid - 1;\n            } else\n                start = mid + 1;\n        }\n        return ans == -1 ? -1 : ans + 1;\n    }\n\n    static boolean canBe(int[] arr, int[][] queries, int mid) {\n        int n = arr.length, q = queries.length;\n        ArrayList<ArrayList<Integer>> list = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            list.add(new ArrayList<>());\n        for (int i = 0; i <= mid; i++) {\n            int from = queries[i][0], to = queries[i][1], val = queries[i][2];\n\n            for (int j = from; j <= to; j++) {\n                list.get(j).add(val);\n            }\n\n        }\n        System.out.println(\"list = \" + list);\n        System.out.println(Arrays.toString(arr));\n        for (int i = 0; i < n; i++) {\n            int current = arr[i];\n            Boolean[][] dp = new Boolean[list.get(i).size()][current + 1];\n            boolean canBe = solve(list.get(i).size() - 1, current, list.get(i), dp);\n            if (!canBe)\n                return false;\n            System.out.println(\"for \" + current + \" at i = \" + i + \" canbe = \" + canBe);\n        }\n\n        return true;\n    }\n\n    static boolean solve(int i, int sum, ArrayList<Integer> l, Boolean[][] dp) {\n        if (sum == 0)\n            return true;\n        if (i < 0)\n            return false;\n        if(dp[i][sum] != null) return dp[i][sum];\n        int current = l.get(i);\n        if (sum >= current) {\n            if (solve(i - 1, sum - current, l, dp))\n                return dp[i][sum] = true;\n        }\n        if (solve(i - 1, sum, l, dp))\n            return dp[i][sum] = true;\n        return dp[i][sum]=  false;\n    }\n}","author":"Priyanshu Pandey","submissionId":"1575157170"},[]]},{"339":[{"id":"339","fileName":"1575157507.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] q) {\n        int n = nums.length;\n        int m = q.length;\n        boolean f = true;\n        for(int x:nums) if(x!=0) f = false;\n        if(f) return 0;\n        int st = 1;\n        int end = m;\n        int ans = -1;\n\n        while(st<=end){\n            int mid = st+(end-st)/2;\n            if(possible(nums,q,mid)){\n                ans = mid;\n                end = mid-1;\n            }\n            else st = mid+1;\n        }\n\n        return ans;\n    }\n\n    public boolean possible(int[] a, int[][] q, int lim){\n        int n = a.length;\n        List<Integer>[] l = new ArrayList[n];\n        for(int i=0;i<n;i++) l[i] = new ArrayList<>();\n        for(int i=0;i<lim;i++){\n            int[] t = q[i];\n            int st = t[0];\n            int end = t[1];\n            l[st].add(t[2]);\n            if(end+1<n) l[end+1].add(-1*t[2]);\n        }\n        Map<Integer,Integer> mp = new HashMap<>();\n        for(int i=0;i<n;i++){\n            // System.out.println(l[i]);\n            if(l[i].size()>0){\n                for(int x:l[i]){\n                    if(x>0) mp.put(x,mp.getOrDefault(x,0)+1);\n                    else{\n                        // if(!mp.containsKey(x)) System.out.println(i + \" \" + x + \" \" + lim);\n                        mp.put(-1*x, mp.get(-1*x)-1);\n                        if(mp.get(-1*x)==0) mp.remove(-1*x);\n                    }\n                }\n            }\n            List<Integer> list = new ArrayList<>();\n            for(int x:mp.keySet()){\n                int val = mp.get(x);\n                for(int j=0;j<val;j++) list.add(x);\n            }\n            Boolean[][] dp = new Boolean[a[i]+1][list.size()+1];\n            \n            boolean f = helper(a[i],list,0,dp);\n            if(!f) return false;\n        }\n        return true;\n    }\n\n    public boolean helper(int x, List<Integer> l, int i, Boolean[][] dp){\n        if(i>=l.size()) return x==0;\n        if(dp[x][i]!=null) return dp[x][i];\n        boolean f = helper(x,l,i+1,dp);\n        if(l.get(i)<=x) f = f || helper(x-l.get(i),l,i+1,dp);\n\n        return dp[x][i] = f;\n    }\n}","author":"BJbTI92iGT","submissionId":"1575157507"},[]]},{"340":[{"id":"340","fileName":"1575157496.txt","sourceCode":"class Solution {\npublic:\n    bool checkForSubsetSumPossible(vector<int>& nums, vector<vector<int>>& queries, int k) {\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            vector<int> contributions;\n            for (int j = 0; j <= k; j++) {\n                int l = queries[j][0], r = queries[j][1], x = queries[j][2];\n                if (i >= l && i <= r) {\n                    contributions.push_back(x);\n                }\n            }\n            int target = nums[i];\n            vector<bool> dp(target + 1, false);\n            dp[0] = true;\n            for (int x : contributions) {\n                for (int s = target; s >= x; s--) {\n                    if (dp[s - x])\n                        dp[s] = true;\n                }\n            }\n            if (!dp[target])\n                return false;\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        vector<vector<int>> temp = queries; \n\n        bool allZeros = true;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != 0) {\n                allZeros = false;\n                break;\n            }\n        }\n        if (allZeros)\n            return 0;\n\n        int low = 0, high = q - 1, ans = -1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (checkForSubsetSumPossible(nums, queries, mid)) {\n                ans = mid + 1;  \n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    \n        return ans;\n    }\n};\n","author":"Srishti1371","submissionId":"1575157496"},[]]},{"341":[{"id":"341","fileName":"1575157646.txt","sourceCode":"int dp[1002][11][1002];\nint rec(int i,int j,int val,vector<int>& nums, vector<vector<int>>& queries){\n    if(i==-1) return val==0;\n    if(dp[i][j][val]!=-1) return dp[i][j][val];\n    dp[i][j][val]=rec(i-1,j,val,nums,queries);\n    if(queries[i][2]<=val and queries[i][0]<=j and queries[i][1]>=j) dp[i][j][val]|=rec(i-1,j,val-queries[i][2],nums,queries);\n    return dp[i][j][val];\n}\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int q=queries.size(),n=nums.size();\n        for(int i=0;i<q;i++) for(int j=0;j<n;j++) for(int k=0;k<=1000;k++) dp[i][j][k]=-1;\n        int c=0;\n        for(int i=0;i<n;i++) if(nums[i]==0) c++;\n        if(c==n) return 0;\n        for(int i=q-1;i>=0;i--) for(int j=0;j<n;j++) rec(i,j,nums[j],nums,queries);\n        for(int i=0;i<q;i++){\n            int flag=1;\n            for(int j=0;j<n;j++) if(dp[i][j][nums[j]]==0){\n                flag=0;\n                break;\n            }\n            if(flag==1) return i+1;\n        }\n        return -1;\n    }\n};","author":"justDummy","submissionId":"1575157646"},[]]},{"342":[{"id":"342","fileName":"1575157285.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number}\n */\nvar minZeroArray = function(nums, queries) {\n    if (Math.max(...nums) === 0) return 0\n    const N = nums.length\n    const cands = Array(N).fill(0).map((x, i) => new Set([nums[i]]))\n    for (let i = 0; i < queries.length; i++) {\n        const [l, r, val] = queries[i]\n        for (let j = l; j <= r; j++) {\n            const arr = []\n            for (const cand of cands[j]) {\n                if (cand - val >= 0) arr.push(cand - val)\n            }\n            for (const c of arr) cands[j].add(c)\n        }\n        if (check()) return i + 1\n    }\n    return -1\n    function check() {\n        for (const cand of cands) {\n            if (!cand.has(0)) return false\n        }\n        // console.log('check', cands)\n        return true\n    }\n};","author":"Harttle","submissionId":"1575157285"},[]]},{"343":[{"id":"343","fileName":"1575157637.txt","sourceCode":"\n\n\n/*Don Paul*/\n \n#define ll long long \n#define ld long double\n#define el __int128\n\n#define vl vector<ll>\n#define ust unordered_set\n#define ump unordered_map\n#define prq priority_queue\n \n#define pb push_back\n#define pp pop_back\n#define sz(x) ((int)x.size())\n#define be(x) x.begin(), x.end()\n#define farr(i, arr) for(int i=0; i<arr.size(); ++i)\n#define fpr(it, m) for(auto it=m.begin(); it!=m.end(); ++it)\n\n\n//Debugging tools\n\n#define lines cout<<\"n----------------------n\"\n#define bline cout<<\"n======================n\"\n#define parr(arr) for(int i=0; i<arr.size(); ++i) cout<<arr[i]<<\" \"; cout<<\"n\";\n#define pset(s) for(auto i=s.begin(); i!=s.end(); ++i) cout<<*i<<\" \"; cout<<\"n\";\n#define pmap(m) for(auto i=m.begin(); i!=m.end(); ++i) cout<<i->first<<\" - \"<<i->second<<\"n\";\n \nll mod = 1e9 + 7;\nll inf = 7e18;\n \n/*======================================================================================================================*/\n\n\nbool find1(ll curr, ll pos, vl &arr, vector<vector<ll>> &dp, ll tar)\n{\n    if(curr > tar)\n        return false;\n\n    if(curr == tar)\n        return true;\n    \n    if(pos == sz(arr))\n        return false;\n    \n    if(dp[pos][curr] != -1)\n        return dp[pos][curr];\n\n    ll now = arr[pos];\n    \n    bool stat = false;\n    \n    bool a1 = find1(curr, pos+1, arr, dp, tar);\n    bool a2 = find1(curr+now, pos+1, arr, dp, tar);\n    \n    stat |= a1;\n    stat |= a2;\n    \n    return dp[pos][curr] = stat;\n}\n\n\nll check(ll val, vl &arr)\n{\n    ll n = sz(arr);\n    ll sum = val + 1;\n    \n    vector<ll> t(sum, -1);\n    vector<vector<ll>> dp(n, t);\n    \n    bool stat = find1(0, 0, arr, dp, val);\n    \n    return stat;\n    \n}\n\n\nbool find(vector<int> &nums, vector<vector<int>> &q, ll val)\n{\n    unordered_map<ll, vl> m;\n    \n    \n    for(ll i=0; i<=val; ++i)\n    {\n        ll l = q[i][0];\n        ll r = q[i][1];\n        ll val = q[i][2];\n        \n        for(ll j=l; j<=r; ++j)\n        {\n            m[j].pb(val);\n        }\n    }\n         \n    for(ll i=0; i<sz(nums); ++i)\n    {\n        ll curr = nums[i];\n        bool stat = check(curr, m[i]);\n        \n        if(!stat)\n            return false;\n    }\n    \n    return true;\n}\n\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        \n        ll low = 0;\n        ll high = sz(q)-1;\n    \n        ll ans = -1;\n        \n        ll cnt = 0;\n        \n        for(ll i=0; i<sz(nums); ++i)\n        {\n            if(nums[i] == 0)\n                ++cnt;\n        }\n        \n        if(cnt == sz(nums))\n            return 0;\n        \n        while(low <= high)\n        {\n            ll mid = (low + high)/2;\n            bool stat = find(nums, q, mid);\n            \n            if(stat)\n            {\n                ans = mid;\n                high = mid-1;\n            }                \n\n            else\n                low = mid+1;\n        }\n        \n        if(ans == -1)\n            return -1;\n        \n        return ans+1;\n        \n    }\n};\n\n\n\n\n\n\n","author":"Don Paul","submissionId":"1575157637"},[]]},{"344":[{"id":"344","fileName":"1575157596.txt","sourceCode":"from collections import defaultdict\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        d=defaultdict(set)\n        # each index has its own set and we just expand the set with the val, if at some point we find our nums[i] then we increase the counter and mark it as true\n        a=0\n        for x in nums:\n            a+=x\n        if a==0:\n            return 0\n        n=len(nums)\n        c=0\n        found=[False]*n\n        for i in range(n):\n            if nums[i]==0:\n                found[i]=True\n                c+=1\n        \n        for i in range(n):\n            d[i]={0}\n        for k,(l,r,val) in enumerate(queries):\n            for i in range(l,r+1):\n                if not found[i]:\n                    cur_set=d[i]\n                    new_set=set()\n                    for x in cur_set:\n                        new_set.add(x)\n                    for x in cur_set:\n                        if x+val==nums[i]:\n                            c+=1\n                            if c==n:\n                                return k+1\n                            found[i]=True\n                        new_set.add(x+val)\n                    d[i]=new_set\n        return -1\n        ","author":"Cem Birler","submissionId":"1575157596"},[]]},{"345":[{"id":"345","fileName":"1575157769.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n=len(nums)\n        dp=[[0 for i in range(1001)] for _ in range(n)]\n        for i in range(n):\n            dp[i][nums[i]]=1\n        cnt0=0\n        for i in range(n):\n            if dp[i][0]==1: cnt0+=1\n        if cnt0==n: return 0\n            \n        for e, [l,r,val] in enumerate(queries):\n            for i in range(l,r+1):\n                for j in range(1001):\n                    if dp[i][j]==1 or (j+val<=1000 and dp[i][j+val]==1):\n                        dp[i][j]=1\n            cnt0=0\n            for i in range(n):\n                if dp[i][0]==1: cnt0+=1\n            if cnt0==n: return e+1\n        return -1","author":"Cheng-Shun Liu","submissionId":"1575157769"},[]]},{"346":[{"id":"346","fileName":"1575158066.txt","sourceCode":"class Solution {\npublic:\n    bool fun(vector<int>& a, vector<vector<int>>& q, int k) {\n        int n = a.size();\n        for (int i = 0; i < n; i++) {\n            int el = a[i];\n            bitset<1101> dp;\n            dp[0] = 1;\n            for (int j = 0; j < k; j++) {\n                int l = q[j][0], r = q[j][1], val = q[j][2];\n                if (l <= i && i <= r) {\n                    dp |= (dp << val);\n                }\n            }\n            if (!dp[el]) return 0;\n        }\n        return 1;\n    }\n\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size();\n        int m = q.size();\n\n        int f=1;\n        for(int i=0;i<n;i++){\n            if(a[i]!=0) f=0;\n        }\n        if(f) return 0;\n        \n        if (!fun(a, q, m))\n            return -1;\n        \n        int l = 1, r = m;\n        int ans=-1;\n        while (l<=r) {\n            int mid = l + (r - l) / 2;\n            if (fun(a, q, mid)){\n                ans=mid;\n                r = mid-1;\n            }\n            else{\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n};\n","author":"Jaikrit Sanandiya","submissionId":"1575158066"},[]]},{"347":[{"id":"347","fileName":"1575158097.txt","sourceCode":"from sortedcontainers import SortedSet\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        n_q = len(queries)\n\n        res = 0\n        for idx, num in enumerate(nums):\n            if not num: continue\n            opts = SortedSet([num])\n            #print(f\"idx = {idx}\")\n            #print(0, opts)\n            for i, q in enumerate(queries):\n                if idx < q[0] or idx > q[1]:\n                    continue\n                found = False\n                for num2 in reversed(list(opts)):\n                    num3 = num2 - q[2]\n                    #print(f\"num3 = {num3}\")\n                    if num3 < 0:\n                        break\n                    elif num3 == 0:\n                        found = True\n                        break\n                    opts.add(num3)\n                #print(i + 1, opts)\n                if found:\n                    res = max(res, i + 1)\n                    #print(f\"res = {res}\")\n                    break\n            else: return -1\n        return res","author":"sveng101","submissionId":"1575158097"},[]]},{"348":[{"id":"348","fileName":"1575157803.txt","sourceCode":"\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int m = queries.length, low = 0, high = m + 1;\n        while(low < high){\n            int mid = low + (high - low) / 2;\n            if(check(nums, queries, mid)) high = mid;\n            else low = mid + 1;\n        }\n        return low <= m ? low : -1;\n    }\n    boolean check(int[] nums, int[][] queries, int k) {\n        int n = nums.length;\n        for(int i = 0; i < n; i++){\n            int target = nums[i];\n            ArrayList<Integer> coins = new ArrayList<>();\n            for(int j = 0; j < k; j++){\n                if(queries[j][0] <= i && i <= queries[j][1]){\n                    coins.add(queries[j][2]);\n                }\n            }\n            if(!canAchieve(target, coins)) return false;\n        }\n        return true;\n    }\n    boolean canAchieve(int target, List<Integer> coins) {\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n        for(int coin : coins){\n            if(coin > target) continue;\n            for(int j = target; j >= coin; j--){\n                if(dp[j - coin]) dp[j] = true;\n            }\n        }\n        return dp[target];\n    }\n}\n","author":"ChristopherJiang","submissionId":"1575157803"},[]]},{"349":[{"id":"349","fileName":"1575158136.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int res = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (nums[i] == 0) continue;\n            int r = helper(queries, i, nums[i]);\n            if (r == -1) return -1;\n            res = max(res, r);\n        }\n        return res;\n    }\n    int helper(vector<vector<int>>& q, int i, int v) {\n        vector<int> seen(1001, 0);\n        seen[0] = 1;\n        for (int j = 0; j < q.size(); ++j) {\n            if (q[j][0] <= i && q[j][1] >= i) {\n                int val = q[j][2];\n                set<int> add;\n                for (int k = 0; k <= v - val; k++) {\n                    if (seen[k]) \n                        add.insert(k + val);\n                }\n                for (int k : add)\n                    seen[k] = 1;\n                if (seen[v]) return j + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"Tyrande","submissionId":"1575158136"},[]]},{"350":[{"id":"350","fileName":"1575158439.txt","sourceCode":"class Solution {\npublic:\n    bool subsetSumToK(int n, int k, vector<int> &arr) {\n        if(n == 0)\n        {\n            return (k == 0);\n        }\n        // Initialize a 2D DP array with dimensions (n x k+1) to store subproblem results\n        vector<vector<bool>> dp(n, vector<bool>(k + 1, false));\n\n        // Base case: If the target sum is 0, we can always achieve it by taking no elements\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        // Base case: If the first element of 'arr' is less than or equal to 'k', set dp[0][arr[0]] to true\n        if (arr[0] <= k) {\n            dp[0][arr[0]] = true;\n        }\n\n        // Fill the DP array iteratively\n        for (int ind = 1; ind < n; ind++) {\n            for (int target = 1; target <= k; target++) {\n                // If we don't take the current element, the result is the same as the previous row\n                bool notTaken = dp[ind - 1][target];\n\n                // If we take the current element, subtract its value from the target and check the previous row\n                bool taken = false;\n                if (arr[ind] <= target) {\n                    taken = dp[ind - 1][target - arr[ind]];\n                }\n\n                // Store the result in the DP array for the current subproblem\n                dp[ind][target] = notTaken || taken;\n            }\n        }\n\n        // The final result is stored in dp[n-1][k]\n        return dp[n - 1][k];\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) \n    {\n        int sz = nums.size();\n        int n = queries.size();\n        int lo = 0, hi = n;\n        int ans = -1;\n        while(lo <= hi)\n        {\n            int mid = (lo + ((hi-lo)/2));\n            bool good = true;\n            for(int i = 0; i < sz; ++i)\n            {\n                vector<int> temp;\n                for(int j = 0; j < mid; ++j)\n                {\n                    int l = queries[j][0];\n                    int r = queries[j][1];\n                    int val = queries[j][2];\n                    if(i >= l && i <= r)\n                    {\n                        temp.push_back(val);\n                    }\n                }\n                int tsz = temp.size();\n                if(!subsetSumToK(tsz, nums[i], temp))\n                {\n                    good = false;\n                    break;\n                }\n            }\n            if(good)\n            {\n                ans = mid;\n                hi = (mid-1);\n            }\n            else \n            {\n                lo = (mid+1);\n            }\n        }\n        return ans;\n    }\n};","author":"Prajjawal_Agrahari","submissionId":"1575158439"},[]]},{"351":[{"id":"351","fileName":"1575158145.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] qs) {\n        int n = nums.length, m = qs.length;\n        boolean all0 = true;\n        for (int x : nums) {\n            if(x != 0) { all0 = false; break; }\n        }\n        if(all0) return 0;\n        for (int k = 1; k <= m; k++) {\n            boolean ok = true;\n            for (int j = 0; j < n; j++) {\n                int tar = nums[j];\n                if(tar == 0) continue;\n                boolean[] dp = new boolean[tar + 1];\n                dp[0] = true;\n                for (int i = 0; i < k; i++) {\n                    int l = qs[i][0], r = qs[i][1], v = qs[i][2];\n                    if(j >= l && j <= r) {\n                        for (int t = tar - v; t >= 0; t--) {\n                            if(dp[t]) dp[t + v] = true;\n                        }\n                    }\n                }\n                if(!dp[tar]) { ok = false; break; }\n            }\n            if(ok) return k;\n        }\n        return -1;\n    }\n}\n","author":"Vivek","submissionId":"1575158145"},[]]},{"352":[{"id":"352","fileName":"1575158544.txt","sourceCode":"class Solution {\npublic:\n    // finds the maximum amount of queries needed to be taken\n    vector<vector<int>> dp;\n    vector<vector<int>> q;\n    int minZeroArray(vector<int>& v, vector<vector<int>>& queries) {\n        q = queries;\n        // for each index in v run a dp memo\n        // take max or return -1 if invalid\n        \n        int ans = 0;\n        int i = 0;\n        for (auto &n : v){\n            dp = vector<vector<int>>(1001, vector<int>(q.size(), -2));\n            int next = dfs(n, 0, i);\n            ++i;\n            if (next == -1) return -1;\n            ans = max(ans, next);\n        }\n        return ans;\n    }\n\n    int dfs(int n, int i, int r){\n        if (n == 0) return 0;\n        if (n < 0) return -1;\n        if (i == q.size()) return -1;\n        if (dp[n][i] == -2){\n            // choose to skip\n            int skip = dfs(n, i + 1, r);\n            if (skip != -1) skip += 1;\n            int ans = skip;\n            // choose to take if possible\n            int take = -1;\n            if (r >= q[i][0] && r <= q[i][1])\n                take = dfs(n - q[i][2], i + 1, r);\n            if (take != -1) take += 1;\n            if (ans == -1) ans = take;\n            else if (take != -1) ans = min(ans, take);\n            dp[n][i] = ans;\n        }\n        return dp[n][i];\n    }\n};","author":"epicfailure2015","submissionId":"1575158544"},[]]},{"353":[{"id":"353","fileName":"1575158261.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        bool alreadyZero = true;\n        for(int x: nums) {\n            if(x != 0) {\n                alreadyZero = false;\n                break;\n            }\n        }\n        if(alreadyZero) return 0;\n        vector<vector<bool>> dp(n, vector<bool>(1001, false));\n        for(int j = 0; j < n; j++){\n            dp[j][0] = true;\n        }\n        for(int i = 0; i < m; i++){\n            int start = queries[i][0];\n            int end = queries[i][1];\n            int dec = queries[i][2];\n            for(int j = start; j <= end; j++){\n                for(int s = 1000; s >= dec; s--){\n                    if(dp[j][s - dec]){\n                        dp[j][s] = true;\n                    }\n                }\n            }\n            bool allPossible = true;\n            for(int j = 0; j < n; j++){\n                int need = nums[j];\n                if(need <= 1000){\n                    if(!dp[j][need]){\n                        allPossible = false;\n                        break;\n                    }\n                } else {\n                    allPossible = false;\n                    break;\n                }\n            }\n            if(allPossible){\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n};\n","author":"Sarthak Soni","submissionId":"1575158261"},[]]},{"354":[{"id":"354","fileName":"1575158559.txt","sourceCode":"typedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\ntypedef unordered_map<int,int> umi;\ntypedef unordered_map<char,int> umci;\ntypedef map<int, int> aomi;\ntypedef map<char,int> aomci;\ntypedef map<int, int, greater<int>> domi;\ntypedef unordered_set<int> usi;\ntypedef unordered_set<char> usc;\ntypedef set<int> aosi;\ntypedef set<int, greater<int>> dosi;\ntypedef unordered_multiset<int> umsi;\ntypedef multiset<int> aomsi;\ntypedef multiset<int, greater<int>> domsi;\ntypedef priority_queue<int, vector<int>, greater<int>> minHeap;\ntypedef priority_queue<int> maxHeap;\ntypedef pair<int,int> pi;\ntypedef pair<long long, int> pli;\ntypedef pair<long long, long long> pll;\n#define PB push_back\n#define PPB pop_back\n#define LB lower_bound\n#define UB upper_bound\n#define AREP(i, a)   for(auto &i: a)\n#define REP(i, a, b)    for(auto i = a; i<b; i++)\n#define REPE(i, a, b)    for(auto i = a; i<=b; i++)\n#define RREP(i, a, b)   for(auto i = a; i>=b; i--)\n#define asort(v)    sort(v.begin(), v.end());\n#define dsortvi(v)  sort(v.begin(), v.end(), greater<int>());\n\n\n\n\n// Logical issue\n// class Solution {\n// public:\n//     int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n//         int n = nums.size();\n//         bool flag = true;\n//         AREP(i, nums)\n//             if(i){\n//                 flag = false;\n//                 break;\n//             }\n//         if(flag)\n//             return 0;\n\n//         int ans = 0;\n//         AREP(query, queries){\n//             ans ++;\n//             REPE(i, query[0], query[1])\n//                 if(nums[i] >= query[2])\n//                     nums[i] -= query[2];\n            \n//             flag = true;\n//             AREP(i, nums)\n//                 if(i){\n//                     flag = false;\n//                     break;\n//                 }\n//             if(flag)\n//                 return ans;\n//         }\n//         return -1;\n//     }\n// };\n\n\n\n\n\nclass Solution {\n    bool isZero(vi &vec){\n        AREP(i, vec)\n            if(i)\n                return false;\n        return true;\n    }\n    bool isZero(vi &a, vector<vi> &b, int n){\n        REP(i, 0, n)\n            if(!b[i][a[i]])\n                return false;\n        return true;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        if(isZero(nums))\n            return 0;\n        \n        int n = nums.size();\n        int ans = 0;\n        \n        vector<vi> canDel(n, vi(1001, 0));\n        REP(i, 0, n)\n            canDel[i][0] = 1;\n        \n        AREP(query, queries){\n            ans ++;\n            int val = query[2];\n            REPE(i, query[0], query[1]){\n                RREP(j, 1000, 0)\n                    if(canDel[i][j] && j+val <= 1000)\n                        canDel[i][j+val] = 1;\n            }\n\n            \n            if(isZero(nums, canDel, n))\n                return ans;\n        }\n        return -1;\n    }\n};","author":"Yash Wairagade","submissionId":"1575158559"},[]]},{"355":[{"id":"355","fileName":"1575158582.txt","sourceCode":"class Solution {\n    public:\n        int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n            int q = queries.size(), n = nums.size();\n\n            auto isSumPoss = [&](vector<int> v, int sum) {\n                int n = v.size();\n                vector<vector<int>> dp(n + 1, vector<int>(sum + 1, 0));\n                dp[0][0] = 1;\n\n                for (int i = 1; i <= n; ++i) {\n                    for (int j = 0; j <= sum; ++j) {\n                        dp[i][j] = dp[i - 1][j];\n                        if (j >= v[i - 1]) {\n                            dp[i][j] |= dp[i - 1][j - v[i - 1]];\n                        }\n                    }\n                }\n                return dp[n][sum];\n            };\n\n            auto check = [&](int k) {\n                map<int, vector<int>> mp;\n                for (int i = 0; i < k; ++i) {\n                    for (int j = queries[i][0]; j <= queries[i][1]; ++j) {\n                        mp[j].push_back(queries[i][2]);\n                    }\n                }\n                for (int i = 0; i < n; ++i) {\n                    vector<int> v = mp[i];\n                    // for (int x : v) cout << x << 'n';\n                    if (!isSumPoss(v, nums[i])) {\n                        return false;\n                    }\n                }\n\n                return true;\n            };\n\n            int lo = 0, hi = q;\n            while (lo <= hi) {\n                int mid = lo + (hi - lo) / 2;\n                if (check(mid)) {\n                    hi = mid - 1;\n                } else {\n                    lo = mid + 1;\n                }\n            }\n\n            // for (int i = 0; i <= q; ++i) cout << check(i) << 'n';\n\n            return (lo <= q ? lo : -1);\n        }\n    };","author":"Sameer Rawat","submissionId":"1575158582"},[]]},{"356":[{"id":"356","fileName":"1575158321.txt","sourceCode":"class Solution(object):\n    def minZeroArray(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        m = len(queries)\n        \n        # Initialize sets for achievable sums\n        S = [set([0]) for _ in range(n)]\n        # Track which indices have achieved their required sum\n        achieved = [nums[i] == 0 for i in range(n)]\n        # Count indices that still need to be zeroed\n        not_achieved = sum(1 for i in range(n) if nums[i] > 0)\n        \n        # If nums is already all zeros, return 0\n        if not_achieved == 0:\n            return 0\n        \n        # Process each query\n        for q in range(m):\n            li, ri, vali = queries[q]\n            # Update achievable sums for each index in range [li, ri]\n            for i in range(li, ri + 1):\n                if not achieved[i]:\n                    # Add new sums by including the current query's value\n                    new_sums = {s + vali for s in S[i] if s + vali <= nums[i]}\n                    S[i] |= new_sums  # Union with existing sums\n                    # Check if target sum is achieved\n                    if nums[i] in S[i]:\n                        achieved[i] = True\n                        not_achieved -= 1\n            # If all indices are zeroed, return current k\n            if not_achieved == 0:\n                return q + 1\n        \n        # If not all indices can be zeroed, return -1\n        return -1","author":"Sudhish Rithvik","submissionId":"1575158321"},[]]},{"357":[{"id":"357","fileName":"1575158614.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n    \n        vector<vector<bool>> dp(n, vector<bool>(1001, false));\n        for (int j = 0; j < n; j++) {\n            dp[j][0] = true;  \n        }\n        bool is_zero = true;\n        for (int j = 0; j < n; j++) {\n            if (nums[j] != 0) {\n                is_zero = false;\n                break;\n            }\n        }\n        if (is_zero) return 0;\n    \n        for (int i = 0; i < queries.size(); i++) {\n            int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                for (int s = nums[j]; s >= v; s--) {\n                    if (!dp[j][s] && dp[j][s - v]) {\n                        dp[j][s] = true;\n                    }\n                }\n            }\n            \n            bool all_zero = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j][nums[j]]) {\n                    all_zero = false;\n                    break;\n                }\n            }\n            if (all_zero) return i + 1;\n        }\n        \n        return -1;\n    }\n};","author":"ahong107","submissionId":"1575158614"},[]]},{"358":[{"id":"358","fileName":"1575158193.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<bool>> left(n,vector<bool>(1001,false));\n        int max = *std::max_element(nums.begin(), nums.end());\n        if(max==0) return 0;\n        for(int i =0;i<n;i++){\n            left[i][nums[i]] = true;\n        }\n        for(int j = 0; j < queries.size();j++)\n        {\n            for(int i = queries[j][0]; i<= queries[j][1];i++){\n                if(left[i][0]) continue;\n                for(int k = queries[j][2];k <= 1000;k++){\n                    if(left[i][k])\n                        left[i][k-queries[j][2]] = true;\n                }\n            }\n            bool res = true;    \n            for(int i =0;i<n;i++){\n                res &= left[i][0];\n            }\n            if(res) return j+1;\n        }\n        return -1;\n    }\n};","author":"Claude Yang","submissionId":"1575158193"},[]]},{"359":[{"id":"359","fileName":"1575158644.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] a, int[][] q) {\n        int n = a.length;\n        int m = q.length;\n        \n        boolean allZero = true;\n        for (int x : a) {\n            if (x != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) return 0;\n        \n        int[] b = a.clone();\n        \n        for (int k = 1; k <= m; k++) {\n            boolean ok = true;\n            for (int i = 0; i < n; i++) {\n                ArrayList<Integer> c = new ArrayList<>();\n                for (int j = 0; j < k; j++) {\n                    int l = q[j][0], r = q[j][1], v = q[j][2];\n                    if (l <= i && i <= r) {\n                        c.add(v);\n                    }\n                }\n                int t = a[i];\n                boolean[] d = new boolean[t + 1];\n                d[0] = true;\n                for (int x : c) {\n                    for (int s = t; s >= x; s--) {\n                        d[s] = d[s] || d[s - x];\n                    }\n                }\n                if (!d[t]) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) return k;\n        }\n        return -1;\n    }\n}","author":"adwicorp","submissionId":"1575158644"},[]]},{"360":[{"id":"360","fileName":"1575158653.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n\n        auto check = [&](int x) {\n            for(int j = 0; j < n; j++){\n                vector<bool> dp(1005, 0);\n                dp[0] = true;\n\n                for(int i = 0; i < x; i++){\n                    int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n\n                    if(j >= l && j <= r){\n                        for (int s = 1000 - v; s >= 0; s--) if (dp[s]) dp[s + v] = true;\n                    }\n                }\n\n                if (!dp[nums[j]]) return 0;\n            }\n            return 1;\n        };\n\n        int lo = 0, hi = m, ans = -1;\n        while (lo <= hi) {\n            int mid = (lo + hi) / 2;\n            if (check(mid)) { ans = mid; hi = mid - 1; } \n            else lo = mid + 1;\n        }\n\n        return ans;\n    }\n};","author":"Navdeep Rathore","submissionId":"1575158653"},[]]},{"361":[{"id":"361","fileName":"1575158770.txt","sourceCode":"import java.util.HashSet;\n\nclass Solution {\n    public int minZeroArray(int[] arr, int[][] queries) {\n\n\n        int max = arr[0];\n        for (int v : arr) {\n            max = Math.max(v, max);\n        }\n        boolean[][] dp = new boolean[arr.length][max + 1];\n        for (int i = 0; i < arr.length; i++) {\n            dp[i][arr[i]] = true;\n        }\n        if (allOk(dp)) {\n            return 0;\n        }\n        for (int i = 0; i < queries.length; i++) {\n            int[] query = queries[i];\n            int l = query[0], r = query[1], v = query[2];\n\n            for (int idx = l; idx <= r; idx++) {\n                if (dp[idx][0]) {\n                    continue;\n                }\n                for (int vv = 0; vv < arr[idx]; vv++) {\n                    if (vv + v <= max && dp[idx][vv + v]) {\n                        dp[idx][vv] = true;\n                    }\n                }\n            }\n            if (allOk(dp)) {\n                return i + 1;\n            }\n        }\n        return -1;\n\n//        if (!canResolve(queries, queries.length + 1, arr)) {\n//            return -1;\n//        }\n//\n//        int lo = 0, hi = queries.length;\n//        while (lo < hi) {\n//            int mid = lo + (hi - lo) / 2;\n//            if (canResolve(queries, mid, arr)) {\n//                hi = mid;\n//            } else {\n//                lo = mid + 1;\n//            }\n//        }\n//        return hi;\n\n    }\n\n    private boolean allOk(boolean[][] dp ) {\n        for (boolean[] arr : dp) {\n            if (!arr[0]) {\n\n                return false;\n            }\n        }\n        return true;\n    }\n\n//    private boolean canResolve(int[][] queries, int cap, int[] arr) {\n//        int[] delta = new int[arr.length];\n//        for (int i = 0; i < cap; i++) {\n//            int[] q = queries[i];\n//            int l = q[0];\n//            int r = q[1];\n//            int d = q[2];\n//        }\n//    }\n}","author":"zokumyoin","submissionId":"1575158770"},[]]},{"362":[{"id":"362","fileName":"1575158709.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<bool>done(n, false);\n        bool f=true;\n        for(int i=0;i<n;i++){\n            if(nums[i]==0) done[i]=true;\n            else f=false;\n        }\n        if(f) return 0;\n        \n        for(int i=0;i<queries.size();i++){\n            bool flag=true;\n            for(int j=0;j<n;j++){\n                if(done[j]) continue;\n                vector<int>v;\n                for(int k=0;k<=i;k++){\n                    if(j>=queries[k][0] && j<=queries[k][1]){\n                        v.push_back(queries[k][2]);\n                    }\n                }\n                vector<bool>dp(nums[j]+1, false);\n                dp[0] = true;\n                for(auto it:v){\n                    for(int l=nums[j];l>=it;l--){\n                        if(dp[l-it]) dp[l]=true;\n                    }\n                }\n                if(!dp[nums[j]]){\n                    flag=false;\n                    break;\n                }\n                else done[j]=true;\n            }\n            if(flag) return i+1;\n        }\n        return -1;\n    }\n};","author":"Siddharth Bisht","submissionId":"1575158709"},[]]},{"363":[{"id":"363","fileName":"1575158678.txt","sourceCode":"class Solution {\npublic:\n    bool cans(int t, const vector<int>& d) {\n        int n = d.size();\n        vector<bool> dp(t + 1, false);\n        dp[0] = true;\n        \n        for (int num : d) {\n            for (int j = t; j >= num; --j) {\n                dp[j] = dp[j] || dp[j - num];\n            }\n        }\n        \n        return dp[t];\n    }\n\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size();\n        set<int> s(a.begin(), a.end());\n        if (s.size() == 1 && *s.begin() == 0) return 0; \n\n        int l = 0, r = q.size(), ans = -1;\n        \n        while (l <= r) {\n            int m = (l + r) / 2;\n            vector<vector<int>> d(n);\n\n            for (int i = 0; i < m; ++i) {\n                for (int j = q[i][0]; j <= q[i][1]; ++j) {\n                    d[j].push_back(q[i][2]);\n                }\n            }\n\n            bool f = true;\n            for (int i = 0; i < n; ++i) {\n                if (a[i] != 0 && !cans(a[i], d[i])) { \n                    f = false;\n                    break;\n                }\n            }\n\n            if (f) {\n                ans = m;\n                r = m - 1;\n            } else {\n                l = m + 1;\n            }\n        }\n\n        return ans;\n    }\n};\n","author":"Manorath Reddy","submissionId":"1575158678"},[]]},{"364":[{"id":"364","fileName":"1575159545.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size();\n        int m = q.size();\n        \n        auto check = [&](int x, vector<int> &v) {\n            vector<int> dp(x + 1);\n            dp[0] = 1;\n            for (int i: v) {\n                for (int j = x; j >= 0; j--) {\n                    if (dp[j] && j + i <= x) {\n                        dp[j + i] = 1;\n                    }\n                }\n            }\n            return dp[x];\n        };\n        \n        auto process = [&](int k) {\n            vector<vector<int>> b(n);\n            for (int i = 0; i < k; i++) {\n                int l = q[i][0], r = q[i][1], val = q[i][2];\n                for (int j = l; j <= r; j++) {\n                    b[j].push_back(val);\n                }\n            }\n            bool res = true;\n            for (int i = 0; i < n; i++) {\n                res &= check(a[i], b[i]);\n            }\n            return res;\n        };\n        \n        int l = 0, r = m, res = -1;\n        while (l <= r) {\n            int mid = (l + r) >> 1;\n            if (process(mid)) {\n                res = mid;\n                r = mid - 1;\n            }\n            else l = mid + 1;\n        }\n        return res;\n    }\n};","author":"Guddu Singh","submissionId":"1575159545"},[]]},{"365":[{"id":"365","fileName":"1575159079.txt","sourceCode":"#define ll long long\nclass Solution {\nprivate:\n    bool isZeroArray(const vector<int>& nums) {\n        return all_of(nums.begin(), nums.end(), [](int x) { return x == 0; });\n    }\n    int helper(vector<int> nums, vector<vector<int>> queries) {\n        ll n = nums.size();\n        ll m = queries.size();\n\n        if (isZeroArray(nums))\n            return 0;\n\n        const ll MAX_SUM = 1100;\n\n        auto isPossible = [&](ll k) -> bool {\n            for (ll i = 0; i < n; i++) {\n                ll target = nums[i];\n                bitset<MAX_SUM> dp;\n                dp.reset();\n                dp.set(0, true);\n\n                for (ll j = 0; j < k; j++) {\n                    ll left = queries[j][0], right = queries[j][1],\n                        value = queries[j][2];\n                    if (left <= i && i <= right) {\n                        dp |= (dp << value);\n                    }\n                }\n                if (!dp.test(target))\n                    return false;\n            }\n            return true;\n        };\n\n        ll low = 0, high = m + 1, ans = -1;\n        while (low < high) {\n            ll mid = low + (high - low) / 2;\n            if (isPossible(mid)) {\n                ans = mid;\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return (int)ans;\n    }\n\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        return helper(nums, queries);\n    }\n};\n","author":"shubhhh_02","submissionId":"1575159079"},[]]},{"366":[{"id":"366","fileName":"1575159414.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n         int count=0;\n         int n=nums.length;\n         boolean isZero=true;\n        for(int a:nums){\n            if(a!=0) isZero=false;\n        }\n        if(isZero) return 0;\n         boolean dp[][]=new boolean[n][1001];\n         for(int i=0;i<n;i++) dp[i][0]=true;\n         for(int i=0;i<queries.length;i++){\n             int l=queries[i][0];\n             int h=queries[i][1];\n             int v=queries[i][2];\n             for(int j=l;j<=h;j++){\n                 for(int t=1000;t>=v;t--){\n                     dp[j][t]|=dp[j][t-v];\n                 }\n             }\n             boolean pos=true;\n             for(int j=0;j<n;j++){\n                 if(!dp[j][nums[j]]) pos=false;\n             }\n             if(pos) return i+1;\n         }\n        return -1;\n    }\n}","author":"user2134Ue","submissionId":"1575159414"},[]]},{"367":[{"id":"367","fileName":"1575159538.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<set<int>>s(n);\n        for (int i = 0 ; i < n ;i++) s[i].insert(0);\n        int x = 1;\n        int zeros = count(nums.begin(), nums.end(), 0);\n        if (zeros == n) { return 0; }\n        for (auto i : queries) {\n            int l = i[0], r = i[1], v = i[2];\n            for (int j = l ; j <= r ; j++) {\n                vector<int> temp;\n                for (auto k : s[j]) {\n                    \n                    temp.push_back(k + v);\n                }\n                for (auto k : temp) s[j].insert(k);\n            }\n            int vals = 0;\n            for (int k = 0 ; k < n ;k++) {\n                if (s[k].find(nums[k]) != s[k].end()) {\n                    vals++;\n                }\n            }\n            if (vals == n) {\n                return x;\n            }\n            x++;\n        }\n        return -1;\n    }\n};","author":"Swaroop vaze","submissionId":"1575159538"},[]]},{"368":[{"id":"368","fileName":"1575159380.txt","sourceCode":"class Solution {\npublic:\n    bool canSumToTarget(const vector<int>& nums, int target) {\n        // Create a dp array of size target + 1, initialized to false\n        vector<bool> dp(target + 1, false);\n    \n        // A sum of 0 is always achievable (using an empty subset)\n        dp[0] = true;\n    \n        // Iterate over each number in the array\n        for (int num : nums) {\n            // Traverse the dp array from right to left to avoid using the same number multiple times\n            for (int i = target; i >= num; --i) {\n                if (dp[i - num]) {\n                    dp[i] = true;\n                }\n            }\n        }\n    \n        // Return whether dp[target] is true (i.e., whether the target can be achieved)\n        return dp[target];\n    }\n\n    bool check(vector<int> &nums, vector<vector<int>> &op) {\n        bool ok = true;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            ok &= canSumToTarget(op[i], nums[i]);\n        }\n        return ok;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        auto &A = nums;\n        auto &Q = queries;\n        int n = nums.size();\n        int q = Q.size();\n\n        vector<vector<int>> options(n);\n        if (check(nums, options)) {\n            return 0;\n        }\n\n        int l = 0, r = q;\n        int ans = -1;\n        while (l <= r) {\n            int m = (l + r) / 2;\n            options.assign(n, {});\n            for (int i = 0; i < m; i++) {\n                for (int k = Q[i][0]; k <= Q[i][1]; k++) {\n                    options[k].push_back(Q[i][2]);\n                }\n            }\n            if (check(nums, options)) {\n                ans = m;\n                r = m - 1;\n            }\n            else {\n                l = m + 1;\n            }\n        }\n        return ans;\n        \n        for (int i = 0; i < q; i++) {\n            for (int k = Q[i][0]; k <= Q[i][1]; k++) {\n                options[k].push_back(Q[i][2]);\n            }\n            if (check(nums, options)) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"Anonymous","submissionId":"1575159380"},[]]},{"369":[{"id":"369","fileName":"1575159744.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        const int n = nums.size();\n        const int m = queries.size();\n        vector<int> res(n, -1);\n        for (int p = 0; p < n; ++p) {\n            int target = nums[p];\n            vector<int> cur(target + 1, 0);\n            cur[0] = 1;\n            for (int i = 0; i < m; ++i) {\n                int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n                if (p < l || p > r) continue;\n                for (int j = target - 1; j >= 0; --j) {\n                    if (cur[j] && j + v <= target) cur[j + v] = 1;\n                }\n                if (cur[target]) {\n                    res[p] = i;\n                    break;\n                }\n            }\n        }\n        \n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == 0) {\n                ans = max(ans, 0);\n                continue;\n            }\n            if (res[i] == -1) return -1;\n            ans = max(ans, res[i] + 1);\n        }\n        return ans;\n    }\n};","author":"jfantasy90","submissionId":"1575159744"},[]]},{"370":[{"id":"370","fileName":"1575159096.txt","sourceCode":"class Solution {\n    int traverse(int ind, int curSum, List <int[]> list, int mx, Integer[][] dp){\n        if(curSum == 0){\n            return mx;\n        }\n\n        if(curSum < 0 || ind >= list.size()){\n            return Integer.MAX_VALUE;\n        }\n        if(dp[ind][curSum] != null){\n            return dp[ind][curSum];\n        }\n\n        int pick = traverse(ind + 1, curSum - list.get(ind)[0], list, Math.max(mx, list.get(ind)[1]), dp);\n        int notPick = traverse(ind + 1, curSum, list, mx, dp);\n        dp[ind][curSum] = Math.min(pick, notPick);\n        return  Math.min(pick, notPick);\n    }\n    \n    int compute(int x, List<int[]> list) {\n        int n = list.size();\n        Integer[][] dp = new Integer[n][x + 10];\n        return traverse(0, x, list, 0, dp);\n    }\n\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        List<int[]>[] list = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            list[i] = new ArrayList();\n        }\n\n        for (int i = 0; i < queries.length; i++) {\n            int l = queries[i][0], r = queries[i][1], x = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                list[j].add(new int[] { x, i + 1 });\n            }\n        }\n\n        int mx = 0, valid = 0;\n        for (int i = 0; i < n; i++) {\n            if(nums[i] == 0){\n                valid++;\n                continue;\n            }\n            int x = compute(nums[i], list[i]);\n            if (x != Integer.MAX_VALUE){\n                mx = Math.max(x, mx); \n                valid++;\n            }\n        }\n\n        return valid < nums.length ? -1 : mx;\n    }\n}","author":"Sri Akshya","submissionId":"1575159096"},[]]},{"371":[{"id":"371","fileName":"1575159771.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        const int n = int(nums.size());\n        const int q = int(queries.size());\n\n        bitset<1000 + 5> dp;\n        \n        auto check = [&](int middle) -> bool {\n            vector<vector<int>> adi(n);\n            for(int i = 0; i <= middle; i++) {\n                int l = queries[i][0];\n                int r = queries[i][1];\n                int val = queries[i][2];\n\n                for(int j = l; j <= r; j++) {\n                    adi[j].emplace_back(val);\n                }\n            }\n\n            bool ok = true;\n            for(int i = 0; i < n; i++) {\n                dp.reset();\n                dp[0] = 1;\n\n                if(dp[nums[i]]) {\n                    continue;\n                }\n                \n                bool found = false;\n                for(auto& x: adi[i]) {\n                    dp |= (dp << x);\n                    \n                    if(dp[nums[i]]) {\n                        found = true;\n                        break;\n                    }\n                }\n                ok &= found;\n            }\n            \n            return ok;\n        };\n        \n        int left = -2; // always bad\n        int right = q; // always good\n        while(left + 1 < right) {\n            int middle = (left + right) >> 1;\n            \n            if(check(middle)) right = middle;\n            else left = middle;\n        }\n\n        if(right == q) return -1;\n        else return right + 1;\n    }\n};","author":"dhuamanilu","submissionId":"1575159771"},[]]},{"372":[{"id":"372","fileName":"1575160345.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if not nums or sum(nums) == 0:\n            return 0\n\n        m, n = len(queries), len(nums)\n\n        def can_form(ops, target):\n            # print((ops, target))\n            dp = [False] * (target + 1)\n            dp[0] = True\n            for i in range(10):\n                op_count = ops[i]\n                op = i+1\n                for _ in range(op_count):\n                    for j in range(target, op-1, -1):\n                        dp[j] = dp[j] | dp[j-op]\n\n            # print(dp)\n            return dp[target]\n                \n\n        def to_zero(k):\n            # print(\"k==\", k)\n            # print(\"n==\", n)\n            memo = [[0] * 10 for _ in range(n+1)]\n            for i in range(k):\n                l, r, val = queries[i]\n                # print(\" queries[i]==\",  queries[i])\n                memo[l][val-1] += 1\n                memo[r+1][val-1] -= 1\n\n            ops = [0] * 10\n            for i in range(n):\n                x = nums[i]\n                for y in range(10):\n                    ops[y] += memo[i][y]\n                if x == 0:\n                    continue\n                # print(\"i==\", i)\n                if not can_form(ops, x):\n                    return False\n            \n            return True\n\n        if not to_zero(m):\n            return -1\n\n        l, r = 0, m\n        while l<r:\n            mid = l + (r-l)//2\n            if to_zero(mid):\n                r = mid\n            else:\n                l = mid+1\n\n        return r\n                ","author":"DietCoke","submissionId":"1575160345"},[]]},{"373":[{"id":"373","fileName":"1575160254.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n=len(nums)\n        q=len(queries)\n\n        inf=int(1e9)\n        ans=-1\n        def f(arr, val):\n            for i in range(len(arr)-1, -1, -1):\n                if arr[i]==1 and i+val < len(arr):\n                    arr[i+val] = 1\n                    \n        for i in range(n):\n            # find how many queries before this nums[i] can be zero\n            vis=[0] * 1001\n            vis[0]=1\n            if nums[i]==0:\n                here = 0\n            else:\n                here=-1\n                for j, (l, r, v) in enumerate(queries):\n                    if l<=i<=r:\n                        # add vis to the shift of itself\n                        # print('f', vis[:10], v)\n                        f(vis, v)\n                        if vis[nums[i]] == 1:\n                            here=max(here, j)  # we suceed on jth query\n                            break\n                # print('processing', i)\n                # print(vis[:10])\n                # print(here)\n                if here==-1:\n                    # cannot\n                    return -1\n                here += 1\n            ans = max(ans, here)\n        return ans\n            \n                \n                        \n                        \n                    \n                \n            ","author":"eatfood","submissionId":"1575160254"},[]]},{"374":[{"id":"374","fileName":"1575160820.txt","sourceCode":"class Solution {\npublic:\n    bool check(int mid, vector<int>& nums, vector<vector<int>>& queries){\n        for(int i = 0; i < nums.size(); i++){\n            vector<int> v;\n            for(int j = 0; j < mid && j < queries.size(); j++){\n                if(queries[j][0] <= i && queries[j][1] >= i){\n                    v.push_back(queries[j][2]);\n                }\n            }\n            vector<bool> dp(nums[i]+1);\n            dp[0] = true;\n            for(int j = 0; j < v.size(); j++){\n                for(int k = nums[i]-v[j]; k >= 0; k--){\n                    if(dp[k]){\n                        dp[k+v[j]] = true;\n                    }\n                }\n            }\n            if(!dp[nums[i]]) return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l = 0, r = queries.size();\n        while(l <= r){\n            int mid = (l+r)/2;\n            if(check(mid, nums, queries)){\n                r = mid-1;\n            }\n            else{\n                l = mid+1;\n            }\n        }\n        if(l == queries.size()+1){\n            return -1;\n        }\n        return l;\n    }\n};","author":"HerbertTheBird","submissionId":"1575160820"},[]]},{"375":[{"id":"375","fileName":"1575160464.txt","sourceCode":"class Solution {\n    fun minZeroArray(nums: IntArray, queries: Array<IntArray>): Int {\n        var maxK = 0\n        for (j in nums.indices) {\n            val target = nums[j]\n            if (target == 0) {\n                continue\n            }\n\n            val jQueries = mutableListOf<Pair<Int, Int>>()\n            for (i in queries.indices) {\n                val query = queries[i]\n                val l = query[0]\n                val r = query[1]\n                val v = query[2]\n                if (j in l..r) {\n                    jQueries.add(i to v)\n                }\n            }\n\n            if (jQueries.isEmpty()) {\n                return -1\n            }\n\n            jQueries.sortBy { it.first }\n\n            val dp = mutableMapOf<Int, Int>()\n            dp[0] = -1\n\n            for ((i, v) in jQueries) {\n                val newDp = mutableMapOf<Int, Int>()\n                for ((sum, currentMax) in dp) {\n                    if (sum !in newDp || currentMax < newDp[sum]!!) {\n                        newDp[sum] = currentMax\n                    }\n\n                    val newSum = sum + v\n                    if (newSum > target) {\n                        continue\n                    }\n\n                    val newMax = maxOf(currentMax, i)\n                    if (newSum !in newDp || newMax < newDp.getOrDefault(newSum, Int.MAX_VALUE)) {\n                        newDp[newSum] = newMax\n                    }\n                }\n                dp.clear()\n                dp.putAll(newDp)\n            }\n\n            if (target !in dp) {\n                return -1\n            }\n\n            val earliestMaxIndex = dp[target]!!\n            val earliestKJ = earliestMaxIndex + 1\n            maxK = maxOf(maxK, earliestKJ)\n        }\n\n        return maxK\n    }\n}","author":"jayle99","submissionId":"1575160464"},[]]},{"376":[{"id":"376","fileName":"1575161219.txt","sourceCode":"class Solution {\n    public  boolean isSubsetSum(List<Integer> arr, int sum) {\n        int n = arr.size();\n        boolean[][] dp = new boolean[n + 1][sum + 1];\n        for (int i = 0; i <= n; i++) {\n            dp[i][0] = true;\n        }\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= sum; j++) {\n                if (j < arr.get(i - 1)) {\n                    dp[i][j] = dp[i - 1][j];\n                }\n                else {\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - arr.get(i - 1)];\n                }\n            }\n        }\n        return dp[n][sum];\n    }\n    public boolean isZeroArray(int[] nums, int n,int k,int[][] queries) {\n        List<Integer>[] arr=new ArrayList[n];\n        for(int i=0;i<n;i++) arr[i]=new ArrayList<>();\n        for(int i=0;i<=k;i++){\n            int[] q=queries[i];\n            int x=q[0];\n            int y=q[1];\n            int z=q[2];\n            for(int j=x;j<=Math.min(n-1,y);j++){\n                arr[j].add(z);\n            }\n        }\n        int sum=0;\n        for(int i=0;i<n;i++){\n            int val=nums[i];\n            if(!isSubsetSum(arr[i],val)) return false;\n        }\n        return true;\n    }\n    public boolean isZero(int[] arr){\n        for(int val:arr){\n            if(val!=0) return false;\n        }\n        return true;\n    }\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n=nums.length;\n        if(isZero(nums)) return 0;\n        int m=queries.length;\n        int ans=-1;\n        int low=0;\n        int high=m-1;\n        while(low<=high){\n            int mid=(low+high)/2;\n            if(isZeroArray(nums,n,mid,queries)){\n                ans=mid+1;\n                high=mid-1;\n            }else low=mid+1;\n        }\n        return ans;\n\n    }\n}","author":"storm_wanderer","submissionId":"1575161219"},[]]},{"377":[{"id":"377","fileName":"1575161007.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n=a.size(),m=q.size();\n        int ans=0;\n        for(int i=0;i<n;i++){\n            int lo=0,hi=m,bsans=m+1;\n            while(hi>=lo){\n                int mid=lo+(hi-lo)/2;\n                vector<int> op;\n                for(int j=0;j<mid;j++){\n                    op.push_back((q[j][0]<=i && q[j][1]>=i ? q[j][2]:0));\n                }\n                vector<vector<int>> dp(mid+1,vector<int>(a[i]+1,-1));\n                auto func=[&](int j,int val,auto &&func)->bool{\n                    if(j==mid)return val==0;\n                    if(dp[j][val]!=-1)return dp[j][val];\n                    bool ok=false;\n                    if(val>=op[j]){\n                        ok = func(j+1, val - op[j], func) || func(j+1, val, func);\n                    }else{ok=(ok || func(j+1,val,func));}\n                    return dp[j][val]=ok;\n                };\n                if(func(0,a[i],func)){\n                    bsans=mid;\n                    hi=mid-1;\n                }else lo=mid+1;\n            }\n            ans=max(ans,bsans);\n        }\n        return (ans==m+1?-1:ans);\n    }\n};","author":"vedantgore_2004","submissionId":"1575161007"},[]]},{"378":[{"id":"378","fileName":"1575160614.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        l ,r = 0,len(queries)\n\n        def good(x: int, p: List[int]):\n            if x == 0:\n                return True\n            f = [0] * (x + 1)\n            f[0] = 1\n            z = []\n            for y in range(1, 11):\n                z += [y] * p[y]\n            # print(x, p, z)\n            for y in z:\n                for i in range(x, -1, -1):\n                    if f[i] > 0 and i + y <= x:\n                        f[i + y] = 1\n                        if f[x] > 0:\n                            return True\n            return False\n        \n        def ok(x):\n            d = [[0 for _ in range(11)] for _ in range(len(nums) + 1)]\n            for i in range(x):\n                a, b, v = queries[i]\n                d[a][v] += 1\n                d[b+1][v] -= 1\n            p = [0] * 11\n            for i in range(len(nums)):\n                for j in range(11):\n                    p[j] += d[i][j]\n                if not good(nums[i], p):\n                    return False\n            return True\n        \n        if not ok(r):\n            return -1\n        if ok(l):\n            return 0\n        while l + 1 < r:\n            mid = (l+r) // 2\n            if ok(mid):\n                r = mid\n            else:\n                l = mid\n        return r","author":"Thinkingface","submissionId":"1575160614"},[]]},{"379":[{"id":"379","fileName":"1575160968.txt","sourceCode":"class Solution {\n    public:\n        int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n            int n = nums.size();\n            vector<vector<pair<int, int>>> changes(n);\n            for (int j = 0; j < queries.size(); j++) {\n                auto& query = queries[j];\n                for (int i = query[0]; i <= query[1]; ++i) {\n                    changes[i].push_back({query[2], j + 1});\n                }\n            }\n            int res = 0;\n            bitset<1001> dp;\n            for (int i = 0; i < n; i++) {\n                dp.reset();\n                dp[0] = 1;\n                int k = 0, m = changes[i].size();\n                while (!dp[nums[i]] && k < m) {\n                    res = max(res, changes[i][k].second);\n                    dp |= (dp << changes[i][k++].first);\n                }\n                if (!dp[nums[i]]) {\n                    return -1;\n                }\n            }\n            return res;\n        }\n    };","author":"tsigave","submissionId":"1575160968"},[]]},{"380":[{"id":"380","fileName":"1575161341.txt","sourceCode":"class Solution {\npublic:\n    int dp[1010][1010];\n    int solve(int j, int num, int i, vector<vector<int>>& queries){\n        if(i == queries.size()){\n            return 1010;\n        }\n        if(dp[i][num] != -1) return dp[i][num];\n\n        int ans = solve(j, num, i+1, queries);\n        if(j >= queries[i][0] && j <= queries[i][1] && num >= queries[i][2]){\n            if(num == queries[i][2]){\n                ans = i;\n            }else{\n                ans = min(ans, solve(j, num-queries[i][2], i+1, queries));\n            }\n        }\n\n        return dp[i][num] = ans;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n\n        int cnt = 0;\n        for(int i=0; i<n; i++){\n            if(nums[i] == 0) cnt++;\n        }\n\n        if(cnt == n) return 0;\n\n        vector<int> ans(n, 0);\n        for(int j=0; j<n; j++){\n            if(nums[j] == 0) continue;\n            memset(dp, -1, sizeof(dp));\n            ans[j] = solve(j, nums[j], 0, queries);\n        }\n\n        int mx = *max_element(ans.begin(), ans.end());\n        if(mx == 1010){\n            return -1;\n        }\n\n        return mx+1;\n    }\n};","author":"Pramod Biradar","submissionId":"1575161341"},[]]},{"381":[{"id":"381","fileName":"1575161445.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int ans = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int num = nums[i];\n            int min = getMin(queries, num, i);\n            if (min == -1) {\n                return -1;\n            }\n            ans = Math.max(ans, min);\n        }\n        return ans;\n    }\n\n    private int getMin(int[][] queries, int num, int idx) {\n        if (num == 0) {\n            return 0;\n        }\n        int m = queries.length;\n        boolean[][] dp = new boolean[m + 1][num + 1];\n        dp[0][0] = true;\n        for (int i = 1; i <= m; i++) {\n            int l = queries[i - 1][0];\n            int r = queries[i - 1][1];\n            int v = queries[i - 1][2];\n            for (int j = 0; j <= num; j++) {\n                dp[i][j] = dp[i - 1][j];\n                if (idx < l || idx > r) {\n                    continue;\n                }\n                if (j >= v) {\n                    dp[i][j] |= dp[i - 1][j - v];\n                }\n            }\n            if (dp[i][num]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}","author":"cc4414","submissionId":"1575161445"},[]]},{"382":[{"id":"382","fileName":"1575161642.txt","sourceCode":"\nvector<int> arr;\nvector<vector<int>> q;\n\n\nbool subsetSum(vector<int>& arr, int target) {\n    // for (int x : arr) cout << x << \",\"; cout << endl;\n    // cout << target << endl;\n\n    vector<bool> seen(target + 1);\n\n    seen[0] = true;\n\n    // target * arr.size() ??\n    for (int x : arr) {\n        auto nex = seen;\n\n        for (int i = 0; i <= target; ++i) {\n            if (seen[i] and i + x <= target) {\n                nex[i + x] = true;\n            }\n        }\n\n        seen = nex;\n\n    }\n\n\n    return seen[target];\n\n}\n\n\nbool can(int k) {\n    // cout << \"can \" << k << endl;\n    int n = arr.size();\n    vector<vector<int>> vals(n);\n\n    // need to check time complexity here as well..\n    // k <= qn .. q * n ??\n    for (int i = 0; i <= k; ++i) {\n        int l = q[i][0];\n        int r = q[i][1];\n        int v = q[i][2];\n\n        for (int j = l; j <= r; ++j) {\n            vals[j].push_back(v);\n        }\n    }\n\n\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] == 0) continue;\n        bool ans = subsetSum(vals[i], arr[i]);\n        if (not ans) return false;\n    }\n    // cout << \"true for \" << k << endl;\n    return true;\n}\n\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\n        arr = nums;\n        q = queries;\n\n        bool nonZero = false;\n\n        for(int x: arr) if (x) nonZero = true;\n\n        if (not nonZero) return 0;\n\n\n        int ans = -1;\n        int qn = queries.size();\n        for (int step = qn; step > 0; step /= 2) {\n            while (step + ans < qn and not can(ans + step)) {\n                ans += step;\n            }\n        }\n\n        if (ans == qn - 1) return -1;\n        return ans + 2;\n\n    }\n};\n\n","author":"Ashish Singh","submissionId":"1575161642"},[]]},{"383":[{"id":"383","fileName":"1575161453.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        q = len(queries)\n\n        ans = 0\n        for i in range(n):\n            curr = nums[i]\n            if curr == 0:\n                continue #no action necessary\n\n            earliest = -1\n            valqueues = [[0] for i in range(11)]\n            seen = [False] * (curr + 1)\n            seen[0] = True\n            \n            for k in range(q):\n                l, r, v = queries[k]\n                if i < l or i > r:\n                    continue\n\n                old = valqueues[v]\n                valqueues[v] = []\n                for op in old:\n                    newop = op + v\n                    if newop > curr or seen[newop]:\n                        continue\n\n                    seen[newop] = True\n                    if newop == curr:\n                        earliest = k + 1\n                        break\n                    for l in range(1, 11):\n                        valqueues[l].append(newop)\n\n            if earliest == -1: return -1 #could not find a combo\n            ans = max(ans, earliest)\n\n        return ans","author":"Andrew H. Pometta","submissionId":"1575161453"},[]]},{"384":[{"id":"384","fileName":"1575161137.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int q = queries.size(), n = nums.size(), MX = 1000;\n        int dp[1001][10][1001];\n        // dp[q + 1][n][MX + 1];\n        for (int i = 0; i <= q; i++){\n            for (int j = 0; j < n; j++){\n                for (int k = 0; k <= MX; k++) dp[i][j][k] = 0;\n            }\n        }\n        for (int i = 0; i < n; i++) dp[0][i][nums[i]] = 1;\n\n        for (int i = 1; i <= q; i++){\n            int valid = 1;\n            for (int j = 0; j < n; j++) valid &= dp[i - 1][j][0];\n            if (valid) return i - 1;\n\n            int l = queries[i - 1][0], r = queries[i - 1][1], val = queries[i - 1][2];\n            for (int j = 0; j < n; j++){\n                for (int k = 0; k <= MX; k++) dp[i][j][k] |= dp[i - 1][j][k];\n            }\n            for (int j = l; j <= r; j++){\n                for (int k = val; k <= MX; k++){\n                    dp[i][j][k - val] |= dp[i][j][k];\n                }\n            }\n            if (i == q){\n                valid = 1;\n                for (int j = 0; j < n; j++) valid &= dp[i][j][0];\n                if (valid) return i;\n            }\n        }\n        return -1;\n    }\n};","author":"Win Chang","submissionId":"1575161137"},[]]},{"385":[{"id":"385","fileName":"1575161296.txt","sourceCode":"/*\n===============================================================================\n                             COMPETITIVE PROGRAMMING TEMPLATE\n-------------------------------------------------------------------------------\nLanguage    : C++\nOnline Handles:\n    - LeetCode   : Nixon2006\n    - Codeforces : Nixon2006\n    - CodeChef   : Nixon2006\n    - AtCoder    : Nixon2006\n===============================================================================\n*/\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\ninline namespace GlobalDefs {\n\n   // ==============================  T Y P E S  =============================================\n    typedef long long ll;\n    typedef unsigned long long ull;\n    typedef long double ld;\n    typedef uint64_t ul;\n    template<typename T> using v1d = std::vector<T>;\n    template<typename T> using v2d = std::vector<v1d<T>>;\n    template<typename T> using v3d = std::vector<v2d<T>>;\n    template<typename T> using v4d = std::vector<v3d<T>>;\n    template<typename T> using v5d = std::vector<v4d<T>>;\n    template <typename T> using us = std::unordered_set<T>;\n    template <typename Key, typename Value> using um = std::unordered_map<Key, Value>;\n    template <typename T1, typename T2> using p = std::pair<T1, T2>;\n    template <typename Key, typename Value> using mm = std::multimap<Key, Value>; \n    template <typename T> using ms = std::multiset<T>; \n    template <typename Key, typename Value> using umm = std::unordered_multimap<Key, Value>; \n    template <typename T> using ums = std::unordered_multiset<T>;\n    typedef vector<int>::iterator vit;\n    typedef pair<int, int> pii;\n    typedef pair<ll, ll> pll;\n    typedef set<int> si;\n    typedef set<ll> sll;\n    typedef map<ll, ll> mll;\n    typedef unordered_map<ll, ll> umll;\n    template <typename T> using adjList = v2d<T>; // Adjacency list \n    template <typename T> using w_adjList = v2d<v1d<T>>; // Weighted adjacency list \n    template <typename T> using adjMatrix = v2d<T>; // Adjacency matrix\n    // using big = __int128;\n    template <typename T> using minheap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n    template <typename T> using maxheap = std::priority_queue<T>;\n\n    // ===================  P O L I C Y   B A S E D   D A T A   S T R U C T U R E  ==============================\n    // Functionalities:\n    // - find_by_order(i) : Finds the element at index `i`.\n    // - order_of_key(k)  : Gives the index of element `k` if it were to be inserted.\n    template <typename Key, typename Value> using oma = tree<Key, Value, less<Key>, rb_tree_tag, tree_order_statistics_node_update>;\n    template <typename Key, typename Value> using oma_ = tree<Key, Value, less_equal<Key>, rb_tree_tag, tree_order_statistics_node_update>;\n    template <typename Key, typename Value> using omd = tree<Key, Value, greater<Key>, rb_tree_tag, tree_order_statistics_node_update>;\n    template <typename Key, typename Value> using omd_ = tree<Key, Value, greater_equal<Key>, rb_tree_tag, tree_order_statistics_node_update>;\n    template <typename Key> using osa = tree<Key, null_type, less<Key>, rb_tree_tag, tree_order_statistics_node_update>;\n    template <typename Key> using osa_ = tree<Key, null_type, less_equal<Key>, rb_tree_tag, tree_order_statistics_node_update>;\n    template <typename Key> using osd = tree<Key, null_type, greater<Key>, rb_tree_tag, tree_order_statistics_node_update>;\n    template <typename Key> using osd_ = tree<Key, null_type, greater_equal<Key>, rb_tree_tag, tree_order_statistics_node_update>;\n\n    // =====================  M A C R O S  =====================================\n    #define ff first\n    #define ss second\n    #define all(a) (a).begin(), (a).end()\n    #define rall(a) (a).rbegin(), (a).rend()\n    #define eb emplace_back\n    #define pf push_front\n    #define ppf pop_front\n    #define pb push_back\n    #define ppb pop_back\n    // #define endl 'n'\n    #define sp <<\" \"<<\n    #define test int tc; cin >> tc; while(tc--)\n    #define iterate(it,a) for (auto &(it) : (a))\n    #define revIterate(it, a) for (auto (it) = (a).rbegin(); (it) != (a).rend(); ++(it))\n    #define rep(i,low,high,delta) for (auto i = (low); i < (high); i+=delta)\n    #define revRep(i,high,low,delta) for(auto i = (high); i > (low); i+= delta)\n    #define op() ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n    #define fraction(a) cout.unsetf(ios::floatfield); cout.precision(a); cout.setf(ios::fixed, ios::floatfield);\n    #define gcd(a, b) (__gcd(a, b))\n    #define lcm(a, b) ((a/gcd(a, b))* b)\n    #define sz(x) ((int)(x.size()))\n    #define mxe(v) (*max_element(all(v)))\n    #define mne(v) (*min_element(all(v)))\n    #define len(s) ((int)(s.length()))\n    #define SUM(v) (accumulate(all(v), 0LL))\n    #define XOR(v) (accumulate(all(v), 0LL, bit_xor<long long>()))\n    #define OR(v) (accumulate(all(v), 0LL, bit_or<long long>()))\n    #define AND(v) (accumulate(all(v), ~0LL, bit_and<long long>()))\n    #define PRODUCT(v) (accumulate(all(v), 1LL, [](long long a, long long b){return (a * b) % MOD; }))\n    #define GCD(v) (accumulate(all(v), v[0], [](long long a, long long b) {return gcd(a, b);}))\n    #define LCM(v) (accumulate(all(v), 1LL, [](long long a, long long b) {return ((a /gcd(a, b)) % MOD) * (b % MOD) % MOD;}))\n    #define srt(v) sort(all(v))\n    #define srt_comp(v,comp) sort(all(v),comp)\n    #define srt_lr(v,l,r) sort(v.begin()+l,v.begin()+r+1)\n    #define srt_comp_lr(v,l,r,comp) sort(v.begin()+l,v.begin()+r+1, comp)\n    #define rsrt(v) sort(all(v),greater<int>())\n    #define rev(v) reverse(all(v))\n    #define rev_lr(v,l,r) reverse(v.begin()+l,v.begin()+r+1)\n    #define substring(s, l, r) ((s).substr((l), (r) - (l) + 1))\n    #define order order_of_key\n    #define elemAt find_by_order\n    #define sqr(a) ((a)*(a))\n    #define cube(a) ((a)*(a)*(a)) \n    #define ter(cond, a, b) ((cond) ? (a) : (b))\n    #define toIndex(it,v) ((int)((it)-((v).begin())))\n    #define ubIndex(key,v) toIndex(ubv(v,key),v)\n    #define lbIndex(key,v) toIndex(lbv(v,key),v)\n    #define reqrem(a,b) (((b)-((a)%(b)))%(b))\n    #define divides(a,b) (!((b)%(a)))\n    #define mp make_pair\n    #define mt make_tuple\n    #define debug(x) cout << #x << \" : \"; _print(x); cout << endl;\n    #define debug_(...) cout << #__VA_ARGS__ << \" : \" << endl; _print_debug(__VA_ARGS__);\n    #define lambda(return_type, function_name, ...) \n        auto function_name = [&](__VA_ARGS__) -> return_type\n    #define lambdaRec(return_type, function_name, ...) \n        auto function_name = [&](auto&& self, __VA_ARGS__) -> return_type\n    #define lexcomp lexicographical_compare\n\n    // ========================= C O N S T A N T S ========================================\n    constexpr ll MOD = 1e9 + 7;\n    constexpr ll MOD2 = 998244353;\n    constexpr double PI = 3.14159265358979323846;\n    const double eps = 1e-9;\n    ll N = 1e6 + 5;  \n    const ll inf = LLONG_MAX, neginf = LLONG_MIN;\n    const ul M1 = 982451653,M2 = 961748927,M3 = 999999937,M4 = 879531629,M5 = 961748941,P1 = 29,P2 = 31,P3 = 37,P4 = 41, P5 =  43;\n    // USE THE FOLLOWING VALUES ONLY WHEN IT'S THE LAST OPTION, AS IT'S SLOW , BUT FASTER COMPARED TO A DOUBLE HASH.\n    // ALSO DON'T FORGET TO UNCOMMENT \"big\" FROM MACROS.\n    // REPLACE \"ul\" WITH \"big\" in the hash struct, OTHERWISE IT WILL EITHER OVERFLOW OR GIVE WRONG ANSWER .\n    ul M6 = 9999999967, M7 = 99999999977, M8 = 999999999989, M9 = 9999999999971, M10 = 2305843009213693951;\n    ul P6 = 47, P7 = 53, P8 = 59 , P9 = 61, P10 = 67;\n    string toDigit = \"0123456789\",toAlpha = \"abcdefghijklmnopqrstuvwxyz\",toAlpha_ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int dr4[] = {-1, 0, 1, 0}; \n    int dc4[] = {0, 1, 0, -1}; \n    string code4[] = {\"N\", \"E\", \"S\", \"W\"}; \n    int dr8[] = {-1, -1, 0, 1, 1, 1, 0, -1}; \n    int dc8[] = {0, 1, 1, 1, 0, -1, -1, -1}; \n    string code8[] = {\"N\", \"NE\", \"E\", \"SE\", \"S\", \"SW\", \"W\", \"NW\"}; \n    int dr6[] = {-1, -1, 0, 1, 1, 0}; \n    int dc6[] = {0, 1, 1, 0, -1, -1};  \n    string code6[] = {\"N\", \"NE\", \"SE\", \"S\", \"SW\", \"NW\"};\n    // Knights movement in chess\n    int drK[] = {-2, -1, 1, 2, 2, 1, -1, -2};\n    int dcK[] = {1, 2, 2, 1, -1, -2, -2, -1}; \n    int dr_diag[] = {-1, -1, 1, 1};        \n    int dc_diag[] = {-1, 1, 1, -1};       \n    string code_diag[] = {\"NW\", \"NE\", \"SE\", \"SW\"}; // Diagonal directions\n    // ========================= P R E C O M P U T E D  V A L U E S =========================\n    constexpr double LOG2 = 0.6931471805599453;   \n    constexpr double LOG10 = 2.302585092994046; \n    constexpr double E = 2.718281828459045;      \n    constexpr ll factorial[21] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800, 87178291200, 1307674368000, 20922789888000, 355687428096000, 6402373705728000, 121645100408832000, 2432902008176640000}; \n    ll fib[93] = {\n    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, \n    2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, \n    317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, \n    14930352, 24157817, 39088169, 63245986, 102334155, 165580141, \n    267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, \n    4807526976, 7778742049, 12586269025, 20365011074, 32951280099, \n    53316291173, 86267571272, 139583862445, 225851433717, 365435296162, \n    591286729879, 956722026041, 1548008755920, 2504730781961, 4052739537881, \n    6557470319842, 10610209857723, 17167680177565, 27777890035288, \n    44945570212853, 72723460248141, 117669030460994, 190392490709135, \n    308061521170129, 498454011879264, 806515533049393, 1304969544928657, \n    2111485077978050, 3416454622906707, 5527939700884757, 8944394323791464, \n    14472334024676221, 23416728348467685, 37889062373143906, 61305790721611591, \n    99194853094755497, 160500643816367088, 259695496911122585, \n    420196140727489673, 679891637638612258, 1100087778366101931, \n    1779979416004714189, 2880067194370816120, 4660046610375530309, \n    7540113804746346429\n    };\n}\nnamespace cp_starter{\n    // =============================== G E N E R A L  F U N C T I O N S =======================\n    inline ll ceildiv(ll a,ll b){ return a/b+(a%b>0);}\n    inline ll floordiv(ll a,ll b){ return a/b-(a%b<0);}\n    template <typename T>vector<T> init1d(size_t size, T defaultValue) {return vector<T>(size, defaultValue);}\n    template <typename T>vector<vector<T>> init2d(size_t size1, size_t size2, T defaultValue) {return vector<vector<T>>(size1, vector<T>(size2, defaultValue));}\n    template <typename T>vector<vector<vector<T>>> init3d(size_t size1, size_t size2, size_t size3, T defaultValue) {return vector<vector<vector<T>>>(size1, vector<vector<T>>(size2, vector<T>(size3, defaultValue)));}\n    template <typename T> vector<vector<vector<vector<T>>>> init4d(size_t size1, size_t size2, size_t size3, size_t size4, T defaultValue) {return vector<vector<vector<vector<T>>>>(size1, vector<vector<vector<T>>>(size2, vector<vector<T>>(size3, vector<T>(size4, defaultValue))));}\n    template <typename T> vector<vector<vector<vector<vector<T>>>>> init5d(size_t size1, size_t size2, size_t size3, size_t size4, size_t size5, T defaultValue) {return vector<vector<vector<vector<vector<T>>>>>(size1, vector<vector<vector<vector<T>>>>(size2, vector<vector<vector<T>>>(size3, vector<vector<T>>(size4, vector<T>(size5, defaultValue)))));}\n    template <typename T> map<T, long long> frequency_map(const std::vector<T>& vec) {map<T, long long> freq;for (const auto& elem : vec) {++freq[elem];}return freq;}\n    template <typename T> bool present(const std::vector<T>& container, const T& key) {for (const auto& item : container) {if (item == key) return true;} return false;}\n    bool present(const std::string& container, char key) {for (const auto& ch : container) {if (ch == key) return true;}return false;}\n    template <typename Container, typename Key> bool present(const Container& container, const Key& key) {return container.find(key) != container.end();}\n    template <typename T> vector<T> subarray(const std::vector<T>& v, size_t l, size_t r) {if (l > r || r >= v.size()) return {};return std::vector<T>(v.begin() + l, v.begin() + r + 1);} \n    template <typename Container, typename Key>auto ub(const Container& container, const Key& key) -> typename Container::const_iterator {return container.upper_bound(key);}\n    template <typename Container, typename Key> auto lb(const Container& container, const Key& key) -> typename Container::const_iterator {return container.lower_bound(key);}\n    template <typename T> typename std::vector<T>::const_iterator ubv(const std::vector<T>& vec, const T& value) {return std::upper_bound(vec.begin(), vec.end(), value);}\n    template <typename T> typename std::vector<T>::const_iterator lbv(const std::vector<T>& vec, const T& value) {return std::lower_bound(vec.begin(), vec.end(), value);}\n    template <typename T> auto getFirst(const T& container) -> decltype(*container.begin()) { return *container.begin();}\n    template <typename T> auto getLast(const T& container) -> decltype(*container.rbegin()) { return *container.rbegin();}\n    template <typename T> void removeFirst(T& container) { if (!container.empty()) {container.erase(container.begin());}}\n    template <typename T> void removeLast(T& container) { if (!container.empty()) { container.erase(std::prev(container.end())); }}\n    template <typename T, typename Key> void remove(T& container, const Key& key) {if ((container.find(key)) != container.end()) {container.erase((container.find(key)));}}\n    template <typename T, typename Key> void removeAll(T& container, const Key& key) {container.erase(key);  }\n    template <typename T> inline void reset1d(vector<T>& v, const T& k) {fill(v.begin(), v.end(), k);}\n    template <typename T> inline void reset2d(vector<vector<T>>& v, const T& k) { for (auto& row : v) { fill(row.begin(), row.end(), k); } }\n    template <typename Container, typename T> inline bool bs(const Container& container, const T& target) {return std::binary_search(container.begin(), container.end(), target);}\n    template<typename T>inline void compress(vector<T>& v) {sort(v.begin(), v.end());v.erase(unique(v.begin(), v.end()), v.end());}\n    template <typename T, typename Condition> bool all_of_vector(const vector<T> &arr, Condition cond) { return all_of(arr.begin(), arr.end(), cond); }\n    template <typename T, typename Condition> bool any_of_vector(const vector<T> &arr, Condition cond) { return any_of(arr.begin(), arr.end(), cond); }\n    template <typename T> vector<T> flatten(const vector<vector<T>> &arr) {vector<T> flat;for (const auto &sublist : arr) flat.insert(flat.end(), sublist.begin(), sublist.end());return flat;}\n    template <typename Func, typename T> vector<long long> prefix_op(const vector<T> &v, Func operation, long long init) { vector<long long> prefix(v.size() + 1, init); for (size_t i = 0; i < v.size(); ++i) prefix[i + 1] = operation(prefix[i], v[i]); return prefix; }\n    template <typename T> inline vector<long long> prefix_sum(const vector<T> &v) { return prefix_op(v, plus<long long>(), 0); }\n    template <typename T> inline vector<long long> prefix_gcd(const vector<T> &v) { return prefix_op(v, gcd<long long, long long>, 0); }\n    template <typename T> inline vector<long long> prefix_min(const vector<T> &v) { return prefix_op(v, [](long long a, long long b) { return min(a, b); }, LLONG_MAX); }\n    template <typename T> inline vector<long long> prefix_max(const vector<T> &v) { return prefix_op(v, [](long long a, long long b) { return max(a, b); }, LLONG_MIN); }\n    template <typename T> inline vector<long long> prefix_xor(const vector<T> &v) { return prefix_op(v, bit_xor<long long>(), 0); }\n    template <typename T> inline vector<long long> prefix_and(const vector<T> &v) { return prefix_op(v, bit_and<long long>(), ~0); }\n    template <typename T> inline vector<long long> prefix_or(const vector<T> &v) { return prefix_op(v, bit_or<long long>(), 0); }\n    template <typename T> inline vector<long long> prefix_lcm(const vector<T> &v) { return prefix_op(v, [](long long a, long long b) { return lcm(a, b); }, 1); }\n    template <typename T> inline vector<long long> prefix_product(const vector<T> &v) { return prefix_op(v, multiplies<long long>(), 1); }\n    inline bool starts_with(const string &s, const string &prefix) { return s.rfind(prefix, 0) == 0; }\n    inline bool ends_with(const string &s, const string &suffix) { return s.size() >= suffix.size() && s.compare(s.size() - suffix.size(), suffix.size(), suffix) == 0; }\n    inline bool is_numeric(const string &s) { return !s.empty() && all_of(s.begin(), s.end(), ::isdigit); }\n    vector<string> split(const string &s, const string &delimiter = \" \") {\n        vector<string> tokens; size_t start = 0, end;\n        while ((end = s.find(delimiter, start)) != string::npos) { tokens.push_back(s.substr(start, end - start)); start = end + delimiter.length(); }\n        tokens.push_back(s.substr(start));\n        return tokens;\n    }\n    string join(const vector<string> &tokens, const string &delimiter = \" \") {string result; for (size_t i = 0; i < tokens.size(); i++) { result += tokens[i]; if (i < tokens.size() - 1) result += delimiter; } return result;}\n    string strip(const string &s) {\n        size_t start = s.find_first_not_of(\" tnrfv\");\n        if (start == string::npos) return \"\";\n        size_t end = s.find_last_not_of(\" tnrfv\");\n        return s.substr(start, end - start + 1);\n    }\n    string lstrip(const string &s, char ch) {size_t start = 0; while (start < s.length() && s[start] == ch) ++start; return s.substr(start);}\n    string rstrip(const string &s, char ch) {size_t end = s.length(); while (end > 0 && s[end - 1] == ch) --end; return s.substr(0, end);}\n    size_t count(const string &s, const string &substring) {\n        size_t count = 0, pos = 0;\n        while ((pos = s.find(substring, pos)) != string::npos) { ++count; pos += substring.length(); }\n        return count;\n    }\n    string replace_all(const string &s, const string &from, const string &to) {\n        string result; size_t pos = 0, start = 0;\n        while ((pos = s.find(from, start)) != string::npos) { result += s.substr(start, pos - start) + to; start = pos + from.length(); }\n        result += s.substr(start);\n        return result;\n    }\n    string to_lower(string s) { transform(s.begin(), s.end(), s.begin(), ::tolower); return s; }\n    string to_upper(string s) { transform(s.begin(), s.end(), s.begin(), ::toupper); return s; }\n    int find(const string &s, const string substring) {size_t pos = s.find(substring); return pos == string::npos ? s.length() : static_cast<int>(pos);}\n    int rfind(const string &s, const string sub) {size_t pos = s.rfind(sub); return pos == string::npos ? -1 : static_cast<int>(pos);}\n    template <typename T> int find(const std::vector<T>& vec, const T& value) {auto it = std::find(vec.begin(), vec.end(), value);return it != vec.end() ? static_cast<int>(std::distance(vec.begin(), it)) : vec.size();}\n    template <typename T> int rfind(const std::vector<T>& vec, const T& value) {auto it = std::find_end(vec.begin(), vec.end(), &value, &value + 1);return it != vec.end() ? static_cast<int>(std::distance(vec.begin(), it)) : -1;}\n    template <typename T> bool isPalindrome(const std::vector<T>& vec) {\n        size_t left = 0, right = vec.size() - 1;\n        while (left < right) {\n            if (vec[left] != vec[right]) {\n                return false;\n            }\n            ++left;\n            --right;\n        }\n        return true;\n    }\n    bool isPalindrome(const std::string& str) {\n        size_t left = 0, right = str.size() - 1;\n        while (left < right) {\n            if (str[left] != str[right]) {\n                return false;\n            }\n            ++left;\n            --right;\n        }\n        return true;\n    }\n    template <typename T> void countingSort(vector<T> &arr) {\n        if (arr.empty()) return;\n        T minVal = *min_element(arr.begin(), arr.end());\n        T maxVal = *max_element(arr.begin(), arr.end());\n        T range = maxVal - minVal + 1;\n        vector<T> count(range, 0);\n        for (T num : arr) {\n            count[num - minVal]++;\n        }\n        int index = 0;\n        for (T i = 0; i < range; ++i) {\n            while (count[i] > 0) {\n                arr[index++] = i + minVal;\n                count[i]--;\n            }\n        }\n    }\n    // Next Greater Element (Strict)\n    template <typename T>\n    std::vector<int> nge_strict(const std::vector<T>& arr) {\n        size_t n = arr.size();\n        std::vector<int> nge(n, n);  // Default to n if no greater element is found\n        std::stack<int> st;\n        for (size_t i = n; i-- > 0;) {  // Iterate from the back\n            while (!st.empty() && arr[st.top()] <= arr[i]) st.pop();  // Pop elements that are less than or equal to current\n            if (!st.empty()) nge[i] = st.top();  // Assign the index of the next greater element\n            st.push(i);  // Push the current index onto the stack\n        }\n        return nge;\n    }\n    // Next Greater Element (Loose)\n    template <typename T>\n    std::vector<int> nge_loose(const std::vector<T>& arr) {\n        size_t n = arr.size();\n        std::vector<int> nge(n, n);  // Default to n if no greater/equal element is found\n        std::stack<int> st;\n        for (size_t i = n; i-- > 0;) {  // Iterate from the back\n            while (!st.empty() && arr[st.top()] < arr[i]) st.pop();  // Pop elements that are less than the current\n            if (!st.empty()) nge[i] = st.top();  // Assign the index of the next greater element\n            st.push(i);  // Push the current index onto the stack\n        }\n        return nge;\n    }\n    // Next Smaller Element (Strict)\n    template <typename T>\n    std::vector<int> nse_strict(const std::vector<T>& arr) {\n        size_t n = arr.size();\n        std::vector<int> nse(n, n);  // Default to n if no smaller element is found\n        std::stack<int> st;\n        for (size_t i = n; i-- > 0;) {  // Iterate from the back\n            while (!st.empty() && arr[st.top()] >= arr[i]) st.pop();  // Pop elements that are greater than or equal to current\n            if (!st.empty()) nse[i] = st.top();  // Assign the index of the next smaller element\n            st.push(i);  // Push the current index onto the stack\n        }\n        return nse;\n    }\n    // Next Smaller Element (Loose)\n    template <typename T>\n    std::vector<int> nse_loose(const std::vector<T>& arr) {\n        size_t n = arr.size();\n        std::vector<int> nse(n, n);  // Default to n if no smaller/equal element is found\n        std::stack<int> st;\n        for (size_t i = n; i-- > 0;) {  // Iterate from the back\n            while (!st.empty() && arr[st.top()] > arr[i]) st.pop();  // Pop elements that are greater than current\n            if (!st.empty()) nse[i] = st.top();  // Assign the index of the next smaller element\n            st.push(i);  // Push the current index onto the stack\n        }\n        return nse;\n    }\n    // Previous Greater Element (Strict)\n    template <typename T>\n    std::vector<int> pge_strict(const std::vector<T>& arr) {\n        size_t n = arr.size();\n        std::vector<int> pge(n, -1);  // Default to -1 if no greater element is found\n        std::stack<int> st;\n        for (size_t i = 0; i < n; ++i) {  // Iterate from the front\n            while (!st.empty() && arr[st.top()] <= arr[i]) st.pop();  // Pop elements that are less than or equal to current\n            if (!st.empty()) pge[i] = st.top();  // Assign the index of the previous greater element\n            st.push(i);  // Push the current index onto the stack\n        }\n        return pge;\n    }\n    // Previous Greater Element (Loose)\n    template <typename T>\n    std::vector<int> pge_loose(const std::vector<T>& arr) {\n        size_t n = arr.size();\n        std::vector<int> pge(n, -1);  // Default to -1 if no greater/equal element is found\n        std::stack<int> st;\n        for (size_t i = 0; i < n; ++i) {  // Iterate from the front\n            while (!st.empty() && arr[st.top()] < arr[i]) st.pop();  // Pop elements that are less than the current\n            if (!st.empty()) pge[i] = st.top();  // Assign the index of the previous greater element\n            st.push(i);  // Push the current index onto the stack\n        }\n        return pge;\n    }\n    // Previous Smaller Element (Strict)\n    template <typename T>\n    std::vector<int> pse_strict(const std::vector<T>& arr) {\n        size_t n = arr.size();\n        std::vector<int> pse(n, -1);  // Default to -1 if no smaller element is found\n        std::stack<int> st;\n        for (size_t i = 0; i < n; ++i) {  // Iterate from the front\n            while (!st.empty() && arr[st.top()] >= arr[i]) st.pop();  // Pop elements that are greater than or equal to current\n            if (!st.empty()) pse[i] = st.top();  // Assign the index of the previous smaller element\n            st.push(i);  // Push the current index onto the stack\n        }\n        return pse;\n    }\n    // Previous Smaller Element (Loose)\n    template <typename T>\n    std::vector<int> pse_loose(const std::vector<T>& arr) {\n        size_t n = arr.size();\n        std::vector<int> pse(n, -1);  // Default to -1 if no smaller/equal element is found\n        std::stack<int> st;\n        for (size_t i = 0; i < n; ++i) {  // Iterate from the front\n            while (!st.empty() && arr[st.top()] > arr[i]) st.pop();  // Pop elements that are greater than current\n            if (!st.empty()) pse[i] = st.top();  // Assign the index of the previous smaller element\n            st.push(i);  // Push the current index onto the stack\n        }\n        return pse;\n    }\n    bool validCell(int i, int j, int n, int m) { return ((i>=0 and i<n) and (j>=0 and j<m)); }\n    template <typename T> long long countInversions(vector<T>& arr) {\n        osa_<T> os; \n        long long inversions = 0;\n        for (int i = arr.size() - 1; i >= 0; --i) {\n            inversions += os.order_of_key(arr[i]);\n            os.insert(arr[i]);\n        }\n        return inversions;\n    }\n    class MEXSet {\n    private:\n        map<int, int> freq; \n        set<int> missing;   \n    public:\n        MEXSet() {missing.insert(0);}\n        void add(int x) {\n            freq[x]++;\n            missing.erase(x); \n            if (!freq.count(x + 1)) missing.insert(x + 1);\n        }\n        void remove(int x) {\n            if (freq[x] > 0) {\n                freq[x]--;\n                if (freq[x] == 0) {\n                    freq.erase(x);\n                    missing.insert(x);\n                }\n            }\n        }\n        void removeAll(int x) {\n            if (freq.count(x)) { \n                freq.erase(x); \n                missing.insert(x); \n            }\n        }\n        int getMEX() {return *missing.begin(); }\n    };\n    adjList<ll> make_adjList(int n, vector<vector<int>>&edges, bool oneBased = false, bool directed = false)\n    {\n        int m = edges.size();\n        adjList<ll> adj(n);\n        for(int i=0;i<m;i++)\n        {\n            int u = edges[i][0], v = edges[i][1];\n            u -= oneBased, v -= oneBased;\n            adj[u].push_back(v);\n            if(not directed) adj[v].push_back(u);\n        }\n        return adj;\n    }\n    w_adjList<ll> make_w_adjList(int n,vector<vector<int>>&edges,bool oneBased = false, bool directed = false)\n    {\n        int m = edges.size();\n        w_adjList<ll> adj(n);\n        for(int i=0;i<m;i++)\n        {\n            int u = edges[i][0], v = edges[i][1], w = edges[i][2];\n            u -= oneBased, v -= oneBased;\n            adj[u].push_back({v,w});\n            if(not directed) adj[v].push_back({u,w});\n        }\n        return adj;\n    }\n    template<typename T> vector<int> topoSort(vector<T>&adj, bool weighted=false)\n    {\n        int n = adj.size();\n        vector<int> res;\n        vector<bool> vis(n,false);\n        auto dfs = [&](auto &&self, int i)->void{\n            vis[i] = true;\n            for(auto &it:adj[i])\n            {\n                int adjNode = weighted ? it[0] : it;\n                if(!vis[adjNode]) self(self,adjNode);\n            }\n            res.push_back(i);\n        };\n        for(int i=0;i<n;i++)\n        {\n            if(vis[i]) continue;\n            dfs(dfs,i);\n        }\n        reverse(res.begin(),res.end());\n        return res;\n    }\n\n    // ===================  Y E S   O R   N O  ======================================== \n    inline void yes(bool b) { if(b) cout << \"YESn\"; else cout<<\"yesn\"; }\n    inline void no(bool b) {  if(b) cout << \"NOn\";  else cout<<\"non\";  }\n \n    // ============================ D E B U G G I N G ==========================================================\n    void _print(ll t) { cout << t; }\n    void _print(int t) { cout << t; }\n    void _print(string t) { cout << t; }\n    void _print(char t) { cout << t; }\n    void _print(ld t) { cout << t; }\n    void _print(double t) { cout << t; }\n    void _print(ull t) { cout << t; }\n    template <class T, class V> void _print(pair<T, V> p) { cout << \"{\"; _print(p.ff); cout << \",\"; _print(p.ss); cout << \"}\"; }\n    template <class T> void _print(vector<T> v) { cout << \"[ \"; for (T i : v) {_print(i); cout << \" \";} cout << \"]\"; }\n    template <class T> void _print(set<T> v) { cout << \"[ \"; for (T i : v) {_print(i); cout << \" \";} cout << \"]\"; }\n    template <class T> void _print(multiset<T> v) { cout << \"[ \"; for (T i : v) {_print(i); cout << \" \";} cout << \"]\"; }\n    template <class T, class V> void _print(map<T, V> v) { cout << \"[ \"; for (auto i : v) {_print(i); cout << \" \";} cout << \"]\"; }\n    template <class T> void _print(unordered_set<T> v) { cout << \"[ \"; for (T i : v) {_print(i); cout << \" \";} cout << \"]\"; }\n    template <class T, class V> void _print(unordered_map<T, V> v) { cout << \"[ \"; for (auto i : v) {_print(i); cout << \" \";} cout << \"]\"; }\n    template <class T> void _print(deque<T> v) { cout << \"[ \"; for (T i : v) {_print(i); cout << \" \";} cout << \"]\"; }\n    template <class T> void _print(list<T> v) { cout << \"[ \"; for (T i : v) {_print(i); cout << \" \";} cout << \"]\"; }\n    template <class T> void _print(stack<T> s) { cout << \"[ \"; stack<T> temp = s; while (!temp.empty()) {_print(temp.top()); cout << \" \"; temp.pop();} cout << \"]\"; }\n    template <class T> void _print(queue<T> q) { cout << \"[ \"; queue<T> temp = q; while (!temp.empty()) {_print(temp.front()); cout << \" \"; temp.pop();} cout << \"]\"; }\n    template <class T> void _print(priority_queue<T> pq) { cout << \"[ \"; priority_queue<T> temp = pq; while (!temp.empty()) {_print(temp.top()); cout << \" \"; temp.pop();} cout << \"]\"; }\n    inline void loopBreak() { cout<<endl<<\"------------------ L O O P  B R E A K -----------------\"<<endl; }\n    inline void lineBreak() { cout<<endl<<endl<<\"============  L I N E  B R E A K  ============\"<<endl<<endl; }\n    inline void tcBreak() { cout<<endl<<endl<<endl<<\"-x-x-x-x-x-x-x-x-x- T C  B R E A K -x-x-x-x-x-x-x-\"<<endl<<endl<<endl; }\n    template <typename T>\n    void _print_debug(const T& t) {\n        _print(t);\n        cout << endl;\n    }\n    template <typename T, typename... Args>\n    void _print_debug(const T& t, const Args&... args) {\n        _print(t);\n        cout << endl;\n        _print_debug(args...);\n    }\n    // ============================ I N P U T S ====================================\n    template <typename T> void input_single(T& var) { cin >> var; }\n    template <> void input_single(string& var) { cin>>var ; }\n    template <typename... Args> auto input() { auto vars = make_tuple(Args()...); apply([](auto&... args) { ((cin >> args), ...); }, vars); return vars; }\n    template <typename T> vector<T> input1d(size_t size) { vector<T> vec(size); for (size_t i = 0; i < size; ++i) input_single(vec[i]); return vec; }\n    template <typename T> vector<vector<T>> input2d(size_t n, size_t m) { vector<vector<T>> vec(n, vector<T>(m)); for (size_t i = 0; i < n; ++i) for (size_t j = 0; j < m; ++j) input_single(vec[i][j]); return vec; }\n    template <typename T> vector<vector<vector<T>>> input3d(size_t x, size_t y, size_t z) { vector<vector<vector<T>>> vec(x, vector<vector<T>>(y, vector<T>(z))); for (size_t i = 0; i < x; ++i) for (size_t j = 0; j < y; ++j) for (size_t k = 0; k < z; ++k) input_single(vec[i][j][k]); return vec; }\n}\nusing namespace cp_starter;\nnamespace cp_bitManipulation {\n    // ======================== B I T  M A N I P U L A T I O N  ======================================\n    inline int popcount(ll x) { return __builtin_popcountll(x); }\n    inline int lowbit(ll x) { return (x == 0 ? -1 : __builtin_ctzll(x)); }\n    inline bool isPowerOfTwo(ll x) { return x && (!(x & (x - 1))); }\n    inline int highbit(ll x) { return x == 0 ? -1 : (63 - __builtin_clzll(x)); }\n    // Get all bits between lowest and highest set bits inclusive\n    inline ll bitMask(ll x) { if (x == 0) return 0;return (1LL << (highbit(x) + 1)) - (1LL << lowbit(x));}\n    // Get length of number in bits (length of binary representation)\n    inline bool isSubMask(ll n, ll check) { return (n | check) == n; }\n    inline int bitLength(ll x) { return x ? highbit(x) + 1 : 0; }\n    // Check if all bits in a number are contiguous\n    inline bool isContiguous(ll x) { return (x & bitMask(x)) == bitMask(x); }\n    // Count the number of set bits in a range\n    inline int countBitsInRange(ll x, int left, int right) {return __builtin_popcountll((x >> left) & ((1LL << (right - left + 1)) - 1));}\n    // Get the next higher number with the same number of 1-bits\n    inline ll nextHigherSameOnes(ll n) {\n        ll c = n & -n;\n        ll r = n + c;\n        return (((n ^ r) / c) >> 2) | r;\n    }\n    // Get the previous smaller number with the same number of 1-bits\n    inline ll prevLowerSameOnes(ll n) {\n        if((n&(n+1)) == 0) return n;\n        if(!(n&1) and ((n>>1)&1)) return n-1;\n        ll k = 1, temp = n;\n        while(temp)\n        {\n            if((n&(1<<k)) and !(n&(1<<(k-1))))\n                break;\n            k++;\n            temp = temp>>1;\n        }\n        ll p = 1LL<<(k-1);\n        ll c = __builtin_popcount(n&(p-1));\n        ll x = n-p;\n        return (x&(~(p-1)))|(p - (1LL<<(k-1-c)));\n    }\n    inline ll setBit(ll x, int i) {\n        return x | (1LL << i);\n    }\n    inline ll clearBit(ll x, int i) {\n        return x & ~(1LL << i);\n    }\n    inline ll toggleBit(ll x, int i) {\n        return x ^ (1LL << i);\n    }\n    inline bool getBit(ll x, int i) {\n        return (x >> i) & 1;\n    }\n    inline int lowUnsetBit(ll x) {\n        return __builtin_ctzll(~x);\n    }\n    // Reverse the bits of a number\n    inline ll reverseBits(ll x) {\n        ll res = 0;\n        while (x > 0) {\n            res = (res << 1) | (x & 1);\n            x >>= 1;\n        }\n        return res;\n    }\n    inline ll negateBits(ll x) {\n        // Find the bit length of the number\n        int len = bitLength(x);\n        // Create a mask with 'len' bits set to 1\n        ll mask = (1LL << len) - 1;  // This gives a mask with all bits up to MSB set to 1\n        // XOR x with the mask to flip the bits\n        return x ^ mask;\n    }\n    inline ll xorTill(ll n){\n        if(n % 4 == 1) return 1; \n        else if(n % 4 == 2) return n + 1; \n        else if(n % 4 == 3) return 0; \n        else return n; \n    }\n    inline ll rangeXor(ll L, ll R) {\n        ll xorTillL = xorTill(L - 1);\n        ll xorTillR = xorTill(R);\n        return xorTillL ^ xorTillR;\n    }\n    vector<ll> setBitCount(ll n) {\n        vector<ll> res(64, 0);\n        if(n <= 0) return res;\n        ll p0 = 1, p1 = 2;\n        ll i = 0;\n        while(i<63) {\n            res[i] = ((n + 1) / p1) * p0 + max(0LL, (n + 1) % p1 - p0);\n            p0 = p1, p1 *= 2;\n            i++;\n        }\n        return res;\n    }\n    ll rangeAnd(ll L, ll R) {\n        vector<ll> tillL = setBitCount(L - 1);\n        vector<ll> tillR = setBitCount(R);\n        ll ans = 0;\n        for(ll i = 0; i < 64; i++) if(tillR[i] - tillL[i] == (R - L + 1)) ans |= (1LL << i);\n        return ans;\n    }\n    ll rangeOr(ll L, ll R) {\n        vector<ll> tillL = setBitCount(L - 1);\n        vector<ll> tillR = setBitCount(R);\n        ll ans = 0;\n        for(ll i = 0; i < 64; i++) if(tillR[i] - tillL[i]) ans |= (1LL << i);\n        return ans;\n    }\n    \n    // =====================================  E N D  ==========================================================\n}\nusing namespace cp_bitManipulation;\nnamespace cp_maths{\n\n    //=================== P O I N T  A N D  S L O P E ====================\n    /*\n        does not handle the case for two same points, that is \n        for x1=x2 and y1=y2.\n    */\n    struct slope{\n        int sign;\n        ll n,d;\n        slope(ll x1,ll y1, ll x2, ll y2)\n        {\n            ll n = abs(y2-y1), d = abs(x2-x1), g = gcd(n,d);\n            auto signFinder = [](ll a, ll b){\n                if(!a or !b) return 1;\n                else if(a<0 and b<0) return 1;\n                else if(a>0 and b>0) return 1;\n                return -1;\n            };\n            int sign = signFinder(y2-y1,x2-x1);\n            this->sign = sign;\n            this->n = d==0 ? 1 : n/g;\n            this->d = n==0 ? 1 : d/g;\n        }\n        bool operator==(slope&other) \n        { return (sign==other.sign and n==other.n and d==other.d); }\n    };\n    struct Point {\n        long long x, y;\n        // Constructor to initialize point with x and y coordinates\n        Point(long long x, long long y) { this->x = x; this->y = y; }\n        // Manhattan Distance (sum of absolute differences of x and y)\n        inline long long manhattan(Point& a) const { return abs(a.x - x) + abs(a.y - y); }\n        // Squared Euclidean Distance (avoids floating-point precision issues)\n        inline long long euclid_sqr(Point& a) const { return (a.x - x) * (a.x - x) + (a.y - y) * (a.y - y); }\n        // Overloading the '+' operator to add two points\n        inline Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n        // Overloading the '-' operator to subtract two points\n        inline Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n        // Overloading the '*' operator for scalar multiplication\n        inline Point operator*(long long scalar) const { return Point(x * scalar, y * scalar); }\n        // Overloading the '/' operator for scalar division\n        inline Point operator/(long long scalar) const { return Point(x / scalar, y / scalar); }\n        // Dot product of two points (treated as vectors)\n        inline long long dot(const Point& p) const { return x * p.x + y * p.y; }\n        // Cross product of two points (2D version)\n        inline long long cross(const Point& p) const { return x * p.y - y * p.x; }\n        // Equality comparison (==)\n        inline bool operator==(const Point& p) const { return x == p.x && y == p.y; }\n        // Inequality comparison (!=)\n        inline bool operator!=(const Point& p) const { return !(*this == p); }\n        // Print function for easy debugging and visualization\n        inline void debugPoint() const { cout << \"(\" << x << \", \" << y << \")\" << endl; }\n         // Pre-increment (increments x and y before returning the updated Point)\n        inline Point& operator++() { ++x; ++y; return *this;}\n        // Post-increment (returns current Point, then increments x and y)\n        inline Point operator++(int) { Point temp = *this; ++x; ++y; return temp;  }\n        // Pre-decrement (decrements x and y before returning the updated Point)\n        inline Point& operator--() { --x; --y; return *this; }\n        // Post-decrement (returns current Point, then decrements x and y)\n        inline Point operator--(int) { Point temp = *this; --x; --y; return temp; }\n    };\n    \n    //============================  M O D U L A R  I N T   ==============================================  \n       struct mi {\n        long long v;\n        static const int MOD = 1e9 + 7; \n        explicit operator int() const { return v; }\n        mi() : v(0) {}\n        mi(long long _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n        mi& operator+=(mi b) { if ((v += b.v) >= MOD) v -= MOD; return *this; }\n        mi& operator-=(mi b) { if ((v -= b.v) < 0) v += MOD; return *this; }\n        mi& operator*=(mi b) { v = (v * b.v) % MOD; return *this; }\n        mi& operator/=(mi b) { return *this *= b.inv(); }\n        mi operator-() const { return mi(-v); }\n        mi pow(long long p) const { \n            mi res = 1, a = *this; \n            while (p) { \n                if (p & 1) res *= a; \n                a *= a,p /= 2; \n            } \n            return res; \n        }\n        mi inv() const { return pow(MOD - 2); }\n        mi operator+(mi b) const { mi temp = *this; return temp += b; }\n        mi operator-(mi b) const { mi temp = *this; return temp -= b; }\n        mi operator*(mi b) const { mi temp = *this; return temp *= b; }\n        mi operator/(mi b) const { mi temp = *this; return temp /= b; }\n        bool operator!=(const mi& b) const { return v != b.v; }\n        bool operator==(const mi& b) const { return v == b.v; }\n        bool operator>(const mi& b) const { return v > b.v; }\n        bool operator<(const mi& b) const { return v < b.v; }\n        bool operator>=(const mi& b) const { return v >= b.v; }\n        bool operator<=(const mi& b) const { return v <= b.v; }\n        mi& operator+=(long long b) { return *this += mi(b); }\n        mi& operator-=(long long b) { return *this -= mi(b); }\n        mi& operator*=(long long b) { return *this *= mi(b); }\n        mi& operator/=(long long b) { return *this /= mi(b); }\n        mi operator+(long long b) const { return *this + mi(b); }\n        mi operator-(long long b) const { return *this - mi(b); }\n        mi operator*(long long b) const { return *this * mi(b); }\n        mi operator/(long long b) const { return *this / mi(b); }\n        bool operator==(long long b) const { return v == mi(b).v; }\n        bool operator!=(long long b) const { return v != mi(b).v; }\n        bool operator>(long long b) const { return v > mi(b).v; }\n        bool operator<(long long b) const { return v < mi(b).v; }\n        bool operator>=(long long b) const { return v >= mi(b).v; }\n        bool operator<=(long long b) const { return v <= mi(b).v; }\n    };\n    mi operator+(long long a, mi b) { return mi(a) + b; }\n    mi operator-(long long a, mi b) { return mi(a) - b; }\n    mi operator*(long long a, mi b) { return mi(a) * b; }\n    mi operator/(long long a, mi b) { return mi(a) / b; }\n    bool operator==(long long a, const mi& b) { return mi(a) == b; }\n    bool operator!=(long long a, const mi& b) { return mi(a) != b; }\n    bool operator>(long long a, const mi& b) { return mi(a) > b; }\n    bool operator<(long long a, const mi& b) { return mi(a) < b; }\n    bool operator>=(long long a, const mi& b) { return mi(a) >= b; }\n    bool operator<=(long long a, const mi& b) { return mi(a) <= b; }\n    std::istream& operator>>(std::istream& is, mi& m) {\n        long long x;\n        is >> x;\n        m = mi(x);\n        return is;\n    }\n    std::ostream& operator<<(std::ostream& os, const mi& m) {return os << m.v;}\n\n    // =====================================  E N D  ==========================================================\n    \n    // =========================  M O D U L A R   A R I T H E M A T I C  ===============================\n    inline ll safe_mod(ll a, ll m = MOD) { return ((a % m) + m) % m;}\n    inline ll mod_add(ll a, ll b, ll m = MOD) { return (a % m + b % m) % m; }\n    inline ll mod_sub(ll a, ll b, ll m = MOD) { return ((a % m - b % m) + m) % m; }\n    inline ll mod_mul(ll a, ll b, ll m = MOD) { return (a % m * b % m) % m; }\n    inline long long normalize(long long x, long long mod=MOD) { x %= mod; if (x < 0) x += mod; return x; }\n    ll mod_exp(ll base, ll exp, ll m = MOD) {\n        ll result = 1;\n        base %= m;\n        while (exp > 0) {\n            if (exp & 1) result = (result * base) % m;\n            base = (base * base) % m;\n            exp >>= 1;\n        }\n        return result;\n    }\n    inline ll mod_inv(ll a, ll m = MOD) { return mod_exp(a, m - 2, m); }\n    inline ll mod_div(ll a, ll b, ll m = MOD) { return mod_mul(a, mod_inv(b, m), m); }\n    \n    // =====================================  E N D  ==========================================================\n \n    // ================== M A T H E M A T I C S ===========================\n    // when not precomputed : \n    long long comb(int n, int r) {\n        if (r > n || r < 0) return 0;\n        long long num = 1, denom = 1;\n        for (int i = 0; i < r; ++i) {\n            num = (num * (n - i)) % MOD;   \n            denom = (denom * (i + 1)) % MOD; \n        }\n        return (num * mod_inv(denom, MOD)) % MOD; \n    }\n    long long perm(int n, int r) {\n        if (r > n || r < 0) return 0;\n        long long result = 1;\n        for (int i = 0; i < r; ++i) {\n            result = (result * (n - i)) % MOD;\n        }\n        return result;\n    }\n    // precomputations:\n    vector<ll> fact, inv_fact; \n    void init_factorials(ll m = MOD) {\n        fact = vector<ll>(N+1, 1);\n        inv_fact = vector<ll>(N+1, 1);\n        for (int i = 2; i <= N; i++) fact[i] = mod_mul(fact[i - 1], i, m);\n        inv_fact[N] = mod_inv(fact[N], m);\n        for (int i = N - 1; i >= 0; i--) inv_fact[i] = mod_mul(inv_fact[i + 1], i + 1, m);\n    }\n    vector<ll> logarithm;\n    void precompute_logarithm(int n)\n    {\n        logarithm = vector<ll>(n+1,0);\n        for(int i=2;i<=n;i++) logarithm[i] = logarithm[i/2] + 1;\n    }\n    // when precomputed : \n    inline ll nCr(ll n, ll r, ll m = MOD) {\n        if (r > n || r < 0) return 0;\n        return mod_mul(fact[n], mod_mul(inv_fact[r], inv_fact[n - r], m), m);\n    }\n    inline ll nPr(ll n, ll r, ll m = MOD) {\n        if (r > n || r < 0) return 0;\n        return mod_mul(fact[n], inv_fact[n - r], m);\n    }\n    // Lucas' theorem for calculating nCr mod p, where p is a small prime number (<=4000)\n    struct Lucas {\n        int p;\n        vector<vector<int>> pascal;\n        Lucas(int prime) : p(prime) {\n            pascal.assign(p, vector<int>());\n            for (int i = 0; i < p; i++) {\n                pascal[i].assign(i + 1, 0);\n                pascal[i][0] = 1;\n                pascal[i][i] = 1;\n                for (int j = 1; j < i; j++)\n                    pascal[i][j] = (pascal[i - 1][j - 1] + pascal[i - 1][j]) % p;\n            }\n        }\n        int nCr(long long n, long long r) {\n            if (r > n)\n                return 0;\n            int res = 1;\n            while (n || r) {\n                int n_digit = n % p;\n                int r_digit = r % p;\n                if (r_digit > n_digit)\n                    return 0;\n                res = (int)((1LL * res * pascal[n_digit][r_digit]) % p);\n                n /= p;\n                r /= p;\n            }\n            return res;\n        }\n    };\n    bool is_prime1(ll n) { \n        if (n <= 1) return false; \n        if (n <= 3) return true; \n        if (n % 2 == 0 || n % 3 == 0) return false; \n        for (ll i = 5; i * i <= n; i += 6) \n            if (n % i == 0 || n % (i + 2) == 0) return false; \n        return true; \n    }\n    bool is_prime2(ll n) {\n        if (n <= 1) return false;\n        if (n <= 3) return true;\n        if (n % 2 == 0 || n % 3 == 0) return false;\n    \n        ll d = n - 1;\n        ll r = 0;\n        while (d % 2 == 0) {\n            d /= 2;\n            r++;\n        }\n    \n        const ll K = 6; // Number of iterations (witnesses)\n        for (ll i = 0; i < K; i++) {\n            ll a = 2 + rand() % (n - 4); // Random number in [2, n-2]\n            ll x = mod_exp(a, d, n);\n            if (x == 1 || x == n - 1) continue;\n    \n            bool composite = true;\n            for (ll j = 0; j < r - 1; j++) {\n                x = mod_mul(x, x, n);\n                if (x == n - 1) {\n                    composite = false;\n                    break;\n                }\n            }\n            if (composite) return false;\n        }\n        return true;\n    }\n    vector<ll> maxPrimeFactor;\n    void precompute_max_prime_factor(ll n) {\n        maxPrimeFactor = vector<ll>(n + 1, 0);\n        for (int i = 2; i <= n; i++) {\n            if (maxPrimeFactor[i] == 0) { // i is prime\n                for (int j = i; j <= n; j += i) {\n                    maxPrimeFactor[j] = i; // Update to latest prime factor (i)\n                }\n            }\n        }\n    }\n     vector<ll> minFactor;\n     void precompute_min_prime_factor( ll n )\n     {\n        minFactor = vector<ll>(n + 1, 0);\n        for (int i = 2; i <= n; i++) minFactor[i] = i; \n        for (int i = 2; i * i <= n; i++) {\n            if (minFactor[i] == i) { // i is a prime\n                for (int j = i * i; j <= n; j += i) {\n                    minFactor[j] = min(minFactor[j], (ll)i); // Update with smallest prime factor\n                }\n            }\n        }\n     }\n    vector<pair<ll,ll>> fastPrimeFactorize(ll n)\n    {\n        vector<pair<ll,ll>> result;\n        while(n!=1)\n        {\n            if(result.empty() || result.back().first != minFactor[n]) result.push_back({minFactor[n], 1});\n            else result.back().second++;\n            n /= minFactor[n];\n        }\n        return result;\n    }\n    // Get prime factorization of a number\n    vector<pair<ll,ll>> primeFactorize(ll n) {\n        vector<pair<ll,ll>> factors;\n        for(ll i = 2; i * i <= n; i++) {\n            if(n % i == 0) {\n                ll cnt = 0;\n                while(n % i == 0) {\n                    cnt++;\n                    n /= i;\n                }\n                factors.push_back({i, cnt});\n            }\n        }\n        if(n > 1) factors.push_back({n, 1});\n        return factors;\n    }\n    long long sum_of_divisors(long long n) {\n        long long sum = 0;\n        for (long long i = 1; i * i <= n; i++) {\n            if (n % i == 0) {\n                sum += i; \n                if (i != n / i) {\n                    sum += n / i; \n                }\n            }\n        }\n        return sum;\n    }\n    // Euler totient function:\n    vector<ll> phi;\n    void compute_totient(ll SIEVE_MAX) {\n        phi = vector<ll>(SIEVE_MAX);\n        for (ll i = 0; i < SIEVE_MAX; i++) phi[i] = i;\n        for (ll i = 2; i < SIEVE_MAX; i++) {\n            if (phi[i] == i) { // i is a prime\n                for (ll j = i; j < SIEVE_MAX; j += i) {\n                    phi[j] *= (i - 1);\n                    phi[j] /= i;\n                }\n            }\n        }\n    }\n    struct GCD_type { long long x, y, d; };\n    // extended euclidean algorithm( to find solutions to ax + by = gcd(a,b) )\n    GCD_type ex_GCD(long long a, long long b)\n    {\n        if (b == 0) return {1, 0, a};\n        GCD_type pom = ex_GCD(b, a % b);\n        return {pom.y, pom.x - a / b * pom.y, pom.d};\n    }\n    \n    // linear diophantine equation (ax + by = c):\n    pair<ll,ll> linear_diophantine(ll a, ll b, ll c)\n    {\n        auto solution = ex_GCD(a,b);\n        ll x0 = solution.x, y0 = solution.y, g = solution.d;\n        if( c % g ) return {-1,-1};\n        return { x0*(c/g), y0*(c/g)};\n    } \n    \n    inline ll general_mod_inverse(ll a, ll M)\n    {\n        auto solution = ex_GCD(a,M);\n        if(solution.d != 1) return LLONG_MAX;\n        return ((solution.x % M) + M) % M;;\n    }\n    // chinese remainder theorem\n    pair<ll ,ll> crt(vector<pair<ll,ll>>&c)\n    {\n        ll t = c.size();\n        for(ll i = 0; i < t; i++) normalize(c[i].ff , c[i].ss);\n        long long ans = c[0].ff;\n        long long LCM = c[0].ss;\n        for(ll i = 1; i < t; i++)\n        {\n            // E X P L A N A T I O N:\n            /*  \n                let our merged congruence for the first i congruences be :\n                X ≡ ans mod LCM \n                X + LCM.Z1 = ans -> 1\n                current congruence (ith congruence):\n                X ≡ aᵢ mod mᵢ \n                X + mᵢ.Z2 = aᵢ -> 2\n                Substracting 1st equation from second : \n                Z2.mᵢ - Z1.LCM = aᵢ-ans\n                (-Z1).LCM + Z2.mᵢ = aᵢ-ans -> 3\n                let bezous coefficients for this equation be = (X1,Y1)\n                so , -Z1 = X1.((aᵢ-ans)/d), here d is the gcd(Z1,Z2)\n                so , Z1 = -X1.((aᵢ-ans)/d), here d is the gcd(Z1,Z2)\n                Putting the value of Z1 in 1st equation we get : \n                X = ans + (X1.((aᵢ-ans)/d))*LCM\n\n                So, our new congruence becomes: \n                X ≡ ( ans + (X1.((aᵢ-ans)/d))*LCM ) % ((mᵢ/d)*LCM) -> 4\n                \n                Lets prove a nice property of the modulo operator : \n                    ca mod cb = (c.(a mod b)) mod cb\n                PROOF : \n                    Let r = a mod b. By definition, this means there exists an integer q \n                    such that a = bq + r  with  0 ≤ r < b.\n                    Multiplying the entire equation by c gives:\n                        ca = c(bq + r) = (cb)q + cr.\n                    When dividing ca by cb, the term (cb)q is exactly divisible by cb, \n                    leaving a remainder of cr. Since 0 ≤ r < b  implies  0 ≤ cr < cb,\n                    cr is the unique remainder when ca is divided by cb. In other words,\n                    ca mod (cb) = cr = c(a mod b).\n                    Thus, we have proved that\n                        ca mod (cb) = (c(a mod b)) mod (cb).\n                    \n                Using this property in equation in equation 4:\n                X = (ans + LCM . ( (X1.((aᵢ-ans)/d)) % (mᵢ/d) ) ) % ((mᵢ/d)*LCM)\n                Thus we finally get our new congruence my merging the first i+1 congruences as:\n                X ≡ ( ans + LCM . ( (X1.((aᵢ-ans)/d)) % (mᵢ/d) ) ) mod ((mᵢ/d)*LCM)\n            */\n            auto pom = ex_GCD(LCM, c[i].ss);\n            ll x1 = pom.x;\n            ll d = pom.d;\n            if((c[i].ff - ans) % d != 0) return {LLONG_MAX,LLONG_MAX};\n            ans = normalize(ans + x1 * (c[i].ff - ans) / d % (c[i].ss / d) * LCM, LCM * c[i].ss / d);\n            LCM = lcm(LCM, c[i].ss); // you can save time by replacing above lcm * c[i].s /d by lcm = lcm * c[i].s / d\n        }\n        return {ans,LCM};\n    }\n    \n    //sieve of eratosthenes:\n    vector<bool> isPrime;\n    vector<ll> primes;\n    void sieve(ll n)\n    {\n        // Creating the sieve array\n        isPrime = vector<bool>(n + 1, true);\n        isPrime[0] = isPrime[1] = false; \n        for (ll i = 2; i * i <= n; i++)\n        {\n            if (isPrime[i])\n            {\n                for (ll j = i * i; j <= n; j += i)\n                    isPrime[j] = false; \n            }\n        }\n        //optional :\n    //    for (ll i = 2; i <= n; i++) {\n    //         if (is_prime[i]) {\n    //             primes.push_back(i);\n    //         }\n    //     }\n    }\n    vector<ll> divisors(ll n) {\n        vector<ll> divs;\n        for (ll i = 1; i * i <= n; i++) {\n            if (n % i == 0) {\n                divs.push_back(i);\n                if (i != n / i) divs.push_back(n / i);\n            }\n        }\n        sort(divs.begin(), divs.end());\n        return divs;\n    }\n    // ncr for all 0<=r<=n\n    // nCr (Combination): Used when order does not matter.\n    vector<long long> nCr_values;\n    vector<long long> compute_nCr(ll n) {\n       nCr_values = vector<long long>(n + 1, 1);  // nC0 is always 1\n        long long current_nCr = 1;  // Initialize with nC0 = 1\n        for (ll r = 1; r <= n; r++) {\n            current_nCr = current_nCr * (n - r + 1) % MOD;\n            // instead of modInverse(r, MOD), we can also use precomputed modinverse values\n            current_nCr = current_nCr * mod_inv(r, MOD) % MOD;\n            nCr_values[r] = current_nCr;\n        }\n        return nCr_values;\n    }\n    // npr for 0<=r<=n\n    // nPr (Permutation): Used when order matters.\n    vector<long long> nPr_values;\n    vector<long long> compute_nPr(ll n) {\n        nPr_values = vector<long long>(n + 1, 1);  // nP0 is always 1\n        long long current_nPr = 1;  // Initialize with nP0 = 1\n        for (ll r = 1; r <= n; r++) {\n            // Calculate nPr based on nPr = nPr-1 * (n - r + 1)\n            current_nPr = current_nPr * (n - r + 1) % MOD;\n            nPr_values[r] = current_nPr;\n        }\n        return nPr_values;\n    }\n    \n    inline ll rangeSum(ll a, ll b) { \n        ll x = a, y = b;\n        ll ans = ((y * (y + 1)) / 2)  - ((x * (x - 1)) / 2);\n        return ans;\n    }\n\n    ll power(ll a, ll b)\n    {\n        ll res = 1;\n        while (b > 0) {\n            ll bit = (b & 1);\n            if (bit) res = res * a;\n            a = a * a;\n            b = b >> 1;\n        }\n        return res;\n    }\n    // logb(x)\n    ll lg(ll x,ll b=2){\n        if(b==1) return -1; //Modify this as per need\n        if(b==2) return 63-__builtin_clzll(x); //O(1) for log2\n        ll p=1,ans=0;\n        while(true){\n            if(p>x) return ans-1;\n            if(p>LLONG_MAX/b) return ans;\n            p*=b,ans++;\n        }\n    }\n    \n    // n-th root: \n    ll mult(ll a,ll b){\n        if(b==0) return 0;\n        return a>inf/b?inf:a*b;\n    }\n    ll binpow(ll a,ll b){\n        ll res=1;\n        while(b){\n            if(b&1) res=mult(res,a);\n            a=mult(a,a),b>>=1; \n        }\n        return res;\n    }\n    ll nth_root(ll x,ll n){\n        if(x==1||n==1) return x;\n        if(x==inf) x--;    // Doesn't make a difference in answer, and check function fails for INF \n        ll l=0,r=x,m;\n        while(r-l>1){\n            m=l+(r-l)/2;\n            if(binpow(m,n)>x) r=m;\n            else l=m;\n        }\n        return l;\n    }\n\n    // higest power of x which is a factor of n:\n    ll maxDivisiblePower(ll x, ll n)\n    {\n        if(x==1) return inf;\n        ll res = 0;\n        while(not (n%x)) n/=x,res++;\n        return res;\n    } \n    \n    // =================================  E N D  ==============================================\n \n}\nusing namespace cp_maths;\nnamespace cp_hashing{\n    // =============================== H A S H I N G ==========================================\n    \n    //1) unordered : \n    template <typename T>\n    struct udh {\n        // Hash parameters\n        ll K1 = 37987, H1 = 79, M1 = 999999937;\n        ll K2 = 53887, H2 = 67, M2 = 370881107;\n        vector<ll> prefixh1, prefixh2;\n        ll n;\n        ll getCodeForString(char c) { return c - 'a' + 1; }\n        ll getCodeForVector(typename T::value_type x) { return x + 1; }\n        udh(const T &container) {\n            n = container.size();\n            prefixh1.resize(n + 1, 0);\n            prefixh2.resize(n + 1, 0);\n            for (ll i = 0; i < n; i++) {\n                ll code = is_same<T, string>::value ? \n                        getCodeForString(container[i]) : \n                        getCodeForVector(container[i]);\n                prefixh1[i + 1] = (prefixh1[i] + mod_exp(code + K1, H1, M1)) % M1;\n                prefixh2[i + 1] = (prefixh2[i] + mod_exp(code + K2, H2, M2)) % M2;\n            }\n        }\n        pair<ll, ll> subHash(ll l, ll r) {\n            return {\n                (prefixh1[r + 1] - prefixh1[l] + M1) % M1,\n                (prefixh2[r + 1] - prefixh2[l] + M2) % M2\n            };\n        }\n    };   \n    //2) ordered : \n    // common for both:\n    struct powers{\n        vector<ul> p;\n        ul P, M;\n        powers(ll n,ul P, ul M)\n        {\n            this->P = P, this->M = M;\n            p.resize(n+1,1);\n            for(ll i=1;i<=n;i++) p[i] = (p[i-1]*P)%M;\n        }\n        ul get(ll i) { return p[i]; }\n    };\n    // a) for strings : \n    struct SingleHash {\n        std::vector<ul> hash;\n        powers*p = NULL;\n        SingleHash(string&s,powers*p)\n        { \n            this->p = p;\n            buildHash(s);\n        }\n        void buildHash(const std::string& s) {\n            hash.resize(s.size() + 1, 0);\n            for(ll i = s.size()-1; i>=0; i--)\n            {\n                hash[i] = (hash[i+1]*(p->P) + (s[i]-'a'+1))%(p->M);\n            }\n        }\n        ul subHash(ll l, ll r) {\n            if(r<l) return 0;\n            ul result = (hash[l] - (hash[r+1]*(p->get(r-l+1)))%(p->M) + (p->M))%(p->M);\n            return result;\n        }\n    };\n    struct DoubleHash {\n        SingleHash *hash1, *hash2;\n        DoubleHash(powers*p1, powers*p2, string&s)\n        {\n            hash1 = new SingleHash(s,p1);\n            hash2 = new SingleHash(s,p2);\n        }\n        std::vector<ul> subHash(ll l, ll r) \n        { return { hash1->subHash(l,r), hash2->subHash(l,r) }; }\n    };\n    struct TripleHash {\n        SingleHash *hash1, *hash2, *hash3;\n        TripleHash(powers*p1, powers*p2, powers*p3, string&s)\n        {\n            hash1 = new SingleHash(s,p1);\n            hash2 = new SingleHash(s,p2);\n            hash3 = new SingleHash(s,p3);\n        }\n        std::vector<ul> subHash(ll l, ll r) \n        {\n            return { hash1->subHash(l,r), hash2->subHash(l,r), hash3->subHash(l,r) };\n        }\n    };\n    //b) for vectors:\n    struct SingleHashv {\n        std::vector<ul> hash;\n        powers* p = NULL;\n        template <typename T>\n        SingleHashv(std::vector<T>& v, powers* p) {\n            this->p = p;\n            buildHash(v);\n        }\n        template <typename T> void buildHash(const std::vector<T>& v) {\n            hash.resize(v.size() + 1, 0);\n            for (ll i = v.size() - 1; i >= 0; i--) {\n                hash[i] = (hash[i + 1] * (p->P) + (v[i] + 1)) % (p->M);\n            }\n        }\n        ul subHash(ll l, ll r) {\n            if (r < l) return 0;\n            ul result = (hash[l] - (hash[r + 1] * (p->get(r - l + 1))) % (p->M) + (p->M)) % (p->M);\n            return result;\n        }\n    };\n    struct DoubleHashv {\n        SingleHashv* hash1, * hash2;\n        template <typename T>\n        DoubleHashv(powers* p1, powers* p2, std::vector<T>& v) {\n            hash1 = new SingleHashv(v, p1);\n            hash2 = new SingleHashv(v, p2);\n        }\n        std::vector<ul> subHash(ll l, ll r) {\n            return { hash1->subHash(l, r), hash2->subHash(l, r) };\n        }\n    };\n    struct TripleHashv {\n        SingleHashv* hash1, * hash2, * hash3;\n        template <typename T>\n        TripleHashv(powers* p1, powers* p2, powers* p3, std::vector<T>& v) {\n            hash1 = new SingleHashv(v, p1);\n            hash2 = new SingleHashv(v, p2);\n            hash3 = new SingleHashv(v, p3);\n        }\n        std::vector<ul> subHash(ll l, ll r) {\n            return { hash1->subHash(l, r), hash2->subHash(l, r), hash3->subHash(l, r) };\n        }\n    };\n    // common for both : \n    template <typename HashType>\n    bool sameHash( HashType& a, HashType& b, ll l1, ll r1, ll l2, ll r2) {\n        if (r1 < l1 || r2 < l2) return false;\n        if ((r1 - l1) != (r2 - l2)) return false;\n        auto aHash = a.subHash(l1, r1);\n        auto bHash = b.subHash(l2, r2);\n        return aHash == bHash;\n    }\n    \n    // 3) murmur hash : \n    uint32_t murmurhash(const std::string& key, uint32_t seed = 23456789) {  // Default seed set to a more random non-sequential 8-digit prime\n        uint32_t len = key.length();\n        const uint8_t* data = reinterpret_cast<const uint8_t*>(key.c_str());\n        const int nblocks = len / 4;\n        uint32_t h1 = seed;\n        const uint32_t c1 = 0xcc9e2d51;\n        const uint32_t c2 = 0x1b873593;\n        const uint32_t* blocks = reinterpret_cast<const uint32_t*>(data);\n        for (int i = 0; i < nblocks; i++) {\n            uint32_t k1 = blocks[i];\n            k1 *= c1;\n            k1 = (k1 << 15) | (k1 >> (32 - 15));  // Left rotate by 15 bits\n            k1 *= c2;\n            h1 ^= k1;\n            h1 = (h1 << 13) | (h1 >> (32 - 13));  // Left rotate by 13 bits\n            h1 = h1 * 5 + 0xe6546b64;\n        }\n        const uint8_t* tail = reinterpret_cast<const uint8_t*>(data + nblocks * 4);\n        uint32_t k1 = 0;\n        switch (len & 3) {\n            case 3: k1 ^= tail[2] << 16;\n            case 2: k1 ^= tail[1] << 8;\n            case 1: k1 ^= tail[0];\n                    k1 *= c1;\n                    k1 = (k1 << 15) | (k1 >> (32 - 15));  // Left rotate by 15 bits\n                    k1 *= c2;\n                    h1 ^= k1;\n        }\n        h1 ^= len;\n        h1 ^= h1 >> 16;\n        h1 *= 0x85ebca6b;\n        h1 ^= h1 >> 13;\n        h1 *= 0xc2b2ae35;\n        h1 ^= h1 >> 16;\n        return h1;\n    }\n    \n    // =====================================  E N D  ==========================================================\n}\nusing namespace cp_hashing;\n\n// =======================  C O D E   F O R   T H E   P R O B L E M  ============================\n\n\n\n\nclass Solution {\n    public:\n        bool possible(vector<int>&nums, int val)\n        {\n            int n = sz(nums);\n            v2d<int> dp(n+1,v1d<int>(val+1,-1));\n            auto solve = [&](auto&&self,int i, int curr)->bool\n            {\n                if(i==n) return curr==0;\n                if(curr==0) return true;\n                if(dp[i][curr]!=-1) return dp[i][curr];\n                bool pick = false, notPick = false;\n                if(nums[i]<=curr) pick = self(self,i+1,curr-nums[i]);\n                notPick = self(self,i+1,curr);\n                return dp[i][curr] = pick or notPick;\n            };\n            return solve(solve,0,val);\n        }\n        int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n            int n = sz(nums), x = sz(q);\n            int s = -1, e = x-1, ans = x;\n            while(s<=e)\n            {\n                int m = s + (e-s)/2;\n                vector<vector<vector<int>>> diff(n+1);\n                rep(i,0,m+1,1) \n                    {\n                diff[q[i][0]].pb({q[i][2],1});\n                diff[q[i][1]+1].pb({q[i][2],-1});\n}\n\n                vector<vector<int>> changes(n);\n                multiset<int> st;\n                rep(i,0,n,1)\n                {\n                    iterate(it,diff[i])\n                    {\n                        if(it[1]==1) st.insert(it[0]); \n                        else remove(st,it[0]);\n                    }\n                    changes[i] = vector<int>(st.begin(),st.end());\n                }\n                bool check = true;\n                for(int i=0;i<n;i++) check = check && possible(changes[i],nums[i]);\n                if(check)\n                {\n                    e = m - 1;\n                    ans = min(ans,m);\n                }\n                else s = m + 1;\n            }\n            return ans==x ? -1 : ans+1;\n        }\n    };\n\n\n\n// class Solution  \n// {\n//     ll testCaseNumber;\n//     public:\n//     Solution(int testCaseNumber) { this->testCaseNumber = testCaseNumber; }\n//     void solve()\n//     {\n//         // auto start = chrono::high_resolution_clock::now();\n\n//         //=================  C O D E   H E R E  =========================\n\n        \n\n//         //========================  E N D  =============================== \n\n//         // auto end = chrono::high_resolution_clock::now();\n//         // auto duration = chrono::duration_cast<chrono::milliseconds>(end - start);\n//         // cout << \"Execution Time: \" << duration.count() << \" ms\" << endl;\n//         // tcBreak();\n//     }\n// };\n// int main() { \n//     op();\n//     cout<<fixed<<setprecision(10);\n//     int t; cin>>t;\n//     for(int i=1;i<=t;i++)\n//     {\n//         Solution obj(i);\n//         obj.solve(); \n//     }\n// }\n\n","author":"Nixon2006","submissionId":"1575161296"},[]]},{"386":[{"id":"386","fileName":"1575161701.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        int l = 0, r = queries.size(), ans = -1;\n        while(l <= r){\n            int mid = (l + r) / 2;\n            // mid = 4;\n            // reduce by exactly val\n            vector<vector<int>> v(n);\n            for(int i = 0; i < mid; i++){\n                int a = queries[i][0];\n                int b = queries[i][1];\n                int val = queries[i][2];\n                for(int j = a; j <= b; j++){\n                    v[j].push_back(val);\n                }\n            }\n            bool ok = true;\n            \n            for(int i = 0; i < n; i++){\n                vector<int> dp(nums[i] + 1);\n                dp[0] = 1;\n                // cout<<\" i - \"<<i<<\" : \";\n                for(auto aa : v[i]) {\n                    // cout<<aa<<\" \";\n                    for(int j = nums[i] -1; j >=0; j--){\n                        // cout<<j<<\" \"<<aa<<\" \"<<j + aa<<endl;\n                        if(dp[j] == 0 || (j + aa) > nums[i])continue;\n                        \n                        dp[j + aa] = 1;\n                    }\n                }\n                // cout<<endl;\n                if(dp[nums[i]] != 1){\n                    ok = false;\n                    break;\n                }\n            }\n            // cout<<mid<<\" \"<<ok<<endl;\n            if(ok){\n                ans = mid;\n                r = mid - 1;\n            }\n            else{\n                l = mid + 1;\n            }\n            // break;\n        }\n        return ans;\n    }\n};","author":"arham doshi","submissionId":"1575161701"},[]]},{"387":[{"id":"387","fileName":"1575161704.txt","sourceCode":"class Solution {\npublic:\n    bool helper(vector<int>& nums, vector<vector<int>>& q, int k) {\n        int n = nums.size();\n        for (int i=0; i < n; i++) {\n            vector<int> temp;\n            for (int j = 0; j < k; j++) {\n                if (q[j][0] <= i && i <= q[j][1]) temp.push_back(q[j][2]);\n            }\n            int target = nums[i];\n            vector<bool> dp(target + 1, false);\n            dp[0] = true;\n            for (int v : temp) {\n                for (int s = target; s >= v; s--) \n                    dp[s] = dp[s] || dp[s - v];\n                if (dp[target]) break;\n            }\n            if (!dp[target]) return false;\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = q.size();\n        for (int k = 0; k <= n; k++) {\n            if (helper(nums, q, k)) return k;\n        }\n        return -1;\n    }\n};\n","author":"Shalini","submissionId":"1575161704"},[]]},{"388":[{"id":"388","fileName":"1575161685.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        best = [set([val]) for val in nums]\n        for k, (l,r, val) in enumerate(queries):\n            finish = True\n            for i in range(len(best)):\n                if 0 not in best[i]:\n                    finish = False\n            if finish:\n                return k\n            for i in range(l, r+1):\n                best[i] = best[i]|{v-val for v in best[i] if v-val>=0}\n            finish = True\n            for i in range(len(best)):\n                if 0 not in best[i]:\n                    finish = False\n            if finish:\n                return k+1\n        return -1","author":"timotoa","submissionId":"1575161685"},[]]},{"389":[{"id":"389","fileName":"1575161567.txt","sourceCode":"class ZC {\npublic:\n    bool chk(vector<int>& a) {\n        return all_of(a.begin(), a.end(), [](int x) { return x == 0; });\n    }\n};\n\nclass BS {\npublic:\n    int srch(vector<int>& a, vector<vector<int>>& q, function<bool(int)> vld) {\n        int l = 0, r = q.size(), rs = -1;\n        while (l <= r) {\n            int m = (l + r) / 2;\n            if (vld(m)) {\n                rs = m;\n                r = m - 1;\n            } else {\n                l = m + 1;\n            }\n        }\n        return rs;\n    }\n};\n\nclass QP {\npublic:\n    unordered_map<int, multiset<int>> get(vector<vector<int>>& q, int lim) {\n        unordered_map<int, multiset<int>> mp;\n        int j = 0;\n        while (j < lim) {\n            int l = q[j][0], r = q[j][1], v = q[j][2];\n            int i = l;\n            while (i <= r) {\n                mp[i].insert(v);\n                i++;\n            }\n            j++;\n        }\n        return mp;\n    }\n};\n\nclass SC {\npublic:\n    bool can(int t, multiset<int>& v) {\n        if (t == 0) return true;\n        vector<bool> dp(t + 1, false);\n        dp[0] = true;\n        for (int x : v) {\n            int j = t;\n            while (j >= x) {\n                if (dp[j - x]) dp[j] = true;\n                j--;\n            }\n        }\n        return dp[t];\n    }\n};\n\nclass VH {\npublic:\n    function<bool(int)> vld(vector<int>& a, vector<vector<int>>& q, QP& p, SC& s) {\n        return [&](int lim) {\n            auto mp = p.get(q, lim);\n            int i = 0;\n            while (i < a.size()) {\n                if (!s.can(a[i], mp[i])) return false;\n                i++;\n            }\n            return true;\n        };\n    }\n};\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& array, vector<vector<int>>& queries) {\n        ZC zc;\n        if (zc.chk(array)) return 0;\n\n        QP qp;\n        SC sc;\n        VH vh;\n        auto validator = vh.vld(array, queries, qp, sc);\n\n        BS bs;\n        return bs.srch(array, queries, validator);\n    }\n};\n","author":"Subham","submissionId":"1575161567"},[]]},{"390":[{"id":"390","fileName":"1575161846.txt","sourceCode":"func minZeroArray(nums []int, queries [][]int) int {\n\tsolve := func(idx int) int {\n\t\ttarget := nums[idx]\n\t\tif target == 0 {\n\t\t\treturn 0\n\t\t}\n\n\t\tdp := make([]bool, target+1)\n\t\tdp[target] = true\n\n\t\tfor i, q := range queries {\n\t\t\tif q[0] <= idx && q[1] >= idx {\n\t\t\t\tnewDp := make([]bool, target+1)\n\t\t\t\tfor j := range target+1 {\n\t\t\t\t\tnewDp[j] = dp[j]\n\t\t\t\t\tif j+q[2] <= target && dp[j+q[2]] {\n\t\t\t\t\t\tnewDp[j] = dp[j+q[2]]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp = newDp\n\t\t\t\tif dp[0] {\n\t\t\t\t\treturn i + 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1\n\t}\n\n\tans := 0\n\tfor i := range nums {\n\t\tv := solve(i)\n\t\tif v == -1 {\n\t\t\treturn -1\n\t\t}\n\t\tans = max(ans, v)\n\t}\n\treturn ans\n}\n","author":"yap","submissionId":"1575161846"},[]]},{"391":[{"id":"391","fileName":"1575161859.txt","sourceCode":"class Solution {\npublic:\n        \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(), m=queries.size(), ans=-1;\n        if(*max_element(nums.begin(), nums.end())==0) return 0;\n        vector<unordered_set<int>>dp(n);\n        for(int i=0;i<n;i++){\n            dp[i].insert(nums[i]);\n        }\n        for(int k=0;k<m;k++){\n            vector<unordered_set<int>>next(n);\n            int l=queries[k][0], r=queries[k][1], v=queries[k][2];\n            for(int i=0;i<n;i++){\n                if(dp[i].find(0)!=dp[i].end()){\n                    next[i]=unordered_set<int>{0};continue;\n                }\n                if(l<=i&&i<=r){\n                    for(auto a:dp[i]){\n                        if(a>=v){\n                            next[i].insert(a-v);\n                        }\n                        next[i].insert(a);\n                    } \n                }\n                else{\n                    next[i]=dp[i];\n                }\n                \n            }\n            bool f=true;\n            for(int i=0;i<n;i++){\n                if(next[i].find(0)!=next[i].end()){\n                    next[i]=unordered_set<int>{0};\n                }\n                else{\n                    f=false;\n                }\n            }\n            dp=next;\n            if(f) return k+1;\n        }\n        return -1;\n        \n    }\n};","author":"yoasobi","submissionId":"1575161859"},[]]},{"392":[{"id":"392","fileName":"1575161905.txt","sourceCode":"class Solution {\n    bool isValid(vector<int>& nums, vector<vector<int>>& queries, int m)\n    {\n        // int n = nums.size();\n        // vector<int> temp(n + 1, 0);\n        // for(int i=0;i<m;i++)\n        // {\n            // int start = queries[i][0];\n            // int end = queries[i][1];\n            // int value = queries[i][2];\n\n        //     temp[start] += value;\n        //     temp[end + 1] -= value;\n        // }\n        // int sum = 0;\n        // for(int i=0;i<n;i++)\n        // {\n        //     sum += temp[i];\n        //     if(nums[i] > sum) return false;\n        // }\n        // return true;\n\n        /*\n            code only checking <= sum but in problem there is a fixed amount so\n            sweep line is not possible\n        */\n        int n = nums.size();\n        for(int i=0;i<n;i++)\n        {\n            int last = nums[i];\n            vector<bool> dp(last + 1, false);\n            dp[0] = true;\n            for(int j=0;j<m;j++)\n            {\n                int start = queries[j][0];\n                int end = queries[j][1];\n                int value = queries[j][2];\n\n                if(start <= i && i <= end)\n                {\n                    for(int k=last;k>=value;k--)\n                    {\n                        if(dp[k - value]) dp[k] = true;\n                    }\n                }\n            }\n            if(dp[last] == false) return false;\n        }\n        return true;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n\n        vector<int> rem = nums;\n        if(!isValid(rem, queries, m)) return -1;\n        int start = 0;\n        int end = m;\n        while(start < end)\n        {\n            int mid = start + (end - start) / 2;\n            if(isValid(rem, queries, mid)) end = mid;\n            else start = mid + 1;\n        }\n        return end;\n    }\n};","author":"Mohit Budhlakoti","submissionId":"1575161905"},[]]},{"393":[{"id":"393","fileName":"1575162437.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = 0;\n        \n        for (int k=0; k<nums.size(); k++) {\n            if (nums[k]==0)\n                continue;\n            vector<vector<bool>> dp(queries.size()+1, vector<bool>(nums[k]+1));\n            int val = queries.size()+1;\n            dp[0][0] = true;\n            for (int i=1; i<=queries.size(); i++) {\n                for (int j=nums[k]; j>=0; j--) {\n                    if (j==0)\n                        dp[i][j] = true;\n\n\n                    dp[i][j] = dp[i-1][j] | dp[i][j];\n\n                    if (k>=queries[i-1][0]&&k<=queries[i-1][1]&&j>=queries[i-1][2])\n                        dp[i][j] = dp[i-1][j-queries[i-1][2]] | dp[i][j];\n\n                    //cout << i << \" \" << j << \" \" << dp[i][j] << \"n\";\n                    if (j == nums[k] && dp[i][j]) {\n                        val = i;\n                        break;\n                    }\n                }\n\n                \n\n                if (val < queries.size()+1)\n                    break;\n            }\n            \n            //cout << k << \" \" << val << \"n\";\n            if (val == queries.size()+1)\n                return -1;\n\n            ans = max(ans, val);\n        }\n\n        return ans;\n    }\n};","author":"Arcan3","submissionId":"1575162437"},[]]},{"394":[{"id":"394","fileName":"1575162219.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        // for each num\n        // for each query, if included, try with and without decrementing\n        int ans = -1;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (nums[i] == 0) {\n                ans = max(ans, 0);\n                continue;\n            }\n            unordered_set<int> s = {nums[i]};\n            int queryIndex = 0;\n            for ( ; queryIndex < queries.size(); ++queryIndex) {\n                auto& query = queries[queryIndex];\n                if (i >= query[0] && i <= query[1]) {\n                    vector<int> v(s.begin(), s.end());\n                    for (int t : v) {\n                        s.insert(t - query[2]);\n                    }\n                    if (s.find(0) != s.end()) {\n                        break;\n                    }\n                }\n            }\n            if (s.find(0) == s.end()) {\n                return -1;\n            }\n            ans = max(ans, queryIndex + 1);\n        }\n        return ans;\n    }\n};","author":"xorcutor","submissionId":"1575162219"},[]]},{"395":[{"id":"395","fileName":"1575162460.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<vector<bool>> dp(n);\n        vector<int> erl(n, -1);\n        for(int j = 0; j < n; j++){\n            dp[j].assign(nums[j] + 1, false);\n            dp[j][0] = true;\n            if(nums[j] == 0)\n                erl[j] = 0;\n        }\n        for(int i = 0; i < m; i++){\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int v = queries[i][2];\n            for(int j = l; j <= r; j++){\n                if(erl[j] != -1)\n                    continue;\n                for(int s = nums[j] - v; s >= 0; s--){\n                    if(dp[j][s] && s + v <= nums[j])\n                        dp[j][s + v] = true;\n                }\n                if(dp[j][nums[j]])\n                    erl[j] = i + 1;\n            }\n        }\n        int ans = 0;\n        for(int j = 0; j < n; j++){\n            if(erl[j] == -1){\n                return -1;\n            }\n            ans = max(ans, erl[j]);\n        }\n        return ans;\n    }\n};","author":"Naveen Khuntey","submissionId":"1575162460"},[]]},{"396":[{"id":"396","fileName":"1575161552.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        List<List<Pair>> qList = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            qList.add(new ArrayList<>());\n        }\n\n        for (int j = 0; j < m; j++) {\n            int l = queries[j][0];\n            int r = queries[j][1];\n            int val = queries[j][2];\n            for (int i = l; i <= r; i++) {\n                qList.get(i).add(new Pair(j, val));\n            }\n        }\n\n        int maxK = 0;\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            if (target == 0) {\n                maxK = Math.max(maxK, 0);\n                continue;\n            }\n\n            List<Pair> qs = qList.get(i);\n            int total = 0;\n            for (Pair p : qs) {\n                total += p.val;\n            }\n            if (total < target) {\n                return -1;\n            }\n\n            Map<Integer, Integer> dp = new HashMap<>();\n            dp.put(0, -1);\n            for (Pair p : qs) {\n                int j = p.index;\n                int valj = p.val;\n                Map<Integer, Integer> tmp = new HashMap<>();\n\n                for (Map.Entry<Integer, Integer> entry : dp.entrySet()) {\n                    int s = entry.getKey();\n                    int currentJ = entry.getValue();\n                    if (!tmp.containsKey(s) || currentJ < tmp.get(s)) {\n                        tmp.put(s, currentJ);\n                    }\n                }\n\n                for (Map.Entry<Integer, Integer> entry : dp.entrySet()) {\n                    int s = entry.getKey();\n                    int currentJ = entry.getValue();\n                    if (s > target - valj) {\n                        continue;\n                    }\n                    int newS = s + valj;\n                    if (newS > target) {\n                        continue;\n                    }\n                    int newJ = Math.max(currentJ, j);\n                    if (!tmp.containsKey(newS) || newJ < tmp.get(newS)) {\n                        tmp.put(newS, newJ);\n                    }\n                }\n\n                dp = tmp;\n            }\n\n            if (!dp.containsKey(target)) {\n                return -1;\n            }\n            int j_i = dp.get(target);\n            maxK = Math.max(maxK, j_i + 1);\n        }\n\n        if (maxK == 0) {\n            for (int num : nums) {\n                if (num != 0) {\n                    return -1;\n                }\n            }\n            return 0;\n        } else {\n            return maxK;\n        }\n    }\n\n    static class Pair {\n        int index;\n        int val;\n\n        Pair(int index, int val) {\n            this.index = index;\n            this.val = val;\n        }\n    }\n}","author":"Supratim Das","submissionId":"1575161552"},[]]},{"397":[{"id":"397","fileName":"1575162500.txt","sourceCode":"class Solution {\npublic:\nbool  isPoss(vector<int>& arr,int k,vector<vector<int>>& q){\n    vector<vector<int>> v(11,vector<int>(arr.size()+2,0));\n    for(int i=0;i<k;i++){\n        int l=q[i][0],r=q[i][1],vl=q[i][2];\n        v[vl][l]++;\n        v[vl][r+1]--;\n    }\n    for(int i=1;i<=10;i++){\n        for(int j=1;j<arr.size();j++){\n            v[i][j]+=v[i][j-1];\n        }\n    }\n    for(int i=0;i<arr.size();i++){\n        if(arr[i]==0)continue;\n        //now we have a set of decrements can we make arr[i] outof them\n        int target = arr[i];\n            vector<bool> dp(target + 1, false);\n            dp[0] = true;\n            for (int val = 1; val <= 10; val++) {\n                int cnt = v[val][i];\n                if (cnt == 0) continue;\n                for (int t = target; t >= 0; t--) {\n                    if (!dp[t]) continue;\n                    for (int c = 1; c <= cnt && t + c * val <= target; c++) {\n                        dp[t + c * val] = true;\n                    }\n                }\n            }\n            if (!dp[target]) return false;\n    }\n    return true;\n}\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l=0;\n        int h=queries.size();\n        int ans=-1;\n        while(l<=h){\n            int mid=l+(h-l)/2;\n            if(isPoss(nums,mid,queries)){\n                h=mid-1;\n                ans=mid;\n            }\n            else{\n                l=mid+1;\n            }\n        }\n        return ans;\n    }\n};","author":"Vincenzo26_Cassano","submissionId":"1575162500"},[]]},{"398":[{"id":"398","fileName":"1575162488.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        \n        dp = []\n        for i in range(n):\n            if nums[i] == 0:\n                dp.append([True])\n            else:\n                dp.append([True] + [False] * nums[i])\n        \n        if all(x == 0 for x in nums):\n            return 0\n        \n        for k in range(1, m + 1):\n            l, r, val = queries[k - 1]  # k-th query (1-indexed k; queries are 0-indexed)\n            for i in range(l, r + 1):\n                if nums[i] > 0:\n                    for s in range(nums[i] - val, -1, -1):\n                        if dp[i][s]:\n                            dp[i][s + val] = True\n            all_zero = True\n            for i in range(n):\n                if nums[i] > 0 and not dp[i][nums[i]]:\n                    all_zero = False\n                    break\n            if all_zero:\n                return k\n        return -1","author":"uday bhaskar mathangi","submissionId":"1575162488"},[]]},{"399":[{"id":"399","fileName":"1575162739.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        // Check if all elements are zero\n        boolean allZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) {\n            return 0;\n        }\n\n        int n = nums.length;\n        List<List<Query>> coverage = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            coverage.add(new ArrayList<>());\n        }\n\n        // Populate coverage for each index\n        for (int j = 0; j < queries.length; j++) {\n            int l = queries[j][0];\n            int r = queries[j][1];\n            int val = queries[j][2];\n            for (int i = l; i <= r; i++) {\n                coverage.get(i).add(new Query(j, val));\n            }\n        }\n\n        int maxK = -1;\n\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            if (target == 0) {\n                continue;\n            }\n\n            List<Query> qList = coverage.get(i);\n            if (qList.isEmpty()) {\n                return -1;\n            }\n\n            Set<Integer> possibleSums = new HashSet<>();\n            possibleSums.add(0);\n            boolean found = false;\n\n            for (Query q : qList) {\n                Set<Integer> newSums = new HashSet<>(possibleSums);\n                for (int s : possibleSums) {\n                    newSums.add(s + q.val);\n                }\n                possibleSums = newSums;\n\n                if (possibleSums.contains(target)) {\n                    if (q.originalIndex > maxK) {\n                        maxK = q.originalIndex;\n                    }\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) {\n                return -1;\n            }\n        }\n\n        if (maxK == -1) {\n            return 0;\n        }\n\n        return maxK + 1;\n    }\n\n    private static class Query {\n        int originalIndex;\n        int val;\n\n        Query(int o, int v) {\n            originalIndex = o;\n            val = v;\n        }\n    }\n}","author":"Sagar TH","submissionId":"1575162739"},[]]},{"400":[{"id":"400","fileName":"1575162621.txt","sourceCode":"class Solution {\npublic:\n    \nbool isPossible(vector<int>& nums, vector<vector<int>>& queries, int k) {\n    int n = nums.size();\n    for(int i = 0; i < n; ++i) {\n        vector<int> vals;\n        for(int q = 0; q < k; ++q) {\n            int l = queries[q][0], r = queries[q][1], val = queries[q][2];\n            if(l <= i && i <= r) vals.push_back(val);\n        }\n        \n        vector<bool> dp(nums[i] + 1, false);\n        dp[0] = true;\n        for(int v : vals) {\n            for(int x = nums[i]; x >= v; --x) {\n                if(dp[x - v]) dp[x] = true;\n            }\n        }\n        if(!dp[nums[i]]) return false; \n    }\n    return true;\n}\n\nint minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    int lo = 0, hi = queries.size(), ans = -1;\n    while(lo <= hi){\n        int mid = (lo + hi)/2;\n        if(isPossible(nums, queries, mid)){\n            ans = mid;\n            hi = mid - 1;\n        } else {\n            lo = mid + 1;\n        }\n    }\n    return ans;\n}\n\n};","author":"Anupam Ghosh","submissionId":"1575162621"},[]]},{"401":[{"id":"401","fileName":"1575162824.txt","sourceCode":"class Solution {\npublic:\n\n\nbool isPos(vector<int>&nums, vector<vector<int>>&queries, int k)\n{\n    int n = nums.size();\n\n    for(int i=0;i<n;i++)\n        {\n            bitset<1001> dp;\n            dp.reset();\n\n            dp[0] = 1;\n\n            for(int j=0;j<k;j++)\n                {\n                    int l = queries[j][0];\n                    int r = queries[j][1];\n                    int val = queries[j][2];\n\n                    if(i >= l && i <= r)\n                    {\n                        dp |= (dp<<val);\n                    }\n                }\n\n            if(!dp[nums[i]])\n            {\n                return false;\n            }\n        }\n\n    return true;\n}\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        int st = 0;\n        int end = m;\n        int ans = -1;\n\n        vector<vector<int>> temp;\n        temp = queries;\n\n        while(st <= end)\n            {\n                int mid = (st + end)/2;\n\n                if(isPos(nums, temp, mid))\n                {\n                    ans = mid;\n                    end = mid - 1;\n                }\n                else \n                {\n                    st = mid + 1;\n                }\n            }\n        return ans;\n    }\n};","author":"Rsoniie","submissionId":"1575162824"},[]]},{"402":[{"id":"402","fileName":"1575162007.txt","sourceCode":"omax, omin = max, min\nmax = lambda x, y: x if x > y else y\nmin = lambda x, y: x if x < y else y\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        need = 0\n        for i, num in enumerate(nums):\n            @cache\n            def best(qidx, target):\n                if target == 0:\n                    return qidx\n                if qidx == len(queries):\n                    return inf\n                if target < 0:\n                    return inf\n                res = best(qidx + 1, target)\n                l, r, val = queries[qidx]\n                if l <= i <= r and target >= val:\n                    res = min(best(qidx + 1, target - val), res)\n                return res\n            need = max(best(0, num), need)\n            best.cache_clear()\n        return need if need != inf else -1","author":"killer-whale","submissionId":"1575162007"},[]]},{"403":[{"id":"403","fileName":"1575162788.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int res = 0;\n        int n = nums.size();\n        for(int i = 0; i < n; i ++) {\n            int k = solve(nums[i], i, queries);\n            if(k == -1) {\n                return -1;\n            }\n            res = max(res, k);\n        }\n        return res;\n    }\n\n    int solve(int num, int i, vector<vector<int>>& queries) {\n        if(num == 0) return 0;\n        int m = queries.size();\n        vector<bool> dp(num + 1, false);\n        dp[0] = true;\n        for(int j = 0; j < m; j ++) {\n            int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n            if(i < l || i > r || val > num) continue;\n            for(int k = num; k >= val; k --) {\n                dp[k] = dp[k] || dp[k - val];\n            }\n            if(dp[num]) {\n                return j + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"zubacii","submissionId":"1575162788"},[]]},{"404":[{"id":"404","fileName":"1575162908.txt","sourceCode":"class Solution {\npublic:\n    bool subsetSum(const vector<int>& arr, int target) {\n        int total = 0;\n        for (int x : arr)\n            total += x;\n        if (total < target)\n            return false;\n        vector<bool> dp(target + 1, false);\n        dp[0] = true;\n        for (int x : arr) {\n            for (int j = target; j >= x; j--) {\n                dp[j] = dp[j] || dp[j - x];\n            }\n        }\n        return dp[target];\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int m = queries.size();\n        int n = nums.size();\n        int low = 0, high = m, ans = -1;\n        \n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            vector<vector<int>> diff(queries.begin(), queries.begin() + mid);\n            bool possible = true;\n            for (int i = 0; i < n; i++) {\n                vector<int> available;\n                for (int j = 0; j < mid; j++) {\n                    int l = diff[j][0], r = diff[j][1], val = diff[j][2];\n                    if (i >= l && i <= r) {\n                        available.push_back(val);\n                    }\n                }\n                if (!subsetSum(available, nums[i])) {\n                    possible = false;\n                    break;\n                }\n            }\n            if (possible) {\n                ans = mid;\n                high = mid - 1; \n            } else {\n                low = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"Hardik Soni","submissionId":"1575162908"},[]]},{"405":[{"id":"405","fileName":"1575162983.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        BitSet[] dp = new BitSet[n];\n\n        for (int j = 0; j < n; j++) {\n            dp[j] = new BitSet(1001);\n            dp[j].set(0);\n        }\n\n        boolean allZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) return 0;\n\n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n                BitSet temp = new BitSet(1001);\n                for (int pos = dp[j].nextSetBit(0); pos >= 0 && pos + v < 1001; pos = dp[j].nextSetBit(pos + 1)) {\n                    temp.set(pos + v);\n                }\n                dp[j].or(temp);\n\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp[j].clear(pos);\n                }\n            }\n\n            boolean allAchieved = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j].get(nums[j])) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n            if (allAchieved) return k + 1;\n        }\n        return -1;\n    }\n}","author":"mn121","submissionId":"1575162983"},[{"id":"1518","similarity":0.8938775510204081,"totOverlap":219,"longestOverlap":109},{"id":"972","similarity":0.9774774774774775,"totOverlap":217,"longestOverlap":108},{"id":"738","similarity":0.8733031674208145,"totOverlap":193,"longestOverlap":53},{"id":"855","similarity":0.8703703703703703,"totOverlap":188,"longestOverlap":34},{"id":"1168","similarity":0.9121951219512195,"totOverlap":187,"longestOverlap":51},{"id":"1168","similarity":0.9296482412060302,"totOverlap":185,"longestOverlap":67}]],"738":[{"id":"738","fileName":"1575189708.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        BitSet[] bitMaskArray = new BitSet[n];\n\n        // Initialize each BitSet and set bit 0 to true\n        for (int i = 0; i < n; i++) {\n            bitMaskArray[i] = new BitSet(1001);\n            bitMaskArray[i].set(0);\n        }\n\n        // Check if all elements in nums are already zero\n        boolean allElementsZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                allElementsZero = false;\n                break;\n            }\n        }\n        if (allElementsZero) return 0;\n\n        // Process each query\n        for (int k = 0; k < queries.length; k++) {\n            int left = queries[k][0];\n            int right = queries[k][1];\n            int value = queries[k][2];\n\n            for (int i = left; i <= right; i++) {\n                BitSet shifted = new BitSet(1001);\n                \n                // Manual left shift (BitSet does not support `<<`)\n                for (int bit = bitMaskArray[i].nextSetBit(0); bit >= 0; bit = bitMaskArray[i].nextSetBit(bit + 1)) {\n                    if (bit + value < 1001) {\n                        shifted.set(bit + value);\n                    }\n                }\n\n                bitMaskArray[i].or(shifted);\n\n                // Reset unreachable values\n                for (int pos = nums[i] + 1; pos < 1001; pos++) {\n                    bitMaskArray[i].clear(pos);\n                }\n            }\n\n            // Check if all target values are reached\n            boolean allValuesReached = true;\n            for (int i = 0; i < n; i++) {\n                if (!bitMaskArray[i].get(nums[i])) {\n                    allValuesReached = false;\n                    break;\n                }\n            }\n\n            if (allValuesReached) return k + 1;\n        }\n\n        return -1;\n    }\n}\n","author":"Bharath","submissionId":"1575189708"},[{"id":"405","similarity":0.8733031674208145,"totOverlap":193,"longestOverlap":53}]],"848":[{"id":"848","fileName":"1575197294.txt","sourceCode":"import java.util.*;\n\npublic class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        BitSet[] dp = new BitSet[n];\n\n        for (int j = 0; j < n; j++) {\n            dp[j] = new BitSet(1001);\n            dp[j].set(0);\n        }\n\n        boolean allZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                allZero = false;\n                break;\n            }\n        }\n\n        if (allZero) return 0;\n\n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n                BitSet shifted = new BitSet(1001);\n                for (int pos = 0; pos < 1001 - v; pos++) {\n                    if (dp[j].get(pos)) {\n                        shifted.set(pos + v);\n                    }\n                }\n                dp[j].or(shifted);\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp[j].clear(pos);\n                }\n            }\n\n            boolean allAchieved = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j].get(nums[j])) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n\n            if (allAchieved) return k + 1;\n        }\n\n        return -1;\n    }\n}\n","author":"Abhishek Kaushik","submissionId":"1575197294"},[{"id":"1179","similarity":0.8508771929824561,"totOverlap":194,"longestOverlap":59},{"id":"855","similarity":0.9009433962264151,"totOverlap":191,"longestOverlap":76},{"id":"405","similarity":0.8703703703703703,"totOverlap":188,"longestOverlap":34}]],"855":[{"id":"855","fileName":"1575197346.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] qs) {\n       int n = nums.length;\n       BitSet[] dp = new BitSet[n];\n       for (int j = 0; j < n; j++) {\n           dp[j] = new BitSet(1001);\n           dp[j].set(0);\n       }\n       boolean allZero = true;\n       for (int j = 0; j < n; j++) {\n           if (nums[j] != 0) {\n               allZero = false;\n               break;\n           }\n       }\n       if (allZero) return 0;\n       for (int i = 0; i < qs.length; i++) {\n           int l = qs[i][0];\n           int r = qs[i][1];\n           int val = qs[i][2];\n           for (int j = l; j <= r; j++) {\n               BitSet shifted = new BitSet(1001);\n               for (int bit = 0; bit < 1001 - val; bit++) {\n                   if (dp[j].get(bit)) {\n                       shifted.set(bit + val);\n                   }\n               }\n               dp[j].or(shifted);\n               for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                   dp[j].clear(pos);\n               }\n           }\n           boolean isZero = true;\n           for (int j = 0; j < n; j++) {\n               if (!dp[j].get(nums[j])) {\n                   isZero = false;\n                   break;\n               }\n           }\n           if (isZero) return i + 1;\n       }\n       return -1;\n    }\n}","author":"Gnanika Omkarini Makkena","submissionId":"1575197346"},[{"id":"848","similarity":0.9009433962264151,"totOverlap":191,"longestOverlap":76}]],"972":[{"id":"972","fileName":"1575206109.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        BitSet[] dp = new BitSet[n];\n\n        // Initialize BitSet\n        for (int j = 0; j < n; j++) {\n            dp[j] = new BitSet(1001);\n            dp[j].set(0);\n        }\n\n        // Check if all elements are initially zero\n        boolean allZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero)\n            return 0;\n\n        // Process the queries\n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n                BitSet shifted = new BitSet(1001);\n\n                // Perform bit shifting manually\n                for (int i = dp[j].nextSetBit(0); i >= 0 && i + v < 1001; i = dp[j].nextSetBit(i + 1)) {\n                    shifted.set(i + v);\n                }\n\n                dp[j].or(shifted);\n\n                // Clear bits greater than nums[j]\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp[j].clear(pos);\n                }\n            }\n\n            // Check if nums[j] is achievable in dp[j]\n            boolean allAchieved = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j].get(nums[j])) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n\n            if (allAchieved) {\n                return k + 1; // Return 1-based index\n            }\n        }\n\n        return -1;\n    }\n}","author":"ujjawal thakur","submissionId":"1575206109"},[{"id":"405","similarity":0.9774774774774775,"totOverlap":217,"longestOverlap":108}]],"1109":[{"id":"1109","fileName":"1575214009.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        BitSet[] dp = new BitSet[n];\n\n        for (int i = 0; i < n; i++) {\n            dp[i] = new BitSet(1001);\n            dp[i].set(0);\n        }\n\n        boolean allZero = Arrays.stream(nums).allMatch(x -> x == 0);\n        if (allZero) return 0;\n\n        for (int queryIndex = 0; queryIndex < queries.length; queryIndex++) {\n            int left = queries[queryIndex][0], right = queries[queryIndex][1], value = queries[queryIndex][2];\n\n            for (int i = left; i <= right; i++) {\n                BitSet shifted = new BitSet(1001);\n                for (int j = 0; j < 1001 - value; j++) {\n                    if (dp[i].get(j)) {\n                        shifted.set(j + value);\n                    }\n                }\n                dp[i].or(shifted);\n\n                for (int pos = nums[i] + 1; pos < 1001; pos++) {\n                    dp[i].clear(pos);\n                }\n            }\n\n            boolean allAchieved = true;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i].get(nums[i])) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n\n            if (allAchieved) return queryIndex + 1;\n        }\n        return -1;\n    }\n}","author":"Ramu Kumar","submissionId":"1575214009"},[{"id":"1118","similarity":1.0,"totOverlap":200,"longestOverlap":100},{"id":"1109","similarity":0.9296482412060302,"totOverlap":185,"longestOverlap":67}]],"1118":[{"id":"1118","fileName":"1575214737.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        BitSet[] dp = new BitSet[n];\n\n        for (int j = 0; j < n; j++) {\n            dp[j] = new BitSet(1001);\n            dp[j].set(0);\n        }\n\n        boolean allZero = Arrays.stream(nums).allMatch(x -> x == 0);\n        if (allZero) return 0;\n\n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0], r = queries[k][1], v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n                BitSet shifted = new BitSet(1001);\n                for (int i = 0; i < 1001 - v; i++) {\n                    if (dp[j].get(i)) {\n                        shifted.set(i + v);\n                    }\n                }\n                dp[j].or(shifted);\n\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp[j].clear(pos);\n                }\n            }\n\n            boolean allAchieved = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j].get(nums[j])) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n\n            if (allAchieved) return k + 1;\n        }\n        return -1;\n    }\n}","author":"Pallav","submissionId":"1575214737"},[{"id":"1109","similarity":1.0,"totOverlap":200,"longestOverlap":100}]],"1168":[{"id":"1168","fileName":"1575217135.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        BitSet[] dp = new BitSet[n];\n\n        for (int j = 0; j < n; j++) {\n            dp[j] = new BitSet(1001);\n            dp[j].set(0);\n        }\n\n        boolean allZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) return 0;\n\n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0], r = queries[k][1], v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n                BitSet shifted = new BitSet(1001);\n                for (int i = 0; i < 1001 - v; i++) {\n                    if (dp[j].get(i)) {\n                        shifted.set(i + v);\n                    }\n                }\n                dp[j].or(shifted);\n\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp[j].clear(pos);\n                }\n            }\n\n            boolean allAchieved = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j].get(nums[j])) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n\n            if (allAchieved) return k + 1;\n        }\n        return -1;\n    }\n}\n","author":"Harikaa-ch","submissionId":"1575217135"},[{"id":"1623","similarity":1.0,"totOverlap":198,"longestOverlap":99},{"id":"1447","similarity":0.9797979797979798,"totOverlap":194,"longestOverlap":88},{"id":"855","similarity":0.9121951219512195,"totOverlap":187,"longestOverlap":51}]],"1179":[{"id":"1179","fileName":"1575217796.txt","sourceCode":"public class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        BitSet[] dp = new BitSet[n];\n        for (int j = 0; j < n; j++) {\n            dp[j] = new BitSet(1001);\n            dp[j].set(0);\n        }\n\n        boolean f = true;\n        for (int num : nums) {\n            if (num != 0) {\n                f = false;\n                break;\n            }\n        }\n        if (f) return 0;\n\n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n                BitSet sVal = (BitSet) dp[j].clone();\n                shiftLeft(sVal, v);\n                dp[j].or(sVal);\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp[j].clear(pos);\n                }\n            }\n\n            boolean fs = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j].get(nums[j])) {\n                    fs = false;\n                    break;\n                }\n            }\n\n            if (fs) return k + 1;\n        }\n\n        return -1;\n    }\n\n    private void shiftLeft(BitSet bitset, int v) {\n        for (int i = 1000 - v; i >= 0; i--) {\n            if (bitset.get(i)) {\n                bitset.set(i + v);\n            } else {\n                bitset.clear(i + v);\n            }\n        }\n        for (int i = 0; i < v; i++) {\n            bitset.clear(i);\n        }\n    }\n}","author":"vismay__yerunkar","submissionId":"1575217796"},[{"id":"848","similarity":0.8508771929824561,"totOverlap":194,"longestOverlap":59}]],"1447":[{"id":"1447","fileName":"1575230772.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n         int num;num = nums.length;\n        BitSet[] pd = new BitSet[num];\n\n        for (int j = 0; j < num; j++)\n            {\n            pd[j] = new BitSet(1001);\n            pd[j].set(0);\n        }\n\n        boolean aZ = true;\n        for (int numElem : nums)\n            {\n            if (numElem != 0)\n            {\n                aZ = false;\n                break;\n            }\n        }\n        if (aZ) return 0;\n\n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0], r = queries[k][1], v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n                BitSet shft = new BitSet(1001);\n                for (int i = 0; i < 1001 - v; i++)\n                    {\n                    if (pd[j].get(i)) \n                    {\n                        shft.set(i + v);\n                    }\n                }\n                pd[j].or(shft);\n\n                for (int pos = nums[j] + 1; pos < 1001; pos++) \n                {\n                    pd[j].clear(pos);\n                }\n            }\n\n            boolean aa = true;\n            for (int j = 0; j < num; j++)\n                {\n                if (!pd[j].get(nums[j]))\n                {\n                    aa = false;\n                    break;\n                }\n            }\n\n            if (aa)\n                return k + 1;\n        }\n        return -1;\n    }\n}","author":"n2210030030","submissionId":"1575230772"},[{"id":"1168","similarity":0.9797979797979798,"totOverlap":194,"longestOverlap":88}]],"1518":[{"id":"1518","fileName":"1575234496.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        BitSet[] dp = new BitSet[n];\n\n        // Initialize BitSet\n        for (int j = 0; j < n; j++) {\n            dp[j] = new BitSet(1001);\n            dp[j].set(0);\n        }\n\n        // Check if all numbers are zero\n        boolean allZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) return 0;\n\n        // Process queries\n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n                BitSet shifted = new BitSet(1001);\n\n                // Perform manual left shift operation\n                for (int pos = dp[j].nextSetBit(0); pos >= 0 && pos + v < 1001; pos = dp[j].nextSetBit(pos + 1)) {\n                    shifted.set(pos + v);\n                }\n\n                dp[j].or(shifted);\n\n                // Reset unnecessary bits\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp[j].clear(pos);\n                }\n            }\n\n            // Check if all elements are achievable\n            boolean allAchieved = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j].get(nums[j])) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n\n            if (allAchieved) return k + 1;\n        }\n\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {1, 2, 3, 4, 5};\n        int[][] queries = {{0, 2, 1}, {1, 4, 2}, {0, 4, 3}};\n\n        int result = solution.minZeroArray(nums, queries);\n        System.out.println(result);\n    }\n}\n","author":"vardhan tas","submissionId":"1575234496"},[{"id":"405","similarity":0.8938775510204081,"totOverlap":219,"longestOverlap":109}]],"1623":[{"id":"1623","fileName":"1575239877.txt","sourceCode":"\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        BitSet[] dp = new BitSet[n];\n\n        for (int j = 0; j < n; j++) {\n            dp[j] = new BitSet(1001);\n            dp[j].set(0);\n        }\n\n        boolean az = true;\n        for (int num : nums) {\n            if (num != 0) {\n                az = false;\n                break;\n            }\n        }\n        if (az) return 0;\n\n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0], r = queries[k][1], v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n                BitSet sh = new BitSet(1001);\n                for (int i = 0; i < 1001 - v; i++) {\n                    if (dp[j].get(i)) {\n                        sh.set(i + v);\n                    }\n                }\n                dp[j].or(sh);\n\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp[j].clear(pos);\n                }\n            }\n\n            boolean aA = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j].get(nums[j])) {\n                    aA = false;\n                    break;\n                }\n            }\n\n            if (aA) return k + 1;\n        }\n        return -1;\n    }\n}\n","author":"Ashish","submissionId":"1575239877"},[{"id":"1168","similarity":1.0,"totOverlap":198,"longestOverlap":99}]]},{"406":[{"id":"406","fileName":"1575163273.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        ## binary\n        def admissible(ind, queries):\n            d = []\n            for i, query in enumerate(queries):\n                l,r,v = query\n                if ind>=l and ind<=r:\n                    d += [(i,v)]\n            return d\n\n        \n\n        def repeat(num, prev, cur):\n            out = prev.copy()\n            for p in prev:\n                if p+cur <= num:\n                    out.add(p+cur)\n            return out\n            \n        \n        \n        def addable(nums, ind, queries, mid):\n            a = admissible(ind, queries)\n            # print(ind, a, mid)\n            prev = {0}\n            num = nums[ind]\n            for i, v in a: ### only allow i <= mid\n                if i+1 <= mid:\n                    next = repeat(num, prev, v)\n                    prev = next\n                    # print(prev, v, next)\n                    if num in next:\n                        return True\n            return False\n\n        def binarysearch(nums, ind, queries):\n            if nums[ind] == 0: return 0\n            left = 0 ### always fail\n            right = len(queries) + 1 ### always work\n            while right - left >= 2:\n                mid = (left+right)//2\n                # print(ind, mid, addable(nums, ind, queries, mid))\n                if addable(nums, ind, queries, mid) == True:\n                    right = mid\n                else:\n                    left = mid\n            return right\n                \n        out = 0\n        for ind in range(len(nums)):\n            # print(binarysearch(nums, ind, queries))\n            if binarysearch(nums, ind, queries) == len(queries)+1:\n                return -1\n            out = max(out, binarysearch(nums, ind, queries))\n        return out\n                \n        \n            \n        ","author":"Aluminum57","submissionId":"1575163273"},[]]},{"407":[{"id":"407","fileName":"1575163156.txt","sourceCode":"from bisect import bisect_left\nfrom collections import defaultdict\nfrom typing import List\n\nclass ZC:\n    def chk(self, a: List[int]) -> bool:\n        return all(x == 0 for x in a)\n\nclass BS:\n    def srch(self, a: List[int], q: List[List[int]], vld) -> int:\n        l, r, rs = 0, len(q), -1\n        while l <= r:\n            m = (l + r) // 2\n            if vld(m):\n                rs, r = m, m - 1\n            else:\n                l = m + 1\n        return rs\n\nclass QP:\n    def get(self, q: List[List[int]], lim: int):\n        mp = defaultdict(list)\n        j = 0\n        while j < lim:\n            l, r, v = q[j]\n            i = l\n            while i <= r:\n                mp[i].append(v)\n                i += 1\n            j += 1\n        return mp\n\nclass SC:\n    def can(self, t: int, v: List[int]) -> bool:\n        if t == 0:\n            return True\n        dp = [False] * (t + 1)\n        dp[0] = True\n        for x in v:\n            j = t\n            while j >= x:\n                if dp[j - x]:\n                    dp[j] = True\n                j -= 1\n        return dp[t]\n\nclass VH:\n    def vld(self, a: List[int], q: List[List[int]], p: QP, s: SC):\n        return lambda lim: all(s.can(a[i], p.get(q, lim)[i]) for i in range(len(a)))\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        zc = ZC()\n        if zc.chk(nums):\n            return 0\n\n        qp = QP()\n        sc = SC()\n        vh = VH()\n        vr = vh.vld(nums, queries, qp, sc)\n\n        bs = BS()\n        return bs.srch(nums, queries, vr)\n","author":"Vivan Arora","submissionId":"1575163156"},[]]},{"408":[{"id":"408","fileName":"1575163357.txt","sourceCode":"from collections import defaultdict\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        if sum(nums) == 0:\n            return 0\n\n        dp = [[False] * 1001 for _ in range(n)]\n        for i in range(n):\n            dp[i][0] = True\n\n        idxsLeft = set(list(range(n)))\n        for i, q in enumerate(queries):\n            #print('start', i)\n            l, r, val = q[0], q[1], q[2]\n            for idx in range(l, r + 1):\n                if idx not in idxsLeft:\n                    continue\n                #print('i', i, 'idx', idx, 'val', val)\n                #print('dp', dp[idx][:10])\n                for x in range(nums[idx], val - 1, -1):\n                    if not dp[idx][x] and dp[idx][x - val]:\n                        dp[idx][x] = True\n                #print('dp', dp[idx][:10])\n                if dp[idx][nums[idx]]:\n                    #print('i', i, 'idx', idx, 'val', val)\n                    #print('dp', dp[idx][:10])\n                    idxsLeft.remove(idx)\n                    if len(idxsLeft) == 0:\n                        return i + 1\n\n        return -1","author":"ffjiang","submissionId":"1575163357"},[]]},{"409":[{"id":"409","fileName":"1575162507.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        dp = []\n        non_zero = False\n        for i, x in enumerate(nums):\n            non_zero |= (x != 0)\n            dp.append([False] * (x + 1))\n            dp[i][0] = True\n        if not non_zero:\n            return 0\n        for k, (l, r, v) in enumerate(queries):\n            for i in range(l, r + 1):\n                target = nums[i]\n                if v > target:\n                    continue\n                for s in range(target - v, -1, -1):\n                    if dp[i][s]:\n                        dp[i][s + v] = True\n            if all(dp[i][nums[i]] for i in range(n)):\n                return k + 1  \n        return -1","author":"StackOverflowAutomaton","submissionId":"1575162507"},[]]},{"410":[{"id":"410","fileName":"1575163532.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\n        auto dfs = [&](auto&& dfs, int x, int ind, int y, int z, vector<vector<int>>&dp) -> bool {\n            if (x == 0)\n                return true;\n            if (ind == z)\n                return false;\n            if(dp[x][ind] != -1)\n                    return dp[x][ind];\n            if (queries[ind][0] <= y && queries[ind][1] >= y &&\n                queries[ind][2] <= x)\n                return dp[x][ind] =  (dfs(dfs, x, ind + 1, y, z, dp) ||\n                        dfs(dfs, x - queries[ind][2], ind + 1, y, z, dp));\n            return dp[x][ind] =  dfs(dfs, x, ind + 1, y, z, dp);\n        };\n        auto check = [&](int m) -> bool\n        {\n            bool ans = true;\n            for(int i = 0; i < nums.size() && ans; ++i)\n                {\n                    vector dp(nums[i] + 1, vector(queries.size() + 1, -1));\n                    ans &= dfs(dfs, nums[i], 0, i, m, dp);\n                }\n            return ans;\n        };\n        int l = 0, r = queries.size();\n        int ans = -1;\n        while(l <= r)\n            {\n                int m = (l+r) >> 1ll;\n                // cout << m << \"n\";\n                if(check(m)){\n                    ans = m;\n                    r = m - 1;\n                }\n                else{\n                    l = m + 1;\n                }\n            }\n        return ans;\n    }\n};","author":"Ankit sisodya","submissionId":"1575163532"},[]]},{"411":[{"id":"411","fileName":"1575163671.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = 0;\n        for (int i = 0; i < size(nums); i++) {\n            int goal = nums[i];\n\n            vector<int> dp(1001, 1e9);\n            dp[goal] = 0;\n            for (int k = 0; k < size(queries); k++) {\n                if (queries[k][0] <= i && i <= queries[k][1]) {\n                    for (int j = 0; j <= goal; j++) {\n                        if (j - queries[k][2] < 0) continue;\n                        if (dp[j] != (int)1e9)\n                        dp[j-queries[k][2]] = min(dp[j - queries[k][2]], k+1);\n                    }\n                }\n            }\n            cout << dp[0] << 'n';\n            if (dp[0] == (int)1e9) return -1;\n            ans = max(ans, dp[0]);\n        }\n        return ans;\n    }\n};","author":"Michael Bao","submissionId":"1575163671"},[]]},{"412":[{"id":"412","fileName":"1575163740.txt","sourceCode":"require \"set\"\n\n# @param {Integer[]} nums\n# @param {Integer[][]} queries\n# @return {Integer}\ndef min_zero_array(nums, queries)\n    return 0 if nums.all?(0)\n    num_set = Array.new(nums.size){Set[nums[_1]]}\n    queries.size.times{|i|\n        l, r, val = queries[i]\n\n        l.upto(r){|j|\n            next if num_set[j].include?(0)\n            if num_set[j].include?(val)\n                num_set[j] = Set[0]\n                next\n            end\n\n            s = Set.new\n            num_set[j].each{\n                s << _1\n                s << _1 - val if _1 > val\n            }\n            num_set[j] = s\n        }\n\n        return i + 1 if num_set.all?{_1.include?(0)}\n    }\n    -1\nend","author":"lanegue","submissionId":"1575163740"},[]]},{"413":[{"id":"413","fileName":"1575164186.txt","sourceCode":"class Solution {\npublic:\n    int get_count(const int& num, const vector<pair<int,int>>&val_idx)\n    {\n        \n        vector<int>prev(num+1,0);\n        prev[0]=1; //maskeing 0 is always possible\n        for(int j=0;j<val_idx.size();j++)\n        {\n            vector<int>cur(num+1,0);\n            cur[0]=1;\n            for(int i=1;i<=num;i++)\n            {\n                \n                cur[i] = prev[i];\n                if(i-val_idx[j].first>=0)\n                cur[i] = cur[i] || prev[i-val_idx[j].first];\n            }\n            if(cur[num]==1)\n                return val_idx[j].second;\n            swap(cur,prev);\n        }\n        return -1;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        //for each num find queries needed\n        int n = nums.size();\n        vector<vector<pair<int,int>>>val_idx(n);\n        for(int j=0;j<queries.size();j++) //1e3\n        {\n            vector<int>&q= queries[j];\n            for(int i=0;i<n;i++) //10\n            {\n                if(q[0]<=i && q[1]>=i)\n                    val_idx[i].push_back({q[2],j});\n            }\n        }\n        int max_q=-1;\n        for(int i=0;i<n;i++)\n        {\n            if(nums[i]==0)\n                continue;\n            int ct = get_count(nums[i],val_idx[i]); //returns -1 if not possible else return max q_idx to make the number\n            if(ct==-1)\n                return -1;\n            max_q = max(max_q,ct); \n        }\n        \n        return max_q+1;//max query idx+1 is count\n        \n        \n    }\n};","author":"Mridul Gupta","submissionId":"1575164186"},[]]},{"414":[{"id":"414","fileName":"1575163951.txt","sourceCode":"class Solution {\npublic:\n bool check(vector<int>&v,int target) {\n    vector<bool> dp(target + 1, false);\n    dp[0] = true;\n    for (auto it:v) {\n        for (int s = target; s >= it; s--) {\n            if (dp[s - it])\n                dp[s] = true;\n        }\n    }\n    return dp[target];\n}\n\nbool isPossible(vector<int>& nums,vector<vector<int>>& queries, int mid) {\n    int n = nums.size();\n    for (int i = 0; i < n; i++) {\n        vector<int> v;\n        for (int j = 0; j < mid; j++) {\n            int l = queries[j][0];\n            int r = queries[j][1];\n            int val = queries[j][2];\n            if (l <= i && i <= r)\n                v.push_back(val);\n        }\n        if (!check(v, nums[i]))\n            return false;\n    }\n    return true;\n}\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n         int q=queries.size();\n         int n=nums.size();\n         int low = 0;\n         int high=q;\n         int ans=-1;\n       while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (isPossible(nums, queries, mid)){\n            ans=mid;\n            high=mid-1;\n        }\n        else{\n            low = mid + 1;\n        }\n    }\n     return ans;\n    }\n};","author":"Mangalgupta","submissionId":"1575163951"},[]]},{"415":[{"id":"415","fileName":"1575164039.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n\n        int k = 0;\n\n        for(int i = 0; i < n; i++) {\n            set<int> sums = {0};\n            if(nums[i] == 0) {\n                continue;\n            }\n            int target = nums[i];\n            \n            for(int j = 0; j < m; j++) {\n                if(queries[j][0] > i || queries[j][1] < i) {\n                    continue;\n                }\n                \n                vector<int> newS = {};\n                for(int sum : sums) {\n                    newS.push_back(sum + queries[j][2]);\n                }\n\n                for(int sum : newS) {\n                    if(sum == target) {\n                        k = max(k, j + 1);\n                        goto next;\n                    }\n                    // cout << i << \": \" << sum << \" inserted into sums\" << endl;\n                    sums.insert(sum);\n                }\n            }\n\n            return -1;\n\n            next:\n        }\n\n        return k;\n    }\n};","author":"Joey Mucci","submissionId":"1575164039"},[]]},{"416":[{"id":"416","fileName":"1575164258.txt","sourceCode":"class Solution {\npublic:\n    bool isPossible(vector<int>&nums,vector<vector<int>>& queries,int k)\n{\n    int n=nums.size();\n    for (int i = 0; i < n; i++) {\n                int target = nums[i];\n                if (target == 0) continue;\n                vector<bool> dp(target + 1, false);\n                dp[0] = true;\n                for (int j = 0; j < k; j++) {\n                    int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                    if (i >= l && i <= r) {\n                        for (int t = target; t >= val; t--) {\n                            dp[t] = dp[t] || dp[t - val];\n                        }\n                    }\n                }\n                if (!dp[target])\n                    return false;\n            }\n            return true;\n}\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n         int n = nums.size();\n        int m = queries.size();\n        \n        int lo = 0, hi = m, ans = -1;\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (isPossible(nums,queries,mid)) {\n                ans = mid;\n                hi = mid - 1;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        return ans;\n        \n    }\n};","author":"shubcoder","submissionId":"1575164258"},[]]},{"417":[{"id":"417","fileName":"1575164354.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\nclass Solution {\npublic:\n    #define vi vector<int>\n    #define vvi vector<vector<int>>\n    #define pb push_back\n    #define sz(x) (int)(x).size()\n\n    bool canSumTab(int t, vi& opt) {\n        vector<int> dp(t + 1, 0); \n        dp[0] = 1;\n        for (int num : opt) {\n            for (int j = t; j >= num; j--) {\n                dp[j] = dp[j] || dp[j - num];\n            }\n        }\n        return dp[t];\n    }\n\n    bool isPossible(vi& arr, vvi& mod, int lim) {\n        vi temp = arr;\n        int n = sz(arr);\n        vvi ch(n);\n       \n\n        for (int i = 0; i < lim; i++) {\n            int l = mod[i][0], r = mod[i][1], v = mod[i][2];\n            for (int j = l; j <= r; j++) {\n                ch[j].pb(v);\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (!temp[i]) continue;\n            if (!canSumTab(temp[i], ch[i])) return false;\n        }\n        return true;\n    }\n\n    int minZeroArray(vi& arr, vvi& mod) {\n        int l = 0, r = sz(mod), ans = -1;\n        while (l <= r) {\n            int m = l + (r - l) / 2;\n            if (isPossible(arr, mod, m)) {\n                ans = m;\n                r = m - 1;\n            } else {\n                l = m + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"Deepak_22100","submissionId":"1575164354"},[]]},{"418":[{"id":"418","fileName":"1575164220.txt","sourceCode":"class Solution {\npublic:\n    bool isSumPossible(const vector<int>& arr, int target) {\n        if(target < 0) return false;\n        vector<bool> dp(target + 1, false);\n        dp[0] = true;\n        for (int num : arr)\n            for (int j = target; j >= num; j--)\n                dp[j] = dp[j] || dp[j - num];\n        return dp[target];\n    }\n    bool check(vector<int>& nums, vector<vector<int>>& queries, int k) {\n        int n = nums.size();\n        vector<vector<int>> dp(n);\n        for (int i = 0; i < k; i++)\n            for (int j = queries[i][0]; j <= queries[i][1]; j++)\n                dp[j].push_back(queries[i][2]);\n        for (int i = 0; i < n; i++)\n            if (!isSumPossible(dp[i], nums[i]))\n                return false;\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int low = 0, high = queries.size(), ans = -1;\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (check(nums, queries, mid)) {\n                ans = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"Krrish Chanchal","submissionId":"1575164220"},[]]},{"419":[{"id":"419","fileName":"1575164000.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        List<List<int[]>> queriesForJ = new ArrayList<>();\n        for (int j = 0; j < n; j++) {\n            List<int[]> list = new ArrayList<>();\n            for (int i = 0; i < queries.length; i++) {\n                int l = queries[i][0];\n                int r = queries[i][1];\n                if (j >= l && j <= r) {\n                    int val = queries[i][2];\n                    list.add(new int[]{i, val});\n                }\n            }\n            queriesForJ.add(list);\n        }\n\n        int maxK = -1;\n        for (int j = 0; j < n; j++) {\n            int target = nums[j];\n            if (target == 0) {\n                continue;\n            }\n\n            List<int[]> qs = queriesForJ.get(j);\n            if (qs.isEmpty()) {\n                return -1;\n            }\n\n            Map<Integer, Integer> dp = new HashMap<>();\n            dp.put(0, -1);\n\n            for (int[] q : qs) {\n                int originalIndex = q[0];\n                int val = q[1];\n                List<Integer> sums = new ArrayList<>(dp.keySet());\n                for (int s : sums) {\n                    int newSum = s + val;\n                    int currentMaxIndex = dp.get(s);\n                    int newMaxIndex = Math.max(currentMaxIndex, originalIndex);\n                    if (!dp.containsKey(newSum) || newMaxIndex < dp.getOrDefault(newSum, Integer.MAX_VALUE)) {\n                        dp.put(newSum, newMaxIndex);\n                    }\n                }\n            }\n\n            if (!dp.containsKey(target)) {\n                return -1;\n            }\n\n            int k_j = dp.get(target);\n            maxK = Math.max(maxK, k_j + 1);\n        }\n\n        return maxK == -1 ? 0 : maxK;\n    }\n}","author":"Laxmikant Mahindrakar","submissionId":"1575164000"},[]]},{"420":[{"id":"420","fileName":"1575164365.txt","sourceCode":"/********************************************\n * author : Jie Chen (4rd Year CS)\n * school : Rochester Institute of Technology\n * created: 03.15.2025 22:46:25\n*********************************************/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef BROKEN_CODE\n#include <bits/lc_parser.h>\n#include <bits/debug.h>\n#else\n#define dbg(...) 10082002\n#define dbp(...) \"Need Internship\"\n#endif\n\nusing i64 = long long;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& queries) {\n        int n = a.size(), m = queries.size();\n\n        vector<vector<int>> dp(n);\n        for (int i = 0; i < n; i++) {\n            dp[i].resize(a[i] + 1);\n            dp[i][0] = 1;\n        }\n\n        if (ranges::all_of(dp, [&](const auto& f) {\n            return f.back() == 1;\n        })) {\n            return 0;\n        }\n\n        for (int i = 0; i < m; i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int v = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                for (int k = a[j] - v; k >= 0; k--) {\n                    if (dp[j][k]) {\n                        dp[j][k + v] = 1;\n                    }\n                }\n            }\n            if (ranges::all_of(dp, [&](const auto& f) {\n                return f.back() == 1;\n            })) {\n                return i + 1;\n            }\n        }\n\n        return -1;\n    }\n};\n\n#ifdef BROKEN_CODE\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    exec(&Solution::JustJie); // CHANGE FOR PROBLEM\n}\n#endif\n\n// ~ JustJie","author":"Jie Chen","submissionId":"1575164365"},[]]},{"421":[{"id":"421","fileName":"1575164453.txt","sourceCode":"class Solution {\n    bool canAchieveZero(int k, const vector<int>& arr, const vector<vector<int>>& ranges, int n) {\n        for (int j = 0; j < n; j++) {\n            vector<bool> dp(1001, false);\n            dp[0] = true;\n            for (int i = 0; i < k; i++) {\n                if (j >= ranges[i][0] && j <= ranges[i][1]) {\n                    for (int s = 1000 - ranges[i][2]; s >= 0; s--) {\n                        if (dp[s]) dp[s + ranges[i][2]] = true;\n                    }\n                }\n            }\n            if (!dp[arr[j]]) return false;\n        }\n        return true;\n    }\npublic:\n\n    int minZeroArray(vector<int>& arr, vector<vector<int>>& ranges) {\n        int length = arr.size(), numQueries = ranges.size();\n        int startt = 0, endd = numQueries, result = -1;\n        \n        while (startt <= endd) {\n            int middle = startt +(-startt + endd) / 2;\n            if (canAchieveZero(middle, arr, ranges, length)) {\n                result = middle;\n                endd = middle - 1;\n            } else {\n                startt = middle + 1;\n            }\n        }\n        return result;\n    }\n};\n","author":"Paras Yerunkar","submissionId":"1575164453"},[]]},{"422":[{"id":"422","fileName":"1575164687.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& ar, vector<vector<int>>& q) {\n        int n = ar.size(), m = q.size();\n        if(*max_element(ar.begin(), ar.end()) == 0) return 0;\n        vector<bitset<1001>> dp(n);\n        for (int j = 0; j < n; j++){\n            dp[j].reset();\n            dp[j].set(0);\n        }\n        for (int i = 0; i < m; i++){\n            int l = q[i][0], r = q[i][1], vali = q[i][2];\n            for (int j = l; j <= r; j++){\n                dp[j] |= (dp[j] << vali);\n            }\n            bool allZero = true;\n            for (int j = 0; j < n; j++){\n                if (ar[j] <= 1000 && !dp[j].test(ar[j])) {\n                    allZero = false;\n                    break;\n                }\n            }\n            if (allZero)\n                return i + 1;\n        }\n        return -1;\n    }\n    \n    \n};","author":"Abdulla bin ah","submissionId":"1575164687"},[]]},{"423":[{"id":"423","fileName":"1575164097.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        reached = [num == 0 for num in nums]\n        queues = [{num} for num in nums]\n        if all(reached): return 0\n        \n        for k, (l, r, val) in enumerate(queries):\n            for i, num in enumerate(nums):\n                if not l <= i <= r or reached[i]:\n                    continue\n                if val in queues[i]:\n                    reached[i] = True\n                if not reached[i]:\n                    new = set()\n                    for num in queues[i]:\n                        if val < num:\n                            new.add(num - val)\n                    queues[i] |= new\n\n            if all(reached):\n                return k + 1\n\n        return -1","author":"edbltn","submissionId":"1575164097"},[]]},{"424":[{"id":"424","fileName":"1575164350.txt","sourceCode":"class Solution {\n    bool rec(auto& dp, auto& sub, int tar, int val){\n        if(tar == 0) return true;\n        if(tar < 0) return false;\n        if(val > 10) return false;\n        if(dp[val][tar] != -1) return dp[val][tar];\n        for(int i=0;i<=sub[val];i++){\n            if(rec(dp, sub, tar - i*val, val+1)) return true;\n        }\n        \n        return dp[val][tar] = false;\n    }\n    \n    bool check(auto& nums, auto& q, int k){\n        int n = nums.size();\n        vector<vector<int>> sub(n, vector<int>(11, 0));\n        for(int i=0;i<k;i++){\n            for(int j=q[i][0];j<=q[i][1];j++){\n                sub[j][q[i][2]]++;\n            }\n        }\n        \n        for(int i=0;i<n;i++){\n            vector<vector<int>> dp(11, vector<int>(1001, -1));\n            if(!rec(dp, sub[i], nums[i], 1)) return false;\n        }\n        \n        return true;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l=0, r=queries.size(), m;\n        while(l<=r){\n            m = (l+r)>>1;\n            if(check(nums, queries, m)) r=m-1;\n            else l=m+1;\n        }\n        \n        return (l==queries.size()+1? -1 : l);\n    }\n};","author":"Ayush Gupta","submissionId":"1575164350"},[]]},{"425":[{"id":"425","fileName":"1575164705.txt","sourceCode":"class Solution {\npublic:\n    bool check(long long target, long long idx, vector<vector<int> > &queries, long long k){\n        vector<long long> coins;\n        if(k == queries.size()+1)\n            return false;\n        for(int i = 0; i < k; i++){\n            if(queries[i][0] <= idx && queries[i][1] >= idx){\n                coins.push_back(queries[i][2]);\n            }\n        }\n        \n        vector<bool> dp(target+1);\n        dp[0] = true;\n        for(int i = 0; i < coins.size(); i++){\n            for(int j = target; j - coins[i] >= 0; j--){\n                if(dp[j - coins[i]])\n                    dp[j] = true;\n            }\n            if(dp[target])\n                return true;\n        }\n        return false;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        bool flag = false;\n        for(int i = 0; i < nums.size(); i++){\n            if(nums[i] != 0){\n                flag = true;\n                break;\n            }\n        }\n        if(!flag)\n            return 0;\n        \n        long long ans = INT_MIN;\n        for(int i = 0; i < nums.size(); i++){\n            long long l = 0, r = queries.size()+1;\n            \n            while(l < r){\n                long long mid = (l + r) / 2;\n                if(check(nums[i], i, queries, mid))\n                    r = mid;\n                else l = mid+1;\n            }\n            \n            if(l == queries.size()+1)\n                return -1;\n            ans = max(ans, l);\n        }\n        return ans;\n    }\n};","author":"sellie50759","submissionId":"1575164705"},[]]},{"426":[{"id":"426","fileName":"1575164734.txt","sourceCode":"from collections import defaultdict\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def check(idx, max_queries):\n            vals = []\n            for i in range(max_queries):\n                l, r, val = queries[i]\n                if l <= idx <= r:\n                    vals.append(val)\n\n            target = nums[idx]\n            if not vals:\n                return target == 0\n            dp = {0}\n            for v in vals:\n                new_dp = dp | {x + v for x in dp}\n                dp = new_dp\n                if target in dp:\n                    return True\n            return False\n\n        n = len(nums)\n        ans = 0\n\n        for idx in range(n):\n            lo, hi = 0, len(queries)\n            curr = -1\n\n            while lo <= hi:\n                mid = (lo + hi) // 2\n                if check(idx, mid):\n                    curr = mid\n                    hi = mid - 1\n                else:\n                    lo = mid + 1\n\n            if curr == -1:\n                return -1\n            ans = max(ans, curr)\n\n        return ans\n","author":"bluehue","submissionId":"1575164734"},[]]},{"427":[{"id":"427","fileName":"1575164757.txt","sourceCode":"class Solution {\npublic:\n\n    // bool pos(vector<int> nums, vector<vector<int>> &queries, int k){\n    //     int n = nums.size();\n    //     vector<int> cur(n);\n    //     for(int i=0;i<=k;i++){\n    //         cur[queries[i][0]]-=queries[i][2];\n    //         if(queries[i][1]<n-1) cur[queries[i][1]+1]+=queries[i][2];\n    //     }\n    //     bool ca = true;\n    //     for(int i=0;i<n;i++){\n    //         if(i>0) cur[i]+=cur[i-1];\n    //         nums[i]+=cur[i];\n    //         nums[i] = max(nums[i], 0);\n    //         ca&=nums[i]==0;\n    //     }\n    //     return ca;\n    // }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        bool done = true;\n        for(int i=0;i<n;i++){\n            done&=nums[i]==0;\n        }\n        if(done) return 0;\n        \n        vector<bitset<1001>> x(n);\n        for(int i=0;i<n;i++){\n            x[i][0] = 1;\n        }\n\n        for(int i=0;i<m;i++){\n            done = true;\n            for(int j=0;j<n;j++){\n                if(j>=queries[i][0] && j<=queries[i][1]){\n                    x[j]|=x[j]<<queries[i][2];\n                }\n                done&=x[j][nums[j]];\n            }\n            if(done) return i+1;\n        }\n        return -1;\n    }\n};","author":"Parag Goyal","submissionId":"1575164757"},[]]},{"428":[{"id":"428","fileName":"1575164801.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        BitSet[] dp = new BitSet[n];\n\n        // Initialize dp array\n        for (int j = 0; j < n; j++) {\n            dp[j] = new BitSet(1001);\n            dp[j].set(0, true);\n        }\n\n        // Check if all elements are zero\n        boolean allZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) return 0;\n\n        // Process queries\n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n                BitSet shifted = (BitSet) dp[j].clone();\n                shifted = shiftLeft(shifted, v);\n                dp[j].or(shifted);\n\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp[j].clear(pos);\n                }\n            }\n\n            // Check if all nums[j] are achieved\n            boolean allAchieved = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j].get(nums[j])) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n\n            if (allAchieved) return k + 1;\n        }\n\n        return -1;\n    }\n\n    // Helper function to shift BitSet left by a given value\n    private BitSet shiftLeft(BitSet bs, int shift) {\n        BitSet shifted = new BitSet(bs.length());\n        for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {\n            if (i + shift < 1001) {\n                shifted.set(i + shift);\n            }\n        }\n        return shifted;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        int[] nums = {1, 2, 3, 4, 5};\n        int[][] queries = {\n            {0, 2, 1},\n            {1, 4, 2}\n        };\n        System.out.println(sol.minZeroArray(nums, queries)); // Example call\n    }\n}\n","author":"29hAAX7v41","submissionId":"1575164801"},[]]},{"429":[{"id":"429","fileName":"1575165130.txt","sourceCode":"def solve1(k,l):\n    if k==0:\n        return True\n    if k>sum(l):\n        return False\n    n=len(l)\n    s=sum(l)\n    dp=[[0]*(s+1) for i in range(n+1)]\n    for i in range(n+1):\n        dp[i][0]=1\n    for i in range(1,n+1):\n        for j in range(1,s+1):\n            dp[i][j]=max(dp[i-1][j],dp[i-1][j-l[i-1]])\n    return dp[n][k]\n    \ndef solve(k,nums,queries):\n    pre=[[] for i in range(len(nums)+1)]\n    for i in queries[:k]:\n        for j in range(i[0],i[1]+1):\n            pre[j].append(i[2])\n    for i in range(len(pre)):\n        pre[i].sort()\n    for i in range(len(nums)):\n        if not solve1(nums[i],pre[i]):\n            return False\n    return True\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        low=0\n        high=len(queries)\n        ans=-1\n        while low<=high:\n            mid=(low+high)//2\n            v=solve(mid,nums,queries)\n            if v:\n                ans=mid\n                high=mid-1\n            else:\n                low=mid+1\n        return ans","author":"vek0r","submissionId":"1575165130"},[]]},{"430":[{"id":"430","fileName":"1575165300.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int low=-1; int high=queries.length-1; int ans=-1;\n        while(low<=high){\n            int mid=low+(high-low)/2;\n            if(solve(nums,queries,mid)){\n                ans=mid+1;\n                high=mid-1;\n            }\n            else low=mid+1;\n        }\n        return ans;\n    }\n    \n    public boolean solve(int nums[],int[][] q,int k){\n        int n=nums.length; \n        for(int i=0;i<n;i++){\n            //by using k queries whether will i make the nums[i] or not \n            //TC: n*k*k*(logK)\n            Boolean dp[][]=new Boolean[k+1][nums[i]+1];\n            if(!solve(0,k,nums[i],i,q,dp))\n            return false;\n        }\n        return true;\n    }\n    \n    public boolean solve(int currIdx,int k,int num,int numIdx,int q[][],Boolean dp[][]){\n        if(num==0)return true;\n        if(currIdx>k)return false;\n        if(dp[currIdx][num]!=null)return dp[currIdx][num];\n        int l=q[currIdx][0]; int r=q[currIdx][1]; int val=q[currIdx][2];\n        boolean flag=solve(currIdx+1,k,num,numIdx,q,dp);\n        if(flag)return dp[currIdx][num]=true;\n        if(numIdx>=l&&numIdx<=r&&(num-val>=0))flag|=solve(currIdx+1,k,num-val,numIdx,q,dp);\n        return dp[currIdx][num]=flag;\n    }\n}","author":"tinku_vishnu17","submissionId":"1575165300"},[]]},{"431":[{"id":"431","fileName":"1575165308.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        dp = [[False] * (nums[i] + 1) for i in range(n)]\n        for i in range(n):\n            dp[i][0] = True\n\n        _sum = [0] * n\n        for k in range(len(queries) + 1):\n            if k > 0:\n                l, r, val = queries[k - 1]\n                for i in range(l, r + 1):\n                    _sum[i] += val\n                    for j in range(nums[i], val - 1, -1):\n                        dp[i][j] |= dp[i][j - val]\n            if all(dp[i][nums[i]] for i in range(n)):\n                return k\n        return -1","author":"TODD YANG","submissionId":"1575165308"},[]]},{"432":[{"id":"432","fileName":"1575164621.txt","sourceCode":"class Solution {\npublic:\n    long long minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\n        int maxx = *max_element(nums.begin(), nums.end());\n        if(maxx == 0) return 0;\n        \n        long long n = nums.size();\n        long long Q = queries.size();\n        \n        vector<long long> minK(n, -1);\n\n        for(long long i=0; i<n; i++){\n\n            vector<bool> dp(nums[i] + 1, false);\n            dp[0] = true;\n                \n            for(long long q=0; q<Q; q++){\n\n                if(i < queries[q][0] or i > queries[q][1]) continue;\n\n                long long val = queries[q][2];\n\n                for(long long x=dp.size() - 1; x >= 0; x--){\n                    if(x + val < dp.size() and dp[x])\n                        dp[x + val] = true; \n                }\n\n                if(dp[nums[i]]){\n                    minK[i] = q + 1;\n                    break;\n                }\n            }\n\n            // cout<<minK[i]<<endl;\n            if(minK[i] == -1) return -1;\n        }\n\n        return *max_element(minK.begin(), minK.end());\n    }\n};","author":"Arjun S","submissionId":"1575164621"},[]]},{"433":[{"id":"433","fileName":"1575165612.txt","sourceCode":"class Solution {\npublic:\n    bool somegoofyfunxtionwhichhelps(vector<int>& nums, vector<vector<int>>& copyquery, int k) {\n        int n = nums.size();\n        for (int index2 = 0; index2 < n; index2++) {\n            bitset<1001> memorization;\n            memorization[0] = 1;\n            for (int index1 = 0; index1 < k; index1++) {\n                int wingardium = copyquery[index1][0], leviosa = copyquery[index1][1], themaincharacter = copyquery[index1][2];\n                if (wingardium <= index2 && index2 <= leviosa) memorization |= (memorization << themaincharacter);\n            }\n            if (!memorization.test(nums[index2])) return false;\n        }\n        return true;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ueueue = queries.size();\n        vector<vector<int>> copyquery = queries;\n        if (!somegoofyfunxtionwhichhelps(nums, copyquery, ueueue))return -1;\n        int low = 0, high = ueueue;\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            if (somegoofyfunxtionwhichhelps(nums, copyquery, mid)) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n};\n","author":"Jai Khanna","submissionId":"1575165612"},[]]},{"434":[{"id":"434","fileName":"1575165626.txt","sourceCode":"class Solution {\npublic:\n    bool isPossible(int x,vector<int> &v){\n        if (x == 0) return true;\n        vector<bool> dp(x + 1, false);\n        dp[0] = true; \n        for (int num : v) {\n            for (int i = x; i >= num; i--) {\n                if (dp[i - num]) {\n                    dp[i] = true;\n                }\n            }\n        }\n        return dp[x];\n    }\n    bool isValid(int k,vector<int> &v,vector<vector<int>> &q){\n        vector<vector<int>> dp(v.size());\n\n        for(int i=0;i<k;i++){\n            for(int j=q[i][0];j<=q[i][1];j++){\n                dp[j].push_back(q[i][2]);\n            }\n        }\n\n        for(int i=0;i<dp.size();i++){\n            if(!isPossible(v[i],dp[i])){\n                return false;\n            }\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& v, vector<vector<int>>& q) {\n        int cnt=0;\n        for(int i=0;i<v.size();i++){\n            if(v[i]==0) cnt++;\n        }\n        if(cnt==v.size()) return 0;\n        int s=1,e=q.size();\n        int ans=-1;\n        while(s<=e){\n            int mid=s+(e-s)/2;\n            if(isValid(mid,v,q)){\n                ans=mid;\n                e=mid-1;\n            }else s=mid+1;\n        }\n        return ans;\n    }\n};","author":"whiz_guy","submissionId":"1575165626"},[]]},{"435":[{"id":"435","fileName":"1575165554.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n\n        if (reduce(nums.begin(), nums.end(), 0) == 0) return 0;\n\n        int left = 1;\n        int right = m;\n\n        auto check = [&](int k) -> bool {\n            // [0, k)\n            vector<vector<int>> vc(n);\n            for (int i = 0; i < k; ++i) {\n                int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n                for (int j = l; j <= r; ++j) {\n                    vc[j].push_back(v);\n                }\n            }\n            // knapsack for every index\n            \n            auto knapsack = [&](int index) -> bool {\n                int ks = vc[index].size();\n                vector<vector<bool>> dp(ks + 1, vector<bool>(nums[index] + 1, false));\n                dp[0][0] = true;\n                for (int i = 0; i < ks; ++i) {\n                    dp[i + 1][0] = true;\n                    for (int j = 0; j < nums[index]; ++j) {\n                        dp[i + 1][j + 1] = dp[i][j + 1];\n                        if (vc[index][i] <= j + 1) dp[i + 1][j + 1] = dp[i + 1][j + 1] || dp[i][j + 1 - vc[index][i]];\n                    }\n                }\n                return dp[ks][nums[index]];\n            };\n            for (int i = 0; i < n; ++i) {\n                if (nums[i] == 0) continue;\n                if (!knapsack(i)) return false;\n            }\n            return true;\n        };\n        \n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (check(mid)) right = mid - 1;\n            else left = mid + 1;\n        }\n        if (left == m + 1) return -1;\n        return left;\n    }\n};\n","author":"jackey","submissionId":"1575165554"},[]]},{"436":[{"id":"436","fileName":"1575165816.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<int> arr(n, m + 1); \n        \n        for (int i = 0; i < n; ++i) {\n            int target = nums[i];\n            if (target == 0) {\n                arr[i] = 0;\n                continue;\n            }\n            vector<bool> dp(target + 1, false);\n            dp[0] = true;\n            arr[i] = m + 1; \n            \n            for (int j = 0; j < m; ++j) {\n                auto& q = queries[j];\n                int l = q[0], r = q[1], val = q[2];\n                if (i < l || i > r) {\n                    continue;\n                }\n                \n                vector<bool> new_dp = dp; \n                for (int s = 0; s <= target - val; ++s) {\n                    if (dp[s]) {\n                        new_dp[s + val] = true;\n                    }\n                }\n                dp = new_dp; \n                \n                if (dp[target]) {\n                    if (j + 1 < arr[i]) {\n                        arr[i] = j + 1;\n                    }\n                }\n            }\n            \n            if (!dp[target]) {\n                return -1;\n            }\n        }\n        \n        int result = *max_element(arr.begin(), arr.end());\n        return result <= m ? result : -1;\n    }\n};","author":"Kuldeep","submissionId":"1575165816"},[]]},{"437":[{"id":"437","fileName":"1575165729.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length, q = queries.length;\n        int low = 0; int high = q;\n        int res = -1;\n        while(low<=high){\n            int mid = (low+high)/2;\n            if(isPos(mid,nums,queries,n,q)){\n                res = mid;\n                high = mid-1;\n            }else{\n                low = mid+1;\n            }\n        }\n        return res;\n    }\n    \n    boolean isPos(int k, int nums[], int queries[][], int n, int q){\n        List<List<Integer>> list = new ArrayList<>();\n        for(int i=0; i<n; i++){\n            list.add(new ArrayList<>());\n        }\n        for(int i=0; i<k; i++){\n            for(int j=queries[i][0]; j<=queries[i][1]; j++){\n                list.get(j).add(queries[i][2]);\n            }\n        }\n        boolean flag = true;\n        for(int i=0; i<n; i++){\n            if(nums[i]==0) continue;\n            if(!isSum(list.get(i),nums[i],0)){\n                flag = false;\n            }\n        }\n        return flag;\n    }\n    \n    boolean isSum(List<Integer> list, int val, int idx) {\n        boolean[] dp = new boolean[val + 1];\n        dp[0] = true;\n\n        for (int num : list) {\n            for (int j = val; j >= num; j--) {\n                dp[j] |= dp[j - num];\n            }\n        }\n\n        return dp[val];\n    }\n}\n\n","author":"Rishabh Kumrawat","submissionId":"1575165729"},[]]},{"438":[{"id":"438","fileName":"1575165843.txt","sourceCode":"class Solution {\npublic:\n    bool helper(int x, vector<int>& nums, vector<vector<int>>& queries) {\n        vector<vector<int>> v(nums.size());\n        for (int i=0;i<x;i++) {\n            auto &it=queries[i];\n            for (int j = it[0]; j <= it[1]; j++)\n                v[j].push_back(it[2]);\n        }\n\n        for (int i = 0; i < nums.size(); i++) {\n            vector<int> dp(nums[i] + 1, 0);\n            dp[0] = 1;\n            int maxi = nums[i];\n            for (auto it : v[i]) {\n                for (int j = maxi - it; j >= 0; j--) {\n                    dp[j + it] = max(dp[j], dp[j + it]);\n                }\n            }\n            if (dp[nums[i]] == 0)\n                return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l=0, r=queries.size();\n        while(r-l>1)\n            {\n                int mid=(l+r)/2;\n                if(helper(mid, nums, queries))\n                    r=mid;\n                else\n                    l=mid;\n            }\n\n        if(helper(l, nums, queries))\n            return l;\n        else if(helper(r, nums, queries))\n            return r;\n        else\n            return -1;\n    }\n};","author":"Soumyadipto Pal","submissionId":"1575165843"},[]]},{"439":[{"id":"439","fileName":"1575165824.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if all(x == 0 for x in nums):\n            return 0\n        vm = (nums, queries)\n        n = len(nums)\n        dp = [1] * n\n        for j, (a, b, v) in enumerate(queries):\n            for i in range(n):\n                if a <= i <= b:\n                    dp[i] |= dp[i] << v\n            if all((dp[i] >> nums[i]) & 1 for i in range(n)):\n                return j + 1\n        return -1\n","author":"black_pather123","submissionId":"1575165824"},[]]},{"440":[{"id":"440","fileName":"1575166252.txt","sourceCode":"class Solution {\n    int MAX;\n    private int helper(int sum,int i,int[][] dp,List<int[]> a){\n        if(sum==0)return 0;\n        if(i>=a.size())return MAX;\n        if(dp[sum][i]!=-1)return dp[sum][i];\n\n        if(sum-a.get(i)[0]<0){\n            return dp[sum][i] = helper(sum,i+1,dp,a);\n        }\n        if(sum-a.get(i)[0]==0){\n            return dp[sum][i] = a.get(i)[1];\n        }\n\n        return dp[sum][i] = Math.min(helper(sum-a.get(i)[0],i+1,dp,a),helper(sum,i+1,dp,a));\n    }\n    public int minZeroArray(int[] nums, int[][] q) {\n        MAX = q.length+1;\n        List<List<int[]>> l = new ArrayList<>();\n\n        int n = nums.length;\n        for(int i=0;i<n;i++){\n            l.add(new ArrayList<>());\n        }\n\n        int k = 0;\n        for(int[] qq:q){\n            for(int j=qq[0];j<=qq[1];j++){\n                l.get(j).add(new int[]{qq[2],k+1});\n            }\n            k++;\n        }\n\n        // for(int i=0;i<n;i++){\n        //     for(int[] v:l.get(i)){\n        //         System.out.print(\"[\"+v[0]+\" \"+v[1]+\"]\");\n        //     }\n        //     System.out.println();\n        // }\n        int ans = -1;\n        boolean f = true;\n        for(int i=0;i<n;i++){\n            int[][] dp = new int[nums[i]+2][l.get(i).size()];\n            for(int j=0;j<=nums[i];j++){\n                Arrays.fill(dp[j],-1);\n            }\n            \n            int v = helper(nums[i],0,dp,l.get(i));\n            // System.out.println(v);\n            if(v==MAX){\n                f = false;\n                break;\n            }\n            \n            ans = Math.max(ans,v);\n        }\n        if(!f)return -1;\n        \n        return ans;\n    }\n}","author":"Pavan D Naik","submissionId":"1575166252"},[]]},{"441":[{"id":"441","fileName":"1575166314.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int[][] arr = new int[nums.length][queries.length];\n        int max = 0;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = 0; j < queries.length; j++) {\n                if (i >= queries[j][0] && i <= queries[j][1]) {\n                    arr[i][j] = queries[j][2];\n                }\n            }\n\n            int[][] dp = new int[nums[i] + 1][queries.length];\n            for (int j = 1; j <= nums[i]; j++) {\n                for (int k = queries.length - 1; k >= 0; k--) {\n                    if (arr[i][k] == j) {\n                        dp[j][k] = k + 1;\n                        continue;\n                    } \n                    if (k == queries.length - 1) {\n                        dp[j][k] = Integer.MAX_VALUE;\n                        continue;\n                    }\n                    if (arr[i][k] < j) {\n                        dp[j][k] = Math.min(dp[j - arr[i][k]][k + 1], dp[j][k + 1]);\n                    } else {\n                        dp[j][k] = dp[j][k + 1];\n                    }\n                }\n            }\n            max = Math.max(max, dp[nums[i]][0]);\n        }\n\n        return max == Integer.MAX_VALUE ? -1 : max;\n    }\n}\n\n/** \n\n1 - 2 5 1\n2 -\n3 - 2 3 1\n\n\n*/","author":"Tianqi","submissionId":"1575166314"},[]]},{"442":[{"id":"442","fileName":"1575166950.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int MAX = *std::max_element(nums.begin(), nums.end());\n        if (MAX == 0) return 0;\n        std::vector<std::vector<int> > dp(n, std::vector<int>(MAX + 1, 0));\n        \n        for (int i = 0; i < n; i++) {\n            dp[i][nums[i]] = 1;\n        }\n        for (int k = 0; k < queries.size(); k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int val = queries[k][2];\n            for (int i = l; i <= r; i++) {\n                for (int j = 0; j < MAX + 1; j++) {\n                    dp[i][j] |= (j + val < MAX + 1 ? dp[i][j + val] : 0);\n                }\n            }\n            bool ok = true;\n            for (int i = 0; i < n; i++) {\n                ok &= dp[i][0];\n            }\n            if (ok) {\n                return k + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"Kai Chen","submissionId":"1575166950"},[]]},{"443":[{"id":"443","fileName":"1575165982.txt","sourceCode":"class Solution:\n    def minZeroArray(self, roh: List[int], vir: List[List[int]]) -> int:\n        cur = 1\n        temp = 3\n        varr = 7\n        var = (roh, vir)\n        cur += 2\n        temp += 6\n        varr += 14\n        abd = len(roh)\n        kar = len(vir)  \n        def vij(sid: int) -> bool:\n            cur = 4\n            temp = 12\n            varr = 28\n            for ash in range(abd):\n                cur += 5\n                temp += 15\n                varr += 35\n                dak = 1\n                cur += 6\n                temp += 18\n                varr += 42\n                for qin in vir[:sid]:\n                    cur += 7\n                    temp += 21\n                    varr += 49\n                    if qin[0] <= ash <= qin[1]:\n                        cur += 8\n                        temp += 24\n                        varr += 56\n                        jug = qin[2]\n                        cur += 9\n                        temp += 27\n                        varr += 63\n                        dak |= (dak << jug)\n                        cur += 10\n                        temp += 30\n                        varr += 70\n                if ((dak >> roh[ash]) & 1) == 0:\n                    cur += 11\n                    temp += 33\n                    varr += 77\n                    return False\n            return True   \n        sam = 0\n        cur += 12\n        temp += 36\n        varr += 84\n        nit = kar + 1\n        cur += 13\n        temp += 39\n        varr += 91\n        ans = kar + 1\n        cur += 14\n        temp += 42\n        varr += 98   \n        while sam < nit:\n            cur += 15\n            temp += 45\n            varr += 105\n            sid = (sam + nit) // 2\n            cur += 16\n            temp += 48\n            varr += 112\n            if vij(sid):\n                cur += 17\n                temp += 51\n                varr += 119\n                ans = sid\n                cur += 18\n                temp += 54\n                varr += 126\n                nit = sid\n                cur += 19\n                temp += 57\n                varr += 133\n            else:\n                cur += 20\n                temp += 60\n                varr += 140\n                sam = sid + 1\n                cur += 21\n                temp += 63\n                varr += 147\n        \n        return -1 if ans > kar else ans","author":"dom7070","submissionId":"1575165982"},[]]},{"444":[{"id":"444","fileName":"1575167010.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        if (!check(nums, queries, queries.size())) return -1;\n        \n        int l = 0, r = queries.size();\n        while (l < r) {\n            int m = l + (r - l) / 2;\n            if (check(nums, queries, m)) r = m;\n            else l = m + 1;\n        }\n        return l;\n    }\nprivate:\n    bool check(vector<int>& nums, vector<vector<int>>& queries, int k) {\n        vector<vector<int>> values(nums.size());\n        for (int i = 0; i < k; i++) {\n            int& l = queries[i][0];\n            int& r = queries[i][1];\n            int& val = queries[i][2];\n            for (int j = l; j <= r; j++) values[j].push_back(val);\n        }\n\n        for (int i = 0; i < nums.size(); i++) {\n            if (!makeZero(nums[i], values[i])) return false;\n        }\n        return true;\n    }\n    bool makeZero(int num, vector<int>& vals) {\n        vector<bool> dp(num + 1, false);\n        dp[0] = true;\n        for (auto& val : vals) {\n            for (int j = num; (j - val) >= 0; j--) {\n                dp[j] = dp[j] || dp[j - val];\n            }\n        }\n        return dp[num];\n    }\n};","author":"Pepe","submissionId":"1575167010"},[]]},{"445":[{"id":"445","fileName":"1575167033.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        # find min k such that subset of the first k queries\n        # is exactly nums[i]\n        ans = inf\n        l, r = 0, len(queries)\n\n        def check(mid):\n            # 2sum on each idx dafuq??!!\n            good = 0\n            for i in range(n):\n                target = nums[i]\n                if target==0: \n                    good += 1\n                    continue\n                vals = []\n                for j in range(mid):\n                    l, r, val = queries[j]\n                    if l <= i <= r:\n                        vals.append(val)\n                dp = {0: True}  # We can always reach 0\n                \n                for val in vals:\n                    for curr_sum in list(dp.keys()):\n                        new_sum = curr_sum + val\n                        if new_sum <= target:\n                            dp[new_sum] = True\n                \n                # If we can't exactly reach target, return False\n                if target in dp:\n                    good += 1\n                \n            \n            return good == n\n                \n        \n        while l <= r:\n            mid = (l + r) // 2\n            if check(mid):\n                ans = mid\n                r = mid - 1\n            else:\n                l = mid + 1\n                \n        return ans if ans != inf else -1","author":"monkeylogic","submissionId":"1575167033"},[]]},{"446":[{"id":"446","fileName":"1575167034.txt","sourceCode":"class Solution {\npublic:\n    bool isValid(vector<int>& nums, int n, vector<vector<int>>& queries, int k) {\n        for (int i = 0; i < n; i++) {\n            int val = nums[i];\n            vector<int> v;\n            for (int j = 0; j < k; j++) {\n                if (queries[j][0] <= i && queries[j][1] >= i)\n                    v.push_back(queries[j][2]);\n            }\n            int sum_available = 0;\n            for (int x : v)\n                sum_available += x;\n            if (sum_available < val)\n                return false;\n            \n            vector<int> dp(val + 1, 0);\n            dp[0] = 1;\n            for (int j = 0; j < v.size(); j++) {\n                for (int t = val; t >= v[j]; t--) {\n                    dp[t] = dp[t] || dp[t - v[j]];\n                }\n            }\n            if (!dp[val])\n                return false;\n        }\n        return true;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int q = queries.size();\n        int low = 0, high = q, res = -1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (isValid(nums, nums.size(), queries, mid)) {\n                res = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return res;\n    }\n};","author":"Bhavik Bharambe","submissionId":"1575167034"},[]]},{"447":[{"id":"447","fileName":"1575166619.txt","sourceCode":"class Solution {\n    bool subsetSum(vector<int>& values, int target) {\n        int n = values.size();\n        vector<bool> dp(target + 1, false);\n        dp[0] = true; \n\n        for (int val : values) {\n            for (int j = target; j >= val; j--) {\n                dp[j] = dp[j] || dp[j - val];\n            }\n        }\n        return dp[target];\n    }\n\n    bool check(int k, vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> mp; \n\n        for (int i = 0; i < k; i++) {\n            int l = queries[i][0], h = queries[i][1], val = queries[i][2];\n            for (int j = l; j <= h; j++) {\n                mp[j].push_back(val);\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (nums[i] > 0) {\n                if (mp[i].empty() || !subsetSum(mp[i], nums[i])) {\n                    return false; \n                }\n            }\n        }\n        return true;\n    }\n\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l = 0, h = queries.size(), ans = -1;\n        \n        while (l <= h) {\n            int mid = l + (h - l) / 2;\n            if (check(mid, nums, queries)) {\n                ans = mid;\n                h = mid - 1; \n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"sandipto729","submissionId":"1575166619"},[]]},{"449":[{"id":"449","fileName":"1575167195.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<unordered_set<int>> dps(nums.size());\n\n        auto isGood = [&dps]() {\n            for (const auto& s : dps) {\n                if (!s.contains(0))\n                    return false;\n            }\n\n            return true;\n        };\n\n        for (auto i = 0; i < nums.size(); ++i) {\n            dps[i].emplace(nums[i]);\n        }\n\n        if (isGood())\n            return 0;\n\n        auto result = 0;\n        for (const auto& query : queries) {\n            auto start = query[0];\n            auto end = query[1];\n            auto val = query[2];\n\n            for (auto i = start; i <= end; ++i) {\n                auto clone = dps[i];\n                for (auto elem : clone) {\n                    if (elem - val >= 0) {\n                        dps[i].emplace(elem - val);\n                    }\n                }\n            }\n\n            result++;\n            if (isGood()) {\n                return result;\n            }\n        }\n\n        return -1;\n    }\n};","author":"Piggy Wang","submissionId":"1575167195"},[]]},{"450":[{"id":"450","fileName":"1575167743.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int m = queries.length, n = nums.length;\n        int ans = 0;\n        for (int i=0; i<n; i++) {\n            if (nums[i]==0) continue;\n            HashSet<Integer> hs = new HashSet<>();\n            hs.add(nums[i]);\n            int k = -1;\n            for (int j=0; j<m; j++) {\n                if (queries[j][0]>i || queries[j][1]<i) continue;\n                int val = queries[j][2];\n                HashSet<Integer> hs1 = new HashSet<>();\n                for (int sums : hs) {\n                    hs1.add(sums);\n                    if (sums-val>=0) hs1.add(sums-val);\n                }\n                hs=hs1;\n                if (hs.contains(0)) {\n                    k=j+1;\n                    //System.out.println(k);\n                    break;\n                }\n                \n                \n            }\n            //System.out.println(i+\" \"+hs);\n            if (k==-1) return -1;\n            ans=Math.max(k,ans);\n        }\n        return ans;\n    }\n}","author":"JerryGu1","submissionId":"1575167743"},[]]},{"451":[{"id":"451","fileName":"1575167257.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if max(nums) == 0: return 0\n        n = len(nums)\n        dp = [set([0]) for _ in range(n)]\n        for k, (l, r, val) in enumerate(queries):\n            for i in range(l, r+1):\n                cur = set()\n                for sum in dp[i]:\n                    if sum + val <= nums[i]:\n                        cur.add(sum + val)\n                dp[i].update(cur)\n            is_valid = all(nums[i] in dp[i] for i in range(n))\n            if is_valid:\n                return k + 1\n        return -1","author":"Luong Quang Dung","submissionId":"1575167257"},[]]},{"452":[{"id":"452","fileName":"1575167238.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        /*boolean allZeros = isAllZerosArray(nums);\n        if (allZeros) {\n            return 0;\n        }\n\n        for (int queryIndex = 0; queryIndex < queries.length; ++queryIndex) {\n            int[] query = queries[queryIndex];\n            for (int index = query[0]; index <= query[1]; ++index) {\n                nums[index] -= query[2];\n                if (nums[index] < 0) {\n                    nums[index] = 0;\n                }\n            }\n\n            allZeros = isAllZerosArray(nums);\n            if (allZeros) {\n                return queryIndex + 1;\n            }\n        }\n\n        return -1;*/\n\n        boolean allZeros = true;\n        for (int index = 0; index < nums.length; ++index) {\n            if (nums[index] != 0) {\n                allZeros = false;\n                break;\n            }\n        }\n\n        if (allZeros) {\n            return 0;\n        }\n        \n        ArrayList<HashSet<Integer>> possibleValues = new ArrayList<>();\n        for (int index = 0; index < nums.length; ++index) {\n            HashSet<Integer> hashSetToAdd = new HashSet<>();\n            hashSetToAdd.add(nums[index]);\n            possibleValues.add(hashSetToAdd);\n        }\n\n        for (int queryIndex = 0; queryIndex < queries.length; ++queryIndex) {\n            int[] query = queries[queryIndex];\n            for (int index = query[0]; index <= query[1]; ++index) {\n                HashSet<Integer> valuesToAdd = new HashSet<>();\n                for (int key : possibleValues.get(index)) {\n                    if (!possibleValues.get(index).contains(key - query[2]) && key - query[2] >= 0) {\n                        valuesToAdd.add(key - query[2]);\n                    }\n                }\n\n                possibleValues.get(index).addAll(valuesToAdd);\n            }\n\n            boolean canAllBeZeros = true;\n            for (int index = 0; index < nums.length; ++index) {\n                if (!possibleValues.get(index).contains(0)) {\n                    canAllBeZeros = false;\n                    break;\n                }\n            }\n\n            if (canAllBeZeros) {\n                return queryIndex + 1;\n            }\n        }\n\n        return -1;\n    }\n\n    private boolean isAllZerosArray(int nums[]) {\n        for (int num : nums) {\n            if (num != 0) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}","author":"Stanislau2","submissionId":"1575167238"},[]]},{"453":[{"id":"453","fileName":"1575167904.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = 0;\n        int m = 0;\n        for (int a: nums) m = max(m, a);\n        if (m == 0) return 0;\n        m++;\n        for (int i = 0; i < nums.size(); i++) {\n            vector<bool> v(m, false);\n            v[nums[i]] = true;\n            int k = 0;\n            for (; k < queries.size(); k++) {\n                vector<int> q = queries[k];\n                if (!(i >= q[0] && i <= q[1])) continue;\n                vector<bool> t(v.begin(), v.end());\n                for (int j = 0; j < m; j++) {\n                    if (j - q[2] >= 0 && v[j]) t[j - q[2]] = true;\n                }\n                v = t;\n                if (v[0]) break;\n            }\n            if (k < queries.size()) ans = max(ans, k + 1);\n            else if (!v[0]) return -1;\n        }\n        return ans;\n    }\n};","author":"Zhenyuan Lu","submissionId":"1575167904"},[]]},{"454":[{"id":"454","fileName":"1575166571.txt","sourceCode":"class Solution {\npublic:\n    int rec(int i , int j , int x ,\nvector <vector <int>> &queries , vector <vector <vector <int>>> &dp){\n        int q = queries.size();\n        if(x==0) return i;\n        if(i==q){\n            return 1e9;\n        }\n\n        if(dp[i][j][x]!= -1 ) return dp[i][j][x];\n        \n        int left = queries[i][0],\n        right = queries[i][1] , val = queries[i][2];\n\n        int ans = rec(i+1,j,x,queries,dp);\n        if((left<=j && j<=right) && x>=val) \n            ans=min(ans,rec(i+1,j,x-val,queries,dp));\n\n        return dp[i][j][x] = ans;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size() , q = queries.size();\n        int m = *max_element(nums.begin(),nums.end());\n        vector <vector <vector <int>>> dp(q+1,\n        vector <vector <int>> (n+1, vector <int> (m+1,-1)));\n\n        int mn = 0;\n        for(int j = 0; j<n; j++){\n            mn = max(mn,rec(0,j,nums[j],queries,dp));\n        }\n        if(mn==1e9) return -1;\n        return mn;\n    }\n};","author":"Manimum","submissionId":"1575166571"},[]]},{"455":[{"id":"455","fileName":"1575167866.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        dp = [1 for _ in range(n)]  \n        masks = [(1 << (nums[i] + 1)) - 1 for i in range(n)]\n        if all(num == 0 for num in nums):\n            return 0\n        for k, (l, r, val) in enumerate(queries, 1):\n            for i in range(l, r + 1):\n                dp[i] |= (dp[i] << val)\n                dp[i] &= masks[i]\n            if all((dp[i] >> nums[i]) & 1 for i in range(n)):\n                return k\n        return -1\n\n","author":"Bariscan","submissionId":"1575167866"},[]]},{"456":[{"id":"456","fileName":"1575167763.txt","sourceCode":"class Solution {\npublic:\nbool possible(vector<int>& nums, vector<vector<int>>& queries, int k) {\n    int n = nums.size();\n    for (int j = 0; j < n; j++) {\n        vector<int> available;\n        for (int i = 0; i < k; i++) {\n            if (queries[i][0] <= j && j <= queries[i][1]) {\n                available.push_back(queries[i][2]);\n            }\n        }\n        \n        int target = nums[j];\n        bitset<10000+1> s;\n        s[0]=true;\n        for(int i:available){\n            s|=s<<i;\n        }\n        if(!s[target]){\n            return false;\n        }\n        // vector<bool> dp(target + 1, false);\n        // dp[0] = true;\n        // for (int val : available) {\n        //     for (int s = target; s >= val; s--) {\n        //         if (dp[s - val]) {\n        //             dp[s] = true;\n        //         }\n        //     }\n        //     if (dp[target]) break;\n        // }\n        // if (!dp[target]) return false;\n    }\n    return true;\n}\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int m = queries.size();\n        for (int k = 0; k <= m; k++) {\n            if (possible(nums, queries, k))\n                return k;\n        }\n        return -1;\n        \n    }\n};","author":"SUPERMAN44","submissionId":"1575167763"},[]]},{"457":[{"id":"457","fileName":"1575168006.txt","sourceCode":"class Solution {\npublic:\n    // Function to check if any subset of 'elements' can sum to 'target'\n    bool canFormSubsetSum(vector<int>& elements, int target) {\n        int m = elements.size();\n        vector<bool> dp(target + 1, false);\n        dp[0] = true; // Base case: subset sum 0 is always possible\n\n        for (int num : elements) {\n            for (int j = target; j >= num; j--) {\n                if (dp[j - num]) {\n                    dp[j] = true;\n                }\n            }\n        }\n        return dp[target];\n    }\n\n    // Function to check if the first 'mid' queries can zero out nums\n    bool check(int mid, vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            int elem = nums[i];\n            vector<int> elements;\n\n            // Collect valid decrements from the first 'mid' queries\n            for (int j = 0; j < mid; j++) {\n                if (i >= queries[j][0] && i <= queries[j][1]) {\n                    elements.push_back(queries[j][2]);\n                }\n            }\n\n            // Use DP to check if a subset sum can reach 'elem'\n            if (!canFormSubsetSum(elements, elem)) {\n                return false; // If no valid subset exists, return false\n            }\n        }\n        return true;\n    }\n\n    // Binary search to find the minimum number of queries needed\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int low = 0, high = queries.size(), ans = -1;\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (check(mid, nums, queries)) {\n                ans = mid;\n                high = mid - 1; // Try to minimize queries\n            } else {\n                low = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"Naman Dwivedi","submissionId":"1575168006"},[]]},{"458":[{"id":"458","fileName":"1575168250.txt","sourceCode":"class Solution {\npublic:\n\n    bool isSum(int sum, vector<int> &arr) {\n        int n = arr.size();\n        vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));\n        for (int i = 0; i <= n; i++)\n            dp[i][0] = true;\n        for (int i = 1; i <= n; i++) {\n          \n            for (int j = 1; j <= sum; j++) {\n                if (j < arr[i - 1]) {\n                    dp[i][j] = dp[i - 1][j]; \n                }\n                else {\n                    dp[i][j] = dp[i - 1][j] \n                    || dp[i - 1][j - arr[i - 1]];\n                }\n            }\n        }\n        return dp[n][sum];\n    }\n\n    bool chk(int k, vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size(), sum = 0;\n        vector<vector<int>> temp(n + 1);\n        \n        for (int i = 0; i < k; i++) {\n            int l = q[i][0], r = q[i][1];\n            for (int j = l; j <= r; j++) {\n                temp[j].push_back(q[i][2]);\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            int sum = nums[i];\n            vector<int> & t = temp[i];\n            if (!isSum(sum, t)) return false;\n        }        \n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int l = 0, r = queries.size(), ans = -1;\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if (chk(mid, nums, queries)) {\n                ans = mid;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"frameboy_27","submissionId":"1575168250"},[]]},{"459":[{"id":"459","fileName":"1575168012.txt","sourceCode":"class Solution {\npublic:\n   \n    int qsz;\n    vector<vector<int>>v1;\n    vector<vector<int>>dp;\n    int mn=1e6;\n    int ind;\n    int solve(int sum,int i)\n    {\n        if(sum<=0)\n        {\n            mn=min(i,mn);\n            return 0;\n        }\n        if(i>=qsz)\n        {\n            return 0;\n        }\n        int ans=1000000;\n        if(dp[i][sum]!=-1)\n            return dp[i][sum];\n        if(sum>=v1[i][2]&&ind>=v1[i][0]&&v1[i][1]>=ind)\n        ans=min(ans,solve(sum-v1[i][2],i+1));\n        ans=min(ans,solve(sum,i+1));\n        dp[i][sum]=ans;\n        return ans;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n       \n         qsz=q.size();\n        v1=q;\n        dp.resize(qsz+1,vector<int>(1e3+1,-1));\n        int ans=0;\n        for(int i=0;i<nums.size();i++)\n        {\n            mn=1e6;\n            ind=i;\n            for(int k=0;k<=qsz;k++)\n            {\n                for(int j=0;j<=1e3;j++)\n                {\n                    dp[k][j]=-1;\n                }\n            }\n           solve(nums[i],0);\n            ans=max(mn,ans);\n        }\n        if(ans>qsz)\n            return -1;\n        return ans;\n       \n        \n    }\n};","author":"Avan Singh","submissionId":"1575168012"},[]]},{"460":[{"id":"460","fileName":"1575168208.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def pos(arr, n):\n            # print(arr, n)\n            if n==0:\n                return True\n            st={0}\n            for val, mult in enumerate(arr):\n                if mult!=0:\n                    tmp=set()\n                    for x in st:\n                        for i in range(1, mult+1):\n                            t=x+val*i\n                            if t==n:\n                                return True\n                            if t<=1000:\n                                tmp.add(t)\n                            else:\n                                break\n                    st.update(tmp)\n            # print(st)\n            return False\n        l0=len(nums)\n        # print(l0)\n        def sib(k):\n            a=[[0]*11 for _ in range(l0)]\n            for i in range(k):\n                l, r, val=queries[i]\n                for j in range(l, r+1):\n                    a[j][val]+=1\n            return all(pos(a[i], nums[i]) for i in range(l0))\n        a=0\n        b=len(queries)\n        if not sib(b):\n            return -1\n        while b-a>1:\n            mid=(a+b)//2\n            if sib(mid):\n                b=mid\n            else:\n                a=mid\n        if sib(a):\n            return a\n        return b\n        ","author":"Marius Beceanu","submissionId":"1575168208"},[]]},{"461":[{"id":"461","fileName":"1575167925.txt","sourceCode":"class Solution {\npublic:\n    bool isPossible(int k, vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            int target = nums[i];\n            vector<int> vals;\n            for (int j = 0; j < k; ++j) {\n                if (queries[j][0] <= i && i <= queries[j][1])\n                    vals.push_back(queries[j][2]);\n            }\n            vector<bool> dp(target + 1, false);\n            dp[0] = true;\n            for (int v : vals) {\n                for (int s = target; s >= v; --s) {\n                    dp[s] = dp[s] || dp[s - v];\n                }\n            }\n            if (!dp[target]) return false;\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int lo = 0, hi = queries.size(), ans = -1;\n        while (lo <= hi) {\n            int mid = (lo + hi) / 2;\n            if (isPossible(mid, nums, queries)) {\n                ans = mid;\n                hi = mid - 1;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"Himanshu","submissionId":"1575167925"},[]]},{"462":[{"id":"462","fileName":"1575168316.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        List<List<int[]>> indexQueries = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            indexQueries.add(new ArrayList<>());\n        }\n\n        // Preprocess: for each query, add it to the list of each index it covers\n        for (int j = 0; j < m; j++) {\n            int l = queries[j][0];\n            int r = queries[j][1];\n            int val = queries[j][2];\n            for (int i = l; i <= r; i++) {\n                indexQueries.get(i).add(new int[]{j, val});\n            }\n        }\n\n        int maxK = 0;\n\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            if (target == 0) continue;\n\n            List<int[]> qi = indexQueries.get(i);\n            if (qi.isEmpty()) return -1;\n\n            // Map to track sum: key is sum, value is [steps, latest_j]\n            Map<Integer, int[]> possibleSums = new HashMap<>();\n            possibleSums.put(0, new int[]{0, -1}); // Initial state: sum 0 requires 0 steps and no query\n\n            int minK_i = Integer.MAX_VALUE;\n\n            for (int[] entry : qi) {\n                int original_j = entry[0];\n                int val = entry[1];\n\n                Map<Integer, int[]> temp = new HashMap<>();\n\n                for (Map.Entry<Integer, int[]> e : possibleSums.entrySet()) {\n                    int s = e.getKey();\n                    int steps = e.getValue()[0];\n                    int latest_j = e.getValue()[1];\n\n                    // Option 1: Take this query\n                    int newSum = s + val;\n                    int newSteps = steps + 1;\n                    int newLatestJ = original_j;\n\n                    if (!temp.containsKey(newSum) || \n                        newSteps < temp.get(newSum)[0] || \n                        (newSteps == temp.get(newSum)[0] && newLatestJ < temp.get(newSum)[1])) {\n                        temp.put(newSum, new int[]{newSteps, newLatestJ});\n                    }\n\n                    // Option 2: Do not take this query (carry forward existing sum)\n                    if (!temp.containsKey(s) || \n                        steps < temp.get(s)[0] || \n                        (steps == temp.get(s)[0] && latest_j < temp.get(s)[1])) {\n                        temp.put(s, new int[]{steps, latest_j});\n                    }\n                }\n\n                possibleSums = new HashMap<>(temp);\n\n                // Check if target is reached and update minK_i\n                if (possibleSums.containsKey(target)) {\n                    int[] current = possibleSums.get(target);\n                    int currentK = current[1] + 1;\n                    if (currentK < minK_i) {\n                        minK_i = currentK;\n                    }\n                }\n            }\n\n            // Check after processing all queries for this index\n            if (!possibleSums.containsKey(target)) {\n                return -1;\n            }\n\n            int[] finalEntry = possibleSums.get(target);\n            int finalK = finalEntry[1] + 1;\n            if (finalK < minK_i) {\n                minK_i = finalK;\n            }\n\n            maxK = Math.max(maxK, minK_i);\n        }\n\n        return maxK;\n    }\n}\n","author":"SACHIN GUSAIN","submissionId":"1575168316"},[]]},{"463":[{"id":"463","fileName":"1575168708.txt","sourceCode":"class Solution:\n  def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n    n = len(nums)\n    n_queries = len(queries)\n    ret = 0\n    for i in range(n):\n      num = nums[i]\n      dp = [[False for _ in range(num + 1)] for _ in range(n_queries + 1)]\n      dp[0][num] = True\n      if dp[0][0]:\n        continue\n      \n      for length in range(1, n_queries + 1):\n        l, r, val = queries[length - 1]\n        for remains in range(0, num + 1):\n          dp[length][remains] = dp[length - 1][remains] or (dp[length - 1][remains + val] if l <= i <= r and remains + val <= num else False)\n        if dp[length][0]:\n          ret = max(ret, length)\n          #print(i, dp)\n          break\n      else:\n        ret = -1\n        #print(i, dp)\n        break\n    return ret\n            \n        ","author":"hope_ma","submissionId":"1575168708"},[]]},{"464":[{"id":"464","fileName":"1575168179.txt","sourceCode":"class Solution {\n    /**\n     * @param Integer[] $nums\n     * @param Integer[][] $queries\n     * @return Integer\n     */\n    function minZeroArray($nums, $queries) {\n        $n = count($nums);\n        $dp = array_fill(0, $n, array_fill(0, 1001, false));\n\n        for ($j = 0; $j < $n; $j++) {\n            $dp[$j][0] = true;\n        }\n\n        $allZero = true;\n        for ($j = 0; $j < $n; $j++) {\n            if ($nums[$j] != 0) {\n                $allZero = false;\n                break;\n            }\n        }\n\n        if ($allZero) return 0;\n\n        foreach ($queries as $k => $query) {\n            list($l, $r, $v) = $query;\n            for ($j = $l; $j <= $r; $j++) {\n                for ($pos = 1000; $pos >= $v; $pos--) {\n                    $dp[$j][$pos] |= $dp[$j][$pos - $v];\n                }\n                for ($pos = $nums[$j] + 1; $pos < 1001; $pos++) {\n                    $dp[$j][$pos] = false;\n                }\n            }\n\n            $allAchieved = true;\n            for ($j = 0; $j < $n; $j++) {\n                if (!$dp[$j][$nums[$j]]) {\n                    $allAchieved = false;\n                    break;\n                }\n            }\n\n            if ($allAchieved) return $k + 1;\n        }\n\n        return -1;\n    }\n}\n","author":"Gokhulnath7","submissionId":"1575168179"},[]]},{"465":[{"id":"465","fileName":"1575168599.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        mnDec = {}\n        for i, num in enumerate(nums):\n            if num == 0: continue\n            possDec = set()\n            found = False\n            for j , (l, r, v) in enumerate(queries):\n                if i < l or i > r: continue\n                if v == num:\n                    mnDec[i] = j\n                    break\n\n                for poss in list(possDec):\n                    new = poss + v\n                    if new == num:\n                        mnDec[i] = j\n                        found = True\n                        break\n                    possDec.add(poss + v)\n                else:\n                    possDec.add(v)\n\n                if found: break\n            else:\n                return -1\n        return 1+ max(list(mnDec.values()), default=-1)\n                    \n                \n                ","author":"Jonathan de Koning","submissionId":"1575168599"},[]]},{"466":[{"id":"466","fileName":"1575169038.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n         int n =nums.size(), m =q.size();\n    bool t =true;\n     for (int x :nums){if(x!=0){t = false;break;}}\n    if (t) return 0;\n    for (int k = 1;k<=m; k++){\n        bool can =true;\n        for (int j = 0; j < n; j++){\n            vector<int>a;\n            for (int i = 0;i <k;i++)\n               if(q[i][0]<=j && j<=q[i][1])a.push_back(q[i][2]);\n            \n            int tar =nums[j] ;\n            bitset<1001>dp; \n            dp[0] = 1;\n            for (int v : a) {\n                dp |=(dp << v);\n                if (dp[tar]) break; \n            }\n            if (!dp[tar]){can = false;break;}\n        }\n        if(can)return k;\n    }\n    return -1;\n}\n};","author":"A7ush","submissionId":"1575169038"},[]]},{"467":[{"id":"467","fileName":"1575168931.txt","sourceCode":"class Solution {\npublic:\n    int memo[1001][1001];\n\n    int dfs(vector<int>& sequence, int cur_idx, int target) {\n        if(target == 0)\n            return cur_idx;\n\n        if(cur_idx == sequence.size())\n            return INT_MAX;\n\n        if(memo[cur_idx][target] != -1)\n            return memo[cur_idx][target];\n        \n        // choose or not choose\n        int ans = INT_MAX;\n\n        // choose\n        if(target >= sequence[cur_idx])\n            ans = min(ans, dfs(sequence, cur_idx+1, target-sequence[cur_idx]));\n\n        ans = min(ans, dfs(sequence, cur_idx+1, target));\n\n        return memo[cur_idx][target] = ans;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size();\n\n        vector<bool> is_zero(n, false);\n        vector<vector<int>> possible_add(n, vector<int>());\n\n        // Note : ans should be i+1\n        for(int i = 0; i < q; i++) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n\n            for(int j = 0; j < n; j++) {\n                if(l <= j && j <= r)\n                    possible_add[j].push_back(val);\n                else\n                    possible_add[j].push_back(0);\n            }\n        }\n\n        int ans = 0;\n        for(int i = 0; i < n; i++) {\n            memset(memo, -1, sizeof(memo));\n            \n            int min_q = dfs(possible_add[i], 0, nums[i]);\n\n            //cout << min_q << endl;\n\n            if(min_q == INT_MAX)\n                return -1;\n            \n            ans = max(ans, min_q);\n            \n        }\n\n        return ans; \n    }\n};","author":"maomao0414","submissionId":"1575168931"},[]]},{"468":[{"id":"468","fileName":"1575169076.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = 0, n = nums.size(), q = queries.size();\n        for(int i=0; i<n; i++){\n            if(nums[i] == 0) continue;\n            bitset<1001> dp;\n            dp[0] = 1;\n            for(int j=0; j<=q; j++){\n                if(j == q) return -1;\n                auto &vec = queries[j];\n                if(vec[0] <= i && vec[1] >= i) dp = dp << vec[2] | dp;\n                if(dp[nums[i]]){\n                    ans = max(j+1, ans);\n                    break;\n                }\n            }\n            \n        }\n        return ans;\n    }\n};","author":"godoflogix","submissionId":"1575169076"},[]]},{"469":[{"id":"469","fileName":"1575169129.txt","sourceCode":"import java.util.*;\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length, result = -1;\n        int low = 0, high = queries.length;\n\n        while (low <= high) {\n            int mid = low + ((high - low)/2);\n\n            List<Integer> adj[] = new List[n];\n\n            for (int i = 0; i < n; i++) {\n                adj[i] = new ArrayList<>();\n            }\n\n            for (int i = 0; i < mid; i++) {\n                for (int j = queries[i][0]; j<= queries[i][1]; j++) {\n                    adj[j].add(queries[i][2]);\n                }\n            }\n\n            boolean valid = true;\n\n            for (int i = 0; i < n; i++) {\n                if (!isPossible(adj[i], nums[i])) {\n                    valid = false;\n                    break;\n                }\n            }\n\n            if (valid) {\n                result = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        \n        return result;\n    }\n\n    public boolean isPossible(List<Integer> indices, int val) {\n        if (val == 0) {\n            return true;\n        } else if (indices.size() == 0) {\n            return false;\n        }\n\n        int n = indices.size();\n\n        boolean dp[][] = new boolean[n + 1][val + 1];\n\n        for (int i = 1; i <= val; i++) {\n            dp[0][i] = false;\n        }\n\n        for (int i = 0; i <= n; i++) {\n            dp[i][0] = true;\n        }\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= val; j++) {\n                dp[i][j] = dp[i - 1][j];\n\n                if (j >= indices.get(i - 1)) {\n                    dp[i][j] = dp[i][j] || dp[i - 1][j - indices.get(i - 1)];\n                }\n            }\n        }\n\n        return dp[n][val];\n    }\n}","author":"Macharla Venkata Ravi Teja","submissionId":"1575169129"},[]]},{"470":[{"id":"470","fileName":"1575168831.txt","sourceCode":"#include <stdbool.h>\n\nint minZeroArray(int *num, int nsz, int **qry, int qsz, int *qcs) {\n    int x, y, z, flg = 1;\n    for (x = 0; x < nsz; x++) {\n        if (num[x] != 0) { flg = 0; break; }\n    }\n    if (flg) return 0;\n    int lo = 1, hi = qsz, md, ans = -1;\n    while (lo <= hi) {\n        md = lo + (hi - lo) / 2;\n        int ok = 1;\n        for (x = 0; x < nsz; x++) {\n            int tgt = num[x];\n            if (tgt == 0) continue;\n            bool tab[1001] = { false };\n            tab[0] = true;\n            for (y = 0; y < md; y++) {\n                int li = qry[y][0], ri = qry[y][1], va = qry[y][2];\n                if (x < li || x > ri) continue;\n                for (z = tgt; z >= va; z--) {\n                    if (tab[z - va]) tab[z] = true;\n                }\n            }\n            if (!tab[tgt]) { ok = 0; break; }\n        }\n        if (ok) { ans = md; hi = md - 1; }\n        else { lo = md + 1; }\n    }\n    return ans;\n}\n","author":"Harshit Raj","submissionId":"1575168831"},[]]},{"471":[{"id":"471","fileName":"1575169173.txt","sourceCode":"import numpy as np\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        def can_make(target: int, coins: dict):\n            able_to_make = [False] * (target + 1)\n            able_to_make[0] = True\n            for k, v in coins.items():\n                for starting in range(target, -1, -1):\n                    if not able_to_make[starting]:\n                        continue\n                    for n_used in range(v + 1):\n                        result = starting + k * n_used\n                        if result <= target:\n                            able_to_make[result] = True\n\n            #print(f\"can_make({target=}, {coins=}) = {able_to_make[target]}\")\n            \n            return able_to_make[target]\n\n        coins_array = [Counter() for _ in range(n)]\n        def is_good(i):\n            return can_make(nums[i], coins_array[i])\n        def good_indices():\n            return [is_good(i) for i in range(n)]\n        def all_good():\n            return all(is_good(i) for i in range(n))\n\n        if all(num == 0 for num in nums):\n            return 0\n        for i, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                coins_array[j][v] += 1\n            if all_good():\n                return i + 1\n\n            #print(f\"After {i=}, {good_indices()=}\")\n\n        return -1\n        ","author":"Robert Perez","submissionId":"1575169173"},[]]},{"472":[{"id":"472","fileName":"1575169239.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> a(n,vector<int> (1010,0));\n        for(int i = 0; i < n; i++) a[i][0] = 1;\n        int ans = 0;\n        for(int ch : nums) ans += ch;\n        if(ans == 0) return 0;\n        ans = 0;\n        for(auto it : queries) {\n            ans++;\n            int l = it[0],r = it[1],val = it[2];\n            for(int i = l; i <= r; i++) {\n                vector<int> pos;\n                for(int j = 0; j < 1000; j++) {\n                    if(a[i][j]) {\n                        int p = j+ val;\n                        if(p <= 1000)\n                            pos.push_back(p);\n                    }\n                }\n                for(int pp : pos) {\n                    a[i][pp] = 1;\n                }\n            }\n            int cnt = 0;\n            for(int i = 0; i < n; i++) {\n                cnt += a[i][nums[i]];\n            }\n            if(cnt == n) {\n                return ans;\n            }\n        }\n        return -1;\n    }\n};","author":"Tutul_dhar","submissionId":"1575169239"},[]]},{"474":[{"id":"474","fileName":"1575169520.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        sets = [set([0]) for _ in range(len(nums))]\n        for i in range(len(queries)):\n            if all([x == 0 for x in nums]):\n                return i\n            l, r, val = queries[i]\n            for j in range(l, r + 1):\n                if nums[j] == 0:\n                    continue\n                s = sets[j]\n                new = []\n                for su in s:\n                    newsu = su + val\n                    if newsu == nums[j]:\n                        nums[j] = 0\n                        break\n                    new.append(newsu)\n                for newsu in new:\n                    s.add(newsu)\n        if all([x == 0 for x in nums]):\n            return len(queries)\n        else:\n            return -1","author":"charlieterle","submissionId":"1575169520"},[]]},{"476":[{"id":"476","fileName":"1575168666.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int m = queries.length;\n     \n        boolean[][] dp = new boolean[n][];\n        for (int i = 0; i < n; i++) {\n            dp[i] = new boolean[nums[i] + 1];\n            dp[i][0] = true;\n        }\n        \n        boolean alreadyZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                alreadyZero = false;\n                break;\n            }\n        }\n        if (alreadyZero) return 0;\n        \n        for (int k = 0; k < m; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int v = queries[k][2];\n            \n         \n            for (int i = l; i <= r; i++) {\n                for (int s = nums[i] - v; s >= 0; s--) {\n                    if (dp[i][s] && s + v <= nums[i]) {\n                        dp[i][s + v] = true;\n                    }\n                }\n            }\n            boolean allZeroPossible = true;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i][nums[i]]) {\n                    allZeroPossible = false;\n                    break;\n                }\n            }\n            if (allZeroPossible) {\n                return k + 1;  \n            }\n        }\n        \n        return -1; \n    }\n}\n","author":"Sunny","submissionId":"1575168666"},[{"id":"1400","similarity":0.8775510204081632,"totOverlap":172,"longestOverlap":22}]],"1400":[{"id":"1400","fileName":"1575228634.txt","sourceCode":"class Solution {\npublic int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int q = queries.length;\n\n        boolean alreadyZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                alreadyZero = false;\n                break;\n            }\n        }\n        if (alreadyZero)\n            return 0;\n\n        boolean[][] dp = new boolean[n][];\n        for (int i = 0; i < n; i++) {\n            dp[i] = new boolean[nums[i] + 1];\n            dp[i][0] = true;\n        }\n\n        for (int k = 0; k < q; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int val = queries[k][2];\n\n            for (int i = l; i <= r; i++) {\n                for (int s = dp[i].length - 1 - val; s >= 0; s--) {\n                    if (dp[i][s] && s + val < dp[i].length) {\n                        dp[i][s + val] = true;\n                    }\n                }\n            }\n\n            boolean allCovered = true;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i][nums[i]]) {\n                    allCovered = false;\n                    break;\n                }\n            }\n            if (allCovered)\n                return k + 1;\n        }\n\n        return -1;\n    }\n}","author":"tmimotw","submissionId":"1575228634"},[{"id":"476","similarity":0.8775510204081632,"totOverlap":172,"longestOverlap":22}]]},{"477":[{"id":"477","fileName":"1575169835.txt","sourceCode":"class Solution {\nprivate:\n    bool subsetSumToK(int k, vector<int> &arr) {\n    int n = arr.size();\n    vector<vector<bool>>dp(n + 1, vector<bool>(k + 1, false));\n    for(int i = 0; i <= n; i++){\n        dp[i][0] = true;\n    }\n\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= k; j++){\n            dp[i][j] = dp[i - 1][j] || ((j >= arr[i - 1]) ? dp[i - 1][j - arr[i - 1]] : false);\n        }\n    }\n\n    return dp[n][k];\n\n}\n    bool isPossible(vector<int>&nums, vector<vector<int>>&queries, int k){\n        for(int i = 0; i < nums.size(); i++){\n            vector<int>v;\n            for(int j = 0; j < k; j++){\n                int l = queries[j][0];\n                int r = queries[j][1];\n                int val = queries[j][2];\n                if(i >= l && i <= r)  v.push_back(val);\n            }\n            if(!subsetSumToK(nums[i], v))  return false;\n        }\n        return true;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int m = queries.size(), n = nums.size();\n        int s = 0, e = m;\n        int ans = -1;\n        while(s <= e){\n            int mid = s + (e - s) / 2;\n            if(isPossible(nums, queries, mid)){\n                ans = mid;\n                e = mid - 1;\n            }\n            else{\n                s = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"Srdjr000","submissionId":"1575169835"},[]]},{"478":[{"id":"478","fileName":"1575170019.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        ans = 0\n        \n        def ok(tmp, x):\n            f = [False] * (x + 1)\n            f[0] = True\n            for x in tmp:\n                for i in range(len(f) - 1, -1, -1):\n                    if i - x >= 0:\n                        f[i] |= f[i - x]\n            return f[-1]\n\n        for i, x in enumerate(nums):\n            if x == 0: continue\n            lo, hi = 1, len(queries)\n            cur = -1\n            while lo <= hi:\n                mid = (lo + hi) >> 1\n                tmp = [q[2] for q in queries[:mid] if q[0] <= i <= q[1]]\n                if ok(tmp, x):\n                    cur = mid\n                    hi = mid - 1\n                else:\n                    lo = mid + 1\n            if cur == -1: return -1\n            ans = max(ans, cur)\n        return ans\n            ","author":"MC_Stone","submissionId":"1575170019"},[]]},{"479":[{"id":"479","fileName":"1575170329.txt","sourceCode":"public class Solution {\n    const int N = 1001;\n    \n    public int MinZeroArray(int[] nums, int[][] queries) {\n        int nz = nums.Count(n => n > 0);\n\n        if (nz == 0) return 0;\n\n        int n = nums.Length;\n        bool[,] ns = new bool[n, N];\n        for (int i = 0; i < n; i++) {\n            ns[i, nums[i]] = true;\n        }\n        \n        for (int k = 0; k < queries.Length; k++) {\n            int l = queries[k][0];\n            int r1 = queries[k][1] + 1;\n            int v = queries[k][2];\n            \n            for (int i = l; i < r1; i++) {\n                if (ns[i, 0]) continue;\n\n                if (ns[i, v]) {\n                    ns[i, 0] = true;\n                    nz--;\n                    if (nz == 0) return k + 1;\n                } else {\n                    for (int j = v + 1; j < N; j++) {\n                        if (ns[i, j]) {\n                            ns[i, j - v] = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        return -1;\n    }\n}","author":"lauel24","submissionId":"1575170329"},[]]},{"480":[{"id":"480","fileName":"1575170535.txt","sourceCode":"import java.util.HashMap;\nimport java.util.Map;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        \n        // Initialize a DP map for each element to track possible sums and their latest query index\n        Map<Integer, Integer>[] dp = new Map[n];\n        for (int i = 0; i < n; i++) {\n            dp[i] = new HashMap<>();\n            dp[i].put(0, -1); // Initial state: sum 0 with no queries used\n        }\n        \n        int minK = Integer.MAX_VALUE;\n        \n        for (int j = 0; j < m; j++) {\n            int[] q = queries[j];\n            int l = q[0], r = q[1], val = q[2];\n            \n            // Update the DP maps for all elements in the current query's range\n            for (int i = l; i <= r; i++) {\n                if (nums[i] == 0) continue;\n                \n                Map<Integer, Integer> newDp = new HashMap<>(dp[i]);\n                for (Map.Entry<Integer, Integer> entry : dp[i].entrySet()) {\n                    int s = entry.getKey();\n                    int currentMaxJ = entry.getValue();\n                    int newS = s + val;\n                    \n                    if (newS > nums[i]) continue; // Exceeding the target sum is not useful\n                    \n                    int newMaxJ = Math.max(currentMaxJ, j);\n                    if (!newDp.containsKey(newS) || newDp.get(newS) < newMaxJ) {\n                        newDp.put(newS, newMaxJ);\n                    }\n                }\n                dp[i] = newDp;\n            }\n            \n            // Check if all elements can be turned to zero with the current queries processed\n            boolean allAchieved = true;\n            int currentMaxCandidate = 0;\n            for (int i = 0; i < n; i++) {\n                if (nums[i] == 0) continue;\n                \n                if (!dp[i].containsKey(nums[i])) {\n                    allAchieved = false;\n                    break;\n                }\n                int ti = dp[i].get(nums[i]);\n                currentMaxCandidate = Math.max(currentMaxCandidate, ti + 1);\n            }\n            \n            if (allAchieved && currentMaxCandidate <= j + 1) {\n                minK = Math.min(minK, currentMaxCandidate);\n            }\n        }\n        \n        return minK == Integer.MAX_VALUE ? -1 : minK;\n    }\n}","author":"Anurag Singh","submissionId":"1575170535"},[]]},{"481":[{"id":"481","fileName":"1575170223.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int lo=0,hi=queries.size();\n        int n=nums.size(),res=-1;\n        vector memo(n,vector<vector<int>>(hi,vector<int>(1001,-1)));\n        function<int(int,int,int)>dp=[&](int i,int j,int num){\n            if(j<0) return num==0?1:0;\n            if(memo[i][j][num]!=-1) return memo[i][j][num];\n            int ans=dp(i,j-1,num);\n            int l=queries[j][0],r=queries[j][1],val=queries[j][2];\n            if(l<=i && i<=r && val<=num){\n                ans|=dp(i,j-1,num-val);\n            }\n            return memo[i][j][num]=ans;\n        };\n        while(lo<=hi){\n            int k=(lo+hi)/2;\n            bool ok=true;\n            for(int i=0;i<n;i++){\n                if(!dp(i,k-1,nums[i])){\n                    ok=false;\n                    break;\n                }\n            }\n            if(ok){\n                res=k;\n                hi=k-1;\n            }\n            else lo=k+1;\n        }\n        return res;\n    }\n};","author":"Honey Gupta","submissionId":"1575170223"},[]]},{"482":[{"id":"482","fileName":"1575170437.txt","sourceCode":"class Solution {\npublic:\n    bool isSubsetSumPossible(vector<int>& nums, int target) {\n        int n= nums.size();\n        \n        vector<vector<int>> dp(n+1,vector<int>(target+1));\n        dp[0][0]=true;\n        for(int i=1;i<=n;i++){\n            for(int j=0;j<=target;j++){\n                if(j>=nums[i-1]){\n                    dp[i][j]= dp[i-1][j-nums[i-1]] or dp[i-1][j];\n                }else{\n                    dp[i][j]= dp[i-1][j];\n                }\n            }\n        }\n        \n        return dp[n][target];\n    }\n    \n    bool isPossible(int k,vector<int>& nums,vector<vector<int>>& queries){\n        int n= nums.size();\n        \n        vector<int> nums2= nums;\n        \n        vector<vector<int>> v(n);\n        for(int i=0;i<=k;i++){\n            int l= queries[i][0], r= queries[i][1], val= queries[i][2];\n            \n            for(int j=l;j<=r;j++){\n                v[j].push_back(val);\n            }\n        }\n        \n        for(int i=0;i<n;i++){\n            if(nums2[i]==0) continue;\n            // if(v[i].size()>0){\n                bool res= isSubsetSumPossible(v[i],nums[i]);\n                if(res==false) return false;\n                nums2[i]=0;\n            // }\n        }\n        \n        for(int i=0;i<n;i++){\n            if(nums2[i]!=0) return false;\n        }\n        \n        return true;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n= nums.size();\n        \n        int flag=1;\n        for(int i=0;i<n;i++){ //already all zero\n            if(nums[i]!=0){\n                flag=0;\n                break;\n            }\n        }\n\n        if(flag) return 0;\n        \n        int s= 0;\n        int e= queries.size()-1;\n        int ans= -2;\n        \n        while(s<=e){\n            int mid= (s+e)/2;\n            if(isPossible(mid,nums,queries)){\n                ans= mid;\n                e= mid-1;\n            }else{\n                s= mid+1;\n            }\n        }\n        \n        return ans+1;\n    }\n};","author":"shresth024","submissionId":"1575170437"},[]]},{"483":[{"id":"483","fileName":"1575170615.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] bottle, int[][] curtain) {\n        Object blanket = new Object[]{bottle, curtain};\n        \n        int pillow = curtain.length;\n        int blanketSize = bottle.length;\n        \n        boolean alrskldlkaro = true;\n        for (int b : bottle) {\n            if (b != 0) {\n               alrskldlkaro = false;\n                break;\n            }\n        }\n        if ( alrskldlkaro) return 0;\n        \n        int low = 0, high = pillow + 1;\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            if (canZero(bottle, curtain, mid)) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        \n        return (low <= pillow) ? low : -1;\n    }\n    \n    private boolean canZero(int[] bottle, int[][] curtain, int pillow) {\n        int blanketSize = bottle.length;\n        for (int i = 0; i < blanketSize; i++) {\n            if (bottle[i] == 0) continue;\n            \n            ArrayList<Integer> candidates = new ArrayList<>();\n            for (int j = 0; j < pillow; j++) {\n                int li = curtain[j][0], ri = curtain[j][1], val = curtain[j][2];\n                if (li <= i && i <= ri) {\n                    candidates.add(val);\n                }\n            }\n            \n            int target = bottle[i];\n            boolean[] dp = new boolean[target + 1];\n            dp[0] = true;\n            for (int candidate : candidates) {\n                for (int s = target - candidate; s >= 0; s--) {\n                    if (dp[s]) {\n                        dp[s + candidate] = true;\n                    }\n                }\n                if (dp[target]) break;\n            }\n            \n            if (!dp[target]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void exndklnaOne() {\n        System.out.println(\"Thisnsdklanklnsdkl;anldnkl;ed.\");\n    }\n\n    private int ejasdnfljakjkdsko(int amlmmlt) {\n        return amlmmlt * 9;\n    }\n}\n","author":"KUSHAL PRIYA","submissionId":"1575170615"},[]]},{"484":[{"id":"484","fileName":"1575170717.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int m = queries.length;\n        int n = nums.length;\n        boolean[] check = new boolean[n];\n        List<Set<Integer>> sets = new ArrayList<>(); \n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            sets.add(new HashSet<>());\n            if (nums[i] == 0) {\n                check[i] = true;\n                count++;\n            } else {\n                sets.get(i).add(nums[i]);\n            }\n        }\n        if (count == n) {\n            return 0;\n        }\n        for (int i = 0; i < m; i++) {\n            int l = queries[i][0], r = queries[i][1], v2 = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                if (check[j]) {\n                    continue;\n                }\n                Set<Integer> set2 = new HashSet<>();\n                for (int v : sets.get(j)) {\n                    if (v == v2) {\n                        check[j] = true;\n                    } else if (v > v2) {\n                        set2.add(v - v2);\n                    }\n                }\n                sets.get(j).addAll(set2);\n            }\n            count = 0;\n            for (boolean c : check) {\n                if (c) {\n                    count++;\n                }\n            }\n            if (count == n) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n}","author":"zhenghao","submissionId":"1575170717"},[]]},{"485":[{"id":"485","fileName":"1575170921.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        num_set = [set([0]) for _ in nums]\n        num_ans = [0 if x!=0 else 1 for x in nums]\n        if all(num_ans):\n            return 0\n        for k, (l, r, val) in enumerate(queries):\n            for add in range(l , r+1):\n                if num_ans[add] == 0:\n                    add_set = {x + val for x in num_set[add]}\n                    num_set[add].update(add_set)\n                    if nums[add] in num_set[add]:\n                        num_ans[add] = 1\n            if all(num_ans):\n                return k + 1\n        return -1\n","author":"Sunny","submissionId":"1575170921"},[]]},{"486":[{"id":"486","fileName":"1575170888.txt","sourceCode":"class Solution {\n    int[][] arr;\n    int dp(int i,int sum,int[][] q,int j){\n        if(sum == 0){\n            return i;\n        }\n        if(i == q.length){\n            return Integer.MAX_VALUE;\n        }\n        if(arr[sum][i] != -1){\n            return arr[sum][i];\n        }\n\n        int a = q[i][0];\n        int b = q[i][1];\n        int v = q[i][2];\n        if(a <= j && j <= b && sum >= v){\n            arr[sum][i] =  Math.min(dp(i+1,sum-v,q,j), dp(i+1,sum,q,j)) ;\n        }\n        else{\n            arr[sum][i] =  dp(i+1,sum,q,j);\n        }\n        return arr[sum][i];\n    }\n    public int minZeroArray(int[] nums, int[][] q) {\n        int n = nums.length;\n        int m = q.length;\n        int ans = -1;\n        arr = new int[1001][m];\n        for(int i = 0;i <= 1000;i++){\n            for(int j = 0;j < m;j++){\n                arr[i][j] = -1;\n            }\n        }\n        for(int i = 0;i < n;i++){\n            arr = new int[1001][m];\n            for(int r = 0;r <= 1000;r++){\n                for(int j = 0;j < m;j++){\n                    arr[r][j] = -1;\n                }\n            }\n            int x = dp(0,nums[i],q,i);\n            if(x == Integer.MAX_VALUE){\n                // System.out.println(i);\n                return -1;\n            }\n            ans = Math.max(ans,x);\n        }\n        return ans;\n    }\n}","author":"Greeshwar R S","submissionId":"1575170888"},[]]},{"487":[{"id":"487","fileName":"1575171006.txt","sourceCode":"class Solution {\npublic:\n    bool knapsack(int W, vector<int> &wt) {\n        int i, j, n = wt.size();\n        vector<bool> dp(W + 1, false);\n        dp[0] = true;\n        for(i = 0; i < n; ++i)\n            for(j = W; j; --j)\n                if (j >= wt[i])\n                    dp[j] = dp[j] || dp[j - wt[i]];\n        return dp[W];\n    }\n    bool func(vector<int>& a, vector<vector<int>>& queries, int k) {\n        int i, j, n = a.size(), m = queries.size();\n        vector<vector<int>> adj(n);\n        while(k--) {\n            auto &q = queries[k];\n            for(i = q[0]; i <= q[1]; ++i) adj[i].push_back(q[2]);\n        }\n        for(i = 0; i < n; ++i)\n            if (!knapsack(a[i], adj[i]))\n                return false;\n        return true;\n    }\n    int minZeroArray(vector<int>& a, vector<vector<int>>& queries) {\n        int i, j, n = a.size(), m = queries.size();\n        int ans = -1, l = 0, r = m;\n        while(l <= r) {\n            int k = (l + r) / 2;\n            if (func(a, queries, k))\n                ans = k, r = k - 1;\n            else l = k + 1;\n        }\n        return ans;\n    }\n};","author":"gtushar","submissionId":"1575171006"},[]]},{"488":[{"id":"488","fileName":"1575170989.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        //how many queries to become a zero array\n        //subset in the range can be decremented\n\n        //decrement exactly is the tricky part, cannot let it overflow i.e. cannot go greedy\n        //for every element > val in the range, you either apply it or you don't\n\n        //can fix an index\n        //for each index see what query you have to go until in order for it to work\n        //the max of those is your answer\n        int worst = INT_MIN;\n        bool all_zero = true;\n        for(int i = 0; i < nums.size(); i++){\n            if(nums[i] != 0){\n                all_zero = false;\n            }\n            std::unordered_map<long long, int> cache;\n            auto ans = get_val(i, nums[i], queries, 0, cache);\n            if(ans == INT_MAX){\n                return -1;\n            }\n            worst = std::max(worst, ans);\n        }\n        if(all_zero){\n            return 0;\n        }\n        return worst+1;\n    }\n\n    int get_val(const int n_idx, int num, auto& queries, int idx, auto& cache){\n        if(num == 0){\n            return idx;\n        }\n        if(idx == queries.size()){\n            return INT_MAX;\n        }\n\n        long long key = (((num << 11) | idx) << 5) | n_idx;\n        if(cache.find(key) != cache.end()){\n            return cache[key];\n        }\n        \n        auto& q = queries[idx];\n        // std::cout << q.size() << std::endl;\n        // std::cout << queries.size() << std::endl;\n        // std::cout << idx << std::endl;\n        int s = q[0], e = q[1], v = q[2]; \n        // std::cout << \"post\" << std::endl;\n        if(n_idx < s || n_idx > e || v > num){\n            auto ans = get_val(n_idx, num, queries, idx+1, cache);\n            cache[key] = ans;\n            // std::cout << \"postro\" << std::endl;\n            return ans;\n        }\n        if(v == num){\n            return idx;\n        }\n\n        //apply\n        int apply = get_val(n_idx, num-v, queries, idx+1, cache);\n\n        int dont = get_val(n_idx, num, queries, idx+1, cache);\n\n        \n        auto ans = std::min(apply, dont);\n        cache[key] = ans;\n        return ans;\n    }\n};","author":"d11235813","submissionId":"1575170989"},[]]},{"489":[{"id":"489","fileName":"1575170525.txt","sourceCode":"class Solution {\npublic:\n    int recure(vector<vector<int>> &queries, int val, int ind, int q, vector<vector<int>> &dp){\n        if(val == 0) return q;\n        if(q == queries.size()) return 1e9;\n        \n        if(dp[q][val] != -1) return dp[q][val];\n        \n        if(queries[q][0] <= ind && queries[q][1] >= ind && queries[q][2] <= val){\n            return dp[q][val] = min(recure(queries, val-queries[q][2], ind, q+1, dp), recure(queries, val, ind, q+1, dp));\n        }\n        return dp[q][val] = recure(queries, val, ind, q+1, dp);\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        \n        vector<int> ans(n);\n        for(int i=0; i<n; i++){\n            //{q, val}\n            vector<vector<int>> dp(queries.size(), vector<int>(nums[i]+1, -1));\n                \n            ans[i] = recure(queries, nums[i], i, 0, dp);\n        }\n        int k = 0;\n        for(auto val: ans) k = max(k, val);\n        return (k == 1e9 ? -1 : k);\n    }\n};","author":"Gunaho ka Devta","submissionId":"1575170525"},[]]},{"490":[{"id":"490","fileName":"1575170668.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        auto abc = make_pair(nums, queries);\n        bool allZero = true;\n        for (int x : nums) {\n            if (x != 0) { \n                allZero = false; \n                break; \n            }\n        }\n        if (allZero) return 0;\n        int m = queries.size(), lo = 1, hi = m, ans = -1;\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (check(nums, queries, mid)) {\n                ans = mid;\n                hi = mid - 1;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        return ans;\n    }\n    \n    bool check(const vector<int>& nums, const vector<vector<int>>& queries, int k) {\n        int n = nums.size();\n        vector<bitset<1001>> dp(n);\n        for (int j = 0; j < n; j++) {\n            dp[j].reset();\n            dp[j].set(0, true);\n        }\n        for (int i = 0; i < k; i++) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                dp[j] |= (dp[j] << val);\n            }\n        }\n        for (int j = 0; j < n; j++) {\n            if (!dp[j].test(nums[j])) return false;\n        }\n        return true;\n    }\n};\n","author":"autumn_1eaf","submissionId":"1575170668"},[]]},{"491":[{"id":"491","fileName":"1575171156.txt","sourceCode":"class Solution {\npublic:\n    bool check(int k, vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            bitset<1001> dp;\n            dp.reset();\n            dp[0] = 1;\n            for (int j = 0; j < k; j++) {\n                if (queries[j][0] <= i && i <= queries[j][1])\n                    dp |= (dp << queries[j][2]);\n            }\n            if (!dp[target]) return 0;\n        }\n        return 1;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int lo = 0, hi = queries.size(), ans = -1;\n        while (lo <= hi) {\n            int mid = (lo + hi) / 2;\n            if (check(mid, nums, queries)) {\n                ans = mid;\n                hi = mid - 1;\n            } \n            else lo = mid + 1;\n        }\n        return ans;\n    }\n};\n","author":"Aditya Roy Chowdhury","submissionId":"1575171156"},[]]},{"492":[{"id":"492","fileName":"1575171272.txt","sourceCode":"class Solution {\npublic:\n    vector<bool> isSubsetSum(vector<int> &arr, int sum) {\n        int n = arr.size();\n\n        vector<bool> ans;\n        vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));\n        for (int i = 0; i <= n; i++)\n            dp[i][0] = true;\n\n            for (int i = 1; i <= n; i++) {\n\n                for (int j = 1; j <= sum; j++) {\n                    if (j < arr[i - 1]) {\n                        dp[i][j] = dp[i - 1][j]; \n                    }\n                    else {\n                        dp[i][j] = dp[i - 1][j] || dp[i - 1][j - arr[i - 1]];\n                    }\n                }\n        }\n        for(int i = 0; i <= n; i++)\n            ans.push_back(dp[i][sum]);\n        return ans;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = queries.size();\n        int start = 0;\n        int end = n;\n        int ans = -1;\n        \n        vector<vector<bool> > vals;\n        \n        for(int i = 0; i < nums.size(); i++) {\n            vector<int> diff(n, 0);\n            for(int j = 0 ; j < n; j++) {\n                if(queries[j][0] <= i && queries[j][1] >= i)\n                    diff[j] = queries[j][2];\n                // cout<<diff[j]<<\": \";\n            }\n            // cout<<endl;\n            vals.push_back(isSubsetSum(diff, nums[i]));\n        }\n        \n        // for(int i = 0; i < nums.size(); i++) {\n        //     for(int j = 0; j < n; j++) {\n        //         cout<<vals[i][j]<<\" : \";\n        //     }\n        //     cout<<endl;\n        // }\n        \n        while(start <= end) {\n            int mid = (start + end)/2;\n            if(isPossible(mid, vals)) {\n                ans = mid;\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return ans;\n    }\n    \n    bool isPossible(int k, vector<vector<bool>> vals) {\n        for(int i = 0; i < vals.size(); i++) {\n            if(vals[i][k] == false)\n                return false;\n        }\n        return true;\n    }\n};","author":"Satyam Bansal","submissionId":"1575171272"},[]]},{"493":[{"id":"493","fileName":"1575171186.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n\n        n = len(nums)\n        dp = [[set({0}) for i in range(n)] for j in range(len(queries) + 1)] # dp[i][j] contains set of values that are obtainable at query i for index j\n\n        for i in range(len(queries)):\n            for j in range(n):\n                to_extend = set(list(dp[i][j]))\n                if j >= queries[i][0] and j <= queries[i][1]:\n                    to_extend.add(queries[i][2])\n                    for v in dp[i][j]:\n                        to_extend.add(v + queries[i][2])\n                    to_extend.union(dp[i][j])\n                    #print(i, j, dp[i][j])\n                dp[i + 1][j] = to_extend\n        #for i in dp:\n        #    print(i)\n        for i in range(len(queries) + 1):\n            works = True\n            for j in range(n):\n                if nums[j] not in dp[i][j]:\n                    works = False\n                    break\n            if works:\n                return i\n        return -1\n\n        # def possible(arr, cur, i=0):\n        #     if cur == 0:\n        #         return True\n        #     if i == len(arr):\n        #         return False\n        #     return possible(arr, cur - arr[i], i+1) or possible(arr, cur, i+1)\n        # n = len(nums)\n        # queries_list = [[[] for i in range(n)]]\n        # for i in range(len(queries)):\n        #     cur = [[b for b in a] for a in queries_list[-1]]\n        #     #print(cur)\n        #     for j in range(queries[i][0], queries[i][1] + 1):\n        #         cur[j].append(queries[i][2])\n        #     queries_list.append(cur)\n        # #for i in range(len(queries_list)):\n        # #    print(i, queries_list[i])\n        # for i in range(len(queries_list)):\n        #     works = True\n        #     #print()\n        #     #print(i, queries_list[i])\n        #     for j in range(n):\n        #         #print(nums[j])\n        #         if not possible(queries_list[i][j], nums[j]):\n        #             works = False\n        #             break\n        #     if works:\n        #         return i\n        # return -1\n","author":"Avery Li","submissionId":"1575171186"},[]]},{"494":[{"id":"494","fileName":"1575171271.txt","sourceCode":"class Solution {\npublic:\nint solve(int val,int k,int index,vector<vector<int>>&q,vector<vector<int>>&dp){\n    if(val==0) return 1;\n    if(val<0) return 0;\n    if(k<0) return 0;\n    if(dp[val][k]!=-1) return dp[val][k];\n    int l= q[k][0];\n    int h=q[k][1];\n    int v= q[k][2];\n    int ans=0;\n    if(index>=l && index<=h){\n        if(solve(val-v,k-1, index,q,dp)==1) ans=1;\n    }\n    if(solve(val,k-1, index,q,dp)==1) ans=1;\n    return dp[val][k]= ans;\n}\nbool isPossible(vector<int>&nums,vector<vector<int>>&q,int mid){\n    for(int i=0;i<nums.size();i++){\n        vector<vector<int>>dp(nums[i]+1,vector<int>(mid,-1));\n        if(solve(nums[i],mid-1,i,q,dp)==0){\n            return false;\n        }\n    }\n    return true;\n}\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l=0,h=queries.size();\n        while((h-l)>1){\n            int mid= l+(h-l)/2;\n            if(isPossible(nums,queries,mid)){\n                h=mid;\n            }\n            else{\n                l=mid;\n            }\n        }\n        if(isPossible(nums,queries,l)) return l;\n        if(isPossible(nums,queries,h)) return h;\n        return -1;\n    }\n};","author":"GavnishKumar","submissionId":"1575171271"},[]]},{"495":[{"id":"495","fileName":"1575171104.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        res = 0        \n        for i, num in enumerate(nums):\n            if num == 0:\n                continue\n                \n            dp = [False] * (num + 1)\n            dp[0] = True\n            for j, (L, R, v) in enumerate(queries):\n                if L <= i <= R:\n                    for k in range(num, v-1, -1):\n                        dp[k] = dp[k] or dp[k - v]\n                if dp[num]:\n                    res = max(res, j + 1)\n                    break\n            if not dp[num]:\n                return -1\n            \n        return res","author":"SMH","submissionId":"1575171104"},[]]},{"496":[{"id":"496","fileName":"1575171249.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        var nonzerocnt=0;\n        int n=nums.length;\n        int qn=queries.length;\n        for (int i=0;i<n;i++) if (nums[i]!=0) nonzerocnt++;\n        if (nonzerocnt==0) return 0;\n        var l=new ArrayList<Set<Integer>>();\n        for (int i=0;i<n;i++) {\n            l.add(new HashSet<Integer>());\n            if (nums[i]!=0) l.get(i).add(nums[i]);\n        }\n        \n        for (int i=0;i<qn;i++) {\n            int left=queries[i][0];\n            int r=queries[i][1];\n            int v=queries[i][2];\n\n            for (int j=left;j<=r;j++) {\n                if (nums[j]==0) continue;\n                if (l.get(j).contains(v)) {\n                    l.get(j).clear();\n                    nums[j]=0;\n                    nonzerocnt--;\n                    if (nonzerocnt==0) return i+1;\n                } else {\n                    var oldvals = new HashSet<Integer>(l.get(j));\n                    for (var w: oldvals) {\n                        if (w>v) l.get(j).add(w-v);\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}","author":"jagbarrameda","submissionId":"1575171249"},[]]},{"497":[{"id":"497","fileName":"1575171426.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        if (accumulate(nums.begin(), nums.end(), 0) == 0) return 0;\n        int n = nums.size();\n        int m = queries.size();\n        vector<vector<bool>> dp(n, vector<bool>(1001));\n        for (int i = 0; i < n; ++i) {\n            dp[i][nums[i]] = true;\n        }\n        int ans = -1;\n        for (int q = 0; q < m; ++q) {\n            ans = q + 1;\n            auto& v = queries[q];\n            int l = v[0], r = v[1], val = v[2];\n            for (int i = l; i <= r; ++i) {\n                if (dp[i][0]) continue;\n                for (int j = val; j <= nums[i]; ++j) {\n                    if (dp[i][j])\n                        dp[i][j - val] = true;\n                }\n            }\n            bool good = true;\n            for (int i = 0; i < n; ++i)\n                if (!dp[i][0]) good = false;\n            if (good) return ans;\n        }\n        return -1;\n    }\n};","author":"Catchet","submissionId":"1575171426"},[]]},{"498":[{"id":"498","fileName":"1575171370.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int[] ks = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            int target = nums[i];\n            if (target == 0) {\n                ks[i] = 0;\n                continue;\n            }\n            HashSet<Integer> set = new HashSet<>();\n            set.add(0);\n            for (int j = 0; j < queries.length; j++) {\n                int[] query = queries[j];\n                if (query[0] <= i && i <= query[1]) {\n                    ArrayList<Integer> vals = new ArrayList<>(set);\n                    for (int v: vals) {\n                        set.add(v + query[2]);\n                    }\n                }\n                if (set.contains(target)) {\n                    ks[i] = j + 1;\n                    break;\n                }\n            }\n            if (ks[i] == 0) {\n               return -1;\n            }\n        }\n        int max = 0;\n        for (int k: ks) {\n            max = Math.max(max, k);\n        }\n        return max;\n    }\n}","author":"aagoran","submissionId":"1575171370"},[]]},{"499":[{"id":"499","fileName":"1575171462.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        def isPossible(k):\n            for i in range(n):\n                target = nums[i]\n                values = []\n                for j in range(k):\n                    l, r, v = queries[j]\n                    if l <= i <= r:\n                        values.append(v)\n                p = {0}\n                for v in values:\n                    np = set(p)\n                    for s in p:\n                        if s + v <= target:\n                            np.add(s + v)\n                    p = np\n                    if target in p:\n                        break\n                if target not in p:\n                    return False\n            return True\n        if sum(nums) == 0:\n            return 0\n        left, right = 1, len(queries)\n        res = -1\n        while left <= right:\n            mid = left + (right - left)//2\n            if isPossible(mid):\n                res = mid \n                right = mid - 1\n            else:\n                left = mid + 1\n        return res","author":"mvar","submissionId":"1575171462"},[]]},{"500":[{"id":"500","fileName":"1575171683.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] q) {\n        int n = nums.length, m = q.length, max = 0;\n        boolean[][] v = new boolean[n][];\n        int[] mins = new int[n];\n        for (int i = 0; i < n; i++) {\n            v[i] = new boolean[nums[i] + 1];\n            v[i][0] = true;\n            if (nums[i] != 0) mins[i] = -1;\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = q[i][0]; j <= q[i][1]; j++) {\n                for (int k = v[j].length - q[i][2] - 1; k >= 0; k--) {\n                    if (v[j][k]) v[j][k + q[i][2]] = true;\n                }\n                if (v[j][v[j].length - 1] && mins[j] == -1) mins[j] = i + 1;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (mins[i] == -1) return -1;\n            max = Math.max(max, mins[i]);\n        } \n        return max;\n    }\n}","author":"Arucade","submissionId":"1575171683"},[]]},{"501":[{"id":"501","fileName":"1575172194.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        @cache\n        def dp(qi, ni, num):\n            if num == 0:\n                return qi\n            if qi >= len(queries):\n                return -1\n            l, r, val = queries[qi]\n            if ni < l or r < ni or val > num:\n                return dp(qi + 1, ni, num)\n            res0 = dp(qi + 1, ni, num)\n            res1 = dp(qi + 1, ni, num - val)\n            if res0 == -1:\n                return res1\n            elif res1 == -1:\n                return res0\n            else:\n                return min(res0, res1)\n        ans = 0\n        for i, num in enumerate(nums):\n            k = dp(0, i, num)\n            if k == -1:\n                return -1\n            ans = max(ans, k)\n        return ans","author":"Theo","submissionId":"1575172194"},[]]},{"502":[{"id":"502","fileName":"1575171419.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        dp = [1 << 0 for _ in range(n)]\n        \n        # if all (0) -> 0\n        if all(x == 0 for x in nums):\n            return 0\n        \n        for k, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                org_val = dp[j]\n                shifts = org_val << v\n                # new_val = org_val || shifts\n                new_val = org_val | shifts\n                \n                # keep only one bits \n                mask = (1 << (nums[j] + 1)) - 1\n                new_val &= mask\n                dp[j] = new_val\n            \n            # target bit set check\n            acvs = True\n            for j in range(n):\n                \n                if (dp[j] & (1 << nums[j])) == 0:\n                    acvs = False\n                    break\n            if acvs:\n                return k + 1  \n        \n        return -1","author":"pyorz","submissionId":"1575171419"},[]]},{"503":[{"id":"503","fileName":"1575171768.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n\n        coverage = [ [] for _ in range(n) ] \n\n        def can_form_target(vals, target):\n            if sum(vals) < target:\n                return False\n            vals.sort(reverse=True)\n            \n            def backtrack(i, cur_sum):\n                if cur_sum == target:\n                    return True\n                if i == len(vals) or cur_sum > target:\n                    return False\n                if backtrack(i+1, cur_sum + vals[i]):\n                    return True\n                return backtrack(i+1, cur_sum)\n\n            return backtrack(0, 0)\n\n        def canZero(k):\n            coverage = [[] for _ in range(n)]\n            for i in range(k):\n                l_i, r_i, val_i = queries[i]\n                for j in range(l_i, r_i+1):\n                    coverage[j].append(val_i)\n\n            # For each index j, we need to see if there's a subset of coverage[j]\n            # that sums exactly to nums[j].\n            for j in range(n):\n                x = nums[j]\n                if x == 0:\n                    continue\n                if not can_form_target(coverage[j], x):\n                    return False\n            return True\n\n        left, right = 0, m+1   # right = m+1 so we can test if left>m eventually\n        while left < right:\n            mid = (left + right) // 2\n            if canZero(mid):\n                right = mid\n            else:\n                left = mid + 1\n\n        # left is the smallest k s.t. canZero(k) is True, if it <= m\n        if left <= m:\n            return left\n        else:\n            return -1","author":"Boris Chen","submissionId":"1575171768"},[]]},{"504":[{"id":"504","fileName":"1575172142.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        \"\"\"\n        if i find for each positions in how many steps it will be zero then done nah max one is answer\n        \"\"\"\n        # @cache\n        # @cache\n        dp={}\n        def do(pos,val,q_p):\n            if((pos,val,q_p) in dp):\n                return dp[(pos,val,q_p)]\n            if(val==0):\n                return 0\n            if(val<0 or q_p==len(queries)):\n                return float('inf')\n            p,q,r=queries[q_p]\n            ans=1+do(pos,val,q_p+1)\n            if(pos<=q and pos>=p):\n                ans=min(ans,1+do(pos,val-r,q_p+1))\n            dp[(pos,val,q_p)]=ans\n            return ans\n        res=-1\n        for i in range(len(nums)):\n            res=max(res,do(i,nums[i],0))\n            dp={}\n        return -1 if res==float('inf') else res\n                \n            ","author":"Vishnu Bathla","submissionId":"1575172142"},[]]},{"505":[{"id":"505","fileName":"1575172224.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        List<List<Boolean>> dp = new ArrayList<>();\n        int zeros = 0;\n        for (int i = 0; i < n; i++) {\n            dp.add(Arrays.asList(new Boolean[nums[i] + 1]));\n            dp.get(i).set(nums[i], true);\n            if (nums[i] == 0) {\n                zeros++;\n            }\n        }\n        if (zeros == n) {\n            return 0;\n        }\n        for (int i = 0; i < m; i++) {\n            int val = queries[i][2], l = queries[i][0], r = queries[i][1];\n            for (int j = l; j <= r; j++) {\n                if (dp.get(j).get(0) != null && dp.get(j).get(0) == true) {\n                    continue;\n                }\n                for (int k = 0; k <= nums[j] - val; k++) {\n                    if (dp.get(j).get(k + val) != null && dp.get(j).get(k + val) == true) {\n                        dp.get(j).set(k, true);\n                    }\n                }\n                if (dp.get(j).get(0) != null && dp.get(j).get(0) == true) {\n                    zeros++;\n                }\n            }\n            \n            if (zeros == n) {\n                return i + 1;\n            }\n        }\n        // System.out.println(dp);\n        \n        return -1;\n    }\n}","author":"Fasdr","submissionId":"1575172224"},[]]},{"506":[{"id":"506","fileName":"1575172481.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        if all(x == 0 for x in nums):\n            return 0\n        dp = [1] * n\n        masks = [(1 << (x + 1)) - 1 for x in nums]\n        for k, (l, r, v) in enumerate(queries, 1):\n            for i in range(l, r + 1):\n                dp[i] |= dp[i] << v\n                dp[i] &= masks[i]\n            if all((dp[i] >> nums[i]) & 1 for i in range(n)):\n                return k\n        return -1\n","author":"commallama","submissionId":"1575172481"},[]]},{"507":[{"id":"507","fileName":"1575172222.txt","sourceCode":"class Solution {\npublic:\n    int f(int i , int num , int ref , vector<vector<int> > & qe , vector<vector<int> > & dp){\n        if(num == 0){\n            return 0;\n        }\n        int q = qe.size();\n        if(i >= q){\n            return (int)1e7;\n        }\n        if(dp[i][num] != -1){\n            return dp[i][num];\n        }\n        int ans = f(i + 1 , num , ref , qe , dp) + 1;\n        if(qe[i][0] <= ref && ref <= qe[i][1] && qe[i][2] <= num){\n            ans = min(ans , f(i + 1 , num - qe[i][2] , ref , qe , dp) + 1);\n        }\n        return dp[i][num] = ans;\n    }\n    int minZeroArray(vector<int>& v, vector<vector<int>>& qe) {\n        int n = v.size();\n        int q = qe.size();\n        vector<int> mn_ops_for_i(n);\n        for(int i = 0 ; i < n ; i ++){\n            {\n                int sum = 0;\n                for(int k = 0 ; k < q ; k ++){\n                    if(qe[k][0] <= i && i <= qe[k][1]){\n                        sum += qe[k][2];\n                    }\n                }\n                if(sum < v[i]){\n                    return -1;\n                }\n            }\n            vector<vector<int> > dp(q , vector<int> (v[i] + 1 , -1));\n            mn_ops_for_i[i] = f(0 , v[i] , i , qe , dp);\n        }\n        int ans = 0;\n        for(int i = 0 ; i < n ; i ++){\n            ans = max(ans , mn_ops_for_i[i]);\n        }\n        if(ans >= 1e7){\n            return -1;\n        }\n        return ans;\n    }\n};","author":"simplesheep03","submissionId":"1575172222"},[]]},{"508":[{"id":"508","fileName":"1575172610.txt","sourceCode":"class Solution {\npublic:\n    int dpf(int i , int ele,int eleind, vector<vector<int>>&dp, vector<vector<int>>&queries){\n        if(ele==0) return i;\n        if(i==queries.size() || ele < 0) return INT_MAX;\n        if(dp[i][ele]!=-1) return dp[i][ele];\n        int take = INT_MAX;\n        if(queries[i][0]<=eleind && queries[i][1]>=eleind){\n            take = dpf(i+1,ele-queries[i][2],eleind, dp, queries);\n        }\n        int nottake = dpf(i+1,ele,eleind,dp,queries);\n        dp[i][ele] = min(take,nottake);\n        return dp[i][ele];\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = 0;\n        for(int i = 0; i < nums.size(); i++){\n            int ele  = nums[i];\n            vector<vector<int>>dp(queries.size(),vector<int>(ele+1,-1));\n            \n            ans = max(ans,dpf(0,nums[i],i,dp,queries));\n        }\n        if(ans==INT_MAX) return -1;\n        return ans;\n    }\n};","author":"sai_uma_sankar","submissionId":"1575172610"},[]]},{"509":[{"id":"509","fileName":"1575172768.txt","sourceCode":"class Solution {\npublic:\n    bool check(int mid, vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> v(n);\n        for (int j=0;j<mid;j++) \n        {\n            int l=queries[j][0], r=queries[j][1], val=queries[j][2];\n            for (int i=l;i<=r;i++) \n            {\n                if (i>=0 && i<n) \n                {\n                    v[i].push_back(val);\n                }\n            }\n        }\n        for (int i=0;i<n;i++) \n        {\n            int k=nums[i];\n            if (k==0) \n                continue;\n            bitset<1001> dp;\n            dp[0] = 1;\n            for (int x:v[i]) {\n                dp|=dp<<x;\n            }\n            if (!dp[k]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int q = queries.size();\n        bool flag = true;\n        for(int it : nums) \n        {\n            if(it != 0) \n            {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) \n            return 0;\n        int lo=0,hi=q+1;\n        while(lo<hi) \n        {\n            int mid=lo+(hi-lo)/2;\n            if (check(mid,nums,queries))\n                hi=mid;\n            else\n                lo=mid+1;\n        }\n        return (lo>q)?-1:lo;\n    }\n};","author":"LemonDrop","submissionId":"1575172768"},[]]},{"510":[{"id":"510","fileName":"1575172430.txt","sourceCode":"typedef int ll;\nclass Solution {\npublic:\n    ll cal(vector<vector<int>>& queries,ll val,ll p){\n        \n        ll n  =queries.size();\n        vector <vector <ll>> dp(n+1,vector <ll> (val+1,n+1));\n        for(ll a=0;a<=val;a++){\n            for(ll i=n-1;i>=0;i--){\n                if(a==0){\n                    dp[i][a] = 0;\n                    continue;\n                }\n                if(queries[i][0]>p || queries[i][1]<p){\n                    dp[i][a] = dp[i+1][a];\n                }\n                else if(queries[i][2]==a){\n                    dp[i][a] = min(dp[i][a],i+1);\n                }\n                else if(queries[i][2]<a){\n                    dp[i][a] = min(dp[i][a],min(dp[i+1][a],dp[i+1][a-queries[i][2]]));\n                }\n                else{\n                    dp[i][a] = min(dp[i][a],dp[i+1][a]);\n                }\n            }\n        }\n        // for(ll a=0;a<n;a++){\n        //     for(ll i=0;i<=val;i++){\n        //         cout<<dp[a][i]<<\" \";\n        //     }\n        //     cout<<endl;\n        // }\n        // cout<<endl;\n        ll x = dp[0][val];\n        if(x==n+1){\n            return -1;\n        }\n        return x;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        ll n = queries.size();\n        ll ans =0;\n        ll i = 0;\n        for(auto x : nums){\n            ll p = cal(queries,x,i);\n            if(p==-1){\n                return -1;\n            }\n            ans = max(ans,p);\n            // cout<<ans<<endl;\n            i++;\n        }\n        // cout<<endl;\n        return ans;\n    }\n};","author":"Alok Priydarshi","submissionId":"1575172430"},[]]},{"511":[{"id":"511","fileName":"1575172668.txt","sourceCode":"class Solution {\npublic:\n    bool help(vector<int>a, int sum){\n        int n = a.size();\n        if(sum==0) return true;\n        vector<vector<int>> dp(n+1,vector<int>(sum+1,0));\n        for(int i=0;i<=n;i++){\n            dp[i][0] = 1;\n        }\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=sum;j++){\n                dp[i][j]=dp[i-1][j];\n                if(a[i-1]<=j){\n                    dp[i][j] = (dp[i][j])||(dp[i-1][j-a[i-1]]);\n                }\n            }\n            if(dp[i][sum]==1) return 1;\n        }\n        return dp[n][sum];\n    }\n    int minZeroArray(vector<int>& a, vector<vector<int>>& que) {\n        int n=que.size(),m=a.size();\n        int low=0,high=n-1,ans=n;\n        bool fuck=true;\n        for(auto &it:a){\n            if(it!=0) {fuck=false;break;}\n        }\n        if(fuck) return 0;\n        while(low<=high){\n            int mid=low+(high-low)/2;\n            \n            vector<vector<int>> used(m);\n            for(int i=0;i<=mid;i++){\n                for(int j=que[i][0];j<=que[i][1];j++){\n                    used[j].push_back(que[i][2]);\n                }\n            }\n            bool check=true;\n            for(int i=0;i<m;i++){\n                int sum=a[i];\n                vector<int> temp=used[i];\n                bool cur = help(temp,sum);\n                \n                if(!cur) {\n                    check=false;\n                    break;\n                }\n            }\n\n            if(!check) low=mid+1;\n            else {\n                ans=mid;\n                high=mid-1;   \n            }\n        }\n        return ans==n?-1:ans+1;\n    }\n};","author":"Meda Jaswanth","submissionId":"1575172668"},[]]},{"512":[{"id":"512","fileName":"1575172504.txt","sourceCode":"class Solution {\npublic:\n    #define ll long long\n    \n    int solve(vector<vector<int>> & arr, int val, int pos, int n, vector<vector<ll>> & dp){\n        if(val == 0){\n            return 0;\n        }\n        if(pos == arr.size()){\n            return n;\n        }\n        if(dp[pos][val] != -1){\n            return dp[pos][val];\n        }\n        int v1 = solve(arr,val,pos+1,n,dp);\n        int v2 = n;\n        \n        if(arr[pos][0]<=val){\n            v2 = max(arr[pos][1], solve(arr,val-arr[pos][0],pos+1,n,dp));\n        }\n        \n        return dp[pos][val] = min(v1,v2);\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<vector<int>>> arr(n);\n        \n        int pos = 0;\n        for(auto it : queries){\n            \n            int l = it[0] , r = it[1];\n            for(int i = l ; i<=r; i++){\n                arr[i].push_back({it[2],pos+1});\n            }\n            pos++;\n        }\n        \n        int maxi = 0;\n        \n        for(int i = 0; i<n; i++){\n            int len = arr[i].size();\n            if(nums[i] == 0) continue;\n            vector<vector<ll>> dp(len,vector<ll>(nums[i]+1,-1));\n            \n            int val = solve(arr[i],nums[i],0,queries.size()+1,dp);\n            \n            maxi = max(maxi,val);\n        }\n        int q = queries.size();\n        if(maxi == q+1){\n            return -1;\n        }\n        else{\n            return maxi;\n        }\n    }\n};","author":"Sudhanshu Pandey","submissionId":"1575172504"},[]]},{"513":[{"id":"513","fileName":"1575172788.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& qs) {\n        int n=nums.size();\n        vector<bool> good(n, false);\n        int rem=n;\n        for(int i=0; i<n; i++)\n        {\n            if(nums[i]==0) good[i]=true, --rem;\n        }\n\n        int ans=0;\n        if(rem==0) return ans;\n\n        vector<set<int>> poss(n);\n\n        for(auto &q:qs)\n        {\n            ++ans;\n            int l=q[0], r=q[1], v=q[2];\n\n            // cout<<l<<\" - \"<<r<<\" - \"<<v<<endl;\n            for(int i=l; i<=r; i++)\n            {\n                // cout<<\"> i = \"<<i<<\" - \"<<poss[i].size()<<endl;\n                if(good[i]) continue;\n                if(poss[i].size()==0) poss[i].insert(v);\n                else\n                {\n                    set<int> nv;\n                    for(auto &el:poss[i])\n                    {\n                        int ns=el+v;\n                        if(poss[i].count(ns)==0 && ns<=nums[i])\n                        nv.insert(ns);\n                    }\n\n                    if(nv.size()>0)\n                    for(auto &el:nv) poss[i].insert(el);\n\n                    poss[i].insert(v);\n                }\n\n                if(poss[i].count(nums[i]))\n                {\n                    good[i]=true;\n                    --rem;\n                }\n            }\n\n            if(rem==0) return ans;\n        }\n\n        return -1;\n    }\n};","author":"Mintu Jupally","submissionId":"1575172788"},[]]},{"514":[{"id":"514","fileName":"1575172911.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int m = queries.length;\n\n        int left = 0, right = m, ans = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (canZero(nums, queries, mid)) {\n                ans = mid;         \n                right = mid - 1;\n            } else {\n                left = mid + 1;    \n            }\n        }\n        return ans;\n    }\n    \n    private boolean canZero(int[] nums, int[][] queries, int k) {\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            if (!canZeroAtIndex(nums[i], i, queries, k))\n                return false;\n        }\n        return true;\n    }\n    \n    private boolean canZeroAtIndex(int target, int i, int[][] queries, int k) {\n        if (target == 0) return true;\n        \n        BitSet dp = new BitSet(target + 1);\n        dp.set(0); \n  \n        for (int j = 0; j < k; j++) {\n            int l = queries[j][0], r = queries[j][1], v = queries[j][2];\n            if (l <= i && i <= r) {\n                BitSet shifted = shift(dp, v, target);\n                dp.or(shifted);\n                if (dp.get(target)) break;\n            }\n        }\n        return dp.get(target);\n    }\n\n    private BitSet shift(BitSet bs, int v, int max) {\n        BitSet shifted = new BitSet(max + 1);\n        for (int s = bs.nextSetBit(0); s >= 0 && s <= max - v; s = bs.nextSetBit(s + 1)) {\n            shifted.set(s + v);\n        }\n        return shifted;\n    }\n}\n","author":"Manali","submissionId":"1575172911"},[]]},{"515":[{"id":"515","fileName":"1575172843.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        boolean[] isChecked = new boolean[nums.length];\n        Map<Integer, Set<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 0) {\n                isChecked[i] = true;\n            }\n            Set<Integer> se = new HashSet<>();\n            se.add(0);\n            map.put(i, se);\n        }\n        if (isFinsihed(isChecked)) {\n            return 0;\n        }        \n        for (int i = 0; i < queries.length; i++) {\n            int left = queries[i][0];\n            int right = queries[i][1];\n            int val = queries[i][2];\n            for (int p = left; p <= right; p++) {\n                if (isChecked[p]) {\n                    continue;\n                }\n                if (helper(map, p, val, nums[p])) {\n                    isChecked[p] = true;\n                }\n            }\n            if (isFinsihed(isChecked)) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n    public boolean helper(Map<Integer, Set<Integer>> map, int pos, int val, int target) {\n        Set<Integer> set = map.get(pos);\n        Set<Integer> set2 = new HashSet<>();\n        for (int i : set) {\n            int next = i + val;\n            if (target == next) {\n                return true;\n            }\n            if (!set.contains(next)) {\n                set2.add(next);\n            }\n        }\n        for (int i : set2) {\n            set.add(i);\n        }\n        return false;\n    }    \n    \n    public boolean isFinsihed(boolean[] checked) {\n        for (int i = 0; i < checked.length; i++) {\n            if (!checked[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n// 1 2 3\n\n// 1\n// 1 2 3\n// 4 5 6","author":"jason_wong1","submissionId":"1575172843"},[]]},{"516":[{"id":"516","fileName":"1575172984.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        const int n = nums.size(), q = queries.size();\n\n        if (std::accumulate(nums.begin(), nums.end(), 0) == 0) {\n            return 0;\n        }\n        \n        int l = 1, r = q;\n        int ans = -1;\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            \n            std::vector<std::vector<int>> a(n + 1);\n            for (int i = 0; i < mid; ++i) {\n                for (int x = queries[i][0]; x <= queries[i][1]; ++x) {\n                    a[x].push_back(queries[i][2]);\n                }\n            }\n\n            bool ok = true;\n            for (int i = 0; i < n && ok; ++i) {\n                std::vector<bool> dp(nums[i] + 1);\n                dp[0] = true;\n                for (const int &v: a[i]) {\n                    for (int j = nums[i] - v; j >= 0; --j) {\n                         dp[j + v] = dp[j + v] || dp[j];   \n                    }\n                }\n\n                ok = dp[nums[i]];\n            }\n\n            if (ok) {\n                ans = mid;\n                r = mid - 1;\n            }\n            else {\n                l = mid + 1;\n            }\n        }\n\n        return ans;\n    }\n};","author":"mcuadros","submissionId":"1575172984"},[]]},{"517":[{"id":"517","fileName":"1575173042.txt","sourceCode":"class Solution {\n    bool isSubset(vector<int>& arr,int sum){\n        int n = arr.size();\n        vector<bool>dp1(sum+1,0);\n        vector<bool>dp2(sum+1,0);\n        for(int i = 1;i<=n;i++){\n            for(int t = 1;t<=sum;t++){\n                if(t < arr[i-1])\n                    dp2[t] = dp1[t];\n                else if(t == arr[i-1] || dp1[t-arr[i-1]]) dp2[t] = 1;\n            }\n            if(dp2[sum]) return 1;\n            dp1 = dp2;\n        }\n        return dp1[sum];\n    }\n    bool check(vector<int>& nums,vector<vector<int>>& q,int k){\n        int n = nums.size();\n        vector<vector<int>> sums(n);\n        for(int i = 0;i<=k;i++){\n            for(int j = q[i][0];j<=q[i][1];j++){\n                sums[j].push_back(q[i][2]);\n            }\n        }\n        for(int i = 0;i<n;i++){\n            if(!nums[i]) continue;\n            // cout<<nums[i]<<\" \"<<isSubset(sums[i],nums[i])<<endl;\n            if(!isSubset(sums[i],nums[i])) return false;\n        }\n        return true;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int i = 0,j = queries.size()-1,res = -2;\n        bool b = true;\n        for(auto& i : nums) if(i) {b = false;break;}\n        if(b) return 0;\n        while(i<=j){\n            int m = (i+j) >> 1;\n            if(check(nums,queries,m)) res = m,j = m-1;\n            else i = m+1;\n            // cout<<endl;\n        }\n        return res+1;\n    }\n};","author":"Sithaarth M","submissionId":"1575173042"},[]]},{"518":[{"id":"518","fileName":"1575172784.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        \n        def check(m):\n            \n            mem = defaultdict(list)\n            \n            for i in range(m):\n                l,r,q = queries[i]\n                for j in range(l, r + 1):\n                    if q <= nums[j]:\n                        mem[j].append(q)\n                        \n                        \n            for i,v in enumerate(nums):\n                if v == 0:\n                    continue\n                    \n                dic = Counter(mem[i])\n                dp = {}\n                dp[0] = 1\n                items = []\n                \n                for key, val in dic.items():\n                    cnt = 1\n                    \n                    while val >= cnt:\n                        val -= cnt\n                        items.append((cnt * key))\n                        cnt *= 2\n                        \n                    if val:\n                        items.append((val * key))\n                        \n                for k in items:\n                    tmp = deepcopy(dp)\n                    for key in dp:\n                        if key + k > v:\n                            continue\n                        if key + k == v:\n                            tmp[v] = 1\n                            break\n                        tmp[key + k] = 1\n                        \n                    dp = tmp\n                    \n                if v not in dp:\n                    return False\n                \n                \n            return True\n                    \n        \n        leng = len(nums)\n        if nums == [0] * leng:\n            return 0\n        \n        l = 1\n        r = len(queries)\n        \n        while l <= r:\n            m = (l + r) // 2\n            if check(m):\n                r = m - 1\n            else:\n                l = m + 1\n                \n        return r + 1 if r + 1 <= len(queries) else -1\n    ","author":"czjnbb","submissionId":"1575172784"},[]]},{"519":[{"id":"519","fileName":"1575173159.txt","sourceCode":"from math import inf, factorial\nimport operator\nfrom bisect import *\nfrom collections import *\nfrom heapq import *\nfrom typing import *\nfrom itertools import *\nfrom functools import *\nfrom sortedcontainers import SortedList as SL\n\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        N = len(nums)\n        Q = len(queries)\n        \n        if sum(nums) == 0:\n            return 0\n        \n        table = [set() for _ in range(N)]\n        for i in range(N):\n            table[i].add(0)\n\n        for qi, (l, r, val) in enumerate(queries):\n            for i in range(l, r+1):\n                s = table[i]\n                lim = nums[i]\n                for x in s.copy():\n                    if x + val <= lim:\n                        s.add(x + val)\n            # check\n            if all(nums[i] in table[i] for i in range(N)):\n                return qi + 1\n\n        return -1\n","author":"momocowcow","submissionId":"1575173159"},[]]},{"520":[{"id":"520","fileName":"1575172622.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) \n    {\n        int n = nums.size();\n        int left = 0, right = queries.size();\n        while (left < right)\n        {\n            int mid = left+(right-left)/2;\n            if (isOK(nums, queries, mid))\n                right = mid;\n            else\n                left = mid+1;\n        }\n        if (isOK(nums,queries, left)) return left;\n        else return -1;        \n    }\n    \n    bool isOK(vector<int>& nums, vector<vector<int>>& queries, int t)\n    {\n        // cout<<\"t=\"<<t<<endl;\n        int n = nums.size();\n        vector<vector<int>>diff(n+1);\n        for (int i=0; i<t; i++)\n        {\n            int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n            diff[l].push_back(v);\n            diff[r+1].push_back(-v);\n        }\n        multiset<int>Set;\n        for (int i=0; i<n; i++)\n        {\n            for (int x: diff[i])\n            {\n                if (x>0) Set.insert(x);\n                else Set.erase(Set.lower_bound(-x));\n            }\n            // cout<<i<<\" \"<<nums[i]<<endl;\n            // cout<<\"set \"; for (int x: Set) cout<<x<<\" \"; cout<<endl;\n            // cout<<subsetSum(Set, nums[i])<<endl;\n            \n            if (!subsetSum(Set, nums[i]))\n                return false;\n        }\n        return true;\n    }\n    \n    bool subsetSum(multiset<int>& nums, int target) \n    {\n        vector<bool> dp(target + 1, false);\n        dp[0] = true; \n        for (int num : nums) \n        {\n            for (int j = target; j >= num; j--) {\n                if (dp[j - num])\n                    dp[j] = true;\n            }\n        }\n        \n        // cout<<\"OK \"<<dp[2]<<endl;\n\n        return dp[target];\n    }\n};","author":"wisdompeak","submissionId":"1575172622"},[]]},{"521":[{"id":"521","fileName":"1575173165.txt","sourceCode":"class Solution {\n// #define int long long int\n// #define double long double\n#define f(i,a,b) for(int i=a;i<b;i++)\n#define pb push_back\n#define pii pair<int, int>\n#define vi vector<int>\n#define vpi vector<pii>\n#define si set<int>\n#define spi set<pii>\n#define umpi unordered_map<int, int>\n#define mpi map<int, int>\n#define mpp map<pii, int>\n#define pq_max priority_queue<int>\n#define pq_min priority_queue<int, vi, greater<int>>\n#define print(v) for (auto x : v) cout << x << \" \"; cout << endl\n#define yn(x) cout << (x ? \"YES\" : \"NO\") << endl\n#define all(v) v.begin(), v.end()\n#define take(v) for (auto &x : v) cin >> x\n#define sum(v) accumulate(v.begin(), v.end(), 0)\nint n,m;\nprivate:\n    bool bs(vi& nums,vector<vi>& q,int k){\n    \tf(j,0,n){\n            if(!nums[j])continue;\n    \t\tvi tmp;\n    \t\tf(i,0,k){\n    \t\t\tif(q[i][0]<=j && j<=q[i][1])\n    \t\t\t\ttmp.pb(q[i][2]);\n    \t\t}\n    \t\tvector<bool> dp(nums[j]+1,false);\n    \t\tdp[0]=true;\n    \t\tfor(auto x: tmp){\n    \t\t\tfor(int val=nums[j];val>=x;val--){\n                    dp[val]=dp[val-x]?true:dp[val];\n    \t\t\t}\n    \t\t}\n    \t\tif(!dp[nums[j]])return 0;\n    \t}\n    \treturn 1;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        if(sum(nums)==0)return 0;\n        n=nums.size(),m=q.size();\n        int l=0,h=m+1,ans=-1;\n    \twhile(l<h){\n    \t\tint mid=l+(h-l)/2;\n    \t\tif(bs(nums,q,mid)){\n    \t\t\tans=mid;\n    \t\t\th=mid;\n    \t\t}\n            else{\n    \t\t\tl=mid+1;\n    \t\t}\n    \t}\n        return ans;\n    }\n};","author":"Aditya Raj","submissionId":"1575173165"},[]]},{"522":[{"id":"522","fileName":"1575173194.txt","sourceCode":"class Solution {\nprivate:\n    bool compute(vector<int>& arr, int index, int csum, vector<vector<int>>& dp) {\n        if(csum == 0)\n            return true;\n        if(csum < 0)\n            return false;\n        if(index >= (int)arr.size())\n            return false;\n        if(dp[index][csum] != -1)\n            return dp[index][csum];\n        bool a1 = compute(arr, index+1, csum, dp);\n        bool a2 = compute(arr, index+1, csum-arr[index], dp);\n        return dp[index][csum] = (a1||a2);\n    }\n    bool canformsum(vector<int>& arr, int target) {\n        int n = arr.size();\n        vector<vector<int>> dp(n, vector<int>(target +1, -1));\n        return compute(arr, 0, target, dp);\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\n        int n = nums.size();\n        vector<vector<int>> opsum(n, vector<int>());\n        \n        function<bool(int)> possible = [&](int steps) -> bool {\n            for(int i=0;i<n;i++)\n                opsum[i].clear();\n            for(int k=0;k<steps;k++) {\n                for(int j=queries[k][0];j<=queries[k][1];j++)\n                    opsum[j].push_back(queries[k][2]);\n            }\n            for(int i=0;i<n;i++) {\n                if(!canformsum(opsum[i], nums[i]))\n                    return false;\n            }\n            return true;\n        };\n        \n        int start = 0;\n        int end = queries.size();\n        int ans = -1;\n        while(start <= end) {\n            int mid = (start + end)/2;\n            if(possible(mid)) {\n                ans = mid;\n                end = mid -1;\n            } else {\n                start = mid+1;\n            }\n        }\n        return ans;\n    }\n};","author":"Shobhit Tewari","submissionId":"1575173194"},[]]},{"523":[{"id":"523","fileName":"1575173393.txt","sourceCode":"class Solution {\npublic:\n    int help(int num , int i ,vector<pair<int,int>>&arr , vector<vector<int>>&dp) {\n         int n = arr.size();\n         if(num == 0) {\n              if(i > 0)return arr[i - 1].second;\n              return -1;\n         }\n         if(i == n || num < 0){\n              return 10000;\n         }\n         \n         if(dp[i][num] != -1)return dp[i][num];\n         int ans =  min(help(num - arr[i].first , i + 1 , arr , dp) ,\n                           help(num , i + 1 , arr , dp));\n        return dp[i][num] = ans;\n    }\n    int minZeroArray(vector<int>& arr, vector<vector<int>>& q) {\n\n         int n = arr.size();\n         vector<vector<pair<int,int>>>v(n);\n         for(int i = 0 ; i < q.size() ; i++ ) {\n             int l = q[i][0] , r= q[i][1] , val = q[i][2];\n             for(int j = l ; j <= r ; j++ ) {\n                  v[j].push_back({val , i});\n             }\n         }\n         int ans = -1;\n        for(int i = 0 ; i < n ; i++ ) {\n             if(arr[i] == 0) {\n                  ans = max(ans , -1);\n                  continue;\n             }\n             vector<vector<int>>dp(v[i].size() , vector<int>(arr[i] + 1 , -1));\n            \n             ans = max(ans , help(arr[i] , 0 , v[i] , dp));\n        }\n        if(ans >= 10000)return -1;\n        return ans + 1;\n        \n    }\n};","author":"Prasann Trivedi","submissionId":"1575173393"},[]]},{"524":[{"id":"524","fileName":"1575173440.txt","sourceCode":"class Solution {\npublic:\n    bool find(const vector<int>& nums, const vector<vector<int>>& queries, int k) {\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) continue;\n            vector<int> arr;\n            for (int j = 0; j < k; j++) {\n                int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                if (l <= i && i <= r) {\n                    arr.push_back(val);\n                }\n            }\n            vector<bool> dp(nums[i] + 1, false);\n            dp[0] = true;\n            for (int v : arr) {\n                for (int s = nums[i]; s >= v; s--) {\n                    if (dp[s - v]) dp[s] = true;\n                }\n            }\n            if (!dp[nums[i]]) return false;\n        }\n        return true;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int q = queries.size();\n        int n = nums.size();\n        bool allZero = true;\n        for (int x : nums) {\n            if (x != 0) { allZero = false; break; }\n        }\n        if (allZero) return 0;\n        int left = 1, right = q, ans = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (find(nums, queries, mid)) {\n                ans = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"im_nitin","submissionId":"1575173440"},[]]},{"525":[{"id":"525","fileName":"1575173479.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int res = 0;\n        \n        boolean[] dp = new boolean[1001];\n        \n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] == 0) continue;\n            \n            Arrays.fill(dp, false);\n            dp[0] = true;\n            \n            for (int j = 0; j < queries.length; ++j) {\n                int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                if (i < l || i > r) continue;\n                \n                for (int k = 1000; k - val >= 0; --k) {\n                    if (!dp[k - val]) continue;\n                    dp[k] = true;\n                }\n                \n                dp[val] = true;\n                \n                if (dp[nums[i]]) {\n                    res = Math.max(res, j + 1);\n                    break;\n                }\n            }\n            \n            if (!dp[nums[i]]) return -1;\n        }\n        \n        return res;\n    }\n}","author":"Terry","submissionId":"1575173479"},[]]},{"526":[{"id":"526","fileName":"1575173705.txt","sourceCode":"class Solution {\npublic:\n\n    int getClose(int ind, int ele, int eleInd, vector<vector<int>> &queries, vector<vector<int>> &dp){\n        if(ele == 0) return ind-1;\n        if(ind >= queries.size()) return ind;\n        if(dp[ind][ele] != -1) return dp[ind][ele];\n        int l = queries[ind][0];\n        int r = queries[ind][1];\n        int val = queries[ind][2];\n        int take = queries.size();\n        if(eleInd >= l and eleInd <= r and ele >= val){\n            take = getClose(ind+1,ele-val,eleInd,queries,dp);\n        }\n        int notTake = getClose(ind+1,ele,eleInd,queries,dp);\n        return dp[ind][ele] =  min(take,notTake);\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\n        vector<int> finish(nums.size());\n        for(int i = 0; i < finish.size(); i++){\n            vector<vector<int>> dp(queries.size()+1,vector<int>(nums[i]+1,-1));\n            finish[i] = getClose(0,nums[i],i,queries,dp);\n            cout << finish[i] << \" \";\n        }\n\n        int ind = INT_MIN;\n        for(int i = 0; i < finish.size(); i++){\n            ind = max(ind,finish[i]);\n        }\n\n        if(ind == queries.size()) return -1;\n        return ind+1;\n    }\n};","author":"Ishan","submissionId":"1575173705"},[]]},{"527":[{"id":"527","fileName":"1575173209.txt","sourceCode":"use std::collections::*;\n\nimpl Solution {\n    pub fn min_zero_array(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> i32 {\n        let mut ans = 0;\n\n        for (i, num) in nums.into_iter().enumerate() {\n            if num == 0 {\n                continue;\n            }\n            \n            let coeffs = queries\n                .iter()\n                .map(|q| if q[0] as usize <= i && i <= q[1] as usize {\n                    q[2]\n                } else {\n                    0\n                })\n                .collect::<Vec<_>>();\n\n            // coeffs * bin = num\n            let mut set = HashSet::new();\n            set.insert(0);\n            let mut idx = 0;\n            'outer: while idx < coeffs.len() {\n                let mut new_set = set.clone();\n                for vi in set {\n                    if vi + coeffs[idx] == num {\n                        ans = ans.max(idx as i32 + 1);\n                        break 'outer;\n                    }\n\n                    if vi + coeffs[idx] < num {\n                        new_set.insert(vi + coeffs[idx]);\n                    }\n                }\n\n                set = new_set;\n                idx += 1;\n            }\n\n            if idx == coeffs.len() {\n                return -1;\n            }\n        }\n        \n        ans\n    }\n}","author":"Fainabi","submissionId":"1575173209"},[]]},{"528":[{"id":"528","fileName":"1575173695.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        List<int[]> list = new ArrayList<>();\n        for (int i = 0; i < queries.length; i++)    {\n            list.add(new int[] {i, queries[i][0], 1, queries[i][2]});\n            list.add(new int[] {i, queries[i][1] + 1, -1, queries[i][2]});\n        }\n        Collections.sort(list, (a, b) -> a[1] == b[1] ? a[2] - b[2] : a[1] - b[1]);\n        TreeMap<Integer, int[]> records = new TreeMap<>();\n        int j = 0;\n        Map<Integer, List<int[]>> m = new HashMap<>();\n        for (int i = 0; i < nums.length; i++)   {\n            while (j < list.size() && list.get(j)[1] <= i)  {\n                int[] cur = list.get(j);\n                if (cur[2] == -1)   {\n                    records.remove(cur[0]);\n                    j++;\n                    continue;\n                }\n                \n                records.put(cur[0], new int[] {cur[0], cur[3]});\n                j++;\n            }\n            \n            for (Map.Entry<Integer, int[]> entry : records.entrySet())  {\n                int idx = entry.getKey();\n                int[] arr = entry.getValue();\n                m.computeIfAbsent(i, x -> new ArrayList<>()).add(arr);\n            }\n        }\n        \n        int[] minIdx = new int[nums.length];\n        Arrays.fill(minIdx, queries.length);\n        for (int i = 0; i < nums.length; i++)   {\n            if (nums[i] == 0)   {\n                minIdx[i] = 0;\n                continue;\n            }\n            List<int[]> cur = m.getOrDefault(i, new ArrayList<>());\n            Set<Integer> set = new HashSet<>();\n            set.add(0);\n            int idx = -1;\n            for (j = 0; j < cur.size(); j++)    {\n                Set<Integer> newSet = new HashSet<>();\n                for (int s : set)\n                    newSet.add(s + cur.get(j)[1]);\n                newSet.addAll(set);\n                set = newSet;\n                if (set.contains(nums[i]))    {\n                    idx = cur.get(j)[0];\n                    break;\n                }\n            }\n            if (idx == -1)\n                return -1;\n            minIdx[i] = idx + 1;\n        }\n        \n        int ans = -1;\n        for (int i : minIdx)\n            ans = Math.max(ans, i);\n        \n        return ans;\n    }\n}","author":"zeningc","submissionId":"1575173695"},[]]},{"529":[{"id":"529","fileName":"1575173808.txt","sourceCode":"#include<bits/stdc++.h>\nusing namespace std;\n\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\n\n#define MOD 1000000007\n#define MOD1 998244353\n#define INF 1000000000000000000LL\n#define nline cout << \"n\"\n#define pb push_back\n#define ppb pop_back\n#define ff first\n#define ss second\n#define bg begin\n#define lbd lower_bound\n#define ubd upper_bound\n#define pll pair<ll, ll>\n#define PI 3.141592653589793238462\n#define set_bits(x) __builtin_popcountll(x)\n#define sz(x) ((ll)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define TT ll t; cin >> t; while(t--)\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing lld = long double;\n\n#define looping(i, a, b) for (ll i = a; i < (b); i++)\n#define loop(i, a) for (ll i = 0; i < (a); i++)\n#define loopingd(i, a, b) for (ll i = (b) - 1; i >= a; i--)\n#define loopd(i, a) for (ll i = (a) - 1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n//------------------------------Debug---------------------------------------------------------------------//\n\n#ifndef ONLINE_JUDGE\n#define debug(x) cerr << #x <<\" \"; _print(x); cerr << endl;\n#else\n#define debug(x)\n#endif\n\nvoid _print(ll t) {cerr << t;}\nvoid _print(int t) {cerr << t;}\nvoid _print(string t) {cerr << t;}\nvoid _print(char t) {cerr << t;}\nvoid _print(lld t) {cerr << t;}\nvoid _print(double t) {cerr << t;}\nvoid _print(ull t) {cerr << t;}\n\ntemplate <class T, class V> void _print(pair <T, V> p);\ntemplate <class T> void _print(vector <T> v);\ntemplate <class T> void _print(set <T> v);\ntemplate <class T, class V> void _print(map <T, V> v);\ntemplate <class T> void _print(multiset <T> v);\ntemplate <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.ff); cerr << \",\"; _print(p.ss); cerr << \"}\";}\ntemplate <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\ntemplate <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\ntemplate <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\ntemplate <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\n\n// -------------------------------------------------------------------------------------------------------//\n\ntemplate <typename T> void read(T& t) { cin >> t; }\ntemplate <typename T, typename... Args> void read(T& t, Args&... args) { read(t); read(args...); }\ntemplate <typename T> void read(vector<T>& vec) { for (auto& element : vec) { cin >> element; } }\ntemplate <typename T> void print(const T& t) { cout << t << \" \"; }\ntemplate <typename T> void prints(const T& t) { cout << t; }\ntemplate <typename T, typename... Args> void print(const T& t, const Args&... args) { print(t); print(args...); }\ntemplate <typename T, typename... Args> void prints(const T& t, const Args&... args) { prints(t); print(args...); }\ntemplate <typename T> void print(const vector<T>& vec) { for (const auto& element : vec) { cout << element << \" \"; } cout << \"n\"; }\ntemplate<class T> using oset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n// -------------------------------------------------------------------------------------------------------//\n\nconst ll dx[] = {0, 0, 1, -1};\nconst ll dy[] = {1, -1, 0, 0};\nll mod_power(ll a, ll b, ll m) { ll ans = 1; while (b) { if (b & 1) ans = ans * a % m; a = a * a % m; b >>= 1; } return ans; }\nll gcd (ll a, ll b) {  return b ? gcd (b, a % b) : a;  }\nll lcm (ll a, ll b) {  return (a * b) / gcd(a, b); }\nll mod_inv(ll x) { return mod_power(x, MOD - 2, MOD) % MOD; }\nll mod_mul(ll a, ll b) { return ((a % MOD) * (b % MOD) % MOD) % MOD; }\nll mod_div(ll a, ll b) { return mod_mul(a, mod_inv(b)) % MOD; }\nll mod_add(ll a, ll b) { return ((a % MOD) + (b % MOD)) % MOD; }\nll mod_sub(ll a, ll b) { return ((a % MOD) - (b % MOD) + MOD) % MOD; }\nbool isprime(ll n) { for (ll i = 2; i * i <= n; ++i) { if (n % i == 0) { return false; } } return true; }\ntemplate <typename T> void chkmn(T &x, T y) { x = min(x, y); }\ntemplate <typename T> void chkmx(T &x, T y) { x = max(x, y); }\n\n//--------------------------------------------------------------------------------------------------------//\n\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        ll n = sz(nums);\n        ll m = sz(queries);\n        vector<vector<ll>> a(n);\n\n        loop(j, m) {\n            looping(i, queries[j][0], queries[j][1] + 1) {\n                a[i].pb(j);\n            }\n        }\n        \n        ll ans = 0;\n        \n        loop(i, n) {\n            vector<ll> b = a[i];\n\n            unordered_map<ll, ll> dp;\n            dp[0] = -1;\n            \n            trav(j, b) {\n                unordered_map<ll, ll> temp;\n\n                trav(u, dp) {\n                    if (u.ff + queries[j][2] > nums[i]) {\n                        continue; \n                    }\n                    if (temp.find(u.ff + queries[j][2]) == temp.end()) {\n                        temp[u.ff + queries[j][2]] = j;\n                    }\n                }\n\n                if (temp.find(queries[j][2]) == temp.end()) {\n                    temp[queries[j][2]] = j;\n                }\n\n                trav(u, temp) {\n                    if (dp.find(u.ff) == dp.end()) {\n                        dp[u.ff] = u.ss;\n                    }\n                }\n            }\n\n            if (dp.find(nums[i]) == dp.end()) {\n                return -1;\n            }\n\n            ll cur = dp[nums[i]] + 1;\n            chkmx(ans, cur);\n        }\n        \n        return ans;\n    }\n};","author":"Amit Yadav","submissionId":"1575173808"},[]]},{"530":[{"id":"530","fileName":"1575174053.txt","sourceCode":"class Solution {\nprivate:\n    int f(int x, vector<int>& db) {\n        // for (int x: db) cout << x << \" \";\n        // cout <<endl;\n        if (x == 0) return 0;\n        unordered_set<int> pre = {x};\n        for (int i = 0; i < db.size(); ++i) {\n            // for (int x: pre) cout << x << \" \";\n            // cout <<endl;\n            if (db[i] == 0) continue;\n            if (pre.find(db[i]) != pre.end()) return i + 1;\n            unordered_set<int> next = pre;\n            for (int y: pre) {\n                if (y > db[i]) next.insert(y - db[i]);\n            }\n            pre = next;\n        }\n        return -1;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> db(n);\n        for (auto& q: queries) {\n            for (int i = 0; i < n; ++i) {\n                if (i < q[0] || i > q[1]) {\n                    db[i].push_back(0);\n                } else {\n                    db[i].push_back(q[2]);\n                }\n            }\n        }\n        int ret = 0;\n        for (int i = 0; i < n; ++i) {\n            int tmp = f(nums[i], db[i]);\n            // cout << tmp <<endl;\n            if (tmp == -1) return -1;\n            ret = max(ret, tmp);\n        }\n        return ret;\n    }\n};","author":"Annie W","submissionId":"1575174053"},[]]},{"531":[{"id":"531","fileName":"1575173777.txt","sourceCode":"import java.math.BigInteger;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int[][] realQuery = new int[nums.length][queries.length];\n        for (int[] rq : realQuery) Arrays.fill(rq, 0);\n        for (int i = 0; i < queries.length; i++)\n            for (int j = queries[i][0]; j <= queries[i][1]; j++)\n                if (queries[i][2] <= nums[j])\n                    realQuery[j][i] = queries[i][2];\n        int ans = 0;\n        for (int i = 0; i < nums.length; i++)\n            ans = Math.max(ans, minSteps(nums[i], realQuery[i]));\n        if (ans == Integer.MAX_VALUE) return -1;\n        return ans;\n    }\n\n    private int minSteps(int target, int[] query) {\n        BigInteger set = BigInteger.ONE;\n        for (int i = 0; i < query.length; i++) {\n            if (set.testBit(target))\n                return i;\n            set = set.shiftLeft(query[i]).or(set);\n        }\n        if (set.testBit(target))\n            return query.length;\n        return Integer.MAX_VALUE;\n    }\n}","author":"samzhu333","submissionId":"1575173777"},[]]},{"532":[{"id":"532","fileName":"1575174108.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n\n        def rec(arr, target, index, memo):\n\n            if target == 0:\n                return True\n            if target < 0 or index >= len(arr):\n                return False\n        \n            if (target, index) in memo:\n                return memo[(target, index)]\n            \n            a = rec(arr, target - arr[index], index + 1, memo)\n        \n            b = rec(arr, target, index+1, memo)\n        \n            memo[(target, index)] = a or b\n            return memo[(target, index)]\n        \n\n        def see(took):\n            prefix = [[] for _ in range(len(nums))]\n            for i in range(took):\n                q = queries[i]\n                start, end, val = q\n                for i in range(start, end+1):\n                    prefix[i].append(val)\n            \n            for i in range(len(nums)):\n                memo = {}\n                #print(took, prefix[i], nums[i])\n                res = rec(prefix[i], nums[i], 0, memo)\n                \n                #print(res)\n                if not res:\n                    return False\n                    \n            return True\n\n        \n        left = 0\n        right = len(queries)\n        while left <= right:\n            mid = (left+right)//2\n            res = see(mid)\n            if not res:\n                left = mid+1\n            else:\n                right = mid-1\n        if left == len(queries)+1:\n            return -1\n        return left","author":"Brandon Collins","submissionId":"1575174108"},[]]},{"533":[{"id":"533","fileName":"1575174078.txt","sourceCode":"public class Solution {\n    public int MinZeroArray(int[] nums, int[][] queries) {\n            int max = 0;\n    for (int i = 0; i < nums.Length; i++) {\n        int val = SolveNum(nums, queries, i);\n        if (val == -1)\n        {\n            return -1;\n        }\n\n        max = Math.Max(max, val);\n    }\n\n    return max;\n}\n\npublic int SolveNum(int[] nums, int[][] queries, int index)\n{\n    int num = nums[index];\n    if (num == 0)\n{\n    return 0;\n}\n    bool[] dp = new bool[num + 1];\n    dp[0] = true;\n    int first = 0;\n    foreach (var query in queries)\n    {\n        first++;\n        int start = query[0];\n        int end = query[1];\n        int value = query[2];\n        if (start > index || end < index)\n        {\n            continue;\n        }\n\n        for(int i = dp.Length - 1; i >= value; i--)\n        {\n            dp[i] = dp[i] || dp[i - value];\n        }\n\n        if (dp[num])\n        {\n            return first;\n        }\n    }\n\n    return -1;\n}\n}","author":"leducthinh55","submissionId":"1575174078"},[]]},{"534":[{"id":"534","fileName":"1575174344.txt","sourceCode":"class Solution {\npublic:\n    vector<vector<int>> dp;\n    int dfs(int n, int i, int ind, vector<int>& nums, vector<vector<int>>& q, int m){\n        if(n==0){\n            return i;\n        }\n        if(i==m){\n            return INT_MAX;\n        }\n        if(dp[n][i]!=-1){\n            return dp[n][i];\n        }\n        if(q[i][0]<=ind && q[i][1]>=ind && n>=q[i][2]){\n            return dp[n][i] = min(dfs(n, i+1, ind, nums, q, m), \n                                    dfs(n-q[i][2], i+1, ind, nums, q, m));\n        }\n        return dp[n][i] = dfs(n, i+1, ind, nums, q, m);\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size(), m= q.size();\n        int res = -1;\n        for(int i=0; i<n; i++){\n            dp = vector<vector<int>> (1001, (vector<int>(1001, -1)));\n            int ans = dfs(nums[i], 0, i, nums, q, m);\n            if(ans==INT_MAX){\n                return -1;\n            }\n            res = max(res, ans);\n        }\n        return res;\n    }\n};","author":"Ranjith_J_23","submissionId":"1575174344"},[]]},{"535":[{"id":"535","fileName":"1575174356.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        decres = [[] for _ in range(len(nums))]\n        for q, (l,r,val) in enumerate(queries):\n            for i in range(l, r+1):\n                decres[i].append([val, q+1])\n\n        def dp(l: int, target: int):\n            if (l, target) in memo:\n                return memo[(l, target)]\n            if l == len(curr):\n                return float('inf')\n            if curr[l][0] == target:\n                return curr[l][1]\n            res = dp(l+1, target)\n            if curr[l][0] < target:\n                res = min(res, dp(l+1, target - curr[l][0]))\n            memo[(l, target)] = res\n            return res\n        \n        ans = []\n        for i in range(len(nums)):\n            memo = dict()\n            target = nums[i]\n            curr = decres[i]\n            if target == 0:\n                ans.append(0)\n            else:\n                ans.append(dp(0,target))\n        return max(ans) if max(ans) != float('inf') else -1","author":"Mark33","submissionId":"1575174356"},[]]},{"536":[{"id":"536","fileName":"1575174375.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(),q=queries.size();\n        int ans = -1;\n        vector<int> temp(n,0);\n        for(int i=0;i<n;i++){\n            int curr=nums[i];\n            if(curr==0)continue;\n            vector<int> pos(1001,-1);\n            pos[curr]=1;\n            for(int j=0;j<q;j++){\n                int val=queries[j][2];\n                if(i>=queries[j][0] && i<=queries[j][1]){\n                    for(int k=1;k<=1000;k++){\n                        if(pos[k]==1){\n                            if(val<=k)pos[k-val]=1;\n                        }\n                    }\n                }\n                if(pos[0]==1){\n                    temp[i]=j+1;\n                    break;\n                }\n            }\n            if(pos[0]!=1)return -1;\n            \n        }\n        for(int i=0;i<n;i++){\n            ans=max(ans,temp[i]);\n        }\n        return ans;\n    }\n};","author":"Patel Patel","submissionId":"1575174375"},[]]},{"537":[{"id":"537","fileName":"1575174260.txt","sourceCode":"class Solution {\npublic:\n    bool can(vector<vector<int>>& q,int k,int cur,int i,vector<vector<int>>& dp){\n        if(cur<0) return 0;\n        if(cur==0) return 1;\n        if(k==-1) return 0;\n        if(dp[k][cur]!=-1) return dp[k][cur]; \n        int l=q[k][0];\n        int r=q[k][1];\n        int v=q[k][2];\n        bool z=0;\n        if(i>=l&&i<=r){\n            z=can(q,k-1,cur-v,i,dp);\n        }\n        z=max(z,can(q,k-1,cur,i,dp));\n        return dp[k][cur]=z;\n    }\n    bool ok(int mid, vector<int>& nums, vector<vector<int>>& q, int n, int m) {\n        // cout<<mid<<endl;\n        for(int i=0;i<n;i++){\n            vector<vector<int>> dp(mid+1,vector<int>(nums[i]+1,-1));\n            if(!can(q,mid-1,nums[i],i,dp)) return 0;\n        }\n        return 1;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int l = 0, r = q.size(), n = nums.size();\n        int m = q.size();\n        while (l < r) {\n            int mid = l + (r - l) / 2;\n            // cout<<mid<<endl;\n            if (ok(mid, nums, q, n, r))\n                r = mid;\n            else\n                l = mid + 1;\n        }\n        // cout<<r<<endl;\n        return (ok(r, nums, q, n, m)) ? r : -1;\n    }\n};\n","author":"Arpan Tomar","submissionId":"1575174260"},[]]},{"538":[{"id":"538","fileName":"1575174417.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        vector<int> min_k(n, -1);\n        \n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) {\n                min_k[i] = 0;\n                continue;\n            }\n            vector<bool> dp(10001, false);\n            dp[0] = true;\n            for (int j = 0; j < q; j++) {\n                int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                if (l <= i && i <= r) {\n                    for (int s = 10000 - val; s >= 0; s--) {\n                        if (dp[s]) {\n                            dp[s + val] = true;\n                        }\n                    }\n                    if (dp[nums[i]] && min_k[i] == -1) {\n                        min_k[i] = j + 1;  \n                    }\n                }\n            }\n        }\n        \n        int ans = 0;\n        for (int k : min_k) {\n            if (k == -1) {\n                return -1;\n            }\n            ans = max(ans, k);\n        }\n        return ans;\n    }\n};","author":"Rahban Ghani","submissionId":"1575174417"},[]]},{"539":[{"id":"539","fileName":"1575174343.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int N = nums.size(), M = queries.size();\n        int k = 0;\n        unordered_set<int> values, nvalues;\n        for (int i = 0; i < N; i++) {\n            if (!nums[i]) continue;\n            values.clear();\n            values.insert(0);\n            for (int j = 0; j < M; j++) {\n                int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                if (l <= i && i <= r) {\n                    nvalues.clear();\n                    for (int x : values) {\n                        nvalues.insert(x + val);\n                    }\n                    values.insert(nvalues.begin(), nvalues.end());\n                }\n                // cout << \"====\" << j << \"=====\" << endl;\n                // for (int x : values) {\n                //     cout << x << \" \";\n                // }\n                // cout << endl;\n                if (values.contains(nums[i])) {\n                    k = max(k, j + 1);\n                    break;\n                }\n                if (j == M - 1) return -1;\n            }\n        }\n        return k;\n    }\n};","author":"Todd Chaney","submissionId":"1575174343"},[]]},{"540":[{"id":"540","fileName":"1575174511.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        max_k = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                continue\n                \n            sum_i = set([nums[i]])\n            for j in range(len(queries)):\n                if queries[j][0] <= i and queries[j][1] >= i:\n                    new_portions = set()\n                    for portions in sum_i:\n                        if portions >= queries[j][2]:\n                            new_portions.add(portions - queries[j][2])\n\n                    sum_i.update(new_portions)\n                    if 0 in sum_i:\n                        max_k = max(max_k, j+1)\n                        break\n\n            else:\n                return -1\n\n        return max_k","author":"advait02c","submissionId":"1575174511"},[]]},{"541":[{"id":"541","fileName":"1575174740.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        \n        extra = (nums, queries)\n        dp = [set([0]) for _ in range(n)]\n        all0 =  all(x == 0 for x in nums)\n        if all0:\n            return 0\n        for k, (lidx, ridx, val) in enumerate(queries):\n            for j in range(lidx, ridx+1):\n                nbit = {a + val for a in dp[j] if a + val < 1001}\n                dp[j].update(nbit)\n                \n                \n                dp[j] = {a for a in dp[j] if a <= nums[j]}\n\n            all0 = all(nums[j] in dp[j] for j in range(n))\n            if all0:\n                return k + 1\n        return -1","author":"Melonlord25","submissionId":"1575174740"},[]]},{"542":[{"id":"542","fileName":"1575174899.txt","sourceCode":"class Solution:\n def minZeroArray(self,nums:List[int],queries:List[List[int]])->int:\n  duchess=len(nums);omalley=len(queries);toulouse=[[]for _ in range(duchess)]\n  for my_theo,(anne,my_tulus,my_ham)in enumerate(queries):\n   for my_garffield in range(anne,my_tulus+1):\n    toulouse[my_garffield].append((my_theo,my_ham))\n  berlioz=[None]*duchess\n  for my_garffield in range(duchess):\n   berlioz[my_garffield]=[1]\n   for(_,my_ham)in toulouse[my_garffield]:\n    berlioz[my_garffield].append(berlioz[my_garffield][-1]|(berlioz[my_garffield][-1]<<my_ham))\n  roquefort,marie,ans=0,omalley+1,-1\n  while roquefort<marie:\n   mid=(roquefort+marie)//2;valid=True\n   for my_garffield in range(duchess):\n    L=toulouse[my_garffield];lo_i,hi_i=0,len(L)\n    while lo_i<hi_i:\n     mm=(lo_i+hi_i)//2\n     if L[mm][0]<mid:lo_i=mm+1\n     else:hi_i=mm\n    cnt=lo_i\n    if not((berlioz[my_garffield][cnt]>>nums[my_garffield])&1):\n     valid=False\n     break\n   if valid:\n    ans=mid;marie=mid\n   else:roquefort=mid+1\n  return ans if ans!=-1 and ans<=omalley else-1","author":"AKASH SINGH CHOUDHARY","submissionId":"1575174899"},[]]},{"543":[{"id":"543","fileName":"1575174830.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length, m = queries.length;\n        if (isAllZero(nums)) return 0;\n        List<Set<Integer>> sets = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            sets.add(new HashSet<>());\n            sets.get(i).add(0);\n        }\n        for (int i = 0; i < m; i++) {\n            int[] query = queries[i];\n            int l = query[0], r = query[1], v = query[2];\n            for (int j = l; j <= r; j++) {\n                Set<Integer> set = sets.get(j);\n                Set<Integer> set2 = new HashSet<>();\n                for (int value : set) {\n                    set2.add(value + v);\n                }\n                set.addAll(set2);\n            }\n            boolean valid = true;\n            for (int j = 0; j < n; j++) {\n                if (!sets.get(j).contains(nums[j])) {\n                    valid = false;\n                    break;\n                }\n            }\n            if (valid) return i + 1;\n        }\n        return -1;\n    }\n    \n    boolean isAllZero(int[] arr) {\n        for (int v : arr) {\n            if (v != 0) return false;\n        }\n        return true;\n    }\n}","author":"YMF","submissionId":"1575174830"},[]]},{"544":[{"id":"544","fileName":"1575174923.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:  # store the input midway as requested\n    \n        n = len(nums)\n        m = len(queries)\n    \n        if all(x == 0 for x in nums):\n            return 0\n    \n        def can_subset_sum(vals, sum_needed):\n        \n            dp = 1 << 0 \n            for val in vals:\n                dp |= (dp << val)\n                \n                if (dp >> sum_needed) & 1:\n                    return True\n            \n            return ((dp >> sum_needed) & 1) == 1\n    \n        \n        for k in range(m+1):\n            v = [[] for _ in range(n)] \n            for q in range(k):\n                l, r, val = queries[q]\n                for i in range(l, r+1):\n                    v[i].append(val)\n    \n            possible_for_all = True\n            for i in range(n):\n                if nums[i] == 0:\n                    continue  \n                if not can_subset_sum(v[i], nums[i]):\n                    possible_for_all = False\n                    break\n    \n            if possible_for_all:\n                return k if k > 0 or any(nums) else 0  \n\n        return -1\n\n                ","author":"Rahul Khurana","submissionId":"1575174923"},[]]},{"545":[{"id":"545","fileName":"1575175054.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n      if sum(nums) == 0:\n        return 0\n      n = len(nums)\n      num_sets = [set([0]) for _ in range(n)]\n      for i in range(len(queries)):\n        s, e, v = queries[i]\n        for j in range(n):\n          if j >= s and j <= e:\n            news = num_sets[j].copy()\n            for val in num_sets[j]:\n              news.add(val + v)\n            num_sets[j] = news\n\n        can_get = True\n        for j, num in enumerate(nums):\n          if num not in num_sets[j]:\n            can_get = False\n        if can_get:\n          return i+1\n\n      return -1\n          ","author":"hakuna_matata7","submissionId":"1575175054"},[]]},{"546":[{"id":"546","fileName":"1575174743.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int ql = queries.length, nl = nums.length;\n        Set<Integer>[] cs = new HashSet[nl];\n        int non0 = 0;\n        for (int i = 0; i < nl; i++) {\n            cs[i] = new HashSet<>();\n            cs[i].add(0);\n            if (nums[i] != 0) {\n                non0++;\n            }\n        }\n        if (non0 == 0) {\n            return 0;\n        }\n        for (int i = 0; i < ql; i++) {\n            int[] q = queries[i];\n            int l = q[0], r = q[1], val = q[2];\n            for (int p = l; p <= r; p++) {\n                List<Integer> toAdd = new ArrayList<>();\n                for (int c : cs[p]) {\n                    if (cs[p].contains(c + val)) {\n                        continue;\n                    }\n                    toAdd.add(c + val);\n                }\n                cs[p].addAll(toAdd);\n            }\n            int matched = 0;\n            for (int p = 0; p < nl; p++) {\n                if (cs[p].contains(nums[p])) {\n                    matched++;\n                } else {\n                    break;\n                }\n            }\n            if (matched == nl) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n}","author":"jizhengfei","submissionId":"1575174743"},[]]},{"547":[{"id":"547","fileName":"1575174759.txt","sourceCode":"class Solution\n{\n    using vi = vector<int>;\n    using vvi = vector<vi>;\n\n    bool f(int n, int k, vi &arr, vvi &memo)\n    {\n        if (k == 0)\n            return 1;\n        if (n == 0)\n            return 0;\n        // base condition\n\n        if (memo[n][k] != -1)\n            return memo[n][k];\n\n        bool pick = false, notPick = false;\n        if (arr[n - 1] <= k)\n            pick = f(n - 1, k - arr[n - 1], arr, memo);\n        notPick = f(n - 1, k, arr, memo);\n        return memo[n][k] = (pick | notPick);\n    }\n\n    // 10\n    // 1 2 4 5 6 3 9 8\n\n    // 1->Yes   k = 9\n\n    bool susumK(int n, int k, vector<int> &arr)\n    {\n        if (n == 0)\n            return k == 0;\n        vvi memo(n + 1, vi(k + 1, -1));\n        return f(n, k, arr, memo);\n    }\n\npublic:\n    int minZeroArray(vector<int> &nums, vector<vector<int>> &q)\n    {\n        int n = nums.size();\n        int countZero = count(nums.begin(), nums.end(), 0);\n        if (countZero == n)\n            return 0;\n        int left = 1, right = q.size();\n        int ans = -1;\n        while (left <= right)\n        {\n            int mid = left + (right - left) / 2;\n            vvi v(n);\n            for (int i = 0; i < mid; i++)\n            {\n                int l = q[i][0], r = q[i][1], x = q[i][2];\n                for (int j = l; j <= r; j++)\n                    v[j].push_back(x);\n            }\n            bool ok = true;\n            for (int i = 0; i < n; i++)\n            {\n                if (!susumK(v[i].size(), nums[i], v[i]))\n                {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok)\n                ans = mid, right = mid - 1;\n            else\n                left = mid + 1;\n        }\n        return ans;\n    }\n};","author":"Aditya Raj","submissionId":"1575174759"},[]]},{"548":[{"id":"548","fileName":"1575175065.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        k = 0\n        for i, n in enumerate(nums):\n            if n == 0:\n                continue\n            p = set()\n            p.add(n)\n            for j, (l, r, val) in enumerate(queries):\n                if i >=l and i<=r:\n                    new_p = {x for x in p}\n                    for x in p:\n                        if x - val >= 0:\n                            new_p.add(x - val)\n                        if 0 in new_p:\n                            break\n                    p = new_p\n        \n                if 0 in p:\n                    break\n                \n            if 0 in p:\n                k = max(k, j+1)\n            else:\n                return -1\n        return k\n                            \n                    \n\n            \n\n\n        \n        k = 0\n        while k < len(queries) and not self.is_all_zero(nums):\n            l, r, val = queries[k]\n            for i in range(l, r+1):\n                nums[i] -= val\n            k += 1\n            print(nums)\n        return k if self.is_all_zero(nums) else -1\n\n    def is_all_zero(self, n):\n        return all((x == 0 for x in n))\n            \n        ","author":"Ali Nikseresht","submissionId":"1575175065"},[]]},{"551":[{"id":"551","fileName":"1575175473.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        q = len(queries)\n        queries = [0] + queries\n        arr = [0 for i in range(n)]\n        maxi = max(nums)\n        dp = [[[False for i in range(maxi+1)] for j in range(n)] for k in range( q+1)]\n        for i in range(n):\n            dp[0][i][nums[i]] = True\n        res = [float('inf') for i in range(n)]\n        for i in range(1, q+1):\n            l, r, v = queries[i]\n            for j in range(n):\n                for k in range(maxi+1):\n                    dp[i][j][k] = dp[i-1][j][k]\n            for j in range(l, r+1):\n                for k in range(maxi-v+1):\n                    if (dp[i-1][j][k+v]):\n                        dp[i][j][k] = True\n        for i in range(n):\n            for j in range(q+1):\n                if (dp[j][i][0]):\n                    res[i] = j\n                    break\n        \n        if (max(res) == float('inf')):\n            return -1\n        else:\n            return max(res)","author":"Evan","submissionId":"1575175473"},[]]},{"552":[{"id":"552","fileName":"1575175302.txt","sourceCode":"class Solution {\npublic:\n    bool isSubsetSum(vector<int>& arr, int sum) {\n        int n = arr.size();\n        vector<vector<int>> dp(n + 1, vector<int>(sum + 1, 0));\n        for (int i = 0; i <= n; i++) {\n            dp[i][0] = 1;\n        }\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= sum; j++) {\n                dp[i][j] = dp[i - 1][j];\n                if (j >= arr[i - 1]) {\n                    dp[i][j] = dp[i][j] || dp[i - 1][j - arr[i - 1]]; \n                }\n            }\n        }\n        return dp[n][sum];\n    }\n\n    bool isValid(int k, vector<int>& a, vector<vector<int>>& q) {\n        vector<vector<int>> temp(a.size());\n        for (int i = 0; i < k; i++) {\n            int l = q[i][0];\n            int r = q[i][1];\n            int val = q[i][2];\n            for (int j = l; j <= r; j++) {\n                temp[j].push_back(val);\n            }\n        }\n        for (int i = 0; i < a.size(); i++) {\n            if (!isSubsetSum(temp[i], a[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int low = 0, high = q.size(), ans = 1e9;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (isValid(mid, a, q)) {\n                ans = min(ans,mid);\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        if(ans==1e9) return -1;\n        return ans;\n    }\n};\n","author":"Divyanshu kumar","submissionId":"1575175302"},[]]},{"553":[{"id":"553","fileName":"1575175558.txt","sourceCode":"class Solution {\npublic:\n    int solve(int i, vector<vector<int>>& queries, int idx, int x, vector<vector<int>> &dp){\n        if(x == 0){\n            return i;\n        }\n        if(i == queries.size()){\n            return INT_MAX;\n        }\n        if(dp[i][x] != -1){\n            return dp[i][x];\n        }\n        \n        int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n        if(idx >= l && idx <= r){\n            int pick = INT_MAX, notPick = solve(i+1, queries, idx, x, dp);\n            if(x >= val){\n                pick = solve(i+1, queries, idx, x-val, dp);\n            }\n\n            return dp[i][x] = min(pick, notPick);\n        }\n        else{\n            return dp[i][x] = solve(i+1, queries, idx, x, dp);\n        }\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int ans = INT_MIN, q = queries.size();\n        for(int i = 0; i < n; i++){\n            int x = nums[i];\n            vector<vector<int>> dp(q, vector<int>(x+1,-1));\n            int tempAns = solve(0, queries, i, x, dp);\n            // cout << tempAns << endl;\n            if(tempAns == INT_MAX) return -1;\n            ans = max(ans, tempAns);\n        }\n        return ans;\n    }\n};","author":"Ganesh Yadav","submissionId":"1575175558"},[]]},{"554":[{"id":"554","fileName":"1575175425.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int res = -1, l=0, r=queries.size();\n        int n = nums.size();\n        auto pos = [&](int k)->bool{\n            \n            unordered_map<int, vector<int>> mp;\n            for(int i=0; i<k; i++){\n                int l=queries[i][0], r=queries[i][1], val=queries[i][2];\n                for(int j=l; j<=r; j++){\n                    mp[j].push_back(val);\n                }\n            }\n            vector<int>temp = nums;\n            for(auto x: mp){\n                int ind = x.first;\n                int target = nums[ind];\n                vector<int> arr = x.second;\n                vector<bool> dp(target + 1, false);\n                dp[0] = true; \n            \n                for (int num : arr) {\n                    for (int j = target; j >= num; --j) {\n                        if (dp[j - num]) {\n                            dp[j] = true;\n                        }\n                    }\n                }\n                if(dp[target]) temp[ind] = 0;\n                else return false;\n                \n            }\n            for(auto x: temp) if(x!=0) return false;\n            return true;\n        };\n\n\n\n        while(l<=r){\n            int mid = (l+r)/2;\n            if(pos(mid)){\n                res = mid;\n                r=mid-1;\n            }else{\n                l=mid+1;\n            }\n        }\n        return res;\n    }\n};","author":"Abhinav Choukse","submissionId":"1575175425"},[]]},{"555":[{"id":"555","fileName":"1575175162.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& v, vector<vector<int>>& q) {\n        bool allZero = true;\n        for (int i = 0; i < v.size(); i++) if (v[i] != 0) allZero = false;\n        if (allZero) return 0;\n        \n        int res = 0;\n        for (int i = 0; i < v.size(); i++) {\n            if (v[i] == 0) continue;\n            vector<int> vv, idx;\n            for (int j = 0; j < q.size(); j++) {\n                if (q[j][0] <= i && q[j][1] >= i) {\n                    vv.push_back(q[j][2]);\n                    idx.push_back(j + 1);\n                }\n            }\n            \n            int dp1[1001] = {0};\n            dp1[0] = 1;\n            bool found = false;\n            for (int j = 0; j < vv.size(); j++) {\n                for (int k = 0; k + vv[j] <= v[i]; k++) {\n                    if (dp1[k] == 1 && dp1[k + vv[j]] == 0) {\n                        dp1[k + vv[j]] = 2;\n                    }\n                }\n                for (int k = 0; k <= v[i]; k++) if (dp1[k] == 2) dp1[k] = 1;\n                if (dp1[v[i]] == 1) {\n                    res = max(res, idx[j]);\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                res = -1;\n                break;\n            }\n        }\n        return res;\n        \n    }\n};","author":"Sohel Hafiz","submissionId":"1575175162"},[]]},{"556":[{"id":"556","fileName":"1575175573.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>&q) {\n        int n=nums.size();\n        int sz=q.size();\n        bool flag=true;\n        for(auto num:nums){\n            if(num){\n                flag=false;\n                break;\n            }\n        }\n        if(flag)return 0;\n        int s=1, e=sz;\n        vector<vector<bool>>index(n+1,vector<bool>(1005,false));\n        for(int i=0;i<n;i++)index[i][0]=true;\n        while(s<=e){\n            int mid=s+(e-s)/2;\n            for(int i=0;i<mid;i++){\n                int l=q[i][0], r=q[i][1], val=q[i][2];\n                while(l<=r){\n                    auto tmp=index[l];\n                    for(int j=0;j<=(nums[l]-val);j++){\n                        if(index[l][j]){\n                            tmp[j+val]=true;\n                        }\n                    }\n                    index[l]=tmp;\n                    l++;\n                }\n            }\n            bool flag=true;\n            for(int idx=0;idx<n;idx++){\n                if(!index[idx][nums[idx]]){\n                    flag=false;\n                }\n                for(int j=1;j<=nums[idx];j++)index[idx][j]=false;\n            }\n            if(flag)e=mid-1;\n            else s=mid+1;\n        }\n        if(s>sz)return -1;\n        return s;\n    }\n};","author":"prashant_kashyap9759","submissionId":"1575175573"},[]]},{"557":[{"id":"557","fileName":"1575175695.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        result = 0\n\n        for n_pos in range (len(nums)):\n            num = nums[n_pos]\n            if num == 0:\n                continue\n                \n            can_decrease = [False] * (num + 1)\n            can_decrease[0] = True\n            \n            for q_pos in range(len(queries)):\n                q = queries[q_pos]\n                if q[0] > n_pos or q[1] < n_pos:\n                    continue\n                    \n                for i in range (num, q[2] - 1, -1):\n                    if can_decrease[i - q[2]]:\n                        can_decrease[i] = True\n\n                if can_decrease[num]:\n                    result = max(result, q_pos+1)\n                    break\n                    \n            if not can_decrease[num]:\n                return -1\n\n        return result","author":"tlh65","submissionId":"1575175695"},[]]},{"558":[{"id":"558","fileName":"1575175788.txt","sourceCode":"class Solution {\npublic:\n    bool targetSum(vector<int>&arr, int target){\n        sort(arr.begin(),arr.end());\n        // cout<<target<<\"n\";\n        // cout<<\"arr: \";\n        // for(auto&i:arr){\n        //     cout<<i<<\" \";\n        // }\n        // cout<<\"n\";\n        vector<int> sum(target+1,0);\n        sum[0] = true;\n        for(auto&a:arr){\n            auto prev = sum;\n            for(int i=0;i<target;i++){\n                if(i+a>target){\n                    break;\n                }\n                sum[i+a] |= prev[i];\n                if(sum[target]){\n                    // cout<<\"ans: \"<<true<<\"n\";\n                    return true;\n                }\n            }\n        }\n        // cout<<\"ans: \"<<false<<\"n\";\n        return sum[target];\n    }\n    bool process(int mid, vector<int>& nums,vector<vector<int>>& queries){\n        // cout<<mid<<\"n\";\n        int n = nums.size();\n        vector<vector<int>> target_arr(n);\n        for(int i=0;i<mid;i++){\n            for(int j=queries[i][0];j<=queries[i][1];j++){\n                target_arr[j].push_back(queries[i][2]);\n            }\n        }\n        for(int i=0;i<n;i++){\n            if(!targetSum(target_arr[i],nums[i])){\n                return false;\n            }\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int low = 0, high = queries.size(),ans=INT_MAX;\n        while(low <= high){\n            int mid = low+(high-low)/2;\n            if(process(mid,nums,queries)){\n                high = mid-1;\n                ans = mid;\n            }else{\n                low = mid+1;\n            }\n        }\n        return ans==INT_MAX?-1:ans;\n    }\n};","author":"Sai Mahesh","submissionId":"1575175788"},[]]},{"559":[{"id":"559","fileName":"1575175908.txt","sourceCode":"'''\n\n\n'''\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if sum(nums) == 0: # all 0\n            return 0\n\n        idx_to_changes = [[] for _ in nums]\n        for qi, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                idx_to_changes[i].append((val, qi)) # (diff, index)\n\n\n        # print(idx_to_changes)\n        ret = - math.inf\n        for i, num in enumerate(nums):\n            if num == 0:\n                continue\n            changes = idx_to_changes[i]\n            # print(\"try to find youngest index whose sum of diffs can be exactly num\")\n            # print(changes, num)\n            possible_sums = set([0])\n            found = False\n            for diff, index in changes:\n                if num - diff in possible_sums:\n                    ret = max(ret, index)\n                    found = True\n                    break\n                for prev_sum in possible_sums.copy():\n                    curr_sum = prev_sum + diff\n                    if curr_sum < num:\n                        possible_sums.add(curr_sum)\n\n            # print(found)\n            if not found:\n                return -1\n\n        return ret + 1\n                    ","author":"kudojp","submissionId":"1575175908"},[]]},{"560":[{"id":"560","fileName":"1575175662.txt","sourceCode":"class Solution {\npublic:\n    int findSum(vector<pair<int,int>>& arr, int target, int start, vector<vector<int>>& dp){\n        if(start == arr.size()) return -1;\n\n        if(dp[start][target] != -2) return dp[start][target];\n        \n        if(arr[start].first == target) return arr[start].second;\n\n        int ans = -1;\n        if(arr[start].first > target){\n            ans = findSum(arr, target, start + 1, dp);\n            return dp[start][target] = ans;\n        }\n        int a = findSum(arr, target - arr[start].first, start + 1, dp);\n        int b = findSum(arr, target, start + 1, dp);\n        if(a == -1 && b == -1) {\n            if(ans == -1) ans = -1;\n        }\n        else if(a == -1) ans = b;\n        else if(b == -1) ans = a;\n        else ans = min(a, b);\n        return dp[start][target] = ans;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = 0;\n        int n = nums.size();\n        for(int i = 0; i < n; i++){\n            if(nums[i] == 0) continue;\n            \n            vector<pair<int,int>> arr;\n            for(int j = 0; j < queries.size(); j++){\n                if(queries[j][0] <= i && i <= queries[j][1] && queries[j][2] <= nums[i]) arr.push_back({queries[j][2], j + 1});\n            }\n            vector<vector<int>> dp(arr.size(), vector<int>(nums[i] + 1, -2));\n            int temp = findSum(arr, nums[i], 0, dp);\n            if(temp == -1) return -1;\n            ans = max(ans, temp);\n        }\n        return ans;\n    }\n};","author":"Win_Handsome","submissionId":"1575175662"},[]]},{"561":[{"id":"561","fileName":"1575175547.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        q = len(queries)\n        ans = 0\n        \n        for i, x in enumerate(nums):\n            if not x:\n                continue\n            c = set([0])\n            for j, (l, r, val) in enumerate(queries):\n                if i < l or i > r:\n                    continue\n                # print(j, l, r, val)\n                d = c.copy()\n                for y in c:\n                    d.add(y + val)\n                if x in d:\n                    break \n                c = d\n            else:\n                # print(i, x)\n                return -1\n\n            ans = max(ans, j + 1)\n                \n        return ans\n            \n        ","author":"Kevin Pan","submissionId":"1575175547"},[]]},{"562":[{"id":"562","fileName":"1575176086.txt","sourceCode":"class Solution {\npublic:\n    bool f(int m,vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n\n        for(int i=0;i<n;i++){\n            int target=nums[i];\n            // ya to pura sutract krna h val[i] ya bilkul hi nhi to take notkae dp on queries affecting ith index(gpt helpU0001f612)\n            vector<bool>dp(target+1,false);\n            dp[0]=true;\n            \n            for(int j=0;j<m;j++){\n                int l=queries[j][0];\n                int r=queries[j][1];\n                int val=queries[j][2];\n                if(l<=i&&i<=r){\n                    for(int k=target;k>=0;k--){\n                        if(dp[k]&&k+val<=target){\n                            dp[k+val]=true;\n                        }\n                    }\n                }\n            }\n            if(!dp[target])return false;\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        //bs for number of queries  \n        int low=0;\n        int high=queries.size();\n        int ans=-1;\n\n        while(low<=high){\n            int mid=low+(high-low)/2;\n            if(f(mid,nums,queries)){\n               high=mid-1;\n               ans=mid;\n            }else{\n               low=mid+1;\n            }\n        }   \n        return ans;\n    }\n};","author":"AMAN","submissionId":"1575176086"},[{"id":"714","similarity":0.8571428571428571,"totOverlap":180,"longestOverlap":45}]],"714":[{"id":"714","fileName":"1575188075.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l = 0;\n        int r = queries.size();\n        int res = -1;\n        while(l<=r){\n            int mid = l+(r-l)/2;\n            if(valid(nums, queries, mid)){\n                res = mid;\n                r = mid-1;\n            }\n            else l = mid+1;\n        }\n        return res;\n    }\n\n    bool valid(vector<int>& nums, vector<vector<int>>& queries, int k){\n        int n = nums.size();\n        for (int j = 0; j < n; j++){\n            int target = nums[j];\n            vector<bool> dp(target + 1, false);\n            dp[0] = true;\n            for (int i = 0; i<k; i++){\n                int l = queries[i][0];\n                int r = queries[i][1];\n                int val = queries[i][2];\n                if(l <= j && j <= r){\n                    for (int s = target-val; s >= 0; s--){\n                        if(dp[s]) dp[s+val] = true;\n                    }\n                }\n            }\n            if(!dp[target]) return false;\n        }\n        return true;\n    }\n};","author":"Nelson","submissionId":"1575188075"},[{"id":"562","similarity":0.8571428571428571,"totOverlap":180,"longestOverlap":45}]]},{"563":[{"id":"563","fileName":"1575175814.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        \n        def canZeroAfterK(k: int) -> bool:\n           \n            for j in range(n):\n                target = nums[j]\n               \n                values = [val for l, r, val in queries[:k] if l <= j <= r]\n                \n               \n                if target == 0:\n                    continue\n                \n               \n                dp = [False] * (target + 1)\n                dp[0] = True\n                for v in values:\n                  \n                    for s in range(target, v - 1, -1):\n                        if dp[s - v]:\n                            dp[s] = True\n    \n                    if dp[target]:\n                        break\n                \n               \n                if not dp[target]:\n                    return False\n            return True\n        \n     \n        if not canZeroAfterK(m):\n            return -1\n        \n \n        low, high = 0, m\n        ans = m\n        while low <= high:\n            mid = (low + high) // 2\n            if canZeroAfterK(mid):\n                ans = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        return ans\n","author":"Kierthana","submissionId":"1575175814"},[]]},{"564":[{"id":"564","fileName":"1575176148.txt","sourceCode":"\n// can get sum with first i queries\n//          numi  q_i  sum\nbool visited[10][1005][2005];\nbool alg[10][1005][2005];\n\nclass Solution {\npublic:\n  vector<int> nums_;\n  vector<vector<int>> queries_;\n  void Dfs(int num_i, int q_i, int sum) {\n    if (visited[num_i][q_i][sum]) {\n      return ;\n    }\n    if (q_i == queries_.size()) {\n      alg[num_i][q_i][sum] = true;\n      visited[num_i][q_i][sum] = true;\n      return ;\n    }\n    alg[num_i][q_i][sum] = true;\n    // not choose\n    Dfs(num_i, q_i + 1, sum);\n    // choose if in queries[q_i]\n    if (num_i >= queries_[q_i][0] && num_i <= queries_[q_i][1] && sum + queries_[q_i][2] < 2005) {\n      Dfs(num_i, q_i + 1, sum + queries_[q_i][2]);\n    }\n    visited[num_i][q_i][sum] = true;\n    return;\n  }\n  \n  int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    nums_ = nums;\n    queries_ = queries;\n    memset(visited, 0, sizeof(visited));\n    memset(alg, 0, sizeof(alg));\n    for (int num_i = 0; num_i < nums.size(); ++num_i) {\n      // for (int q_i = 0; q_i <= queries.size(); ++q_i) {\n      //   visited[num_i][q_i][0] = true;\n      //   alg[num_i][q_i][0] = true;\n      // }\n      Dfs(num_i, 0, 0);\n    }\n    if (accumulate(nums.begin(), nums.end(), 0) == 0) {\n      return 0;\n    }\n    for (int k = 1; k <= queries.size(); ++k) {\n      bool all_zero = true;\n      for (int num_i = 0; num_i < nums.size(); ++num_i) {\n        if (alg[num_i][k][nums[num_i]] == false && nums[num_i] != 0) {\n          all_zero = false;\n          break;\n        }\n      }\n      if (all_zero) {\n        return k;\n      }\n    }\n    return -1;\n  }\n};","author":"FighterNan","submissionId":"1575176148"},[]]},{"565":[{"id":"565","fileName":"1575176286.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n        vector<bitset<1001>> dp(n);\n        init(dp, n);\n        \n        if (z(nums)) return 0;\n        \n        for (int i = 0; i < q.size(); i++) {\n            aq(dp, nums, q[i]);\n            if (allAchieved(dp, nums, n)) return i + 1;\n        }\n        return -1;\n    }\n\nprivate:\n    void init(vector<bitset<1001>>& dp, int n) {\n        for (int i = 0; i < n; i++) {\n            dp[i].reset();\n            dp[i].set(0);\n        }\n    }\n\n    bool z(vector<int>& nums) {\n        return all_of(nums.begin(), nums.end(), [](int x) { return x == 0; });\n    }\n\n    void aq(vector<bitset<1001>>& dp, vector<int>& nums, vector<int>& q) {\n        int l = q[0], r = q[1], v = q[2];\n        for (int i = l; i <= r; i++) {\n            dp[i] |= (dp[i] << v);\n            for (int j = nums[i] + 1; j < 1001; j++) {\n                dp[i].reset(j);\n            }\n        }\n    }\n\n    bool allAchieved(vector<bitset<1001>>& dp, vector<int>& nums, int n) {\n        for (int i = 0; i < n; i++) {\n            if (!dp[i].test(nums[i])) return false;\n        }\n        return true;\n    }\n};\n","author":"Mr-TAGORE3944","submissionId":"1575176286"},[{"id":"1043","similarity":0.9218106995884774,"totOverlap":224,"longestOverlap":38}]],"1043":[{"id":"1043","fileName":"1575210305.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<bitset<1001>> dp(n);\n\n        initializeDP(dp, n);\n        if (checkAllZero(nums)) return 0;\n\n        for (int k = 0; k < queries.size(); k++) {\n            processQuery(dp, nums, queries[k]);\n\n            if (isAchieved(dp, nums)) return k + 1;\n        }\n        return -1;\n    }\n\nprivate:\n    void initializeDP(vector<bitset<1001>>& dp, int n) {\n        for (int i = 0; i < n; i++) {\n            dp[i].reset();\n            dp[i].set(0, true);\n        }\n    }\n\n    bool checkAllZero(vector<int>& nums) {\n        for (int num : nums) {\n            if (num != 0) return false;\n        }\n        return true;\n    }\n\n    void processQuery(vector<bitset<1001>>& dp, vector<int>& nums, vector<int>& query) {\n        int l = query[0], r = query[1], v = query[2];\n\n        for (int j = l; j <= r; j++) {\n            dp[j] |= (dp[j] << v);\n            for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                dp[j].reset(pos);\n            }\n        }\n    }\n\n    bool isAchieved(vector<bitset<1001>>& dp, vector<int>& nums) {\n        for (int j = 0; j < nums.size(); j++) {\n            if (!dp[j].test(nums[j])) return false;\n        }\n        return true;\n    }\n};\n","author":"edward7780","submissionId":"1575210305"},[{"id":"565","similarity":0.9218106995884774,"totOverlap":224,"longestOverlap":38}]]},{"566":[{"id":"566","fileName":"1575175996.txt","sourceCode":"class Solution {\npublic:\n    vector<vector<int>> cache;\n    int helper(int num, vector<vector<int>>& queries, int idx, int i, int curr) {\n        if (curr == num) {\n            return i;\n        }\n        if (i == queries.size()) return INT_MAX;\n        if (cache[i][curr] != -1) return cache[i][curr];\n\n        int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n        if (idx >= l && idx <= r) {\n            if (curr + val > num) return cache[i][curr] = helper(num, queries, idx, i + 1, curr);\n\n            return cache[i][curr] = min(helper(num, queries, idx, i + 1, curr), \n                                        helper(num, queries, idx, i + 1, curr + val));\n        }\n        return cache[i][curr] = helper(num, queries, idx, i + 1, curr);\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int res = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            cache.assign(queries.size(), vector<int>(1001, -1));\n            int a = helper(nums[i], queries, i, 0, 0);\n            // cout<<i<<\" \"<<a<<\" \"<<endl;\n            if (a == INT_MAX) return -1;\n            res = max(res, a);\n        }\n        return res;\n    }\n};","author":"hiJason","submissionId":"1575175996"},[]]},{"567":[{"id":"567","fileName":"1575176311.txt","sourceCode":"/**\n *    author:  Chet8n\n *    created: 16.03.2025 08:28:09\n **/\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define fastio ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define all(x) (x).begin(), (x).end()\n#define ceill(x, y) ((x + y - 1) / y)\n#define setbits(x) __builtin_popcountll(x)\n\nconst int mod = 1e9 + 7;\nconst int inf = 2e9 + 5;\nconst long long infl = 2e18 + 5;\ndouble PI = 3.14159265358979323846;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define db(...) 20\n#define sout(...) 20\n#endif\n\nclass Solution {\n  public:\n    int minZeroArray(vector<int> &nums, vector<vector<int>> &queries) {\n\n        int n = nums.size();\n        int m = queries.size();\n        map<int, vector<pair<int, int>>> mp;\n        for (int i = 0; i < m; i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                mp[j].push_back({val, i+1});\n            }\n        }\n\n        auto findIfSumPossible = [&](int target, vector<pair<int, int>> &a) {\n            db(target, a);\n            vector<vector<int>> dp(target + 5, vector<int>((int)a.size() + 1, inf));\n            for (int i = 0; i <= (int)a.size(); i++) {\n                dp[0][i] = 0;\n            }\n            for (int i = 1; i <= (int)a.size(); i++) {\n                for (int sum = 1; sum <= target; sum++) {\n                    dp[sum][i] = (dp[sum][i - 1]);\n                    // db(sum, i, a[i-1].first);\n                    if (a[i - 1].first <= sum) {\n                        if (dp[sum - a[i - 1].first][i - 1] != inf) {\n                            dp[sum][i] = min(dp[sum][i], a[i - 1].second);\n                        }\n                    }\n                    // db(dp[sum][i]);\n                }\n            }\n            // db(dp);\n            return dp[target][(int)a.size()];\n        };\n\n        int ans = -1;\n        for (int i = 0; i < n; i++) {\n            int here = findIfSumPossible(nums[i], mp[i]);\n            db(here);\n            if (here == inf) {\n                return -1;\n            }\n            ans = max(ans, here);\n        }\n        return ans;\n    }\n};\n\n#ifdef LOCAL\nint32_t main() {\n    fastio;\n    int testCases = 1;\n    // cin >> testCases;\n    for (int i = 1; i <= testCases; i++) {\n        Solution s;\n        vector<int> nums = {2, 0, 2};\n        vector<vector<int>> queries = {{0, 2, 1}, {0, 2, 1}, {1, 1, 3}};\n        auto ans = s.minZeroArray(nums, queries);\n        sout(ans);\n    }\n}\n#endif","author":"Chethan J","submissionId":"1575176311"},[]]},{"568":[{"id":"568","fileName":"1575176242.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, q = len(nums), len(queries)\n        mxI = 0\n        \n        for i in range(n):\n            if nums[i] == 0:\n                continue\n            \n            dp = [False] * (nums[i] + 1)\n            dp[0] = True\n            for j in range(q):\n                if queries[j][0] <= i <= queries[j][1] and queries[j][2] <= nums[i]:\n                    v = queries[j][2]\n                else:\n                    continue\n                \n                for s in range(nums[i], v - 1, -1):\n                    if dp[s - v]:\n                        dp[s] = True\n                \n                if dp[nums[i]]:\n                    mxI = max(mxI, j + 1)\n                    break\n            \n            if dp[nums[i]] == False:\n                return -1\n        return mxI","author":"Atul","submissionId":"1575176242"},[]]},{"569":[{"id":"569","fileName":"1575176617.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        @cache\n        def dfs(i, c, j):\n            if c == 0:\n                return i\n            if i>=len(queries):\n                return 100000\n            \n            res = 100000\n            l, r, val = queries[i]\n            if l <= j <= r and val <= c:\n                res = min(res, dfs(i + 1, c - val, j))\n            res = min(res, dfs(i + 1, c, j))\n            return res\n        result = 0\n        for i in range(n):\n            ans = dfs(0, nums[i], i)\n            dfs.cache_clear()\n            if ans == 100000:\n                return -1\n            result = max(result, ans)\n            \n            \n        return result\n            \n                \n                ","author":"resposible_display","submissionId":"1575176617"},[]]},{"570":[{"id":"570","fileName":"1575176667.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        # Preprocess for each element i: list of (query index j, val_j) where i is in [l_j, r_j]\n        element_queries = [[] for _ in range(n)]\n        for j in range(m):\n            l, r, val = queries[j]\n            for i in range(l, r + 1):\n                if i < n:  # Ensure index is within bounds\n                    element_queries[i].append((j, val))\n        \n        max_k = 0\n        for i in range(n):\n            target = nums[i]\n            if target == 0:\n                continue\n            q_list = element_queries[i]\n            dp = {0: -1}\n            for (j, val) in q_list:\n                temp_entries = {}\n                for s in list(dp.keys()):\n                    current_max_j = dp[s]\n                    new_sum = s + val\n                    if new_sum > target:\n                        continue\n                    new_max_j = max(current_max_j, j)\n                    if new_sum not in temp_entries or new_max_j < temp_entries[new_sum]:\n                        temp_entries[new_sum] = new_max_j\n                # Merge temp_entries into dp\n                for s in temp_entries:\n                    new_max_j = temp_entries[s]\n                    if s not in dp or new_max_j < dp.get(s, float('inf')):\n                        dp[s] = new_max_j\n            if target not in dp:\n                return -1\n            required_j_max = dp[target]\n            required_k_i = required_j_max + 1\n            if required_k_i > max_k:\n                max_k = required_k_i\n        # Check if all elements were zero\n        if all(num == 0 for num in nums):\n            return 0\n        return max_k if max_k != 0 else -1\n        ","author":"arisadeveloper","submissionId":"1575176667"},[]]},{"571":[{"id":"571","fileName":"1575176517.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        max_val = max(nums)\n        if max_val == 0:\n            return 0  \n        \n        LIMIT = 1001\n        ALL_ONES_MASK = (1 << LIMIT) - 1  \n    \n        dp = [(1 << 0) for _ in range(n)]  \n    \n        for k, (l, r, val) in enumerate(queries, start=1):\n            shift_amount = val\n            \n            for i in range(l, r+1):\n                old_mask = dp[i]\n                shifted = (old_mask << shift_amount) & ALL_ONES_MASK\n                dp[i] = old_mask | shifted\n    \n            all_zero = True\n            for i in range(n):\n                \n                if nums[i] > max_val: \n                    \n                    all_zero = False\n                    break\n                if not (dp[i] & (1 << nums[i])):\n                    all_zero = False\n                    break\n            \n            if all_zero:\n                return k  \n    \n        return -1","author":"Xray Whiskey","submissionId":"1575176517"},[]]},{"572":[{"id":"572","fileName":"1575176687.txt","sourceCode":"#define ll long long\n#define ull unsigned long long\n#define MOD 1000000007\n#define pb push_back\n#define F first\n#define S second\n#define all(v) (v).begin(),(v).end()\n#define rall(v) (v).rbegin(),(v).rend()\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rrep(i,n) for(int i=(n)-1;i>=0;--i)\n#define lloop(i,a,b) for(int i=(a);i<=(b);++i)\n#define jloop(i,a,b,k) for(int i=(a);i<=(b);i+=(k))\n#define nlloop(i,a,b) for(int i=(a);i>=(b);--i)\n#define njloop(i,a,b,k) for(int i=(a);i>=(b);i-=(k))\n#define vi vector<int>\n#define vll vector<long long>\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vpii vector<pair<int,int>>\n#define vpll vector<pll>\n#define vvi vector<vi>\n#define vb vector<bool>\n#define umii unordered_map<int,int>\n#define umci unordered_map<char,int>\n#define umli unordered_map<ll,int>\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(),ans=0;\n        rep(i,n)\n        {\n            if(nums[i]==0)\n                continue;\n            vpii pr;\n            rep(j,(int)queries.size())\n            {\n                int u=queries[j][0],v=queries[j][1],w=queries[j][2];\n                if(u<=i && i<=v)\n                    pr.pb({j,w});\n            }\n            int tar=nums[i];\n            vi dp(tar+1,INT_MAX);\n            dp[0]=0;\n            for(auto it:pr)\n            {\n                int key=it.F,val=it.S;\n                nlloop(k,(tar-val),0)\n                {\n                    if(dp[k]!=INT_MAX)\n                    {\n                        int temp=max(dp[k],key+1);\n                        dp[k+val]=min(dp[k+val],temp);\n                    }\n                }\n            }\n            if(dp[tar]==INT_MAX)\n                return -1;\n            ans=max(ans,dp[tar]);\n        }\n        return ans;\n    }\n};","author":"Aditya Mondal","submissionId":"1575176687"},[]]},{"573":[{"id":"573","fileName":"1575176748.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] qs) {\n        int n = nums.length, qn = qs.length;\n        int maxOfMins = 0;\n        for(int i=0; i<n; i++) {\n            int min = solve(0, i, nums[i], qs, new Integer[qn][nums[i]+1]);\n            maxOfMins = Math.max(maxOfMins, min);\n        }\n        \n        return maxOfMins > qn? -1: maxOfMins;\n    }\n    \n    private int solve(int i, int ni, int num, int[][] q, Integer[][] dp) {\n        if(i == q.length) {\n            if(num > 0) \n                return 100;\n            return 0;\n        }\n        \n        if(num == 0) return 0;\n        \n        if(dp[i][num] != null) {\n            return dp[i][num];\n        }\n        \n        int l = q[i][0], r = q[i][1], v = q[i][2];\n        int min = solve(i + 1, ni, num, q, dp);\n        if(l <= ni && r >= ni && num >= v) {\n            min = Math.min(min, solve(i + 1, ni, num - v, q, dp));\n        }\n        \n        return dp[i][num] = min + 1;\n    }\n}","author":"Saurabh_082","submissionId":"1575176748"},[]]},{"574":[{"id":"574","fileName":"1575176717.txt","sourceCode":"class Solution {\n    int res = Integer.MAX_VALUE;\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int sum = Arrays.stream(nums).sum();\n        if(sum == 0) return 0;\n        int n = nums.length;\n        List<int[]>[] lists = new List[n];\n        for(int i = 0; i < n; i++) lists[i] = new ArrayList<>();\n        for(int i = 0; i < queries.length; i++) {\n            int[] query = queries[i];\n            int l = query[0], r = query[1], val = query[2];\n            for(int j = l; j <= r; j++) {\n                lists[j].add(new int[]{val, i});\n            }\n        }\n        int res = Integer.MIN_VALUE;\n        for(int i = 0; i < n; i++) {\n            int t = helper(lists[i], nums[i]);\n            // System.out.println(\"t: \" + t);\n            if(t == -1) return -1;\n            res = Math.max(res, t);\n        }\n        return res;\n    }\n    \n    \n    int helper(List<int[]> list, int target) {\n        int n = list.size();\n        // list.forEach((e) -> System.out.print(Arrays.toString(e)));\n        // System.out.println(\", target: \" + target);\n        boolean[][] dp = new boolean[n + 1][target + 1];\n        dp[0][0] = true;\n        \n        for(int i = 1; i <= n; i++) {\n            int[] cur = list.get(i - 1);\n            int val = cur[0], index = cur[1];\n            for(int j = 0; j <= target; j++) {\n                dp[i][j] |= dp[i - 1][j];\n                if(j - val >= 0) dp[i][j] |= dp[i - 1][j - val];\n            }\n            if(dp[i][target]) return index + 1;\n        }\n        \n        return -1;\n    }\n    \n//     boolean helper(int cur, int[] queries, int[] nums) {\n//         int pos = 0;\n//         for(int num : nums) {\n//             if(num < 0) return false;\n//             if(num > 0) pos++;\n//         }\n//         if(pos == 0) return true;\n        \n//         int[] query = queries[cur];\n//         int l = query[0], r = query[1], val = query[2];\n        \n//         for(int )\n//     }\n}","author":"ws1255","submissionId":"1575176717"},[]]},{"575":[{"id":"575","fileName":"1575176833.txt","sourceCode":"impl Solution {\n    pub fn min_zero_array(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> i32 {\n        let n = nums.len();\n        let mut ans = vec![i32::MAX; n];\n        for i in 0..n {\n            let max = nums[i] as usize;\n            let mut dp = vec![i32::MAX; max+1];\n            dp[max] = 0;\n            for qi in 0..queries.len() {\n                let q = &queries[qi];\n                let (l, r, val) = (q[0] as usize, q[1] as usize, q[2] as usize);\n                if i < l || r < i {\n                    continue;\n                }\n                for j in val..=max {\n                    if dp[j] != i32::MAX {\n                        dp[j-val] = dp[j-val].min(qi as i32 +1);\n                    }\n                }\n            }\n            ans[i] = dp[0];\n        }\n        let ansmax = ans.iter().max().unwrap();\n        if *ansmax == i32::MAX {\n            -1\n        } else {\n            *ansmax\n        }\n    }\n}","author":"tomarin","submissionId":"1575176833"},[]]},{"576":[{"id":"576","fileName":"1575176865.txt","sourceCode":"class Solution {\npublic:\n    \n    bool r(vector<int> &vals,int x) {\n        vector<bool> dp(x+1,0);\n        dp[0]=1;\n        for (auto v:vals) {\n            for (int j=x;j>=v;j--) {\n                dp[j] = (dp[j]||dp[j-v]);\n            }\n        }\n        return dp[x];\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        \n        int s=0,e=q,ans=-1;\n        while(s<=e) {\n            int mid=s+(e-s)/2;\n            \n            bool f=1;\n            for (int i=0;i<n;++i) {\n                vector<int> v;\n                for (int j=0;j<mid;++j) {\n                    if ((queries[j][0]<=i)&&(i<= queries[j][1]))\n                        v.push_back(queries[j][2]);\n                }\n                if(!r(v,nums[i])){\n                    f=0;break;\n                }\n            }\n\n            if (f) {\n                ans=mid;\n                e=mid-1;\n            } else {\n                s=mid+1;\n            }\n        }\n\n        return ans;\n    }\n};","author":"sutanjoypal","submissionId":"1575176865"},[]]},{"577":[{"id":"577","fileName":"1575177226.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>&a, vector<vector<int>>&q) {\n        int n=a.size(),m=q.size();\n        int flag=1;\n        int i;\n        for(i=0;i<n;i++)\n            {\n                if(a[i]!=0)\n                {\n                    flag=0;\n                    break;\n                }\n            }\n        if(flag)\n            return 0;\n        vector<vector<pair<int,int>>>v(n);\n        int j;\n        for(j=0;j<m;j++)\n            {\n                int l=q[j][0],r=q[j][1],val=q[j][2];\n                for(i=l;i<=r;i++)\n                    {\n                        v[i].push_back({j,val});\n                    }\n            }\n\n        for(i=0;i<n;i++)\n            {\n                sort(v[i].begin(), v[i].end(), \n                 [](const pair<int,int>& a, const pair<int,int>& b){\n                     return a.first < b.first;\n                 });\n            }\n\n        int l=1;\n        int h=m+1;\n        while(l<h)\n            {\n                int mid=l+(h-l)/2;\n                flag=1;\n                for(i=0;i<n;i++)\n                    {\n                        int t=a[i];\n                        bitset<1001>dp;\n                        dp.reset();\n                        dp[0]=1;\n                        for(auto &it:v[i])\n                            {\n                                if(it.first>=mid)\n                                    break;\n                                int t1=it.second;\n                                dp|=(dp<<t1);\n                                if(dp[t])break;\n                            }\n                        if(!dp[t])\n                        {\n                            flag=0;\n                            break;\n                        }\n                    }\n                if(flag)\n                {\n                    h=mid;\n                }\n                else\n                {\n                    l=mid+1;\n                }\n            }\n        if(l>m)\n            return -1;\n        return l;\n    }\n};","author":"Soumyadeep Singh","submissionId":"1575177226"},[]]},{"578":[{"id":"578","fileName":"1575176889.txt","sourceCode":"using i8 = int8_t;\nusing u8 = uint8_t;\nusing i16 = int16_t;\nusing u16 = uint16_t;\nusing i32 = int32_t;\nusing u32 = uint32_t;\nusing i64 = int64_t;\nusing u64 = uint64_t;\n\nusing f32 = float;\nusing f64 = double;\n\n#define all(x) (x).begin(), (x).end()\n#define ll long long int\n#define VI vector<ll>\n#define VVI vector<VI>\n\n#define ISD true\n#define debug(x) \n    if (ISD)     \n    cout << #x << \": \" << x << endl\n#define DEBUG(x) cout << #x << \": \" << x << endl\n\ntemplate <typename C>\ni64 SIZE(const C &c)\n{\n    return static_cast<i64>(c.size());\n}\n\ntemplate <typename T, size_t N>\ni64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }\n\ntemplate <typename T, typename U, typename Comp = less<>>\nbool chmax(T &xmax, const U &x, Comp comp = {})\n{\n    if (comp(xmax, x))\n    {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T, typename U, typename Comp = less<>>\nbool chmin(T &xmin, const U &x, Comp comp = {})\n{\n    if (comp(x, xmin))\n    {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\n#define CPP_STR(x) CPP_STR_I(x)\n#define CPP_CAT(x, y) CPP_CAT_I(x, y)\n#define CPP_STR_I(args...) #args\n#define CPP_CAT_I(x, y) x##y\n\n#define ASSERT(expr...) assert((expr))\n\n// }}}\n\nconstexpr i64 INF = 1'010'000'000'000'000'017LL;\n\nconstexpr i64 MOD = 998244353LL;\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n#define M5 100007\n#define M9 1000000000\n\n#define F first\n#define S second\n\n// util {{{\n#define FOR(i, start, end) for (i64 i = (start), CPP_CAT(i, xxxx_end) = (end); i < CPP_CAT(i, xxxx_end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nclass Solution\n{\npublic:\n    int minZeroArray(vector<int> &nums, vector<vector<int>> &queries)\n    {\n        ll N = nums.size();\n        ll M = 1001;\n        vector<vector<bool>> dp(N, vector<bool>(M, false));\n        REP(i, N)\n        dp[i][0] = true;\n        ll ans = 0;\n        bool isOK0 = true;\n        REP(i, N)\n        {\n            if (nums[i] != 0)\n            {\n                isOK0 = false;\n            }\n        }\n        if (isOK0)\n            return 0;\n\n        for (auto q : queries)\n        {\n            ans++;\n            FOR(i, q[0], q[1] + 1)\n            {\n                for (int j = M; j >= 0; j--)\n                {\n                    if (j + q[2] > M)\n                        continue;\n                    if (dp[i][j])\n                    {\n                        dp[i][j + q[2]] = true;\n                    }\n                }\n            }\n            bool isOK = true;\n            REP(i, N)\n            {\n                if (!dp[i][nums[i]])\n                {\n                    isOK = false;\n                }\n            }\n            if (isOK)\n            {\n                return ans;\n            }\n        }\n        return -1;\n    }\n};","author":"atm314","submissionId":"1575176889"},[]]},{"579":[{"id":"579","fileName":"1575176775.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(queries)\n\n        def getMinQueries(idx, val):\n            A = [[False] * (val + 1) for _ in range(n + 1)]     \n            A[0][val] = True\n\n            for i in range(1, n + 1):\n                l, r, dec = queries[i - 1]\n                for j in range(val + 1):\n                    if l <= idx <= r and j + dec <= val:\n                        A[i][j] |= A[i - 1][j + dec]\n                    A[i][j] |= A[i - 1][j]\n                    # print(idx, val, i, j, A[i][j])\n                if A[i][0] == True:\n                    return i\n            return -1\n        \n        allZero = True\n        for val in nums:\n            if val != 0:\n                allZero = False\n        if allZero:\n            return 0\n        \n        ans = -1\n        for idx, val in enumerate(nums):\n            res = getMinQueries(idx, val)\n            if res == -1:\n                return -1\n            ans = max(ans, res)\n        return ans\n\n","author":"hathacker5","submissionId":"1575176775"},[]]},{"580":[{"id":"580","fileName":"1575177265.txt","sourceCode":"class Solution {\npublic:\ntypedef long long ll; \ntypedef long double ld;\n#define pb push_back\n#define be(a) a.begin(), a.end()\n#define vi vector<int> \n#define vl vector<ll>\n#define vs vector<string>\n#define vc vector<char>\n#define yes cout<<\"YES\"<<endl;\n#define no cout<<\"NO\"<<endl;\n#define loop(i,n) for(int i=0;i<n;i++)\n    bool prx(int pew,vi& sus) \n    {\n        if(pew==0)\n        {\n            return true;\n        }\n        if (sus.empty()) return false;  \n\n        int tf= accumulate(sus.begin(), sus.end(), 0);\n        if (tf < pew) return false;\n        vector<bool> dp(pew+1, false);\n        dp[0]=true;\n\n        loop(i,sus.size())\n        {\n            int v=sus[i];\n            for (int j=pew;j>=v;j--) \n            {\n                dp[j] = dp[j] or dp[j - v];\n            }\n        }\n        return dp[pew];\n    }\n    bool valid(vi& nums,vector<vi>& meth)\n    {\n        loop(i,nums.size())\n        {\n            if(!prx(nums[i],meth[i]))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) \n    {\n        int n = nums.size();\n \n        int ans=0;\n        int ct=0;\n        vector<vi> rgx(n); \n        loop(i,nums.size())\n        {\n            if(nums[i]==0)\n            {\n                ct++;\n            }\n        }\n        if(ct==nums.size())\n        {\n            return 0;\n        }\n        for (auto& query : queries) \n        {\n            int l = query[0];\n            int r = query[1];\n            int val = query[2]; \n            for(int i=l;i<=r;i++)\n            {\n                rgx[i].pb(val);\n            }\n            if (valid(nums,rgx)) \n            {\n                return ans + 1;\n            }\n\n            ans++;\n        }\n        return -1;\n    }\n};","author":"s1ege","submissionId":"1575177265"},[]]},{"581":[{"id":"581","fileName":"1575177347.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        element_queries = [[] for _ in range(n)]\n        for j, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                element_queries[i].append((j, val))\n        \n        required_ks = []\n        for i in range(n):\n            current_num = nums[i]\n            applicable = element_queries[i]\n            \n            if current_num == 0:\n                required_ks.append(0)\n                continue\n            \n            sum_vals = sum(val for _, val in applicable)\n            if sum_vals < current_num:\n                return -1\n            applicable.sort()\n            dp = {0: -1} \n            for j_original, val in applicable:\n                temp = {}\n                for s in list(dp.keys()):\n                    new_sum = s + val\n                    if new_sum not in dp:\n                        temp[new_sum] = j_original\n                for s in temp:\n                    if s not in dp or temp[s] < dp.get(s, float('inf')):\n                        dp[s] = temp[s]\n            \n            if current_num not in dp:\n                return -1\n            required_j = dp[current_num]\n            required_ks.append(required_j + 1)\n        max_k = max(required_ks)\n        if max_k > len(queries):\n            return -1\n        return max_k    \n        ","author":"_hari_18_","submissionId":"1575177347"},[]]},{"582":[{"id":"582","fileName":"1575177410.txt","sourceCode":"class Solution {\npublic:\n    int func(vector<int>& contri,int target,int idx,vector<vector<int>>& dp){\n        if(target==0){\n            return true;\n        }\n        if(idx>=contri.size()){\n            return false;\n        }\n        if(dp[idx][target]!=-1){\n            return dp[idx][target];\n        }\n        bool pick=false;\n        if(contri[idx]<=target){\n            pick |= func(contri,target-contri[idx],idx+1,dp);\n        }\n        bool notpick=func(contri,target,idx+1,dp);\n        return dp[idx][target]=(pick || notpick);\n    }\n    int f(int target,vector<int>& contri){\n        int n=contri.size();\n        vector<vector<int>> dp(n, vector<int>(target + 1, -1));\n        return func(contri,target,0,dp);\n    }\n    \n    bool isPos(vector<int>& nums, vector<vector<int>>& queries, int tmp){\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            if(nums[i]==0){\n                continue;\n            }\n            vector<int> contri;\n            for(int j=0;j<tmp;j++){\n                if(i>=queries[j][0] && i<=queries[j][1]){\n                    contri.push_back(queries[j][2]);\n                }\n            }\n            if(!f(nums[i],contri)){\n                return false;\n            }\n        }\n        return true;\n    }    \n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int s=0,e=queries.size();\n        int ans=-1;\n        while(s<=e){\n            int m=s+(e-s)/2;\n            if(isPos(nums,queries,m)){\n                ans=m;\n                e=m-1;\n            }else{\n                s=m+1;\n            }\n        }\n        return ans;\n    }\n};","author":"prajpro","submissionId":"1575177410"},[]]},{"583":[{"id":"583","fileName":"1575177246.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int[][] dp = new int[n][1001];\n\n        for (int j = 0; j < n; j++) {\n            Arrays.fill(dp[j], 0);\n            dp[j][0] = 1;\n        }\n\n        boolean all_zero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                all_zero = false;\n                break;\n            }\n        }\n        if (all_zero)\n            return 0;\n\n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n                int[] newDp = new int[1001];\n                for (int i = 0; i < 1001; i++) {\n                    if (dp[j][i] == 1) {\n                        if (i + v < 1001) {\n                            newDp[i + v] = 1;\n                        }\n                    }\n                }\n                for (int i = 0; i < 1001; i++) {\n                    dp[j][i] |= newDp[i];\n                }\n\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp[j][pos] = 0;\n                }\n            }\n\n            boolean valid = true;\n            for (int j = 0; j < n; j++) {\n                if (dp[j][nums[j]] == 0) {\n                    valid = false;\n                    break;\n                }\n            }\n            if (valid)\n                return k + 1;\n        }\n        return -1;\n    }\n}\n","author":"Revanth Sai Chaparala","submissionId":"1575177246"},[{"id":"1561","similarity":0.8622222222222222,"totOverlap":194,"longestOverlap":45}]],"1561":[{"id":"1561","fileName":"1575236963.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] qs) {\n        int n = nums.length;\n        int[][] dp = new int[n][1001];\n\n        for (int j = 0; j < n; j++) {\n            dp[j][0] = 1;\n        }\n\n        boolean az = true;\n        for (int x : nums) {\n            if (x != 0) {\n                az = false;\n                break;\n            }\n        }\n        if (az)\n            return 0;\n\n        for (int i = 0; i < qs.length; i++) {\n            int l = qs[i][0];\n            int r = qs[i][1];\n            int v = qs[i][2];\n\n            for (int j = l; j <= r; j++) {\n                int[] tmp = new int[1001];\n\n                for (int k = 0; k < 1001 - v; k++) {\n                    if (dp[j][k] == 1) {\n                        tmp[k + v] = 1;\n                    }\n                }\n\n                for (int k = 0; k < 1001; k++) {\n                    if (tmp[k] == 1) {\n                        dp[j][k] = 1;\n                    }\n                }\n                for (int p = nums[j] + 1; p < 1001; p++) {\n                    dp[j][p] = 0;\n                }\n            }\n\n            boolean ok = true;\n            for (int j = 0; j < n; j++) {\n                if (dp[j][nums[j]] != 1) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok){\n                return i + 1;\n                \n            }\n        }\n        return -1;\n    }\n}","author":"Jaimin Detroja","submissionId":"1575236963"},[{"id":"583","similarity":0.8622222222222222,"totOverlap":194,"longestOverlap":45}]]},{"584":[{"id":"584","fileName":"1575177541.txt","sourceCode":"class Solution {\npublic:\n  int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    int n = nums.size();\n    using sum_t = bitset<11000>;\n    vector<sum_t> tab(n, sum_t(1));\n\n    auto canDo = [&] {\n      for (int i = 0; i < n; ++i) {\n        if (!tab[i].test(nums[i])) {\n          return false;\n        }\n      }\n      return true;\n    };\n    if (canDo()) {\n      return 0;\n    }\n\n    for (int i = 0; i < (int)queries.size(); ++i) {\n      int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n      for (int p = l; p <= r; ++p) {\n        auto& sum = tab[p];\n        sum |= (sum << v);\n      }\n      if (canDo()) {\n        return i + 1;\n      }\n    }\n    return -1;\n  }\n};","author":"Dexter","submissionId":"1575177541"},[]]},{"585":[{"id":"585","fileName":"1575177394.txt","sourceCode":"\n\nclass Solution {\n    public:\n\n        int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n            int Q = queries.size();\n\n            int n = nums.size();\n            vector<bitset<1001>> can(n);\n            for(int i=0;i<n;i++) {\n                can[i].reset();\n                can[i][0]=true;\n            }\n\n            // if all zeros, return 0\n            if(accumulate(nums.begin(),nums.end(),0)==0) {\n                return 0;\n            }\n\n            for(int k=0;k<queries.size();k++) {\n                int l = queries[k][0];\n                int r = queries[k][1];\n                int delta = queries[k][2];\n                for(int i=l;i<=r;i++) {\n                    can[i] |= (can[i]<<delta);\n                }\n                bool ok=true;\n                for(int i=0;i<n;i++) {\n                    if (!can[i][nums[i]]) ok=false;\n                }\n                if(ok) return k+1;\n            }\n            return -1;\n        }\n    };\n\n","author":"Balakrishnan Varadarajan","submissionId":"1575177394"},[]]},{"586":[{"id":"586","fileName":"1575178151.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int q = queries.size();\n        int n = nums.size();\n        vector<set<int>> vs(n);\n        int zeros = 0;\n        for (int i = 0; i < n; ++i) {\n            if (!nums[i]) {\n                zeros++;\n            }\n        }\n        if (zeros == n)\n            return 0;\n        for (int i = 0; i < q; ++i) {\n            // cout<<\"EEE\"<<endl;\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            bool works = true;\n            for (int j = l; j <= r; ++j) {\n                if (nums[j] == 0 || vs[j].count(nums[j]))\n                    continue;\n                if (vs[j].size() == 0) {\n                    vs[j].insert(val);\n                    if (val == nums[j])\n                        zeros++;\n                } else {\n                    set<int> s;\n                    for (auto x : vs[j]) {\n                        s.insert(x + val);\n                    }\n                    for (auto x : s) {\n                        vs[j].insert(x);\n                    }\n                    vs[j].insert(val);\n                    if (vs[j].count(nums[j])) {\n                        zeros++;\n                    }\n                }\n            }\n            if (zeros == n)\n                return i + 1;\n        }\n        return -1;\n    }\n};","author":"BrainZhao","submissionId":"1575178151"},[]]},{"587":[{"id":"587","fileName":"1575177895.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        N = len(nums)\n        \n        vv = True\n        \n        for i in range(N):\n            if nums[i] != 0:\n                vv = False\n                break\n                \n        if vv: return 0\n        \n        def check(target):\n            xx = nums[:]\n            val_a = [[] for _ in range(N)]\n            \n            for i in range(N):\n                for pos in range(target):\n                    l, r, v = queries[pos]\n\n                    if l <= i <= r:\n                        if xx[i] >= v:\n                            val_a[i].append(v)\n            \n            def solve(i):\n                if i == N:\n                    return True\n                \n                if xx[i] == 0:\n                    return solve(i + 1)\n                \n                vals = val_a[i]\n                            \n                @cache\n                def f(pp, ss):\n                    if ss == xx[i]:\n                        return True\n                    \n                    if pp == len(vals):\n                        return False\n                    \n                    res = f(pp + 1, ss)\n                    if res: return True\n                    \n                    return f(pp + 1, ss + vals[pp])\n                \n                ress = f(0, 0)\n                f.cache_clear()\n                if ress: return solve(i + 1)\n                    \n                return False\n            \n            return solve(0)\n            \n#             q = collections.deque()\n#             q.append((0, nums[:]))\n            \n#             while q:\n#                 for _ in range(len(q)):\n#                     pos, x = q.popleft()\n                    \n#                     if not any(xx for xx in x if xx != 0): return True\n                    \n#                     if pos >= target: continue\n            \n#                     l, r, v = queries[pos]\n                \n#                     rr = list(range(l, r + 1))\n#                     for ll in range(r - l + 2):\n#                         for c in itertools.combinations(rr, ll):\n#                             valid = True\n#                             nx = x[:]\n#                             for i in c:\n#                                 if nx[i] < v:\n#                                     valid = False\n#                                     break\n#                                 nx[i] -= v\n#                             if valid:\n#                                 if not any(xx for xx in nx if xx != 0):\n#                                     return True\n#                                 q.append((pos + 1, nx))\n                \n#             return False\n        \n        low, high = 1, len(queries)\n        \n        while low < high:\n            mid = low + ((high - low) >> 1)\n            \n            if check(mid):\n                high = mid\n            else:\n                low = mid + 1\n                \n        return high if check(high) else -1\n    \n#     [2,0,2]\n# [[0,2,1],[0,2,1],[1,1,3]]\n# [4,3,2,1]\n# [[1,3,2],[0,2,1]]\n# [1,2,3,2,1]\n# [[0,1,1],[1,2,1],[2,3,2],[3,4,1],[4,4,1]]\n# [1,2,3,2,6]\n# [[0,1,1],[0,2,1],[1,4,2],[4,4,4],[3,4,1],[4,4,5]]\n# [10]\n# [[0,0,4],[0,0,8],[0,0,1],[0,0,10],[0,0,10]]\n# [18,4]\n# [[1,1,1],[1,1,3],[1,1,9],[0,0,1],[1,1,6],[1,1,3],[1,1,4],[0,0,1],[1,1,4],[0,0,5],[0,0,4],[1,1,10],[1,1,2],[1,1,8],[1,1,7],[1,1,7]]\n# [13,12,20]\n# [[0,2,4],[0,2,8],[2,2,2],[1,2,7],[2,2,1],[1,1,2],[2,2,9],[1,2,4],[1,2,2],[2,2,8],[0,0,4],[0,0,8],[0,1,10],[1,1,2],[1,1,6],[2,2,3],[1,1,2],[0,1,7],[2,2,6]]\n                        ","author":"vfh5025","submissionId":"1575177895"},[]]},{"588":[{"id":"588","fileName":"1575178190.txt","sourceCode":"#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\nprivate:\n    // Custom class to store all variables\n    class MinimumOperationsCalculator {\n    public:\n        // Input data\n        vector<int> originalArray;\n        vector<vector<int>> operationQueries;\n        int arraySize;\n        int queryCount;\n        \n        // Constructor\n        MinimumOperationsCalculator(vector<int>& inputArray, vector<vector<int>>& queries) {\n            originalArray = inputArray;\n            operationQueries = queries;\n            arraySize = inputArray.size();\n            queryCount = queries.size();\n        }\n        \n        // Check if we can reduce array to zero using first k queries\n        bool canMakeZero(int k) {\n            // Check each element in the array\n            for (int position = 0; position < arraySize; position++) {\n                // Dynamic programming array to track possible sums\n                vector<bool> possibleSums(1001, false);\n                possibleSums[0] = true;  // Base case: we can always make sum of 0\n                \n                // Apply each of the first k queries that affect current position\n                for (int queryIndex = 0; queryIndex < k; queryIndex++) {\n                    // Check if query applies to current position\n                    if (position >= operationQueries[queryIndex][0] && \n                        position <= operationQueries[queryIndex][1]) {\n                        \n                        // Value to subtract from current element\n                        int subtractValue = operationQueries[queryIndex][2];\n                        \n                        // Update possible sums (iterate backwards to avoid counting same operation multiple times)\n                        for (int sum = 1000 - subtractValue; sum >= 0; sum--) {\n                            if (possibleSums[sum]) {\n                                possibleSums[sum + subtractValue] = true;\n                            }\n                        }\n                    }\n                }\n                \n                // Check if we can reduce current element to zero\n                if (!possibleSums[originalArray[position]]) {\n                    return false;\n                }\n            }\n            \n            return true;\n        }\n        \n        // Binary search to find minimum number of queries\n        int findMinimumQueries() {\n            int lowerBound = 0;\n            int upperBound = queryCount;\n            int result = -1;\n            \n            while (lowerBound <= upperBound) {\n                int middle = (lowerBound + upperBound) / 2;\n                \n                if (canMakeZero(middle)) {\n                    result = middle;\n                    upperBound = middle - 1;  // Try fewer queries\n                } else {\n                    lowerBound = middle + 1;  // Need more queries\n                }\n            }\n            \n            return result;\n        }\n    };\n\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        // Create calculator object and find minimum queries needed\n        MinimumOperationsCalculator calculator(nums, queries);\n        return calculator.findMinimumQueries();\n    }\n};","author":"monk0707","submissionId":"1575178190"},[]]},{"589":[{"id":"589","fileName":"1575178167.txt","sourceCode":"\n  //the game is won at the practice not during the performance//-->someone \n  #include <bits/stdc++.h>\n  using namespace std;\n  #define ll                     long long int\n  #define all(v)                 v.begin(), v.end()\n  #define maxi(v)                *max_element(v.begin(), v.end())\n  #define vecsum(v)              accumulate(v.begin(), v.end(), 0LL)\n  #define mini(v)                *min_element(v.begin(), v.end())\n  #define sortd(v)                sort(v.begin(), v.end(), greater<int>())\n  #define read(a, n)             for(int i=0;i<n;i++)    cin >> a[i]\n  #define print(a, n)            for(int i=0;i<n;i++)    cout << a[i] << \" \"; cout << endl\n  #define rep(a,n,b,i)           for(int i=a;i<n;i+=b)       \n  #define M                       1000000007\n  #define pb                      push_back\n  #define sz                      size()\n  #define len                     length()\n  #define fir                     first\n  #define sec                     second\n  #define cy                      cout << \"YES\" << endl\n  #define cn                      cout << \"NO\" << endl \n  using pp = pair<ll,ll>;\n  using ppp = pair<ll,pair<ll,ll>>;\n  using vl = vector<ll>;\n  using vc = vector<char>;\n  using vi = vector<int>;\n  using vvl=vector<vector<ll>>;\n  using vvc=vector<vector<char>>;\n  \n  class Solution {\n    public:\n    bool ss(vector<ll>& arr, ll tar) {\n        vector<bool>dp(tar+ 1,false);\n        dp[0]=true; \n        for (auto it:arr) {\n            for (int j=tar;j>=it;--j) {\n                dp[j]=dp[j]||dp[j - it];  \n            }\n        }\n    \n        return dp[tar];\n    }\n        int minZeroArray(vector<int>& v, vector<vector<int>>& q) {\n            ll n=v.sz,ans=-1;\n             ll low=0, hi=q.sz;\n             auto che=[&](ll mid)->bool{\n                vvl v1(n);\n                for(int i=0;i<mid;i++){\n                    ll lef=q[i][0],ri=q[i][1],val=q[i][2];\n                    for(int j=lef;j<=ri;j++){\n                        v1[j].pb(val);\n                    }\n                }\n                for(int i=0;i<n;i++){\n                    if(v[i]!=0){\n                        ll cur=v[i];\n                        vl v2=v1[i];\n                        if(!ss(v2,cur))return false;\n                    }\n                }\n                return true;\n             };\n             while(low<=hi){\n                ll mid=(low+hi)/2;\n                if(che(mid)){\n                    hi=mid-1;\n                    ans=mid;\n                }\n                else low=mid+1;\n             }\n             return ans;\n        }\n    };","author":"nishanth14","submissionId":"1575178167"},[]]},{"590":[{"id":"590","fileName":"1575178371.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        index_map = defaultdict(list)\n        index_pos = defaultdict(list)\n        n = len(nums)\n        n_q = len(queries)\n\n        def solve(x, arr):\n            if x == 0:\n                return -1\n            n = len(arr)\n            dp = [[False] * (1 + x) for i in range(n + 1)]\n            dp[0][0] = True\n            for i in range(1, n + 1):\n                for j in range(1 + x):\n                    if j >= arr[i - 1]:\n                        dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n                    else:\n                        dp[i][j] = dp[i - 1][j]\n                if dp[i][x] == True:\n                    return i - 1\n            return n\n        \n        for i, (l, r, val) in enumerate(queries):\n            for j in range(l, r + 1):\n                index_map[j].append(val)\n                index_pos[j].append(i)\n\n        ans = -1\n        for i in range(n):\n            if nums[i] == 0:\n                continue\n            arr = index_map[i]\n            ind = solve(nums[i], arr)\n            if ind >= len(arr):\n                return -1\n            ans = max(ans, index_pos[i][ind])\n        return ans + 1\n\n        ","author":"djhunjhu","submissionId":"1575178371"},[]]},{"591":[{"id":"591","fileName":"1575177684.txt","sourceCode":"#include <bits/stdc++.h>\n#pragma GCC optimize(2)\n#define rep(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep_(i, a, b) for (int i = (a); i > (b); i--)\n#define CEIL_DIV(a, b) ((b) == 0 ? 0 : (((a) >= 0) ? ((a) + (b) - 1) / (b) : (a) / (b)))\n#define FLOOR_DIV(a, b) (((a) / (b)) - ((a) % (b) != 0 &&(((a) < 0) != ((b) < 0))))\n#define mst(x, a) memset(x, a, sizeof(x))\n#define all(a) begin(a), end(a)\n#define lowbit(x) ((x) & (-(x)))\n#define bitcnt(x) (__builtin_popcountll(x))\n#define se second\n#define fi first\n#define pb push_back\n#define maxe max_element\n#define mine min_element\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, ll> pil;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\nconstexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\nconstexpr static int inf = 0x3f3f3f3f, mod = 1e9 + 7;\nconst ll infl = 0x3f3f3f3f3f3f3f3fll;\ntemplate<class T> bool chmax(T &a, T b) {\n    if (a >= b) return false;\n    a = b; return true;\n}\ntemplate<class T> bool chmin(T &a, T b) {\n    if (a <= b) return false;\n    a = b; return true;\n}\ntemplate<class T> bool chsum(T &a, T b) {\n    a = (a + b + mod) % mod;\n    return 0;\n}\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& qs) {\n        const int n = a.size();\n        const int m = qs.size();\n        int l = 0, r = m + 1;\n        while (l < r) {\n            int mid = l + ((r - l) >> 1);\n            bool sign = true;\n            rep(i, 0, n) {\n                bitset<1005> dp;\n                dp.reset();\n                dp[0] = 1;\n                rep(j, 0, mid) {\n                    if (qs[j][0] <= i && i <= qs[j][1]) {\n                        dp |= (dp << qs[j][2]);\n                    }\n                }\n                if (!dp.test(a[i])) {\n                    sign = false;\n                    break;\n                }\n            }\n            if (sign) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l > m ? -1 : r;\n    }\n};","author":"Ryan","submissionId":"1575177684"},[]]},{"592":[{"id":"592","fileName":"1575178415.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        v = [[] for i in range(len(nums))]\n\n        # splitting into values at their indexes\n        for i, q in enumerate(queries):\n            l, r, val = q\n            for j in range(l, r+1):\n                v[j].append((val, i+1))\n\n        # performing knapsack on every value\n        def knapsack(ceiling, values):\n            dp = {0}\n            for i in values:\n                new_dp = dp.copy()\n                for j in dp:\n                    s = j + i[0]\n                    if s < ceiling:\n                        new_dp.add(s)\n                    elif s == ceiling:\n                        return i[1]\n                    # else it's larger and we don't need to keep track of it\n                dp = new_dp\n            return -1\n            \n        mins = []\n        # print(v)\n        for i, x in enumerate(v):\n            if nums[i] == 0:\n                mins.append(0)\n                continue\n            r = knapsack(nums[i], x)\n            # print(r)\n            if r == -1:\n                return -1\n            else:\n                mins.append(r)\n\n        return max(mins)","author":"user7719id","submissionId":"1575178415"},[]]},{"593":[{"id":"593","fileName":"1575178621.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int mq = queries.size();\n        vector<vector<pair<int, int>>> Q(n); // For each index i, list of (query index, val) of queries that include i\n\n        // Populate Q[i] with queries that include index i\n        for (int j = 0; j < mq; ++j) {\n            int l = queries[j][0];\n            int r = queries[j][1];\n            int val = queries[j][2];\n            for (int i = l; i <= r; ++i) {\n                Q[i].emplace_back(j, val);\n            }\n        }\n\n        // Sort each Q[i] by query index\n        for (int i = 0; i < n; ++i) {\n            sort(Q[i].begin(), Q[i].end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n                return a.first < b.first;\n            });\n        }\n\n        // Precompute prefix sums and possible subset sums for each Q[i]\n        vector<vector<int>> prefixSums(n);\n        vector<vector<vector<bool>>> subsetSums(n);\n\n        for (int i = 0; i < n; ++i) {\n            const auto& queries_i = Q[i];\n            int m = queries_i.size();\n            prefixSums[i].resize(m + 1, 0);\n            for (int j = 0; j < m; ++j) {\n                prefixSums[i][j + 1] = prefixSums[i][j] + queries_i[j].second;\n            }\n\n            // Compute subset sums using dynamic programming\n            vector<vector<bool>> dp(m + 1);\n            dp[0] = vector<bool>(1, false);\n            dp[0][0] = true;\n\n            for (int j = 0; j < m; ++j) {\n                int val = queries_i[j].second;\n                int prevSize = dp[j].size();\n                dp[j + 1].resize(prevSize + val, false);\n\n                // Copy previous possibilities\n                for (int s = 0; s < prevSize; ++s) {\n                    if (dp[j][s]) {\n                        // Not take the current value\n                        if (s < dp[j + 1].size()) {\n                            dp[j + 1][s] = true;\n                        }\n                        // Take the current value\n                        if (s + val < dp[j + 1].size()) {\n                            dp[j + 1][s + val] = true;\n                        }\n                    }\n                }\n            }\n            subsetSums[i] = move(dp);\n        }\n\n        // Check for each k from 0 to mq\n        for (int k = 0; k <= mq; ++k) {\n            bool valid = true;\n            for (int i = 0; i < n; ++i) {\n                const auto& queries_i = Q[i];\n                int m = upper_bound(queries_i.begin(), queries_i.end(), make_pair(k - 1, 0),\n                    [](const pair<int, int>& a, const pair<int, int>& b) {\n                        return a.first < b.first;\n                    }) - queries_i.begin();\n\n                int sum = prefixSums[i][m];\n                if (sum < nums[i]) {\n                    valid = false;\n                    break;\n                }\n                int D = sum - nums[i];\n                if (D < 0) {\n                    valid = false;\n                    break;\n                }\n\n                if (m >= subsetSums[i].size() || D >= subsetSums[i][m].size() || !subsetSums[i][m][D]) {\n                    valid = false;\n                    break;\n                }\n            }\n            if (valid) {\n                return k;\n            }\n        }\n\n        return -1;\n    }\n};","author":"Gautam Kumar","submissionId":"1575178621"},[]]},{"594":[{"id":"594","fileName":"1575178288.txt","sourceCode":"class Solution {\npublic:\n    int dpcal[1001][1001];\n    int dp(int idx,int sum,int val,vector<int>&vec)\n    {\n      if(idx==vec.size())\n      {\n          if(sum==val)\n          {\n              return 0;\n          }\n          else\n             return 1e4;\n      }\n        if(sum>val)\n        {\n            return 1e4;\n        }\n        if(dpcal[idx][sum]!=-1)\n            return dpcal[idx][sum];\n      int ans=1e4;\n      ans=min(ans,1+dp(idx+1,sum+vec[idx],val,vec));\n      ans=min(ans,dp(idx+1,sum,val,vec));\n        dpcal[idx][sum]=ans;\n       // cout<<ans<<\"n\";\n      return ans;\n    }\n    int solve(int mid,vector<int>&nums,vector<vector<int>>&queries)\n    {\n        int n=nums.size();\n        map<int,vector<int>>cnt;\n        for(int i=0;i<mid;i++)\n        {\n            int left=queries[i][0];\n            int right=queries[i][1];\n            int val=queries[i][2];\n            for(int j=left;j<=right;j++)\n            {\n                cnt[j].push_back(val);\n            }\n        }\n       \n        memset(dpcal,-1,sizeof dpcal);\n        bool flag=true;\n        for(int i=0;i<n;i++)\n        {\n            vector<int>vec=cnt[i];\n            int ans=dp(0,0,nums[i],vec);\n         //   cout<<ans<<\" \";\n            if(ans==1e4)\n            {\n                flag=false;\n                break;\n            }\n            //cout<<\"n\";\n            memset(dpcal,-1,sizeof dpcal);\n        }\n        return flag;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) \n    {\n      int n=nums.size();\n      int sz=queries.size();\n      int l=0;\n      int r=sz;\n      int ans=-1;\n      while(l<=r)\n      {\n          int mid=l+(r-l)/2;\n          if(solve(mid,nums,queries))\n          {\n             // cout<<mid<<\"n\";\n            ans=mid;\n            r=mid-1;\n          }\n          else\n             l=mid+1;\n      }\n        return ans;\n    }\n};","author":"lostinspace","submissionId":"1575178288"},[]]},{"595":[{"id":"595","fileName":"1575178519.txt","sourceCode":"class Solution {\npublic:\n    int rec(int k,vector<int>& nums, vector<vector<int>>& queries){\n        int n = nums.size(),m = queries.size();\n        for(int i=0;i<n;i++){\n            if(nums[i] == 0) continue;\n            vector<int>temp;\n            for(int j=0;j<k;j++){\n                int l = queries[j][0],r = queries[j][1],val = queries[j][2];\n                if(l<=i && i<=r){\n                    temp.push_back(val);\n                }\n            }\n            vector<int>dp(nums[i]+1,0);\n            dp[0] = 1;\n            for(auto &it : temp){\n                for(int c = nums[i];c >= it;c--){\n                    if(dp[c - it]){\n                        dp[c] = 1;\n                    }\n                }\n            }\n            if(!dp[nums[i]]) return 0;\n        }\n        return 1;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(),m = queries.size();\n        int s = 0,e = m;\n        int ans = -1;\n        while(s <= e){\n            int mid = (s + e)/2;\n            if(rec(mid,nums,queries)){\n                ans = mid;\n                e = mid - 1;\n            }\n            else{\n                s = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"adi_097","submissionId":"1575178519"},[]]},{"596":[{"id":"596","fileName":"1575178631.txt","sourceCode":"class Solution {\npublic:\n    int dp[1001][1001];\n    int rec(vector<int>&arr, int i, int left){\n        int n = arr.size();\n        if(left < 0) return 0;\n        if(i == n) return left==0;\n    \n        if(dp[i][left] != -1) return dp[i][left];\n    \n        int ans = rec(arr, i + 1, left);\n        if(arr[i] <= left){\n            ans = ans or rec(arr, i+1, left - arr[i]);\n        }\n    \n        return dp[i][left] = ans;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n      \n        function<bool(int)> check = [&](int mid) {\n            int n = nums.size();\n            vector<vector<int> > arr(n);\n\n            for(int i = 0; i < mid; i++){ // 1e3\n                int l = queries[i][0]; int r = queries[i][1]; \n                int val = queries[i][2];\n\n                for(int j=l;j<=r;j++) arr[j].push_back(val);\n            } \n\n            for(int i = 0; i < n; i++) {\n                memset(dp, -1, sizeof(dp));\n                if(!rec(arr[i], 0, nums[i])) return false;\n            }\n            \n            return true;\n        };\n\n        int n = queries.size();\n        int lo = 0;\n        int hi = n;\n        int ans = n + 1; \n        \n        while(lo <=hi){\n            int mid = (lo + hi)/2;\n            // ffffffttttttt\n            if(check(mid)) {\n                ans = mid;\n                hi = mid - 1;\n            } else {\n                lo = mid + 1;\n            }\n        }\n\n        return ans == n + 1 ? -1: ans;\n    }\n};","author":"Shaurya","submissionId":"1575178631"},[]]},{"597":[{"id":"597","fileName":"1575178805.txt","sourceCode":"class Solution {\npublic:\n    bool isSubsetSum(vector<int>& nums, int sum) {\n        int n = nums.size();\n        vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));\n\n        for (int i = 0; i <= n; i++) dp[i][0] = true;\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= sum; j++) {\n                if (nums[i - 1] <= j)\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];\n                else\n                    dp[i][j] = dp[i - 1][j];\n            }\n        }\n\n        return dp[n][sum];\n    }\n    bool check(vector<int> nums, vector<vector<int>>& queries, set<int> pos_idx, int x){\n        vector<vector<int>> indexes(nums.size());\n        for(int i=0; i<x; ++i){\n            for(int j=queries[i][0]; j<=queries[i][1]; ++j){\n                if(nums[j] == 0) continue;\n                indexes[j].push_back(queries[i][2]);\n                if(queries[i][2] == nums[j]){\n                    nums[j] = 0;\n                    pos_idx.erase(j);\n                }\n            }\n        }\n        for(int i=0; i<nums.size(); ++i){\n            if(nums[i] == 0) continue;\n            if(isSubsetSum(indexes[i], nums[i])){\n                pos_idx.erase(i);\n            }\n        }\n        return pos_idx.size() == 0;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        set<int> pos_idx, temp;\n        for(int i=0; i<nums.size(); ++i){\n            if(nums[i] > 0){\n                pos_idx.insert(i);\n            }\n        }\n        if(pos_idx.size() == 0) return 0;\n        int l = 1, r = queries.size(), res = INT_MAX;\n        while(l<=r){\n            int mid = (l+r)/2;\n            temp = pos_idx;\n            if(check(nums, queries, temp, mid)){\n                r = mid - 1;\n                res = min(res, mid);\n            }else{\n                l = mid + 1;\n            }\n        }\n        return (res == INT_MAX) ? -1 : res;\n    }\n};","author":"Madhav Jha","submissionId":"1575178805"},[]]},{"598":[{"id":"598","fileName":"1575179133.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        if (zeroArray(nums)) return 0;\n\n        int[][] temp = queries;\n        int n = nums.length;\n\n        boolean[][] dp = new boolean[n][1001];\n        for (int i=0; i < n; i++) dp[i][0] = true;\n\n        for (int i=0; i < queries.length; i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n\n            for (int j=l; j<= r; j++) {\n                for (int k=1000; k>= val; k--) {\n                    if (dp[j][k-val]) {\n                        dp[j][k] = true;\n                    }\n                }\n            }\n\n            boolean allZero = true;\n            for (int j=0; j < n; j++) {\n                if (nums[j] <= 1000) {\n                    if (!dp[j][nums[j]]) {\n                        allZero = false;\n                        break;\n                    }\n                } else {\n                    allZero = false;\n                    break;\n                }\n            }\n\n            if (allZero) return i + 1;\n        }\n\n        return -1;\n    }\n\n    private boolean zeroArray(int[] arr) {\n        for (int x: arr) {\n            if (x != 0) return false;\n        }\n        return true;\n    }\n}","author":"Yuqi Guo","submissionId":"1575179133"},[]]},{"599":[{"id":"599","fileName":"1575178787.txt","sourceCode":"#define ll long long \n#define vl vector<ll>\n#define vvl vector<vl>\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define sep(i,a,b) for(ll i=a;i>=b;i--)\n#define sz(a) (ll)(a.size())\n#define inf (ll)(1e15)\n#define pb push_back\n#define pl pair<ll,ll>\n#define fr first\n#define sc second\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        ll n=sz(a);\n        ll m=sz(q);\n\n  \n        vl ans(n+1,inf);\n        vvl bb(n);\n        vvl dp(n,vl(1005,-1));\n        ll c=0;\n        rep(i,0,n){\n            dp[i][0]=1;\n            if(a[i]==0) c++;\n        }\n        if(c==n) return 0;\n        rep(i,0,m){\n            ll l=q[i][0],r=q[i][1],v=q[i][2];\n          \n            rep(j,l,r+1){\n                if(ans[j]!=inf) continue;\n                //01 \n\n                    ll x=v;\n                    for(ll rr=a[j];rr>=0;rr--){\n                        if(rr-x>=0 && dp[j][rr-x]==1){\n                            dp[j][rr]=1;\n                        }\n                    }\n                if(dp[j][a[j]]==1){\n                    ans[j]=i+1;\n                }\n            }\n        }\n        ll res=ans[0];\n        rep(j,1,n){\n            res=max(res,ans[j]);\n        }\n        if(res==inf) return -1;\n        return res;\n    }\n};","author":"Raghav Mangla","submissionId":"1575178787"},[]]},{"600":[{"id":"600","fileName":"1575178956.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n         unordered_map<int, int> mp;\n        \n         for(int i = 0; i < nums.size(); i++){\n               if (nums[i] == 0){\n                  mp[i] = 1;\n               }\n         }\n         if(mp.size() == nums.size())\n              return 0;\n\n         int ind = 0;\n         vector<vector<int>>dp(nums.size(), vector<int>(1001, 0));\n\n         for(int i = 0; i < nums.size(); i++){\n             dp[i][0] = 1;\n         }\n\n         for(auto it : q){\n             ind++;\n             vector<vector<int>> curr = dp;\n\n             for(int i = it[0]; i <= it[1]; i++) {\n                 if (mp.count(i)) \n                     continue;\n\n                 for(int j = 0; j <= nums[i]; j++) {\n                     if (dp[i][j] == 1 && j + it[2] <= nums[i]){\n                         curr[i][j + it[2]] = 1;\n                     }\n                 }\n                 if(curr[i][nums[i]] == 1){\n                     mp[i] = 1;\n                 }\n             }\n             dp = curr; \n\n             if(mp.size() == nums.size()) \n                 return ind;\n         }\n         return -1;\n    }\n};\n","author":"Yash Garg","submissionId":"1575178956"},[]]},{"601":[{"id":"601","fileName":"1575178925.txt","sourceCode":"class Solution {\n    private int[][] dp;\n    \n    private boolean hasSum(List<Integer> list, int idx, int sum){\n        if (sum < 0){\n            return false;\n        }\n        if (sum == 0){\n            return true;\n        }\n        if (idx == list.size()){\n            return false;\n        }\n        //System.out.println(list.size());\n        //System.out.println(idx + \" \" + sum);\n        if (dp[idx][sum] == -1) return false;\n        if (dp[idx][sum] == 1001) return true;\n\n        if (hasSum(list, idx + 1, sum) || hasSum(list, idx + 1, sum - list.get(idx))){\n            dp[idx][sum] = 1001;\n            return true;\n        } else {\n            dp[idx][sum] = -1;\n            return false;\n        }        \n    }\n    \n    private boolean isValid(int[] arr, int[][] q, int num){\n        List<List<Integer>> aux = new ArrayList<List<Integer>>();\n        for (int i = 0; i < arr.length; i++){\n            aux.add(new ArrayList<Integer>());\n        }\n        \n        for (int i = 0; i < num; i++){\n            for (int j = q[i][0]; j <= q[i][1]; j++){\n                aux.get(j).add(q[i][2]);\n            }\n        }\n\n        for (int i = 0; i < arr.length; i++){\n            dp = new int[aux.get(i).size() + 1][arr[i] + 1];\n            //System.out.println(arr[i]);\n            if (!hasSum(aux.get(i), 0, arr[i])) return false;\n        }\n\n        return true;\n    }\n    \n    public int minZeroArray(int[] nums, int[][] queries) {\n        int lo = 0;\n        int hi = queries.length;\n\n        if (isValid(nums, queries, hi)){\n            int mid = 0;\n            while (lo < hi){\n                mid = (lo + hi) / 2;\n                if (isValid(nums, queries, mid)){\n                    hi = mid;\n                } else {\n                    lo = mid + 1;\n                }\n            }\n\n            mid = (lo + hi) / 2;\n            return mid;\n        }\n\n        return -1;\n    }\n}","author":"Alfonso Valenciana","submissionId":"1575178925"},[]]},{"602":[{"id":"602","fileName":"1575179205.txt","sourceCode":"class Solution {\n\nprivate:\n    bool f(int mid , vector<int>& nums,vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        for (int j = 0; j < n; j++) {\n            bitset<1001> dp;\n            dp[0] = 1;\n            for (int i = 0; i < mid; i++) {\n                if (queries[i][0] <= j && j <= queries[i][1]) {\n                    dp |= (dp << queries[i][2]);\n                }\n            }\n            if (!dp.test(nums[j]))\n                return false;\n        }\n        return true;\n    }\n\n\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int sum = 0 ;\n        int n = nums.size();\n        int m = queries.size();\n        for(auto i : nums){\n            sum += i;\n        }\n        if(sum == 0){\n            return 0 ;\n        }\n\n        int low = 1 ;\n        int high = m ;\n        int ans = -1;\n\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (f(mid , nums, queries)) {\n                ans = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return ans;\n    }\n};","author":"Anshul Sharma","submissionId":"1575179205"},[]]},{"604":[{"id":"604","fileName":"1575179187.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        vector<vector<bool>>dp(n,vector<bool>(1001, false));\n        for(int i=0;i<n;i++)\n        {\n            dp[i][0]=true;\n        }\n        if(count(nums.begin(),nums.end(),0)==nums.size())\n        {\n            return 0;\n        }\n        \n        for(int i=0;i<queries.size();i++)\n            {\n                int l=queries[i][0];\n                int r=queries[i][1];\n                int v=queries[i][2];\n                for(int j=l;j<=r;j++)\n                    {\n                        for(int p=1000-v;p>=0;p--)\n                            {\n                                if(dp[j][p]!=0)\n                                {\n                                    dp[j][p+v]=true;\n                                }\n                            }\n                    }\n                int f=1;\n                for(int k=0;k<n;k++)\n                    {\n                        if(dp[k][nums[k]]==0)\n                        {\n                            f=0;\n                            break;\n                        }\n                    }\n                if(f)\n                {\n                    return i+1;\n                }\n            }\n        return -1;\n    }\n};","author":"sh2004","submissionId":"1575179187"},[]]},{"605":[{"id":"605","fileName":"1575179315.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n\n        @cache\n        def dp(i, num, idx):\n            if idx == m:\n                return m+1\n            take = notake = float(inf)\n            if queries[idx][0] <= i <= queries[idx][1] and num >= queries[idx][2]:\n                left = num - queries[idx][2]\n                take = idx+1 if left == 0 else dp(i, left, idx+1)\n\n            notake = dp(i, num, idx+1)\n            return min(take, notake)\n        \n        ans = 0\n        for i, num in enumerate(nums):\n            if num == 0: continue\n            v = dp(i, num, 0)\n\n            if v == m+1:\n                return -1\n            ans = max(v, ans)\n\n        return ans","author":"Gabriel Sasu","submissionId":"1575179315"},[]]},{"606":[{"id":"606","fileName":"1575179194.txt","sourceCode":"import java.util.BitSet;\n\npublic class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        BitSet[] dp = new BitSet[n];\n        \n        // Initialize the BitSet array\n        for (int j = 0; j < n; j++) {\n            dp[j] = new BitSet(1001);\n            dp[j].set(0); // Start with 0 being achievable\n        }\n\n        // Check if the array is already all zeros\n        boolean allZero = true;\n        for (int j = 0; j < n; j++) {\n            if (nums[j] != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) return 0;\n\n        // Process each query\n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int v = queries[k][2];\n\n            // Apply the query to the range [l, r]\n            for (int j = l; j <= r; j++) {\n                // Shift the bits to the left by v positions\n                BitSet newBits = new BitSet(1001);\n                for (int pos = dp[j].nextSetBit(0); pos != -1; pos = dp[j].nextSetBit(pos + 1)) {\n                    if (pos + v < 1001) {\n                        newBits.set(pos + v);\n                    }\n                }\n                dp[j].or(newBits); // Combine the new bits with the existing ones\n            }\n\n            // Check if all positions are achieved\n            boolean allAchieved = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j].get(nums[j])) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n            if (allAchieved) return k + 1;\n        }\n\n        return -1;\n    }\n}","author":"kartikchourey2","submissionId":"1575179194"},[]]},{"607":[{"id":"607","fileName":"1575179366.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number}\n */\nvar minZeroArray = function (nums, queries) {\n  if (nums.every((num) => num === 0)) return 0\n\n  function canZero(k) {\n    for (let i = 0; i < nums.length; i++) {\n      const target = nums[i]\n      const values = []\n      for (let j = 0; j < k; j++) {\n        const [l, r, v] = queries[j]\n        if (i >= l && i <= r) {\n          values.push(v)\n        }\n      }\n      const dp = new Array(target + 1).fill(false)\n      dp[0] = true\n      for (const v of values) {\n        for (let s = target; s >= v; s--) {\n          if (dp[s - v]) dp[s] = true\n        }\n      }\n      if (!dp[target]) return false\n    }\n    return true\n  }\n\n  for (let i = 0; i < queries.length; i++) {\n    if (canZero(i + 1)) {\n      return i + 1\n    }\n  }\n  return -1\n}\n","author":"wwwap","submissionId":"1575179366"},[]]},{"608":[{"id":"608","fileName":"1575179670.txt","sourceCode":"class Solution {\npublic:\n#define ll long long int\n#define ull unsigned long long\n#define ld double\n#define vi vector<int>\n#define vll vector<ll>\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define ff first\n#define ss second\n#define pb push_back\n#define all(v) v.begin(),v.end()\n\nint ans;\n\n    void sol(int pos,int val,int id,vector<vi>& q,vector<vi>& dp)\n    {\n        int n = q.size();\n        if(val==0)\n        {\n            if(ans==-1)\n                ans = pos;\n            else\n                ans = min(ans,pos);\n            return;\n        }\n        else if(dp[pos][val]!=-1)\n            return;\n        else\n        {\n            if(pos==n)\n                return;\n            int id1 = q[pos][0];\n            int id2 = q[pos][1];\n            int vv = q[pos][2];\n            if(id>=id1 && id<=id2 && vv<=val)\n            {\n                sol(pos+1,val-vv,id,q,dp); // use the value\n                sol(pos+1,val,id,q,dp); // not use the value\n            }\n            else\n            {\n                sol(pos+1,val,id,q,dp);\n            }\n            dp[pos][val] = 1;\n        }\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n\n        int res=0;\n        for(int i=0;i<nums.size();i++)\n        {\n            ans = -1;\n            vector<vi> dp(q.size()+2, vi (1003,-1));\n            sol(0,nums[i],i, q,dp);\n            if(ans==-1)\n            {\n                res = -1;\n                break;\n            }\n            res = max(ans,res);\n            // cout << \"i \" << i << endl;\n            // cout << \"ans \" << ans << endl << endl;\n        }\n        return(res);\n    }\n};","author":"prabh_","submissionId":"1575179670"},[]]},{"609":[{"id":"609","fileName":"1575179413.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]):\n        min_k = [] # min k for each element\n        \n        for i, num in enumerate(nums):\n            k = 0\n            if num == 0:\n                min_k.append(0)\n                continue\n            \n            possible_sums = {0}\n            for left, right, val in queries:      \n                k += 1\n                if i < left or i > right:\n                    continue\n                \n                new_sums = {s + val for s in possible_sums}\n                possible_sums.update(new_sums)\n                if num in possible_sums:\n                    min_k.append(k)\n                    break\n        \n        if len(min_k) < len(nums):\n            return -1\n        return max(min_k)\n                    \n        ","author":"litely","submissionId":"1575179413"},[]]},{"610":[{"id":"610","fileName":"1575179973.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), qn = queries.size();\n        int mx = *max_element(nums.begin(), nums.end());\n        if(mx == 0) return 0;\n\n        int ans = 0;\n        for(int i=0; i<n; ++i){\n            if(nums[i] == 0) continue;\n            \n            set<int> s;\n            bool found = 0;\n            for(int q=0; q<qn; ++q){\n                int l = queries[q][0], r = queries[q][1], val = queries[q][2];\n                if(i >= l && i <= r){\n                    for(auto it: set<int>(s.begin(), s.end())){\n                        if(it+val <= nums[i])\n                            s.insert(it+val);\n                        if(it+val == nums[i]){\n                            ans = max(ans, q);\n                            found = 1;\n                            break;\n                        }\n                    }\n\n                    if(found) break;\n                    \n                    s.insert(val);\n                    if(val == nums[i]){\n                        ans = max(ans, q);\n                        found = 1;\n                        break;\n                    }\n                }\n            }\n\n            if(!found) return -1;\n        }\n        \n        return ans+1;\n    }\n};","author":"Santosh Swansi","submissionId":"1575179973"},[]]},{"611":[{"id":"611","fileName":"1575179975.txt","sourceCode":"class Solution {\npublic:\n    bool helper(vector<int>& nums, int target, int index, vector<vector<int>>& dp) {\n        if (target == 0) return true;\n        if (index < 0) return false;\n        if (dp[index][target] != -1) return dp[index][target];\n        \n        bool include = (target >= nums[index]) && helper(nums, target - nums[index], index - 1, dp);\n        bool exclude = helper(nums, target, index - 1, dp);\n\n        return dp[index][target] = include || exclude;\n    }\n\n    bool func(vector<int>& nums, vector<vector<int>>& queries, int k) {\n        bool ans = true;\n\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == 0) continue;\n\n            vector<int> arr;\n            for (int j = 0; j < k; j++) {\n                if (i >= queries[j][0] && i <= queries[j][1]) arr.push_back(queries[j][2]);\n            }\n\n            if (arr.empty()) return false;\n\n            int maxTarget = nums[i];  \n            vector<vector<int>> dp(arr.size(), vector<int>(maxTarget + 1, -1));\n\n            ans = ans & helper(arr, maxTarget, arr.size() - 1, dp);\n        }\n\n        return ans;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int s = 0, e = queries.size(), ans = -1;\n\n        while (s <= e) {\n            int m = s + (e - s) / 2;\n            if (func(nums, queries, m)) {\n                ans = m;\n                e = m - 1;\n            } else {\n                s = m + 1;\n            }\n        }\n\n        return ans;\n    }\n};\n","author":"Pratik Priyam","submissionId":"1575179975"},[]]},{"612":[{"id":"612","fileName":"1575180083.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int[] copy = Arrays.copyOf(nums, n);\n        boolean Zero = true;\n        for (int num : copy) {\n            if (num != 0) {\n                Zero = false;\n                break;\n            }\n        }\n        if (Zero) return 0;\n        int low = 1;\n        int high = queries.length;\n        int ans = -1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (canMakeZero(nums, queries, mid)) {\n                ans = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return ans;\n    }\n    public static boolean canMakeZero(int[] nums, int[][] queries, int k) {\n        int n = nums.length;\n        for (int j = 0; j < n; j++) {\n            int tar = nums[j];\n            if (tar == 0) continue;\n            List<Integer> avail = new ArrayList<>();\n            for (int i = 0; i < k; i++) {\n                if (queries[i][0] <= j && j <= queries[i][1]) {\n                    avail.add(queries[i][2]);\n                }\n            }\n            if (!subsetSum(avail, tar)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    public static boolean subsetSum(List<Integer> ll, int target) {\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n        for (int v : ll) {\n            for (int s = target; s >= v; s--) {\n                if (dp[s - v]) {\n                    dp[s] = true;\n                }\n            }\n        }\n        return dp[target];\n        \n    }\n}","author":"Mohammad Ashhar","submissionId":"1575180083"},[]]},{"613":[{"id":"613","fileName":"1575179814.txt","sourceCode":"class Solution {\npublic:\n    bool solve(int ind,vector<int>& arr,int n, int target,vector<vector<int>> &dp){\n        \n        if(target < 0) return false;\n        if(target == 0) return true;\n        if(ind >= n) return false;\n        \n        if(dp[ind][target] != -1) return dp[ind][target];\n        \n        bool take = solve(ind+1,arr,n,target-arr[ind],dp); \n        bool ntake = solve(ind+1,arr,n,target,dp);\n        \n        return dp[ind][target] = take|ntake;\n        \n    }\n    bool check(vector<int> arr,int target){\n        int n = arr.size();\n        vector<vector<int>> dp(n,vector<int>(target+1,-1));\n        return solve(0,arr,n,target,dp);\n    }\n    bool pos(vector<int> nums, vector<vector<int>> qrs,int m){\n        int n = nums.size();\n        bool fl = true;\n        for(int i=0;i<n;i++){\n            if(nums[i] != 0) fl = false;\n        }\n        if(fl) return fl;\n        \n        vector<vector<int>> v(n);\n        for(int i=0;i<m;i++){\n            for(int j = qrs[i][0];j<=qrs[i][1];j++){\n                v[j].push_back(qrs[i][2]);\n            }\n        }\n\n        for(int i=0;i<n;i++){\n            if(!check(v[i],nums[i])) return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& qrs) {\n\n        int l = 0;\n        int r = qrs.size();\n\n        int ans = -1;\n        int m = (l+r)/2;\n        while(l <= r){\n            if( pos(nums,qrs,m) ){\n                ans = m;\n                r = m-1;\n            }\n            else{\n                l = m+1;\n            }\n            m = (l+r)/2;\n        }\n\n        return ans;\n    }\n};","author":"Harshit Chauhan","submissionId":"1575179814"},[]]},{"614":[{"id":"614","fileName":"1575180024.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        \n       int u = 0; \n       int n = queries.length;\n       for(int i=0; i<nums.length; i++) {\n           Integer[][] dp = new Integer[n+1][nums[i]+1];\n           int ans = solve(i, nums[i], 0, queries, dp);\n           if(ans == 2000) return -1;\n           //System.out.println(ans);\n           u = Math.max(u, ans);\n       }\n        \n       return u;\n    }\n    \n    int solve(int index, int rem, int i, int[][] queries, Integer dp[][]) {\n        \n        if(rem == 0) return i;\n        \n        if(i >= queries.length) return 2000;\n        \n        if(dp[i][rem] != null) return dp[i][rem];\n        \n        int ans = 2000;\n        \n        if(index >= queries[i][0] && index <= queries[i][1]) {\n            \n            if(rem >= queries[i][2]) {\n                ans = Math.min(ans,solve(index, rem - queries[i][2], i+1, queries, dp));\n            }\n        }\n        \n        ans = Math.min(ans, solve(index, rem, i+1, queries, dp));\n        \n        return dp[i][rem] = ans;\n    }\n}","author":"manjpatel00","submissionId":"1575180024"},[]]},{"615":[{"id":"615","fileName":"1575179744.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n           int fl=1;\n           for(auto it:nums){if(it!=0){fl=0;}}\n           if(fl==1){return 0;}\n        \n           int n = nums.size();\n           vector<vector<pair<int,int>>>take(n);\n           int q = queries.size();\n           for(int i=0;i<q;i++){\n               int l = queries[i][0],r = queries[i][1],val=queries[i][2];\n               for(int j=l;j<=r;j++){\n                   take[j].push_back({val,i});\n               }\n           }\n\n           int mx=-1;\n           int count=0;\n           for(int i=0;i<n;i++){\n               int num = nums[i];\n               int n1 = take[i].size();\n               vector<vector<int>>dp(n1,vector<int>(10001,0));\n              \n               int fl=0;\n               for(int i1=0;i1<n1;i1++){\n                   for(int sum=0;sum<=1000;sum++){\n                       int val = take[i][i1].first;\n                       int quer = take[i][i1].second;\n                       if(i1==0){\n                           if(sum==0 || sum==val){dp[i1][sum]=1;}\n                       }\n                       else{\n                         int ans = dp[i1-1][sum];\n                         if(val<=sum){ans|=dp[i1-1][sum-val];} \n                         dp[i1][sum]=ans;\n                       }\n                       if(sum==num && dp[i1][sum]==1 && fl==0){\n                           count++;\n                           mx=max(mx,quer); fl=1;\n                       }\n                    }\n                 }\n                }\n                if(mx==-1 || count<n){return -1;}\n                else{return mx+1;}\n\n\n\n\n        \n    }\n};","author":"Tanishq Singh Rathore","submissionId":"1575179744"},[]]},{"616":[{"id":"616","fileName":"1575180207.txt","sourceCode":"#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& elements, vector<vector<int>>& operations) {\n        int size = elements.size();\n        int opsCount = operations.size();\n        vector<vector<int>> opsForIndex(size);  \n        for (int opIdx = 0; opIdx < opsCount; ++opIdx) {\n            int left = operations[opIdx][0];\n            int right = operations[opIdx][1];\n            for (int i = left; i <= right; ++i) {\n                opsForIndex[i].push_back(opIdx);\n            }\n        }\n        vector<int>visited(operations.size(),-1);\n        int maxSteps = 0;\n        for (int i = 0; i < size; ++i) {\n            int targetValue = elements[i];\n            if (targetValue == 0) continue;\n\n            vector<int>& applicableOps = opsForIndex[i];\n            unordered_map<int, int> dpMap;\n            dpMap[0] = -1;\n\n            for (int opIndex : applicableOps) {\n                int addValue = operations[opIndex][2];\n                unordered_map<int, int> tempMap;\n\n                for (auto& entry : dpMap) {\n                    int currentSum = entry.first;\n                    int highestOpIdx = entry.second;\n\n                    int newSum = currentSum + addValue;\n                    if (newSum > targetValue) continue;\n\n                    int newOpIdx = max(highestOpIdx, opIndex);\n                    if (tempMap.find(newSum) == tempMap.end()) {\n                        tempMap[newSum] = newOpIdx;\n                    } else {\n                        if (newOpIdx < tempMap[newSum]) {\n                            tempMap[newSum] = newOpIdx;\n                        }\n                    }\n                }\n\n                \n                for (auto& entry : tempMap) {\n                    int sumKey = entry.first;\n                    int minOpIdx = entry.second;\n                    if (dpMap.find(sumKey) == dpMap.end() || minOpIdx < dpMap[sumKey]) {\n                        dpMap[sumKey] = minOpIdx;\n                    }\n                }\n            }\n            \n            if (dpMap.find(targetValue) == dpMap.end()) {\n                return -1;\n            }\n\n            int requiredSteps = dpMap[targetValue] + 1;\n            if (requiredSteps > maxSteps) {\n                maxSteps = requiredSteps;\n            }\n        }\n\n        return maxSteps;\n    }\n};\n","author":"Prashant Singh","submissionId":"1575180207"},[]]},{"617":[{"id":"617","fileName":"1575180267.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        left = 0\n        right = len(queries)\n        minK = float('inf')\n        while left <= right:\n            mid = (left + right) // 2\n            # -we dont have to decrement at all\n            # -build arr, arr[i] == list of possible decrements \n            # for ith index of nums\n            # -combo them together until we reach exactly\n            # nums[i]\n            arr = []\n            for num in nums:\n                arr.append([])\n            for i in range(mid):\n                l,r,val = queries[i]\n                for i in range(l, r+1):\n                    arr[i].append(val)\n            def dp(total, arrEntry, index, target, cache):\n                if total >= target:\n                    if total == target:\n                        return True\n                    return False\n                if index >= len(arrEntry):\n                    return False\n                if (total, index) in cache:\n                    return cache[(total, index)]\n                # dont take\n                dontTake = dp(total, arrEntry, index+1, target, cache)\n                doTake = dp(total+arrEntry[index], arrEntry, index+1, target, cache)\n                cache[(total, index)] = dontTake or doTake\n                return cache[(total, index)]\n            res = True\n            count = 0\n            for arrEntry in arr:\n                res = res and dp(0, arrEntry, 0, nums[count], {})\n                count += 1\n            if res:\n                minK = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        return minK if minK < float('inf') else -1","author":"pogert","submissionId":"1575180267"},[]]},{"618":[{"id":"618","fileName":"1575180297.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int t,i,j,k,n=a.size(),m=q.size(),ans=-1,l=0,r=m,mn=0;\n        vector<pair<int,int>>b[11];\n        for(i=0;i<m;i++){\n            l=q[i][0];\n            r=q[i][1];\n            k=q[i][2];\n            for(j=l;j<=r;j++)b[j].push_back({k,i});\n        }\n        bool dp[1005];\n        for(i=0;i<n;i++){\n            memset(dp,0,sizeof(dp));\n            dp[0]=1;\n            int op=INT_MAX;\n            if(a[i]==0)op=0;\n            else\n            for(auto [k,ind]:b[i]){\n                for(j=a[i]-k;j>=0;j--)dp[j+k]|=dp[j];\n                if(dp[a[i]]){\n                    op=ind+1;\n                    break;\n                }\n            }\n            if(op==INT_MAX)return -1;\n            mn=max(mn,op);\n        }\n        return mn;\n        // while(l<=r){\n        //     m=(l+r)>>1;\n        //     for(j=0;j<n;j++)b[j]=a[j];\n        //     for(j=0;j<m;j++){\n                \n        //     }\n        // }\n    }\n};","author":"charan_singh","submissionId":"1575180297"},[]]},{"619":[{"id":"619","fileName":"1575180625.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int k = 0;\n        int maxValue = 0;\n        for(int i=0; i<nums.size(); ++i) {\n            int val = nums[i];\n            if(val==0) continue;\n            vector<vector<int>> dp (queries.size()+1, vector<int>(val+1,INT_MAX));\n            dp[0][val] = 0;\n            for(int j=1; j<=queries.size(); ++j) {\n                dp[j] = dp[j-1];\n                int decrement = queries[j-1][2];\n                if(queries[j-1][0]>i || queries[j-1][1]<i) decrement = 0;\n                for(int l=0; l<=val-decrement; ++l) {\n                    dp[j][l] = min(dp[j][l],dp[j-1][l+decrement]);\n                }\n                if(dp[j][0]==0) {\n                    maxValue = max(j,maxValue);\n                    break;\n                } else if(j==queries.size()) {\n                    return -1;\n                }\n            }\n        }\n        return maxValue;\n    }\n};","author":"Vansh Chawla","submissionId":"1575180625"},[]]},{"620":[{"id":"620","fileName":"1575180608.txt","sourceCode":"bool inrange(int l,int m,int r){if(r<l)return 0;return ((l<=m and m<=r));}\nclass Solution \n{\npublic:\n   int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) \n   {\n      int here = 0 ; \n      vector<vector<int>>dp(queries.size() + 1 , vector < int > (1001 , -1)) ; \n      auto f = [ & ](int idx , int cur , auto  & f) -> int{\n         if(cur < 0)return queries.size() + 1 ; \n         if(cur == 0)return idx ; \n         if(idx == queries.size())return queries.size() + 1 ; \n         int  & res = dp[idx][cur] ; \n         if(res != -1)return res ; \n         res = f(idx + 1 , cur , f) ;\n         if(inrange(queries[idx][0] , here , queries[idx][1]))res = min(res , f(idx + 1 , cur - queries[idx][2] , f)) ;  \n         return res ; \n      } ; \n      int ans = -1 ;\n      for(int i = 0 ; i < nums.size() ; i += 1)\n      {\n         here = i ; \n         dp = vector<vector<int>>(queries.size() + 1 , vector < int > (1001 , -1)) ; \n         ans = max(ans , f(0 , nums[i] , f)) ; \n      }\n      if(ans == queries.size() + 1)return -1 ; \n      return ans ; \n   }\n};\n","author":"Ritik Rathor","submissionId":"1575180608"},[]]},{"621":[{"id":"621","fileName":"1575180295.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        // int operations = INT_MAX;\n        int q = queries.size();\n        int n = nums.size();\n        for(int i = 0;i<n;i++){\n            int x = nums[i];\n            if(x){\n                vector<pair<int,int>> arr;\n                arr.push_back({0,0});\n                \n                for(int j = 0;j<q;j++){\n                    if(queries[j][0]<=i && queries[j][1]>=i){\n                        arr.push_back({queries[j][2],j});\n                    };\n                };\n                int s = arr.size();\n                vector<vector<bool>> possible(s,vector<bool>(x+1));\n                possible[0][x] = true;\n                int ans = INT_MAX;\n                for(int k = 1;k<s;k++){\n                    int sub = arr[k].first;\n                    for(int val = x;val>0;val--){\n                        if(possible[k-1][val]){\n                            possible[k][val] = true;\n                            if(val>=sub)\n                            possible[k][val-sub] = true;\n                        };\n                    }\n                    if(possible[k][0]){\n                        ans = arr[k].second+1;\n                        break;\n                    }\n                    //check if 0 was formed\n                };\n                nums[i] = ans;\n                //find the number of operations to make it 0\n            };  \n        };\n        int maxi = 0;\n        for(auto it: nums){\n            maxi = max(it,maxi);\n        };\n        return (maxi == INT_MAX ? -1 : maxi);\n    }\n};","author":"Advaita Soni","submissionId":"1575180295"},[]]},{"622":[{"id":"622","fileName":"1575180636.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)        \n        dp = [set([0]) for _ in range(n)]        \n        zero = all(i == 0 for i in nums)\n        if zero:\n            return 0\n        for i,(a,b,c) in enumerate(queries):\n            for j in range(a,b + 1):\n                new_values = {k + c for k in dp[j]}\n                dp[j].update(new_values)\n                dp[j] = {k for k in dp[j] if k <= 1000}            \n            res = all(nums[j] in dp[j] for j in range(n))\n            if res:\n                return i + 1        \n        return -1","author":"SMS","submissionId":"1575180636"},[]]},{"623":[{"id":"623","fileName":"1575180697.txt","sourceCode":"class Solution {\npublic:\n    bool f(int index,int left_val,int query_idx,vector<vector<int>> &queries,int prefix,vector<vector<vector<int>>> &dp) {\n        // cout<<left_val<<\" \"<<query_idx<<endl;\n        if(query_idx>=prefix) {\n            return (left_val == 0);\n        }\n        auto &x = dp[index][left_val][query_idx];\n        if(x!=-1) {\n            return x;\n        }\n        bool ans = false;\n        // take it \n        if(queries[query_idx][0]<=index&&queries[query_idx][1]>=index&&queries[query_idx][2]<=left_val) {\n            ans|=f(index,left_val-queries[query_idx][2],query_idx+1,queries,prefix,dp);\n        }\n        // leave it\n        ans|=f(index,left_val,query_idx+1,queries,prefix,dp);\n        return x = ans;\n    }\n\n    bool check(vector<int> &nums,vector<vector<int>> &queries,int prefix) {\n        int maxx = *max_element(begin(nums),end(nums));\n        int n = nums.size();\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(maxx+1,vector<int>(queries.size()+1,-1)));\n        for(int i=0;i<n;i++) {\n            if(f(i,nums[i],0,queries,prefix,dp)==false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int i = 1,j = queries.size(),ans = -1;\n        int maxx = *max_element(begin(nums),end(nums));\n        if(maxx==0) {\n            return 0;\n        }\n        while(i<=j) {\n            int mid = (i+j)/2;\n            if(check(nums,queries,mid)) {\n                j=mid-1;\n                ans=mid;\n            } else {\n                i=mid+1;\n            }\n        }\n        return ans;\n    }\n};","author":"Prateek8696","submissionId":"1575180697"},[]]},{"624":[{"id":"624","fileName":"1575180935.txt","sourceCode":"class Solution {\nint min_q(int i,int index,int val,vector<vector<int>>& queries,vector<vector<int>>& dp){\n    if(val==0){return index;}\n    if(index>=queries.size()){return INT_MAX;}\n\n    if(dp[index][val]!=-1){return dp[index][val];}\n\n    int ans=min_q(i,index+1,val,queries,dp);\n    if(i>=queries[index][0] && i<=queries[index][1] && val-queries[index][2]>=0){\n        ans=min(ans,min_q(i,index+1,val-queries[index][2],queries,dp));\n    }\n    return dp[index][val]=ans;\n}\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans=0;\n        for(int i=0;i<nums.size();i++){\n            vector<vector<int>> dp(queries.size(),vector<int>(nums[i]+1,-1));\n            int index=min_q(i,0,nums[i],queries,dp);\n            cout<<nums[i]<<\" \"<<i<<\" \"<<index<<endl;\n            ans=max(ans,index);\n        }\n        if(ans==INT_MAX){return -1;}\n        return ans;\n    }\n};","author":"yashsinghbhadauria05","submissionId":"1575180935"},[]]},{"625":[{"id":"625","fileName":"1575180849.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        Set<Integer>[] m = new HashSet[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            m[i] = new HashSet<>(Set.of(nums[i]));\n        }\n        if (ok(m)) {\n            return 0;\n        }\n        for (int i = 0; i < queries.length; i++) {\n            var q = queries[i];\n            for (int j = q[0]; j <= q[1]; j++) {\n                var s = new HashSet<>(m[j]);\n                for (int l : m[j]) {\n                    s.add(l - q[2]);\n                }\n                m[j] = s;\n            }\n            if (ok(m)) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n\n    private boolean ok(Set<Integer>[] m) {\n        for (int j = 0; j < m.length; j++) {\n            if (!m[j].contains(0)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}","author":"Ali","submissionId":"1575180849"},[]]},{"626":[{"id":"626","fileName":"1575180984.txt","sourceCode":"// Jai shree ram\nclass Solution {\npublic:\n    bool possible(int tg, vector<int> v) \n    {\n        int n = v.size();\n        vector<bool> pv(tg + 1, false), cv(tg + 1);\n        pv[0] = true;\n\n        for (int i = 1; i <= n; i++) \n        {\n            for (int j = 0; j <= tg; j++) \n            {\n                if (j < v[i - 1])\n                {\n                    cv[j] = pv[j];\n                }\n                else\n                {\n                    cv[j] = (pv[j] or pv[j - v[i - 1]]);\n                }\n            }\n            pv = cv;\n        }\n        return pv[tg];\n    }\n\n    bool check(vector<int>& v, vector<vector<int>>& q, int mid)\n    {\n        int n = v.size();\n        int m = q.size();\n\n        unordered_map<int, vector<int>> mp;\n            \n        for(int j = 0; j < mid; j++)\n        {\n            int l = q[j][0];\n            int r = q[j][1];\n            int val = q[j][2];\n    \n            for(int i = l; i <= r; i++)\n            {\n                mp[i].push_back(val);\n            }  \n        }\n\n        for(int i = 0; i < n; i++)\n        {\n            if (v[i] > 0 and mp[i].size() == 0)\n            {\n                return false;\n            }\n            else \n            {\n                if (!possible(v[i], mp[i]))\n                {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n        \n    }\n    int minZeroArray(vector<int>& v, vector<vector<int>>& q) {\n        int n = v.size();\n        int m = q.size();\n\n\n        int ans = -1;\n        int lo = 0, hi = m;\n\n        while(lo <= hi)\n        {\n            int mid = (lo + hi) / 2;\n\n            if (check(v, q, mid))\n            {\n                ans = mid;\n                hi = mid - 1;\n            }\n            else \n            {\n                lo = mid + 1;\n            }    \n        }\n\n        return ans;\n        \n    }\n};","author":"Ajay Bansal","submissionId":"1575180984"},[]]},{"627":[{"id":"627","fileName":"1575180992.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<unordered_set<int>> v(nums.size(),{0});\n        int mn=*min_element(nums.begin(),nums.end());\n        int mx=*max_element(nums.begin(),nums.end());\n        if(mn==mx && mx==0)\n            return 0;\n        for(int i=0;i<queries.size();i++) {\n            int val=queries[i][2];\n            for(int j=queries[i][0];j<=queries[i][1];j++) {\n                if(v[j].find(nums[j])==v[j].end()) {\n                    unordered_set<int> temp=v[j];\n                    for(auto &x:temp) {\n                        if(x+val<=1000)\n                            v[j].insert(x+val);\n                    }\n                }\n            }\n            int count=0;\n            for(int j=0;j<v.size();j++)\n                if(v[j].find(nums[j])!=v[j].end())\n                    count++;\n            if(count==nums.size())\n                return i+1;\n        }\n        return -1;\n    }\n};","author":"Ujjwal Gupta","submissionId":"1575180992"},[]]},{"628":[{"id":"628","fileName":"1575181004.txt","sourceCode":"from collections import defaultdict\n\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        n_q = len(queries)\n        \n        def can_sum(nums: list[int], val: int) -> bool:\n            dp = [False] * (val + 1)\n            dp[0] = True  # 和為 0 可以用空集合得到\n\n            for num in nums:\n                for i in range(\n                    val, num - 1, -1\n                ):  # 必須從後往前更新，避免重複使用同一個元素\n                    dp[i] = dp[i] or dp[i - num]\n\n            return dp[val]\n\n        def is_blue(k):\n            d = defaultdict(list)\n\n            for i in range(k):\n                l, r, val = queries[i]\n                for j in range(l, r + 1):\n                    d[j].append(val)\n\n            for i in range(n):\n                if not can_sum(d[i], nums[i]):\n                    return True\n\n            return False\n\n        l = -1\n        r = n_q + 1\n        while l + 1 != r:\n            m = l + (r - l) // 2\n            if is_blue(m):\n                l = m\n            else:\n                r = m\n\n        return r if r != n_q + 1 else -1\n","author":"drfv123","submissionId":"1575181004"},[]]},{"629":[{"id":"629","fileName":"1575181082.txt","sourceCode":"from functools import lru_cache\nfrom bisect import bisect_left\nfrom typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        \n        def can(x, lst):\n            \"\"\"Check if x can be formed using elements in lst.\"\"\"\n            @lru_cache(None)\n            def helper(i, x):\n                if x == 0: return True\n                if i == len(lst) or x < 0: return False\n                return helper(i + 1, x - lst[i]) or helper(i + 1, x)\n\n            result = helper(0, x)\n            helper.cache_clear()\n            return result\n\n        def bcan(k):\n            \"\"\"Check if nums[0:k] can be formed using given queries.\"\"\"\n            c = [[] for _ in range(len(nums))]\n            for l, r, v in queries[:k]:\n                for i in range(l, r + 1):\n                    c[i].append(v)\n\n            return all(can(nums[i], c[i]) for i in range(len(nums)))\n\n        idx =bisect_left(range(len(queries) + 1), True, key=bcan)\n        return idx if idx<=len(queries) else -1\n","author":"rba123","submissionId":"1575181082"},[]]},{"630":[{"id":"630","fileName":"1575181111.txt","sourceCode":"class Solution {\n\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        std::unordered_set<int> done_pos;\n        std::vector<std::unordered_set<int>> pos_to_sums(nums.size());\n        for (int i = 0; i < nums.size(); ++i) {\n            pos_to_sums[i].insert(0);\n            if (nums[i] == 0) {\n                done_pos.insert(i);\n            }\n        }\n\n        int result = 0;\n        for (const auto& q: queries) {\n            if (done_pos.size() == nums.size()) {\n                break;\n            }\n            result++;\n            int l = q[0];\n            int r = q[1];\n            int delta = q[2];\n            for (int pos = l; pos <= r; ++pos) {\n                std::unordered_set<int> sums = pos_to_sums[pos];\n                for (int sum: sums) {\n                    int candidate = sum + delta;\n                    pos_to_sums[pos].insert(candidate);\n                    if (candidate == nums[pos]) {\n                        done_pos.insert(pos);\n                    }\n                }\n            }\n        }\n        if (done_pos.size() == nums.size()) {\n            return result;\n        }\n        return -1;\n    }\n};","author":"Qimu Z","submissionId":"1575181111"},[]]},{"631":[{"id":"631","fileName":"1575180761.txt","sourceCode":"#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& v, vector<vector<int>>& q) {\n        map<int, vector<int>> mp;\n        int n = v.size();\n        for (int i = 0; i < q.size(); i++) {\n            for (int j = q[i][0]; j <= q[i][1]; j++) {\n                mp[j].push_back(i);\n            }\n        }\n        for(int i=0;i<n;i++){\n            if(mp.find(i)==mp.end() && v[i]!=0)return -1;\n        }\n        \n        auto fn = [&](auto&& self, int i, int sum, vector<int>& vv, vector<vector<int>>& dp, int val) -> int {\n            if (i >= vv.size() || sum>val) return 1e8;\n            if (dp[i][sum] != -1) return dp[i][sum];\n            int newsum = q[vv[i]][2]+sum;\n            if(newsum == val){\n                return dp[i][sum] = vv[i]+1;\n            }\n            return dp[i][sum] = min(self(self, i + 1, sum, vv, dp, val), \n                                    self(self, i + 1, newsum, vv, dp, val));\n        };\n        \n        int ans = 0;\n        for (auto& [x, y] : mp) {\n            if(v[x]==0)continue;\n            vector<vector<int>> dp(y.size() + 1, vector<int>(1001, -1));\n            ans = max(ans, fn(fn, 0, 0, y, dp, v[x]));\n            cout<<ans<<endl;\n            if (ans > 1e7) return -1;\n        }\n        \n        return ans;\n    }\n};\n","author":"Ankush Gaurav","submissionId":"1575180761"},[]]},{"632":[{"id":"632","fileName":"1575181254.txt","sourceCode":"class Solution {\npublic:\n    int tree(int val,vector<pair<int,int>>&dp){\n       if(val==0){\n           return -1;\n       }\n        vector<int>res(val+1,0);\n        for(int i=0;i<dp.size();i++){\n         for(int j=val;j>=0;j--){\n             if(res[j]){\n                 if(j+dp[i].first<=val){\n                     res[j+dp[i].first]=1;\n                 }\n             }\n         }\n            if(dp[i].first<=val){\n                res[dp[i].first]=1;\n            }\n            if(res[val]){\n                return dp[i].second;\n            }\n\n            \n        }\n        return -5;\n\n        \n    }\n    int minZeroArray(vector<int>& nu, vector<vector<int>>& qu) {\n        vector<vector<pair<int,int>>>dp(nu.size());\n        for(int i=0;i<nu.size();i++){\n           for(int j=0;j<qu.size();j++){\n               if(qu[j][0]<=i&&i<=qu[j][1]){\n                   dp[i].push_back({qu[j][2],j});\n               }\n           }\n        }\n      //  vector<int>res(nu.size());\n        int ans=0;\n        for(int i=0;i<nu.size();i++){\n            int uy=tree(nu[i],dp[i]);\n            if(uy==-5){\n                return -1;\n            }\n            ans=max(ans,uy+1);\n        }\n        return ans;\n    }\n};","author":"nitin","submissionId":"1575181254"},[]]},{"633":[{"id":"633","fileName":"1575181215.txt","sourceCode":"#include <vector>\n#include <bitset>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canMakeZero(vector<int>& nums, vector<vector<int>>& queries, int k) {\n        int n = nums.size();\n        vector<bitset<1001>> dp(n);\n        for (int i = 0; i < n; i++) {\n            dp[i].reset();\n            dp[i].set(0);\n        }\n        for (int i = 0; i < k; i++) {\n            int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                dp[j] |= (dp[j] << v);\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp[j].reset(pos);\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (!dp[i].test(nums[i])) return false;\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int low = 0, high = queries.size(), ans = -1;\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (canMakeZero(nums, queries, mid)) {\n                ans = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"Shubhamnegi","submissionId":"1575181215"},[]]},{"634":[{"id":"634","fileName":"1575181740.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\n    public:\n    vector<vector<pair<int, int>>> cover;\n\n\n    bool func(int mid, vector<int>& nums) {\n        int n = nums.size();\n        for (int pos = 0; pos < n; ++pos) {\n            int target = nums[pos];\n            if (target == 0) continue;\n            \n            auto it = lower_bound(cover[pos].begin(), cover[pos].end(), make_pair(mid, 0));\n            vector<int> arr;\n            for (auto iter = cover[pos].begin(); iter != it;iter++) {\n                if (iter->second <= target) {\n                    arr.push_back(iter->second);\n                }\n            }\n\n            vector<int> dp(target + 1, 0);\n            dp[0] = 1;\n\n            for (int d : arr) {\n                for (int j = target; j >= d; --j) {\n                    dp[j] = dp[j] || dp[j - d];  \n                }\n            }\n\n            if (!dp[target]) return false;\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        cover.resize(n);\n\n        for (int i = 0; i < m; ++i) {\n            int l = queries[i][0], r = queries[i][1], dec = queries[i][2];\n            for (int pos = l; pos <= r; ++pos) {\n                cover[pos].emplace_back(i, dec);\n            }\n        }\n        \n        for (int i = 0; i < n; ++i) {\n            sort(cover[i].begin(), cover[i].end());\n        }\n\n        int lo = 0, hi = m + 1;\n        while (lo < hi) {\n            int mid = (lo + hi) / 2;\n            if (func(mid,nums)) {\n                hi = mid;\n            } else {\n                lo = mid + 1;\n            }\n        }\n\n        return (lo <= m) ? lo : -1;\n    }\n};\n\n\n","author":"devanshDev_001","submissionId":"1575181740"},[]]},{"635":[{"id":"635","fileName":"1575181687.txt","sourceCode":"class Solution:\n    def minZeroArray(self, a: List[int], b: List[List[int]]) -> int:\n        m = len(b)\n        def c(k):\n            for i in range(len(a)):\n                s = 1\n                for l,r,v in b[:k]:\n                    if l <= i <= r:\n                        s|=s<<v\n                if not (s>>a[i])&1:\n                    return False\n            return True\n        z = [c(i) for i in range(m+1)]\n        t = bisect.bisect_left(z,True)\n        return t if t < len(z) else -1","author":"aespa fan","submissionId":"1575181687"},[]]},{"636":[{"id":"636","fileName":"1575181749.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& A, vector<vector<int>>& queries) {\n        int ans = -1;\n        int l = 0;\n        int r = queries.size() - 1;\n        int n = A.size();\n        bool allZero = true;\n        for (auto& c : A) {\n            if (c != 0) {\n                allZero = false;\n            }\n        }\n        if (allZero) return 0;\n        \n        auto check = [&](int m) -> bool {\n            vector<vector<int>> pos(n);\n            for (int i = 0; i <= m; i++) {\n                int l = queries[i][0];\n                int r = queries[i][1];\n                int val = queries[i][2];\n                for (int v = l; v <= r; v++) {\n                    pos[v].push_back(val);\n                }\n            }\n            bool ok = true;\n            for (int i = 0; i < n && ok; i++) if (A[i] != 0) {\n                vector<bool> dp(A[i] + 1,false);\n                dp[0] = true;\n                for (auto& c : pos[i]) {\n                    for (int v = A[i]; v >= c; v--) if (dp[v - c]) {\n                        dp[v] = true;\n                    }\n                }\n                ok &= dp[A[i]];\n            }\n            return ok;\n        };\n        while (l <= r) {\n            int m = (l + r) / 2;\n            if (check(m)) {\n                ans = m + 1;\n                r = m - 1;\n            } else {\n                l = m + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"abz-codes","submissionId":"1575181749"},[]]},{"637":[{"id":"637","fileName":"1575181300.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        max_k = 0\n        for i in range(n):\n            required = nums[i]\n            if required == 0:\n                continue  # contributes 0 to max_k\n            q_list = []\n            for pos, (l, r, val) in enumerate(queries):\n                if l <= i <= r:\n                    q_list.append((val, pos))\n            if not q_list:\n                return -1\n            dp = {0: 0}\n            for val, pos in q_list:\n                new_dp = {}\n                for s in dp:\n                    # Option 1: do not take this query\n                    if s not in new_dp or dp[s] < new_dp.get(s, float('inf')):\n                        new_dp[s] = min(new_dp.get(s, float('inf')), dp[s])\n                    # Option 2: take this query\n                    new_s = s + val\n                    new_k = max(dp[s], pos + 1)\n                    if new_s not in new_dp or new_k < new_dp.get(new_s, float('inf')):\n                        new_dp[new_s] = min(new_dp.get(new_s, float('inf')), new_k)\n                dp = new_dp\n            if required not in dp:\n                return -1\n            current_k = dp[required]\n            if current_k > max_k:\n                max_k = current_k\n        return max_k if max_k != 0 or all(num == 0 for num in nums) else 0","author":"sytherash","submissionId":"1575181300"},[]]},{"638":[{"id":"638","fileName":"1575181930.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& elements, vector<vector<int>>& operations) {\n\n    int n=elements.size();\n        vector<int>v;\n        for(auto &p:elements){\n            v.push_back(p);\n        }\n        \n        int size = elements.size(), numOps = operations.size();\n        \n        auto isZeroPossible = [&](int k) -> bool {\n            for (int j = 0; j < size; j++) {\n                bitset<1001> dp;\n                dp[0] = true;\n                \n                for (int i = 0; i < k; i++) {\n                    if (j >= operations[i][0] && j <= operations[i][1]) {\n                        int value = operations[i][2];\n                        for (int s = 1000; s >= value; s--) {\n                            if (dp[s - value]) dp[s] = true;\n                        }\n                    }\n                }\n                \n                if (!dp[elements[j]]) return false;\n            }\n            return true;\n        };\n        unordered_map<int,int>m;\n        for(auto &p:v){\n            m[p]++;\n        }\n        int left = 0, right = numOps;\n        int minOps = -1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (isZeroPossible(mid)) {\n                minOps = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        \n        return minOps;\n    }\n};","author":"ARJUN DAS","submissionId":"1575181930"},[]]},{"639":[{"id":"639","fileName":"1575181932.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        if all(num == 0 for num in nums):\n            return 0\n        cache = [set() for _ in range(n)]\n        for j in range(n):\n            cache[j].add(0)\n\n        for k, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                lst = {x + v for x in cache[j]}\n                cache[j].update(lst)\n                for posi in range(nums[j] + 1, 1001):\n                    if posi in cache[j]:\n                        cache[j].remove(posi)\n\n            if all(any(x == num for x in cache[j]) for j, num in enumerate(nums)):\n                return k + 1\n\n        return -1\n","author":"Ayush","submissionId":"1575181932"},[]]},{"640":[{"id":"640","fileName":"1575181110.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        HARIVEL = (nums, queries)  # Equivalent to the C++ pair\n\n        dp = [set() for _ in range(n)]\n        for j in range(n):\n            dp[j].add(0)\n\n        if all(num == 0 for num in nums):\n            return 0\n\n        for k, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                new_values = {x + v for x in dp[j] if x + v <= 1000}\n                dp[j].update(new_values)\n\n                dp[j] = {x for x in dp[j] if x <= nums[j]}  # Limit values to nums[j]\n\n            if all(nums[j] in dp[j] for j in range(n)):\n                return k + 1\n\n        return -1\n","author":"HARIVEL-GK","submissionId":"1575181110"},[]]},{"641":[{"id":"641","fileName":"1575182318.txt","sourceCode":"class Solution {\npublic:\n    int dp(int count, int n,vector<pair<int,int> >&v,vector<vector<int> >&memo)\n{\n    if(count==0)\n    {\n        if(n==0)\n        {\n            return 0;\n        }\n        return v[n-1].second;\n    }\n    if(n==v.size())\n    {\n        return INT_MAX;\n    }\n    if(memo[count][n]!=-1)\n    {\n        return memo[count][n];\n    }\n    int ans=dp(count,n+1,v,memo);\n    if(v[n].first<=count)\n    {\n        ans=min(ans,dp(count-v[n].first,n+1,v,memo));\n    }\n    return memo[count][n]=ans;\n    \n}\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int count=0;\n        int n=nums.size();\n        for(int i=0;i<n;i++)\n            {\n                if(nums[i]==0)\n                {\n                    count++;\n                }\n            }\n        vector<vector<pair<int,int> > >v(n);\n        for(int i=0;i<q.size();i++)\n            {\n              for(int j=q[i][0];j<=q[i][1];j++)\n                  {\n                       v[j].push_back(make_pair(q[i][2],i+1));\n                  }\n            }\n        int ans=0;\n        for(int i=0;i<n;i++)\n            {\n                vector<vector<int> >memo(nums[i]+1,vector<int>(v[i].size(),-1));\n                ans=max(ans,dp(nums[i],0,v[i],memo));\n                \n            }\n        if(ans==INT_MAX)\n        {\n            ans=-1;\n        }\n        return ans;\n        \n       \n        \n    }\n};","author":"Raj Tiwari","submissionId":"1575182318"},[]]},{"642":[{"id":"642","fileName":"1575182044.txt","sourceCode":"class Solution {\npublic:\n    #define pi pair<int,int>\n    #define fi first\n    #define sd second\n    \n    int dp[1001][1001];\n    \n    int f(vector<pi>& v,int x,int i,int n) {\n        \n        if(x == 0) {\n            return 0;\n        }\n        \n        if(i == n || x<0) {\n            return 1e9;\n        }\n        \n        if(v[i].fi == x) {\n            return v[i].sd;\n        }\n        \n        if(dp[x][i] != -1) {\n            return dp[x][i];\n        }\n        \n        int a = f(v,x,i+1,n);\n        int b = f(v,x - v[i].fi,i+1,n);\n        \n        return dp[x][i] = min(a,b);\n    }\n    \n    int minZeroArray(vector<int>& v, vector<vector<int>>& q) {\n        int n = v.size();\n        vector<vector<pi>> mp(n);\n        int i,qn=q.size(),j;\n        \n        for(i=0;i<qn;i++) {\n            \n            int l = q[i][0];\n            int r = q[i][1];\n            int x = q[i][2];\n            \n            for(j=l;j<=r;j++) {\n                mp[j].push_back({x,i+1});\n            }\n        }\n        int ans = 0;\n        \n        for(i=0;i<n;i++) {\n            memset(dp, -1, sizeof(dp));\n            ans = max(ans, f(mp[i], v[i], 0, mp[i].size()));\n        }\n        return ans == 1e9 ? -1 : ans;\n    }\n};","author":"Yuu","submissionId":"1575182044"},[]]},{"643":[{"id":"643","fileName":"1575182084.txt","sourceCode":"class Solution {\npublic:\n    vector<vector<int>>dp;\n    int rec(int val, int idx, int ii, vector<vector<int>>&qq){\n        // cout<<ii<<\" \"<<idx<<\" \"<<val<<endl;\n        if(val==0) return idx;\n        if(val<0 || idx==qq.size()) return 1e9;\n\n        if(dp[val][idx]!=-1) return dp[val][idx];\n\n        int ans = rec(val, idx+1, ii, qq);\n        int l=qq[idx][0],r=qq[idx][1], v = qq[idx][2];\n\n        if(ii>=l && ii<=r)\n        ans = min(ans, rec(val-v,idx+1,ii,qq));\n\n        return dp[val][idx] = ans;\n\n        return 0;\n    }\n\n    int minZeroArray(vector<int>& arr, vector<vector<int>>& qq) {\n        \n        int ans = -1e9;\n        for(int i=0;i<arr.size();i++){\n            dp.clear();dp.resize(arr[i]+1, vector<int>(qq.size(),-1));\n            // cout<<arr[i]<<\" \"<<rec(arr[i],0,i,qq)<<endl;\n            ans = max(ans, rec(arr[i],0,i,qq));\n        }\n\n        if(ans==-1e9 || ans==1e9) return -1;\n        return ans;\n    }\n};","author":"soundboard","submissionId":"1575182084"},[]]},{"644":[{"id":"644","fileName":"1575182421.txt","sourceCode":"class Solution {\npublic:\n    int dp[1001][1001];\n    int f(int i,int val,vector<int>&comb){\n        if(val == 0) return 1;\n        if(i == comb.size()) return 0;\n        if(dp[i][val] != -1) return dp[i][val];\n        bool ans = false;\n        if(comb[i] <= val) ans |= f(i + 1,val - comb[i],comb);\n        ans |= f(i + 1,val,comb);\n        return dp[i][val] = ans;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>&queries) {\n        int low = 0,high = queries.size(),ans = -1;\n        int n = nums.size();\n\n        auto ok = [&](int mid)->bool{\n            vector<vector<int>>comb(n);\n            for(int i = 0;i < mid; i++){\n                int l = queries[i][0],r = queries[i][1],val = queries[i][2];\n                while(l <= r){\n                    comb[l].push_back(val);\n                    l++;\n                }\n            }\n            // what i have 10 -> vals, total 1e3\n            // check whether it is possible to make with this combinations\n            for(int i = 0;i < n; i++){\n                for(int j = 0 ;j < comb[i].size(); j++){\n                    for(int k = 0; k < nums[i] + 1; k++){\n                        dp[j][k] = -1;\n                    }\n                }\n                if(!f(0,nums[i],comb[i])){\n                     return false;\n                }\n            }\n            comb.clear();\n            return true;\n        };\n        while(low <= high){\n            int mid = (low + high)/2;\n            if(ok(mid)){\n                high = mid - 1;\n                ans = mid;\n            }else{\n                low = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"sahil_726","submissionId":"1575182421"},[]]},{"645":[{"id":"645","fileName":"1575182397.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] query) {\n        int temp;\n        int ans=0;\n        int max=0;\n        for(int e:nums){\n            max=Math.max(max,e);\n        }\n        dp=new int[max+1][query.length][11];\n        for(int d[][]:dp){\n            for(int d1[]:d){\n                Arrays.fill(d1,-1);\n            }\n        }\n        for(int i=0;i<nums.length;i++){\n            temp=helper(query,nums[i],0,i);\n            if(temp==Integer.MAX_VALUE)\n                return -1;\n            // System.out.println(\"i=\"+i+\" nm=\"+nums[i]+\" temp=\"+temp);\n            ans=Math.max(ans,temp);\n            // reset(dp);\n        }\n        return ans;\n    }\n    int dp[][][];\n    public int helper(int query[][],int targ,int idx,int numidx){\n        if(targ==0)\n        return idx;\n\n        if(idx==query.length)\n        return Integer.MAX_VALUE;\n\n        if(dp[targ][idx][numidx]!=-1)\n        {\n            // System.out.println(\"backtrack\");\n            return dp[targ][idx][numidx];\n        }\n        \n        int ans=Integer.MAX_VALUE;\n        if(query[idx][0]<=numidx&&numidx<=query[idx][1]&&targ>=query[idx][2]){\n            ans=Math.min(ans,helper(query,targ-query[idx][2],idx+1,numidx));\n        }\n        ans=Math.min(ans,helper(query,targ-0,idx+1,numidx));    \n\n        dp[targ][idx][numidx]=ans;\n        \n        return ans;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n","author":"hacker","submissionId":"1575182397"},[]]},{"646":[{"id":"646","fileName":"1575181330.txt","sourceCode":"class Solution {\n    bool check_poss(vector<int>& vals, int total){\n        \n        vector<bool> poss(total+1, false);\n            // cout<< total<<\" -!- \"<<vals.size()<<endl;\n            // for(int it=0;it<=total;it++) cout<<it<<\" \"<<poss[it]<<endl;\n        poss[0] = true;\n        for(const auto &val:vals){\n            for(int it=total-val;it>=0;it--){\n                if(poss[it]) {\n                    poss[it+val] =true;\n                }\n            }\n            // cout<< total<<\" - \"<<val<<endl;\n            // for(int it=0;it<=total-val;it++) cout<<it<<\" \"<<poss[it]<<endl;\n        }\n            // for(int it=0;it<=total;it++) cout<<it<<\" ** \"<<poss[it]<<endl;\n        return poss[total];\n    }\n\n     bool check_with_k_queries(vector<int>& nums, vector<vector<int>>& queries, int k){\n         vector<vector<int>> vals(nums.size());\n         for(int it=0;it<k;it++){\n             for(int it2=queries[it][0];it2<=queries[it][1];it2++){\n                 vals[it2].push_back(queries[it][2]);\n             }\n         }\n         for(int it=0;it<nums.size();it++){\n             // cout<<k<<\" !! \"<<nums[it]<<endl;\n             // for(const auto &n:vals[it]) cout<<n<<\" \";\n             // cout<<endl;\n             if(!check_poss(vals[it], nums[it])) return false;\n         }\n         // cout<<k<<endl;\n         return true;\n     }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int left=0,right=queries.size()+1,mid;\n        while(left<right){\n            mid = (left+right)/2;\n            if(check_with_k_queries(nums, queries, mid)) right = mid;\n            else left = mid+1;\n        }\n        return (left==queries.size()+1)?-1:left ;\n    }\n};","author":"peak_slayer","submissionId":"1575181330"},[]]},{"647":[{"id":"647","fileName":"1575182698.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        // foreach indices i in [0, n]                        O(n)\n        //    for k in filtered-queries                       O(q)\n        //        filter queries involve i                    \n        //        do combine or not?                          O(v)\n        //        check if nums[i] in dynamic set\n\n        const int m = queries.size();\n        const int n = nums.size();\n        unordered_set<int> curr, next;\n        int l, r, v;\n        int i, k;\n        int ans = 0;\n\n        for (i = 0; i < n; ++i) {\n            if (nums[i] == 0) {\n                continue;\n            }\n\n            curr.clear(); curr.insert(0);\n            next.clear();\n\n            for (k = 0; k < m; ++k) {\n                l = queries[k][0];\n                r = queries[k][1];\n                v = queries[k][2];\n\n                if (i < l || i > r)\n                    continue;\n\n                for (const auto e: curr) {\n                    next.insert(e);\n                    next.insert(e + v);\n                }\n\n                swap(curr, next);\n                if (curr.count(nums[i])) {\n                    break;\n                }\n            } // k\n\n            ans = max(ans, k + 1);\n            if (k == m)\n                return -1;\n        }\n\n        return ans;\n    }\n};","author":"Edward Lee","submissionId":"1575182698"},[]]},{"648":[{"id":"648","fileName":"1575182505.txt","sourceCode":"class Solution {\npublic:\n\nbool canFormX(vector<int>& a, int x) {\n    vector<int> dp(x + 1, false);\n    dp[0] = true;\n\n    for (int num : a) {\n        for (int j = x; j >= num; j--) {\n            dp[j] |= dp[j - num];\n        }\n    }\n\n    return dp[x];\n}\n\nint minStepsToX(vector<int>& a, int x) {\n    unordered_set<int> visited;\n    queue<pair<int, int>> q;  // (current state, steps)\n    q.push({0, 0});\n    visited.insert(0);\n\n    while (!q.empty()) {\n        auto [cur, steps] = q.front();\n        q.pop();\n        if (cur == x) return steps;\n\n        for (int num : a) {\n            int newState = cur + num;\n            if (newState <= x && !visited.count(newState)) {\n                visited.insert(newState);\n                q.push({newState, steps + 1});\n            }\n        }\n    }\n    return -1;  // If not possible\n}\n\nbool check(int k,vector<int>&a,vector<vector<int>>&queries){\n    int n=a.size(),q=queries.size();\n    vector<vector<int>> setq(queries.begin(),queries.begin()+k);\n    vector<vector<int>> mp(n);\n    // sort(setq.begin(),setq.end(),comp);\n    for(int i=0;i<k;i++){\n        int l=setq[i][0],r=setq[i][1],val=setq[i][2];\n        for(int j=l;j<=r;j++){\n            mp[j].push_back(val);\n        }\n    }\n    for(int i=0;i<n;i++){\n        if(a[i]==0) continue;\n        else{\n            bool ch=canFormX(mp[i],a[i]);\n            if(!ch){\n                return false;\n            }\n            \n        }\n    }\n    return true;\n}\n\n\nint minZeroArray(vector<int>& a, vector<vector<int>>& queries) {\n    int n=a.size(),q=queries.size(),ans=-1;\n    int lo=0,hi=q;\n    while(lo<=hi){\n        int mid=(lo+hi)/2;\n        if(check(mid,a,queries)){\n            hi=mid-1;\n            ans=mid;\n        }\n        else{\n            lo=mid+1;\n        }\n    }\n    return ans;\n}\n};","author":"Meet Modi","submissionId":"1575182505"},[]]},{"649":[{"id":"649","fileName":"1575182442.txt","sourceCode":"class Solution {\npublic int minZeroArray(int[] nums, int[][] queries) {\n    int n = nums.length;\n    boolean allZero = true;\n    for (int x : nums) {\n        if (x != 0) {\n            allZero = false;\n        }\n    }\n    if (allZero) return 0;\n\n    int Q = queries.length;\n    boolean[][] possible = new boolean[n][];\n    for (int i = 0; i < n; i++) {\n        possible[i] = new boolean[nums[i] + 1];\n        possible[i][0] = true;\n    }\n\n    for (int j = 0; j < Q; j++) {\n        int l = queries[j][0];\n        int r = queries[j][1];\n        int val = queries[j][2];\n\n        for (int i = l; i <= r; i++) {\n            if (nums[i] >= val) {\n                for (int s = nums[i]; s >= val; s--) {\n                    if (possible[i][s - val]) {\n                        possible[i][s] = true;\n                    }\n                }\n            }\n        }\n        boolean canMakeAll = true;\n        for (int i = 0; i < n; i++) {\n            if (!possible[i][nums[i]]) {\n                canMakeAll = false;\n                break;\n            }\n        }\n        if (canMakeAll) {\n            return j + 1;\n        }\n    }\n    return -1;\n}\n\n}","author":"Neighbor1","submissionId":"1575182442"},[]]},{"650":[{"id":"650","fileName":"1575182661.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        unordered_map<int,set<int>>indexToHit;\n        vector<bool> resolved(nums.size(), false);\n        for(int i = 0; i < nums.size(); i++){\n            indexToHit[i].insert(nums[i]);\n            if(nums[i]==0){\n                resolved[i] = true;\n            }\n        }\n\n        bool alrSolved = true;\n        for(bool s : resolved){\n            alrSolved = alrSolved && s;\n        }\n        if(alrSolved){\n            return 0;\n        }\n\n        for(int i = 0; i < queries.size(); i++){\n            vector<int> cur = queries[i];\n            int val = cur[2];\n            bool solved = true;\n            for(int index = cur[0]; index <= cur[1]; index++){\n                if(!resolved[index]){\n                    set<int> curTargets = indexToHit[index];\n                    for(int target : curTargets){\n                        if(target == val){\n                            resolved[index] = true;\n                        }\n                    }\n                    if(!resolved[index]){\n                        set<int> newTargets;\n                        for(int i : curTargets){\n                            newTargets.insert(i);\n                            if(i-val > 0){\n                                newTargets.insert(i-val);\n                            }\n                        }\n                        indexToHit[index] = newTargets;\n                    }\n                }\n            }\n            for(bool s : resolved){\n                solved = solved && s;\n            }\n            if(solved){\n                return i+1;\n            }\n        } \n\n        return -1;\n    }\n};","author":"ALWHleetcode","submissionId":"1575182661"},[]]},{"651":[{"id":"651","fileName":"1575182762.txt","sourceCode":"\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        best_k = -1\n        for ind in range(len(nums)):\n            num = nums[ind]\n            if num == 0:\n                best_k = max(0, best_k)\n                continue\n            contain = [False] * (num + 1)\n            contain[0] = True\n            for k in range(len(queries)):\n                l, r, val = queries[k]\n                if l <= ind <= r:\n                    for i in range(num - val, -1, -1):\n                        if not contain[i]: continue\n                        if contain[i]:\n                            contain[i + val] = True\n                if contain[-1]:\n                    best_k = max(best_k, k + 1)\n                    break\n            if not contain[-1]:\n                return -1\n        return best_k","author":"N Venkat Abhilash","submissionId":"1575182762"},[]]},{"652":[{"id":"652","fileName":"1575182968.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n\n        mp = defaultdict(list)\n\n        for j in range(len(queries)):\n            s,e,val = queries[j]\n            for i in range(s,e+1):\n                mp[i].append([val,j+1])\n\n        res = 0\n        for i in range(len(nums)):\n            if nums[i]!=0 and i not in mp:\n                return -1\n        for k in mp.keys():\n            arr = mp[k]\n            s = set()\n            # print(nums[k])\n            # print(arr)\n            s.add(0)\n            if nums[k]==0:\n               continue\n            else:\n                for val,cnt in arr:\n                    tempset = set()\n                    for values in s:\n                        tempset.add(val+values)\n                    s = s.union(tempset)\n                    # print(s)\n                    if nums[k] in s:\n                        res = max(res,cnt)\n                        break\n                if nums[k] not in s:\n                    return -1\n        return res\n","author":"user3996te","submissionId":"1575182968"},[]]},{"653":[{"id":"653","fileName":"1575182849.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        vector<bool> bZero(n, false);\n        int cntZero = 0;\n        vector<set<int>> vecs(n);\n        for(int i = 0; i < n; i++){\n            if(nums[i] == 0){\n                bZero[i] = true;\n                cntZero++;\n                continue;\n            }\n            vecs[i].insert(nums[i]);\n        }\n        if(cntZero == n)\n            return 0;\n        for(int k = 0; k < q; k++){\n            int left = queries[k][0];\n            int right = queries[k][1];\n            int val = queries[k][2];\n            for(int i = left; i <= right; i++){\n                if(bZero[i])\n                    continue;\n                for(auto& v : vecs[i]){\n                    if(v == val){\n                        bZero[i] = true;\n                        cntZero++;\n                        break;\n                    }\n                    if(v - val > 0)\n                        vecs[i].insert(v - val);\n                }\n            }\n            if(cntZero == n)\n                return k + 1;\n        }\n        return -1;\n    }\n};","author":"PeterChenX","submissionId":"1575182849"},[]]},{"654":[{"id":"654","fileName":"1575182972.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n\n        ans = -1\n        # row represent index (MAX 10)\n        # col represent querose (MAX 1000)\n        # grid[i][j] is does ith index is in range of queries[j]\n        grid = [[0]*m for i in range(n)]\n\n        for i in range(n):\n            for j in range(m):\n                l, r, v = queries[j]\n                if l<=i<=r:\n                    grid[i][j] = v\n\n        # for i in grid:\n        #     print(i)\n\n        INT_MAX = 1000000000000\n        for row in range(n):\n            # for each index find minimum queries from start to make it zero\n\n            @cache\n            def dp(i, curr):\n                if curr == 0:\n                    return i\n\n                if curr < 0:\n                    return INT_MAX\n\n                if i >= m:\n                    return INT_MAX\n\n                return min(dp(i+1, curr), dp(i+1, curr-grid[row][i]))\n\n            temp = dp(0, nums[row])\n            # print(temp)\n            ans = max(ans, temp)\n            \n        return ans if ans != INT_MAX else -1","author":"Rudra Narola","submissionId":"1575182972"},[]]},{"655":[{"id":"655","fileName":"1575183086.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def poss(mid):\n            for i in range(len(nums)):\n                bit=1\n                for l,r,v in queries[:mid]:\n                    if l<=i<=r:\n                        bit|=bit<<v\n                if not bit&(1<<nums[i]):\n                    return False\n            return True\n        l=0\n        r=len(queries)\n        ans=False\n        while l<=r:\n            mid=l+(r-l)//2\n            if poss(mid):\n                ans=True\n                r=mid-1\n            else:\n                l=mid+1\n        return l if ans else -1","author":"Bay Harbour Butcher","submissionId":"1575183086"},[]]},{"656":[{"id":"656","fileName":"1575183352.txt","sourceCode":"class Solution(object):\n    def subtract(self, s, val):\n        if val in s:\n            return True\n        t = []\n        for i in s:\n            d = i - val\n            if d > 0 and d not in s:\n                t.append(d)\n        for i in t:\n            s.add(i)\n        return False\n                \n        \n    def minZeroArray(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        sets = []\n        res = 0\n        left = n\n        for i in nums:\n            if i == 0:\n                left -= 1\n                sets.append([None, True])\n            else:\n                s = set()\n                s.add(i)\n                sets.append([s, False])\n        if left == 0:\n            return res\n        \n        for l, r, val in queries:\n            res += 1\n            for i in range(l, r+1):\n                if not sets[i][1]:\n                    sets[i][1] = self.subtract(sets[i][0], val)\n                    left -= sets[i][1]\n            if left == 0:\n                return res\n        return -1","author":"brandonleo","submissionId":"1575183352"},[]]},{"657":[{"id":"657","fileName":"1575183520.txt","sourceCode":"class Solution {\n    List<Integer> list;\n    int end;\n    Boolean[][] dp;\n    public int minZeroArray(int[] nums, int[][] queries) {\n        List<List<Integer>> index2List = new ArrayList<>();\n        boolean allZero = true;\n        for (int i = 0; i < nums.length; i++) {\n            List<Integer> l = new ArrayList<>();\n            for (int[] q : queries) {\n                if (q[0] <= i && q[1] >= i) {\n                    l.add(q[2]);\n                } else {\n                    l.add(0);\n                }\n            }        \n            index2List.add(l);\n            if (nums[i] != 0) {\n                allZero = false;\n            }\n        }\n        if (allZero) {\n            return 0;\n        }\n        \n        int left = 0;\n        int right = queries.length - 1;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            end = mid;\n            boolean valid = true;\n            for (int i = 0; i < nums.length; i++) {\n                list = index2List.get(i);\n                dp = new Boolean[nums[i] + 1][end + 1];\n                if (!dfs(nums[i], 0)) {\n                    valid = false;\n                    break;\n                }\n            }\n            if (valid) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        \n        boolean valid = true;\n        end = left;\n        for (int i = 0; i < nums.length; i++) {\n            dp = new Boolean[nums[i] + 1][end + 1];\n            list = index2List.get(i);\n            if (!dfs(nums[i], 0)) {\n                valid = false;\n                break;\n            }\n        }\n        if (valid) {\n            return left + 1;\n        }\n        return -1;\n    }\n    \n    private boolean dfs(int sum, int index) {\n        if (sum == 0) {\n            return true;\n        }\n        if (sum < 0) {\n            return false;\n        }\n        if (index > end) {\n            return false;\n        }\n        if (dp[sum][index] != null) {\n            return dp[sum][index];\n        }\n        boolean res = dfs(sum, index + 1) || dfs(sum - list.get(index), index + 1);\n        return dp[sum][index] = res;\n    }\n}","author":"googlehsiehhh","submissionId":"1575183520"},[]]},{"658":[{"id":"658","fileName":"1575183379.txt","sourceCode":"class Solution {\npublic:\n    bool checker(int A, const vector<int> & nums){\n        vector<bool>dp(A+1, false);\n        dp[0]=true;\n        for(int num:nums){\n            if(num>A){continue;}\n            for(int j=A;j>=num;--j){\n                dp[j]=dp[j] || dp[j-num];\n            }\n        }return dp[A];\n    }\n\n    bool solver(vector<int>& nums, vector<vector<int>>& q, int mid){\n        bool final=true;\n        \n        for(int i=0;i<nums.size();i++){\n            //filter query values for this index\n            vector<int> qur;\n            for(int j=0;j<=mid;j++){\n                vector<int> qi=q[j];\n                if(qi[0]<=i && qi[1]>=i){qur.push_back(qi[2]);}\n            }\n            if(checker(nums[i], qur)){\n                continue;\n            }else{\n                return false;\n            }\n        }return true;\n    }\n\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        if(q.empty()){return -1;}\n        //check all 0\n        bool temp_zero=true;\n        for(auto k:nums){\n            if(k!=0){\n                temp_zero=false;\n            }\n        }if(temp_zero==true){return 0;}\n        \n        int i=0, j=q.size()-1;\n        int ans=INT_MAX;\n        while(i<=j){\n            int mid=(i+j)/2;\n            if(solver(nums, q, mid)){\n                ans=min(ans, mid);\n                j=mid-1;\n            }else{\n                i=mid+1;\n            }\n        }\n        if(ans==INT_MAX){return -1;}\n        return ans+1;\n    }\n};","author":"Shashvat Singhal","submissionId":"1575183379"},[]]},{"659":[{"id":"659","fileName":"1575183574.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        res = 0\n        for i in range(len(nums)):\n            if nums[i] == 0: continue\n            S = set()\n            S.add(nums[i])\n            for j in range(1, len(queries)+1):\n                if not queries[j-1][0] <= i <= queries[j-1][1]:\n                    continue\n                T = set()\n                for n in S:\n                    dif = n - queries[j-1][2]\n                    if dif > 0:\n                        T.add(dif)\n                    elif dif == 0:\n                        res = max(res, j)\n                        break\n                else:\n                    S |= T\n                    continue\n                break\n            else:\n                return -1\n        return res","author":"domick","submissionId":"1575183574"},[]]},{"660":[{"id":"660","fileName":"1575183638.txt","sourceCode":"public class Solution {\n    public int MinZeroArray(int[] nums, int[][] queries) \n    {\n        int Q = queries.Length;\n        int N = nums.Length;\n        int low = 0, high = Q + 1; \n        \n        while (low < high)\n        {\n            int mid = low + (high - low) / 2;\n            if (CanReduce(nums, queries, mid)) high = mid;\n            else low = mid + 1;\n        }\n        \n        return low <= Q ? low : -1;\n    }\n\n    private bool CanReduce(int[] nums, int[][] queries, int k)\n        {\n            int N = nums.Length;\n            // all query values that change index\n            List<int>[] change = new List<int>[N];\n            for (int j = 0; j < N; j++)\n            {\n                change[j] = new List<int>();\n            }\n            // first k queries\n            for (int i = 0; i < k; i++)\n            {\n                int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n                for (int j = l; j <= r; j++)\n                {\n                    change[j].Add(val);\n                }\n            }\n            // can we form nums[j] from the queries \n            for (int j = 0; j < N; j++)\n            {\n                if (!DPSubsetSum(change[j], nums[j]))\n                    return false;\n            }\n            return true;\n        }\n\n    private bool DPSubsetSum(List<int> vals, int target)\n        {\n            if (target == 0) return true; // luck\n\n            // if the sum of all available values is less than target\n            int sum = 0;\n            foreach (int v in vals)\n                sum += v;\n            if (sum < target) return false;\n\n            // DP is true if sum s can be formed\n            bool[] dp = new bool[target + 1];\n            dp[0] = true;\n            foreach (int v in vals)\n            {\n                for (int s = target; s >= v; s--)\n                {\n                    if (dp[s - v])\n                        dp[s] = true;\n                }\n            }\n            return dp[target];\n        }\n}","author":"Irine","submissionId":"1575183638"},[]]},{"661":[{"id":"661","fileName":"1575182943.txt","sourceCode":"using ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\n#define all(x) begin(x), end(x)\n#define F first\n#define S second\n#define pb push_back\n\ntemplate<class T> inline T& ckmin(T& a, const T& b) { if(b < a) a = b; return a; }\ntemplate<class T> inline T& ckmax(T& a, const T& b) { if(a < b) a = b; return a; }\n\nnamespace IO {\n    template<typename... Args> void rd(Args&... args) {\n        ((cin >> args), ...); }\n\n    template<typename... Args> void print(Args... args) {\n        ((cout << args << \" \"), ...); }\n}\n\nusing namespace IO;\n\nclass SegmentTree {\nprivate:\n    int n;\n    vector<ll> tree, lazy;\n\n    void push(int node, int l, int r) {\n        if (lazy[node] != 0) {\n            tree[node] += lazy[node];\n            if (l != r) {\n                lazy[node * 2]     += lazy[node];\n                lazy[node * 2 + 1] += lazy[node];\n            }\n            lazy[node] = 0;\n        }\n    }\n\n    void range_add(int node, int l, int r, int ql, int qr, int val) {\n        push(node, l, r);\n        if (qr < l || r < ql) {\n            return;\n        }\n        if (ql <= l && r <= qr) {\n            lazy[node] += val;\n            push(node, l, r);\n            return;\n        }\n        int mid = (l + r) >> 1;\n        range_add(node * 2, l, mid, ql, qr, val);\n        range_add(node * 2 + 1, mid + 1, r, ql, qr, val);\n        tree[node] = max(tree[node * 2], tree[node * 2 + 1]);\n    }\n\n    ll range_max(int node, int l, int r, int ql, int qr) {\n        push(node, l, r);\n        if (qr < l || r < ql) {\n            return numeric_limits<int>::lowest();\n        }\n        if (ql <= l && r <= qr) {\n            return tree[node];\n        }\n        int mid = (l + r) >> 1;\n        return max(range_max(node * 2, l, mid, ql, qr), range_max(node * 2 + 1, mid + 1, r, ql, qr));\n    }\n    \n    ll range_min(int node, int l, int r, int ql, int qr) {\n        push(node, l, r);\n        if (qr < l || r < ql) {\n            return (ll) 1e18;\n        }\n        if (ql <= l && r <= qr) {\n            return tree[node];\n        }\n        int mid = (l + r) >> 1;\n        return min(range_min(node * 2, l, mid, ql, qr), range_min(node * 2 + 1, mid + 1, r, ql, qr));\n    }\n\n    void build(int node, int l, int r, const vector<int>& data) {\n        if (l == r) {\n            tree[node] = data[l];\n            return;\n        }\n        int mid = (l + r) >> 1;\n        build(node * 2, l, mid, data);\n        build(node * 2 + 1, mid + 1, r, data);\n        tree[node] = max(tree[node * 2], tree[node * 2 + 1]);\n    }\n\npublic:\n\n    SegmentTree(const vector<int>& data) {\n        n = (int) data.size();\n        tree.resize(4 * n);\n        lazy.assign(4 * n, 0);\n        build(1, 0, n - 1, data);\n    }\n\n    void range_add(int l, int r, int val) {\n        range_add(1, 0, n - 1, l, r, val);\n    }\n\n    ll range_max(int l, int r) {\n        return range_max(1, 0, n - 1, l, r);\n    }\n    \n    ll range_min(int l, int r) {\n        return range_min(1, 0, n - 1, l, r);\n    }\n};\n\nclass Solution {\npublic:\n    int dp[1005][11];\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size();\n        memset(dp, 0, sizeof dp);\n        for (int i = 0; i < n; i++) {\n            dp[0][i] = 1;\n        }\n        \n        int f = 1;\n        for (int i = 0; i < n && f; i++) {\n            if (nums[i] != 0) {\n                f = false;\n            }\n        }\n        \n        if (f) {\n            return 0;\n        }\n        \n        for (int i = 0; i < q; i++) {\n            int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n            \n            for (int j = l; j < r + 1; j++) {\n                for (int s = nums[j]; s >= v; s--) {\n                    if (!dp[s][j] && dp[s - v][j]) dp[s][j] = 1;\n                }\n            }\n            \n            bool out = 1;\n            for (int ans = 0; ans < n && out; ans++) {\n                if (dp[nums[ans]][ans] == 0) {\n                    out = 0;\n                }\n            }\n            \n            if (out) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"_chiikawa","submissionId":"1575182943"},[]]},{"662":[{"id":"662","fileName":"1575183827.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        \n        boolean isZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                isZero = false;\n                break;\n            }\n        }\n        if (isZero) return 0;\n        \n        boolean[][] dp = new boolean[n][];\n        for (int i = 0; i < n; i++) {\n            dp[i] = new boolean[nums[i] + 1];\n            dp[i][0] = true;\n        }\n        \n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int val = queries[k][2];\n            for (int i = l; i <= r && i < n; i++) {\n                for (int s = nums[i] - val; s >= 0; s--) {\n                    if (dp[i][s]) {\n                        dp[i][s + val] = true;\n                    }\n                }\n            }\n            isZero = true;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i][nums[i]]) {\n                    isZero = false;\n                    break;\n                }\n            }\n            if (isZero) return k + 1;\n        }\n        \n        return -1;\n    }\n}","author":"krobzh","submissionId":"1575183827"},[]]},{"663":[{"id":"663","fileName":"1575183866.txt","sourceCode":"class Solution {\npublic:\n    vector<vector<int>> q;\n    vector<int> arr;\n\n    int subsetSum(vector<int> coin , int target){\n        vector<vector<int>> dp(11 , vector<int>(target + 1));\n        for(int i = 0 ; i < 11 ; i++)dp[i][0] = true;\n        \n\n        for(int i = 1 ; i <= 10 ; i++){\n            for(int j = 1 ; j<= target ; j++){\n                // if(j < coin[i]){\n                //     dp[i][j] = dp[i-1][j];\n                // }\n                // else{\n                //     dp[i][j] = dp[i-1][j] || dp[i-1][j - coin[i]];\n                // }\n                dp[i][j] = dp[i-1][j];\n                for(int k = 1 ; k <= coin[i] ; k++){\n                    if(j >= k * i){\n                        dp[i][j] = dp[i-1][j] || dp[i-1][j- k * i];\n                        if(dp[i][j] == true)break;\n                    }\n                    else{\n                        break;\n                    }\n                }\n            }\n        }\n        \n        return dp[10][target];\n    }\n\n    int check(int k){\n        int n = arr.size();\n        vector<vector<int>> State( n , vector<int>(11));\n        for(int i = 0 ; i < k ; i++){\n            int l = q[i][0];\n            int r = q[i][1];\n            int val = q[i][2];\n            for(int j = l ; j <= r ; j++){\n                State[j][val]++;\n            }\n        }\n        // for(int i = 0 ; i < n ; i++){\n        //     for(int j = 0 ; j < 11 ;j++){\n        //         cout << State[i][j] << ' ';\n        //     }\n        //     cout << 'n';\n        // }\n        //cout << 'n';\n        for(int i = 0 ; i < n ; i++){\n            // cout << subsetSum(State[i] , arr[i]) << 'n';\n            // for(auto& a : State[i])cout << a << ' ';\n            // cout << 'n';\n            // cout << arr[i] << 'n';\n            if(subsetSum(State[i] , arr[i]) == 0)return false;\n            \n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        arr = nums;\n        q = queries;\n\n        int lo = 0 , hi = queries.size();\n        int ans = -1;\n        while(lo <= hi){\n            int mid = lo + (hi - lo)/2;\n            if(check(mid)){\n                hi = mid-1;\n                ans = mid;\n            }\n            else{\n                lo = mid+1;\n            }\n        }\n       \n\n\n        return ans;\n    }\n};","author":"sujal das","submissionId":"1575183866"},[]]},{"664":[{"id":"664","fileName":"1575183703.txt","sourceCode":"\npublic class Solution {\n     private boolean isAllZero(int[] nums) {\n        for (int num : nums) {\n            if (num != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private static final int MAX_SIZE = 1001;\n\n    private BitSet shiftLeft(BitSet bs, int shift) {\n        BitSet shifted = new BitSet(MAX_SIZE);\n        for (int i = 0; i < MAX_SIZE - shift; i++) {\n            if (bs.get(i)) {\n                shifted.set(i + shift);\n            }\n        }\n        return shifted;\n    }\n    \n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        List<BitSet> dp = new ArrayList<>(n);\n\n        for (int i = 0; i < n; i++) {\n            BitSet bitSet = new BitSet(MAX_SIZE);\n            bitSet.set(0, true);\n            dp.add(bitSet);\n        }\n\n        if (isAllZero(nums)) {\n            return 0;\n        }\n        \n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n                dp.get(j).or(shiftLeft(dp.get(j), v));\n\n                for (int pos = nums[j] + 1; pos < MAX_SIZE; pos++) {\n                    dp.get(j).clear(pos);\n                }\n            }\n            if (allAchieved(nums, dp)) {\n                return k + 1;\n            }\n        }\n\n        return -1;\n    }\n\n    private boolean allAchieved(int[] nums, List<BitSet> dp) {\n        for (int i = 0; i < nums.length; i++) {\n            if (!dp.get(i).get(nums[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n","author":"Ashwani Tiwari","submissionId":"1575183703"},[]]},{"603":[{"id":"603","fileName":"1575179197.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        List<BitSet> dp = new ArrayList<>(n);\n        \n        for (int j = 0; j < n; j++) {\n            dp.add(new BitSet(1001));\n            dp.get(j).set(0, true);\n        }\n        \n        boolean allZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        \n        if (allZero) return 0;\n        \n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int v = queries[k][2];\n            \n            for (int j = l; j <= r; j++) {\n                BitSet shifted = (BitSet) dp.get(j).clone();\n                shifted = shifted.get(0, 1001);\n                shifted = shiftLeft(shifted, v);\n                dp.get(j).or(shifted);\n                \n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp.get(j).clear(pos);\n                }\n            }\n            \n            boolean allAchieved = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp.get(j).get(nums[j])) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n            \n            if (allAchieved) return k + 1;\n        }\n        \n        return -1;\n    }\n    \n    private BitSet shiftLeft(BitSet bitSet, int shift) {\n        BitSet shifted = new BitSet(1001);\n        for (int i = 0; i < 1001 - shift; i++) {\n            if (bitSet.get(i)) {\n                shifted.set(i + shift);\n            }\n        }\n        return shifted;\n    }\n}","author":"ayushthaku1","submissionId":"1575179197"},[{"id":"603","similarity":0.8612099644128114,"totOverlap":242,"longestOverlap":43}]],"665":[{"id":"665","fileName":"1575183870.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        List<BitSet> dp = new ArrayList<>(n);\n        \n        for (int j = 0; j < n; j++) {\n            dp.add(new BitSet(1001));\n            dp.get(j).set(0);\n        }\n\n        boolean zeros = true;\n        for (int num : nums) {\n            if (num != 0) {\n                zeros = false;\n                break;\n            }\n        }\n        if (zeros) return 0;\n\n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n                BitSet temp = (BitSet) dp.get(j).clone();\n                temp.or(shiftLeft(dp.get(j), v));\n\n                dp.set(j, temp);\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp.get(j).clear(pos);\n                }\n            }\n\n            boolean all = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp.get(j).get(nums[j])) {\n                    all = false;\n                    break;\n                }\n            }\n            if (all) return k + 1;\n        }\n\n        return -1;\n    }\n\n    private BitSet shiftLeft(BitSet bits, int shift) {\n        BitSet result = new BitSet(1001);\n        for (int i = bits.nextSetBit(0); i >= 0; i = bits.nextSetBit(i + 1)) {\n            if (i + shift < 1001) {\n                result.set(i + shift);\n            }\n        }\n        return result;\n    }\n}\n","author":"DRAGON GAMER","submissionId":"1575183870"},[{"id":"1056","similarity":0.8781362007168458,"totOverlap":245,"longestOverlap":50},{"id":"1056","similarity":0.8612099644128114,"totOverlap":242,"longestOverlap":43}]],"1056":[{"id":"1056","fileName":"1575210788.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        List<BitSet> dp = new ArrayList<>(n);\n        \n        for (int i = 0; i < n; i++) {\n            BitSet bitset = new BitSet(1001);\n            bitset.set(0);\n            dp.add(bitset);\n        }\n        \n        boolean allZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        \n        if (allZero) return 0;\n        \n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int v = queries[k][2];\n            \n            for (int j = l; j <= r; j++) {\n                BitSet shifted = (BitSet) dp.get(j).clone();\n                shifted.clear(1000);\n                shifted = shifted.get(0, 1000);\n                shifted.or(shifted.get(0, 1000));\n                shifted.or(shiftLeft(dp.get(j), v));\n                dp.set(j, shifted);\n                \n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp.get(j).clear(pos);\n                }\n            }\n            \n            boolean allAchieved = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp.get(j).get(nums[j])) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n            \n            if (allAchieved) return k + 1;\n        }\n        \n        return -1;\n    }\n    \n    private BitSet shiftLeft(BitSet bitset, int shift) {\n        BitSet shifted = new BitSet(1001);\n        for (int i = 0; i + shift < 1001; i++) {\n            if (bitset.get(i)) {\n                shifted.set(i + shift);\n            }\n        }\n        return shifted;\n    }\n}","author":"Tirthankar Sardar","submissionId":"1575210788"},[{"id":"665","similarity":0.8781362007168458,"totOverlap":245,"longestOverlap":50}]]},{"666":[{"id":"666","fileName":"1575184005.txt","sourceCode":"#include <bitset>\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size();\n        int lo = 0, hi = q + 1;\n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            bool valid = true;\n            for (int i = 0; i < n; i++) {\n                bitset<1001> dp;\n                dp.reset();\n                dp[0] = 1;\n                for (int j = 0; j < mid; j++) {\n                    if (queries[j][0] <= i && i <= queries[j][1])\n                        dp |= (dp << queries[j][2]);\n                }\n                if (!dp[nums[i]]) {\n                    valid = false;\n                    break;\n                }\n            }\n            if (valid)\n                hi = mid;\n            else\n                lo = mid + 1;\n        }\n        return (lo <= q ? lo : -1);\n    }\n};\n","author":"Siddhant kale","submissionId":"1575184005"},[]]},{"667":[{"id":"667","fileName":"1575184077.txt","sourceCode":"class Solution {\n    public:\n    int dfs(vector<vector<int>>& dp, vector<int>& nums, vector<vector<int>>& queries, int& origInd, int ind, int cur){\n        if(ind == queries.size()){\n            if(cur == 0) {\n                return ind;\n            }\n            return INT_MAX;\n        }\n        if(cur == 0){\n            return ind;\n        }\n        if(cur < 0) return INT_MAX;\n        if(dp[ind][cur] > -1) return dp[ind][cur];\n\n        //take don't take\n        int out = INT_MAX;\n        if(queries[ind][0] <= origInd && queries[ind][1] >= origInd){\n            out = dfs(dp, nums, queries, origInd, ind + 1, cur - queries[ind][2]);\n        }\n        out = min(out, dfs(dp, nums, queries, origInd, ind + 1, cur));\n        dp[ind][cur] = out;\n        return out;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        //should we eval each ind separately and find the earliest?\n\n        //so then dp for each ind separately? \n        //take don't take \n        int minInd = -1;\n        for(int i = 0; i < nums.size(); i++){\n            vector<vector<int>> dp(queries.size(), vector<int>(nums[i] + 1, -1));\n            int minQueries = dfs(dp, nums, queries, i, 0, nums[i]);\n\n            minInd = max(minInd, minQueries);\n        }\n        return minInd == INT_MAX ? -1 : minInd;\n    }\n};","author":"Zach Breger","submissionId":"1575184077"},[]]},{"668":[{"id":"668","fileName":"1575184138.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& Q) {\n        int qn = Q.size(), n = nums.size(), res = -1;\n        vector<vector<int>> dp(n, vector<int>(1001, qn));\n\n        for (int i = 0; i < n; i++) dp[i][0] = 0;\n\n        for (int qi = 0; qi < qn; qi++) {\n            auto &q = Q[qi];\n            for (int i = q[0]; i <= q[1]; i++) {\n                for (int d = 1000; d >= q[2]; d--) {\n                    if (dp[i][d - q[2]] == qn) continue;\n                    dp[i][d] = min(dp[i][d], max(dp[i][d - q[2]], qi));\n                }\n            }\n        }\n\n        for (int i = 0; i  < n; i++) {\n            if (nums[i] == 0) continue;\n            if (dp[i][nums[i]] == qn) return -1;\n            res = max(res, dp[i][nums[i]]);\n        }\n\n        return res + 1;\n    }\n};","author":"PP Hunter","submissionId":"1575184138"},[]]},{"669":[{"id":"669","fileName":"1575184233.txt","sourceCode":"#define inf 1000000000\n#define MIN(x,y) ((x)<(y)?(x):(y))\n#define MAX(x,y) ((x)>(y)?(x):(y))\n\nclass Solution {\n    int st[1001][1001];\npublic:\n    bool IsZeroArray(const vector<int>& nums)\n    {\n        for(auto x:nums)\n            if(x > 0)\n                return false;\n        \n        return true;\n    }\n    \n    int solve(int idx, int val, const vector<int>& arr, const int m)\n    {\n        if(val == 0)\n            return 0;\n        \n        if(idx >= m)\n            return inf;\n        \n        if(st[idx][val] != -1)\n            return st[idx][val];\n        \n        int ans = solve(idx+1, val, arr, m)+1;\n        if(val >= arr[idx])\n            ans = MIN(ans, solve(idx+1, val-arr[idx], arr, m)+1);\n        \n        return st[idx][val] = ans;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        \n        int n = nums.size();\n        int m = queries.size();\n        \n        vector<vector<int> > arr(n, vector<int>(m, inf));\n        \n        for(int i=0;i<m;i++)\n        {\n            int l,r,v;\n            l = queries[i][0];\n            r = queries[i][1];\n            v = queries[i][2];\n            \n            for(int j=l;j<=r;j++)\n                arr[j][i] = v;\n        }\n        \n        /*\n        for(int i=0;i<n;i++)\n        {\n            cout<<i<<\" : \";\n            for(int j=0;j<m;j++)\n                cout<<arr[i][j]<<\" \";\n            cout<<\"n\";\n        }*/\n        \n        int ans = -1;\n        for(int i=0;i<n;i++)\n        {\n            memset(st, -1, sizeof(st));\n            int idx = solve(0, nums[i], arr[i], m);\n            if(idx >= inf)\n            {\n                ans = -1;\n                break;\n            }\n            \n            ans = MAX(ans, idx);\n        }\n        \n        \n        return ans;\n    }\n};","author":"Yuvansh Agrawal","submissionId":"1575184233"},[]]},{"670":[{"id":"670","fileName":"1575184447.txt","sourceCode":"class Solution:\n    def subset_sum(self, nums, target):\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        for num in nums:\n            for j in range(target, num - 1, -1):\n                dp[j] |= dp[j - num]\n        return dp[target]\n\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        delta = [[] for _ in range(len(nums))]\n        curDelta = []\n        curQ = 0\n\n        for i, val in enumerate(nums):\n            for delt in delta[i]:\n                if delt > 0:\n                    curDelta.append(delt)\n                else:\n                    curDelta.remove(-delt)\n            if self.subset_sum(curDelta, val):\n                continue\n\n            while curQ < len(queries) and not self.subset_sum(curDelta, val):\n                start, end, value = queries[curQ]\n\n                delta[start].append(value)\n                if end + 1 < len(nums):\n                    delta[end + 1].append(-value)\n\n                if i >= start and i < end + 1:\n                    curDelta.append(value)\n                curQ += 1\n            if curQ >= len(queries) and not self.subset_sum(curDelta, val):\n                return -1\n        return curQ\n\n","author":"quanbnz","submissionId":"1575184447"},[]]},{"671":[{"id":"671","fileName":"1575184259.txt","sourceCode":"class Solution {\npublic:\n    bool DP(vector<vector<int>>& queries, int bound, int val, int idx){\n        vector<int> reached (val + 1, 0);\n        for(int i = 0; i <= bound; i++){\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int decr = queries[i][2];\n            if(l <= idx and idx <= r){\n                for(int j = (int)reached.size() - 1; j >= 0; j--){\n                    if(reached[j] == 1 and j + decr < reached.size()) reached[j + decr] = 1;\n                }\n                if(decr < reached.size()) reached[decr] = 1;\n                \n                // cout << \"inserted \" << decr << endl;\n                // cout << \"reached\" << endl;\n                // for(int x : reached) cout << x << ' ';\n                // cout << endl;\n                \n                if(reached.back() == 1) return true;\n            }\n        }\n        return false;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        // binary search of DP subroutines\n        int ans = -1;\n        for(int i = 0; i < nums.size(); i++){\n            int val = nums[i];\n            // binary search on queries\n            if(nums[i] == 0){ // already zero\n                ans = max(ans, 0);\n                continue;\n            }\n            if(DP(queries, (int)queries.size() - 1, val, i) == false) return -1; // impossible to bring nums[i] to 0 using the queries available\n            if(DP(queries, 0, val, i) == true){ // just the first query is enough to bring nums[i] to 0\n                ans = max(ans, 1);\n                continue;\n            }\n            int lo = 0;\n            int hi = (int)queries.size() - 1;\n            while(true){\n                int mid = (lo + hi) / 2;\n                bool ok = DP(queries, mid, val, i);\n                bool ok_1 = DP(queries, mid + 1, val, i);\n                if(not ok and ok_1){\n                    ans = max(ans, mid + 2); // instead of mid + 1, since we are not returning index, but number of queries\n                    break;\n                }else if(ok) hi = mid;\n                else lo = mid + 1;\n                // cout << \"lo: \" << lo << \" mid: \" << mid << \" hi: \" << hi << \" queries.size() \" << queries.size() << endl;\n            }\n        }\n        return ans;\n    }\n};","author":"jachetheboss","submissionId":"1575184259"},[]]},{"672":[{"id":"672","fileName":"1575184695.txt","sourceCode":"class Solution {\npublic:\nint n;\nbool check(vector<int>& nums, vector<vector<int>>& queries, int k) {\n    for (int i = 0; i < nums.size(); i++) {\n        vector<int> vals;\n        for (int j = 0; j < k; j++) {\n            int l = queries[j][0];\n            int r = queries[j][1];\n            int val = queries[j][2];\n            if (l <= i && i <= r) {\n                vals.push_back(val);\n            }\n        }\n\n        int target = nums[i];\n        vector<bool> dp(target + 1, false);\n        dp[0] = true;\n        for (int v : vals) {\n            for (int t = target; t >= v; t--) {\n                dp[t] = dp[t] || dp[t - v];\n            }\n        }\n        if (!dp[target]) return false;\n    }\n    return true;\n}\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        n=nums.size();\n      int l=0,r=queries.size();\n      int ans=-1;\n      while(l<=r){\n        int mid=l+(r-l)/2;\n        if(check(nums,queries,mid)){\n          ans=mid;\n          r=mid-1;\n        }else{\n            l=mid+1;\n        }\n      }\n      return ans; \n    }\n};","author":"Vijay Kumar","submissionId":"1575184695"},[]]},{"673":[{"id":"673","fileName":"1575184334.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int size = queries.size();\n\n        for(int k=0; k<=size; k++)\n            {\n                bool check = true;\n                for(int i=0; i<n; i++)\n                    {\n                        int target = nums[i];\n                        vector<int>temp;\n                        for(int q=0; q<k; q++)\n                            {\n                                int l = queries[q][0];\n                                int r = queries[q][1];\n                                int val = queries[q][2];\n                                if(l<=i && i<=r)\n                                {\n                                    temp.push_back(val);\n                                }\n                            }\n                        vector<bool> dp(target+1, false);\n                        dp[0] = true;\n                        for(int v : temp)\n                            {\n                                for(int s=target-v; s>=0; s--)\n                                    {\n                                        if(dp[s])\n                                        {\n                                            dp[s+v] = true;\n                                        }\n                                    }\n                            }\n                        if(!dp[target])\n                        {\n                            check = false;\n                            break;\n                        }\n                    }\n                if(check)\n                {\n                    return k;\n                }\n            }\n        return -1;\n    }\n};","author":"Harsh Thakkar","submissionId":"1575184334"},[]]},{"674":[{"id":"674","fileName":"1575184803.txt","sourceCode":"class Solution {\npublic:\n    bool canmakezero(vector<int>& nums, vector<vector<int>>& queries, int k) {\n        int n = nums.size();\n        vector<vector<int>> cur(n + 1);\n\n        for (int i = 0; i < k; i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int v = queries[i][2];\n            cur[l].push_back(v);\n            cur[r + 1].push_back(-v); \n        }\n\n        unordered_map<int, int> count; \n        vector<int> com; \n        for (int i = 0; i < n; i++) {\n            for (int x : cur[i]) {\n                if (x < 0) {\n                    if (count[-x] > 0) count[-x]--;\n                } else {\n                    count[x]++;\n                }\n            }\n            vector<bool> dp(nums[i] + 1, false);\n            dp[0] = true;\n            for (auto [num, freq] : count) {\n                for (int f = 0; f < freq; f++) {\n                    for (int sum = nums[i]; sum >= num; sum--) {\n                        dp[sum] = dp[sum] || dp[sum - num];\n                    }\n                }\n            }\n\n            if (!dp[nums[i]]) return false;\n        }\n\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l = 0, r = queries.size(), ans = -1;\n        if (!canmakezero(nums, queries, r)) return -1;\n\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if (canmakezero(nums, queries, mid)) {\n                ans = mid;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n\n        return ans;\n    }\n};\n","author":"balaganesh","submissionId":"1575184803"},[]]},{"675":[{"id":"675","fileName":"1575184894.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if all(num <= 0 for num in nums):\n            return 0\n\n        possibleNums = defaultdict(set)\n        for i, num in enumerate(nums):\n            possibleNums[i].add(num)\n            \n        for i, (l, r, val) in enumerate(queries):\n            for j in range(l, r + 1):\n                temp = possibleNums[j].copy()\n                for num in temp:\n                    if num - val >= 0:\n                        possibleNums[j].add(num - val)\n                        \n            if all(0 in possibleNums[i] for i, num in enumerate(nums)):\n                return i + 1\n        return -1\n            \n            ","author":"Dragonsq","submissionId":"1575184894"},[]]},{"676":[{"id":"676","fileName":"1575185286.txt","sourceCode":"class Solution {\n  public int minZeroArray(int[] nums, int[][] queries) {\n    boolean zeros = true;\n    for (int n : nums) {\n      if (n != 0) {\n        zeros = false;\n        break;\n      }\n    }\n    if (zeros) {\n      return 0;\n    }\n    int n = nums.length, m = queries.length;\n    List<int[]>[] diff = new ArrayList[n];\n    for (int i = 0; i < n; i++) {\n      diff[i] = new ArrayList<>();\n    }\n    for (int i = 0; i < m; i++) {\n      int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n      for (int j = l; j <= r; j++) {\n        diff[j].add(new int[]{i, v});\n      }\n    }\n    int l = 1, h = m, ret = -1;\n    while (l <= h) {\n      int mid = l + (h - l) / 2;\n      boolean valid = true;\n      for (int j = 0; j < n; j++) {\n        int temp = nums[j];\n        if (nums[j] == 0) {\n          continue;\n        }\n        List<Integer> curr = new ArrayList<>();\n        for (int[] currDiff : diff[j]) {\n          if (currDiff[0] < mid) {\n            curr.add(currDiff[1]);\n          }\n        }\n        if (!validSub(curr, temp)) {\n          valid = false;\n          break;\n        }\n      }\n      if (valid) {\n        ret = mid;\n        h = mid - 1;\n      }\n      else {\n        l = mid + 1;\n      }\n    }\n    return ret;\n\n  }\n  \n  private boolean validSub(List<Integer> curr, int temp) {\n    boolean[] dp = new boolean[temp + 1];\n    dp[0] = true;\n    for (int i = 0; i < curr.size(); i++) {\n      int num = curr.get(i);\n      for (int j = temp; j >= num; j--) {\n        if (dp[j - num]) {\n          dp[j] = true; \n        }\n      }\n    }\n    return dp[temp];\n  }\n}","author":"Zachary Bi","submissionId":"1575185286"},[]]},{"677":[{"id":"677","fileName":"1575184770.txt","sourceCode":"// lc\n#define vi vector<int>\n#define vvii vector<vi>\n#define vpii vector<pair<int,int>>\n#define pii  pair<int,int>\n#define ll long long int\n#define vs vector<string>\n#define mii map<int, int>\n#define umii unordered_map<int, int> \n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define sall(x) sort(x.begin(), x.end());\n#define rall(x) sort(x.rbegin(), x.rend())\n#define pb push_back \n#define in insert\n#define ff first\n#define ss second\n#define rep(i, a, b) for (int i = a; i < b; i++)\n#define all(x) x.begin(), x.end()\n#define sall(x) sort(x.begin(), x.end());\n#define rall(x) sort(x.rbegin(), x.rend())\n#define MAX(x) *max_element(x.begin(), x.end())\n#define MIN(x) *min_element(x.begin(), x.end())\n#define SUM(X) accumulate(X.begin(), X.end(), 0LL)\n#define rev(a) reverse(a.begin(), a.end());\nconst int mod = 1e9 + 7;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        int low=0,high=m,ans=-1;\n        auto rec = [&](int i, vi &temp, int t, vvii &dp, auto &&self)->bool{\n            if(t==0) return true;\n            if(i==temp.size()) return false;\n            if(dp[i][t] != -1) return dp[i][t];\n            bool ans = false;\n            if(t >= temp[i]) ans = ans | self(i+1, temp, t-temp[i], dp, self);\n            if(ans) return dp[i][t] = true;\n            ans = ans | self(i+1, temp, t, dp, self); \n            if(ans) return dp[i][t] = true;\n            return dp[i][t] = ans;\n        };\n        auto check = [&](int q) {\n            unordered_map<int,vi> mp;\n            for(int i=0;i<q;i++) {\n                int l=queries[i][0], r = queries[i][1], val = queries[i][2];\n                rep(k,l,r+1) {\n                    mp[k].pb(val);\n                }\n            }\n            rep(i,0,n)  {\n                vvii dp(mp[i].size(),vi(nums[i]+1,-1));\n                if(!rec(0,mp[i],nums[i],dp,rec)) return false;\n            }\n            return true;\n        };\n        while(low<=high) {\n            int mid = (low + high)>>1;\n            if(check(mid)) {\n                ans = mid;\n                high = mid-1;\n            } else {\n                low = mid+1;\n            }\n        }\n        return ans;\n    }\n};","author":"Shivank Dixit","submissionId":"1575184770"},[]]},{"678":[{"id":"678","fileName":"1575185163.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int maxVal = 1001;\n        \n        boolean[][] dp = new boolean[n][maxVal];\n        \n        for(int i=0; i < n; i++)\n            dp[i][0] = true;\n        \n        boolean flag = true;\n        for(int j=0; j < n; j++){\n            if(nums[j] != 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag)\n            return 0;\n        \n        for(int k=0; k < queries.length; k++){\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int v = queries[k][2];\n            \n            for(int j=l; j <= r; j++){\n                for(int val=maxVal - 1; val >= v; val--){\n                    if(dp[j][val - v])\n                        dp[j][val] = true;\n                }\n            }\n            \n            boolean temp = true;\n            for(int i=0; i < n; i++){\n                if(!dp[i][nums[i]]) {\n                    temp = false;\n                    break;\n                }\n            }\n            \n            if(temp)\n                return k + 1;\n        }\n        \n        return -1;\n    }\n}","author":"Sandesh Atulya","submissionId":"1575185163"},[]]},{"679":[{"id":"679","fileName":"1575184713.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        boolean empty = true;\n        for (int i: nums) if (i > 0) empty = false;\n        if (empty) return 0;\n            \n        int min = -1;\n        for (int i=0; i<nums.length; i++) {\n            int left = 0, right = queries.length-1;\n            while (left <= right) {\n                int mid = (left + right) / 2;\n                int[] count = new int[11];\n                int sum = 0;\n                for (int j=0; j<=mid; j++) {\n                    if (queries[j][0] <= i && i <= queries[j][1]) {\n                        count[queries[j][2]] ++;\n                        sum += queries[j][2];\n                    }\n                }\n                if (sum < nums[i] || !sum(count, nums[i], 10)) left = mid+1;\n                else right = mid-1;\n            }\n            if (left == queries.length) return -1;\n            else min = Math.max(min, left+1);\n        }\n        return min;\n    }\n    private boolean sum(int[] count, int targ, int n) {\n        if (targ == 0) return true;\n        if (n <= 0) return false;\n        for (int i=Math.min(count[n], targ/n); i>=0; i--) {\n            if (sum(count, targ - i*n, n-1)) return true;\n        }\n        return false;\n    }\n}","author":"iris","submissionId":"1575184713"},[]]},{"680":[{"id":"680","fileName":"1575185337.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        d = defaultdict(list)\n        for i, n in enumerate(nums):\n            for j, q in enumerate(queries):\n                if q[0]<=i<=q[1]:\n                    d[i].append((q[2],j))\n        #print(d)\n        @cache\n        def getv(n, j, i):\n            l = d[j]\n            if i >= len(l):\n                return inf\n            if n == l[i][0]:\n                return l[i][1] + 1\n            if n < l[i][0]:\n                return getv(n, j, i+1)\n            return min( getv(n, j, i+1), getv(n-l[i][0], j, i+1))\n\n        ans = -1\n        for i, n in enumerate(nums):\n            if n==0: \n                ans = max(ans, 0)\n                continue\n            ans = max(ans, getv(n,i,0))\n            #print(i, n, ans)\n            if ans == inf: return -1\n            \n        return ans\n        ","author":"kenchen","submissionId":"1575185337"},[]]},{"681":[{"id":"681","fileName":"1575185464.txt","sourceCode":"class Solution {\n     public int minZeroArray(int[] a, int[][] qs) {\n        int n = a.length;\n        boolean all0 = true;\n        for(int ai: a){\n            if(ai>0){\n                all0 = false;\n                break;\n            }\n        }\n        if(all0){\n            return 0;\n        }\n        int qn = qs.length;\n        for(int i=0; i<qn; ++i){\n            if(doable(a, qs, i+1)){\n                return i+1;\n            }\n        }\n        return -1;\n    }\n\n    private boolean doable(int[] a, int[][] qs, int k) {\n        int n = a.length;\n        List<Integer>[] ls = new ArrayList[n];\n        for(int i=0; i<n; ++i){\n            ls[i] = new ArrayList<>();\n        }\n        for(int i=0; i<k; ++i){\n            int l = qs[i][0];\n            int u = qs[i][1];\n            int val = qs[i][2];\n            for(int j=l; j<=u; ++j){\n                ls[j].add(val);\n            }\n        }\n        for(int i=0; i<n; ++i){\n            int v = a[i];\n            dp = new int[ls[i].size()][v+1];\n            for(int j=0;j<dp.length; ++j){\n                Arrays.fill(dp[j], -1);\n            }\n            if(solve(ls[i], 0, v)!=1){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int solve(List<Integer> l, int i, int v) {\n        int n = l.size();\n        if(v<0){\n            return 0;\n        }\n        if(i==n){\n            return v==0?1:0;\n        }\n        if(dp[i][v] != -1){\n            return dp[i][v];\n        }\n        int way1 = solve(l, i+1, v-l.get(i));\n        int way2 = solve(l, i+1, v);\n        int res = Math.max(way1, way2);\n        dp[i][v] = res;\n        return res;\n    }\n\n    private int[][] dp;\n}","author":"JOZLEETCODE","submissionId":"1575185464"},[]]},{"682":[{"id":"682","fileName":"1575185483.txt","sourceCode":"function minZeroArray(nums: number[], queries: number[][]): number {\n     const n = nums.length;\n    const elementQueries: { queryIndex: number; val: number }[][] = Array.from({ length: n }, () => []);\n\n    for (let j = 0; j < queries.length; j++) {\n        const [l, r, val] = queries[j];\n        for (let i = l; i <= r; i++) {\n            elementQueries[i].push({ queryIndex: j, val });\n        }\n    }\n\n    let maxK = 0;\n\n    for (let i = 0; i < n; i++) {\n        const s = nums[i];\n        if (s === 0) {\n            continue;\n        }\n\n        const qList = elementQueries[i];\n        const sumMap = new Map<number, number>();\n        sumMap.set(0, -1);\n\n        let found = false;\n\n        for (const q of qList) {\n            const currentVal = q.val;\n            const currentQueryIndex = q.queryIndex;\n\n            const currentSums = Array.from(sumMap.entries());\n            for (const [sum, earliestJ] of currentSums) {\n                const newSum = sum + currentVal;\n                if (newSum > s) continue;\n\n                if (!sumMap.has(newSum) || currentQueryIndex < sumMap.get(newSum)!) {\n                    sumMap.set(newSum, currentQueryIndex);\n                }\n\n                if (newSum === s) {\n                    const candidateK = currentQueryIndex + 1;\n                    if (candidateK > maxK) {\n                        maxK = candidateK;\n                    }\n                    found = true;\n                    break;\n                }\n            }\n            if (found) {\n                break; // Break outer loop for queries\n            }\n        }\n\n        if (!found) {\n            return -1;\n        }\n    }\n\n    if (maxK > queries.length) {\n        return -1;\n    }\n\n    return maxK;\n};","author":"Anand Kumar Jha","submissionId":"1575185483"},[]]},{"683":[{"id":"683","fileName":"1575185473.txt","sourceCode":"class Solution {\npublic:\n    bool check(vector<int>& nums, vector<vector<int>>& queries, int k) {\n        int n = nums.size();\n        vector<vector<bool>> possible(n);\n\n        for (int j = 0; j < n; j++) {\n            possible[j].resize(nums[j] + 1, false);\n            possible[j][0] = true;\n        }\n\n        for (int i = 0; i < k; i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n\n            for (int j = l; j <= r; j++) {\n                vector<bool> new_possible = possible[j];\n                for (int s = 0; s <= nums[j]; s++) {\n                    if (possible[j][s] && s + val <= nums[j]) {\n                        new_possible[s + val] = true;\n                    }\n                }\n                possible[j].swap(new_possible);\n            }\n        }\n\n        for (int j = 0; j < n; j++) {\n            if (!possible[j][nums[j]]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int Q = queries.size();\n\n        bool allZero = all_of(nums.begin(), nums.end(), [](int x) { return x == 0; });\n        if (allZero) return 0;\n\n        int low = 1, high = Q, ans = -1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (check(nums, queries, mid)) {\n                ans = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return ans;\n    }\n};","author":"Aman Wairagkar","submissionId":"1575185473"},[]]},{"684":[{"id":"684","fileName":"1575185515.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = queries.length;\n        if (pass(nums, 0, queries))\n        \treturn 0;\n        if (!pass(nums, n, queries))\n        \treturn -1;\n        int left = 0;\n        int right = n;\n        while (left + 1 < right) {\n        \tint mid = (left + right) / 2;\n        \tif (pass(nums, mid, queries))\n        \t\tright = mid;\n        \telse\n        \t\tleft = mid;\n        }\n        return right;\n    }\n\t\n\tprivate static boolean pass(int[] nums, int index, int[][] queries) {\n\t\tint n = nums.length;\n\t\tint[][] vals = new int[n][11];\n\t\tfor (int i = 0; i < index; i++) {\n\t\t\tfor (int j = queries[i][0]; j <= queries[i][1]; j++)\n\t\t\t\tvals[j][queries[i][2]]++;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!canMake(nums[i], vals[i]))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate static boolean canMake(int k, int[] vals) {\n\t\tif (k == 0)\n\t\t\treturn true;\n\t\tif (k < 0)\n\t\t\treturn false;\n\t\tSet<Integer> set = new HashSet();\n\t\tfor (int i = 10; i > 0; i--) {\n\t\t\tif (vals[i] == 0)\n\t\t\t\tcontinue;\n\t\t\tSet<Integer> now = new HashSet();\n\t\t\tnow.addAll(set);\n\t\t\tfor (int j = 1; j <= vals[i]; j++) {\n\t\t\t\tif (k < i * j)\n\t\t\t\t\tbreak;\n\t\t\t\tnow.add(i * j);\n\t\t\t\tfor (int prev : set) {\n\t\t\t\t\tif (prev + i * j <= k)\n\t\t\t\t\t\tnow.add(prev + i * j);\n\t\t\t\t}\n\t\t\t\tif (now.contains(k))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tset = now;\n\t\t}\n\t\treturn false;\n    }\n}","author":"realstar","submissionId":"1575185515"},[]]},{"685":[{"id":"685","fileName":"1575185453.txt","sourceCode":"class Solution {\npublic:\nvector<vector<int>>dp;\n    bool solve (int sum,int index,auto&val,int b,int i){\n        if(sum<0)return 0;\n        if(sum==0)return 1;\n        if(index==b){\n            return 0;\n        }\n        if(dp[sum][index]!=-1)return dp[sum][index];\n        bool ans=solve(sum,index+1,val,b,i)||solve(sum-val[i][index],index+1,val,b,i);\n        return dp[sum][index]= ans;\n    }\n    bool check(vector<int>&nums,vector<vector<int>>&q,int mid){\n        int n=nums.size();\n        int m=q.size();\n        vector<vector<int>>val(n);\n        for(int i=0;i<=mid;i++){\n            for(int j=q[i][0];j<=q[i][1];j++){\n                val[j].push_back(q[i][2]);\n            }\n        }\n        for(int i=0;i<n;i++){\n            dp=vector<vector<int>>(nums[i]+1,vector<int>(mid+1,-1));\n            int b=val[i].size();\n            bool a=solve(nums[i],0,val,b,i);\n            if(a==false)return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n=nums.size();\n        int start=0;\n        int end=q.size()-1;\n        int sum=0;\n        int ans=-2;\n        for(int i=0;i<n;i++){\n            sum+=nums[i];\n        }\n        if(sum==0)return 0;\n        while(start<=end){\n            int mid=start+(end-start)/2;\n            if(check(nums,q,mid)){\n                end=mid-1;\n                ans=mid;\n            }\n            else{\n                start=mid+1;\n            }\n        }\n        return ans+1;\n    }\n};","author":"aditya kumar","submissionId":"1575185453"},[]]},{"686":[{"id":"686","fileName":"1575185661.txt","sourceCode":"use std::collections::VecDeque;\n\nimpl Solution {\n    pub fn min_zero_array(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> i32 {\n        let n = nums.len();\n        let max_value = 1000; // Max possible value in nums\n        let mut bit_dp = vec![VecDeque::from(vec![false; max_value + 1]); n];\n\n        // Initialize DP bitset with 1 at position 0\n        for j in 0..n {\n            bit_dp[j][0] = true;\n        }\n\n        // Check if nums is already zero array\n        if nums.iter().all(|&x| x == 0) {\n            return 0;\n        }\n\n        // Process queries\n        for (query_idx, query) in queries.iter().enumerate() {\n            let (left_idx, right_idx, value) = (query[0] as usize, query[1] as usize, query[2] as usize);\n\n            for j in left_idx..=right_idx {\n                for pos in (value..=max_value).rev() {\n                    if bit_dp[j][pos - value] {\n                        bit_dp[j][pos] = true;\n                    }\n                }\n            }\n\n            // Check if all numbers can be transformed to zero\n            let mut all_reached = true;\n            for j in 0..n {\n                if !bit_dp[j][nums[j] as usize] {\n                    all_reached = false;\n                    break;\n                }\n            }\n\n            if all_reached {\n                return (query_idx + 1) as i32;\n            }\n        }\n\n        -1\n    }\n}\n","author":"leetcoder_999","submissionId":"1575185661"},[]]},{"687":[{"id":"687","fileName":"1575185706.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        p = {i: [] for i in range(len(nums))}\n\n        for i, q in enumerate(queries):\n            l, r, v = q\n            for j in range(l, r + 1):\n                p[j].append((v, i + 1))\n\n        def check(val, arr):\n            if val == 0:\n                return 0\n            \n            @cache\n            def f(v, i):\n                if i == len(arr):\n                    return -1\n\n                if arr[i][0] == v:\n                    return arr[i][1]\n\n                take = -1\n                skip = f(v, i + 1)\n                \n                if arr[i][0] < v:\n                    take = f(v - arr[i][0], i + 1)\n\n                if take == -1:\n                    return skip\n\n                if skip == -1:\n                    return take\n\n                return min(skip, take)\n\n            return f(val, 0)\n\n        values = []\n        for i, n in enumerate(nums):\n            values.append(check(n, p[i]))\n\n        if min(values) == -1:\n            return -1\n        \n        return max(values)","author":"Duck","submissionId":"1575185706"},[]]},{"688":[{"id":"688","fileName":"1575185924.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        q = len(queries)\n        coin_lists = [[] for _ in range(n)]\n        for qi, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                coin_lists[j].append((qi, v))\n        for j in range(n):\n            coin_lists[j].sort(key=lambda x: x[1])\n        def can_form_all(k: int) -> bool:\n            for j in range(n):\n                target = nums[j]\n                if target == 0:\n                    continue\n                available = [v for qi, v in coin_lists[j] if qi < k]\n                dp = 1\n                for coin in available:\n                    dp |= dp << coin\n                    if dp >> target & 1:\n                        break\n                if not (dp >> target) & 1:\n                    return False\n            return True\n        low, high = 0, q + 1\n        ans = -1\n        while low < high:\n            mid = (low + high) // 2\n            if can_form_all(mid):\n                ans = mid\n                high = mid\n            else:\n                low = mid + 1        \n        return ans if ans != -1 and ans <= q else -1\n","author":"Sujoy De","submissionId":"1575185924"},[]]},{"689":[{"id":"689","fileName":"1575186282.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], querikjbjkes: List[List[int]]) -> int:\n\n        @cache\n        def dfs(val, k, i):\n            if val == 0:\n                return True\n            \n            if k < 0 or val < 0:\n                return False\n\n            l = False\n            if querikjbjkes[k][0] <= i <= querikjbjkes[k][1]:\n                l = dfs(val - querikjbjkes[k][2], k-1, i)\n            r = dfs(val, k - 1, i)\n\n            return l or r\n        \n        def check(k):\n            for i in range(len(nums)):\n                if not dfs(nums[i], k - 1, i):\n                    return False\n\n            return True\n        \n        l, r = 0, len(querikjbjkes)\n        adoihvns = -1\n        \n        while l <= r:\n            mdgrew = (l + r) // 2\n            \n            if check(mdgrew):\n                adoihvns = mdgrew\n                r = mdgrew - 1\n            else:\n                l = mdgrew + 1\n\n        return adoihvns","author":"james Paul","submissionId":"1575186282"},[]]},{"690":[{"id":"690","fileName":"1575186312.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& qq) {\n        bool pos[11][1001];\n\n        for (int i = 0; i < a.size(); i++)\n            for (int j = 0; j <= 1000; j++)\n                pos[i][j] = false;\n\n        for (int i = 0; i < a.size(); i++)\n            pos[i][0] = true;\n\n        bool f = true;\n        for (int i = 0; i < a.size(); i++)\n            if (pos[i][a[i]] == false)\n                f = false;\n\n        if (f == true)\n            return 0;\n\n        int ans = 0;\n        for (auto q : qq) {\n            ans++;\n            f = true;\n\n            for (int i = q[0]; i <= q[1]; i++) {\n\n                for (int j = 1000; j >= q[2]; j--)\n                    if (pos[i][j - q[2]] == true)\n                        pos[i][j] = true;\n            }\n\n            cout << pos[2][0] << endl;\n            cout << pos[2][1] << endl;\n            cout << pos[2][2] << endl;\n\n            cout << \"-----------\" << endl;\n\n\n            for (int i = 0; i < a.size(); i++)\n                if (pos[i][a[i]] == false)\n                    f = false;            \n\n            if (f == true)\n                return ans;\n        }\n        return -1;\n    }\n};","author":"Vlad Sobin","submissionId":"1575186312"},[]]},{"691":[{"id":"691","fileName":"1575186387.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if sum(nums) == 0:\n            return 0\n\n        dp = []\n        for num in nums:\n            dp.append([False for i in range(num+1)])\n            if len(dp[-1]) > 0:\n                dp[-1][-1] = True\n\n        for k, query in enumerate(queries):\n            l, r, val = query\n            for i in range(l, r+1):\n                for j in range(nums[i]+1):\n                    if dp[i][j] == True and j - val >= 0:\n                        dp[i][j-val] = True\n\n            allTrue = True\n            for i in range(len(nums)):\n                if len(dp[i]) > 0:\n                    allTrue = allTrue and dp[i][0]\n                \n                if not allTrue:\n                    break\n\n            if allTrue:\n                return k + 1\n\n        return -1\n                ","author":"amithshettya","submissionId":"1575186387"},[]]},{"692":[{"id":"692","fileName":"1575186062.txt","sourceCode":"class Solution {\n    boolean solve(int i, int q, int idx, int mid, int[][] queries, Boolean dp[][]){\n        if(i == 0){\n            return true;\n        }\n        if(q == mid+1){\n            return false;\n        }\n        if(dp[i][q] != null){\n            return dp[i][q];\n        }\n        dp[i][q] = false;\n        if(queries[q][0] <= idx && queries[q][1] >= idx && i >= queries[q][2]){\n            dp[i][q] |= solve(i-queries[q][2], q+1, idx, mid, queries, dp);\n        }\n        dp[i][q] |= solve(i, q+1, idx, mid, queries, dp);\n        return dp[i][q];\n    } \n    boolean isZero(int mid, int nums[], int[][] queries){\n        for(int i=0; i<nums.length; i++){\n            if(!solve(nums[i], 0, i, mid, queries, new Boolean[nums[i]+1][mid+1])){\n                return false;\n            }\n        }\n        return true;\n    }\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int low = 0;\n        int high = queries.length-1;\n        int ans = -1;\n        int nonZeros = 0;\n        for(int i:nums){\n            if(i > 0){\n                nonZeros++;\n            }\n        }\n        if(nonZeros == 0){\n            return 0;\n        }\n        while(low <= high){\n            int mid = (low+high)/2;\n            if(isZero(mid, nums.clone(), queries)){\n                ans = mid;\n                high = mid-1;\n            }else low = mid+1;\n        }\n        if(ans == -1){\n            return ans;\n        }\n        return ans+1;\n    }\n}","author":"MOHANA YOGESH DIKKALA","submissionId":"1575186062"},[]]},{"693":[{"id":"693","fileName":"1575186728.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        need_to_check = False\n        \n        for num in nums:\n            if num != 0:\n                need_to_check = True\n\n        if not need_to_check:\n            return 0\n\n        n = len(nums)\n        max_num = max(nums)\n\n        dp = [[False] * (max_num + 1) for _ in range(n)]\n\n        for i in range(n):\n            dp[i][0] = True\n\n        for i in range(len(queries)):\n            l, r, val = queries[i]\n\n            for j in range(l, r + 1):\n                for k in range(max_num, val - 1, -1):\n                    if dp[j][k - val]:\n                        dp[j][k] = True\n\n            good = True\n            for x in range(n):\n                if nums[x] > max_num or not dp[x][nums[x]]:\n                    good = False\n                    break\n\n            if good:\n                return i + 1\n\n        return -1","author":"Hung","submissionId":"1575186728"},[]]},{"694":[{"id":"694","fileName":"1575186492.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        # for num in nums:\n        print = lambda *x:x\n        print(\"=\"*20)\n        \n        reachables = [set([num]) for num in nums]\n        print(reachables)\n        \n        if all(0 in reachables[index] for index in range(n)):\n            return 0\n\n        \n        for i, query in enumerate(queries):\n            left, right, val = query\n            \n            for index in range(left, right+1):\n                # if 0 in reachables[index]:\n                #     continue\n\n                new = set()\n                for eVal in reachables[index]:\n                    new.add(eVal)\n                    if eVal >= val:\n                        new.add(eVal-val)\n                reachables[index] = new\n        \n            print(i, query)\n            print(i, reachables)\n        \n                \n            if all(0 in reachables[index] for index in range(n)):\n                return i +1\n\n        return -1\n            \n        \n        ","author":"wansong123","submissionId":"1575186492"},[]]},{"695":[{"id":"695","fileName":"1575186735.txt","sourceCode":"class Solution {\npublic:\n    int solve(int i, int x, vector<int>& items, vector<vector<int>>& dp) {\n        if(x == 0) return 0; \n        if(x < 0 || i == items.size()) return 1'000'000;\n        if(dp[i][x] != -1) return dp[i][x]; \n        return dp[i][x] = 1 + min(solve(i+1, x, items, dp), solve(i+1, x-items[i], items, dp));\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int res = 0;\n        int n = nums.size();\n        for(int i = 0; i < n; i++) {\n            vector<int> items;\n            vector<int> indices; \n            indices.push_back(0); \n            for(int j = 0; j < queries.size(); j++) {\n                auto &query = queries[j]; \n                int left = query[0], right = query[1], val = query[2]; \n                if(left > i || right < i) continue; \n                items.push_back(val);\n                indices.push_back(j+1);\n            }\n            vector<vector<int>> dp(items.size(), vector<int>(1001, -1)); \n            int tmp = solve(0, nums[i], items, dp);\n            if(tmp >= 1'000'000) return -1; \n            res = max(res, indices[tmp]);\n        }\n        return (res >= 1'000'000 ? -1 : res);\n    }\n};","author":"Konstantinos Fotopoulos","submissionId":"1575186735"},[]]},{"696":[{"id":"696","fileName":"1575186804.txt","sourceCode":"class Solution {\n    \n    bool check(vector<int> &v, int w)\n    {\n        int n = v.size();\n        // cout<<w<<endl;\n\n        vector<vector<bool>> dp(n+1, vector<bool>(w+1, false));\n\n        dp[0][0] = true;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<=w;j++)\n            {\n                dp[i+1][j] = dp[i][j];\n                if(v[i]<=j)\n                    dp[i+1][j] = (dp[i+1][j] || dp[i][j-v[i]]);\n\n                // cout<<dp[i+1][j]<<\" \";\n            }\n            // cout<<endl;\n        }\n\n        // cout<<dp[n][w]<<endl;\n        return dp[n][w];\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = -1;\n        int l = 0;\n        int r = queries.size();\n        int n = nums.size();\n\n        while(l<=r)\n        {\n            int mid = l + (r-l)/2;\n            bool pos =  true;\n\n            for(int i=0;i<n;i++)\n            {\n                vector<int> v;\n                for(int j=0;j<mid;j++)\n                {\n                    if(queries[j][0]<=i&&queries[j][1]>=i)\n                        v.push_back(queries[j][2]);\n                }\n\n                if(check(v, nums[i])==false)\n                {\n                    pos = false;\n                    break;\n                }\n            }\n\n            if(pos)\n            {\n                ans =mid;\n                r = mid-1;\n            }\n            else\n                l = mid+1;\n        }\n\n        return ans;\n    }\n};","author":"Suryansh Gupta","submissionId":"1575186804"},[]]},{"697":[{"id":"697","fileName":"1575187051.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n\n        int max_moves = 0;\n        for (int i = 0; i < n; ++i) {\n            int num = nums[i];\n            if (num == 0) continue;\n\n            vector<bool> v(1001, false);\n            v[num] = true;\n\n            for (int k = 0; k < queries.size(); ++k) {\n                int left = queries[k][0];\n                int right = queries[k][1];\n                int val = queries[k][2];\n                if (left > i || right < i) continue;\n\n                for (int j = 0; j <= 1000; ++j) {\n                    if (v[j] && j - val >= 0) v[j - val] = true;\n                }\n\n                if (v[0]) {\n                    max_moves = max(max_moves, k + 1);\n                    break;\n                }\n            }\n\n            if (!v[0]) return -1;\n        }\n\n        return max_moves;\n    }\n};","author":"Jack Palaia","submissionId":"1575187051"},[]]},{"698":[{"id":"698","fileName":"1575187257.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int dp[11][1001]={0};\n        int n=nums.size();\n        int ans=-1;\n        int m=queries.size();\n        for(int j=0; j<m; j++){\n            int l=queries[j][0];\n            int r=queries[j][1];\n            int val=queries[j][2];\n            bool sach=true;\n            for(int k=0; k<n; k++){\n                dp[k][0]=1;\n                if(nums[k]!=0&&dp[k][nums[k]]==0)sach=false;\n            }\n            if(sach){\n                ans=j;\n                return ans;\n            }\n            for(int k=l; k<=r; k++){\n                for(int g=1000; g>=0; g--){\n                    if(g+val<1001)dp[k][g+val]|=(dp[k][g]>0);\n                }\n            }\n        }\n        bool sach=true;\n            for(int k=0; k<n; k++){\n                if(nums[k]!=0&&dp[k][nums[k]]==0)sach=false;\n            }\n        if(sach)ans=m;\n        return ans;\n        \n    }\n};","author":"AJ148","submissionId":"1575187257"},[]]},{"699":[{"id":"699","fileName":"1575186797.txt","sourceCode":"class Solution {\npublic:\n\n    int find_min_idx(vector<int> &v, int sum, int i, int memo[1001][1001]){\n        int n = v.size();\n\n        if(i == n){\n            if(sum == 0){\n                return n;\n            } else{\n                return INT_MAX;\n            }\n        }\n\n        if(sum<0){\n            return INT_MAX;\n        }\n        \n        if(sum == 0){\n            return i;\n        }\n\n        if(memo[sum][i]!=-1) return memo[sum][i];\n\n        return memo[sum][i] = min(find_min_idx(v, sum, i+1, memo), find_min_idx(v, sum- v[i], i+1, memo));\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\n        int n = nums.size();\n        int q = queries.size();\n\n        vector<vector<int>> v(n, vector<int>(q, 0));\n\n        for(int i = 0; i<q; ++i){\n            int left = queries[i][0], right = queries[i][1], val = queries[i][2];\n\n            for(int j = left; j<=right; ++j){\n                v[j][i] = val;\n            }\n        }\n\n        int ans = INT_MIN;\n        int memo[1010][1001];\n        for(int i = 0; i<n; ++i){\n            memset(memo, -1, sizeof(memo));\n            ans = max(find_min_idx(v[i], nums[i], 0, memo), ans);\n        }\n\n        return ans == INT_MAX? -1: ans;\n    }\n};","author":"automatefreely","submissionId":"1575186797"},[]]},{"700":[{"id":"700","fileName":"1575187258.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& que) {\n        int l = -1, r = que.size() - 1;\n        int n = a.size();\n        int ans = -1;\n        int mx = 0;\n        for (int x : a) {\n            mx = max(x, mx);\n        }\n        \n        while (l <= r) {\n            int mid = (l + r) / 2;\n            vector<vector<int>> dp(n, vector<int>(mx + 1, 0));\n            for (int id = 0; id < n; id++) {\n                dp[id][0] = 1;\n            }\n            for (int q = 0; q <= mid; q++) {\n                int l = que[q][0];\n                int r = que[q][1];\n                int val = que[q][2];\n                for (int v = mx; v >= val; v--) {\n                    for (int id = l; id <= r; id++) {\n                        dp[id][v] |= dp[id][v - val];\n                    }\n                }\n            }     \n            int cnt = 0;\n            for (int i = 0; i < n; i++) {\n                cnt += dp[i][a[i]];\n            }\n            if (cnt == n) {\n                r = mid - 1;\n                ans = mid + 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"Dang Nguyen Bao","submissionId":"1575187258"},[]]},{"701":[{"id":"701","fileName":"1575187323.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        dp = [[float('inf')] * 1001 for _ in range(n)]\n        for i in range(n):\n            dp[i][0] = 0\n        if all(dp[i][nums[i]] != float('inf') for i in range(n)):\n            return 0\n        for k, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                num = nums[i]\n                for j in range(num, val - 1, -1):\n                    dp[i][j] = min(dp[i][j], dp[i][j - val] + 1)\n            if all(dp[i][nums[i]] != float('inf') for i in range(n)):\n                return k + 1\n        return -1\n                ","author":"gwdyxxzl","submissionId":"1575187323"},[]]},{"702":[{"id":"702","fileName":"1575187378.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        l = len(nums)\n        inf = float('inf')\n        qm = []\n        for li, ri, val in queries:\n            oq = [0] * l\n            for i in range(li, ri+1):\n                oq[i] += val\n            qm.append(oq)\n        #print(queries)\n        #print(qm)\n        lb = -1\n        ub = len(queries) - 1\n        def isz(n, cnts):\n            flags = [True] + [False] * n\n            for c in cnts:\n                inds = []\n                for i in range(len(flags)-1, -1, -1):\n                    if flags[i] and i + c < len(flags):\n                        flags[i + c] = True\n                if flags[n]:\n                    return True\n            return flags[n]\n        ans = inf\n        while lb <= ub:\n            mi = (lb+ub) // 2\n            found = True\n            for i in range(l):\n                n = nums[i]\n                q = list(qm[j][i] for j in range(mi+1))\n                if not isz(n, q):\n                    found = False\n                    break\n            if found:\n                ans = min(ans, mi)\n                ub = mi - 1\n            else:\n                lb = mi + 1\n        return ans + 1 if ans != inf else -1","author":"Waxon Waxoff","submissionId":"1575187378"},[]]},{"703":[{"id":"703","fileName":"1575186116.txt","sourceCode":"class Solution {\npublic:\n    bool canSumTo(vector<int> &seq, int target) {\n        int n = seq.size();\n        if (n==0) return target==0;\n\n        unordered_set<int> dp, tmp;\n        dp.insert(0);\n        for (int &x: seq) {\n            for (int sm: dp) {\n                tmp.insert(sm+x);\n            }\n            for (int y:tmp) {\n                dp.insert(y);\n            }\n            tmp.clear();\n        }\n        \n\n        \n        \n        return dp.find(target)!=dp.end();\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int k = 0;\n        \n        int n = nums.size();\n        int done = 0;\n        vector<unordered_set<int>> dp(n);\n        for (int i=0;i<n;i++) {\n            if (nums[i]==0) done |= (1<<i);\n            dp[i].insert(0);\n        }\n        if (done+1==(1<<n)) return k;\n        \n        for (auto &q:queries) {\n            k++;\n            int l = q[0], r = q[1], d = q[2];\n            for (int i =l;i<=r;i++) {\n                if (done&(1<<i)) continue;\n                unordered_set<int> tmp;\n                for (int x: dp[i]) {\n                    tmp.insert(x+d);\n                }\n                for (int x:tmp) {\n                    dp[i].insert(x);\n                }\n                if (dp[i].find(nums[i])!=dp[i].end()) {\n                    done |= (1<<i);\n                }\n            }\n            if (done+1==(1<<n)) return k;\n        }\n        return -1;\n    }\n};","author":"Haggai Liu","submissionId":"1575186116"},[]]},{"704":[{"id":"704","fileName":"1575187382.txt","sourceCode":"public class Solution {\n    public int MinZeroArray(int[] nums, int[][] queries) \n    {\n        int max = 0;\n        for (int i = 0; i < nums.Length; ++i) \n        {\n            int x = nums[i];\n            \n            HashSet<int> hset = new() {x};\n            int j = 0;\n            for (; j < queries.Length && !hset.Contains(0); ++j) \n            {\n                var q = queries[j];\n            \n                if (i < q[0] || i > q[1]) continue;\n\n                foreach (int val in hset.ToArray()) if (val - q[2] >= 0) hset.Add(val - q[2]);\n            }\n\n            if (!hset.Contains(0)) return -1;\n\n            max = Math.Max(max, j);\n        }\n        return max;\n    }\n}","author":"Rad0miR","submissionId":"1575187382"},[]]},{"705":[{"id":"705","fileName":"1575187425.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans=0;\n        for(int i=0; i<nums.size(); ++i)\n        {   \n            unordered_map<int,int>m;\n            int minm=queries.size();\n            m[nums[i]]=1;\n            int maxm=1e9;\n            for(int j=0; j<queries.size()+1; ++j)\n            {     \n                 if(m.find(0)!=m.end()) \n                 {\n                     maxm=j;\n                     break;\n                 }\n                 if(j==queries.size()) break;\n                 int l=queries[j][0],r=queries[j][1],val=queries[j][2];\n                 if(l>i or r<i) continue;\n                 unordered_map<int,int>m2;\n                 for(auto k:m)\n                 {  \n                    m2[k.first]=1;\n                    if(k.first>=val) m2[k.first-val]=1;   \n                 }\n                 m=m2;\n            }\n            cout<<maxm<<endl;\n            if(maxm==1e9) return -1;\n            else ans=max(ans,maxm);\n        }\n        return ans;\n    }\n};","author":"stfudevansh","submissionId":"1575187425"},[]]},{"706":[{"id":"706","fileName":"1575187428.txt","sourceCode":"class Solution:\n    def is_possible(self, nums, dp, k, target):\n\n        first = False\n        second = False\n        for i in range(target + 1):\n            \n            if k - 1 >= 0:\n                first = dp[k - 1][i]\n                \n            if i - nums[k - 1] >= 0 and k - 1 >= 0:\n                second = dp[k - 1][i - nums[k - 1]]\n\n            dp[k][i] = first or second\n            \n        return dp[k][target]\n\n    def get_min_k(self, index, queries, nums):\n        dp = [[False for _ in range(nums[index] + 1)] for _ in range(len(queries) + 1)]\n\n        for i in range(len(dp)):\n            dp[i][0] = True\n\n        numbers = []\n        k = 0\n        for l, r, v in queries:\n            k += 1\n            if l <= index and r >= index:\n                numbers.append(v)\n                if self.is_possible(numbers, dp, len(numbers), nums[index]):\n                    return k\n        return -1\n        \n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        ans = 0\n        \n        for i in range(len(nums)):\n            if nums[i] != 0: \n                k = self.get_min_k(i, queries, nums)\n                if k == -1:\n                    return -1\n                ans = max(ans, k)\n        return ans\n        ","author":"Vic","submissionId":"1575187428"},[]]},{"707":[{"id":"707","fileName":"1575187433.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        f = []\n        for i in range(n):\n            f.append(set())\n        is_checked = [0] * n\n        for i in range(n):\n            if nums[i] == 0:\n                is_checked[i] = 1\n        if sum(is_checked)==n:\n            return 0\n        for i in range(len(queries)):\n            l = queries[i][0]\n            r = queries[i][1]\n            val = queries[i][2]\n            for idx in range(l, r+1):\n                current_sums = list(f[idx])\n                for s in current_sums:\n                    f[idx].add(s+val)\n                f[idx].add(val)\n                if nums[idx] in f[idx]:\n                    is_checked[idx] = 1\n            if sum(is_checked) == n:\n                return i+1\n        return -1","author":"tuanbi97","submissionId":"1575187433"},[]]},{"708":[{"id":"708","fileName":"1575187585.txt","sourceCode":"class Solution {\npublic:\n    int helper(int target, int curr, int idx, vector<vector<int>>& queries, vector<vector<int>>& dp, int index)\n    {\n        if(idx == queries.size())\n        {\n            return 1001;\n        }\n\n        if(dp[idx][curr] != -1) return dp[idx][curr];\n\n        int l = queries[idx][0];\n        int r = queries[idx][1];\n        int w = queries[idx][2];\n\n        if(index < l || index > r)\n        {\n            return dp[idx][curr] = helper(target, curr, idx + 1, queries, dp, index);\n        }\n\n        if(curr + w < target)\n        {\n            dp[idx][curr] = min(helper(target, curr + w, idx + 1, queries, dp, index), helper(target, curr, idx +1, queries, dp, index));\n            return dp[idx][curr];\n        }\n\n        if(curr + w > target)\n        {\n            return dp[idx][curr] = helper(target, curr, idx + 1, queries, dp, index);\n        }\n\n        return dp[idx][curr] = idx + 1;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> count(n + 1, 0);\n        int ans = 0;\n        for(int i = 0; i < n; ++i)\n        {\n            int numQ = queries.size();\n            vector<vector<int>> dp(numQ, vector<int>(1001, -1));\n            int curr = 0;\n            if(nums[i] != 0)\n            {\n                curr = helper(nums[i], 0, 0, queries, dp, i);\n            }\n            ans = max(ans, curr);\n        }\n        if(ans > 1000)\n        {\n            return -1;\n        }\n        return ans;\n    }\n};","author":"pratyushaggarwal1281","submissionId":"1575187585"},[]]},{"709":[{"id":"709","fileName":"1575187612.txt","sourceCode":"#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    bool canMakeZero(vector<int> &nums, vector<vector<int>> &allowedOps)\n    {\n        int n = nums.size();\n        for (int i = 0; i < n; i++)\n        {\n            int target = nums[i];\n            vector<bool> dp(target + 1, false);\n            dp[0] = true;\n            for (int val : allowedOps[i])\n            {\n                for (int j = target; j >= val; j--)\n                {\n                    dp[j] = dp[j] || dp[j - val];\n                }\n            }\n            if (!dp[target])\n                return false;\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int> &nums, vector<vector<int>> &queries)\n    {\n        int n = nums.size();\n        int t = queries.size();\n        int low = 0, high = t, ans = -1;\n\n        while (low <= high)\n        {\n            int mid = (low + high) / 2;\n            vector<vector<int>> allowedOps(n);\n\n            for (int i = 0; i < mid; i++)\n            {\n                int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n                for (int idx = l; idx <= r; idx++)\n                {\n                    allowedOps[idx].push_back(val);\n                }\n            }\n\n            if (canMakeZero(nums, allowedOps))\n            {\n                ans = mid;\n                high = mid - 1;\n            }\n            else\n            {\n                low = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n\n// int main()\n// {\n//     vector<int> nums = {1, 2, 3, 2, 1};\n//     vector<vector<int>> queries = {{0, 1, 1}, {1, 2, 1}, {2, 3, 2}, {3, 4, 1}, {4, 4, 1}};\n//     Solution sol;\n//     cout << sol.minZeroArray(nums, queries) << endl;\n//     return 0;\n// }\n","author":"amit sharma","submissionId":"1575187612"},[]]},{"710":[{"id":"710","fileName":"1575187619.txt","sourceCode":"/*\nn = nums.length\nm = queries.length\nk = max(nums)\n\nstates[i] := HashSet of possible states for nums[i]\nquery := [left, right, val]\nfor each state in states[left, right]: add (state - val) if >= 0\ncheck whether 0 in each states[i]\n=> TC: O(mnk), SC: O(nk)\n*/\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        Set<Integer>[] states = new Set[n];\n        for (int i = 0; i < n; i++) {\n            states[i] = new HashSet<>();\n            states[i].add(nums[i]);\n        }\n        if (check(states)) {\n            return 0;\n        }\n        for (int i = 0; i < queries.length; i++) {\n            int left = queries[i][0];\n            int right = queries[i][1];\n            int val = queries[i][2];\n            for (int j = left; j <= right; j++) {\n                Set<Integer> toAdd = new HashSet<>();\n                for (int state : states[j]) {\n                    int newState = state - val;\n                    if (newState >= 0) {\n                        toAdd.add(newState);\n                    }\n                }\n                for (int state : toAdd) {\n                    states[j].add(state);\n                }\n            }\n            if (check(states)) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n\n    private boolean check(Set<Integer>[] states) {\n        for (Set<Integer> set : states) {\n            if (!set.contains(0)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}","author":"kenCHLEE","submissionId":"1575187619"},[]]},{"711":[{"id":"711","fileName":"1575187648.txt","sourceCode":"\nfunc minZeroArray(nums []int, queries [][]int) int {\n    arrayLength := len(nums)\n    \n    // Use a slice of bool arrays to simulate bitset<1001>\n    dp := make([][]bool, arrayLength)\n    for i := range dp {\n        dp[i] = make([]bool, 1001)\n        dp[i][0] = true // Initial state: 0 is achievable\n    }\n    \n    // Check if all elements are zero\n    allZeros := true\n    for _, num := range nums {\n        if num != 0 {\n            allZeros = false\n            break\n        }\n    }\n    if allZeros {\n        return 0\n    }\n    \n    // Process each query\n    for queryNum, query := range queries {\n        left := query[0]\n        right := query[1]\n        value := query[2]\n        \n        // Update DP states for range [left, right]\n        for pos := left; pos <= right; pos++ {\n            // Shift existing states by value\n            for j := 1000; j >= value; j-- {\n                if dp[pos][j-value] {\n                    dp[pos][j] = true\n                }\n            }\n            // Clear states above nums[pos]\n            for j := nums[pos] + 1; j <= 1000; j++ {\n                dp[pos][j] = false\n            }\n        }\n        \n        // Check if all positions can reach their target\n        allReached := true\n        for i, target := range nums {\n            if !dp[i][target] {\n                allReached = false\n                break\n            }\n        }\n        if allReached {\n            return queryNum + 1\n        }\n    }\n    \n    return -1\n}","author":"joker","submissionId":"1575187648"},[]]},{"712":[{"id":"712","fileName":"1575187759.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        // Convert to the problem to\n        // For each element nums[i], what's the minimum k to make it 0?\n        int ans = INT_MIN;\n        for (int i = 0; i < nums.size(); ++i) {\n            int res;\n            if (nums[i] == 0) res = 0;\n            else res = knapsack(i, nums[i], queries);\n            ans = max(ans, res);\n        }\n        return ans == INT_MAX ? -1 : ans;\n    }\n\n    int knapsack(int i, int val, vector<vector<int>> & queries) {\n        vector<bool> dp(val + 1, false);\n        // Find the minimum index that we can add all queries to val\n        dp[0] = true;\n        for (int k = 0; k < queries.size(); ++k) {\n            if (i >= queries[k][0] && i <= queries[k][1]) {\n                for (int j = val; j >= queries[k][2]; --j)\n                    if (dp[j - queries[k][2]]) {\n                        // cout << \"i = \" << i << \", j = \" << j << \", k = \" << k << \", queries[k][2] = \" << queries[k][2] << endl;\n                        dp[j] = true;\n                    }\n            }\n            if (dp.back()) {\n                // cout << \"i = \" << i << \", k = \" << k << endl;\n                return k + 1;\n            }\n        }\n        return INT_MAX;\n    }\n};","author":"Clark Li","submissionId":"1575187759"},[]]},{"713":[{"id":"713","fileName":"1575187814.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int zero_count=0,n=nums.size();\n        vector<unordered_set<int>> all_possible_values(n);\n        for(int i=0;i<n;i++){\n            all_possible_values[i].insert(nums[i]);\n            if(nums[i]==0){\n                zero_count++;\n            }\n        }\n        if(zero_count==n){\n            return 0;\n        }\n        for(int k=0;k<queries.size();k++){\n            int l=queries[k][0],r=queries[k][1],v=queries[k][2];\n            for(int i=l;i<=r;i++){\n                unordered_set<int> t;\n                for(auto x: all_possible_values[i]){\n                    if(x-v>=0){\n                        t.insert(x-v);\n                    }\n                }\n                if(t.find(0)!=t.end()&&all_possible_values[i].find(0)==all_possible_values[i].end()){\n                    zero_count++;\n                }\n                for(auto x: t){\n                    all_possible_values[i].insert(x);\n                }\n            }\n            if(zero_count==n){\n                return k+1;\n            }\n        }\n        return -1;\n    }\n};","author":"thrivikram karur","submissionId":"1575187814"},[]]},{"715":[{"id":"715","fileName":"1575187890.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        if (chk(nums))\n            return 0;\n        int l = 0;\n        int r = queries.length;\n        while (l < r) {\n            int mid = (l + r) >>> 1;\n            if (chk(nums, queries, mid)) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        if (r == queries.length)\n            return -1;\n        return r + 1;\n    }\n\n    public boolean chk(int[] nums) {\n        for (int num : nums) {\n            if (num != 0)\n                return false;\n        }\n        return true;\n    }\n\n    public boolean chk(int[] nums, int[][] queries, int mid) {\n        int[][] arr = new int[nums.length + 1][11];\n        for (int i = 0; i <= mid; i++) {\n            arr[queries[i][0]][queries[i][2]]++;\n            arr[queries[i][1] + 1][queries[i][2]]--;\n        }\n        int[] counts = new int[11];\n        int sum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = 1; j < arr[i].length; j++) {\n                sum += j * arr[i][j];\n                counts[j] += arr[i][j];\n            }\n            if (sum < nums[i] || !dfs(counts, 1, nums[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean dfs(int[] counts, int i, int target) {\n        if (target == 0)\n            return true;\n        if (target < 0 || i == counts.length)\n            return false;\n        for (int j = counts[i]; j >= 0; j--) {\n            if (dfs(counts, i + 1, target - j * i))\n                return true;\n        }\n        return false;\n    }\n}","author":"watercyb","submissionId":"1575187890"},[]]},{"716":[{"id":"716","fileName":"1575188315.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        isZero = set() \n        n = len(nums)\n        canDecrease = [set() for _ in range(n)]\n        for i in range(n):\n            if nums[i] == 0:\n                isZero.add(i)\n            else:\n                canDecrease[i].add(nums[i])\n        if len(isZero)  == n: return 0\n\n        for i in range(len(queries)):\n            l, r, val = queries[i]\n            for j in range(l, r+1):\n                if j in isZero: continue\n                if val in canDecrease[j]: \n                    isZero.add(j)\n                else:\n                    tmp = list(canDecrease[j])\n                    for v in tmp:\n                        if val < v: \n                            canDecrease[j].add(v - val)\n\n            if len(isZero)  == n: return i + 1\n        return -1\n        ","author":"yui","submissionId":"1575188315"},[]]},{"717":[{"id":"717","fileName":"1575187735.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n\n        dp = [set([0]) for _ in range(n)]\n        \n        if all(num == 0 for num in nums):\n            return 0\n        \n        for k in range(len(queries)):\n            l, r, v = queries[k]\n            \n            for j in range(l, r + 1):\n                new_values = set()\n                for val in dp[j]:\n                    new_values.add(val + v)\n                dp[j].update(new_values)\n                \n                dp[j] = {val for val in dp[j] if val <= nums[j]}\n            \n            all_achieved = True\n            for j in range(n):\n                if nums[j] not in dp[j]:\n                    all_achieved = False\n                    break\n            \n            if all_achieved:\n                return k + 1\n        \n        return -1","author":"Aniket","submissionId":"1575187735"},[]]},{"718":[{"id":"718","fileName":"1575188709.txt","sourceCode":"class Solution:\n\n    def isSubsetSum(self,arr, x):\n        n = len(arr)\n        dp = [[False] * (x + 1) for _ in range(n + 1)]\n        \n        for i in range(n + 1):\n            dp[i][0] = True\n        \n        for i in range(1, n + 1):\n            for j in range(1, x + 1):\n                if arr[i-1] > j:\n                    dp[i][j] = dp[i-1][j] \n                else:\n                    dp[i][j] = dp[i-1][j] or dp[i-1][j - arr[i-1]] \n    \n        return dp[n][x]\n\n        \n    def check(self,num,d,i):\n\n        arr = []\n\n        for key in d[i].keys():\n            if key > num:\n                continue\n\n            if key == num:\n                return True\n\n            x = d[i][key]\n\n            for _ in range(min(x, num//key + 1)):\n                arr.append(key)\n\n        arr.sort()\n\n        return self.isSubsetSum(arr,num)\n\n    \n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n\n        d = [{} for _ in range(n)]\n\n        currIndex = 0\n\n        q = len(queries)\n\n        for i, num in enumerate(nums):\n            if num == 0:\n                continue\n\n            while not self.check(num,d,i) and currIndex < q:\n                l,r,val = queries[currIndex]\n\n                for j in range(l,r+1):\n                    d[j][val] = d[j].get(val,0) + 1\n\n                currIndex += 1\n\n            if currIndex == q and not self.check(num,d,i):\n                return -1\n                \n\n        return currIndex\n            \n                    \n\n            \n            \n            \n            \n\n            ","author":"Joker17","submissionId":"1575188709"},[]]},{"719":[{"id":"719","fileName":"1575188768.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int max_j = -1;\n        \n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == 0) {\n                continue;\n            }\n            \n            vector<pair<int, int>> applicable;\n            for (int j = 0; j < queries.size(); ++j) {\n                int l = queries[j][0];\n                int r = queries[j][1];\n                int val = queries[j][2];\n                if (i >= l && i <= r) {\n                    applicable.emplace_back(j, val);\n                }\n            }\n            \n            unordered_map<int, int> dp;\n            dp[0] = -1;\n            \n            for (auto& q : applicable) {\n                int j_original = q.first;\n                int val = q.second;\n                \n                unordered_map<int, int> temp;\n                for (auto& entry : dp) {\n                    int s = entry.first;\n                    int new_s = s + val;\n                    if (new_s > nums[i]) {\n                        continue;\n                    }\n                    if (temp.find(new_s) == temp.end() || j_original < temp[new_s]) {\n                        temp[new_s] = j_original;\n                    }\n                }\n                \n                for (auto& entry : temp) {\n                    int s = entry.first;\n                    int j = entry.second;\n                    if (dp.find(s) == dp.end() || j < dp[s]) {\n                        dp[s] = j;\n                    }\n                }\n            }\n            \n            if (dp.find(nums[i]) == dp.end()) {\n                return -1;\n            }\n            int earliest_j_i = dp[nums[i]];\n            max_j = max(max_j, earliest_j_i);\n        }\n        \n        return (max_j == -1) ? 0 : (max_j + 1);\n    }\n};","author":"Kaushik Dutta","submissionId":"1575188768"},[]]},{"720":[{"id":"720","fileName":"1575188856.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n\n        dp = [set() for _ in range(n)]\n        for j in range(n):\n            dp[j].add(0)\n\n        if all(num == 0 for num in nums):\n            return 0\n\n        for k, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                new_values = {val + v for val in dp[j] if val + v <= 1000}\n                dp[j].update(new_values)\n\n                dp[j] = {val for val in dp[j] if val <= nums[j]}\n\n            if all(nums[j] in dp[j] for j in range(n)):\n                return k + 1\n\n        return -1","author":"Alex","submissionId":"1575188856"},[]]},{"721":[{"id":"721","fileName":"1575188995.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int sum=0,n=nums.size();\n        for(auto it:nums) sum+=it;\n        if(sum==0) return 0;\n        vector<bitset<1001>> dp(n, bitset<1001>(1));\n        for(int i=0;i<q.size();i++){\n            for(int j=q[i][0];j<=q[i][1];j++){\n                dp[j]|=(dp[j]<<q[i][2]);\n                bitset<1001> mask;\n                for(int pos=0;pos<=nums[j];pos++) {\n                    mask.set(pos);\n                }                \n                dp[j] &= mask;\n            }\n            vector<int> ind(n);\n            for(int j=0;j<n;j++) ind[j]=j;\n            bool check = true;\n            for(int j=0;j<n;j++){\n                if (!dp[j][nums[j]]) {\n                    check = false;\n                    break;\n                }\n            }\n            if(check) return i+1;\n        }\n        return -1;\n        \n        \n    }\n};","author":"mhr","submissionId":"1575188995"},[]]},{"722":[{"id":"722","fileName":"1575189138.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = -1;\n        int lo = 0, hi = queries.size();\n        while (lo <= hi){\n            int mid = (lo + hi)/2;\n            bool ok = true;\n            for (int i = 0;i < nums.size();i++){\n                bool possible[1001];\n                for (int j = 0;j <= 1000;j++){\n                    possible[j] = false;\n                }\n                possible[nums[i]] = true;\n                for (int j = 0;j < mid;j++){\n                    if (queries[j][0] <= i and queries[j][1] >= i){\n                        for (int k = 0;k <= 1000 - queries[j][2];k++){\n                            if (possible[k + queries[j][2]]){\n                                possible[k] = true;\n                            }\n                        }\n                    }\n                }\n                if (!possible[0]){\n                    ok = false;\n                }\n            }\n            if (ok){\n                ans = mid;\n                hi = mid - 1;\n            }\n            else{\n                lo = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"littlemouse","submissionId":"1575189138"},[]]},{"723":[{"id":"723","fileName":"1575187953.txt","sourceCode":"class Solution {\npublic:\n    vector<bool> dp;\n    bool ispossible(vector<int>& nums, vector<vector<int>>& queries, int k) {\n        for (int j = 0; j <nums.size(); j++) {\n            dp.assign(1001, false);dp[0]=true;\n            for (int i=0;i<k;i++) {\n                int l=queries[i][0];\n                int r=queries[i][1];\n                int val=queries[i][2];\n                if (j>=l&&j<=r) {\n                    for (int k=1000-val;k>=0;k--) {\n                        int newpos=k+val;\n                        if (dp[k]){\n                            dp[newpos] = true;\n                        }\n                    }\n                }\n            }\n            if (!dp[nums[j]]) return false;\n        }\n        return true;\n    }\n    int search(vector<int>& nums, vector<vector<int>>& queries) {\n        int l = 0, r = queries.size(), ans = -1;\n        while(l<=r){\n            int mid = l+(r-l)/2;\n            if(ispossible(nums, queries, mid)) {\n                ans = mid;\n                r=mid-1;\n            }\n            else l=mid+1;\n        }\n        return ans;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        return search(nums, queries);\n    }\n};\n","author":"NISHANT TIWARI","submissionId":"1575187953"},[]]},{"724":[{"id":"724","fileName":"1575189174.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def solve(a,k):\n            n = len(a)\n            INF = float('inf')\n            dp = [INF for _ in range(k+1)]\n            dp[0] = -1\n            for i in range(n):\n                for j in range(k,a[i]-1,-1):\n                    if dp[j-a[i]]!=INF:\n                        dp[j] = min(dp[j],i)\n            # print(dp,n)\n            return dp[k] if dp[k]!=INF else -1\n        n = len(nums)\n        d = [[]for _ in range(n)]\n        d_idx = [[]for _ in range(n)]\n        m = len(queries)\n        for i1 in range(m):\n            i,j,val = queries[i1]\n            for k in range(i,j+1):\n                d[k].append(val)\n                d_idx[k].append(i1)\n        res = -1\n        for i in range(n):\n            if nums[i]!=0:\n                temp = solve(d[i],nums[i])\n                if temp == -1:\n                    return -1\n                # print(d_idx[i],temp)\n                res = max(d_idx[i][temp],res)\n        return res+1\n        ","author":"sri_teja","submissionId":"1575189174"},[]]},{"725":[{"id":"725","fileName":"1575188894.txt","sourceCode":"class Solution {\npublic:\n    int kandariarjun(){ return 1;}\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        kandariarjun();\n        int n = nums.size(), q = queries.size();\n        int maxVal = 0;\n        kandariarjun();\n        maxVal = *max_element(nums.begin(),nums.end());\n        vector<vector<bool>> dp(n, vector<bool>(maxVal + 1, false));\n        for (int j = 0; j < n; j++)\n            dp[j][0] = true;\n\n        if(accumulate(nums.begin(),nums.end(),0LL) == 0) return 0;\n\n        kandariarjun();\n\n        for (int i = 0; i < q; i++) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                for (int s = maxVal - val; s >= 0; s--) {\n                    if (dp[j][s])\n                        dp[j][s + val] = true;\n                }\n            }\n            kandariarjun();\n            bool allPossible = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j][nums[j]]) {\n                    allPossible = false;\n                    break;\n                }\n            }\n            kandariarjun();\n            if (allPossible)\n                return i + 1;\n        }\n        kandariarjun();\n        return -1;\n    }\n};","author":"Arjun Singh Kandari","submissionId":"1575188894"},[]]},{"726":[{"id":"726","fileName":"1575189363.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        \n        todo = set()\n        backet = []\n        for i,v in enumerate(nums):\n            if v == 0:\n                backet.append(set())\n            else:\n                backet.append({v})\n                todo.add(i)\n                \n        if not todo:\n            return 0\n            \n        k = 0\n        for L,R,V in queries:\n            k += 1\n            for idx in todo.copy():\n                if idx >= L and idx <= R:\n                    if V in backet[idx]:\n                        backet[idx] = set()\n                        todo.remove(idx)\n                    else:\n                        for val in backet[idx].copy():\n                            if V < val:\n                                backet[idx].add(val - V)\n            \n            if not todo:\n                break\n\n        if todo:\n            return -1\n        \n        return k\n        ","author":"sslance","submissionId":"1575189363"},[]]},{"727":[{"id":"727","fileName":"1575189633.txt","sourceCode":"class Solution {\npublic:\nint minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    int n = nums.size();\n\n    if (*max_element(nums.begin(), nums.end()) == 0)\n        return 0;\n\n    vector<bitset<1001>> bs(n);\n    for (auto& p : bs) {\n        p.set(0, 1);\n    }\n    for (int i = 0; i < queries.size(); i++) {\n        for (int j = 0; j < n; j++) {\n            if (j >= queries[i][0] && j <= queries[i][1]) {\n                auto& p = bs[j];\n                p |= p << queries[i][2];\n            }\n        }\n\n        bool f = true;\n        for (int j = 0; j < n; j++) {\n            if (!bs[j].test(nums[j]))\n            {\n                f = false;\n                break;\n            }\n        }\n        if (f)\n            return i + 1;\n    }\n\n    return -1;\n}\n};","author":"charles2011","submissionId":"1575189633"},[]]},{"728":[{"id":"728","fileName":"1575189743.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        int m=queries.size();\n        bool flag=true;\n        for(int i=0;i<n;i++)\n            {\n                if(nums[i]!=0)\n                {\n                    flag=false;\n                    break;\n                }\n            }\n        if(flag)\n            return 0;\n        int maxN=-1;\n        for(int i=0;i<n;i++)\n            {\n                maxN=max(maxN,nums[i]);\n            }\n        vector<vector<bool>>dp(n,vector<bool>(maxN+1,false));\n        for(int i=0;i<n;i++)\n            {\n                dp[i][0]=true;\n            }\n        for(int i=0;i<m;i++)\n            {\n                for(int j=queries[i][0];j<=queries[i][1];j++)\n                    {\n                    for(int k=maxN-queries[i][2];k>=0;k--)\n                        {\n                            if(dp[j][k]){\n                                dp[j][k+queries[i][2]]=true;\n                            }\n                        }\n                    }\n                flag=true;\n                for(int j=0;j<n;j++){\n                    if(nums[j]>maxN || !dp[j][nums[j]])\n                    {\n                        flag=false;\n                        break;\n                    }\n                }\n                if(flag)\n                    return i+1;\n            }\n        return -1;\n    }\n};","author":"kakashi_001","submissionId":"1575189743"},[]]},{"729":[{"id":"729","fileName":"1575189745.txt","sourceCode":"class Solution {\n    public:\n        int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\n            int n = nums.size();\n            int q = queries.size();\n\n            const int THRESHOLD = 1 << 29;\n            const int INF = 1 << 30;\n\n            vector<int> ans_list(n, INF);\n\n            for (int i = 0; i < n; i++) {\n\n                int x = nums[i];\n                int ans = INF;\n                vector<int> dp(x + 2, INF);\n                dp[0] = 0;\n\n                for (int j = 0; j < q; j++) {\n\n                    int left = queries[j][0];\n                    int right = queries[j][1];\n                    int v = queries[j][2];\n\n                    if (i < left || right < i) {\n                        continue;\n                    }\n\n                    for (int k = x; -1 < k; k--) {\n\n                        if (dp[k] == INF) {\n                            continue;\n                        }\n\n                        int index = min(x + 1, k + v);\n                        dp[index] = min(dp[index], j + 1);\n                    }\n                }\n\n                ans_list[i] = dp[x];\n                // cout << i << \" \" << nums[i] << \" \" << dp[x] << endl;\n            }\n\n            int ans = *max_element(ans_list.begin(), ans_list.end());\n            ans = (ans < THRESHOLD ? ans : -1);\n\n            return ans;\n        }\n    };\n","author":"drifter","submissionId":"1575189745"},[]]},{"730":[{"id":"730","fileName":"1575189605.txt","sourceCode":"class Solution {\npublic:\n    int solve(int x, int index, vector<vector<int>> &queries) {\n        int q = queries.size();\n        vector<vector<bool>> dp(q + 1, vector<bool> (1001, false));\n        dp[0][0] = true;\n        \n        // dp[q][x] = dp[q - 1][x] or (dp[q - 1][x - queries[q][2]] and (i <= r and i >= l));\n        for(int i = 1; i <= q; i++) {\n            for(int j = 0; j <= x; j++) {\n                dp[i][j] = dp[i - 1][j];\n                if(index <= queries[i - 1][1] and index >= queries[i - 1][0] and j >= queries[i - 1][2]) {\n                    dp[i][j] = dp[i][j] or dp[i - 1][j - queries[i - 1][2]];\n                }\n            }\n        }\n        \n        int l = 0, r = q, ans = -1;\n        while(l <= r) {\n            int m = l + (r - l) / 2;\n            if(dp[m][x]) {\n                ans = m;\n                r = m - 1;\n            } else {\n                l = m + 1;\n            }\n        }\n        \n        return ans;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int ans = -1;\n        for(int i = 0; i < n; i++) {\n            int res = solve(nums[i], i, queries);\n            if(res == -1) return -1;\n            \n            ans = max(ans, res);\n        }\n        \n        return ans;\n    }\n};","author":"sarvagya2544","submissionId":"1575189605"},[]]},{"731":[{"id":"731","fileName":"1575189805.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length, m = queries.length;\n        int[] originalNums = Arrays.copyOf(nums, n);\n        int left = 0, right = m, ans = -1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (canMakeZero(nums, queries, mid)) {\n                ans = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n            nums = Arrays.copyOf(originalNums, n);\n        }\n        return ans;\n    }\n\n    boolean canMakeZero(int[] nums, int[][] queries, int k) {\n        int n = nums.length;\n        List<List<Integer>> appliedDecrements = new ArrayList<>();\n        for (int i = 0; i < n; i++) appliedDecrements.add(new ArrayList<>());\n\n        for (int i = 0; i < k; i++) {\n            int li = queries[i][0], ri = queries[i][1], vali = queries[i][2];\n            for (int j = li; j <= ri; j++) {\n                appliedDecrements.get(j).add(vali);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            List<Integer> values = appliedDecrements.get(i);\n            if (!canSelectSubset(values, target)) \n                return false;\n        }\n        return true;\n    }\n\n    boolean canSelectSubset(List<Integer> values, int target) {\n        int m = values.size();\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n\n        for (int val : values) {\n            for (int sum = target; sum >= val; sum--) {\n                dp[sum] |= dp[sum - val];\n            }\n        }\n        return dp[target];\n    }\n}","author":"nickee1942","submissionId":"1575189805"},[]]},{"732":[{"id":"732","fileName":"1575189825.txt","sourceCode":"class Solution\n{\n    public:\n    \n    \n//     super interesting constraints\n//     n <= 10, bitmask, val <= 10 as well;\n//     q.size() <=  1000?\n//     can choose non empty subset as well\n//     decrementing the number by exactly val\n//     \n    \n    int const MOD = 1e9 + 7;\n    \n    \n    int rec(vector<vector<int>> &queries, vector<vector<int>> &dp, vector<int> &idx, int i, int rem)\n    {\n        // cout<<\"i: \"<<i<<\" rem: \"<<rem<<endl;\n        int const n = idx.size();\n        if (i >= n) return rem == 0 ? 0 : MOD;\n        else if (dp[i][rem] != -1) return dp[i][rem];\n        else\n        {\n            int take = MOD;\n            if (rem >= queries[idx[i]][2]) take = max(idx[i], rec(queries, dp, idx, i + 1, rem - queries[idx[i]][2]));\n            \n            int nottake = rec(queries, dp, idx, i + 1, rem);\n            \n            return dp[i][rem] = min(take, nottake);\n        }\n    }\n    \n    int findix(vector<vector<int>>& queries, vector<int> &idx, int const val)\n    { // solving for ix in nums, find earliest index to make it possible;\n        int const n = idx.size();\n        vector<vector<int>> dp(n + 1, vector<int>(val + 1, -1));        \n        int ix = rec(queries, dp, idx, 0, val);\n        \n        // cout<<ix<<endl;\n        \n        return ix;        \n    }\n    \n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries)\n    {\n        int const n = nums.size(), q = queries.size();\n        vector<vector<int>> idx(n);\n        \n        for (int qi = 0; qi <= q - 1; qi++)\n        {\n            for (int i = queries[qi][0]; i <= queries[qi][1]; i++) idx[i].push_back(qi);\n        }\n        \n        int ans = 0;\n        for (int i = 0; i <= n - 1; i++)\n        {\n            if (!nums[i]) continue; // already zero, ignore\n            \n            int ix = findix(queries, idx[i], nums[i]);\n            if (ix >= q) return -1; // not possible;\n            \n            ans = max(ans, ix + 1);\n        }\n\n        return ans;\n    }\n};","author":"lakkshyag","submissionId":"1575189825"},[]]},{"733":[{"id":"733","fileName":"1575189842.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        max_k = 0\n        for i, num in enumerate(nums):\n            vals = set([num])\n            k = 0\n            if num == 0:\n                continue\n            for l, r, d in queries:\n                k += 1\n                if r < i or l > i:\n                    continue\n                v2 = set()\n                for val in vals:\n                    if val < d:\n                        continue\n                    v2.add(val - d)\n                vals |= v2\n                if 0 in vals:\n                    break\n            if 0 not in vals:\n                return -1\n            max_k = max(max_k, k)\n        return max_k\n        ","author":"bogdansharpy","submissionId":"1575189842"},[]]},{"734":[{"id":"734","fileName":"1575189939.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        idx_vals = defaultdict(list)\n\n        for i in range(len(queries)):\n            l, r, val = queries[i]\n\n            for j in range(l, r+1):\n                if nums[j] >= val:\n                    idx_vals[j].append((val, i))\n\n        # print(idx_vals)\n        \n        max_idx = -1\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                continue\n            if len(idx_vals[i]) == 0:\n                return -1\n\n            min_idx = inf\n            tmp_set = set()\n\n            for j in range(len(idx_vals[i])):\n                val, qi = idx_vals[i][j]\n                # print(j, val, qi)\n                if val == nums[i]:\n                    min_idx = qi\n                    break\n                else:\n                    new_set = set()\n                    flag = False\n                    for x in tmp_set:\n                        new_val = val+x\n                        if new_val == nums[i]:\n                            min_idx = qi\n                            flag = True\n                            break\n                        new_set.add(new_val)\n                    tmp_set.update(new_set)\n                    tmp_set.add(val)\n                    if flag:\n                        break\n\n            if min_idx == inf:\n                return -1\n            max_idx = max(max_idx, min_idx)\n\n        return max_idx + 1\n        \n        ","author":"ShadowLau","submissionId":"1575189939"},[]]},{"735":[{"id":"735","fileName":"1575189928.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        n = len(nums)\n\n        out = 0\n        for i in range(n):\n            must = self.gett(queries, i, nums[i])\n            # print(f\"i{i}, must{must}\")\n            if must == -1:\n                return -1\n            out = max(out, must)\n        return out\n\n    def gett(self, queries, i, goal_num):\n        \n        @cache\n        def dp(amount_rem, qpos):\n\n            if amount_rem == 0:\n                return qpos\n            if qpos == len(queries) or amount_rem < 0:\n                return -1\n            \n\n            # try to not choose this num\n            hr = dp(amount_rem, qpos+1)\n            \n            l, r, val = queries[qpos]\n            if l<=i<=r:\n                # option to choose this num\n                btr = dp(amount_rem-val, qpos+1)\n                # choose smaller that is not -1\n                if min(hr,btr) != -1:\n                    return min(hr,btr)\n                return max(hr,btr)\n            else:\n                return hr\n                \n                \n\n            \n\n        return dp(goal_num, 0)","author":"Xander Gardner","submissionId":"1575189928"},[]]},{"736":[{"id":"736","fileName":"1575190026.txt","sourceCode":"class Solution {\n    public boolean isPossible(int[] nums , int K , int[][] queries){\n        int n = nums.length;\n        int q = queries.length;\n        boolean[][] dp = new boolean[n][1200];\n        \n        for (int i = 0 ; i < n ;i++)\n            dp[i][nums[i]] = true;\n        \n        for (int i = 0 ; i <=K ; i++){\n            boolean[][] ndp = new boolean[n][1200];\n            for (int j= 0 ; j < n ; j++)\n                for (int k = 0 ; k < 1200  ; k++)\n                    ndp[j][k]  = dp[j][k];\n                \n            int val = queries[i][2];\n            int l = queries[i][0];\n            int r = queries[i][1];\n            \n            for (int b = l ; b<=r ; b++){\n                for (int v = 0 ; v<1200 ; v++){\n                    if (v - val>=0 && dp[b][v])\n                        ndp[b][v-val] = true;\n                }\n            }\n            int cnt = 0;\n            for (int b = 0 ; b<n ; b++){\n                if (ndp[b][0])\n                    cnt++;\n            }\n            for (int j = 0 ; j < n ; j++)\n                for (int k = 0 ; k < 1200 ; k++)\n                    dp[j][k] = ndp[j][k];\n            if (cnt==n)\n                return true;\n        }\n        return false;\n    }\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int q = queries.length;\n        int l = 0 , r = q - 1;\n        int ans = q;\n        boolean z = true;\n        for (int i = 0 ; i < nums.length ; i++){\n            if (nums[i]!=0)\n                z = false;\n        }\n        if (z)\n            return 0;\n        while(l<=r){\n            int mid = (l + r)/2;\n            if (isPossible(nums , mid , queries)){\n                ans = Math.min(ans , mid);\n                r = mid - 1;\n            }\n            else\n                l = mid + 1;\n        }\n        if (ans==q)\n            return -1;\n        \n        return ans + 1;\n        \n    }\n}","author":"SATYAJEET","submissionId":"1575190026"},[]]},{"737":[{"id":"737","fileName":"1575190186.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        @cache\n        def dfs(i, j, s):\n            if s == 0: return i\n            if i == len(queries): return inf\n            l, r, v = queries[i]\n            res = dfs(i + 1, j, s)\n            if s >= v and l <= j <= r:\n                res = min(res, dfs(i + 1, j, s - v))\n            return res\n\n        res = 0\n        for j in range(len(nums)):\n            res = max(res, dfs(0, j, nums[j]))\n            dfs.cache_clear()\n        return -1 if res == inf else res","author":"kwrefs","submissionId":"1575190186"},[]]},{"739":[{"id":"739","fileName":"1575190225.txt","sourceCode":"class Solution {\npublic:\n    // int fun1(int val,vector<int> &arr,int i,vector<vector<int>> &dp){\n    //     if(val == 0) return 1;\n    //     if(i == arr.size()) return 0;\n    //     if(dp[i][val]!=-1) return dp[i][val];\n    //     bool ans = 0;\n    //     ans |= fun1(val-arr[i],arr,i+1,dp);\n    //     ans |= fun1(val,arr,i+1,dp);\n    //     return dp[i][val] = ans;\n    // }\n    // bool fun(int val,vector<int>&arr){\n    //     vector<vector<int>> dp(arr.size()+1,vector<int>(val+1,-1));\n    //     return fun1(val,arr,0,dp);\n    // }\n    bool fun(int val, vector<int>& arr) {\n    int n = arr.size();\n    vector<vector<int>> dp(n + 1, vector<int>(val + 1, 0));\n    for (int i = 0; i <= n; i++) dp[i][0] = 1;\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = 0; j <= val; j++) {\n            bool ans = dp[i + 1][j]; \n            if (j >= arr[i]) ans |= dp[i + 1][j - arr[i]]; \n            dp[i][j] = ans;\n        }\n    }\n\n    return dp[0][val];\n}\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int l = 1,r=(int)queries.size();\n        if(count(nums.begin(),nums.end(),0) == n) return 0;\n        int ans = -1;\n        auto check=[&](int mid)->bool{\n            vector<vector<int>> pos(n+1);\n            for(int i=0;i<mid;i++){\n                for(int j=queries[i][0];j<=queries[i][1];j++){\n                    pos[j].push_back(queries[i][2]);\n                }\n            }\n            // if(mid == 4){\n            //     for(auto &ele:pos[0]) cout<<ele<<\" \"; cout<<endl;\n            // }\n            bool flag = 1;\n            // cout<<mid<<endl;\n            for(int i=0;i<n;i++){\n                flag&=fun(nums[i],pos[i]);\n            }\n            return flag;\n        };\n        while(l<=r){\n            int mid = l + (r-l)/2;\n            if(check(mid)) {ans= mid; r = mid-1;}\n            else l = mid+1;\n        }\n        return ans;\n    }\n};","author":"Hritik Anand","submissionId":"1575190225"},[]]},{"740":[{"id":"740","fileName":"1575189964.txt","sourceCode":"class Solution {\npublic:\n\n    int dp[1001][1001];\n    vector<vector<int>>q;\n    int N;\n    int solve(int i , int j , int &id) {\n        if(i < 0) {\n            return 1e9;\n        }\n        if(i == 0) {\n            return j;\n        }\n        if(j == N) {\n            return 1e9;\n        }\n        if(dp[i][j] != -1) return dp[i][j];\n\n        int ans = 1e9;\n        ans = min(ans,solve(i,j+1,id));\n\n        int L = q[j][0];\n        int R = q[j][1];\n        int val = q[j][2];\n        if(L <= id && R >= id) {\n            ans = min(ans,solve(i-val,j+1,id));\n        }\n\n        return dp[i][j] = ans;\n        \n    }\n\n    int minZeroArray(vector<int>& a, vector<vector<int>>& _q) {\n        q = _q;\n        int n = (int)a.size();\n        int ans = 0;\n        N = (int)q.size();\n        for(int i = 0 ; i < n ; i++) {\n            int x = a[i];\n            if(x == 0) {\n                continue;\n            }\n            for(int j = 0 ; j <= x ; j++) {\n                for(int k = 0 ; k <= N ; k++) {\n                    dp[j][k] = -1;\n                }\n            }\n\n            int can = solve(x,0,i);\n            ans = max(ans,can);\n        }\n        if(ans > N) {\n            return -1;\n        }\n        return ans;\n    }\n};","author":"Soutik Dey","submissionId":"1575189964"},[]]},{"741":[{"id":"741","fileName":"1575190310.txt","sourceCode":"class Solution {\n    int[][] cache;\n    \n    private int steps(int[][] queries, int i, int idx, int sum) {\n        if(sum == 0)  return i;\n        else if(i >= queries.length) return Integer.MAX_VALUE;\n        else if(cache[i][sum] > 0) return cache[i][sum];\n\n        // System.out.println(i  + \" \" + sum);\n        \n        int l = queries[i][0];\n        int r = queries[i][1];\n        int val = queries[i][2];\n\n        int min = Integer.MAX_VALUE;\n        if(idx >= l && idx <= r && (sum - val) >= 0) {\n            min = steps(queries, i + 1, idx, sum - val);\n        }\n        min = Math.min(min, steps(queries, i + 1, idx, sum));\n\n        cache[i][sum] = min;\n\n        return min;\n    }\n    \n    public int minZeroArray(int[] nums, int[][] queries) {\n        int max = 0;\n        for(int i = 0; i < nums.length; i++) {\n            cache = new int[1001][1001];\n            int result = steps(queries, 0, i, nums[i]);\n            if(result == Integer.MAX_VALUE) return -1;\n            max = Math.max(result, max);\n        }\n\n        return max;\n    }\n}","author":"Lovepreet Singh","submissionId":"1575190310"},[]]},{"742":[{"id":"742","fileName":"1575190510.txt","sourceCode":"const int INF = (int)1e9;\n\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        auto v = nums;\n        int n = v.size();\n        int ans = 0; \n        for (int i = 0; i < n; i++) {\n            vector <int> dp(v[i] + 1);\n            dp[0] = 1;\n            if (v[i] == 0) {\n                continue;\n            }\n            \n            int cnt = 1;\n            bool ok = false;\n            \n            for (auto it : queries) {\n                int l = it[0], r = it[1], val = it[2];\n                if (i >= l && r >= i) {\n                    for (int j = v[i] - 1; j >= 0; j--) {\n                        if (j + val <= v[i]) {\n                            dp[j + val] |= dp[j];\n                        }\n                    }\n                }\n                \n                if (dp[v[i]]) {\n                    ok = true;\n                    break;\n                }\n                cnt++;\n            }\n            \n            if (!ok) {\n                return -1;\n            }\n            \n            ans = max(ans, cnt);\n        }\n        \n        return ans;\n    }\n};","author":"Ineesh","submissionId":"1575190510"},[]]},{"743":[{"id":"743","fileName":"1575190357.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums, queries):\n        n = len(nums)\n        dp_state = [{} for _ in range(n)]\n        for i in range(n):\n            dp_state[i][0] = True\n        if sum(nums) == 0:\n            return 0\n\n        for idx, (l, r, v) in enumerate(queries):\n            for i in range(l, r + 1):\n                new_values = set()\n                for key in dp_state[i]:\n                    new_values.add(key + v)\n\n                for val in new_values:\n                    if val <= nums[i]:\n                        dp_state[i][val] = True\n            if all(nums[i] in dp_state[i] for i in range(n)):\n                return idx + 1  \n        return -1\n","author":"Dhoni 25","submissionId":"1575190357"},[]]},{"744":[{"id":"744","fileName":"1575190218.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        dp = [[False]*(num+1) for num in nums]\n        unfinished = set(range(n))\n        for idx,num in enumerate(nums):\n            if num==0:\n                unfinished.remove(idx)\n            dp[idx][0] = True\n        \n        if not unfinished:\n            return 0\n        \n        for k, (L,R,val) in enumerate(queries, 1):\n            for idx in range(L,R+1):\n                if idx not in unfinished:\n                    continue\n                num = nums[idx]\n                arr = dp[idx]\n                lazyLst = []\n                for i,b in enumerate(arr):\n                    if b:\n                        if i+val>=num:\n                            if i+val==num:\n                                arr[-1] = True\n                                unfinished.remove(idx)\n                                lazyLst = []\n                            break\n                        # else:\n                        lazyLst.append(i+val)\n                for i in lazyLst:\n                    arr[i] = True\n            if not unfinished:\n                return k\n            \n        return -1","author":"yinboshi13","submissionId":"1575190218"},[]]},{"745":[{"id":"745","fileName":"1575190645.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        int ans = INT_MAX;\n        //each element in nums will have a knapsack to take from\n        //for each knapsack, find if its possible to make it zero\n        auto possible = [&](int x)->bool{\n            //we take the first x queries\n            vector<vector<int>> v(n);\n            for(int i=0;i<x;i++){\n                int left = queries[i][0], right = queries[i][1], val = queries[i][2];\n                for(int j=left;j<=right;j++){\n                    v[j].push_back(val);\n                }\n            }\n            for(int i=0;i<n;i++){\n                vector<bool> dp(nums[i]+1,false);\n                dp[0]=true;\n                for(auto&it:v[i]){\n                    for(int j=nums[i];j>=it;j--){\n                        dp[j]=(dp[j]|dp[j-it]);\n                    }\n                }\n                if(!dp[nums[i]]) return false;\n            }\n            return true;\n        };\n        int l = 0, r = m;\n        while(l<=r){\n            int x = (l+r)/2;\n            if(possible(x)){\n                ans = x;\n                r = x - 1;\n            }else{\n                l = x + 1;\n            }\n        }\n        if(ans==INT_MAX)\n            return -1;\n        return ans;\n    }\n};","author":"Dipjoy Basak","submissionId":"1575190645"},[]]},{"746":[{"id":"746","fileName":"1575190518.txt","sourceCode":"from collections import defaultdict\nimport bisect\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        \n        def feasible(k):\n            for i in range(n):\n                target = nums[i]\n                if target == 0:\n                    continue\n                \n                coins = []\n                for j in range(k):\n                    l, r, v = queries[j]\n                    if l <= i <= r:\n                        coins.append(v)\n                \n\n                dp = 1  \n                mask = (1 << (target + 1)) - 1\n                for coin in coins:\n                    dp |= dp << coin  \n                    dp &= mask        \n                    if dp & (1 << target):\n                        break\n                if not (dp & (1 << target)):\n                    return False\n            return True\n    \n        if all(x == 0 for x in nums):\n            return 0\n    \n        lo, hi = 1, m + 1\n        ans = -1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if feasible(mid):\n                ans = mid\n                hi = mid\n            else:\n                lo = mid + 1\n        return ans if ans != -1 and ans <= m else -1\n","author":"brightgyung","submissionId":"1575190518"},[]]},{"747":[{"id":"747","fileName":"1575190668.txt","sourceCode":"\n#define ff first\n#define ss second\n#define all(x) (x).begin(), (x).end()\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nclass Solution {\npublic:\n\n    int fun(ll in, ll targ, vector<pair<ll,ll>>&vec){\n        if(targ==0){\n            return 0;\n        }\n        unordered_set<ll>st;\n        st.insert(targ);\n        for(ll i=0;i<vec.size();i++){\n            unordered_set<ll>nst;\n            for(ll x:st){\n                ll numb=x-vec[i].ff;\n                if(numb==0){\n                    return vec[i].ss;\n                }\n                if(numb>0){\n                    nst.insert(numb);\n                }\n            }\n            st.insert(all(nst));\n        }\n        return 50000;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int ans=0;\n        int sz=nums.size();\n        vector<vector<pair<ll,ll>>>gr(sz,vector<pair<ll,ll>>(0));\n        for(int i=0;i<q.size();i++){\n            for(int j=q[i][0];j<=q[i][1];j++){\n                gr[j].push_back({q[i][2],i+1});\n            }\n        }\n        for(ll i=0;i<nums.size();i++){\n            ans=max(ans,fun(i,nums[i],gr[i]));\n        }\n        if(ans==50000){\n            return -1;\n        }else{\n            return ans;\n        }\n    }\n};","author":"jai_hanumant","submissionId":"1575190668"},[]]},{"748":[{"id":"748","fileName":"1575190694.txt","sourceCode":"class Solution {\n    vector<vector<int>>Q;\n    uint cc(int p,int t){\n        bitset<1024>d;d.set(0);int rr=0;\n        for(auto&q:Q){\n            if(d[t])break;\n            ++rr;if(q[0]<=p&&p<=q[1])d|=d<<q[2];\n        }\n        return d[t]?rr:-1;\n    }\npublic:\n    int minZeroArray(vector<int>& x, vector<vector<int>>&_Q) {\n        uint RR=0;Q=move(_Q);\n        for(int i=0;i<x.size();++i){\n            RR=max(RR,cc(i,x[i]));\n        }\n        return RR;\n    }\n};","author":"rip.nsk","submissionId":"1575190694"},[]]},{"749":[{"id":"749","fileName":"1575190735.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<vector<int>>vec = queries;\n\n        auto solve = [&](int k)->bool{ //lambda define first k queries check karne ke liye\n            for(int i=0;i<n;i++){\n                int t = nums[i];\n                if(t==0){ //agar target 0 hai subtraction not needed\n                    continue;\n                }\n                vector<int>avail;\n                for(int j=0;j<k;j++){\n                    int l = vec[j][0];\n                    int r = vec[j][1];\n                    int val = vec[j][2];\n                    if(l<=i && i<=r){ // check karna hai idx i range me hai [l,r]\n                        avail.push_back(val);\n                    }\n                }\n                vector<bool>dp(t+1,false);\n                dp[0] = true;\n                for(int idx = 0;idx<avail.size();idx++){\n                    int qVal = avail[idx];\n                    for(int s = t;s>=qVal;s--){\n                        if(dp[s-qVal]){\n                            dp[s] = true;\n                        }\n                    }\n                }\n                if(!dp[t])\n                    return false;\n            }\n            return true;\n        };\n        //binary search\n        int low = 0,high = m+1;\n        while(low<high){\n            int mid = low + (high-low)/2;\n            if(solve(mid)){\n                high= mid;\n            }else{\n                low = mid+1;\n            }\n        }\n        if(low==m+1)\n            return -1;\n        return low;\n    }\n};","author":"Anshuman_coder01","submissionId":"1575190735"},[]]},{"750":[{"id":"750","fileName":"1575190807.txt","sourceCode":"class Solution {\npublic:\n\n    bool isSubsetSum(vector<int> &arr, int sum){\n        int n = arr.size();\n        if(!n) return (sum == 0);\n        if(!sum) return 1;\n        vector<bool> prev(sum + 1, 0), cur(sum + 1, 0);\n        prev[0] = cur[0] = 1;\n        prev[arr[0]] = 1;\n        \n        for(int i = 1; i < n; i++){\n            for(int tar = 1; tar <= sum; tar++){\n                \n                bool take = 0, not_take = 0;\n                if(prev[tar]) not_take = 1;\n                if(tar >= arr[i] && prev[tar - arr[i]]) take = 1;\n                \n                cur[tar] = (take | not_take);\n            }\n            prev = cur;\n        }\n        return prev[sum];\n    }\n    int minZeroArray(vector<int>& v, vector<vector<int>>& query) {\n        int n = v.size(), q = query.size();\n\n        auto check = [&] (int len) -> bool {\n            vector<vector<int>> u(n);\n            for(int i = 0; i <= len; i ++){\n                int l = query[i][0], r = query[i][1], val = query[i][2];\n                for(int j = l; j <= r; j ++){\n                    u[j].push_back(val);\n                }\n            }\n            for(int i = 0; i < n; i++){\n                if(!isSubsetSum(u[i], v[i])) return false;\n            }\n            return true;\n        };\n        int c = 0;\n        for(int i = 0; i < n; i ++) if(v[i] == 0) c ++;\n        if(c == n) return 0;\n        int lo = 0, hi = q - 1, m, ans = -1;\n        while(lo <= hi){\n            m = lo + (hi - lo) / 2;\n            if(check(m)) {\n                ans = m;\n                hi = m - 1;\n            }\n            else lo = m + 1;\n        }\n        return (ans == -1 ? ans : ans + 1);\n    }\n};","author":"Rounak Kumar","submissionId":"1575190807"},[]]},{"751":[{"id":"751","fileName":"1575190714.txt","sourceCode":"class Solution {\n    static int dp[][];\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int q = queries.length;\n        int low = 0; int high = q; int ans=  -1;\n        while(low<=high)\n        {\n            int mid = (low+high)/2;\n            if(f(nums,n,queries,mid))\n            {\n                ans = mid;\n                high = mid-1;\n            }\n            else \n            {\n                low = mid+1;\n            }\n        }\n        return ans;\n    }\n    public boolean f(int nums[], int n, int queries[][], int k)\n    {\n        int red[][] = new int[n][11];\n        for(int i=0;i<k;i++)\n        {\n            int l = queries[i][0]; int r = queries[i][1]; int val = queries[i][2];\n            for(int j=l;j<=r;j++)\n            {\n                red[j][val]++;\n            }\n        }\n        // if(k==2)\n        // {\n        //     // System.out.println(\"YES\");\n        //     for(int i=0;i<n;i++)\n        //     {\n        //       for(int j=0;j<=2;j++)\n        //       {\n        //           System.out.print(red[i][j]+\" \");\n        //       }\n        //        System.out.println(); \n        //     }\n        // }\n        for(int i=0;i<n;i++)\n        {\n            dp = new int[11][nums[i]+1];\n            for(int j=0;j<=10;j++) Arrays.fill(dp[j],-1);\n            int ret = f(red[i],11,0,nums[i]);\n            if(ret==0) return false;\n        }\n        return true;\n    }\n    public int f(int a[], int n, int i,int sum)\n    {\n        if(sum==0) return 1;\n        if(i==n)\n        {\n            return 0;\n        }\n        if(dp[i][sum]!=-1) return dp[i][sum];\n        int cnt = a[i];\n        for(int j=0;j<=cnt;j++)\n        {\n            if(j*i>sum) break;\n            int ret = f(a,n,i+1,sum-j*i);\n            if(ret==1) return dp[i][sum] = 1;\n        }\n        return dp[i][sum] = 0;\n    }\n}","author":"TulasiRaj","submissionId":"1575190714"},[]]},{"752":[{"id":"752","fileName":"1575190250.txt","sourceCode":"class Solution {\npublic:\n    int solve(vector<vector<int>>& queries, int i, int target, int k, vector<vector<int>>& dp){\n        if(target == 0) return k;\n        if(k >= queries.size() || target < 0) return queries.size() + 1;\n        if(dp[target][k] != -1) return dp[target][k];\n        int res = solve(queries, i, target, k+1, dp);\n        if(queries[k][0] <= i && i <= queries[k][1]) res = min(res, solve(queries, i, target - queries[k][2], k+1, dp));\n        return dp[target][k] = res;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = -1;\n        for(int i = 0; i < nums.size(); ++i){\n            vector<vector<int>> dp(nums[i]+1, vector<int>(queries.size() +1, -1));\n            int res = solve(queries, i, nums[i], 0, dp);\n            if(res > queries.size()) return -1;\n            ans = max(ans, res);\n        }\n        return ans;\n    }\n};","author":"Kishan Kumar Patel","submissionId":"1575190250"},[]]},{"753":[{"id":"753","fileName":"1575190811.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> minForEachNum = vector<int>(n, -1);\n        for(int i = 0; i < n; ++i) {\n            int targetNum = nums[i];\n            unordered_set<int> possible;\n            unordered_set<int> temp_possible;\n            if(targetNum == 0) {\n                minForEachNum[i] = 0;\n                continue;\n            }\n            for(int j = 0; j < queries.size(); ++j) {\n                vector<int>& query = queries[j];\n                int l  = query[0];\n                int r = query[1];\n                int val = query[2];\n                if(l <= i && i <= r) {\n                    for(auto x: possible) {\n                        temp_possible.insert(x);\n                        temp_possible.insert(x+val);\n                    }\n                    temp_possible.insert(val);\n                    swap(possible, temp_possible);\n                    temp_possible.clear();\n                }\n                if(possible.count(targetNum) > 0) {\n                    minForEachNum[i] = j + 1;\n                    break;\n                }\n                // cout << j << \": \";\n                // for(auto x: possible) {\n                //     cout << x << \" \";\n                // }\n                // cout << endl;\n            }\n        }\n        int ans = -1;\n\n        // for(auto x: minForEachNum) {\n        //     cout << x << \" \";\n        // }\n        \n        for(auto x: minForEachNum) {\n            if(x == -1) {\n                return -1;\n            }\n            ans = max(ans, x);\n        }\n        return ans;\n    }\n};\n\n// exactly k operation --> \n\n// element one by one: given a number, and find the minimum possible queries\n\n// special dp on the possible number that could be achieved?\n// O(n)\n\n// Consider the number one by one.","author":"choiivan13","submissionId":"1575190811"},[]]},{"754":[{"id":"754","fileName":"1575190810.txt","sourceCode":"impl Solution {\n    pub fn min_zero_array(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> i32 {\n        let mut state = vec![vec![false; 1001]; nums.len()];\n        let mut count = 0;\n        for i in 0..nums.len() {\n            state[i][nums[i] as usize] = true;\n            if nums[i] == 0 {\n                count += 1;\n            }\n        }\n        if count == nums.len() {\n            return 0;\n        }\n        for i in 0..queries.len() {\n            let l = queries[i][0] as usize;\n            let r = queries[i][1] as usize;\n            let val = queries[i][2] as usize;\n            for j in l..=r {\n                if !state[j][0] {\n                    for num in 0..=1000 - val {\n                        state[j][num] = state[j][num] || state[j][num + val];\n                    }\n                    if state[j][0] {\n                        count += 1;\n                    }\n                }\n            }\n            if count == nums.len() {\n                return i as i32 + 1;\n            }\n        }\n        -1\n    }\n}\n","author":"WHMHammer","submissionId":"1575190810"},[]]},{"755":[{"id":"755","fileName":"1575190921.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if all([i == 0 for i in nums]):\n            return 0\n        \n        dp = []\n        for i in range(len(nums)):\n            dp.append([0]*(nums[i]+1))\n            dp[i][nums[i]] = 1\n        \n        k = 0\n        for query in queries:\n            k += 1\n            l, r, val = query\n            for i in range(l, r+1):\n                for j in range(val, nums[i]+1):\n                    if dp[i][j]:\n                        dp[i][j-val] = 1\n\n            all_zero = True\n            for i in range(len(nums)):\n                if dp[i][0] == 0:\n                    all_zero = False\n                    break\n\n            if all_zero:\n                return k\n\n        return -1\n                \n        \n        ","author":"ApoapsisAlpha","submissionId":"1575190921"},[]]},{"756":[{"id":"756","fileName":"1575190980.txt","sourceCode":"class Solution {\n    public boolean binary(int[] nums, int k,int[][] queries){\n        int n=nums.length;\n        for(int i=0;i<n;i++){\n            int tar=nums[i];\n            boolean[] dp=new boolean[tar+1];\n            dp[0]=true;\n            for(int j=0;j<k;j++){\n                if(queries[j][0]<=i && i<=queries[j][1]){\n                    int val=queries[j][2];\n                    for(int l=tar;l>=val;l--){\n                        if(dp[l-val]) dp[l]=true;\n                    }\n                }\n            }\n            if(!dp[tar]) return false;\n        }\n        \n        return true;\n    }\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int st=0,end=queries.length;\n        int[][] temp=queries;\n        int ans=-1;\n        while(st<=end){\n            int mid=st+(end-st)/2;\n            if(binary(nums,mid,temp)){\n                ans=mid;\n                end=mid-1;\n            }\n            else{\n                st=mid+1;\n            }\n        }\n        return ans;\n    }\n}","author":"Sachin Singh Rajawat","submissionId":"1575190980"},[]]},{"757":[{"id":"757","fileName":"1575191037.txt","sourceCode":"class Solution {\npublic:\n    unordered_map<int, unordered_map<int, int>> memo; // 记忆化搜索表\n\n    int dfs(int x, vector<int>& vals, int index, vector<vector<int>>& q) {\n        if (x == 0) return vals[index-1];  // 找到最早使 x 变为 0 的索引\n        if (index >= vals.size()) return INT_MAX;  // 结束遍历，未找到\n        \n        if (memo.count(x) && memo[x].count(index)) return memo[x][index]; // 记忆化\n\n        int res = INT_MAX;\n        int minus = q[vals[index]][2];\n\n        // 选择减去当前值\n        if (x >= minus) {\n            res = min(res, dfs(x - minus, vals, index + 1, q));\n        }\n\n        // 选择跳过当前值\n        res = min(res, dfs(x, vals, index + 1, q));\n\n        return memo[x][index] = res;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n        vector<vector<int>> vals(n, vector<int>());\n\n        for(int i = 0; i < q.size(); ++i) {\n            int l = q[i][0], r = q[i][1];\n            for(int j = l; j <= r; ++j){\n                vals[j].push_back(i);\n            }\n        }\n\n        int ans = -1;\n        for(int i = 0; i < n; ++i) {\n            if(nums[i] == 0) {\n                ans = max(ans, 0);\n                continue;\n            }\n            memo.clear(); // 每次计算不同的 `nums[i]` 时，清空 memo\n            int res = dfs(nums[i], vals[i], 0, q);\n            if(res == INT_MAX) return -1;\n            ans = max(ans, res + 1);\n        }\n\n        return ans;\n    }\n};\n","author":"Jialuo Yuan","submissionId":"1575191037"},[]]},{"758":[{"id":"758","fileName":"1575191173.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n\n        def can_form_subset_sum(vals, target):\n            if target < 0:\n                return False\n            reachable = {0}\n            for v in vals:\n                new_set = set(reachable)  \n                for s in reachable:\n                    s2 = s + v\n                    if s2 == target:\n                        return True\n                    if s2 < target:\n                        new_set.add(s2)\n                reachable = new_set\n                if target in reachable:\n                    return True\n            return (target in reachable)\n        def feasible(k: int) -> bool:\n            coverage_vals = [[] for _ in range(n)]\n            for i in range(k):\n                l, r, val = queries[i]\n                for j in range(l, r + 1):\n                    coverage_vals[j].append(val)\n            for j in range(n):\n                if not can_form_subset_sum(coverage_vals[j], nums[j]):\n                    return False\n            return True\n        for k_ in range(m + 1):\n            if feasible(k_):\n                return k_\n        return -1\n            ","author":"maky","submissionId":"1575191173"},[]]},{"759":[{"id":"759","fileName":"1575191066.txt","sourceCode":"class Solution:\n    def minZeroArray(self, temp: List[int], queries: List[List[int]]) -> int:\n        n = len(temp)\n        m = len(queries)\n\n        if all(temp[i] == 0 for i in range(n)):\n            return 0\n\n        max_val = max(temp)\n        dp = [[False] * (max_val+1) for i in range(n)]\n\n        for i in range(n):\n            dp[i][temp[i]] = True\n            \n        # def helper(k):\n        #     dp2 = [row[:] for row in dp]\n\n        #     for i in range(k):\n        #         l, r, val = queries[i]\n\n        #         for j in range(l, r + 1):\n        #             for m in range(1000, val - 1, -1):\n        #                 if dp2[j][m]:\n        #                     dp2[j][m - val] = True\n\n        #     return all(dp2[i][0] == True for i in range(n))\n\n        # start = 0\n        # end = m\n        # ans = -1\n        # while start <= end:\n        #     mid = (start + end) // 2\n        #     if helper(mid):\n        #         ans = mid\n        #         end = mid - 1\n        #     else:\n        #         start = mid + 1\n\n        for i in range(m):\n            dp2=[row[:] for row in dp]\n            l, r, val = queries[i]\n\n            for j in range(l, r + 1):\n                for m in range(max_val, val - 1, -1):\n                    if dp[j][m]:\n                        dp2[j][m - val] = True\n\n            if all(dp2[i][0] == True for i in range(n)):\n                return i + 1\n            \n            dp=[row[:] for row in dp2]\n        return -1\n","author":"Harish Ramaswamy","submissionId":"1575191066"},[]]},{"760":[{"id":"760","fileName":"1575191183.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        dp = {i: set([x]) for i, x in enumerate(nums) if x > 0}\n        if not dp:\n            return 0\n        \n        for i, (l, r, val) in enumerate(queries):\n            for j in range(l, r+1):\n                if j in dp:\n                    tmp = set()\n                    for k in dp[j]:\n                        if k - val == 0:\n                            del dp[j]\n                            break\n                        if k - val > 0:\n                            tmp.add(k-val)\n                    if j in dp:\n                        dp[j] |= tmp\n\n            if not dp:\n                return i + 1\n        return -1","author":"chris850327","submissionId":"1575191183"},[]]},{"761":[{"id":"761","fileName":"1575191295.txt","sourceCode":"\n\nconst int inf = 1000;\n\nbool dp[11][inf + 1][inf + 1] = {};\n\nclass Solution {\npublic:\n\t\t\n\tbool contains(int idx, vector<int>& q) {\n\t\treturn q[0] <= idx && idx <= q[1];\n\t}\n\n\tint minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\t\tint n = nums.size(), q = queries.size();\n\n\t\tfor (int idx = 0; idx < n; idx++) {\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tfor (int val = 0; val <= inf; val++) {\n\t\t\t\t\tif (val == 0) {\n\t\t\t\t\t\tdp[idx][i][val] = 1;\n\t\t\t\t\t} else if (contains(idx, queries[i])) {\n\t\t\t\t\t\tdp[idx][i][val] = queries[i][2] == val;\n\t\t\t\t\t\tif (i && !dp[idx][i][val]) {\n\t\t\t\t\t\t\tdp[idx][i][val] = dp[idx][i - 1][val];\n\t\t\t\t\t\t\tif (!dp[idx][i][val] && queries[i][2] <= val) {\n\t\t\t\t\t\t\t\tdp[idx][i][val] = dp[idx][i - 1][val - queries[i][2]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[idx][i][val] = 0;\n\t\t\t\t\t\tif (i) dp[idx][i][val] = dp[idx][i - 1][val];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (count(nums.begin(), nums.end(), 0) == n) return 0;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tbool isOkay = 1;\n\t\t\tfor (int idx = 0; idx < n; idx++) {\n\t\t\t\tif (!dp[idx][i][nums[idx]]) {\n\t\t\t\t\tisOkay = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isOkay) return i + 1;\n\t\t}\n\t\treturn -1;\n\t}\n};","author":"PHUC","submissionId":"1575191295"},[]]},{"762":[{"id":"762","fileName":"1575191231.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        already_zero = all(num == 0 for num in nums)\n        if already_zero:\n            return 0\n\n        available = [[] for _ in range(n)]\n        for j, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                available[i].append((j, val))\n\n        low, high, answer = 1, len(queries), -1\n        while low <= high:\n            mid = (low + high) // 2\n            if self.can_zero(nums, available, mid):\n                answer = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        return answer\n\n    def can_zero(self, nums: List[int], available: List[List[tuple[int, int]]], k: int) -> bool:\n        for i, target in enumerate(nums):\n            dp = [False] * (target + 1)\n            dp[0] = True\n            for op in available[i]:\n                if op[0] < k:\n                    val = op[1]\n                    for s in range(target, val - 1, -1):\n                        if dp[s - val]:\n                            dp[s] = True\n            if not dp[target]:\n                return False\n        return True\n        ","author":"Ragul","submissionId":"1575191231"},[]]},{"763":[{"id":"763","fileName":"1575191233.txt","sourceCode":"\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length, q = queries.length;\n        int loW = 0, higH = q, optimal = -1;\n\n        while (loW <= higH) {\n            int mid = loW + (higH - loW) / 2;\n            if (canReduceToZero(nums, queries, n, mid)) {\n                optimal = mid;\n                higH = mid - 1;\n            } else {\n                loW = mid + 1;\n            }\n        }\n        return optimal;\n    }\n\n    private boolean canReduceToZero(int[] nums, int[][] queries, int n, int limit) {\n        for (int index = 0; index < n; index++) {\n            Set<Integer> possibleSums = new HashSet<>();\n            possibleSums.add(0);\n\n            for (int i = 0; i < limit; i++) {\n                int start = queries[i][0];\n                int end = queries[i][1];\n                int decrement = queries[i][2];\n\n                if (index >= start && index <= end) {\n                    List<Integer> tempSums = new ArrayList<>(possibleSums);\n                    for (int sum : tempSums) {\n                        possibleSums.add(sum + decrement);\n                    }\n                }\n            }\n            if (!possibleSums.contains(nums[index])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n","author":"Karan Kumar Singh","submissionId":"1575191233"},[]]},{"764":[{"id":"764","fileName":"1575191335.txt","sourceCode":"class Solution {\npublic:\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& que) {\n        int n = nums.size();\n        int q = que.size();\n\n        int maxi = *max_element(nums.begin(), nums.end());\n        if(!maxi) return 0;\n\n        vector<vector<int>> dp(n + 1, vector<int>(1001, 0));\n\n        for(int j = 0; j < n; j++){\n            dp[j][0] = 1;\n        }\n        int ind = 0;\n        while(q--){\n            int l = que[ind][0], r = que[ind][1], val = que[ind][2];\n            for(int j = l; j <= r; j++){\n                for(int k = 1000; k >= val; k--){\n                    if(dp[j][k - val]){\n                        dp[j][k] = 1;\n                    }\n                }\n            }\n\n            bool flag = true;\n            for(int j = 0; j < n; j++){\n                if(!dp[j][nums[j]]){\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag) return ind + 1;\n            ind++;\n        }\n        return -1;\n    }\n};","author":"Ayushcoder12","submissionId":"1575191335"},[]]},{"765":[{"id":"765","fileName":"1575191432.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size();\n        pair<vector<int>, vector<vector<int>>> vm = {a, q};\n\n        vector<bitset<1001>> d(n);\n        int i = 0;\n        while (i < n) {\n            d[i].reset();\n            d[i].set(0, true);\n            i++;\n        }\n\n        int j = 0;\n        while (j < n) {\n            if (a[j] != 0) break;\n            j++;\n        }\n        if (j == n) return 0;\n\n        i = 0;\n        while (i < q.size()) {\n            int l = q[i][0], r = q[i][1], v = q[i][2];\n\n            for (int j = l; j <= r; j++) {\n                d[j] |= (d[j] << v);\n                for (int p = a[j] + 1; p < 1001; p++) d[j].reset(p);\n            }\n\n            int f = 1, k = 0;\n            while (k < n) {\n                if (!d[k].test(a[k])) {\n                    f = 0;\n                    break;\n                }\n                k++;\n            }\n\n            if (f) return i + 1;\n            i++;\n        }\n        return -1;\n    }\n};","author":"Jagadish Nayak","submissionId":"1575191432"},[]]},{"766":[{"id":"766","fileName":"1575191488.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        sz = len(nums)\n        def can_transform(target):\n            axis = [{0} for _ in range(sz + 1)]\n            for i in range(target + 1):\n                s, e, v = queries[i]\n                for i in range(s, e + 1):\n                    ls = [v]\n                    for num in axis[i]:\n                        ls.append(num + v)\n                    for num in ls:\n                        axis[i].add(num)\n            for i in range(sz):\n                if nums[i] not in axis[i]:\n                    return False\n            return True\n\n        s, e = -1, len(queries) - 1\n        while s + 1 < e:\n            mid = (s + e) // 2\n            if can_transform(mid):\n                e = mid\n            else:\n                s = mid\n        if can_transform(s):\n            return s + 1\n        if can_transform(e):\n            return e + 1\n        return -1","author":"deantt","submissionId":"1575191488"},[]]},{"767":[{"id":"767","fileName":"1575191531.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        zeroed = [num==0 for num in nums]\n        if all(zeroed):\n            return 0\n        sum_set = [set([num]) for num in nums]\n        m = len(queries)\n        for i in range(m):\n            l,r,v = queries[i]\n            for j in range(l,r+1):\n                if zeroed[j] == False:\n                    if v in sum_set[j]:\n                        zeroed[j] = True\n                        if all(zeroed):\n                            return i+1\n                    else:\n                        new_set = sum_set[j].copy()\n                        for e in sum_set[j]:\n                            if e-v>0:\n                                new_set.add(e-v)\n                        sum_set[j] = new_set\n            \n        return -1","author":"Jianqiao Li","submissionId":"1575191531"},[]]},{"768":[{"id":"768","fileName":"1575191585.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        dp = [set([0]) for _ in range(n)]\n\n        if all(x == 0 for x in nums):\n            return 0\n\n        for k, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                new_dp = set(dp[j])\n                for val in dp[j]:\n                    if val + v <= 1000:\n                        new_dp.add(val + v)\n                dp[j] = new_dp\n\n            if all(nums[j] in dp[j] for j in range(n)):\n                return k + 1\n\n        return -1\n","author":"Sushant M S","submissionId":"1575191585"},[]]},{"769":[{"id":"769","fileName":"1575191679.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        \n        bool allzero = true;\n        for (auto i : nums) if (i != 0) { allzero = false; break; }\n\n        if (allzero) return 0;\n        \n        int l = 0, r = queries.size(), ans = -1;\n        \n        while (l <= r) {\n            int mid = (l + r) / 2;\n            bool flag = true;\n            \n            for (int i = 0; i < n && flag; i++) {\n                if (nums[i] == 0) continue;\n                \n                vector<int> vals;\n                for (int j = 0; j < mid; j++) if (queries[j][0] <= i && i <= queries[j][1]) vals.push_back(queries[j][2]);\n                \n                bitset<1001> dp;\n                dp[0] = 1;\n                \n                for (auto v : vals) dp |= (dp << v);\n                \n                if (!dp[nums[i]]) flag = false;\n            }\n            \n            flag ? (ans = mid, r = mid - 1) : l = mid + 1;\n        }\n        return ans;\n    }\n};\n","author":"Prem Kumar","submissionId":"1575191679"},[]]},{"770":[{"id":"770","fileName":"1575191542.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n\n        n = len(nums)\n        ans = []\n        for ind in range(n):\n            start = nums[ind]\n            if start == 0:\n                ans.append(0)\n                continue\n            \n            choice = []\n            for qind, (l, r, v) in enumerate(queries):\n                if l <= ind <= r and v != 0:\n                    choice.append((qind+1, v))\n                    \n            c = len(choice)\n            reachable = [False] * (start+1)\n            reachable[start] = True\n            finished = False\n            \n            for qind, v in choice:\n                for rind, r in enumerate(reachable):\n                    if r == True and rind-v >= 0:\n                        reachable[rind-v] = True\n                # print(reachable)\n                if reachable[0]:\n                    ans.append(qind)\n                    break\n                    \n            if reachable[0] != True:\n                ans.append(-1)\n\n        # print(ans)\n        if -1 in ans:\n            return -1\n        else:\n            return max(ans)\n                ","author":"bronzekiller2017","submissionId":"1575191542"},[]]},{"771":[{"id":"771","fileName":"1575192031.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size(), m = q.size();\n        int l = 1, r = m, ans = INT_MAX, p = *max_element(nums.begin(), nums.end());\n        if (p == 0) return 0;\n        \n        while (l <= r) {\n            int mid = (l + r) / 2;\n            vector<vector<int>> v1(n);\n            \n            for (int i = 0; i < mid; i++) {\n                for (int j = q[i][0]; j <= q[i][1]; j++) {\n                    v1[j].push_back(q[i][2]);\n                }\n            }\n\n            bool ok = true;\n            for (int i = 0; i < n; i++) {\n                bitset<1001> dp;\n                dp[0] = 1;\n                for (int val : v1[i]) {\n                    dp |= (dp << val);\n                }\n                if (!dp[nums[i]]) {\n                    ok = false;\n                    break;\n                }\n            }\n\n            if (ok) {\n                ans = min(ans, mid);\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n\n        return ans == INT_MAX ? -1 : ans;\n    }\n};","author":"u1904123","submissionId":"1575192031"},[]]},{"772":[{"id":"772","fileName":"1575191718.txt","sourceCode":"class Solution {\n    public boolean f(int i,ArrayList<Integer> list,int val,Boolean[][] dp){\n        if(val==0){\n            return true;\n        }\n        if(val<0 || i==list.size())return false;\n        if(dp[i][val]!=null)return dp[i][val];\n        boolean pick=f(i+1,list,val-list.get(i),dp);\n\n        boolean notpick=f(i+1,list,val,dp);\n\n        dp[i][val]=pick||notpick;\n        return pick||notpick;\n    }\n    \n    public boolean check(int x,int[] nums,int[][] queries){\n        int n=nums.length;\n        ArrayList<ArrayList<Integer>> list=new ArrayList<>();\n        for(int i=0;i<nums.length;i++){\n            list.add(new ArrayList<>());\n        }\n\n            for(int i=0;i<x;i++){\n            int l=queries[i][0];\n            int r=queries[i][1];\n            int val=queries[i][2];\n\n                for(int j=l;j<=r;j++){\n                    if(nums[j]>0){\n                        list.get(j).add(val);\n                    }\n                }\n            }\n\n        for(int i=0;i<n;i++){\n            if(nums[i]==0)continue;\n            ArrayList<Integer> cur=list.get(i);\n\n            Boolean[][] dp=new Boolean[cur.size()][nums[i]+1];\n            if(!f(0,cur,nums[i],dp)){\n                return false;\n            }\n        }\n        return true;\n        }\n    \n    \n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n=nums.length;\n        int q=queries.length;\n        int low=0;\n        int high=q-1;\n        if(!check(q,nums,queries))return -1;\n        while(low<=high){\n            int mid=low+(high-low)/2;\n            if(check(mid,nums,queries)){\n                high=mid-1;\n            }else{\n                low=mid+1;\n            }\n        }\n        return low;\n    }\n}","author":"Aditya Chauhan","submissionId":"1575191718"},[]]},{"773":[{"id":"773","fileName":"1575192376.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        boolean[][][] dp = new boolean[m][n][1001];\n        int ans = 0;\n        boolean flag=true;\n        for(int num : nums){\n            if(num!=0) {\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            return 0;\n        }\n        flag = true;\n        for(int j = 0;j<n;j++){\n            dp[0][j][0] = true;\n            if(j>=queries[0][0] && j<=queries[0][1]) {\n                dp[0][j][queries[0][2]] = true;\n            }\n            \n            if(!dp[0][j][nums[j]]) {\n                flag=false;\n            }\n        }\n        if(flag){\n            return 1;\n        }\n        \n        for(int i = 1; i < m ; i++){\n            int[] query = queries[i];\n            int l = query[0];\n            int r = query[1];\n            int val = query[2];\n            for(int j = 0;j<n;j++){\n                dp[i][j][0] = true;\n                if(j>=l && j<=r){\n                    for(int k = 1;k<=1000;k++){\n                        if(k-val >= 0) {\n                            dp[i][j][k] = dp[i-1][j][k] || dp[i-1][j][k-val];\n                        } else {\n                            dp[i][j][k] = dp[i-1][j][k];\n                        }\n                    }\n                } else {\n                    for(int k = 1;k<=1000;k++){\n                        dp[i][j][k] = dp[i-1][j][k];\n                    }\n                }\n                flag = true;\n                for(int k = 0;k<n;k++) {\n                    if(!dp[i][k][nums[k]]) {\n                        flag=false;\n                        break;\n                    }\n                }\n                if(flag){\n                    return i+1;\n                }\n            }\n        }\n        return -1;\n    }\n\n}","author":"hsujc513","submissionId":"1575192376"},[]]},{"774":[{"id":"774","fileName":"1575191777.txt","sourceCode":"\nclass Solution {\n    public int minZeroArray(int[] arrr, int[][] q) {\n        int n = arrr.length;\n        boolean allZero = true;\n        for (int num : arrr) {\n            if(num != 0) { allZero = false; break; }\n        }\n        if(allZero) return 0;\n        boolean[][] dp = new boolean[n][1001];\n        for (int i = 0; i < n; i++) dp[i][0] = true;\n       \n        for (int k = 0; k < q.length; k++) {\n            int l = q[k][0], r = q[k][1], val = q[k][2];\n            for (int i = l; i <= r; i++) {\n                boolean[] newdp = new boolean[1001];\n                for (int s = 0; s < 1001; s++) {\n                    if (dp[i][s]) newdp[s] = true;\n                }\n                for (int s = 0; s <= 1000 - val; s++) {\n                    if (dp[i][s]) newdp[s + val] = true;\n                }\n                dp[i] = newdp;\n            }\n            boolean all = true;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i][arrr[i]]) { all = false; break; }\n            }\n            if(all) return k + 1;\n        }\n        return -1;\n    }\n   \n   \n}","author":"Robin Kumar","submissionId":"1575191777"},[]]},{"775":[{"id":"775","fileName":"1575192158.txt","sourceCode":"class Solution\n{\n    using vi = vector<int>;\n    using vvi = vector<vi>;\n\n    bool canWeDoIt(int k, vi &arr)\n    {\n        int n = arr.size();\n        if (!n)\n            return !k;\n        vi dx(k + 1, 0);\n        dx[0] = 1;\n        if (arr[0] <= k)\n            dx[arr[0]] = 1;\n        for (int i = 1; i < n; i++)\n        {\n            vi tx(k + 1, 0);\n            tx[0] = 1;\n            for (int x = 1; x <= k; x++)\n            {\n                tx[x] = dx[x];\n                if (x >= arr[i])\n                    tx[x] = tx[x] || dx[x - arr[i]];\n            }\n            dx = tx;\n        }\n        return dx[k];\n    }\n\npublic:\n    int minZeroArray(vi &arr, vector<vi> &quer)\n    {\n        int n = arr.size();\n        if (count(arr.begin(), arr.end(), 0) == n)\n            return 0;\n        int l = 1, r = quer.size(), res = -1;\n        int ans = -1;\n        while (l <= r)\n        {\n            int m = (l + r) / 2;\n            vvi all(n);\n            for (int i = 0; i < m; i++)\n                for (int j = quer[i][0]; j <= quer[i][1]; j++)\n                    all[j].push_back(quer[i][2]);\n            bool yes = 1;\n            for (int i = 0; i < n; i++)\n            {\n                if (!canWeDoIt(arr[i], all[i]))\n                {\n                    yes = 0;\n                    break;\n                }\n            }\n            if (yes)\n                r = m - 1, res = m;\n            else\n                l = m + 1;\n        }\n        return res;\n    }\n};","author":"user6957zk","submissionId":"1575192158"},[]]},{"776":[{"id":"776","fileName":"1575192366.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        res = -1\n        for idx in range(len(nums)):\n            if nums[idx]==0:\n                continue\n            dp = {0}\n            # print(\"****\")\n            for q_idx, (l, r, v) in enumerate(queries):\n                if not (l<=idx<=r):\n                    continue\n                dp.update({t+v for t in dp if t+v<=nums[idx]})\n                # print(q_idx, nums[idx], dp)\n                if nums[idx] in dp:\n                    res = max(res, q_idx)\n                    break\n            if nums[idx] not in dp:\n                return -1\n        return res+1","author":"yahoo010206","submissionId":"1575192366"},[]]},{"777":[{"id":"777","fileName":"1575192298.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        # [1, 2, 6, 10]\n        # [9, 7, 8, 4, 3, 1, 2]\n        dic_nums = {n: set([num]) for n, num in enumerate(nums) if num > 0}\n\n        if len(dic_nums) == 0:\n            return 0\n\n        for n, [l, r, val] in enumerate(queries):\n            for i in range(l, r + 1):\n                if i in dic_nums:\n                    probs = set()\n                    probs.add(nums[i] - val)\n                    \n                    for prob in dic_nums[i]:\n                        probs.add(prob - val)\n\n                    for prob in probs:\n                        if prob == 0:\n                            del dic_nums[i]\n                            break\n                        elif prob > 0:\n                            dic_nums[i].add(prob)\n                    \n            if len(dic_nums) == 0:\n                return n + 1\n\n        return -1\n            ","author":"HoaLA","submissionId":"1575192298"},[]]},{"778":[{"id":"778","fileName":"1575191719.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        l = 0\n        r = len(queries)\n        if set(nums) == {0}:\n            return 0\n        res = -1\n\n        def isvalid(k):\n            for i in range(n):\n                target = nums[i]\n                coins = []\n                for j in range(k):\n                    l, r, val = queries[j]\n                    if l <= i <= r:\n                        coins.append(val)\n                \n                dp = 1\n                for coin in coins:\n                    dp |= (dp << coin)\n                    dp &= (1 << (target + 1)) - 1\n                if (dp >> target) & 1 == 0:\n                    return False\n            return True\n\n        while l <= r:\n            m = (l+r) // 2\n\n            if isvalid(m):\n                res = m\n                r = m-1\n            else:\n                l = m+1\n\n        return res","author":"Akshat Joshi","submissionId":"1575191719"},[]]},{"779":[{"id":"779","fileName":"1575192431.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> num_query(n);\n        for(int i = 0; i < queries.size(); ++i) {\n            const vector<int>& q = queries[i];\n            int l = q[0], r = q[1];\n            for(int j = l; j <=r ; ++j) {\n                num_query[j].push_back(i);\n            }\n        }\n\n        int ans = 0;\n        for(int i = 0; i < n; ++i) {\n            if(nums[i] == 0) {\n                continue;\n            }\n\n            unordered_set<int> vals;\n            vals.insert(nums[i]);\n            const vector<int>& qs = num_query[i];\n            bool found = false;\n            for(int j : qs) {\n                int dec = queries[j][2];\n                if(vals.count(dec)) {\n                    found = true;\n                    ans = max(ans, j + 1);\n                    break;\n                }\n                else {\n                    unordered_set<int> nexts;\n                    for(int val : vals) {\n                        if(val > dec) {\n                            nexts.insert(val - dec);\n                        }\n                    }\n                    for(int next : nexts) {\n                        vals.insert(next);\n                    }\n                }\n            }\n\n            if(!found) {\n                return -1;\n            }\n        }\n\n        return ans;\n    }\n};","author":"Sam Lee","submissionId":"1575192431"},[]]},{"780":[{"id":"780","fileName":"1575192613.txt","sourceCode":"class Solution {\npublic:\n    // int ans=0;\n    // void solve(vector<int> &nums, vector<vector<int>>&q, int i, int k)\n    // {\n    //     if(i==q.size())\n    //     {\n    //         int cnt=0;\n    //         for(int j=0; j<nums.size(); j++)\n    //             {\n    //                 if(nums[j]==0)\n    //                 {\n    //                     cnt++;\n    //                 }\n    //             }\n    //         if(cnt==nums.size())\n    //         {\n    //             ans++;\n    //         }\n    //         return;\n    //     }\n    //     for(int j=max(k, q[i][0]); j<=q[i][1]; j++)\n    //         {\n    //             nums[j]=nums[j]-q[i][2];\n    //             solve(nums, q, i, j+1);\n    //             nums[j]=nums[j]+q[i][2];\n    //         }\n    //     solve(nums, q, i+1, INT_MIN);\n    // }\n    void solve(vector<pair<int,int>> &vec, int i, int ele, int &ans, vector<vector<int>> &dp)\n{\n    if(ele==0)\n    {\n        ans=min(vec[i-1].first, ans);\n        return;\n    }\n    if(ele<0)\n    {\n        return;\n    }\n    if(i==vec.size())\n    {\n        return;\n    }\n    if(dp[i][ele]!=-1)\n    {\n        ans=min(ans, dp[i][ele]);\n    }\n    if(ele>= vec[i].second)\n    {\n        solve(vec, i+1, ele-vec[i].second, ans, dp);\n    }\n    solve(vec, i+1, ele, ans, dp);\n    dp[i][ele]=ans;\n}\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        // solve(nums, queries, 0, INT_MIN);\n        int n=nums.size();\n        vector<vector<pair<int,int>>> ind(n);\n        int m=q.size();\n        for(int i=0; i<m; i++)\n            {\n                for(int j=q[i][0]; j<=q[i][1]; j++)\n                    {\n                        ind[j].push_back({i+1,q[i][2]});\n                    }\n            }\n        for(int i=0; i<n; i++)\n            {\n                sort(ind[i].begin(), ind[i].end());\n            }\n        int ans=INT_MIN;\n        int res=INT_MAX;\n        for(int i=0; i<n; i++)\n            {\n                res=INT_MAX;\n                int ele=nums[i];\n                // vector<vector<int>> dp(ind[i].size()+1, vector<int> (1001, -1));\n                // if(ele==0){\n                //     res=0;\n                // }\n                // else\n                // {\n                //     solve(ind[i], 0, ele, res, dp);\n                //     if(res==INT_MAX)\n                //     {\n                //         res=-1;\n                //         return -1;\n                //     }\n                // }\n                // ans=max(res, ans);\n                vector<int> dp(1001, INT_MAX);\n                dp[0] = 0;\n                for (auto [index, val] : ind[i]) {\n                    for (int j = 1000; j >= val; j--) {\n                        if (dp[j - val] != INT_MAX) {\n                            dp[j] = min(dp[j], index);\n                        }\n                    }\n                }\n                res=dp[ele];\n                if (res == INT_MAX)\n                {\n                    return -1;\n                }\n                ans = max(ans, res);\n            }\n        return ans; \n    }\n};","author":"Pratham Chaurasiya","submissionId":"1575192613"},[]]},{"781":[{"id":"781","fileName":"1575192469.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> sum_nums(n);\n        for(int i=0;i<n;i++){\n            sum_nums[i].resize(nums[i]+3,0);\n        }\n        for(int i=0;i<n;i++) sum_nums[i][0] = 1;\n        int all_zero=1;\n        for(int i=0;i<n;i++){\n            if(nums[i]!=0) all_zero=0;\n        }\n        if(all_zero==1) return 0;\n\n        for(int i=0;i<queries.size();i++){\n            int left = queries[i][0];\n            int right = queries[i][1];\n            int val = queries[i][2];\n            for(int j=left;j<=right && j<n ;j++){\n                for(int k=nums[j]; k>0 && k>=val;k--){\n                    sum_nums[j][k] = max(sum_nums[j][k], sum_nums[j][k-val] );\n                }\n            }\n            int is_possible = 1;\n            for(int j=0;j<n;j++){\n                int num_val = nums[j];\n                if( sum_nums[j][num_val] != 1) is_possible = 0;\n            }\n\n            // for(int j=0;j<n;j++){\n            //     cout<<endl;\n            //     cout<<j<<\" j -> \";\n            //     for(int k=0;k<=nums[j];k++) cout<<sum_nums[j][k]<<\"   \";\n            // }\n            \n            if(is_possible==1) return i+1;\n            \n        }\n        return -1;\n        \n        \n    }\n};","author":"yash gupta","submissionId":"1575192469"},[]]},{"782":[{"id":"782","fileName":"1575192644.txt","sourceCode":"class Solution {\npublic:\n    int f(int i,int sum,vector<vector<int>>& q,int m,int id,vector<vector<int>>&dp){\n        if(sum==0){\n            return 0;\n        }else if(i==m){\n            return m+10;\n        }\n        if(dp[i][sum]!=-2)return dp[i][sum];\n        int ans;\n        if(q[i][2]<=sum&&q[i][0]<=id&&q[i][1]>=id){\n            ans=min(1+f(i+1,sum-q[i][2],q,m,id,dp),1+f(i+1,sum,q,m,id,dp));\n        }else{\n            ans=1+f(i+1,sum,q,m,id,dp);\n        }\n        return dp[i][sum]=ans;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n=nums.size();\nint m =q.size();\nint ans=0;\n        for(int i=0;i<n;i++){\n    vector<vector<int>>dp(m+1,vector<int>(nums[i]+1,-2));\n    int curr=f(0,nums[i],q,m,i,dp);\n    if(curr>m)return -1;\n    ans=max(ans,curr);\n        }\nreturn ans;\n    }\n};","author":"Aman Vyas","submissionId":"1575192644"},[]]},{"783":[{"id":"783","fileName":"1575192470.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<vector<bool>> ok(11, vector<bool>(1001, false)); \n        if(accumulate(nums.begin(), nums.end(), (long long)0) == 0) return 0 ;\n        for(int i = 0 ; i < nums.size() ; ++i) {\n            ok[i][0] = true;\n        }\n        int cnt = 0;\n        for(const auto& q : queries) {\n            int val = q[2];\n            // cout << \"Q \" << q[0] << \" \" << q[1] << endl;\n            for(int i = q[0] ;  i <= q[1] ; ++i) {\n                for(int j = 1000 ; j >= 0 ; --j) {\n                    if(ok[i][j] && (j + val <= 1000)) {\n                        ok[i][j+val] = true;\n                        // cout << \"MARK \" << i << \" \" << j+val << endl;\n                    }\n                }\n            }\n            ++cnt;\n            bool form = true;\n            for(int i = 0 ; i < nums.size() ; ++i) {\n                if(!ok[i][nums[i]]) {\n                    form = false;\n                    break;\n                }\n            }\n            if(form) return cnt;\n        }\n        return -1;\n    }\n};","author":"Yu-Cheng Lin","submissionId":"1575192470"},[]]},{"784":[{"id":"784","fileName":"1575192789.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size();\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            vector<int> affecting;\n            for (int j = 0; j < q; j++) {\n                if (queries[j][0] <= i && i <= queries[j][1]) {\n                    affecting.push_back(j);\n                }\n            }\n            vector<bool> dp(nums[i] + 1, false);\n            dp[nums[i]] = true;\n            int cur = -1;\n            for (auto qIdx : affecting) {\n                if (dp[0]) break;\n                int val = queries[qIdx][2];\n                cur = qIdx;\n                for (int j = val; j <= nums[i]; j++) {\n                    if (dp[j] && j - val >= 0) {\n                        dp[j - val] = true;\n                    }\n                }\n            }\n            if (!dp[0]) return -1;\n            ans = max(ans, cur + 1);\n        }\n        return ans;\n    }\n};","author":"Devansh Vyas","submissionId":"1575192789"},[]]},{"785":[{"id":"785","fileName":"1575192902.txt","sourceCode":"class Solution {\npublic:\n    vector<vector<int>> dp;\n    \n    bool poss1(vector<int>& v, int i, int t) \n    {\n        if (t == 0) \n            return true;\n        if(t<0)\n            return false;\n        if (i >= v.size()) \n            return false;\n        if (dp[i][t] != -1) \n            return dp[i][t];\n        \n        \n        return (dp[i][t] = (poss1(v, i + 1, t - v[i]) || poss1(v, i + 1, t)));\n    }\n    \n    bool poss(vector<int>&v,vector<vector<int>>& q,int k)\n    {\n        int n=v.size();\n        for(int i=0;i<n;i++)\n        {\n            vector<int>t;\n            for(int j=0;j<k;j++)\n            {\n                if(q[j][0]<=i && q[j][1]>=i)\n                    t.push_back(q[j][2]);\n            }\n            dp.clear();\n            dp.resize(t.size(), vector<int>(1e4 + 10, -1));\n            if(!poss1(t,0,v[i]))\n                return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& v, vector<vector<int>>& q) \n    {\n        int n=v.size(),m=q.size();\n        int l=0,r=m;\n        int ans=m+10;\n        while(l<=r)\n        {\n            int mid=(r-l)/2+l;\n            if(poss(v,q,mid))\n            {\n                ans=mid;\n                r=mid-1;\n            }\n            else\n                l=mid+1;\n        }\n        // poss(v,q,2);\n        if(ans<=m)\n            return ans;\n        return -1;\n    }\n};","author":"Neelabh Rana","submissionId":"1575192902"},[]]},{"786":[{"id":"786","fileName":"1575192946.txt","sourceCode":"from sortedcontainers import SortedList\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        N=len(nums)\n        M=len(queries)\n        \n        if sum(nums) == 0:\n            return 0\n        \n        low,high=1,M\n        \n        def go(k):\n            arr=defaultdict(lambda : SortedList())\n            for l,r,val in queries[:k]:\n                for i in range(l,r+1):\n                    arr[i].add(val)\n                    \n            for i in range(N):\n                A=arr[i]\n                @cache\n                def helper(i,val):\n                    if val == 0:\n                        return True\n                    if i == len(A):\n                        return val == 0\n                    if A[i]>val:\n                        return False\n                    x=helper(i+1,val)\n                    y=helper(i+1,val-A[i])\n                    return x or y\n\n                helper.cache_clear()\n                if not helper(0,nums[i]):\n                    return False\n\n            return True\n\n        while low<=high:\n            mid=(low+high)//2\n            if go(mid):\n                high=mid-1\n            else:\n                low=mid+1\n        ans=high+1\n        if ans>M:\n            ans=-1\n        return ans","author":"happy","submissionId":"1575192946"},[]]},{"787":[{"id":"787","fileName":"1575192981.txt","sourceCode":"class Solution {\npublic:\n    // bool solve(int num,int i,vector<int>& sub){\n    //     if(num < 0){\n    //         return false;\n    //     }\n    //     if(i == sub.size()){\n    //         return num == 0;\n    //     }\n    //     if(num == 0){\n    //         return true;\n    //     }\n        \n    //     bool res1 = solve(num-sub[i],i+1,sub);\n    //     if(res1){\n    //         return true;\n    //     }\n    //     bool res2 = solve(num,i+1,sub);\n    //     return res2;\n    // }\n    bool check(vector<int>& nums, vector<vector<int>>& queries,int mid){\n        vector<vector<int>> temp(nums.size());\n        for(int i = 0;i<mid;i++){\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            for(int j = l;j<=r;j++){\n                temp[j].push_back(val);\n            }\n        }\n        for(int i = 0;i<nums.size();i++){\n            if(nums[i] == 0){\n                continue;\n            }\n            if(nums[i] > 0 && temp[i].size() == 0){\n                return false;\n            }\n            int n = temp[i].size();\n            vector<vector<bool>> dp(n,vector<bool>(nums[i]+1,0));\n            for(int i = 0;i<n;i++){\n                dp[i][0] = true;\n            }\n            dp[0][temp[i][0]] = true;\n            for(int ind = 1;ind<n;ind++){\n                for(int target = 1;target<=nums[i];target++){\n                    bool nottake = dp[ind-1][target];\n                    bool take = false;\n                    if(temp[i][ind]<=target){\n                        take = dp[ind-1][target-temp[i][ind]];\n                    }\n                    dp[ind][target] = take | nottake;\n                }\n            }\n            if(dp[n-1][nums[i]] == false){\n                return false;\n            }\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int low = 0;\n        int high = queries.size();\n        int ans = -1;\n        while(low <= high){\n            int mid = low + (high-low)/2;\n            if(check(nums,queries,mid)){\n                high = mid-1;\n                ans = mid;\n            }\n            else{\n                low = mid+1;\n            }\n        }\n        return ans;\n    }\n};","author":"Ishu Gupta","submissionId":"1575192981"},[]]},{"788":[{"id":"788","fileName":"1575192919.txt","sourceCode":"/*\n * Author: aappyy07\n * Handle: aappyy07\n * Date: 16-03-25\n * \"God, I have humbled myself before the court\n    Drop my ego when confidence was my last resort\n    I know, I know He got a plan, I know I'm on Your beams\n    One set of footsteps, You was carryin' me\"\n */\n#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define DEBUG(x) cout << '>' << #x << ':' << x << endl;\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, a, b) for (int i = (a); i <= (b); i++)\n#define FORD(i, a, b) for (int i = (a); i >= (b); i--)\ninline bool EQ(double a, double b) { return fabs(a - b) < 1e-9; }\n\nconst int INF = 1 << 29;\ntypedef long long ll;\n\ninline int two(int n) { return 1 << n; }\ninline int test(int n, int b) { return (n >> b) & 1; }\ninline void set_bit(int& n, int b) { n |= two(b); }\ninline void unset_bit(int& n, int b) { n &= ~two(b); }\ninline int last_bit(int n) { return n & (-n); }\ninline int ones(int n) {\n    int res = 0;\n    while (n && ++res)\n        n -= n & (-n);\n    return res;\n}\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\ntemplate <typename T>\nvector<T> merge(const vector<T>& left, const vector<T>& right) {\n    vector<T> result;\n    size_t i = 0, j = 0;\n\n    while (i < left.size() && j < right.size()) {\n        if (left[i] <= right[j]) {\n            result.push_back(left[i]);\n            i++;\n        } else {\n            result.push_back(right[j]);\n            j++;\n        }\n    }\n\n    while (i < left.size()) {\n        result.push_back(left[i]);\n        i++;\n    }\n\n    while (j < right.size()) {\n        result.push_back(right[j]);\n        j++;\n    }\n\n    return result;\n}\n\ntemplate <typename T> vector<T> mergeSort(const vector<T>& arr) {\n    if (arr.size() <= 1) {\n        return arr;\n    }\n\n    size_t mid = arr.size() / 2;\n    vector<T> left(arr.begin(), arr.begin() + mid);\n    vector<T> right(arr.begin() + mid, arr.end());\n\n    left = mergeSort(left);\n    right = mergeSort(right);\n\n    return merge(left, right);\n}\nvoid file() {\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n}\n#include <bitset>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int arraySize = nums.size();\n        pair<vector<int>, vector<vector<int>>> inputPair = {nums, queries};\n        vector<bitset<1001>> possibilities(arraySize);\n\n        int index = 0;\n        while (index < arraySize) {\n            possibilities[index].reset();\n            possibilities[index].set(0, 1);\n            index++;\n        }\n\n        int isAllZero = 1;\n        index = 0;\n        while (index < arraySize) {\n            if (nums[index] != 0) {\n                isAllZero = 0;\n                break;\n            }\n            index++;\n        }\n        if (isAllZero)\n            return 0;\n\n        int queryIndex = 0;\n        while (queryIndex < queries.size()) {\n            int startPos = queries[queryIndex][0];\n            int endPos = queries[queryIndex][1];\n            int shiftAmount = queries[queryIndex][2];\n\n            index = startPos;\n            while (index <= endPos) {\n                possibilities[index] |= (possibilities[index] << shiftAmount);\n\n                int bitPosition = nums[index] + 1;\n                while (bitPosition < 1001) {\n                    possibilities[index].reset(bitPosition);\n                    bitPosition++;\n                }\n                index++;\n            }\n\n            int targetReached = 1;\n            index = 0;\n            while (index < arraySize) {\n                if (!possibilities[index].test(nums[index])) {\n                    targetReached = 0;\n                    break;\n                }\n                index++;\n            }\n            if (targetReached)\n                return queryIndex + 1;\n\n            queryIndex++;\n        }\n        return -1;\n    }\n};\n/*\n * Author: aappyy07\n * Handle: aappyy07\n * Date: 16-03-25\n * \"God, I have humbled myself before the court\n    Drop my ego when confidence was my last resort\n    I know, I know He got a plan, I know I'm on Your beams\n    One set of footsteps, You was carryin' me\"\n */\n","author":"Anurag Kumar","submissionId":"1575192919"},[]]},{"789":[{"id":"789","fileName":"1575193156.txt","sourceCode":"class Solution:\n    def check(self, nums: list[int], queries: list[list[int]], middle: int) -> bool:\n        n: int = len(nums)\n        dp: list[set[int]] = [set() for _ in range(n)]\n        for i in range(n):\n            dp[i].add(nums[i])\n        for l, r, v in queries[:middle]:\n            for i in range(l, r + 1):\n                if 0 in dp[i]: continue\n                for num in dp[i].copy():\n                    if num >= v: dp[i].add(num - v)\n        return all(0 in dp[i] for i in range(n))\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        left: int = 0\n        right: int = len(queries)\n        answer: int = -1\n        while left <= right:\n            middle: int = left + ((right - left) >> 1)\n            if self.check(nums, queries, middle):\n                answer = middle\n                right = middle - 1\n            else: left = middle + 1\n        return answer","author":"Peter Kalugin","submissionId":"1575193156"},[]]},{"790":[{"id":"790","fileName":"1575193126.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int left = 0, right = queries.length, result = -1;\n\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (canFormZero(nums, queries, mid)) {\n                result = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return result;\n    }\n\n    private boolean canFormZero(int[] nums, int[][] queries, int k) {\n        int n = nums.length;\n\n        for (int idx = 0; idx < n; idx++) {\n            int target = nums[idx];\n\n            List<Integer> decrements = new ArrayList<>();\n            for (int i = 0; i < k; i++) {\n                int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n                if (idx >= l && idx <= r) {\n                    decrements.add(val);\n                }\n            }\n\n            if (!subsetSumPossible(decrements, target))\n                return false;\n        }\n\n        return true;\n    }\n\n    private boolean subsetSumPossible(List<Integer> vals, int target) {\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n\n        for (int val : vals) {\n            for (int t = target; t >= val; t--) {\n                if (dp[t - val]) dp[t] = true;\n            }\n        }\n\n        return dp[target];\n    }\n}\n","author":"Ranjith R N","submissionId":"1575193126"},[]]},{"791":[{"id":"791","fileName":"1575193045.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        dp = [set([0]) for _ in range(n)]\n\n        if all(num == 0 for num in nums):\n            return 0\n\n        for k, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                new_dp = set(x + v for x in dp[j] if x + v <= 1000)\n                dp[j].update(new_dp)\n\n            if all(nums[j] in dp[j] for j in range(n)):\n                return k + 1\n\n        return -1","author":"M Harinath","submissionId":"1575193045"},[]]},{"792":[{"id":"792","fileName":"1575193246.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        max_k = 0\n\n        for i in range(n):\n            T = nums[i]\n            if T == 0:\n                current_k_i = 0\n            else:\n                covered_queries = []\n                for j, q in enumerate(queries):\n                    l, r, val = q\n                    if l <= i <= r:\n                        covered_queries.append((j, val))\n                \n                if not covered_queries:\n                    return -1\n                \n                covered_queries.sort()\n                dp = {0: -1}\n                target = T\n                \n                for (j, val) in covered_queries:\n                    new_dp = {}\n                    for s in dp:\n                        existing_j = dp[s]\n                        if s in new_dp:\n                            if existing_j < new_dp[s]:\n                                new_dp[s] = existing_j\n                        else:\n                            new_dp[s] = existing_j\n                    \n                    for s in dp:\n                        new_s = s + val\n                        if new_s > target:\n                            continue\n                        if new_s in new_dp:\n                            if j < new_dp[new_s]:\n                                new_dp[new_s] = j\n                        else:\n                            new_dp[new_s] = j\n                    \n                    dp = new_dp\n                \n                if target not in dp:\n                    return -1\n                \n                current_k_i = dp[target] + 1\n            \n            max_k = max(max_k, current_k_i)\n\n        if max_k > m:\n            return -1\n        \n        return max_k\n","author":"CALL_ME_SHINCHAN","submissionId":"1575193246"},[]]},{"793":[{"id":"793","fileName":"1575192984.txt","sourceCode":"class Solution {\npublic:\n\nbool solve(int tar,vector<int>&sol,vector<vector<int>>&dp,int ind)\n{\n    if(tar==0)\n    {\n        return true;\n    }\n    if(ind==sol.size())\n    {\n        return false;\n    }\n    if(dp[ind][tar]!=-1)\n    {\n        return dp[ind][tar];\n    }\n    bool ans=false;\n    if(tar>=sol[ind]){\n    ans=ans||solve(tar-sol[ind],sol,dp,ind+1);\n        }\n    ans=ans||solve(tar,sol,dp,ind+1);\n    return dp[ind][tar]=ans;\n}\nbool ispossible(int mid,vector<int>&nums,vector<vector<int>>&queries)\n{\n    int n=nums.size();\n    // vector<vector<int>>ind(n+1,0);\n    vector<string>ans(n+1);\n    multiset<int>prev;\n    for(int i=0;i<mid;i++)\n        {\n           ans[queries[i][0]]+=\"pu\"+to_string(queries[i][2]);\n           ans[queries[i][1]+1]+=\"po\"+to_string(queries[i][2]);\n        }\n    for(int i=0;i<n;i++)\n        {\n            int j=0;\n            while(j<ans[i].size())\n                {\n                    if(ans[i][j]=='p'&&ans[i][j+1]=='u')\n                    {\n                        j++;\n                        j++;\n                        string num=\"\";\n                        while(ans[i][j]>='0'&&ans[i][j]<='9')\n                            {\n                                 num+=ans[i][j];\n                                j++;\n                            }\n                        prev.insert(stoi(num));\n                    }else if(ans[i][j]=='p'&&ans[i][j+1]=='o')\n                    {\n                        j++;\n                        j++;\n                        string num=\"\";\n                        while(ans[i][j]>='0'&&ans[i][j]<='9')\n                            {\n                                 num+=ans[i][j];\n                                j++;\n                            }\n                        prev.erase(prev.find(stoi(num)));\n                    }\n                }\n            vector<int>sol(prev.size());\n             j=0;\n            for(auto &m:prev)\n                {\n                    sol[j]=m;\n                    j++;\n                }\n            vector<vector<int>>dp(j+2,vector<int>(nums[i]+1,-1));\n            if(!solve(nums[i],sol,dp,0))\n            {\n                return false;\n            }\n        }\n    return true;\n    \n}\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int s=0,e=queries.size(),ans=-1;\n        while(s<=e)\n            {\n                int mid=s+(e-s)/2;\n                if(ispossible(mid,nums,queries))\n                {\n                    ans=mid;\n                    e=mid-1;\n                }else{\n                    s=mid+1;\n                }\n            }\n        return ans;\n    }\n};","author":"ky198484","submissionId":"1575192984"},[]]},{"794":[{"id":"794","fileName":"1575193349.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int res = -1;\n        for(int i = 0; i < nums.size(); ++i)\n        {\n            if(nums[i] == 0)\n                continue;\n            int leastIdx = leastIdxSatisfy(nums, queries, i);\n            if(leastIdx == -1)\n                return -1;\n            res = max(res, leastIdx);\n        }\n        return res+1;\n    }\n\n\n    int leastIdxSatisfy(vector<int>& nums, vector<vector<int>>& queries, int i)\n    {\n        int res = -1;\n        vector<vector<int>> dp(queries.size(), vector<int>(nums[i]+1, -1));\n        for(int idx = 0; idx < queries.size(); ++idx)\n        {\n            if(dpCal(i, dp, queries, idx, nums[i]) == 1)\n            {\n                res = idx;\n                break;\n            }            \n        }\n        return res;\n    }\n    int dpCal(int pos, vector<vector<int>>& dp, vector<vector<int>>& queries, int idx, int sum)  //0~idx, can it make sum become 0 after choosing some subsets?\n    {\n        if(dp[idx][sum] != -1)\n            return dp[idx][sum];\n        if(sum == 0)\n        {\n            return dp[idx][sum] = 1;\n        }\n        int l = queries[idx][0], r = queries[idx][1], val = queries[idx][2];\n        if(idx == 0)\n        {\n            if((!(l <= pos && pos <= r)) || sum != val)  //cannot pick\n                return dp[idx][sum] = 0;\n            return dp[idx][sum] = 1;\n        }\n        if(l <= pos && pos <= r)\n        {\n            if(val <= sum)  //pick\n            {\n                if(dpCal(pos, dp, queries, idx-1, sum-val) == 1)\n                {\n                    return dp[idx][sum] = 1;\n                }\n            }\n        }\n        // not pick\n        if(dpCal(pos, dp, queries, idx-1, sum) == 1)\n        {\n            dp[idx][sum] = 1;\n        }\n        else\n        {\n            dp[idx][sum] = 0;\n        }\n        return dp[idx][sum];\n    }\n};","author":"lai_cheng","submissionId":"1575193349"},[]]},{"795":[{"id":"795","fileName":"1575193372.txt","sourceCode":"#define FOR(i,a,b)   for(int i = a; i < b.size(); ++i)\n#define F(i,a,b)     for(int i = a; i < b; ++i)\n#define F0(i,b)      for(int i = 0; i< b.size();++i)\n#define BE(a)        a.begin(), a.end()\n#define __S(a)       a.size()\n#define pb(a)        push_back(a)\n#define pr(a)        cout << a << \" \";\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef vector<string> vs;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector <long long> vl;\ntypedef vector<vector<long long> > vvl;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        // exactly 0, \n\n        bool dp[10][1001];\n        memset(dp, 0, sizeof dp);\n\n        int n = __S(nums);\n        F(i,0,n){\n            dp[i][nums[i]] = 1;\n        }\n\n        int c={};\n        for(auto a: q){ // 1000*10*1000\n            bool ans = 1;\n            F(i,0,n){\n                ans = ans && dp[i][0];\n            }\n            if (ans) return c;\n\n            \n            F(i, a[0], a[1]+1){\n                F(j, a[2], nums[i]+1){\n                    if (dp[i][j]) dp[i][j-a[2]] = 1;\n                }\n            }\n            c++;\n        }\n\n        bool ans = 1;\n        F(i,0,n){\n            ans = ans && dp[i][0];\n        }\n        if (ans) return c;\n        return -1;\n    }\n};","author":"ziang","submissionId":"1575193372"},[]]},{"796":[{"id":"796","fileName":"1575193421.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        boolean[][] dp = initializeDP(n);\n\n        if (allZeros(nums)) return 0;\n\n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0], r = queries[k][1], v = queries[k][2];\n            applyDecrements(dp, nums, l, r, v);\n\n            if (allAchieved(dp, nums)) return k + 1;\n        }\n\n        return -1;\n    }\n\n    private boolean[][] initializeDP(int n) {\n        boolean[][] dp = new boolean[n][1001];\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n        return dp;\n    }\n\n    private boolean allZeros(int[] nums) {\n        for (int num : nums) {\n            if (num != 0) return false;\n        }\n        return true;\n    }\n\n    private void applyDecrements(boolean[][] dp, int[] nums, int l, int r, int v) {\n        for (int j = l; j <= r; j++) {\n            for (int pos = 1000; pos >= v; pos--) {\n                if (dp[j][pos - v]) {\n                    dp[j][pos] = true;\n                }\n            }\n            for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                dp[j][pos] = false;\n            }\n        }\n    }\n\n    private boolean allAchieved(boolean[][] dp, int[] nums) {\n        for (int i = 0; i < nums.length; i++) {\n            if (!dp[i][nums[i]]) return false;\n        }\n        return true;\n    }\n}\n","author":"vinaychowdary7","submissionId":"1575193421"},[]]},{"797":[{"id":"797","fileName":"1575193415.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        vector<vector<pair<int,int>>>v(n);\n        for(int i = 0; i < q; i++){\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            for(int j = l; j <= r; j++){\n                v[j].push_back({val, i + 1});\n            }\n        }\n        int ans = -1;\n        for(int i = 0; i < n; i++){\n            if(nums[i] == 0){\n                ans = max(ans, 0);\n                continue;\n            }\n            set<int>st;\n            st.insert(0);\n            bool found = false;\n            for(int j = 0; j < v[i].size(); j++){\n                set<int>st1;\n                for(int x:st){\n                    if(x + v[i][j].first == nums[i]){\n                        ans = max(ans, v[i][j].second);\n                        found = true;\n                        break;\n                    }\n                    st1.insert(x + v[i][j].first);\n                }\n                if(found) break;\n                for(int y:st1) st.insert(y);\n            }\n            if(found == false) return -1;\n        }\n        return ans;\n    }\n};","author":"Siddharth Singh","submissionId":"1575193415"},[]]},{"798":[{"id":"798","fileName":"1575193398.txt","sourceCode":"from typing import List\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        already_zero = all(num == 0 for num in nums)\n        if already_zero:\n            return 0\n        available = [[] for _ in range(n)]\n        for j, query in enumerate(queries):\n            l, r, val = query\n            for i in range(l, r + 1):\n                available[i].append((j, val))\n        low, high = 1, len(queries)\n        ans = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if self.canZero(nums, available, mid):\n                ans = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        return ans\n    def canZero(self, nums: List[int], available: List[List[tuple]], k: int) -> bool:\n        for i in range(len(nums)):\n            target = nums[i]\n            dp = [False] * (target + 1)\n            dp[0] = True\n            for op in available[i]:\n                if op[0] < k:  \n                    val = op[1]\n                    for s in range(target, val - 1, -1):\n                        if dp[s - val]:\n                            dp[s] = True\n            if not dp[target]:\n                return False\n        return True","author":"Tejas N","submissionId":"1575193398"},[]]},{"799":[{"id":"799","fileName":"1575193780.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        const unsigned n = nums.size();\n        const unsigned m = queries.size();\n        {\n            bool ok = true;\n            for (unsigned i = 0; i < n; ++i)\n                if (nums[i] != 0)\n                    ok = false;\n            if (ok)\n                return 0;\n        }\n        vector<vector<bool>> vs(n);\n        for (unsigned i = 0; i < n; ++i) {\n            vs[i].resize(nums[i] + 1);\n            vs[i][0] = true;\n        }\n        for (unsigned i = 0; i < m; ++i) {\n            auto &q = queries[i];\n            unsigned l = q[0];\n            unsigned r = q[1];\n            unsigned v = q[2];\n            for (unsigned j = l; j <= r; ++j) {\n                for (unsigned t = nums[j]; t >= v; t--)\n                    vs[j][t] = vs[j][t] || vs[j][t - v];\n            }\n            bool ok = true;\n            for (unsigned j = 0; j < n; ++j)\n                if (!vs[j][nums[j]])\n                    ok = false;\n            if (ok)\n                return i + 1;\n        }\n        return -1;\n    }\n};","author":"Yuriy Kaminskiy","submissionId":"1575193780"},[]]},{"800":[{"id":"800","fileName":"1575193696.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        options = [[] for _ in range(n)]\n\n        for ts, (ll, rr, vv) in enumerate(queries):\n            for ii in range(ll, rr + 1):\n                options[ii].append((vv, ts))\n\n\n        def solve(arr, ttt):\n            @functools.lru_cache(None)\n            def dp(m, t):\n                if m == 0:\n                    return t == 0\n                if t == 0:\n                    return True\n                if t < 0:\n                    return False\n\n                return dp(m - 1, t) or dp(m - 1, t - arr[m - 1][0])\n\n            for mmm in range(0, len(arr) + 1):\n                if dp(mmm, ttt):\n                    if mmm == 0:\n                        sol = -1\n                    else:\n                        sol = arr[mmm-1][1]\n                    break\n            else:\n                sol = float('inf')\n            dp.cache_clear()\n            return sol\n\n        ret = -1\n        for i in range(n):\n            ts = solve(options[i], nums[i])\n            if ts == float('inf'):\n                return -1\n            ret = max(ret, ts)\n        return ret + 1\n","author":"Behrooz Sepehry","submissionId":"1575193696"},[]]},{"801":[{"id":"801","fileName":"1575193363.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        left = 0\n        right = len(queries)\n        n = len(nums)\n        res = -1\n        def helper(vals, i, target):\n            if not target:\n                return True\n\n            if target < 0 or i == len(vals):\n                return False\n\n            return helper(vals, i+1, target-vals[i]) or helper(vals, i+1, target)\n            \n        while left <= right:\n            mid = (left+right)//2\n            isZero = True\n            vals = [[] for _ in range(n)]\n            for i in range(mid):\n                l, r, val = queries[i]\n                for indx in range(l, r+1):\n                    vals[indx].append(val)\n\n            isZero = True\n            for i in range(n):\n                if sum(vals[i]) < nums[i] or not helper(vals[i], 0, nums[i]):\n                    isZero = False\n                    break\n\n            if isZero:\n                res = mid\n                right = mid-1\n\n            else:\n                left = mid+1\n\n        return res","author":"David Yee","submissionId":"1575193363"},[]]},{"802":[{"id":"802","fileName":"1575193915.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def back(i):\n            n = nums[i]\n            if n==0:\n                return 0\n            possible = [False]*n + [True]\n            for k,(l,r,v) in enumerate(queries):\n                if l <= i <= r:\n                    for j in range(1,n+1):\n                        if possible[j] and j-v >= 0:\n                            possible[j-v] = True\n                    if possible[0]:\n                        return k+1\n#                    print((l,r,v),possible)\n            return -1\n        arr = [back(i) for i in range(len(nums))]\n        return -1 if -1 in arr else max(arr)\n","author":"technique_god","submissionId":"1575193915"},[]]},{"803":[{"id":"803","fileName":"1575193945.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number}\n */\nvar minZeroArray = function(nums, queries) {\n  const n = nums.length;\n  const m = queries.length;\n  \n  if (Math.max(...nums) === 0) return 0;\n  \n  const values = new Array(n).fill().map(() => new Array());\n  \n  for (let j = 0; j < m; j += 1) {\n    const [l, r, v] = queries[j];\n    for (let i = l; i <= r; i += 1) {\n      values[i].push([v, j]);\n    }\n  }\n  \n  const earliest = new Array(n).fill(Infinity);\n  \n  for (let i = 0; i < n; i += 1) {\n    \n    const k = values[i].length;\n    const dp = new Array(k + 1).fill().map(() => new Array(nums[i] + 1).fill(null));\n    const f = (j, rem) => {\n    \n      if (rem === 0) {\n        return values[i][j - 1][1];\n      }\n\n      // cant do\n      if (j >= values[i].length) return Infinity;\n      \n      if (dp[j][rem] !== null) return dp[j][rem];\n\n      let min = Infinity;\n      // take\n      if (values[i][j][0] <= rem) min = Math.min(min, f(j + 1, rem - values[i][j][0]));\n\n      // not take\n      min = Math.min(min, f(j + 1, rem));\n      \n      return dp[j][rem] = min;\n    }\n    \n    if (nums[i] === 0) {\n      earliest[i] = 0;\n      continue;\n    }\n    const e = f(0, nums[i]);\n    // console.log(values[0])\n    // console.log(i, e)\n\n    if (e === Infinity) return -1;\n    earliest[i] = e;\n  }\n  \n  // console.log(earliest)\n  \n  const res =  Math.max(...earliest);\n  // if (res === 0) return 0;\n  return res + 1;\n};\n","author":"espr3ss0","submissionId":"1575193945"},[]]},{"804":[{"id":"804","fileName":"1575194017.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        dp = [set([0]) for _ in range(len(nums))]\n        if all(x == 0 for x in nums): return 0\n        for k in range(1, len(queries) + 1):\n            l, r, val = queries[k - 1]\n            for i in range(l, r + 1):\n                p = {x + val for x in dp[i]}\n                dp[i].update(p)\n\n            if all(nums[i] in dp[i] for i in range(len(nums))): return k\n        return -1","author":"Eason","submissionId":"1575194017"},[]]},{"805":[{"id":"805","fileName":"1575194149.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        '''\n            nums: array[int]\n                nums.n ~ 1..10\n            queries: [li, ri, vali]\n                queries.n <= 1000\n                \n                select subset in range [li, ri]\n                decrease value at selected index by vali\n                    => Select any indices if [li, ri] -> decrease by `vali`\n\n            ZERO array -> all elements == 0\n\n            RETURN MIN possible NON-negative value of `k` -> process first `k` queries\n                if not found -> -1\n            Naive:\n                -> for each index\n                    find min operation\n        '''\n        def can_zero_out(nums, queries_k):\n            N = len(nums)\n            coverage = [[] for _ in range(N)]\n            for (l, r, v) in queries_k:\n                for i in range(l, r + 1):\n                    coverage[i].append(v)\n            for i in range(N):\n                target = nums[i]\n                if target == 0:\n                    continue\n                possible_sums = {0}\n                for val in coverage[i]:\n                    new_sums = set(possible_sums)  # start by copying\n                    for s in possible_sums:\n                        new_val = s + val\n                        if new_val == target:  \n                            new_sums.add(new_val)\n                            break\n                        elif new_val < target:\n                            new_sums.add(new_val)\n                    possible_sums = new_sums\n                    if target in possible_sums:\n                        break\n                if target not in possible_sums:\n                    return False\n            return True\n        if not can_zero_out(nums, queries):\n            return -1\n        l, r = 0, len(queries) + 1\n        while l < r:\n            m = (l + r) // 2\n            if can_zero_out(nums, queries[:m]):\n                r = m\n            else:\n                l = m + 1\n        return l\n                    \n                \n        ","author":"ymn5tfnXS0","submissionId":"1575194149"},[]]},{"806":[{"id":"806","fileName":"1575194165.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        myStore = [set([num]) for num in nums]\n        remain = len(nums) - sum([1 if num == 0 else 0 for num in nums])\n        if remain == 0:\n            return 0\n            \n        # print(remain)\n        for j, v in enumerate(queries):\n            l, r, n = v\n            for i in range(l, r + 1):\n                st = myStore[i]\n                if 0 in st:\n                    continue\n                    \n                tmp = set()\n                for itm in st:\n                    if itm - n >= 0:\n                        tmp.add(itm - n)\n                    tmp.add(itm)\n                    if itm - n == 0:\n                        # print(itm, n, j)\n                        remain -= 1\n                        break\n                myStore[i] = tmp\n                        \n            if remain == 0:\n                return j + 1\n\n        return -1","author":"syji","submissionId":"1575194165"},[]]},{"807":[{"id":"807","fileName":"1575194339.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) \n    {\n        int k=-1e9;\n        \n        for(int i=0;i<a.size();i++){\n            if(!a[i])\n                continue;\n            vector<int> dp(a[i]+1, 0);\n            dp[0] = 1; \n            int ct=0;\n            for(int j=0;j<q.size();j++){\n                if(i<q[j][0] || i>q[j][1] || q[j][2]>a[i])\n                    continue;\n                vector<int> ndp;\n                ndp = dp;\n                int cur = q[j][2];\n                for(int l=0;l<a[i]+1;l++){\n                    if(l+cur > a[i])\n                        break;\n                    if(dp[l])\n                        ndp[l+cur]=1;\n                }\n                dp = ndp;\n                if(dp[a[i]])\n                {\n                    k = max(k, j+1);\n                    break;\n                }\n            }\n            if(!dp[a[i]])\n                return -1;\n        }\n        return k==-1e9 ? 0 : k;\n    }\n};","author":"prasoon107","submissionId":"1575194339"},[]]},{"808":[{"id":"808","fileName":"1575194049.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        # find min for each num \n        @cache\n        def dfs(i,j,r):\n            if r == 0:\n                return 0\n            if j==len(queries):\n                return inf\n            \n            ret = inf\n            if queries[j][0]<=i<=queries[j][1]:\n                if r>=queries[j][2]:\n                    # use \n                    ret=min(ret, 1+dfs(i,j+1,r-queries[j][2]))\n            # not use \n            ret=min(ret, 1+dfs(i,j+1,r))\n            return ret\n         \n        ret = 0\n        for i, n in enumerate(nums):\n            t = dfs(i,0,nums[i])\n            #print(i, t)\n            ret=max(ret, t)\n            dfs.cache_clear()\n        return ret if ret!=inf else -1\n        ","author":"zanbin2046python","submissionId":"1575194049"},[]]},{"809":[{"id":"809","fileName":"1575193899.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if sum(nums) == 0:\n            return 0\n\n        n = len(nums)\n        max_target = max(nums)\n        mask = (1 << (max_target + 1)) - 1\n    \n        dp = [1] * n  # dp[i] is an integer where the jth bit is set if sum j is reachable.\n    \n        for k, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                dp[i] |= (dp[i] << val)\n                dp[i] &= mask\n            \n            # Check if for every index, the target value is reachable.\n            if all((dp[i] >> nums[i]) & 1 for i in range(n)):\n                return k + 1  # queries are 0-indexed, so k+1 queries have been processed.\n        \n        return -1","author":"Tsung Han Wu","submissionId":"1575193899"},[]]},{"811":[{"id":"811","fileName":"1575194581.txt","sourceCode":"class Solution {\npublic:\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        vector<vector<bool>> dp(n,vector<bool>(1001));\n        for(int i=0;i<n;i++)dp[i][0]=1;\n        int zc=0;\n        for(int i=0;i<n;i++)zc+=(nums[i]==0);\n        if(zc==n)return 0;\n        for(int i=0;i<queries.size();i++){\n            int l=queries[i][0],r=queries[i][1],vl=queries[i][2];\n            for(int j=l;j<=r;j++){\n                for(int k=1000;k>=0;k--){\n                    if(dp[j][k]&&k+vl<=1000)dp[j][k+vl]=1;\n                }\n            }\n            bool pos=1;\n            for(int j=0;j<nums.size();j++){\n                if(!dp[j][nums[j]]){\n                    pos=0;\n                    break;\n                }\n            }\n            if(pos)return i+1;\n        }\n        return -1;\n    }\n};","author":"Hrithik Kumar","submissionId":"1575194581"},[]]},{"812":[{"id":"812","fileName":"1575194677.txt","sourceCode":"class Solution {\npublic:\n\n    int solve(vector<pair<int, int>> &v, int sum, int i, vector<vector<int>> &dp){\n        if(sum < 0) return 1e9;\n        if(sum == 0) return 0;\n\n        if(i >= v.size()) return 1e9;\n\n        if(dp[i][sum] != -1) return dp[i][sum];\n\n        int skip = solve(v, sum, i+1, dp);\n        int pick = max(v[i].second, solve(v, sum-v[i].first, i+1, dp) );\n\n        return dp[i][sum] = min(pick, skip);\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n\n        vector<vector<pair<int, int>>> v(n);\n\n        int j =1;\n        for(auto it : queries){\n            int s = it[0], e = it[1], val = it[2];\n\n            for(int i=s;i<=e;i++){\n                v[i].push_back({val, j});\n            }\n\n            j++;\n        }\n\n        vector<int> ans(n, 1e9);\n        for(int i=0;i<n;i++){\n             vector<vector<int>> dp(v[i].size() + 1, vector<int>(nums[i] + 1, -1));\n\n            ans[i] = solve(v[i], nums[i], 0, dp);\n        }\n\n        int maxi = *max_element(ans.begin(), ans.end());\n        if(maxi >= 1e9) return -1;\n        return maxi;\n    }\n};","author":"Vivek Katkar","submissionId":"1575194677"},[]]},{"813":[{"id":"813","fileName":"1575194815.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int q = queries.length;\n        ArrayList<Set<Integer>> list = new ArrayList<>();\n        for(int i=0;i<n;i++) list.add(new HashSet<>());\n        boolean ok[] = new boolean[n];\n        for(int i=0;i<n;i++){\n            list.get(i).add(nums[i]);\n            if(nums[i]==0) ok[i] = true;\n        }\n        boolean yess = true;\n        for(int i=0;i<n;i++) if(!ok[i]){\n            yess = false;\n            break;\n        }\n        if(yess) return 0;\n        for(int i=0;i<q;i++){\n            u:for(int j=queries[i][0];j<=queries[i][1];j++){\n                if(ok[j]) continue;\n                Set<Integer> temp = new HashSet<>();\n                for(int k : list.get(j)){\n                    int val = k - queries[i][2];\n                    if(val==0){\n                        ok[j] = true;\n                        continue u;\n                    }\n                    else if(val < 0) continue;\n                    else temp.add(val);\n                }\n                list.get(j).addAll(temp);\n            }\n            boolean yes = true;\n            for(int j=0;j<n;j++){\n                if(!ok[j]){\n                    yes = false;\n                    break;\n                }\n            }\n            //System.out.println(list);\n            if(yes) return i + 1;\n        }\n        return -1;\n    }\n}","author":"Sudeap Thapa","submissionId":"1575194815"},[]]},{"815":[{"id":"815","fileName":"1575195063.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& asks) {\n        int n = nums.size(), q = asks.size();\n\n        auto rec = [](auto& self, int rem, int i, vector<int> &v,\n                      vector<vector<int>> &dp) {\n            if (rem == 0)\n                return 1;\n            if (i == v.size())\n                return 0;\n            int& ret = dp[rem][i];\n            if (~ret)\n                return ret;\n            ret = self(self, rem, i + 1, v, dp);\n            if (rem - v[i] >= 0)\n                ret |= self(self, rem - v[i], i + 1, v, dp);\n            return ret;\n        };\n        auto can = [&](int mid) {\n            vector<vector<int>> values(n);\n            for (int g = 0; g < mid; g++) {\n                int l = asks[g][0];\n                int r = asks[g][1];\n                int val = asks[g][2];\n                for (int i = l; i <= r; i++)\n                    values[i].push_back(val);\n            }\n            for (int g = 0; g < n; g++) {\n                vector<vector<int>> dp(1001, vector<int>(values[g].size(),-1));\n\n                int temp = rec(rec, nums[g], 0, values[g], dp);\n                if (temp == 0)\n                    return 0;\n            }\n            return 1;\n        };\n        int st = 0, end = q, mid, ans = -1;\n        while (st <= end) {\n            mid = (st + end) / 2;\n            if (can(mid)) {\n                ans = mid;\n                end = mid - 1;\n            } else\n                st = mid + 1;\n        }\n        return ans;\n    }\n};","author":"George Magde","submissionId":"1575195063"},[]]},{"816":[{"id":"816","fileName":"1575194704.txt","sourceCode":"class Solution {\npublic:\n    vector<int> v;\n    unordered_map<int, unordered_map<int, int>> dp;\n\n    int helper(int idx, int target, const vector<vector<int>>& queries) {\n        if (target == 0) return -1;\n        if (idx >= v.size()) return INT_MAX;\n\n        if (dp[idx].find(target) != dp[idx].end()) return dp[idx][target];\n\n        int query_idx = v[idx];\n        int val = queries[query_idx][2];\n\n        int result = INT_MAX;\n\n        int skip = helper(idx + 1, target, queries);\n        if (skip != INT_MAX) {\n            result = min(result, skip);\n        }\n\n        if (val <= target) {\n            int use = helper(idx + 1, target - val, queries);\n            if (use != INT_MAX) {\n                result = min(result, max(query_idx, use));\n            }\n        }\n\n        dp[idx][target] = result;\n        return result;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        int ans = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) continue;\n\n            v.clear();\n            for (int j = 0; j < m; j++) {\n                if (queries[j][0] <= i && i <= queries[j][1]) {\n                    v.push_back(j);\n                }\n            }\n\n            if (v.empty()) {\n                return -1;\n            }\n\n            dp.clear();\n            int res = helper(0, nums[i], queries);\n\n            if (res == INT_MAX) {\n                return -1;\n            }\n\n            ans = max(ans, res + 1);\n        }\n\n        if (ans <= m) {\n            return ans;\n        }\n\n        return -1;\n    }\n};","author":"dte_pk","submissionId":"1575194704"},[]]},{"817":[{"id":"817","fileName":"1575195287.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        vector<vector<int>>v(n,vector<int>(1001,0));\n        for(int i=0;i<n;i++){\n            v[i][0]=1;\n        }\n        bool flag=true;\n        for(auto i:nums){\n            if(i!=0){\n                flag=false;\n                break;\n            }\n        }\n        if(flag) return 0;\n        for(int i=0;i<queries.size();i++){\n            int a=queries[i][0];\n            int b=queries[i][1];\n            int c=queries[i][2];\n            for(int j=a;j<=b;j++){\n                 for(int k=1000;k>=c;k--){\n                     v[j][k]|=v[j][k-c];\n                 }\n                for(int k=nums[j]+1;k<=1000;k++){\n                    v[j][k]=0;\n                }\n            }\n            flag=true;\n            for(int i=0;i<n;i++){\n                if(!v[i][nums[i]]){\n                    flag=false;\n                    break;\n                }\n            }\n            if(flag)return (i+1);\n        }\n        return -1;\n    }\n};","author":"Piyush Bihani","submissionId":"1575195287"},[]]},{"818":[{"id":"818","fileName":"1575195115.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    private boolean canSumTo(List<Integer> values, int target, int idx, HashMap<String,Boolean> map) {\n        if (target == 0) return true;\n        if (idx >= values.size()) return false;\n        String key = idx + \" # \" + target;\n        if (map.containsKey(key)) return map.get(key);\n        if (canSumTo(values, target, idx + 1, map)) {\n            map.put(key, true);\n            return true;\n        }\n        int current = values.get(idx);\n        if (current <= target && canSumTo(values, target - current, idx + 1, map)) {\n            map.put(key, true);\n            return true;\n        }\n        \n        map.put(key, false);\n        return false;\n    }\n    \n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length, m = queries.length;\n        int st =0,end = m;\n        int ans = -1;\n        while(st <=end){\n            int mid = (st+end)/2;\n            boolean flag = true;\n            for (int i = 0; i < n; i++) {\n                List<Integer> list = new ArrayList<>();\n                for (int j = 0; j < mid; j++) {\n                    int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                    if (l <= i && i <= r) {\n                        list.add(val);\n                    }\n                }\n                HashMap<String, Boolean> map = new HashMap<>();\n                if (!canSumTo(list, nums[i], 0, map)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                ans = mid;\n                end = mid-1;\n            }\n            else st = mid+1;\n        }\n        return ans;\n    }\n    \n}\n","author":"Ankith_Kumar","submissionId":"1575195115"},[]]},{"819":[{"id":"819","fileName":"1575195303.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l = 0, r = queries.size() - 1, ans = -1, n = nums.size();\n\n        if (all_of(nums.begin(), nums.end(), [](int x) { return x == 0; })) \n            return 0;\n\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            vector<vector<int>> v(n);\n\n            for (int i = 0; i <= mid; i++) {\n                for (int j = queries[i][0]; j <= queries[i][1]; j++) {\n                    v[j].emplace_back(queries[i][2]);\n                }\n            }\n\n            vector<int> a = nums;\n            bool flag= true;\n\n            for (int i = 0; i < n; i++) {\n                unordered_set<int> dp = {0};\n\n                for (int val : v[i]) {\n                    vector<int> tmpsum;\n                    for (int s : dp) {\n                        tmpsum.push_back(s + val);\n                    }\n                    dp.insert(tmpsum.begin(), tmpsum.end());\n                }\n\n                if (dp.count(nums[i])) {\n                    a[i] = 0;\n                } else {\n                    flag= false;\n                }\n            }\n\n            if (flag) {\n                ans = mid + 1;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n\n        return ans;\n    }\n};\n","author":"Manya_24","submissionId":"1575195303"},[]]},{"820":[{"id":"820","fileName":"1575194945.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int max = 0;\n        for(int i = 0; i < n; i++) {\n            if(nums[i] == 0)\n                continue;\n            int need = f(i, nums[i], queries);\n            if(need == -1)\n                return -1;\n            max = Math.max(need, max);\n        }\n        return max;\n    }\n\n    public int f(int ind, int n, int[][] q) {\n        int qs = q.length;\n        int[] dp = new int[n+1];\n        Arrays.fill(dp, -1);\n        dp[n] = 0;\n        for(int i = 0; i < qs && dp[0] == -1; i++) {\n            int[] ndp = new int[n+1];\n            for(int j = n; j >= 0; j--) {\n                ndp[j] = dp[j];\n            }\n            if(q[i][0] <= ind && ind <= q[i][1]) {\n                for(int j = n; j >= 0; j--) {\n                    if(dp[j] == -1)\n                        continue;\n                    int nind = j - q[i][2];\n                    if(nind < 0)\n                        continue;\n                    ndp[nind] = i;\n                }\n            }\n            dp = ndp;\n        }\n        return dp[0] == -1 ? -1 : dp[0] + 1;\n    }\n}","author":"jam","submissionId":"1575194945"},[]]},{"821":[{"id":"821","fileName":"1575195251.txt","sourceCode":"class Solution {\npublic:\n    int f(int n, int i, vector<vector<int>>& queries, int k) {\n        bitset<1005> bt;\n        if (n == 0) return 1;\n        bt[0] = 1;\n        \n        for (int j = 0;j<=k;j++) {\n            if (i >= queries[j][0] && i <= queries[j][1]) {\n                bt = bt | (bt << queries[j][2]);\n                \n                if (bt[n] == 1) return 1;\n            }\n        }\n        return -1;\n    }\n    \n    bool check(vector<vector<int>>& queries, vector<int>& nums, int k) {\n        for (int i=0;i<nums.size();i++) {\n            int x = f(nums[i], i, queries, k);\n            if (x == -1) return false;\n        }\n        \n        return true;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l = 0, r = queries.size() - 1, ans = -1;\n        int sum = 0;\n        for(int i=0;i<nums.size();i++) {\n            sum += nums[i];\n        }\n        \n        if (sum == 0) return 0;\n        \n        while(l <= r) {\n            int mid = l + (r - l) / 2;\n            \n            if (check(queries, nums, mid)) {\n                ans = mid;\n                r = mid - 1;\n            }\n            else l = mid + 1;\n        }\n        \n        if (ans == -1) return ans;\n        return ans + 1;\n    }\n};","author":"Aitijhya Modak","submissionId":"1575195251"},[]]},{"822":[{"id":"822","fileName":"1575195154.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(), maxi = *max_element(nums.begin(), nums.end());\n        vector<vector<bool>> dp(n, vector<bool>(maxi+1));\n        int zeros=0;\n        for (int i=0; i<n; ++i) {\n            dp[i][nums[i]] = true;\n            zeros += nums[i] == 0;\n        }\n        if (zeros == n) return 0;\n        int nqueries=queries.size();\n        for (int i=0; i<nqueries; ++i) {\n            int l=queries[i][0];\n            int r=queries[i][1];\n            int val=queries[i][2];\n            for (int j=l; j<=r; ++j) {\n                for (int k=val; k<=maxi; ++k) {\n                    if (dp[j][k]) dp[j][k-val] = true;\n                }\n            }\n            zeros=0;\n            for (int j=0; j<n; ++j) {\n                zeros += dp[j][0] == true;\n            }\n            if (zeros == n) return i+1;\n        }\n        return -1;\n    }\n};\n/*\n4,3,2,1\n  -----\n4 1 0 1\n\n\n10 digits, range 0 to 1000\n1 1 2 3 4 5\nif each digit has isPossible(0) as true, then return k\nat end return -1\n\n*/","author":"justdoit1999","submissionId":"1575195154"},[]]},{"823":[{"id":"823","fileName":"1575195566.txt","sourceCode":"class Solution {\npublic:\n    int f(vector<int>& nums, vector<vector<int>>& queries,int idx,int num,int nidx,vector<vector<int>> &dp){\n        if(num==0) return idx;\n        if(idx==queries.size()) return INT_MAX;\n        if(dp[num][idx]!=-1) return dp[num][idx];\n        int a=INT_MAX;\n        if(nidx>=queries[idx][0] && nidx<=queries[idx][1] && num>=queries[idx][2]){\n            a=f(nums,queries,idx+1,num-queries[idx][2],nidx,dp);\n        }\n        int b=f(nums,queries,idx+1,num,nidx,dp);\n        return dp[num][idx] = min(a,b);\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int q=queries.size();\n        int k=INT_MIN;\n        for(int i=0;i<nums.size();i++){\n            vector<vector<int>> dp(nums[i]+1,vector<int> (q,-1));\n            int temp=f(nums,queries,0,nums[i],i,dp);\n            if(temp==INT_MAX) return -1;\n            k=max(k,temp);\n        }\n        return k;\n    }\n};","author":"Devansh Singh","submissionId":"1575195566"},[]]},{"824":[{"id":"824","fileName":"1575195448.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        arr = [-1] * len(nums)\n        for i, n in enumerate(nums):\n            if n == 0:\n                arr[i] = 0\n                continue\n            s = set()\n            s.add(n)\n            for j,q in enumerate(queries):\n                l = q[0]\n                r = q[1]\n                v = q[2]\n                if l <= i <= r:\n                    u = s.copy()\n                    for t in u:\n                        s.add(t-v)\n                if 0 in s:\n                    arr[i] = j+1\n                    break\n        \n        return max(arr) if min(arr) >= 0 else -1","author":"Flo","submissionId":"1575195448"},[]]},{"825":[{"id":"825","fileName":"1575195385.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        Q = len(queries)\n        res = []\n\n        for i, num in enumerate(nums):\n            # Create a DP table with dimensions (Q+1) x (num+1)\n            dp = [[inf] * (num + 1) for _ in range(Q + 1)]\n    \n            dp[Q][0] = Q\n         \n\n            for q in range(Q - 1, -1, -1):\n                l, r, v = queries[q]\n                for cur in range(num + 1):\n                    if cur == 0:\n\n                        dp[q][0] = q\n                    else:\n  \n                        if not (l <= i <= r):\n                            dp[q][cur] = dp[q + 1][cur]\n                        else:\n\n                            skip = dp[q + 1][cur]\n\n                            take = dp[q + 1][cur - v] if cur >= v else inf\n                            dp[q][cur] = min(skip, take)\n            res.append(dp[0][num])\n\n        ans = max(res)\n        return ans if ans != inf else -1\n\n","author":"user5779lS","submissionId":"1575195385"},[]]},{"826":[{"id":"826","fileName":"1575195784.txt","sourceCode":"class Solution {\npublic:\n\nbool isSubsetSum(vector<int> &arr, int sum) {\n        int n = arr.size();\n        vector<bool> prev(sum + 1, false), curr(sum + 1, false);\n        prev[0] = true;\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= sum; j++) {\n                if (j < arr[i - 1])\n                    curr[j] = prev[j];\n                else\n                    curr[j] = prev[j] || prev[j - arr[i - 1]];\n            }\n            prev = curr;\n        }\n        return prev[sum];\n    }\n\n    bool check(vector<int> &nums, vector<vector<int>> &q, int mid) {\n        map<int, vector<int>> mp;\n        \n        for (int i = 0; i < mid; i++) {\n            int l = q[i][0], r = q[i][1], val = q[i][2];\n            for (int j = l; j <= r; j++)\n                mp[j].push_back(val);\n        }\n\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == 0) continue;\n\n            vector<int> v;\n            if (mp.count(i))\n                v = mp[i];\n\n            if (!isSubsetSum(v, nums[i]))\n                return false;\n        }\n\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l = 0, r = queries.size(), ans = -1;\n\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            if (check(nums, queries, mid)) {\n                ans = mid;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n\n        return ans;\n    }\n};","author":"Bhawnachauhan","submissionId":"1575195784"},[]]},{"827":[{"id":"827","fileName":"1575195690.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = -1;\n\n        int n = nums.size();\n\n        for (int i = 0; i < n; i++) {\n            vector<vector<int>> dec;\n            for (int idx = 0; idx < queries.size(); idx++) {\n                auto &q = queries[idx];\n                if (q[0] <= i && q[1] >= i) {\n                    if (q[2] <= nums[i]) {\n                        dec.push_back({q[2], idx+1});\n                    }\n                }\n            }\n            int k = findTarget(nums[i], dec);\n            if (k == -1) {\n                return -1;\n            } else {\n                if (k > ans)\n                    ans = k;\n            }\n        }\n\n        return ans;\n    }\n\n    int findTarget(int n, vector<vector<int>> &dec) {\n        if (n == 0)\n            return 0;\n        unordered_set<int> here;\n        for (auto &d: dec) {\n            if (d[0] == n)\n                return d[1];\n            unordered_set<int> tmp;\n            for (auto h: here) {\n                if (h + d[0] == n) {\n                    return d[1];\n                } else if (h + d[0] < n) {\n                    tmp.insert(h + d[0]);\n                }\n            }\n            here.insert(d[0]);\n            for (auto t: tmp) {\n                here.insert(t);\n            }\n        }\n        return -1;\n    }\n};","author":"dongli-_-","submissionId":"1575195690"},[]]},{"828":[{"id":"828","fileName":"1575195732.txt","sourceCode":"class Solution {\npublic:\n    bool check(int ind,vector<int>& nums,vector<vector<int>>& queries){\n        int n=nums.size();\n        vector<vector<int>> avail(n);\n        for(int i=0;i<=ind;++i){\n            auto q=queries[i];\n            int l=q[0],r=q[1],val=q[2];\n            for(int i=l;i<=r;++i){\n                avail[i].push_back(val);\n            }\n        }\n        for(int i=0;i<n;++i){\n            vector<int> dp(nums[i]+1,-1);\n            dp[0]=1;\n            // cout<<i<<\" \"<<avail[i].size()<<endl;\n            for(auto &e:avail[i]){\n                for(int j=nums[i]-e;j>=0;--j){\n                    if(dp[j]==1){\n                        dp[j+e]=1;\n                    }\n                }\n            }\n            if(dp[nums[i]]!=1)return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        int q=queries.size();\n        int l=0,r=q-1;\n        int ans=r+1;\n        int flag=1;\n        for(int i=0;i<n;++i){\n            if(nums[i]){\n                flag=0;\n                break;\n            }\n        }\n        if(flag==1)return 0;\n        while(l<=r){\n            int mid=(l+r)/2;\n            // cout<<mid<<endl;\n            if(check(mid,nums,queries)){\n                ans=mid;\n                r=mid-1;\n            }else{\n                l=mid+1;\n            }\n        }\n        if(ans==q)return -1;\n        else return ans+1;\n    }\n};","author":"varuos","submissionId":"1575195732"},[]]},{"829":[{"id":"829","fileName":"1575195717.txt","sourceCode":"class Solution {\npublic:\n    bool rec(const vector<int>& v, int idx, int rem, vector<vector<int>>& dp) {\n        if (rem == 0) return true;\n        if (idx == v.size()) return false;\n        if (dp[idx][rem] != -1) \n            return dp[idx][rem] == 1;\n        bool no = rec(v,idx+1,rem,dp);\n        bool yes = false;\n        if (rem >= v[idx]) yes = rec(v,idx+1,rem-v[idx],dp);\n        dp[idx][rem] = (yes || no) ? 1 : 0;\n        return yes || no;\n    }\n    \n    bool okay(vector<int>& v, int tgt) {\n        int n = v.size();\n        vector<vector<int>> dp(n+1,vector<int>(tgt+1,-1));\n        return rec(v,0,tgt,dp);\n    }\n\n    bool ok(vector<int>& nums,vector<vector<int>>& q,int mid){\n        int n = nums.size();\n        unordered_map<int,vector<int>> mp;\n        for (int i=0;i<mid;i++){\n            for (int j=q[i][0];j<=q[i][1];j++) mp[j].push_back(q[i][2]);\n        }\n        bool iska = true;\n        for (int i=0;i<n;i++){\n            if (!okay(mp[i],nums[i])) {\n                iska = false;\n                break;\n            }\n        }\n        return iska;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n        int lo = 0, hi = q.size();\n        while(hi-lo > 1){\n            int mid = (hi+lo)/2;\n            if (ok(nums,q,mid)){\n                hi = mid;\n            }\n            else{\n                lo = mid;\n            }\n        }\n        if (ok(nums,q,lo)) return lo;\n        if (ok(nums,q,hi)) return hi;\n        return -1;\n    }\n};","author":"Kushhhhh42","submissionId":"1575195717"},[]]},{"830":[{"id":"830","fileName":"1575195884.txt","sourceCode":"class Solution {\npublic:\n    bool isPossible(vector<int>& nums, int target) {\n        if (target == 0) return true;\n        vector<bool> dp(target + 1, false);\n        dp[0] = true;\n\n        for (int num : nums) {\n            for (int j = target; j >= num; j--) {\n                dp[j] = dp[j] || dp[j - num];\n            }\n        }\n\n        return dp[target];\n    }\n\n    bool solve(vector<int>& nums, vector<vector<int>>& queries, int cnt) {\n        int n = nums.size();\n        \n        for (int i = 0; i < n; i++) {\n            vector<int> temp;\n            for (int j = 0; j <= cnt; j++) {\n                int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                if (i >= l && i <= r) {\n                    temp.push_back(val);\n                }\n            }\n            if (!isPossible(temp, nums[i])) return false;\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        bool flag = true;\n        for(int i=0;i<nums.size();i++) if(nums[i]!=0) flag=false;\n        if(flag) return 0;\n        for (int i = 0; i < queries.size(); i++) {\n            if (solve(nums, queries, i)) return i + 1;\n        }\n        return -1;\n    }\n};\n","author":"Utkarsh1112","submissionId":"1575195884"},[]]},{"831":[{"id":"831","fileName":"1575195816.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def possible(k):\n            def subset_sum(i, _sum):\n                key = (i, _sum)\n                if key in memo:\n                    return memo[key]\n                if _sum == 0:\n                    memo[key] = True\n                elif i < 0:\n                    memo[key] = False\n                else:\n                    memo[key] = subset_sum(i-1, _sum) or subset_sum(i-1, _sum - val_list[i])\n                return memo[key]\n            decrements = [[] for _ in range(n)]\n            for j in range(k):\n                l, r, val = queries[j]\n                for i in range(l, r+1):\n                    decrements[i].append(val)\n            for i, val_list in enumerate(decrements):\n                memo = {}\n                if not subset_sum(len(val_list)-1, nums[i]):\n                    return False\n            return True\n        n, m = len(nums), len(queries)\n        l, h = 0, m+1\n        while l < h:\n            mid = (l + h) // 2\n            if possible(mid):\n                h = mid\n            else:\n                l = mid + 1\n        return -1 if l == m+1 else l","author":"Rajesh S V","submissionId":"1575195816"},[]]},{"832":[{"id":"832","fileName":"1575195894.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if(max(nums)==0):\n            return 0\n        n = len(nums)\n        l = 0 \n        r = len(queries)-1\n        ans = r + 1\n        isPoss=  False\n        while(r>=l):\n            # print('-----',l,r)\n            m = l + (r-l)//2\n            li = [{0:1} for _ in range(n)]\n            # print(li)\n\n            for i in range(m+1):\n                p,q,rr = queries[i]\n                for ind in range(p,q+1):\n                    ttmp = list(li[ind].keys())\n                    for k in ttmp:\n                        if(k+rr<=nums[ind]):\n                            li[ind][k+rr] = 1\n\n            # for i in li:\n                # print(m,i)\n\n            poss= True\n            for i in range(n):\n                if(nums[i] not in li[i]):\n                    poss = False\n                    break\n\n            if(poss):\n                ans = min(ans,m+1)\n                isPoss = True\n                r = m-1\n            else:\n                l = m+1\n\n            # print('last',l,r)\n                            \n        if(isPoss):\n            return ans\n        return -1\n\n        \n        ","author":"Arun","submissionId":"1575195894"},[]]},{"833":[{"id":"833","fileName":"1575196051.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        TreeSet<Integer>[] trees = new TreeSet[nums.length];\n        for(int i=0; i<nums.length; i++) {\n            trees[i] = new TreeSet<>();\n            trees[i].add(nums[i]);\n        }\n        for(int q=0; q<queries.length; q++) {\n            if(isAllZero(trees)) {\n                return q;\n            }\n            decrement(trees, queries[q][0], queries[q][1], queries[q][2]);\n        }\n        return isAllZero(trees) ? queries.length : -1;\n    }\n\n    private void decrement(TreeSet<Integer>[] trees, int start, int end, int val) {\n        for(int i=start; i<=end; i++) {\n            List<Integer> list = new ArrayList<>();\n            for(int x: trees[i]) {\n                if(x-val>=0) {\n                    list.add(x-val);\n                }\n            }\n            trees[i].addAll(list);\n        }\n    }\n\n    private boolean isAllZero(TreeSet<Integer>[] trees) {\n        for(int i=0; i<trees.length; i++) {\n            if(trees[i].first()>0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}","author":"Jawaherul Alam","submissionId":"1575196051"},[]]},{"834":[{"id":"834","fileName":"1575195857.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int beg = 0, end = queries.size();\n        int res = -1;\n        while(beg <= end){\n            int mid = beg + (end-beg)/2;\n            if(isPossible(nums, queries, mid)){\n                res = mid;\n                end = mid-1;\n            }\n            else{\n                beg = mid+1;\n            }\n        }\n        return res;\n    }\n\n    bool isPossible(vector<int>& nums, vector<vector<int>>& queries, int ind){\n        vector<vector<int>> candidates(nums.size());\n        for(int i = 0; i < ind; i++){\n            auto q = queries[i];\n            for(int i = q[0]; i <= q[1]; i++){\n                candidates[i].push_back(q[2]);\n            }\n        }\n        int count = 0;\n        for(int i = 0; i < nums.size(); i++){\n            if(isPossible(nums[i], candidates[i])){\n                count++;\n            }\n        }\n        return count == nums.size();\n    }\n\n    bool isPossible(int target_sum, vector<int> arr){\n        int n = arr.size();\n        vector<vector<bool>> dp(n + 1, vector<bool>(target_sum + 1, false));\n\n        for (int i = 0; i <= n; ++i) {\n            dp[i][0] = true;\n        }\n\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= target_sum; ++j) {\n                if (arr[i - 1] <= j) {\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - arr[i - 1]];\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n\n        return dp[n][target_sum];\n    }\n};","author":"Shikha Verma","submissionId":"1575195857"},[]]},{"835":[{"id":"835","fileName":"1575196110.txt","sourceCode":"// iostream::sync_with_stdio(false); cin.tie(NULL);\n#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define Sree ios_base::sync_with_stdio(false);\n#define Vardhan cin.tie(NULL);\n\n#define pi pair<int,int>\n#define ppi pair<pair<int,int>,int>\n#define pip pair<int,pair<int,int>>\n#define umii unordered_map<int,int>\n#define mii map<int,int>\n#define umsi unordered_map<string,int>\n#define msi map<string,int>\n#define umss unordered_map<string,string>\n#define mss map<string,string>\n#define vi vector<int>\n#define vb vector<bool>\n#define vll vector<ll>\n#define vvi vector<vector<int>>\n#define vvb vector<vector<bool>>\n#define vpi vector<pair<int,int>>\n#define vpic vector<pair<int,char>>\n#define vvpi vector<vector<pair<int,int>>>\n#define pqimax priority_queue<int>\n#define pqimin priority_queue<int,vector<int>,greater<int>>\n#define ll long long\n#define pb push_back\n#define br cout<<endl;\n#define Name \"Sreevardhan\"\n\n\n#define fl(i,n) for(int i=0;i<n;i++)\n#define fli(i,n) for(int i=n-1;i>=0;i--)\n#define srt(v) sort(v.begin(),v.end());\n#define srtg(v) sort(v.begin(),v.end(),greater<int>());\n\n#define print(_) cout<<_<<\" \";\n#define println(_) cout<<_<<endl;\n#define inp(_) for(auto &__:_) cin>>__;\n#define prv(_) for(auto &__:_) cout<<__<<\" \";\n\nclass Solution {\npublic:\n    bool find(vi &nums,int mid,vvi& queries,map<pi,bool> &m){\n        int n = nums.size();\n        fl(i,n){\n            vi vals;\n            fl(j,mid){\n                if(queries[j][0]<=i && queries[j][1]>=i){\n                    vals.pb(queries[j][2]);\n                }\n            }\n            int num = nums[i];\n            vb dp(num+1);\n            dp[0]=true;\n            for(int &v:vals){\n                for(int t = num; t>=v;t--){\n                    dp[t]=dp[t]|dp[t-v];\n                }\n            }\n            if(!dp[num]) return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        Sree Vardhan\n        int k=queries.size();\n        int i=0,j=k;\n        map<pi,bool> m;\n        while(i<=j){\n            int mid = i + (j-i)/2;\n            bool x = find(nums,mid,queries,m);\n            if(x){\n                j=mid-1;\n            }\n            else{\n                i=mid+1;\n            }\n        }\n        return i>k? -1 :i;\n    }\n};\n","author":"Sreevardhan Reddy","submissionId":"1575196110"},[]]},{"836":[{"id":"836","fileName":"1575196105.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        \n        def is_formable(counter: List[int], target: int) -> bool:\n            dp = [False] * (target + 1)\n            dp[0] = True\n            \n            for num, count in enumerate(counter):\n                if count == 0:\n                    continue\n                for t in range(target, num - 1, -1):\n                    for c in range(1, count + 1):\n                        if c * num > t:\n                            break\n                        dp[t] |= dp[t - c * num]\n                        if dp[target]:\n                            return True\n            return dp[target]\n\n        def is_valid(k: int) -> bool:\n            counter = [0] * 11\n            events = []\n            \n            for i in range(k):\n                l, r, x = queries[i]\n                events.append((l, x))\n                events.append((r + 1, -x))\n\n            events.sort()\n            \n            j = 0\n            for i, num in enumerate(nums):\n                while j < len(events) and events[j][0] == i:\n                    _, val = events[j]\n                    counter[abs(val)] += 1 if val > 0 else -1\n                    j += 1\n                \n                if not is_formable(counter, num):\n                    return False\n\n            return True\n\n        if not is_valid(len(queries)):\n            return -1\n        \n        left, right = 0, len(queries)\n        while left < right:\n            mid = (left + right) // 2\n            if is_valid(mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left","author":"dinhlockt02","submissionId":"1575196105"},[]]},{"837":[{"id":"837","fileName":"1575196131.txt","sourceCode":"class Solution {\npublic:\n    bool helper(int k, vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        // For each position, check if we can exactly \"pay\" the required value using temp from first k queries.\n        for (int pos = 0; pos < n; pos++) {\n            int t = nums[pos];\n            if (t == 0)\n                continue;\n\n            vector<int> temp;\n            int s = 0;\n            for (int j = 0; j < k; j++) {\n                if (pos >= queries[j][0] && pos <= queries[j][1]) {\n                    temp.push_back(queries[j][2]);\n                    s += queries[j][2];\n                }\n            }\n            if (s < t)\n                return false;\n            bitset<100001> ps;\n            ps.reset();\n            ps[0] = 1;\n            for (int coin : temp) {\n                ps |= (ps << coin);\n            }\n            if (!ps[t])\n                return false;\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int m = queries.size();\n        bool zeroo = true;\n        for (int num : nums) {\n            if (num != 0) {\n                zeroo = false;\n                break;\n            }\n        }\n        if (zeroo)\n            return 0;\n        int lo = 1, hi = m, ans = -1;\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (helper(mid, nums, queries)) {\n                ans = mid;\n                hi = mid - 1;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"Mayank sharma","submissionId":"1575196131"},[]]},{"838":[{"id":"838","fileName":"1575196319.txt","sourceCode":"class Solution {\nprivate:\n    int findRes(vector<vector<int>> &queries, int num, int idx, int i, vector<vector<int>> &dp) {\n        int n = queries.size();\n        if(num == 0) return idx;\n        if(idx == n) return -1;\n        if(num < 0) return -1;\n        if(dp[num][idx] != -2) return dp[num][idx];\n        int l = queries[idx][0], r = queries[idx][1], val = queries[idx][2];\n        int res = i >= l && i <= r ? findRes(queries, num - val, idx+1, i, dp) : -1;\n\n        int res2 = findRes(queries, num, idx+1, i, dp);\n        if(res2 != -1) {\n            if(res == -1) res = res2;\n            else res = min(res, res2);\n        }\n        return dp[num][idx] = res;\n    }\n\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int mx = -1, n = nums.size(), m = queries.size();\n        for(int i = 0; i<n; i++) {\n            vector<vector<int>> dp(1001, vector<int>(m, -2));\n            int res = findRes(queries, nums[i], 0, i, dp);\n            if(res == -1) return -1;\n            mx = max(mx, res);\n        }\n\n        return mx;\n    }\n};","author":"Parth Gupta","submissionId":"1575196319"},[]]},{"839":[{"id":"839","fileName":"1575196512.txt","sourceCode":"class Solution {\npublic:\n\n    static bool comp(const pair<int, int> &a, const pair<int, int> &b){\n        return a.first < b.first;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<int> dec(n, 0); \n        bool cant = false;\n\n        for (int j = 0; j < n; j++) {\n            if (nums[j] == 0) {\n                dec[j] = 0; \n                continue;\n            }\n\n            vector<pair<int, int>> ranges; \n            for (int i = 0; i < m; i++) {\n                int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n                if (j >= l && j <= r) {\n                    ranges.emplace_back(i, val);\n                }\n            }\n\n            sort(ranges.begin(), ranges.end(),comp);\n\n            bitset<2000001> dp;\n            dp.set(1000000); \n\n            bool achieved = false;\n            for (const auto& [i, val] : ranges) {\n                if (val > 0) {\n                    dp |= (dp << val); \n                } \n                else if (val < 0) {\n                    dp |= (dp >> (-val)); \n                }\n                \n                if (dp.test(1000000 + nums[j])) {\n                    dec[j] = i + 1; \n                    achieved = true;\n                    break;\n                }\n            }\n\n            if (!achieved) {\n                cant = true; \n                break;\n            }\n        }\n\n        if (cant){\n            return -1;\n        }\n\n        int answer = *max_element(dec.begin(), dec.end());\n        return answer;\n    }\n};","author":"Vaibhav Sharma","submissionId":"1575196512"},[]]},{"840":[{"id":"840","fileName":"1575196765.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size();\n        bool zero = true;\n        for (int x : nums) {\n            if (x != 0) { zero = false; break; }\n        }\n        if(zero) return 0;\n        \n        vector<int> numscpy = nums;\n        int lo = 1, hi = q, ans = -1;\n        while(lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            bool poss = true;\n            for (int i = 0; i < n && poss; i++) {\n                int target = numscpy[i];\n                if(target == 0) continue;\n                bitset<1001> dp;\n                dp.reset();\n                dp[0] = 1;\n                for (int j = 0; j < mid; j++) {\n                    int l = queries[j][0], r = queries[j][1], v = queries[j][2];\n                    if(l <= i && i <= r) {\n                        dp |= (dp << v);\n                    }\n                }\n                if(!dp[target]) poss = false;\n            }\n            if(poss) { ans = mid; hi = mid - 1; }\n            else { lo = mid + 1; }\n        }\n        return ans;\n    }\n};\n","author":"Rajit Anand","submissionId":"1575196765"},[]]},{"841":[{"id":"841","fileName":"1575196439.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if sum(nums) == 0:\n            return 0\n        \n        def check(k):\n            for i, n in enumerate(nums):\n                if n == 0:\n                    continue\n                if not checkSum(i, k):\n                    return False\n            return True\n\n        @cache\n        def checkSum(idx, k):\n            n = nums[idx]\n            l = []\n            for j in range(k):\n                if queries[j][0] <= idx <= queries[j][1]:\n                    if queries[j][2] == n:\n                        return True\n                    if queries[j][2] > n:\n                        continue\n                    l.append(queries[j][2])\n\n            @cache\n            def dfs(c, i):\n                if c < 0:\n                    return False\n                if c == 0:\n                    return True\n                if i == len(l):\n                    return False\n                return dfs(c - l[i], i + 1) or dfs(c, i + 1)\n\n            return dfs(n, 0)\n                \n\n        l = 1\n        r = len(queries)\n\n        # print(check(1))\n        while l < r:\n            mid = l + (r - l) // 2\n            if check(mid):\n                r = mid\n            else:\n                l = mid + 1\n        \n        return l if check(l) else -1\n            \n            ","author":"oOoOoOoOo","submissionId":"1575196439"},[]]},{"842":[{"id":"842","fileName":"1575196917.txt","sourceCode":"class Solution {\npublic:\n\nint solve(int p,int index,vector<vector<int>>& queries,int t, vector<vector<int>> &dp)\n{\n    if(p==0)\n    {\n        return index;\n    }\n  \n    if(index>=queries.size())\n    {\n        return index+1;\n    }\n    if(dp[index][p]!=-1) return dp[index][p];\n    int take=INT_MAX;\n    if(p>=queries[index][2]&&t>=queries[index][0]&&t<=queries[index][1])\n    {\n        take=solve(p-queries[index][2],index+1,queries,t,dp);\n    }\n   int notTake=solve(p,index+1,queries,t,dp);\n    return dp[index][p]= min(take,notTake);\n}\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n     \n        int ans=-1;\n        for(int i=0;i<nums.size();i++)\n            {\n                 vector<vector<int>> dp(queries.size(),vector<int>(nums[i]+1,-1));\n                int p=solve(nums[i],0,queries,i,dp);\n                if(p==queries.size()+1)\n                {\n                    return -1;\n                }\n                ans=max(ans,p);\n                \n            }\n        return ans;\n    }\n};","author":"ichoudharyb","submissionId":"1575196917"},[]]},{"843":[{"id":"843","fileName":"1575197022.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& arr, vector<vector<int>>& qu) {\n        unordered_map<int, int> mp;\n\n        for (int i = 0; i < arr.size(); i++) {\n            if (arr[i] == 0) {\n                mp[i] = 1;\n            }\n        }\n        if (mp.size() == arr.size())\n            return 0;\n\n        int idx = 0;\n        vector<vector<int>> dp(arr.size(), vector<int>(1001, 0));\n\n        for(auto &it : dp) {\n            it[0] = 1; \n        }\n\n        for (auto it : qu) {\n            vector<vector<int>> temp = dp;\n\n            for (int i = it[0]; i <= it[1]; i++) {\n                if (mp.count(i))\n                    continue;\n\n                for (int j = 0; j <= arr[i]; j++) {\n                    if (dp[i][j] == 1 && j  <= arr[i] - it[2]) \n                        temp[i][j + it[2]] = 1;\n                }\n                if (temp[i][arr[i]] == 1) mp[i] = 1;\n                \n            }\n            dp = temp;\n\n            ++idx;\n            if (mp.size() == arr.size())\n                return idx;\n        }\n        return -1;\n    }\n};","author":"Tushar","submissionId":"1575197022"},[]]},{"844":[{"id":"844","fileName":"1575197027.txt","sourceCode":"// class Solution {\n// public:\n    \n//     bool helper(int i, int sum, int k, int ind, vector<vector<int>>& q, vector<vector<int>> &dp){\n//         if(sum<0) return false;\n//         if(sum == 0) return true;\n//         if(i == k) return false;\n//         if(dp[i][sum] != -1) return dp[i][sum];\n//         bool ans = false;\n//         ans = helper(i+1, sum, k, ind, q, dp);\n//         if(ind>=q[i][0] and ind<=q[i][1]) ans |= helper(i+1, sum-q[i][2], k, ind, q, dp);\n//         return dp[i][sum] = ans;\n//     }\n//     bool check(int k, vector<int> &nums, vector<vector<int>>& queries){\n//         int n = nums.size();\n//         vector<int> v(n+1, 0);\n//         int j = k;\n//         set<int> st;\n//         st.insert(0);\n//         for(auto &q:queries){\n//              if(k <= 0) break;\n//             int l = q[0], r = q[1], val = q[2];\n//             v[l] += val;\n//             v[r+1] -= val;\n//             k--;\n//             // set<int> tmp;\n//             // for(auto &x:st){\n//             //     tmp.insert(x+val);\n//             // }\n//             // for(auto &x:tmp){\n//             //     st.insert(x);\n//             // }\n//             if(k == 0) break;\n//         }\n//         for(int i=1; i<n+1; i++){\n//             v[i] += v[i-1];\n//         }\n//         for(int i=0; i<n; i++){\n//             int x = v[i]-nums[i];\n//             // if(j == 0)\n//             // cout<<v[i]<<\" \";\n//             // if(x<0) return false;\n//             vector<vector<int>> dp(n+1, vector<int>(x+1, -1));\n//             if(!helper(0, x, j, i, queries, dp)) return false;\n//             // if(st.find(x) == st.end()) return false;\n//         }\n//         return true;\n//     }\n//     int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n//         int q = queries.size();\n//         int l = 0, r = q;\n//         int ans = -1;\n//         while(l<=r){\n//             int mid = l+(r-l)/2;\n//             // cout<<mid<<\" \";\n//             if(check(mid, nums, queries)){\n//                 ans = mid;\n//                 r = mid-1;\n//             }else l = mid+1;\n            \n//         }\n//         // for(int k=1; k<=q; k++){\n//         //     if(check(k, nums, queries)){\n//         //         ans = k;\n//         //         break;\n//         //     }\n//         // }\n//         return ans;\n        \n//     }\n// };\nclass Solution {\npublic:\n    bool helper(int i, int sum, int k, int ind, vector<vector<int>>& q, vector<vector<int>>& dp) {\n        if (sum < 0) return false;\n        if (sum == 0) return true;\n        if (i == k) return false;\n        if (dp[i][sum] != -1) return dp[i][sum];\n\n        bool ans = helper(i + 1, sum, k, ind, q, dp);\n        if (ind >= q[i][0] && ind <= q[i][1]) \n            ans |= helper(i + 1, sum - q[i][2], k, ind, q, dp);\n\n        return dp[i][sum] = ans;\n    }\n\n    bool check(int k, vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> v(n + 1, 0);\n\n        // Apply the first `k` queries using prefix sum\n        for (int i = 0; i < k; i++) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            v[l] += val;\n            if (r + 1 < n) v[r + 1] -= val;\n        }\n\n        // Compute the modified array\n        for (int i = 1; i < n; i++) {\n            v[i] += v[i - 1];\n        }\n\n        // Check if each element can be made zero using at most `k` operations\n        for (int i = 0; i < n; i++) {\n            int x = v[i] - nums[i];\n            if (x < 0) return false;\n\n            vector<vector<int>> dp(k + 1, vector<int>(x + 1, -1));\n            if (!helper(0, x, k, i, queries, dp)) return false;\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int q = queries.size();\n        int l = 0, r = q, ans = -1;\n\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if (check(mid, nums, queries)) {\n                ans = mid;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"Shashi Raj","submissionId":"1575197027"},[]]},{"845":[{"id":"845","fileName":"1575197069.txt","sourceCode":"#\nclass Solution:\n    def recurse(self, ix, num, q_ix, queries, dp):\n        if num == 0:\n            print(num, q_ix)\n            return q_ix\n        if q_ix == len(queries):\n            return None\n        if (ix, num, q_ix) in dp:\n            return dp[(ix, num, q_ix)]\n        # Can we use this current query?\n        query = queries[q_ix]\n        k1 = None\n        if (query[0] <= ix <= query[1]) and num >= query[2]:\n            # Consider recursing down this path\n            print(\"Recursing down\", num)\n            k1 = self.recurse(ix, num-query[2], q_ix+1, queries, dp)\n        # Or just ignore it\n        k2 = self.recurse(ix, num, q_ix+1, queries, dp)\n        if k1 is None:\n            ans = k2\n        elif k2 is None:\n            ans = k1\n        else:\n            ans = min(k1, k2)\n        dp[(ix, num, q_ix)] = ans\n        return ans\n\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        ans = 0\n        \n        # Maybe simulation?\n        # For each num, check how many queries it takes to get to 0?\n        # Extremely slow\n        for i, num in enumerate(nums):\n            k = self.recurse(i, num, 0, queries, {})\n            if k == None:\n                return -1\n            ans = max(ans, k)\n        return ans","author":"p00p","submissionId":"1575197069"},[]]},{"846":[{"id":"846","fileName":"1575197071.txt","sourceCode":"class Solution {\npublic:\n    std::vector<std::unordered_set<int>> possible_values;\n    std::vector<int> done;\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        auto N = nums.size();\n        done.resize(N, 0);\n        possible_values.resize(N, {});\n        for (size_t i = 0; i < N; i++) {\n            if (nums[i] == 0) {\n                done[i] = true;\n                continue;\n            }\n            possible_values[i].insert(nums[i]);\n        }\n        if (std::all_of(done.begin(), done.end(), [](auto v) {return v;})) {\n            return 0;\n        }\n        for (auto i = 0; i < queries.size(); i++) {\n            auto range_l = queries[i][0];\n            auto range_r = queries[i][1];\n            auto decrement_val = queries[i][2];\n            for (auto j = range_l; j <= range_r; j++) {\n                if (done[j]) continue;\n                auto& pv = possible_values[j];\n                if (pv.count(decrement_val)) {\n                    done[j] = true;\n                } else {\n                    std::vector<int> decreased;\n                    for (auto v : pv) {\n                        decreased.push_back(v - decrement_val);\n                    }\n                    pv.insert(decreased.begin(), decreased.end());\n                }\n            }\n            if (std::all_of(done.begin(), done.end(), [](auto v) {return v;})) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"Yushun","submissionId":"1575197071"},[]]},{"847":[{"id":"847","fileName":"1575197170.txt","sourceCode":"#define INF 1e5\nclass Solution {\npublic:\n    int dfs(int i, int j, int sum, vector<vector<int>>& queries,\n        vector<vector<int>>& dp) {\n        int m = queries.size();\n        if (sum == 0) {\n            return j;\n        }\n        if (sum < 0 || j == m) {\n            return INF;\n        }\n        int& res = dp[j][sum];\n        if (res != INT_MAX) {\n            return res;\n        }\n        res = INF;\n        if (i >= queries[j][0] && i <= queries[j][1]) {\n            res = dfs(i, j+1, sum-queries[j][2], queries, dp);\n        }\n        res = min(res, dfs(i, j+1, sum, queries, dp));\n        return res;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        int ans = -1;\n        vector<vector<int>> dp;\n        for (int i = 0; i < n; i++) {\n            dp.assign(m, vector<int>(1e3+1, INT_MAX));\n            int res = dfs(i, 0, nums[i], queries, dp);\n            if (res < INF) {\n                ans = max(ans, res);\n            } else {\n                return -1;\n            }\n        }\n        return ans;\n    }\n};","author":"Apurv Chauhan","submissionId":"1575197170"},[]]},{"849":[{"id":"849","fileName":"1575197086.txt","sourceCode":"class Solution {\npublic:\n    vector<vector<int>> dp;\n\n    int solve(int i, int curr, int idx, vector<vector<int>>& queries) {\n        if (curr == 0) return i;\n        if(curr<0) return INT_MAX;\n        if (i >= queries.size()) return INT_MAX;\n        \n        if (dp[i][curr] != -1) return dp[i][curr];\n\n        int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n        int opt1 = INT_MAX;\n\n        if (idx >= l && idx <= r) opt1 = solve(i + 1,curr-val, idx, queries);\n        opt1 = min(opt1, solve(i + 1, curr, idx, queries));\n\n        return dp[i][curr] = opt1;\n    }\n\n    int minZeroArray(vector<int>& arr, vector<vector<int>>& queries) {\n        int ans = -1;\n\n        for (int i = 0; i < arr.size(); i++) {\n            dp.assign(queries.size(), vector<int>(1001, -1));\n            int currans = solve(0, arr[i], i, queries);\n            if (currans == INT_MAX) return -1;\n            ans = max(ans, currans);\n        }\n\n        return ans;\n    }\n};\n","author":"Anuj Nagpure","submissionId":"1575197086"},[]]},{"850":[{"id":"850","fileName":"1575197193.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        result = 0\n        \n        for i, n in enumerate(nums):\n            if n == 0: continue\n                \n            mp = {}\n            for j, (a, b, c) in enumerate(queries):\n                if i < a or i > b: continue\n\n                for v in list(mp.keys()):\n                    if v + c not in mp:\n                        mp[v + c] = j\n                        \n                if c not in mp:\n                    mp[c] = j\n\n                if n in mp:\n                    result = max(result, mp[n] + 1)\n                    break\n            else:\n                return -1\n            \n            \n        return result","author":"padth","submissionId":"1575197193"},[]]},{"851":[{"id":"851","fileName":"1575197321.txt","sourceCode":"class Solution {\npublic:\n    bool isGood(int val , vector<int> &values , int idx, vector<vector<int>> & dp){\n        if (dp[val][idx] != -1)return dp[val][idx] ; \n        if (val == 0){\n            return true ; \n        }\n        if (idx >= values.size()){\n            return false ; \n        }\n        bool take = 0 , notTake = 0 ; \n        notTake = isGood(val , values , idx + 1 , dp);\n        if (values[idx] <= val){\n            take = isGood(val - values[idx] , values ,idx + 1 , dp) ;\n        }\n        return dp[val][idx] = (take || notTake) ; \n    }\n    bool isOk(int limit , vector<int> & nums , vector<vector<int>> & queries){\n        int n = nums.size();\n        vector<vector<int>>mp(n);\n        for (int i = 0 ; i < limit ; i++ ){\n            int l = queries[i][0] , r = queries[i][1] , val = queries[i][2];\n            for (int j = l ; j <= r ; j++){\n                mp[j].push_back(val);\n            }\n        }\n        for (int i = 0 ; i < mp.size() ; i++ ){\n            int my_val = nums[i];\n            vector<vector<int>>dp(my_val + 1,vector<int>( mp[i].size() + 1 , -1));\n            if(isGood(my_val ,mp[i] , 0 , dp)){\n                continue;\n            }else{\n                return false;\n            }\n        }\n        return true ; \n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int low = 1 , high = queries.size() ; \n        int ans = -1 ; \n        int n = nums.size();\n        bool check = false ; \n        for (int i= 0 ; i < n ; i++){\n            if (nums[i] != 0)check = true ; \n        }\n        if (check == 0)return 0 ; \n        while (low <= high){\n            int mid = (low + high)>>1 ; \n            if(isOk(mid , nums , queries)){\n                ans = mid ; \n                high = mid - 1 ;\n            }else{\n                low = mid + 1 ; \n            }\n        }\n        return ans;\n    }\n};","author":"Rishabh Mishra","submissionId":"1575197321"},[]]},{"852":[{"id":"852","fileName":"1575197479.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<vector<int>> V(nums.size(),vector<int>(1001,0));\n        int flag=1;\n            for(int i=0;i<nums.size();i++){\n                if(nums[i]) flag=0;\n            }\n        if(flag) return 0;\n        for(int j=0;j<queries.size();j++){\n            int l=queries[j][0],r=queries[j][1],val=queries[j][2];\n            for(int i=l;i<=r;i++){\n                V[i][nums[i]]=1;\n                if(V[i][0]) continue;\n                for(int it=0;it<1001;it++){\n                    if(V[i][it] && it>=val) V[i][it-val]=1;\n                }\n            }\n            flag=1;\n            for(int i=0;i<nums.size();i++){\n                if(!V[i][0]) flag=0;\n            }\n            if(flag) return j+1;\n        }\n        return -1;\n    }\n};","author":"Dara_2001","submissionId":"1575197479"},[]]},{"854":[{"id":"854","fileName":"1575197579.txt","sourceCode":"class Solution(object):\n    def minZeroArray(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: int\n        \"\"\"\n\n        def dps(target, vals):\n            if target==0:\n                return 0\n\n            dp = [False for _ in range(target+1)]\n            dp[0] = True\n            \n            for i in range(len(vals)):\n                v = vals[i]\n                for j in range(target, -1, -1):\n                    if dp[j] and j+v<target+1:\n                        if j+v == target:\n                            return i+1\n                        dp[j+v] = True\n            return -1\n\n        res = {i:[] for i in range(len(nums))}\n        actual = {i:-1 for i in range(len(nums))}\n        for i in range(len(nums)):\n            if nums[i]==0:\n                actual[i] = 0\n\n        for l,r,v in queries:\n            for i in range(len(nums)):\n                if l<=i<=r:\n                    res[i].append(v)\n                else:\n                    res[i].append(0)\n        print(actual)\n        for index in res.keys():\n            target = nums[index]\n            vals = res[index]\n\n            if target==0:\n                continue\n\n            actual[index] = dps(target, vals)\n\n        print(res)\n        print(actual)\n        a = actual.values()\n        return -1 if -1 in a else max(a)\n        ","author":"Davius1","submissionId":"1575197579"},[]]},{"856":[{"id":"856","fileName":"1575197622.txt","sourceCode":"class Solution {\n    public:\n        bool f(int i, int target, vector<int>&c , vector<vector<int>>&dp){\n\n            if(target == 0){\n                return true;\n            }\n\n            if(i >= c.size()){\n                return false;\n            }\n\n            if(dp[i][target] != -1){\n                return dp[i][target];\n            }\n\n            bool res = f(i+1, target, c, dp) || (c[i] <= target && f(i+1, target-c[i], c, dp));\n            dp[i][target] = res;\n            return res;\n        }\n        \n        int minZeroArray(vector<int>&nums, vector<vector<int>>&queries){\n\n            int n = nums.size();\n            int m = queries.size();\n\n            bool iszero = true;\n            for(int num : nums){\n                if(num != 0){\n                    iszero = false; \n                    break; \n                }\n            }\n            if(iszero){\n                return 0;\n            } \n\n            for(int k = 1; k <= m; k++){\n                bool allzero = true;\n                for(int j = 0; j < n; j++){\n                    vector<int>c;\n                    for(int i = 0; i < k; i++){\n                        if(queries[i][0] <= j && j <= queries[i][1])\n                            c.push_back(queries[i][2]);\n                    }\n                    vector<vector<int>>dp(c.size()+1, vector<int>(nums[j]+1,-1));\n                    if(!f(0, nums[j], c, dp)){\n                        allzero = false;\n                        break;\n                    }\n                }\n                if(allzero){\n                    return k;\n                }\n            }\n\n            return -1;\n        }\n    };","author":"vedantmate","submissionId":"1575197622"},[]]},{"857":[{"id":"857","fileName":"1575197428.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def can_zero(k):\n            for i in range(len(nums)):\n                available_vals = [val for l, r, val in queries[:k] if l <= i <= r]\n                target = nums[i]\n                dp = [False] * (target + 1)\n                dp[0] = True\n                for val in available_vals:\n                    for j in range(target, val - 1, -1):\n                        dp[j] |= dp[j - val]\n                if not dp[target]:\n                    return False\n            return True\n\n        left, right = 0, len(queries)\n        result = -1\n\n\n        while left <= right:\n            mid = (left + right) // 2\n            if can_zero(mid):\n                result = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return result","author":"StasShkolnyi","submissionId":"1575197428"},[]]},{"858":[{"id":"858","fileName":"1575197739.txt","sourceCode":"class Solution(object):\n    def minZeroArray(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        m = len(queries)\n        \n        S = [set([0]) for _ in range(n)]\n        achieved = [nums[i] == 0 for i in range(n)]\n        not_achieved = sum(1 for i in range(n) if nums[i] > 0)\n        \n        if not_achieved == 0:\n            return 0\n        \n        for q in range(m):\n            li, ri, vali = queries[q]\n            for i in range(li, ri + 1):\n                if not achieved[i]:\n                    new_sums = {s + vali for s in S[i] if s + vali <= nums[i]}\n                    S[i] |= new_sums\n                    if nums[i] in S[i]:\n                        achieved[i] = True\n                        not_achieved -= 1\n            if not_achieved == 0:\n                return q + 1\n        \n        return -1","author":"Dedeepya Yakkala","submissionId":"1575197739"},[{"id":"1197","similarity":1.0,"totOverlap":140,"longestOverlap":70},{"id":"1215","similarity":1.0,"totOverlap":140,"longestOverlap":70}]],"1197":[{"id":"1197","fileName":"1575218928.txt","sourceCode":"class Solution(object):\n    def minZeroArray(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        m = len(queries)\n        \n        S = [set([0]) for _ in range(n)]\n        achieved = [nums[i] == 0 for i in range(n)]\n        not_achieved = sum(1 for i in range(n) if nums[i] > 0)\n        \n        if not_achieved == 0:\n            return 0\n        \n        for q in range(m):\n            li, ri, vali = queries[q]\n            for i in range(li, ri + 1):\n                if not achieved[i]:\n                    new_sums = {s + vali for s in S[i] if s + vali <= nums[i]}\n                    S[i] |= new_sums\n                    if nums[i] in S[i]:\n                        achieved[i] = True\n                        not_achieved -= 1\n            if not_achieved == 0:\n                return q + 1\n        \n        return -1","author":"Darshini S","submissionId":"1575218928"},[{"id":"858","similarity":1.0,"totOverlap":140,"longestOverlap":70}]],"1215":[{"id":"1215","fileName":"1575219546.txt","sourceCode":"class Solution(object):\n    def minZeroArray(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        m = len(queries)\n        \n        S = [set([0]) for _ in range(n)]\n        achieved = [nums[i] == 0 for i in range(n)]\n        not_achieved = sum(1 for i in range(n) if nums[i] > 0)\n        \n        if not_achieved == 0:\n            return 0\n        \n        for q in range(m):\n            li, ri, vali = queries[q]\n            for i in range(li, ri + 1):\n                if not achieved[i]:\n                    new_sums = {s + vali for s in S[i] if s + vali <= nums[i]}\n                    S[i] |= new_sums\n                    if nums[i] in S[i]:\n                        achieved[i] = True\n                        not_achieved -= 1\n            if not_achieved == 0:\n                return q + 1\n        \n        return -1","author":"Deepika Rajalakshmi Balu","submissionId":"1575219546"},[{"id":"858","similarity":1.0,"totOverlap":140,"longestOverlap":70}]]},{"859":[{"id":"859","fileName":"1575197680.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n=len(nums)\n        m=len(queries)\n        if sum(nums)==0:return 0\n        dic=defaultdict(list)\n        for i in range(m):\n            l,r,v=queries[i]\n            for j in range(l,r+1):\n                dic[j].append([v,i+1])\n        st=[-1]*n\n        for i in dic:\n            c=nums[i]\n            d=[0]*(c+1)\n            d[0]=1\n            for v,k in dic[i]:\n                for j in range(c,v-1,-1):\n                    if d[j-v]:\n                        d[j]=1\n                if d[c]:\n                    st[i]=k\n                    break\n        for i in range(n):\n            if st[i]==-1:\n                return -1\n        return max(st)\n\n        ","author":"FrogFox","submissionId":"1575197680"},[]]},{"860":[{"id":"860","fileName":"1575197949.txt","sourceCode":"class Solution:\n    def minZeroArray(self, a: List[int], q: List[List[int]]) -> int:\n        n = len(a)\n        S = [set([0]) for _ in range(n)]\n        if all(x == 0 for x in a):\n            return 0\n        for i, (l, r, v) in enumerate(q):\n            for j in range(l, r + 1):\n                S[j] |= {x + v for x in S[j] if x + v <= a[j]}\n            if all(a[j] in S[j] for j in range(n)):\n                return i + 1\n        return -1","author":"Sriram Nagarajan","submissionId":"1575197949"},[{"id":"1190","similarity":0.8645833333333334,"totOverlap":83,"longestOverlap":27}]],"1190":[{"id":"1190","fileName":"1575217927.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        ans= (nums, queries)\n        a= [set([0]) for i in range(n)]\n        if all(num == 0 for num in nums):\n            return 0\n        for k, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                a[j] |= {x + v for x in a[j] if x + v <= 1000}\n                a[j] = {x for x in a[j] if x <= nums[j]}\n\n            if all(nums[j] in a[j] for j in range(n)):\n                return k+1\n        return -1\n","author":"Mahathi M","submissionId":"1575217927"},[{"id":"860","similarity":0.8645833333333334,"totOverlap":83,"longestOverlap":27}]]},{"861":[{"id":"861","fileName":"1575197966.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n\n        ArrayList<Integer>[] arr = new ArrayList[11];\n        int qlen = queries.length;\n        for(int i = 0; i < arr.length; i++){\n            arr[i] = new ArrayList<>();\n        }\n        int z = 0;\n        for(int i = 0; i < nums.length; i++){\n            if(nums[i] > 0){\n                z = 1;\n                break;\n            }\n        }\n        if(z == 0){\n            return 0;\n        }\n        for(int i = 0; i < qlen; i++){\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            for(int j = l; j<= r; j++){\n                ArrayList<Integer> temp = arr[j];\n                temp.add(val);\n            }\n            int flag = 0;\n            for(int j = 0; j <nums.length; j++){\n                ArrayList<Integer> temp = arr[j];\n                int check = targetSum(temp, nums[j]);\n                if(check == 0){\n                    flag = 1;\n                    break;\n                }\n            }\n            if(flag == 0){\n                return i + 1;\n            }\n            \n        }\n        return -1;\n    }\n     private int targetSum(ArrayList<Integer> list, int target) {\n        if (list.isEmpty()) return 0;\n        \n        int sum = 0;\n        for (int num : list) sum += num;\n        if (sum < target) return 0;\n        \n        int[] dp = new int[target + 1];\n        dp[0] = 1;\n\n        for (int num : list) {\n            for (int j = target; j >= num; j--) {\n                dp[j] |= dp[j - num];\n            }\n        }\n        return dp[target];\n    }\n}","author":"Deepak","submissionId":"1575197966"},[]]},{"862":[{"id":"862","fileName":"1575197992.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n         int n = nums.length, m = queries.length;\n        int[] arr = Arrays.copyOf(nums, n);\n        int l = 0, h = m, result = -1;\n        while (l <= h) {\n            int mid = (l + h) / 2;\n            if (check(n,mid,queries,nums)) {\n                result = mid;\n                h = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return result;\n    }\n    public boolean check(int n,int k,int[][] queries,int nums[])\n    {\n         \n            for (int j = 0; j < n; j++) {\n                boolean[] dp = new boolean[1001];\n                dp[0] = true;\n                for (int i = 0; i < k; i++) {\n                    if (j >= queries[i][0] && j <= queries[i][1]) {\n                        for (int sum = 1000 - queries[i][2]; sum >= 0; sum--) {\n                            if (dp[sum]) dp[sum + queries[i][2]] = true;\n                        }\n                    }\n                }\n                if (!dp[nums[j]]) return false;\n            }\n            return true;\n    }\n}","author":"SANDEEP JAAT","submissionId":"1575197992"},[]]},{"863":[{"id":"863","fileName":"1575197980.txt","sourceCode":"class Solution {\npublic:\n    bool check(vector<int>& nums, vector<vector<int>>& queries, int k) {\n        for (int j = 0; j < nums.size(); j++) {\n            vector<int> temp;\n            for (int i = 0; i < k; i++) {\n                if (queries[i][0] <= j && j <= queries[i][1]) {\n                    temp.push_back(queries[i][2]);\n                }\n            }\n            bool flag = true;\n            vector<bool> dp(nums[j] + 1, false);\n            dp[0] = true;\n            for (int i=0;i<temp.size();i++) {\n                for (int s = nums[j]; s >= temp[i]; s--) {\n                    if (dp[s - temp[i]]) {\n                        dp[s] = true;\n                    }\n                }\n            }\n            flag= dp[nums[j]];\n            if (!flag) {\n                return false;\n            }\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        bool flag = true;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            return 0;\n        }\n        int start = 1, end = q + 1, ans = -1;\n        while (start < end) {\n            int mid = start + (end - start) / 2;\n            if (check(nums, queries, mid)) {\n                ans = mid;\n                end = mid;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"Abhuday","submissionId":"1575197980"},[]]},{"864":[{"id":"864","fileName":"1575198031.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int dp[10][1010];\n        int ans[10] = {-1};\n        memset(dp, 0, sizeof dp);\n        memset(ans,-1,sizeof ans);\n        for(int i = 0; i < nums.size(); ++i){\n            dp[i][0] = 1;\n        }\n        vector<int>tmp = {-1,-1,0};\n        queries.insert(queries.begin(),tmp);\n        for(int i = 0; i < nums.size(); ++i){\n            //cout<<\"nums\"<<i<<endl;\n            if(!nums[i]){\n                //cout<<\"ans \"<<i<<' '<<ans[i]<<'n';\n                ans[i] = 0;\n                continue;\n            }\n            for(int j = 1; j < queries.size() && !~ans[i]; ++j)\n                if(i >= queries[j][0] && i <= queries[j][1])\n                    for(int k = nums[i] - queries[j][2]; k >= 0 && !~ans[i]; --k){\n                        dp[i][k + queries[j][2]] = max(dp[i][k + queries[j][2]],dp[i][k]);\n                        //cout<<i<<' '<<k + queries[j][2]<<' '<<dp[i][k + queries[j][2]]<<endl;\n                        if(dp[i][nums[i]]){\n                            ans[i] = j;\n                            //cout<<\"ans \"<<i<<' '<<ans[i]<<'n';\n                        }\n                    }\n        }\n        int ret = 0;\n        //for(int i = 0; i<nums.size();++i)\n          //  cout<<i<<' '<<ans[i]<<endl;\n        for(int i = 0; i < nums.size(); ++i)\n            if(!~ans[i])\n                return -1;\n            else\n                ret = max(ret, ans[i]);\n        return ret;\n    }\n};","author":"f1016142506","submissionId":"1575198031"},[]]},{"865":[{"id":"865","fileName":"1575198150.txt","sourceCode":"class Solution {\npublic:\n    int f(int x , int ind , vector<vector<int>> &dp,vector<vector<int>>& queries){\n        int m = queries.size();\n        for(int i = m-1;i>=0;i--){\n            for(int j = x ; j>=1 ; j--){\n                int one  = dp[i+1][j];\n                int two = 1e9;\n                if(ind >= queries[i][0] && ind <= queries[i][1] && j>=queries[i][2]){\n                    two = dp[i+1][j-queries[i][2]];\n                }\n                dp[i][j] = 1 + min(one,two);\n            }\n        }\n        return dp[0][x];\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<vector<int>> dp(m+1,vector<int>(1001,1e9));\n        for(int i = 0 ; i<=m;i++){\n            dp[i][0] = 0;\n        }\n        int maxi = 0;\n        for(int i = 0 ;i<nums.size() ;i++){\n            int ans = f(nums[i],i,dp,queries);\n            if(ans >= 1e9) return -1;\n            maxi = max(maxi,ans);\n        }\n        return maxi;\n    }\n};","author":"kushagra saxena","submissionId":"1575198150"},[]]},{"866":[{"id":"866","fileName":"1575198102.txt","sourceCode":"class Solution {\npublic:\n\n\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n      int n = nums.size(), m =queries.size();\n      vector<vector<bool>> dp(n ,vector<bool>(1002,false));\n      \n      for(int i=0;i<n;++i){\n        dp[i][nums[i]] =true;\n      }\n\n      bool flag =true;\n      for(int i=0;i<n;++i){\n        if(!dp[i][0]){\n          flag =false;\n          break;\n        }\n      }\n      if(flag) return 0;\n      \n      for(int i=0;i<m;++i){\n        int l = queries[i][0], r = queries[i][1],  val = queries[i][2];\n        \n        for(int j=l;j<=r;++j){\n          for(int k= 0;(k+val)<=1000;++k){\n            if(dp[j][k+val])dp[j][k] = true;\n          }\n        }\n\n\n      flag =true;\n      for(int j=0;j<n;++j){\n        if(!dp[j][0]){\n          flag =false;\n          break;\n        }\n      }\n        \n      if(flag) return i+1;\n        \n      }\n\n      return -1;\n        \n    }\n};","author":"ngmi","submissionId":"1575198102"},[]]},{"867":[{"id":"867","fileName":"1575198212.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] arr, int[][] queries) {\n        int n = arr.length, q = queries.length;\n        if(true){\n            int flag = 0;\n            for(int i = 0; i < n; i++){\n                if(arr[i] > 0) {\n                    flag = 1;\n                    break;\n                }\n            }\n            if(flag == 0) return 0;\n        }\n        int MAX_VAL = 0;\n        for(int i = 0; i < n; i++) MAX_VAL = Math.max(MAX_VAL, arr[i]);\n        int[][] prevDp = new int[n][MAX_VAL + 1];\n        int[][] currDp = new int[n][MAX_VAL + 1];\n        for(int i = 0; i < n; i++) Arrays.fill(prevDp[i], -1);\n        for(int i = 0; i < n; i++) prevDp[i][0] = 1;\n        for(int queryNo = 0; queryNo < q; queryNo++){\n            for(int i = 0; i < n; i++) {\n                for(int col = 0; col <= MAX_VAL; col++) currDp[i][col] = prevDp[i][col];\n            }\n            int left = queries[queryNo][0], right = queries[queryNo][1], val = queries[queryNo][2];\n            for(int idx = left; idx <= right; idx++){\n                int[] currRow = currDp[idx], prevRow = prevDp[idx];\n                if(val <= MAX_VAL) currRow[val] = 1;\n                currRow[0] = 1;\n                for(int col = 0; col <= MAX_VAL; col++){\n                    if(col - val >= 0 && prevRow[col - val] == 1) currRow[col] = 1; \n                    if(prevRow[col] == 1) currRow[col] = 1; \n                }\n            }\n\n            // System.out.println(\"queryNo: \" + queryNo);\n            // for(int i = 0; i < n; i++){\n            //     for(int j = 0; j <= MAX_VAL; j++) System.out.print(currDp[i][j] + \" \");\n            //     System.out.println(\"\");\n            // }\n            // System.out.println(\"n-----------\");\n            \n            int flag = 0;\n            for(int i = 0; i < n; i++){\n                if(currDp[i][arr[i]] == -1) {\n                    flag = 1;\n                    break;\n                }\n            }\n            if(flag == 0) return queryNo + 1;\n            for(int row = 0; row < n; row++){\n                for(int col = 0; col <= MAX_VAL; col++) prevDp[row][col] = currDp[row][col];\n            }\n        }\n        return -1;\n    }\n}","author":"Prakhar Garg","submissionId":"1575198212"},[]]},{"868":[{"id":"868","fileName":"1575198499.txt","sourceCode":"#define ll long long\n#define pii pair<int,int>\n#define vvpii vector<vector<pii>>\n#define vvi vector<vector<int>>\n#define vvb vector<vector<bool>>\n#define uset unordered_set\n#define umap unordered_map\n#define vi vector<int>\n#define pll pair<ll, ll>\n#define vll vector<ll>\n#define vb vector<bool>\n#define umapii unordered_map<int, int>\n#define mapii map<int, int>\n#define useti unordered_set<int>\n#define v vector\n\nint solve(vvi & dp, int k, int ind, vvi & queries, int ptr = 0, int cur = 0){\n    if(cur == k) return ptr;\n    if(cur > k) return INT_MAX;\n    if(ptr>=queries.size()) return INT_MAX;\n    if(dp[cur][ptr] != -1) return dp[cur][ptr];\n    int left = queries[ptr][0], right = queries[ptr][1], val = queries[ptr][2];\n    int pick = INT_MAX;\n    if(left <=ind && right >= ind){\n        pick = min(pick , solve(dp, k, ind, queries, ptr+1, cur + val));\n    }\n    int skip = solve(dp, k, ind, queries, ptr+1, cur);\n    return dp[cur][ptr] = min(pick, skip);\n}\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = 0;\n        for(int i = 0; i<nums.size(); i++){\n            vvi dp(nums[i]+1, v<int>(queries.size(), -1));\n            int cur = solve(dp, nums[i], i, queries);\n            if(cur > queries.size()) return -1;\n            ans = max(ans, cur);\n        }\n        return ans;\n    }\n};","author":"Gurekamjot Singh","submissionId":"1575198499"},[]]},{"869":[{"id":"869","fileName":"1575198139.txt","sourceCode":"class Solution\n{\n\nprivate:\n    bitset<1001> ss(const bitset<1001> &bitSet, int shift)\n    {\n        bitset<1001> shifted;\n        for (int i = 0; i + shift < 1001; i++)\n        {\n            if (bitSet.test(i))\n            {\n                shifted.set(i + shift);\n            }\n        }\n        return shifted;\n    }\n\npublic:\n    int minZeroArray(vector<int> &array, vector<vector<int>> &operations)\n    {\n        int length = array.size();\n        vector<bitset<1001>> mp(length);\n\n        for (int i = 0; i < length; i++)\n        {\n            mp[i].set(0, true);\n        }\n\n        bool zero = true;\n        for (int value : array)\n        {\n            if (value != 0)\n            {\n                zero = false;\n                break;\n            }\n        }\n        if (zero)\n        {\n            return 0;\n        }\n\n        for (int op = 0; op < operations.size(); op++)\n        {\n            int start = operations[op][0];\n            int end = operations[op][1];\n            int increment = operations[op][2];\n\n            for (int i = start; i <= end; i++)\n            {\n                bitset<1001> temp = ss(mp[i], increment);\n                mp[i] |= temp;\n                for (int pos = array[i] + 1; pos < 1001; pos++)\n                {\n                    mp[i].reset(pos);\n                }\n            }\n\n            bool istrue = true;\n            for (int i = 0; i < length; i++)\n            {\n                if (!mp[i].test(array[i]))\n                {\n                    istrue = false;\n                    break;\n                }\n            }\n\n            if (istrue)\n                return op + 1;\n        }\n\n        return -1;\n    }\n};\n","author":"Ashutosh Kumar","submissionId":"1575198139"},[]]},{"871":[{"id":"871","fileName":"1575198701.txt","sourceCode":"class Solution {\npublic:\nbool r(int i, int s, int t, int j, int k, const vector<vector<int>> &q, vector<vector<int>> &m) {\n    if(s == t) return true;\n    if(i == k) return false;\n    if(s > t) return false;\n    if(m[i][s] != -1) return m[i][s];\n    bool res = false;\n    if(j >= q[i][0] && j <= q[i][1])\n        res = r(i + 1, s, t, j, k, q, m) || ((s + q[i][2] <= t) && r(i + 1, s + q[i][2], t, j, k, q, m));\n    else\n        res = r(i + 1, s, t, j, k, q, m);\n    m[i][s] = res;\n    return res;\n}\n\nbool chk(int j, int k, const vector<int> &ns, const vector<vector<int>> &q) {\n    int t = ns[j];\n    vector<vector<int>> m(k + 1, vector<int>(t + 1, -1));\n    return r(0, 0, t, j, k, q, m);\n}\n\nbool pos(int k, const vector<int> &ns, const vector<vector<int>> &q) {\n    int n = ns.size();\n    for(int i = 0; i < n; i++)\n        if(!chk(i, k, ns, q)) return false;\n    return true;\n}\n\nint minZeroArray(vector<int>& ns, vector<vector<int>>& q) { \n    int m = q.size();\n    int ans = -1; \n    int hi = m, lo = 0;\n    int n = ns.size();\n    while(lo <= hi) {\n        int mid = lo + (hi - lo) / 2;\n        if(pos(mid, ns, q)) { ans = mid; hi = mid - 1; }\n        else lo = mid + 1;\n    }\n    return ans;\n}\n};","author":"Code_guy_2008","submissionId":"1575198701"},[]]},{"872":[{"id":"872","fileName":"1575198587.txt","sourceCode":"\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if sum(nums) == 0:\n            return 0\n        def is_value_sum(aa, tt):\n            @lru_cache(maxsize=None)\n            def find(cur, ii):\n                # print(cur, ii, 'here')\n                if cur == 0:\n                    return True\n                if ii < 0:\n                    return False\n                vv = aa[ii]\n                skip = find(cur, ii - 1)\n                if vv > cur:\n                    return skip\n                skip = skip or find(cur - vv, ii - 1)\n                return skip\n\n            # print(tt, aa, find(tt, len(aa) - 1))\n            return find(tt, len(aa) - 1)\n\n\n\n        def is_all_zero(kk):\n            # print('is_all_zero', kk)\n            tt = {}\n            for ii, num in enumerate(nums):\n                tt[ii] = []\n                for jj in range(kk + 1):\n                    ll, rr, vv = queries[jj]\n                    if ii not in range(ll, rr + 1):\n                        continue\n                    tt[ii].append(vv)\n            for ii in range(len(nums)):\n                tt[ii].sort()\n                if is_value_sum(tt[ii], nums[ii]):\n                    continue\n                return False\n            return True\n\n        def bisect_search(ll, rr):\n            # print('bisect', ll, rr)\n            if ll == rr:\n                if is_all_zero(ll):\n                    return ll + 1\n                return -1\n            mid = (ll + rr) // 2\n            if is_all_zero(mid):\n                return bisect_search(ll, mid)\n            return bisect_search(mid + 1, rr)\n        return bisect_search(0, len(queries) - 1)\n\n","author":"yuanchenxi2022","submissionId":"1575198587"},[]]},{"873":[{"id":"873","fileName":"1575198769.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        // Check if the array is already all zeros\n        bool allZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) return 0;\n\n        int n = nums.size();\n        int m = queries.size();\n\n        // Preprocess: For each element, collect the queries that include it\n        vector<vector<pair<int, int>>> elementQueries(n);\n        for (int i = 0; i < m; ++i) {\n            auto& query = queries[i];\n            int l = query[0], r = query[1], val = query[2];\n            for (int j = l; j <= r; ++j) {\n                elementQueries[j].emplace_back(i, val);\n            }\n        }\n\n        int maxK = 0;\n        for (int i = 0; i < n; ++i) {\n            int target = nums[i];\n            if (target == 0) continue;\n\n            unordered_set<int> possibleSums;\n            possibleSums.insert(0);\n            int currentK = -1;\n            bool found = false;\n\n            for (const auto& [queryIdx, val] : elementQueries[i]) {\n                unordered_set<int> newSums;\n                for (int sum : possibleSums) {\n                    // Option to not include the current query's value\n                    newSums.insert(sum);\n                    // Option to include the current query's value\n                    int newSum = sum + val;\n                    if (newSum <= target) {\n                        newSums.insert(newSum);\n                    }\n                }\n                possibleSums = move(newSums);\n\n                if (possibleSums.find(target) != possibleSums.end()) {\n                    currentK = queryIdx + 1; // Convert to 1-based index\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) return -1;\n            if (currentK > maxK) maxK = currentK;\n        }\n\n        return maxK;\n    }\n};","author":"Varun Dandriyal","submissionId":"1575198769"},[]]},{"874":[{"id":"874","fileName":"1575198856.txt","sourceCode":"class Solution {\npublic:\n    int calc(int n,int ind,vector<int>& v,vector<vector<int>>& dp){\n        if(n==0) return ind;\n        if(ind==v.size()) return INT_MAX;\n        if(dp[n][ind]!=-1) return dp[n][ind];\n        int ans=INT_MAX;\n        if(v[ind]<=n)\n        ans=min(ans,calc(n-v[ind],ind+1,v,dp));\n        ans=min(ans,calc(n,ind+1,v,dp));\n        return dp[n][ind]=ans;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(),m=queries.size();\n        vector<vector<int>> tab(n);\n        map<pair<int,int>,int> mp;\n        for(int i=0;i<m;i++){\n            for(int j=queries[i][0];j<=queries[i][1];j++){\n                mp[{j,0}]=0;\n                tab[j].push_back(queries[i][2]);\n                mp[{j,tab[j].size()}]=i+1;\n            }\n        }\n        int ans=-1;\n        for(int i=0;i<n;i++){\n            vector<vector<int>> dp(nums[i]+10,vector<int>(tab[i].size()+10,-1));\n            int temp=calc(nums[i],0,tab[i],dp);\n            if(temp==INT_MAX) return -1;\n            ans=max(ans,mp[{i,temp}]);\n        }\n        return ans;\n    }\n};","author":"Naramala Siva Vekata Pavan","submissionId":"1575198856"},[]]},{"875":[{"id":"875","fileName":"1575198653.txt","sourceCode":"class Solution {\n    int can_zero(int x, vector<pair<int, int>> &v) {\n        if (x == 0) {\n            return 0;\n        }\n        int n = v.size();\n        vector<vector<int>> dp(n + 1, vector<int> (x + 1, 0));\n        dp[0][0] = 1;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= x; j++) {\n                dp[i][j] = dp[i - 1][j];\n                if (j >= v[i - 1].second) {\n                    dp[i][j] = dp[i][j] || dp[i - 1][j - v[i - 1].second];\n                }\n            }\n            if (dp[i][x]) {\n                return v[i - 1].first + 1;\n            }\n        }\n        return INT_MAX;\n    }\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& qr) {\n        int n = a.size();\n        vector<vector<pair<int, int>>> d(n);\n        int m = qr.size();\n        for (int i = 0; i < m; ++i) {\n            for (int j = qr[i][0]; j <= qr[i][1]; ++j) {\n                d[j].push_back({i, qr[i][2]});\n            }\n        }\n        int max_ = 0;\n        vector<int> mx(n);\n        for (int i = 0; i < n; ++i) {\n            mx[i] = can_zero(a[i], d[i]);\n            if (mx[i] == INT_MAX) {\n                return -1;\n            }\n            max_ = max(max_, mx[i]);\n        }\n        return max_;\n    }\n};\n","author":"Twin Braids","submissionId":"1575198653"},[]]},{"876":[{"id":"876","fileName":"1575198929.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> b(n);\n        \n        for (int i = 0; i < n; ++i) {\n            b[i].assign(nums[i] + 1, 0);\n            b[i][nums[i]] = 1;\n        }\n        \n        bool ok = true;\n        for (int i = 0; i < n; ++i) {\n            if(nums[i] != 0) {\n                ok = false;\n            }\n        }\n        if (ok) {\n            return 0;\n        }\n        \n        for (int i = 0; i < queries.size(); ++i) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int v = queries[i][2];\n            \n            for (int j = l; j <= r; ++j) {\n                for (int k = 0; k + v <= nums[j]; ++k) {\n                    if (b[j][k + v]) {\n                        b[j][k] = 1;\n                    }\n                }\n            }\n            ok = true;\n            for (int j = 0; j < n; ++j) {\n                if(b[j][0] == 0) {\n                    ok = false;\n                }\n            }\n            if (ok) {\n                return i+1;\n            }\n        }\n        return -1;\n    }\n};","author":"Teemu Ryyti","submissionId":"1575198929"},[]]},{"877":[{"id":"877","fileName":"1575198857.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans=-1;\n        vector<vector<bool>> v(nums.size(),vector<bool>(1001,false));\n        for(int i=0;i<nums.size();i++) v[i][nums[i]]=true;\n        int qq=0;\n        while(qq<queries.size()){\n            bool flag=true;\n            for(int i=0;i<nums.size();i++){\n                if(!v[i][0]) flag=false;\n            }\n            if(flag){\n                ans=qq;break;\n            }\n            int l=queries[qq][0],r=queries[qq][1],val=queries[qq][2];\n            for(int i=l;i<=r;i++){\n                for(int j=0;j<=1000;j++){\n                    if(v[i][j] && j-val>=0){\n                        // cout<<\"from \"<<j<<\" set value \"<<j-val<<endl;\n                        v[i][j-val]=true;\n                    }\n                }\n            }\n            qq++;\n        }\n        if(ans==-1){\n             bool flag=true;\n            for(int i=0;i<nums.size();i++){\n                if(!v[i][0]) flag=false;\n            }\n            if(flag) ans=queries.size();\n        }\n\n        return ans;\n    }\n};","author":"rudra_pathak","submissionId":"1575198857"},[]]},{"878":[{"id":"878","fileName":"1575198991.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        auto solve = [&](int k) {\n            for (int i = 0; i < n; i++) {\n                bitset<1001> dp;\n                dp.reset();\n                dp[0] = 1;\n                for (int j = 0; j < k; j++) {\n                    if (queries[j][0] <= i && i <= queries[j][1]) {\n                        int val = queries[j][2];\n                        dp |= (dp << val);\n                    }\n                }\n                if (!dp.test(nums[i])) return false;\n            }\n            return true;\n        };\n        if (all_of(nums.begin(), nums.end(), [](int x) { return x == 0; })) return 0;\n        int left = 1, right = queries.size();\n        if (!solve(right)) return -1;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (solve(mid)) right = mid;\n            else left = mid + 1;\n        }\n        return left;\n    }\n};","author":"professor1412","submissionId":"1575198991"},[]]},{"879":[{"id":"879","fileName":"1575198967.txt","sourceCode":"class Solution {\n    private int[][] cache;\n    \n    private int bt(int val, int ind, int k, int[][] queries) {\n        if(val == 0) return k;\n        if(val < 0) return 1001;\n        if(k == queries.length) return 1001;\n        if(cache[val][k] != 0) return cache[val][k];\n        int res = bt(val, ind, k+1, queries);\n        if(queries[k][0] <= ind && ind <= queries[k][1]){\n            res = Math.min(res, bt(val - queries[k][2], ind, k+1, queries));\n        }\n        cache[val][k] = res;\n        return res;\n    }\n    \n    public int minZeroArray(int[] nums, int[][] queries) {\n        int[] res = new int[nums.length];\n        for(int i = 0; i < nums.length; i++){\n            cache = new int[nums[i]+1][queries.length];\n            res[i] = bt(nums[i], i, 0, queries);\n        }\n        int max = 0;\n        for(int n: res){\n            max = Math.max(max, n);\n        }\n        return max == 1001? -1: max;\n    }\n}","author":"snico1124","submissionId":"1575198967"},[]]},{"880":[{"id":"880","fileName":"1575199007.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def bfs(i):\n            if nums[i] == 0:\n                return 0\n                \n            v = set([nums[i]])\n            \n            for j in range(len(queries)):\n                start, end, val = queries[j]\n                \n                if i < start or i > end:\n                    continue\n                    \n                for n in list(v):\n                    if n == val:\n                        return j + 1\n                    elif n > val:\n                        v.add(n-val)\n\n            return -1\n\n        ans = -1\n        for i in range(len(nums)):\n            k = bfs(i)\n            # print(i, k)\n            if k == -1:\n                return -1\n            ans = max(ans, k)\n\n        return ans\n\n                    \n                    ","author":"serein","submissionId":"1575199007"},[]]},{"881":[{"id":"881","fileName":"1575198772.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)  # Store the length of the input array \n        s = [set([0]) for _ in range(n)]  # Initialize a list of sets            # Each set initially contains only 0\n        z = all(x == 0 for x in nums)  # Check if all elements in 'nums' 0\n        if z:\n            return 0 \n        for o, (st, e, inc) in enumerate(queries):  # Iterate through each operation in \n            # 'o' is the operation index, (st, e, inc) \n            for i in range(st, e + 1):  # Iterate through the elements in the range [st, e] (inclusive).\n                t = s[i].copy()  # Create a copy of the current state of element 'i'.\n                sh = {x + inc for x in t if x + inc < 1001}  # Create a new set 'sh' by shifting the elements in 't' by 'inc'.\n                                                            # Only include shifted elements that are less than 1001.\n                s[i].update(sh)  # Update the state of element 'i' by adding the shifted elements.\n                s[i] = {x for x in s[i] if x <= nums[i]}  # Keep only the elements \n                                                          # This reflects the constraint \n\n            tg = all(nums[i] in s[i] for i in range(n))  # Check if all elements in 'nums' can be made equal to their current value.\n                                                        # This is done by checking if the current value of each element is present in its state.\n\n            if tg:\n                return o + 1  # If the target condition is met, return the number of operations performed + 1.\n\n        return -1  # If the target condition is not met after all operations, return -1.\n        ","author":"Jafrash eada","submissionId":"1575198772"},[]]},{"882":[{"id":"882","fileName":"1575199043.txt","sourceCode":"// check add\nclass segtree {\n    public:\n    struct node {\n        int sm = 0;\n         int mn = 1e9;\nint mx = -1e9;\n        void apply(int l, int r, int x) {\n            sm += x*(r-l+1);\n            mn = min(mn, x);\n            mx = max(mx, x);\n        }\n    };\n \n    node unite(const node &a, const node &b) const {\n        node res;\n        res.sm = a.sm + b.sm;\n        res.mn = min(a.mn, b.mn);\n        res.mx = max(a.mx, b.mx);\n        return res;\n    }\n \n    inline void push(int x, int l, int r) {\n        // int y = (l + r) >> 1;\n        // int z = x + ((y - l + 1) << 1);\n        // if (tree[x].add != 0) { // it's wrong because of me\n        //     tree[x + 1].apply(l, y, tree[x].add);\n        //     tree[z].apply(y + 1, r, tree[x].add);\n        //     tree[x].add = 0;\n        // }\n    }\n \n    inline void pull(int x, int z) {\n        tree[x] = unite(tree[x + 1], tree[z]);\n    }\n \n    int n;\n    vector<node> tree;\n \n    template <typename M>\n    void build(int x, int l, int r, const vector<M> &v) {\n        if (l == r) {\n            tree[x].apply(l, r, v[l]);\n            return;\n        }\n        int y = (l + r) >> 1;\n        int z = x + ((y - l + 1) << 1);\n        build(x + 1, l, y, v);\n        build(z, y + 1, r, v);\n        pull(x, z);\n    }\n \n    node query(int x, int l, int r, int LL, int rr) {\n        if (LL <= l && r <= rr) {\n            return tree[x];\n        }\n        int y = (l + r) >> 1;\n        int z = x + ((y - l + 1) << 1);\n        push(x, l, r);\n        node res{};\n        if (rr <= y) {\n            res = query(x + 1, l, y, LL, rr);\n        } \n        else{\n            if (LL > y) {\n                res = query(z, y + 1, r, LL, rr);\n            } \n            else{\n                res = unite(query(x + 1, l, y, LL, rr), query(z, y + 1, r, LL, rr));\n            }\n        }\n        pull(x, z);\n        return res;\n    }\n \n    template <typename... M>\n    void update(int x, int l, int r, int LL, int rr, const M&... v) {\n        if (LL <= l && r <= rr) {\n            tree[x].apply(l, r, v...);\n            return;\n        }\n        int y = (l + r) >> 1;\n        int z = x + ((y - l + 1) << 1);\n        push(x, l, r);\n        if (LL <= y) {\n            update(x + 1, l, y, LL, rr, v...);\n        }\n        if (rr > y) {\n            update(z, y + 1, r, LL, rr, v...);\n        }\n        pull(x, z);\n    }\n    \n    template <typename M>\n    segtree(const vector<M> &v) {\n        n = v.size();\n        assert(n > 0);\n        tree.resize(2 * n - 1);\n        build(0, 0, n - 1, v);\n    }\n \n    node query(int LL, int rr) {\n        if(LL > rr)\n            return {};\n        assert(0 <= LL && LL <= rr && rr <= n - 1);\n        return query(0, 0, n - 1, LL, rr);\n    }\n \n    template <typename... M>\n    void update(int LL, int rr, const M&... v) {\n        assert(0 <= LL && LL <= rr && rr <= n - 1);\n        update(0, 0, n - 1, LL, rr, v...);\n    }\n};\n\nclass Solution {\npublic:\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        segtree st(nums);\n        int m = q.size();\n        int n = nums.size();\n        map<int, vector<array<int, 2>>> mp;\n        for(int i =0; i<m;++i){\n            int l = q[i][0], r = q[i][1];\n            for(int j = l; j<=r; ++j){\n                mp[j].push_back({q[i][2], i+1});\n            }\n        }\n        int ans = 0;\n        for(auto&a:mp){\n            int num = nums[a.first];\n            vector<int> dp(num+1, 0);\n            if(!num) continue;\n            dp[0] = 1;\n            int idx = -1;\n            for(int i = 0; i<a.second.size(); ++i){\n                for(int j = num; j>=a.second[i][0]; --j){\n                    dp[j] |= dp[j-a.second[i][0]];\n                    \n                }\n                if(dp[num]){\n                    idx = a.second[i][1];\n                    break;\n                }\n            }\n            \n            if(idx==-1) return -1;\n            else ans = max(ans, idx);\nnums[a.first] = 0;\n        }\nfor(int i =0 ; i<n; ++i)if(nums[i]) return -1;\n        return ans;\n    }\n};","author":"MemoMeto","submissionId":"1575199043"},[]]},{"883":[{"id":"883","fileName":"1575199190.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& b) {\n        vector<int> cur=a;\n        int n=a.size(),m=b.size();\n        bool allZero=true;\n        for(int i=0;i<n;i++) {\n            if(a[i]!=0) {allZero=false;break;}\n        }\n        if(allZero) return 0;\n        for(int k=1;k<=m;k++) {\n            bool ok=true;\n            for(int i=0;i<n;i++) {\n                int val=cur[i];\n                vector<bool> dp(val+1,false);\n                dp[0]=true;\n                for(int j=0;j<k;j++) {\n                    if(b[j][0]<=i&&i<=b[j][1]) {\n                        int v=b[j][2];\n                        for(int s=val;s>=v;s--) {\n                            dp[s]=dp[s]||dp[s-v];\n                        }\n                    }\n                }\n                if(!dp[val]) {ok=false;break;}\n            }\n            if(ok) return k;\n        }\n        return -1;\n    }\n};","author":"p_rakesh_kumar","submissionId":"1575199190"},[{"id":"1475","similarity":0.92,"totOverlap":161,"longestOverlap":58},{"id":"1531","similarity":0.8535031847133758,"totOverlap":134,"longestOverlap":41}]],"1475":[{"id":"1475","fileName":"1575231932.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& b) {\n        int quer_size = b.size(), nums_size = a.size();\n        vector<int> vct = a;\n        for (int k = 0; k <= quer_size; k++) \n        {\n            bool t = true;\n            for (int i = 0; i < nums_size; i++) \n            {\n                int targ = vct[i];\n                vector<bool> dp(targ + 1, false);\n                dp[0] = true;\n                for (int j = 0; j < k; j++) \n                {\n                    if (b[j][0] <= i && i <= b[j][1]) \n                    {\n                        int v = b[j][2];\n                        for (int s = targ; s >= v; s--) \n                        {\n                            dp[s] = dp[s] || dp[s - v];\n                        }\n                    }\n                }\n                if(!dp[targ]) \n                {\n                    t = false;\n                    break;\n                }\n            }\n            if(t) \n            return k;\n        }\n        return -1;\n    }\n};","author":"Shreyansh kachhadiya","submissionId":"1575231932"},[{"id":"883","similarity":0.92,"totOverlap":161,"longestOverlap":58}]],"1531":[{"id":"1531","fileName":"1575235061.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        for (int k = 0; k <= m; k++) {\n            bool ok = true;\n            for (int i = 0; i < n; i++) {\n                int tar = nums[i];\n                vector<bool> dp(tar+1, false);\n                dp[0] = true;\n                for (int j = 0; j < k; j++) {\n                    if (queries[j][0] <= i && i <= queries[j][1]) {\n                        int val = queries[j][2];\n                        for (int s = tar - val; s >= 0; s--) {\n                            if (dp[s]) dp[s+val] = true;\n                        }\n                    }\n                }\n                if (!dp[tar]) { ok = false; break; }\n            }\n            if (ok) return k;\n        }\n        return -1;\n    }\n};\n","author":"Amjad Imran","submissionId":"1575235061"},[{"id":"1475","similarity":0.8535031847133758,"totOverlap":134,"longestOverlap":41}]]},{"884":[{"id":"884","fileName":"1575199066.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        int q=queries.size();\n        unordered_map<int,vector<pair<int, int>>>applicable;\n        for(int idx=0;idx<q;idx++){\n            int l=queries[idx][0];\n            int r=queries[idx][1];\n            int val=queries[idx][2];\n            for(int i=l;i<=r;i++){\n                if(i>=0&&i<n){\n                    applicable[i].emplace_back(idx,val);\n                }\n            }\n        }\n        int max_k=-1;\n        for (int i=0;i<n;i++) {\n            if(nums[i]==0)\n                continue;\n            auto aq=applicable[i];\n            if(aq.empty())\n                return -1;\n            unordered_set<int>sums={0};\n            bool found =false;\n            int currentSum=0;\n            int currentMaxIdx=-1;\n            for(auto query:aq){\n                int idx=query.first;\n                int val=query.second;\n                currentSum+=val;\n                unordered_set<int>newSums;\n                for(int s : sums){\n                    int newS=s+val;\n                    if (newS==nums[i]){\n                        currentMaxIdx=max(currentMaxIdx, idx);\n                        found=true;\n                        break;\n                    }\n                    newSums.insert(newS);\n                }\n                if(found) \n                    break;\n\n                for(int s:newSums){\n                    sums.insert(s);\n                }\n                sums.insert(val);\n            }\n            if(!found)\n                return -1;\n            max_k=max(max_k,currentMaxIdx);\n        }\n        return max_k == -1 ? 0 : max_k + 1;\n    }\n};","author":"mukhesh27","submissionId":"1575199066"},[]]},{"885":[{"id":"885","fileName":"1575199208.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number}\n */\nvar minZeroArray = function (nums, queries) {\n  if (nums.every((x) => x === 0)) return 0;\n\n  let n = nums.length;\n  let q = queries.length;\n\n  let cov = Array.from({ length: n }, () => Array(q).fill(0));\n  for (let i = 0; i < q; i++) {\n    let [l, r, val] = queries[i];\n    for (let j = l; j <= r; j++) {\n      cov[j][i] = val;\n    }\n  }\n\n  function canSum(arr, t) {\n    let dp = new Uint8Array(t + 1);\n    dp[0] = 1;\n    for (let x of arr) {\n      for (let s = t; s >= x; s--) {\n        if (dp[s - x]) dp[s] = 1;\n      }\n    }\n    return dp[t] === 1;\n  }\n\n  for (let k = 1; k <= q; k++) {\n    let ok = true;\n    for (let idx = 0; idx < n; idx++) {\n      let need = nums[idx];\n      if (need === 0) continue;\n\n      let arr = cov[idx].slice(0, k);\n      let sumArr = arr.reduce((a, b) => a + b, 0);\n\n      if (sumArr < need || !canSum(arr, need)) {\n        ok = false;\n        break;\n      }\n    }\n    if (ok) return k;\n  }\n  return -1;\n};\n","author":"Yuriy","submissionId":"1575199208"},[]]},{"886":[{"id":"886","fileName":"1575198952.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        res = 0\n        n, m = len(nums), len(queries)\n        cntZero = nums.count(0)\n        \n        if cntZero == n:\n            return res\n        \n        finished = set(i for i, num in enumerate(nums) if num == 0)\n        sets = [set() for _ in range(n)]\n        \n        for j, (left, right, val) in enumerate(queries):\n            for i in range(left, right + 1):\n                if i not in finished:\n                    new_set = {val}\n                    for x in sets[i]:\n                        new_set.add(x)\n                        new_set.add(x + val)\n                    \n                    if nums[i] in new_set:\n                        finished.add(i)\n                        if len(finished) == n:\n                            return j + 1\n                    else:\n                        sets[i] = new_set\n        \n        return -1\n","author":"cl3424","submissionId":"1575198952"},[]]},{"887":[{"id":"887","fileName":"1575199248.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        auto check = [&](int k) {\n            vector<vector<int>> x(n);\n            int cnt = 0;\n        for(auto &y: queries) {\n            if(cnt >= k) break;\n            cnt++;\n            for(int i = y[0]; i <= y[1]; i++) x[i].push_back(y[2]);\n        }\n        for(int i = 0; i < n; i++) {\n            if(nums[i] == 0) continue;\n            vector<int> dp(nums[i] + 1, 0);\n            dp[0] = 1;\n            for(int j = 0; j < x[i].size(); j++) {\n                for(int k = nums[i]; k >= 0; k--) {\n                    if(k >= x[i][j]) dp[k] |= dp[k - x[i][j]];\n                }\n            }\n            if(dp[nums[i]] == 0) return 0;\n        }\n        return 1;\n        };\n        int lo = 0, hi = queries.size(), ans = -1;\n        while(lo <= hi) {\n            int mid = (lo + hi) / 2;\n            if(check(mid)) {\n                hi = mid - 1;\n                ans = mid;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        return ans;\n        \n    }\n};","author":"Kaizen2024","submissionId":"1575199248"},[]]},{"888":[{"id":"888","fileName":"1575199375.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if not any(nums): return 0\n        n = len(nums)\n        offs = [{0} for _ in range(n)]\n        for idx,(l, r, v) in enumerate(queries):\n            for i in range(l, r+1):\n                offs[i] |= {x+v for x in offs[i]}\n            if all([x in offs[i] for i,x in enumerate(nums)]): return idx+1\n        return -1","author":"glump1","submissionId":"1575199375"},[]]},{"889":[{"id":"889","fileName":"1575199346.txt","sourceCode":"class Solution \n{\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) \n    {\n        int n = nums.size(), m = queries.size();\n\n        std::vector<std::vector<std::pair<int, int>>> arr(n);\n        for (int i = 0; i < m; ++i)\n        {\n            int left = queries[i][0];\n            int right = queries[i][1];\n            int val = queries[i][2];\n            for (int j = left; j <= right; ++j)\n                arr[j].push_back({ i, val });\n        }\n\n        int left = 0, right = m;\n        while (left < right)\n        {\n            int mid = left + (right - left) / 2;\n            if (isOk(nums, arr, mid))\n                right = mid;\n            else\n                left = mid + 1;\n        }\n\n        if (!isOk(nums, arr, left))\n            return -1;\n        \n        return left;\n    }\n\nprivate:\n    bool isOk(\n        std::vector<int>& nums, \n        std::vector<std::vector<std::pair<int, int>>>& arr,\n        int k)\n    {\n        int n = nums.size(), m = arr.size();\n\n        for (int i = 0; i < n; ++i)\n        {\n            if (nums[i] == 0)\n                continue;\n\n            std::vector<int> vals(k, 0);\n            for (auto&& [i, v] : arr[i])\n            {\n                if (i < k)\n                    vals.push_back(v);\n            }\n\n            sumBit.reset();\n            sumBit[0] = 1;\n            for (auto v : vals)\n                sumBit |= (sumBit << v);\n\n            if (sumBit[nums[i]] == 0)\n                return false;\n        }\n\n        return true;\n    }\n\nprivate:\n    std::bitset<1001> sumBit;\n};","author":"Todd","submissionId":"1575199346"},[]]},{"890":[{"id":"890","fileName":"1575199886.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(), k=queries.size();\n        vector<vector<int>>dp(n, vector<int>(1001, -1));\n        for(int i=0;i<n;i++){\n            dp[i][nums[i]]=0;\n        }\n        auto getMinK=[&](int j, int val, int idx)\n        {\n            if(dp[j][0]!=-1)return;\n            for(int i=0;i+val <= nums[j];i++){\n                if(dp[j][i+val]!=-1){\n                    dp[j][i]=idx;\n                }\n            }\n        };\n        auto check=[&]()\n        {\n            int yes=true;\n            for(int i=0;i<n;i++){\n                yes&=(dp[i][0] !=-1);\n            }\n            return yes;\n        };\n        if(check()){\n            return 0;\n        }\n        int idx=0;\n        for(auto j:queries){\n            idx++;\n            int l=j[0], r=j[1], val=j[2];\n            while(l<=r){\n                getMinK(l, val, idx);\n                l++;\n            }\n            if(check()){\n                return idx;\n            }\n        }\n        return -1;\n    }\n};","author":"Krishna0211","submissionId":"1575199886"},[]]},{"891":[{"id":"891","fileName":"1575199341.txt","sourceCode":"class Node:\n    def __init__(self):\n        # Array to store links to child nodes,\n        # each index represents a letter\n        self.links = [None] * 26\n        # Flag indicating if the node\n        # marks the end of a word\n        self.flag = False\n\n    # Check if the node contains\n    # a specific key (letter)\n    def containsKey(self, ch):\n        return self.links[ord(ch) - ord('a')] is not None\n\n    # Insert a new node with a specific\n    # key (letter) into the Trie\n    def put(self, ch, node):\n        self.links[ord(ch) - ord('a')] = node\n\n    # Get the node with a specific\n    # key (letter) from the Trie\n    def get(self, ch):\n        return self.links[ord(ch) - ord('a')]\n\n    # Set the current node\n    # as the end of a word\n    def setEnd(self):\n        self.flag = True\n\n    # Check if the current node\n    # marks the end of a word\n    def isEnd(self):\n        return self.flag\n\n\nclass Trie:\n    def __init__(self):\n        # Constructor to initialize the\n        # Trie with an empty root node\n        self.root = Node()\n\n    # Inserts a word into the Trie\n    # Time Complexity O(len), where len\n    # is the length of the word\n    def insert(self, word):\n        node = self.root\n        for ch in word:\n            if not node.containsKey(ch):\n                # Create a new node for\n                # the letter if not present\n                node.put(ch, Node())\n            # Move to the next node\n            node = node.get(ch)\n        # Mark the end of the word\n        node.setEnd()\n\n    # Returns if the word\n    # is in the trie\n    def search(self, word):\n        node = self.root\n        for ch in word:\n            if not node.containsKey(ch):\n                # If a letter is not found,\n                # the word is not in the Trie\n                return False\n            # Move to the next node\n            node = node.get(ch)\n        # Check if the last node\n        # marks the end of a word\n        return node.isEnd()\n\n    # Returns if there is any word in the\n    # trie that starts with the given prefix\n    def startsWith(self, prefix):\n        node = self.root\n        for ch in prefix:\n            if not node.containsKey(ch):\n                # If a letter is not found, there is\n                # no word with the given prefix\n                return False\n            # Move to the next node\n            node = node.get(ch)\n        # The prefix is found in the Trie\n        return True\n\n\nclass Solution(object):\n    def minZeroArray(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: int\n        \"\"\"\n        arraySize = len(nums)\n        dynamicProgramming = [set() for _ in range(arraySize)]\n        \n        for index in range(arraySize):\n            dynamicProgramming[index].add(0)\n        \n        isAllZero = all(num == 0 for num in nums)\n        \n        if isAllZero:\n            return 0\n        \n        for operationIndex, operation in enumerate(queries):\n            left, right, value = operation\n            \n            for index in range(left, right + 1):\n                newSet = set()\n                for existingValue in dynamicProgramming[index]:\n                    newSet.add(existingValue + value)\n                dynamicProgramming[index].update(newSet)\n                dynamicProgramming[index] = {x for x in dynamicProgramming[index] if x <= nums[index]}\n            \n            isAllAchieved = all(nums[index] in dynamicProgramming[index] for index in range(arraySize))\n            \n            if isAllAchieved:\n                return operationIndex + 1\n        \n        return -1","author":"ABHINAV KUMAR","submissionId":"1575199341"},[]]},{"892":[{"id":"892","fileName":"1575199691.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        if (allZero(nums)) return 0;\n        int left = 0, right = queries.length - 1;\n        while (left <= right) {\n            int mid = left + right >>> 1;\n            if (valid(nums, queries, mid)) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left == queries.length ? -1 : left + 1;\n    }\n\n    private boolean allZero(int[] nums) {\n        for (int i : nums) if (i != 0) return false;\n        return true;\n    }\n\n    private boolean valid(int[] nums, int[][] queries, int idx) {\n        List<List<Integer>> vals = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) vals.add(new ArrayList<>());\n        for (int i = 0; i <= idx; i++) {\n            for (int j = queries[i][0]; j <= queries[i][1]; j++) {\n                vals.get(j).add(queries[i][2]);\n            }\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] > 0 && !canFill(nums[i], vals.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean canFill(int val, List<Integer> list) {\n        boolean[] dp = new boolean[val + 1];\n        dp[0] = true;\n        for (int num : list) {\n            for (int i = val; i >= num; i--) {\n                if (num > i) continue;\n                dp[i] |= dp[i - num];\n            }\n        }\n        return dp[val];\n    }\n}","author":"Di Ha","submissionId":"1575199691"},[]]},{"893":[{"id":"893","fileName":"1575200098.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        N = len(nums)\n        def is_possible(k):\n            for i in range(N):\n                if nums[i] == 0:\n                    continue\n                target = nums[i]\n\n                dp = [False] * (target + 1)\n                dp[0] = True\n\n                for j in range(k):\n                    left, right, val = queries[j]\n                    if left <= i <= right:\n                        for s in range(target,val-1,-1):\n                            if dp[s-val]:\n                                dp[s]=True\n\n                if not dp[target]:\n                    return False\n\n            return True\n\n        if not is_possible(len(queries)):\n            return -1\n\n        left, right = 0, len(queries)\n\n        res = float('inf')\n        while left <= right:\n            mid = left + ((right-left)//2)\n            if is_possible(mid):\n                res = min(res,mid)\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return res\n                \n        ","author":"adityabhattad18","submissionId":"1575200098"},[]]},{"894":[{"id":"894","fileName":"1575200133.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int N = nums.size(), Q = queries.size();\n        vector<bool> finished(N);\n        vector<set<int>> m(N);\n        for (auto& i: m) i.insert(0);\n        int res = 0;\n        for (int i = 0; i < N; ++i) {\n            if (nums[i] == 0) finished[i] = true;\n        }\n        for (int i = 0; i < queries.size(); ++i) {\n            int val = queries[i][2];\n            for (int j = queries[i][0]; j <= queries[i][1]; ++j) {\n                if (finished[j]) continue;\n                vector<int> vals;\n                for (auto v: m[j]) {\n                    if (val + v == nums[j]) {\n                        res = max(res, i+1);\n                        finished[j] = true;\n                    }\n                    vals.push_back(val+v);\n                }\n                for (auto i: vals) m[j].insert(i);\n            }\n        }\n        // for (auto i: m) {\n        //     for (auto j: i) cout << j << \" \";\n        //     cout << \"!n\";\n        // }\n        // for (auto i: finished) cout << i << \" \";\n        if (accumulate(begin(finished), end(finished), 0) != N) \n            return -1;\n        return res;\n    }\n};","author":"Manny","submissionId":"1575200133"},[]]},{"895":[{"id":"895","fileName":"1575200223.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        @lru_cache(maxsize=len(queries)*len(nums)*32)\n        def minQueries(qi, ni, nval):\n            if nval == 0:\n                return 0\n            if qi >= len(queries):\n                return float('inf')\n            take, skip = float('inf'), float('inf')\n            l, r, val = queries[qi]\n            if ni >= l and ni <= r and nval >= val:\n                take = 1 + minQueries(qi+1, ni, nval - val)\n            skip = 1 + minQueries(qi+1, ni, nval)\n            return min(take, skip)\n\n        res = 0\n        for i, n in enumerate(nums):\n            # print(i, n, minQueries(0, i, n))\n            res = max(res, minQueries(0, i, n))\n        return res if res != float('inf') else -1\n            ","author":"Andrew Lo Zhi Sheng","submissionId":"1575200223"},[]]},{"896":[{"id":"896","fileName":"1575200215.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int l = 0, r = queries.length;\n        int ans = -1;\n\n        while (l <= r) {\n            int mid = (r - l) / 2 + l;\n            if (canTransform(nums, queries, mid)) {\n                r = mid - 1;\n                ans = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n\n        return ans;\n    }\n\n    public boolean canTransform(int[] nums, int[][] queries, int right) {\n        final int N = nums.length;\n        List<List<Integer>> querySums = new ArrayList<>();\n\n        for (int i = 0; i < N; i++) {\n            querySums.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < right; i++) {\n            int start = queries[i][0];\n            int end = queries[i][1];\n            int decrement = queries[i][2];\n\n            for (int j = start; j <= end; j++) {\n                querySums.get(j).add(decrement);\n            }\n        }\n\n        for (int i = 0; i < N; i++) {\n            if (!canMakeExactSum(querySums.get(i), nums[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private boolean canMakeExactSum(List<Integer> options, int target) {\n        if (target == 0) return true;\n\n        Set<Integer> possibleSums = new HashSet<>();\n        possibleSums.add(0);\n\n        for (int num : options) {\n            Set<Integer> newSums = new HashSet<>(possibleSums);\n            for (int sum : possibleSums) {\n                int newSum = sum + num;\n                if (newSum == target) return true;\n                newSums.add(newSum);\n            }\n            possibleSums = newSums;\n        }\n\n        return possibleSums.contains(target);\n    }\n\n}","author":"aarons_daniel","submissionId":"1575200215"},[]]},{"897":[{"id":"897","fileName":"1575200225.txt","sourceCode":"class Solution {\npublic:\n    bool recur(int ind,vector<int> &arr,int target, vector<vector<int>> & dp){\n        if(target == 0) return true;\n        if(ind == 0) return (arr[0] == target);\n        if(dp[ind][target]!=-1) return dp[ind][target];\n        bool nTake = recur(ind-1, arr, target,dp);\n        bool take = false;\n        if(arr[ind]<=target)\n        take = recur(ind-1,arr,target-arr[ind],dp);\n        return dp[ind][target] = take || nTake;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<vector<int>> v(n);\n        for(int i = 0;i<m;i++){\n            bool f = 1;\n            //**************************\n            \n            for(int i = 0;i<v.size();i++){\n            if(v[i].size() == 0){\n                if(nums[i] != 0){\n                    f = 0;\n                    break;\n                }\n            }\n             vector<vector<int>> dp(v[i].size(),vector<int>(nums[i]+1,-1));\n            if(!recur(v[i].size()-1,v[i],nums[i],dp)){\n                f = 0;\n                break;\n            }\n           \n            \n        }\n            if(f) return i;\n            //**************************\n            for(int ind = queries[i][0];ind<=queries[i][1];ind++){\n                v[ind].push_back(queries[i][2]);\n            }\n        }\n        \n        bool f = 1;\n            \n            for(int i = 0;i<v.size();i++){\n            if(v[i].size() == 0){\n                if(nums[i] != 0){\n                    f = 0;\n                    break;\n                }\n            }\n             vector<vector<int>> dp(v[i].size(),vector<int>(nums[i]+1,-1));\n            if(!recur(v[i].size()-1,v[i],nums[i],dp)){\n                f = 0;\n                break;\n            }\n           \n            \n        }\n            if(f) return m;\n        return -1;\n    }\n};","author":"Vishal Rathod","submissionId":"1575200225"},[]]},{"898":[{"id":"898","fileName":"1575200243.txt","sourceCode":"class SegmentTree:\n    def __init__(self, n):\n        self.n = n\n        while (self.n & (self.n-1)) != 0:\n            self.n += 1\n        self.build(n)\n\n    def build(self, n):\n        self.tree = [0] * (2*self.n)\n        # Leaf nodes.\n        for i in range(self.n, self.n+n):\n            self.tree[i] = 1\n        # Parent nodes.\n        for i in range(self.n-1, 0, -1):\n            self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1]\n\n    def update(self, i, val):\n        self.tree[self.n+i] += val\n        j = (self.n+i) >> 1\n        while j >= 1:\n            self.tree[j] = self.tree[j << 1] + self.tree[j << 1 | 1]\n            j >>= 1\n\n    #def update_range(self, l, r, val):\n    #    l += self.n\n    #    r += self.n + 1\n    #    for i in range(l, r):\n    #        if self.tree[i] < \n        \n    def query(self, l, r):\n        res = 0\n        l += self.n\n        r += self.n + 1\n        while l < r:\n            if l & 1:\n                res += self.tree[l]\n                l += 1\n            if r & 1:\n                r -= 1\n                res += self.tree[r]\n            l >>= 1\n            r >>= 1\n            \n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        #segment_tree = SegmentTree(len(nums))\n        #for i, num in enumerate(nums):\n        #    segment_tree.update(i, num)\n\n        #for l, r, val in queries:\n        \n        zero_count = 0\n        state = []\n        for i, num in enumerate(nums):\n            state.append(set())\n            if nums[i] != 0:\n                state[i].add(num)\n            else:\n                zero_count += 1\n        if zero_count == len(nums):\n            return 0\n        #print(f'zc: {zero_count}, state: {state}')\n        for i, q in enumerate(queries):\n            #print(f'start query - index {i}, ')\n            l = q[0]\n            r = q[1]\n            val = q[2]\n            for j in range(l, r+1):\n                if not state[j]:\n                    # Already zero.\n                    continue\n                if val in state[j]:\n                    # Becomes 0.\n                    state[j] = set()\n                    zero_count += 1\n                    if zero_count == len(nums):\n                        return i+1\n                    continue\n                curr_state = state[j]\n                to_add = []\n                for v in state[j]:\n                    if v-val > 0 and v-val not in state[j]:\n                        to_add.append(v-val)\n                for a in to_add:\n                    state[j].add(a)\n        return -1\n            ","author":"jeremyfellner","submissionId":"1575200243"},[]]},{"899":[{"id":"899","fileName":"1575200341.txt","sourceCode":"class Solution {\npublic:\n    vector<vector<int>> dp;\n    \n    int rec(int idx,int sum,vector<pair<int,int>> &val){\n        \n        \n        if(sum==0){\n            if(idx-1>=0)return val[idx-1].second;\n            else return 0;\n        }\n        \n        if(idx==val.size())return 1e9;\n        \n        if(dp[idx][sum]!=-1)return dp[idx][sum];\n        \n        int ans=1e9;\n        if(sum>=val[idx].first)\n         ans=min(ans,rec(idx+1,sum-val[idx].first,val));\n        ans=min(ans,rec(idx+1,sum,val));\n        \n        return dp[idx][sum]=ans;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        \n         int n=nums.size();\n        \n         vector<vector< pair<int,int> > >values(n);\n        \n         int q=queries.size();\n        \n         for(int i=0;i<q;i++){\n             \n             int l=queries[i][0],r=queries[i][1],val=queries[i][2];\n             for(int j=l;j<=r;j++){\n                 values[j].push_back({val,i+1});\n             }\n         }\n        \n        int ans=-1;\n        \n        for(int i=0;i<n;i++){\n            if(values[i].size()==0){\n                if(nums[i]!=0){\n                    return -1;\n                }else{\n                    continue;\n                }\n            }\n            \n            dp=vector<vector<int>>((int)values[i].size(),vector<int>(nums[i]+1,-1));\n            int res=rec(0,nums[i],values[i]);\n            // cout<<res<<endl;\n            if(res==1e9){\n                ans=-1;\n                break;\n            }else{\n                ans=max(ans,res);\n            }\n            \n        }\n        \n       \n        \n        return ans;\n    }\n};","author":"Sahil Kumar","submissionId":"1575200341"},[]]},{"900":[{"id":"900","fileName":"1575200805.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        BitSet[] arr = new BitSet[n];\n        for (int j = 0; j < n; j++) {\n            arr[j] = new BitSet(1001);\n            arr[j].set(0);\n        }\n        int flag = 1;\n        for (int j = 0; j < n; j++) {\n            if (nums[j] != 0) {\n                flag = 0;\n                break;\n            }\n        }\n        if (flag == 1) return 0;\n        for (int k = 0; k < queries.length; k++) {\n            int li = queries[k][0];\n            int ri = queries[k][1];\n            int val = queries[k][2];\n            for (int j = li; j <= ri; j++) {\n                BitSet temp = new BitSet(1001);\n                for (int i = 0; i < 1001 - val; i++) {\n                    if (arr[j].get(i)) {\n                        temp.set(i + val);\n                    }\n                }\n                arr[j].or(temp);\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    arr[j].clear(pos);\n                }\n            }\n            flag = 1;\n            for (int j = 0; j < n; j++) {\n                if (!arr[j].get(nums[j])) {\n                    flag = 0;\n                    break;\n                }\n            }\n            if (flag == 1) return k + 1;\n        }\n        return -1;\n    }\n}\n","author":"Gokul G","submissionId":"1575200805"},[]]},{"901":[{"id":"901","fileName":"1575200768.txt","sourceCode":"class Solution {\npublic:\n\n    // bool canZeroAtIndex(const vector<int>& s, int target) {\n    //     vector<bool> dp(target + 1, false);\n    //     dp[0] = true;\n    //     for (int val : s) {\n    //         for (int j = target; j >= val; --j) {\n    //             if (dp[j - val]) {\n    //                 dp[j] = true;\n    //             }\n    //         }\n    //     }\n    //     return dp[target];\n    // }\n\n    // bool canZeroAtIndex(const vector<int>& s, int target) {\n    //     bitset<1001> dp;  \n    //     dp.reset();\n    //     dp[0] = 1;\n    //     for (int val : s) {\n    //         dp |= (dp << val);\n    //     }\n    //     return dp[target];\n    // }\n\n    // bool check(vector<int>& nums, vector<vector<int> >& q, int mid) {\n    //     int n = nums.size();\n    //     int m = q.size();\n    //     vector<vector<int> > store(n);\n    //     for (int i = 0; i <= mid; ++i) {\n    //         for (int l = q[i][0]; l <= q[i][1]; ++l) {\n    //             store[l].push_back(q[i][2]);\n    //         }\n    //     }\n    //     for (auto& v: store) {\n    //         std::sort(v.begin(), v.end());\n    //     }\n    //     for (int i = 0; i < n; ++i) {\n    //         if (nums[i] == 0) continue;\n    //         if (!canZeroAtIndex(store[i], nums[i])) {\n    //             return false;\n    //         }\n    //     }\n\n    //     return true;\n    // }\n\n    // int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n    //     int n = nums.size(), m = q.size();\n    //     const int MAX_SUM = 1010;\n\n    //     vector<bitset<1001>> dp(n);\n    //     vector<int> earliest(n, -1);\n\n    //     for (int i = 0; i < n; i++) {\n    //         dp[i].reset();\n    //         dp[i][0] = 1;\n    //     }\n    //     for (int j = 0; j < m; j++) {\n    //         int l = q[j][0], r = q[j][1], val = q[j][2];\n    //         for (int i = l; i <= r; i++) {\n    //             dp[i] |= (dp[i] << val);  \n    //             if (earliest[i] == -1 && dp[i][nums[i]] == true) {\n    //                 earliest[i] = j;\n    //             }\n    //         }\n    //     }\n    //     int ans = -1;\n    //     for (int i = 0; i < n; i++) {\n    //         if (nums[i] > 0 && earliest[i] == -1) {\n    //             return -1; \n    //         }\n    //         ans = max(ans, earliest[i]);\n    //     }\n    //     return ans + 1; \n    // }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        bool allZero = true;\n        for (int val: nums) {\n            if (val) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) {\n            return 0;\n        }\n        vector<vector<bool>> dp(n);\n        for (int i = 0; i < n; i++) {\n            dp[i].resize(nums[i] + 1, false);\n            dp[i][0] = true;\n        }\n\n        // O(m * (10) * (m + n)) \n        for (int k = 0; k < m; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int val = queries[k][2];\n            for (int i = l; i <= r; i++) {\n                for (int j = dp[i].size() - 1; j >= val; j--) {\n                    if (dp[i][j - val]) {\n                        dp[i][j] = true;\n                    }\n                }\n            }\n            bool allZero = true;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i][nums[i]]) {\n                    allZero = false;\n                    break;\n                }\n            }\n            if (allZero) {\n                return k + 1; \n            }\n        }\n        return -1; \n    }\n   \n};","author":"dumpfile","submissionId":"1575200768"},[{"id":"1863","similarity":0.8697674418604651,"totOverlap":187,"longestOverlap":46},{"id":"903","similarity":0.8599033816425121,"totOverlap":178,"longestOverlap":43}]],"903":[{"id":"903","fileName":"1575201017.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n\n        int zeros = 0;\n\n        for (int x : nums)\n        {\n            if (x == 0) {\n                zeros++;\n            }\n        }\n\n        if (zeros == n) {\n            return 0;\n        }\n        \n        vector<vector<bool>> dp(n);\n        \n        for (int i = 0; i < n; i++)\n        {\n            dp[i].resize(nums[i] + 1, false);\n            dp[i][0] = true;\n        }\n\n        for (int j = 0; j < q; j++)\n        {\n            int l = queries[j][0];\n            int r = queries[j][1];\n            int val = queries[j][2];\n            \n            for (int i = l; i <= r; i++)\n            {\n                for (int s = dp[i].size() - 1 - val; s >= 0; s--)\n                {\n                    if (dp[i][s])\n                    {\n                        int ns = s + val;\n                        if (ns <= nums[i]) {\n                            dp[i][ns] = true;\n                        }\n                    }\n                }\n            }\n            \n            bool allZero = true;\n            for (int i = 0; i < n; i++)\n            {\n                if (!dp[i][nums[i]])\n                {\n                    allZero = false;\n                    break;\n                }\n            }\n            if (allZero) {\n                return j + 1;\n            }\n        }\n        \n        return -1;\n    }\n};","author":"Soumik Majumder","submissionId":"1575201017"},[{"id":"901","similarity":0.8599033816425121,"totOverlap":178,"longestOverlap":43}]],"1863":[{"id":"1863","fileName":"611249842.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        \n        bool allZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) {\n            return 0;\n        }\n        \n        vector<vector<bool>> possible(n);\n        for (int j = 0; j < n; ++j) {\n            possible[j].resize(nums[j] + 1, false);\n            possible[j][0] = true;\n        }\n        \n        for (int k = 0; k < m; ++k) {\n            int li = queries[k][0];\n            int ri = queries[k][1];\n            int vali = queries[k][2];\n            \n            for (int j = li; j <= ri; ++j) {\n                int max_s = nums[j];\n                for (int s = max_s; s >= vali; --s) {\n                    if (s - vali >= 0) {\n                        possible[j][s] = possible[j][s] || possible[j][s - vali];\n                    }\n                }\n            }\n            \n            bool can_achieve = true;\n            for (int j = 0; j < n; ++j) {\n                if (!possible[j][nums[j]]) {\n                    can_achieve = false;\n                    break;\n                }\n            }\n            if (can_achieve) {\n                return k + 1;\n            }\n        }\n        \n        return -1;\n    }\n};","author":"Jepe","submissionId":"611249842"},[{"id":"901","similarity":0.8697674418604651,"totOverlap":187,"longestOverlap":46}]]},{"902":[{"id":"902","fileName":"1575200942.txt","sourceCode":"class Solution {\npublic:\n\n    bool subsetSum(vector<int> &temp, int i, int target){\n        if(target==0) return true;\n        if(i==temp.size()) return false;\n        bool Ans = false;\n        if(target-temp[i] >= 0)\n            Ans = subsetSum(temp, i+1, target-temp[i]);\n        if(Ans) return Ans;\n        Ans = Ans | subsetSum(temp, i+1, target);\n        return Ans;\n    }\n\n    bool subsetSum_bitset(vector<int>& nums, int target) {\n        bitset<100001> dp; \n        dp[0] = 1; \n        for (int num : nums) {\n            dp |= dp << num; \n        }\n        return dp[target];\n    }\n\n    bool canSolve(vector<int>&A, vector<vector<int>>&Q, int mid){\n        unordered_map<int, vector<int>> M;\n        for(int i=0; i<=mid; i++){\n            int l = Q[i][0];\n            int r = Q[i][1];\n            int val = Q[i][2];\n            for(int j=l; j<=r; j++){\n                if(val <= A[j] ){\n                     M[j].push_back(val);\n                }\n               \n            }\n        }\n        \n        for(int i=0; i<A.size(); i++){\n            if(A[i]==0) continue;\n            bool subsetAns =  subsetSum_bitset(M[i], A[i]);\n            if(!subsetAns) return false;\n        }\n\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int> temp =  nums;\n        sort(temp.begin(), temp.end());\n        if(temp.back() == 0) return 0;\n        \n        int start = 0, end = queries.size()-1;\n        while(start < end){\n            int mid = start + (end-start)/2;\n            if(canSolve(nums, queries, mid)){\n                end = mid;\n            } else{\n                start = mid+1;\n            }\n        }\n\n        if(canSolve(nums, queries, start)) return start+1;\n        return -1;\n    }\n};","author":"Asmit Papney","submissionId":"1575200942"},[]]},{"904":[{"id":"904","fileName":"1575200712.txt","sourceCode":"class Solution {\npublic:\n    bool help(vector<int>& arr,int target){\n        vector<bool> dp(target+1,false);\n        dp[0]=true;\n        for(auto val:arr){\n            for(int s=target;s>=val;s--) dp[s]=dp[s]||dp[s-val];\n        }\n\n        return dp[target];\n    }\n    bool f(vector<int>& nums,vector<vector<int>>& queries,vector<vector<int>>& temp,int mid){\n        for(int i=0;i<nums.size();i++){\n            if(nums[i]==0) continue;\n            vector<int> avail;\n            for(int j=0;j<temp[i].size();j++){\n                if(temp[i][j]<mid){\n                    avail.push_back(queries[temp[i][j]][2]);\n                }\n            } \n            if(!help(avail,nums[i])) return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<vector<int>> temp(nums.size());\n        for(int i=0;i<queries.size();i++){\n            for(int j=queries[i][0];j<=queries[i][1];j++) temp[j].push_back(i);\n        }\n        int lo=0,hi=queries.size(),ans=-1;\n        while(lo<=hi){\n            int mid=(lo+hi)/2;\n            if(f(nums,queries,temp,mid)){\n                ans=mid;\n                hi=mid-1;\n            }\n            else lo=mid+1;\n        }\n        return ans;\n    }\n};","author":"dhruv_gupta123","submissionId":"1575200712"},[]]},{"905":[{"id":"905","fileName":"1575200963.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    int n = nums.size();\n    \n    vector<unordered_set<int>> achievable(n);\n    \n    for (int i = 0; i < n; i++) {\n        achievable[i].insert(0);\n    }\n    \n    if (all_of(nums.begin(), nums.end(), [](int x) { return x == 0; })) {\n        return 0;\n    }\n    \n    for (int queryIdx = 0; queryIdx < queries.size(); queryIdx++) {\n        int left = queries[queryIdx][0];\n        int right = queries[queryIdx][1];\n        int addValue = queries[queryIdx][2];\n        \n        for (int pos = left; pos <= right; pos++) {\n            unordered_set<int> newValues;\n            \n            for (int val : achievable[pos]) {\n                int newVal = val + addValue;\n                if (newVal <= 1000) {  \n                    newValues.insert(newVal);\n                }\n            }\n            \n            achievable[pos].insert(newValues.begin(), newValues.end());\n        }\n        \n        bool allTargetsAchievable = true;\n        for (int i = 0; i < n; i++) {\n            if (achievable[i].find(nums[i]) == achievable[i].end()) {\n                allTargetsAchievable = false;\n                break;\n            }\n        }\n        \n        if (allTargetsAchievable) {\n            return queryIdx + 1;\n        }\n    }\n    \n    return -1;\n}\n};","author":"roronoazoro2000","submissionId":"1575200963"},[]]},{"275":[{"id":"275","fileName":"1575151079.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        int q=queries.size();\n        vector<bitset<1001>> dp(n);\n        for(int i=0;i<n;i++)\n        {\n            dp[i].reset();\n            dp[i].set(0,true); \n        }\n        bool check=true;\n        for(int i=0;i<n;i++)\n        {\n            if(nums[i]!=0){\n                check=false;\n                break;\n            }\n        }\n        if(check)\n            return 0;\n        for(int i=0;i<q;i++)\n        {\n            for(int j=queries[i][0];j<=queries[i][1];j++)\n            {\n                dp[j]|=dp[j]<<queries[i][2];\n            }\n            bool check=true;\n            for(int i=0;i<n;i++)\n            {\n                if(!dp[i].test(nums[i])){\n                    check=false;\n                    break;\n                }\n            }\n            if(check)\n                return i+1;\n        }\n        return -1;\n    }\n};","author":"Harshit Chauhan","submissionId":"1575151079"},[{"id":"275","similarity":0.851063829787234,"totOverlap":160,"longestOverlap":29}]],"475":[{"id":"475","fileName":"1575169784.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        \n        bool flag = true;\n        for (int x : nums) {\n            if (x != 0) { flag= false; break; }\n        }\n        if (flag) return 0;\n        vector<bitset<1001>> dp(n);\n        for (int i = 0; i < n; i++) {\n            dp[i].reset();\n            dp[i].set(0, true); \n        }\n        \n        for (int j = 0; j < m; j++) {\n            int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n            for (int i = l; i <= r; i++) {\n                dp[i] |= (dp[i] << val);\n            }\n            \n             flag = true;\n            for (int i = 0; i < n; i++) {\n                if ( !dp[i].test(nums[i])) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) return j + 1; \n        }\n        \n        return -1;\n    }\n};\n","author":"LikithReddy","submissionId":"1575169784"},[{"id":"475","similarity":0.8888888888888888,"totOverlap":152,"longestOverlap":35}]],"549":[{"id":"549","fileName":"1575175235.txt","sourceCode":"class Solution {\n    public:\n        int minZeroArray(vector<int>& nums, vector<vector<int>>& q){\n            int n = nums.size(), m = q.size();\n            vector<bitset<1001>> dp(n);\n            for(int i = 0;i<n;i++){\n                dp[i].reset();\n                dp[i].set(0, true);\n            }\n            bool f = true;\n            for(int i=0;i<n;i++){\n                if (nums[i] != 0){\n                    f = false;\n                    break;\n                }\n            }\n            if (f)return 0;\n            for(int k=0;k<m;k++){\n                int l = q[k][0], r = q[k][1], v = q[k][2];\n                for(int i = l;i <= r;i++)dp[i] |= (dp[i] << v);\n                bool p = true;\n                for(int i=0;i<n;i++){\n                    if (!dp[i].test(nums[i])){\n                        p = false;\n                        break;\n                    }\n                }\n                if (p)return k + 1;\n            }\n            return -1;\n        }\n    };","author":"Sumit Kumar Pattanayak","submissionId":"1575175235"},[{"id":"549","similarity":0.9186046511627907,"totOverlap":158,"longestOverlap":60}]],"810":[{"id":"810","fileName":"1575194295.txt","sourceCode":"#include <vector>\n\n#include <bitset>\n\nusing namespace std;\n\nclass Solution {\n\npublic:\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\n        int n = nums.size();\n\n        vector<bitset<1001>> dp(n);\n\n        // Initialize dp: each index starts with only '0' reachable\n\n        for (int j = 0; j < n; j++) {\n\n            dp[j].reset();\n\n            dp[j].set(0);\n\n        }\n\n        // Check if all elements in nums are zero initially\n\n        bool allZero = true;\n\n        for (int j = 0; j < n; j++) {\n\n            if (nums[j] != 0) {\n\n                allZero = false;\n\n                break;\n\n            }\n\n        }\n\n        if (allZero) return 0;\n\n        // Process Queries\n\n        for (int k = 0; k < queries.size(); k++) {\n\n            int l = queries[k][0];\n\n            int r = queries[k][1];\n\n            int v = queries[k][2];\n\n            // Apply updates to dp array\n\n            for (int j = r; j >= l; j--) {\n\n                dp[j] |= (dp[j] << v);\n\n            }\n\n            // Reset numbers that exceed the current number in nums\n\n            for (int j = l; j <= r; j++) {\n\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n\n                    dp[j].reset(pos);\n\n                }\n\n            }\n\n            // Check if all numbers can be reduced to zero\n\n            bool allAchieved = true;\n\n            for (int j = 0; j < n; j++) {\n\n                if (!dp[j].test(nums[j])) {\n\n                    allAchieved = false;\n\n                    break;\n\n                }\n\n            }\n\n            if (allAchieved) return k + 1; // Return the query count\n\n        }\n\n        return -1; // Not possible to reach zero for all elements\n\n    }\n\n};","author":"VIKAS AK","submissionId":"1575194295"},[{"id":"810","similarity":0.9018691588785047,"totOverlap":193,"longestOverlap":32}]],"853":[{"id":"853","fileName":"1575197552.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<bitset<1001>> dp(n);\n        for (int j = 0; j < n; j++) {\n            dp[j].reset();\n            dp[j].set(0, true);\n        }\n        bool noOnes = false;\n        for (int j = 0; j < n; j++) {\n            if(nums[j]==0) continue;\n            else {\n                noOnes = true;\n                break;\n            }\n        }\n\n        if (!noOnes) return 0;\n\n        for (int k = 0; k < queries.size(); k++) {\n            int l = queries[k][0],r = queries[k][1], v = queries[k][2];\n            for (int j = l; j <= r; j++) {\n                dp[j] |= (dp[j] << v);\n                for (int pos = nums[j] + 1; pos < 1001; pos++) dp[j].reset(pos);\n                \n            }\n            bool allDone = true;\n            for (int j = 0; j < n; j++) {\n                if (dp[j].test(nums[j])) continue;\n                else{\n                    allDone = false;\n                    break;\n                }\n            }\n\n            if (allDone) return k + 1;\n        }\n\n        return -1;\n    }\n};","author":"being_nocturnal","submissionId":"1575197552"},[{"id":"853","similarity":0.8700564971751412,"totOverlap":154,"longestOverlap":31}]],"906":[{"id":"906","fileName":"1575201391.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n         int n = nums.size();\n        pair<vector<int>, vector<vector<int>>> pair = {nums, queries};\n       vector<bitset<1001>> dp(n);\n        for (int j=0; j<n;j++) {\n            dp[j].reset();\n            dp[j].set(0,true);\n        }\n       bool zero =true;\n        for (int j=0;j<n;j++){\n            if (nums[j]!=0){\n                zero=false;\n                break;\n            }\n        }\n      if(zero) return 0;\n        for (int k=0;k<queries.size();k++) {\n            int l =queries[k][0];\n            int r =queries[k][1];\n            int p =queries[k][2];\n            for (int j=l; j<=r;j++) {\n                dp[j] |= (dp[j] << p);\n                for (int res = nums[j] + 1;res<1001;res++) {\n                    dp[j].reset(res);\n                }\n            }\n          bool final = true;\n            for (int j=0;j<n;j++) {\n                if (!dp[j].test(nums[j])) {\n                    final=false;\n                    break;\n                }\n            }\n\n            if (final) return k+1;\n        }\n\n        return -1;\n    }\n};","author":"jeyanthi_a","submissionId":"1575201391"},[{"id":"1106","similarity":0.9587155963302753,"totOverlap":209,"longestOverlap":92},{"id":"1528","similarity":0.8959276018099548,"totOverlap":198,"longestOverlap":42},{"id":"1210","similarity":0.8508771929824561,"totOverlap":194,"longestOverlap":48},{"id":"1210","similarity":0.9018691588785047,"totOverlap":193,"longestOverlap":32},{"id":"1210","similarity":0.8584474885844748,"totOverlap":188,"longestOverlap":59},{"id":"1291","similarity":0.8732394366197183,"totOverlap":186,"longestOverlap":48},{"id":"1538","similarity":0.8701923076923077,"totOverlap":181,"longestOverlap":48},{"id":"1538","similarity":0.8606965174129353,"totOverlap":173,"longestOverlap":21},{"id":"1166","similarity":0.8936170212765957,"totOverlap":168,"longestOverlap":30},{"id":"1067","similarity":0.8652849740932642,"totOverlap":167,"longestOverlap":29},{"id":"1067","similarity":0.9382022471910112,"totOverlap":167,"longestOverlap":40},{"id":"1533","similarity":0.9322033898305084,"totOverlap":165,"longestOverlap":41},{"id":"906","similarity":0.851063829787234,"totOverlap":160,"longestOverlap":29},{"id":"1495","similarity":0.8932584269662921,"totOverlap":159,"longestOverlap":22},{"id":"1067","similarity":0.9186046511627907,"totOverlap":158,"longestOverlap":60},{"id":"1067","similarity":0.8700564971751412,"totOverlap":154,"longestOverlap":31},{"id":"1533","similarity":0.8547486033519553,"totOverlap":153,"longestOverlap":16},{"id":"1429","similarity":0.8888888888888888,"totOverlap":152,"longestOverlap":35}]],"923":[{"id":"923","fileName":"1575202182.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int  n = nums.size();\n        bool zero = true;\n        for (int x : nums) {\n            if (x != 0) {\n                zero = false;\n                break;\n            }\n        }\n\n        if (zero) {\n            return 0;\n        }\n\n        vector<int> input{nums};\n        const int MAX_SUM = 1001;\n        vector<bitset<MAX_SUM>> dp(n);\n        for (int j = 0; j < n; j++) {\n            dp[j].reset();\n            dp[j].set(0, true);\n        }\n\n        int m = queries.size();\n        for (int k = 0; k < m; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int coin = queries[k][2];\n            for (int j = l; j <= r; j++) {\n                dp[j] |= (dp[j] << coin);\n            }\n\n            bool isOk = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j].test(input[j])) {\n                    isOk = false;\n                    break;\n                }\n            }\n\n            if (isOk) {\n                return k + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"lianghudreamMustBeComeTrue","submissionId":"1575202182"},[{"id":"1429","similarity":0.8563829787234043,"totOverlap":161,"longestOverlap":28},{"id":"1429","similarity":0.8547486033519553,"totOverlap":153,"longestOverlap":16}]],"970":[{"id":"970","fileName":"1575205952.txt","sourceCode":"class Solution {\npublic:\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        int m=queries.size();\n        int vall=-1;\n        // dp vector\n        vector<bitset<2001>> dp(n);\n        for (int i = 0; i < n; i++) {\n            dp[i].reset();\n            dp[i].set(0);\n        }\n        bool flag = true;\n        if(!flag)return vall;\n        // initial check\n        for (int num : nums) {\n            if (num != 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) return 0;\n        int count=0;\n        for(int k = 0; k < queries.size(); k++) {\n            int left = queries[k][0];\n            int right = queries[k][1];\n            int val = queries[k][2];\n             for (int j = left; j <=right; j++) {\n                dp[j] = (dp[j] | (dp[j] << val));\n            }\n\n            for (int j = left; j <= right; j++) {\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp[j].reset(pos);\n                }}\n            \n             bool isPossible = true;\n            for (int j = 0; j < n; j++) {\n                if (!(dp[j].test(nums[j]))) {\n                    isPossible = false;\n                    break;\n                }\n            }\n\n            if (isPossible) return k + 1;\n        }\n\n        return vall;\n\n    }\n};","author":"Akshat","submissionId":"1575205952"},[{"id":"970","similarity":0.8606965174129353,"totOverlap":173,"longestOverlap":21}]],"1000":[{"id":"1000","fileName":"1575207571.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n        vector<bitset<1001>> mask(n);\n        for (int i=0;i<n;i++) {\n            mask[i].set(0, true);\n        }\n\n        bool zc=true;\n        for (int i=0;i<n;i++) {\n            if (nums[i]!=0) {\n                zc = false;\n                break;\n            }}\n        if(zc) return 0;\n        for(int i=0;i<q.size();i++) {\n            int l=q[i][0],r=q[i][1],num=q[i][2];\n            for(int j=l;j<=r;j++) {\n                mask[j]|=(mask[j]<<num);\n                for (int k=nums[j]+1;k<1001;k++) mask[j].reset(k);\n            }\n            bool pos = true;\n            for(int j=0;j<n;j++) {\n                if(!mask[j].test(nums[j])) {\n                    pos = false;\n                    break;\n                }\n            }\n            if(pos) return i+1;\n        }\n        return 1?-1:-1;\n    }\n};\n","author":"Champath Krishnaa K","submissionId":"1575207571"},[{"id":"1000","similarity":0.9382022471910112,"totOverlap":167,"longestOverlap":40}]],"1067":[{"id":"1067","fileName":"1575211503.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size();\n        vector<bitset<1001>> dp(n);\n        for(int i=0;i<n;i++){\n            dp[i].reset();\n            dp[i].set(0, true);\n        }\n        bool az = true;\n        for(int i=0;i<n;i++){\n            if(nums[i] != 0){\n                az = false;\n                break;\n            }\n        }\n        if (az) return 0;\n        for(int i=0;i<q;i++){\n            int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n            for(int j=l;j<=r;j++){\n                dp[j] |= (dp[j] << v);\n                for(int k=nums[j]+1;k<1001;k++) dp[j].reset(k);\n            }\n            bool flag = true;\n            for(int j=0;j<n;j++){\n                if (!dp[j].test(nums[j])) {\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag) return i + 1;\n        }\n\n        return -1;\n    }\n};","author":"Satwik Kini","submissionId":"1575211503"},[{"id":"906","similarity":0.8652849740932642,"totOverlap":167,"longestOverlap":29}]],"1106":[{"id":"1106","fileName":"1575213800.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int>elements = nums;\n        vector<vector<int>>actions = queries;\n        int size = elements.size();\n        pair<vector<int>, vector<vector<int>>> storage = {elements, actions};\n    \n        vector<bitset<1001>> tracker(size);\n        for (int idx = 0; idx < size; idx++) {\n            tracker[idx].reset();\n            tracker[idx].set(0, true);\n        }\n    \n        bool isAllZero = true;\n        for (int idx = 0; idx < size; idx++) {\n            if (elements[idx] != 0) {\n                isAllZero = false;\n                break;\n            }\n        }\n    \n        if (isAllZero) return 0;\n    \n        for (int step = 0; step < actions.size(); step++) {\n            int start = actions[step][0];\n            int end = actions[step][1];\n            int increment = actions[step][2];\n    \n            for (int idx = start; idx <= end; idx++) {\n                tracker[idx] |= (tracker[idx] << increment);\n                for (int pos = elements[idx] + 1; pos < 1001; pos++) {\n                    tracker[idx].reset(pos);\n                }\n            }\n    \n            bool conditionMet = true;\n            for (int idx = 0; idx < size; idx++) {\n                if (!tracker[idx].test(elements[idx])) {\n                    conditionMet = false;\n                    break;\n                }\n            }\n    \n            if (conditionMet) return step + 1;\n        }\n    \n        return -1;\n        \n    }\n};","author":"vanshkr22","submissionId":"1575213800"},[{"id":"906","similarity":0.9587155963302753,"totOverlap":209,"longestOverlap":92}]],"1150":[{"id":"1150","fileName":"1575216472.txt","sourceCode":"class Solution {\npublic:\n    bool check(int l,int r,int val,vector<bitset<1001>> &dp,vector<int> & nums){\n        for(int j = l; j <= r; j++){\n                dp[j] |= (dp[j] << val);\n                for(int pos = nums[j] + 1; pos < 1001; pos++){\n                    dp[j].reset(pos);\n                }\n            }\n            for(int j =0 ; j < nums.size(); j++){\n                if(!dp[j].test(nums[j])){\n                    return false;\n                }\n            }\n            return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n        vector<bitset<1001>> dp(n);\n        for(int i = 0; i < n; i++){\n            dp[i].reset();\n            dp[i].set(0,true);\n        }\n        bool flage = true;\n        for(int i = 0; i < n ;i++){\n            if(nums[i] != 0){\n                flage = false;\n                break;\n            }\n        }\n        if(flage)return 0;\n        \n        for(int i = 0; i <  q.size(); i++){\n            int l = q[i][0];\n            int r = q[i][1];\n            int val = q[i][2];\n            if(check(l,r,val,dp,nums))return i + 1;\n            \n        }\n        return -1;\n    }\n};","author":"Roshan","submissionId":"1575216472"},[{"id":"1150","similarity":0.8584474885844748,"totOverlap":188,"longestOverlap":59}]],"1166":[{"id":"1166","fileName":"1575217138.txt","sourceCode":"#include <vector>\n#include <bitset>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<bitset<1001>> t(n);\n\n        for (int i = 0; i < n; i++) {\n            t[i].reset();\n            t[i].set(0);\n        }\n\n        bool isZero = true;\n        for (int x : nums) {\n            if (x != 0) {\n                isZero = false;\n                break;\n            }\n        }\n        if (isZero) return 0;\n\n        for (int s = 0; s < queries.size(); s++) {\n            int l = queries[s][0], r = queries[s][1], v = queries[s][2];\n\n            for (int i = l; i <= r; i++) {\n                t[i] |= (t[i] << v);\n                for (int p = nums[i] + 1; p < 1001; p++) {\n                    t[i].reset(p);\n                }\n            }\n\n            bool done = true;\n            for (int i = 0; i < n; i++) {\n                if (!t[i].test(nums[i])) {\n                    done = false;\n                    break;\n                }\n            }\n\n            if (done) return s + 1;\n        }\n\n        return -1;\n    }\n};\n","author":"Namburi sriram","submissionId":"1575217138"},[{"id":"810","similarity":0.8936170212765957,"totOverlap":168,"longestOverlap":30}]],"1210":[{"id":"1210","fileName":"1575219525.txt","sourceCode":"#include <vector>\n#include <bitset>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<bitset<1001>> v(n);\n        for (int j = 0; j < n; j++) {\n            v[j].reset();\n            v[j].set(0, true);\n        }\n        bool flag = true;\n        for (int j = 0; j < n; j++) {\n            if (nums[j] != 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) return 0;\n        for (int k = 0; k < queries.size(); k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int vVal = queries[k][2];\n            applyQuery(v, nums, l, r, vVal);\n            bool ans = true;\n            for (int j = 0; j < n; j++) {\n                if (!v[j].test(nums[j])) {\n                    ans = false;\n                    break;\n                }\n            }\n            if (ans) return k + 1;\n        }\n\n        return -1;\n    }\n\n    void applyQuery(vector<bitset<1001>>& v, vector<int>& nums, int l, int r, int vVal) {\n        for (int j = l; j <= r; j++) {\n            v[j] |= (v[j] << vVal);\n            for (int p = nums[j] + 1; p < 1001; p++) {\n                v[j].reset(p);\n            }\n        }\n    }\n\n};\n","author":"Veeravardhan","submissionId":"1575219525"},[{"id":"1106","similarity":0.8508771929824561,"totOverlap":194,"longestOverlap":48}]],"1291":[{"id":"1291","fileName":"1575223593.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        vector<bitset<1001>> dp(n);\n        for(int i=0;i<n;i++){\n            dp[i].reset();\n            dp[i].set(0,true);\n        }\n        bool zero=true;\n        for(int i=0;i<n;i++){\n            if(nums[i]!=0){\n                zero=false;\n                break;\n            }\n        }\n        if(zero) return 0;\n        for(int i=0;i<queries.size();i++){\n            int left=queries[i][0];\n            int right=queries[i][1];\n            int val=queries[i][2];\n            int bisect=0;\n            for(int j=left;j<=right;j++){\n                dp[j]|=(dp[j]<<val);\n                bisect++;\n                // cout<<dp[j]<<endl;\n                for(int k=nums[j]+1;k<1001;k++) dp[j].reset(k);\n            }\n            bool can_make=true;\n            for(int j=0;j<n;j++){\n                if(!dp[j].test(nums[j])){\n                    can_make=false;\n                    break;\n                }\n            }\n            // cout<<bisect;\n            // cout<<i;\n            if(can_make) return i+1;\n        }\n        return -1;\n    }\n};","author":"THARUN KUMAR P","submissionId":"1575223593"},[{"id":"1106","similarity":0.8732394366197183,"totOverlap":186,"longestOverlap":48}]],"1429":[{"id":"1429","fileName":"1575230068.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<int> v = nums;\n        bool alr = true;\n        for(int x : v) {\n            if(x!=0) {\n                alr = false;\n                break;\n            }\n        }\n        if(alr) return 0;\n        const int MAX_SUM = 1000;\n        vector<bitset<1001>> D(n);\n        for(int i = 0;i < n;i++) {\n            D[i].reset();\n            D[i].set(0, true);\n        }\n        for(int k = 0;k < m;k++) {\n            int l = queries[k][0], r = queries[k][1], val = queries[k][2];\n            for(int i = l;i <= r;i++) {\n                D[i] |= (D[i] << val);\n            }\n            bool all = true;\n            for(int i = 0;i < n;i++) {\n                if(!D[i].test(v[i])) {\n                    all = false;\n                    break;\n                }\n            }\n            if(all) {\n                return k+1;\n            }\n        }\n        return -1;\n    }\n}; ","author":"Shasheendra_7","submissionId":"1575230068"},[{"id":"923","similarity":0.8563829787234043,"totOverlap":161,"longestOverlap":28}]],"1495":[{"id":"1495","fileName":"1575233452.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n\n        bool allEleZero = true;\n        for(int i=0; i<n; i++){\n            if(nums[i] != 0){\n                allEleZero = false;\n                break;\n            }\n        }\n        if(allEleZero) return 0; // k=0\n\n        vector<bitset<1001>> dp(n); // log2(1000) = 9.9\n        for(int i=0; i<n; i++){\n            dp[i].set(0);\n        }\n        int nq = queries.size();\n        for(int k=0; k<nq; k++){\n            int l = queries[k][0], r = queries[k][1], val = queries[k][2];\n            for(int i = l; i<=r; i++){\n                dp[i] |= (dp[i] << val);\n                for(int j=nums[i] + 1; j<1001; j++){\n                    dp[i].reset(j);\n                }\n            }\n            bool allZero = true;\n            for(int i=0; i<n; i++){\n                if(!dp[i].test(nums[i])){\n                    allZero = false;\n                    break;\n                }\n            }\n            if(allZero) return k+1;\n        }\n        return -1;\n    }\n};","author":"Vijay Purohit","submissionId":"1575233452"},[{"id":"1067","similarity":0.8932584269662921,"totOverlap":159,"longestOverlap":22}]],"1528":[{"id":"1528","fileName":"1575234881.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        int m=queries.size();\n        pair<vector<int>,vector<vector<int>>>vec= {nums, queries};\n        vector<bitset<1001>>dp(n);\n        for (int j=0;j<n;j++){\n            dp[j].reset();\n            dp[j].set(0,true);\n        }\n        bool Zero=true;\n        for (int j=0;j<n;j++){\n            if(nums[j]!=0){\n                Zero = false;\n                break;\n            }\n        }\n        if(Zero) return 0;\n        for(int k=0;k<m;k++){\n            int start = queries[k][0];\n            int end= queries[k][1];\n            int v = queries[k][2];\n            for(int j=start;j<=end;j++){\n                dp[j]|=(dp[j]<<v);\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp[j].reset(pos);\n                }\n            }\n            bool a = true;\n            for(int j=0;j<n;j++){\n                a = !dp[j].test(nums[j]) ? false : a;\n                if (!a) break;\n            }\n            if(a){\n                return k+1;\n            }\n        }\n        return -1;\n    }\n};","author":"M Samarth","submissionId":"1575234881"},[{"id":"1106","similarity":0.8959276018099548,"totOverlap":198,"longestOverlap":42}]],"1533":[{"id":"1533","fileName":"1575235165.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n        vector<bitset<1001>> state(n);\n        for(int i=0;i<n;i++){\n            state[i].reset();\n            state[i].set(0,true);\n        }\n        bool allZero=true;\n        for(int num:nums){\n            if(num!=0){\n                allZero=false;\n                break;\n            }\n        }\n        if(allZero) return 0;\n        for(int qi=0;qi<q.size();qi++){\n            int l=q[qi][0],r=q[qi][1],v=q[qi][2];\n            for(int i=l;i<=r;i++){\n                state[i]|=(state[i]<<v);\n                for(int j=nums[i]+1;j<1001;j++) state[i].reset(j);\n            }\n            bool zeroAll=true;\n            for(int i=0;i<n;i++){\n                if(!state[i].test(nums[i])){\n                    zeroAll=false;\n                    break;\n                }\n            }\n            if(zeroAll) return qi+1;\n        }\n        return -1;\n    }\n};\n","author":"aniruddhapande","submissionId":"1575235165"},[{"id":"1067","similarity":0.9322033898305084,"totOverlap":165,"longestOverlap":41}]],"1538":[{"id":"1538","fileName":"1575235360.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m=queries.size();\n        vector<bitset<1001>> dp(n);\n\n      \n        for (int j = 0; j < n; j++) {\n            dp[j].reset();\n            dp[j].set(0);\n        }\n\n       \n        bool zero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                zero = false;\n                break;\n            }\n        }\n\n        if (zero) return 0;\n\n       \n        for (int k = 0; k < m; k++) {\n            int le = queries[k][0];\n            int ri = queries[k][1];\n            int val = queries[k][2];\n\n            for (int j = le; j <= ri; j++) {\n                dp[j] |= (dp[j] << val);\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp[j].reset(pos);\n                }\n            }\n\n            \n            bool valid = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j].test(nums[j])) {\n                    valid = false;\n                    break;\n                }\n            }\n\n            if (valid) return k + 1;\n        }\n\n        return -1;\n    }\n};\n\n","author":"bigamjaan","submissionId":"1575235360"},[{"id":"1106","similarity":0.8701923076923077,"totOverlap":181,"longestOverlap":48}]]},{"907":[{"id":"907","fileName":"1575201413.txt","sourceCode":"class Solution {\npublic:\n    bool check(vector<int>& nums, vector<vector<int>>& queries, int qidx, int n, int nmax) {\n        vector<vector<int>> ops(n+1);\n        for(int i = 0; i <= qidx; i++) {\n            vector<int> q = queries[i];\n            ops[q[0]].push_back(q[2]);\n            ops[q[1]+1].push_back(-q[2]);\n        }\n        map<int, int> left;\n        for(int i = 0 ; i < n; i++) {\n            for(int q : ops[i]) {\n                if(q > 0) {\n                    left[q] += 1;\n                } else {\n                    left[-q] -= 1;\n                }\n            }\n            // for(auto ele : left) {\n            //     cout << ele.first<< \" \" << ele.second << endl;\n            // }\n            if(nums[i] == 0) continue;\n            vector<bool> avail(nmax + 1, false);\n            avail[0] = true;\n            for(auto kv : left) {\n                int k = kv.first;\n                int v = kv.second;\n                for(int j = 0; j < v; j++) {\n                    vector<bool> newavail = avail;\n                    for(int num = 0; num <= nmax; num++) {\n                        if(!avail[num]) continue;\n                        int newn = num + k;\n                        if(newn <= nmax){\n                            newavail[newn] = true;\n                            // cout << newn << endl;\n                        }\n                    }\n                    avail = newavail;\n                    if(avail[nums[i]]) break;\n                }\n            }\n            if(!avail[nums[i]]) return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();  \n        int qmax = queries.size();\n        int nmax = 0;\n        for(int num : nums) {\n            nmax = max(nmax, num);\n        }\n        if(nmax == 0) return 0; \n        // cout << nmax << endl;\n        bool resp = check(nums, queries, qmax-1, n, nmax);\n        if(!resp) return -1;\n        resp = check(nums, queries, 0, n, nmax);\n        if(resp) return 1;\n        int le = 0;\n        int ri = qmax - 1;\n        while(le < ri - 1) {\n            int mid = (le + ri) / 2;\n            bool r = check(nums, queries, mid, n, nmax);\n            if(r){\n                ri = mid;\n            } else {\n                le = mid;\n            }\n        }\n        return ri + 1;\n    }\n};","author":"Aster233","submissionId":"1575201413"},[]]},{"908":[{"id":"908","fileName":"1575201595.txt","sourceCode":"class Solution {\npublic:\n    #define f first\n    #define s second\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        \n        vector<pair<int,int>> adj[10];\n        \n        for(int  i = 0 ;i<q.size();i++ )\n        {\n            int l = q[i][0]  , r = q[i][1] , val = q[i][2];\n            \n            for(int j = l ;j<=r;j++)\n            {\n                adj[j].push_back({val,i+1});\n            }\n        }\n        \n        int ans = 0;\n        for(int i = 0 ; i<nums.size();i++)\n        {\n            if(nums[i] == 0 ) continue;\n            \n            \n            vector<int> dp( nums[i]+1 ,0  );\n            int ok =0;\n            dp[0] = 1; \n            \n            \n            for(int j = 0;j<adj[i].size();j++)\n            {\n                vector<int> ndp( nums[i]+1 ,0  );\n                for(int k = 0 ;k<= nums[i] ;k++)\n                {\n                    if( k >= adj[i][j].f )\n                    {\n                        ndp[k] = dp[k] | dp[ k -adj[i][j].f ];\n                    }\n                    else ndp[k] = dp[k];\n                }\n                \n                dp = ndp;\n            \n                \n                if(dp[nums[i]])\n                {\n                    ans = max(ans , adj[i][j].s);\n                    ok = 1;\n                    break;\n                }\n            }\n            \n            if(ok==0)\n            {\n                return -1;\n            }\n        }\n        \n        return ans;\n    }\n};","author":"ak_fo7","submissionId":"1575201595"},[]]},{"909":[{"id":"909","fileName":"1575201735.txt","sourceCode":"class Solution {\npublic:\n    bool target(int ind,int sum,vector<int>&arr,vector<vector<int>>&dp){\n        if(sum==0)return true;\n        if(ind==0){\n            return sum==arr[ind];\n        }\n        if(dp[ind][sum]!=-1)return dp[ind][sum];\n        bool take=false;\n        if(sum-arr[ind]>=0)take=target(ind-1,sum-arr[ind],arr,dp);\n        bool nottake=target(ind-1,sum,arr,dp);\n        return dp[ind][sum]=take||nottake;\n    }\n    bool check(int mid,vector<vector<int>>&pre,vector<int>&nums){\n        int n=nums.size();\n        // for(int i=1;i<n;i++){\n        //     update[i]+=update[i-1];\n        // }\n        vector<vector<int>>val(mid);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<mid;j++){\n                val[i].push_back(pre[i][j]);\n            }\n        }\n        for(int i=0;i<n;i++){\n            vector<vector<int>>dp(mid,vector<int>(nums[i]+1,-1));\n            if(!target(mid-1,nums[i],nums,dp))return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(),k=queries.size();\n        vector<vector<int>>pre(k,vector<int>(n+1,0));\n        vector<bitset<1001>>dp(n);\n        bool flag=true;\n        for(auto x:nums){\n            if(x!=0){\n                flag=false;\n                break;\n            }\n        }\n        if(flag)return 0;\n        // pre[0][queries[0][0]]-=queries[0][2];\n        // pre[0][queries[0][1]+1]+=queries[0][2];\n        // for(int i=1;i<k;i++){\n        //     pre[i]=pre[i-1];\n        //     pre[i][queries[i][0]]-=queries[i][2];\n        //     pre[i][queries[i][1]+1]+=queries[i][2];\n        // }\n        for(int j=0;j<n;j++){\n            dp[j].reset();\n            dp[j].set(0,true);\n        }\n        // int s=1,e=k,ans=-1;\n        // while(s<=e){\n        //     int mid=s+(e-s)/2;\n        //     if(check(mid,pre,nums)){\n        //         ans=mid;\n        //         e=mid-1;\n        //     }\n        //     else s=mid+1;\n        // }\n        for(int i=0;i<k;i++){\n            bool flag2=true;\n            for(int j=queries[i][0];j<=queries[i][1];j++){\n                dp[j]|=(dp[j]<<queries[i][2]);\n                for(int a=nums[j]+1;a<1001;a++){\n                    dp[j].reset(a);\n                }\n            }\n            for(int j=0;j<n;j++){\n                if(!dp[j].test(nums[j])){\n                    flag2=false;\n                    break;\n                }\n            }\n            if(flag2)return i+1;\n            \n        }\n        return -1;\n\n    }\n};","author":"Divyansh Saharan","submissionId":"1575201735"},[]]},{"910":[{"id":"910","fileName":"1575201625.txt","sourceCode":"#define ll long long\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& v, vector<vector<int>>& q) {\n        ll n = v.size();\n        ll m = q.size();\n        \n        auto isposs = [&](ll idx) -> bool {\n            \n            vector< vector<int> > whatAll(n);\n            for(int i=0;i<=idx;i++){\n                vector<int> x = q[i];\n                int l = x[0];\n                int r = x[1];\n                int val = x[2];\n                for(int i=l;i<=r;i++) whatAll[i].push_back(val);\n            }\n            \n            auto canSum = [&](ll s, vector<int> &op) -> bool {\n                bitset<10001> dp;\n                dp[0] = 1;\n                for (auto &x:op) dp |= (dp << x);\n                return dp[s];\n            };\n            \n            bool ok = true;\n            for(int i=0;i<n;i++) ok &= canSum(v[i], whatAll[i]);\n            return ok;\n        };\n        \n        bool allZero = true;\n        for(auto &x:v) allZero &= (x == 0);\n        if(allZero) return 0;\n        \n        int l = 0, r = m-1;\n        while(l+1<r)\n        {\n            int md = (r-l)/2 + l;\n            if( isposs(md) ) r = md;\n            else l = md;\n        }\n        \n        int ans = -1;\n        if( isposs(r) ) ans = r;\n        if( isposs(l) ) ans = l;\n        return (ans != -1 ? ans + 1 : ans);\n    }\n};","author":"e7F9OC79Eg","submissionId":"1575201625"},[]]},{"911":[{"id":"911","fileName":"1575201863.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        int ct = 0;\n        vector<int> hash(n, 0);\n        int prev=0;\n        for (int i = 0; i < n; i++) {\n            if (hash[i]) continue;\n            if (nums[i] == 0) continue;\n            \n            ct++;\n            vector<int> temp;\n            \n            for (int j = 0; j < q; j++) {\n                if (queries[j][0] <= i && queries[j][1] >= i)\n                    temp.push_back(queries[j][2]);\n            \n            \n            int m = temp.size();\n            sort(temp.begin(), temp.end());\n            \n            vector<bool> dp(nums[i] + 1, false);\n            dp[0] = true;\n            \n            for (int j = 0; j < m; j++) {\n                for (int val = nums[i]; val >= temp[j]; val--) {\n                    if (dp[val - temp[j]])\n                        dp[val] = true;\n                }\n            }\n            \n            if (dp[nums[i]]) {\n                hash[i] = 1;\n                prev=max(prev,j+1);\n                break;\n            }\n        }\n        }\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != 0 && !hash[i])\n                return -1;\n        }\n        \n        return prev;\n    }\n};","author":"Lakshya Shukla","submissionId":"1575201863"},[]]},{"912":[{"id":"912","fileName":"1575201945.txt","sourceCode":"class Solution {\npublic:\nint dp[11][1001][1001];\nint solve(int id,vector<int>&nums,int pos,vector<vector<int>>& queries,int rem){\n    if(rem==0) return pos;\n    if(pos==queries.size()){\n          if(rem==0) return 0;\n          return INT_MAX;\n     }\n     if(dp[id][pos][rem]!=-1) return dp[id][pos][rem];\n      int pick=INT_MAX;\n    int notPick=solve(id,nums,pos+1,queries,rem);\n     if(id<=queries[pos][1] and id>=queries[pos][0] and rem>=queries[pos][2])        pick=solve(id,nums,pos+1,queries,rem-queries[pos][2]);\n     return dp[id][pos][rem]=min(pick,notPick);\n}\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n          memset(dp,-1,sizeof(dp));\n          int maxi=INT_MIN;\n         for(int id=0;id<nums.size();id++){\n              maxi=max(maxi,solve(id,nums,0,queries,nums[id]));\n         }\n           return maxi==INT_MAX?-1:maxi;\n    }\n};","author":"Ravikant Yadav","submissionId":"1575201945"},[]]},{"913":[{"id":"913","fileName":"1575201795.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        bool already = true;\n        for (int x : nums) {\n            if (x != 0) { \n                already = false; \n                break;\n            }\n        }\n        if (already) return 0;\n        \n        vector<vector<pair<int, int>>> affects(n); // idx -> qidx, val\n        for (int j = 0; j < m; j++) {\n            int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n            for (int i = l; i <= r; i++) {\n                affects[i].push_back({j, val});\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            sort(affects[i].begin(), affects[i].end(), [](auto &a, auto &b) {\n                return a.first < b.first;\n            });\n        }\n\n        auto OK = [&](int k) -> bool {\n            for (int i = 0; i < n; i++) {\n                int target = nums[i];\n                if (target == 0) continue;\n                \n                bitset<1100> dp;\n                dp[0] = 1;\n                for (auto [qid, val] : affects[i]) {\n                    if (qid + 1 > k) break;\n                    dp |= (dp << val);\n                    if (dp[target]) break;\n                }\n                if (!dp[target]) return false;\n            }\n            return true;\n        };\n        int l = 1, r = m;\n        while (l < r) {\n            int mid = l + r >> 1;\n            if (OK(mid))\n                r = mid;\n            else \n                l = mid + 1;\n        }\n        return OK(l) ? l : -1;\n    }\n};","author":"wayjiang","submissionId":"1575201795"},[]]},{"914":[{"id":"914","fileName":"1575202065.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<unordered_set<int>> v(nums.size(), {0});\n        vector<int> ans(nums.size(), -1);\n        for(int i = 0; i < queries.size(); i++)\n        {\n            for(int j = queries[i][0]; j <= queries[i][1]; j++)\n            {\n                if(nums[j]==0)\n                {\n                    ans[j]=0;\n                    continue;\n                }\n                vector<int> arr;\n                for(int cur: v[j])\n                    arr.push_back(cur);\n                for(int cur: arr)\n                    v[j].insert(cur+queries[i][2]);\n                if(v[j].count(nums[j]) && ans[j]==-1)\n                {\n                    ans[j] = i+1;\n                }\n                    \n            }\n        }\n        int ret = 0;\n        for(int cur: ans)\n        {\n            if(cur==-1)\n                return -1;\n            ret = max(ret, cur);\n        }\n        return ret;\n    }\n};","author":"ycyubill","submissionId":"1575202065"},[]]},{"915":[{"id":"915","fileName":"1575201968.txt","sourceCode":"class Solution {\npublic:\n    vector<vector<vector<int>>> dp;\n    int solve(int curr,int idx, vector<vector<int>>& queries, int n,int i){\n        if(curr==0) return i;\n        if(i>=n) return INT_MAX;\n\n        if (dp[idx][curr][i] != -1) return dp[idx][curr][i];\n\n        int notPick = solve(curr,idx,queries,n,i+1);\n        int pick = INT_MAX;\n        if(idx>=queries[i][0] && idx<=queries[i][1] && curr >= queries[i][2]) pick = solve(curr-queries[i][2],idx,queries,n,i+1);\n\n        return dp[idx][curr][i] = min(pick,notPick);\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n =nums.size(),q = queries.size();\n        int ans = 0;\n        int maxVal = *max_element(nums.begin(), nums.end());\n        dp.resize(n, vector<vector<int>>(maxVal + 1, vector<int>(q + 1, -1)));\n        for(int i=0;i<n;i++){\n            int k = solve(nums[i],i,queries,q,0);\n            if(k==INT_MAX) return -1;\n            ans = max(k,ans);\n        }\n        return ans;\n    }\n};","author":"Nakul","submissionId":"1575201968"},[]]},{"916":[{"id":"916","fileName":"1575202171.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        nazeeb = [set() for _ in range(n)]\n        for j in range(n):\n            nazeeb[j].add(0)\n        xo = all(x == 0 for x in nums)\n        if xo:\n            return 0\n        for k, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                ns = set()\n                for val in nazeeb[j]:\n                    ns.add(val + v)\n                nazeeb[j].update(ns)\n                nazeeb[j] = {x for x in nazeeb[j] if x <= nums[j]}\n            ala = all(nums[j] in nazeeb[j] for j in range(n))\n            if ala:\n                return k + 1\n        return -1","author":"MAHAMMAD NAZEEB SHAIK","submissionId":"1575202171"},[]]},{"917":[{"id":"917","fileName":"1575201703.txt","sourceCode":"int dp[1010][1010];\n\nclass Solution \n{\n    int f(int a_idx, int sum, int q_idx, vector<vector<int>>& queries) \n    {\n        if(sum == 0) return q_idx;\n        if(q_idx == queries.size()) return 1e5;\n\n        int &ans = dp[sum][q_idx]; if(ans != -1) return ans;\n        \n        ans = f(a_idx, sum, q_idx + 1, queries);\n\n        if(queries[q_idx][0] <= a_idx and queries[q_idx][1] >=  a_idx and queries[q_idx][2] <= sum)\n        {\n            ans = min(ans, f(a_idx, sum - queries[q_idx][2], q_idx + 1, queries));\n        }\n\n        return ans;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), ans = 0;\n        for(int i = 0; i < n; ++i)\n        {\n            for(int j = 0; j <= nums[i]; ++j)\n            {\n                for(int k = 0; k <= queries.size(); ++k)\n                {\n                    dp[j][k] = -1;\n                }\n            }\n\n            ans = max(ans, f(i, nums[i], 0, queries));\n        }\n        return ans > queries.size() ? -1 : ans;\n    }\n};","author":"Dhruv Pasricha","submissionId":"1575201703"},[]]},{"918":[{"id":"918","fileName":"1575202152.txt","sourceCode":"#include <vector>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& n,vector<vector<int>>& q){\n        int s=n.size();\n        vector<int> m(s,-1);\n        for(int j=0;j<s;++j){\n            int t=n[j];\n            if(t==0)\n            {\n                m[j]=-1;\n                continue;\n            }\n            vector<int> r;\n            for(int i=0;i<q.size();++i){\n                int l=q[i][0],r1=q[i][1];\n                if(l<=j&&j<=r1)r.push_back(i);\n            }\n            unordered_set<int> p;\n            p.insert(0);\n            bool f=false;\n            for(int i:r){\n                int v=q[i][2];\n                unordered_set<int> n_p=p;\n                bool b=false;\n                for(int s1:p){\n                    int n_s=s1+v;\n                    if(n_s==t){\n                        m[j]=i;\n                        f=true;\n                        b=true;\n                        break;\n                    }\n                    else if(n_s<t)n_p.insert(n_s);\n                }\n                if(b)break;\n                p=n_p;\n            }\n            if(!f){return -1;}\n        }\n        int mx=-1;\n        for(int j=0;j<s;++j){\n            if(n[j]!=0)mx=max(mx,m[j]);\n        }\n        if(mx==-1){\n            return 0;\n        }\n        else{\n            return mx+1;\n        }\n    }\n};","author":"YUVAL BHAYANI","submissionId":"1575202152"},[]]},{"919":[{"id":"919","fileName":"1575202097.txt","sourceCode":"\n// General overload for containers (vector, set, deque, map, etc.)\ntemplate <typename T_container,\n          typename = typename enable_if<!is_same<T_container, string>::value,\n                                        typename T_container::value_type>::type>\nostream& operator<<(ostream& os, const T_container& container) {\n    os << '{';\n    string sep;\n    for (const auto& element : container)\n        os << sep << element, sep = \", \";\n    return os << '}';\n}\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n\n// shortcut type\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\n\n// Constants\nconst int MOD = 1e9 + 7;\n\nclass Solution {\nbool f(vector<int>& nums, int x) {\n   vector<bool> dp(x + 1, false);\n    dp[0] = true;\n\n    for (int num : nums) {\n        for (int sum = x; sum >= num; sum--) {\n            dp[sum] = dp[sum] || dp[sum - num];\n        }\n    }\n\n    return dp[x];\n}\npublic:\n    int minZeroArray(vector<int>& v, vector<vector<int>>& q) {\n        bool t = 1;\n        for (auto& i : v) {\n            if (i > 0) {\n                t = 0;\n                break;\n            }\n        }\n        if (t)\n            return 0;\n        int n = v.size();\n        \n        vector<vector<int>>tem(n);\n       for(int l=0;l<q.size();l++){\n           for(int i=0;i<n;i++){\n               if(i>=q[l][0] and i<=q[l][1])tem[i].push_back(q[l][2]);\n           }\n           bool t=1;\n           for(int i=0;i<n;i++){\n               if(!f(tem[i],v[i])){\n                   t=0;\n                   break;\n               }\n           }\n           if(t)return l+1;\n           \n       }\n         \n\n        return -1;\n    }\n};","author":"Sk Najir","submissionId":"1575202097"},[]]},{"920":[{"id":"920","fileName":"1575202298.txt","sourceCode":"class Solution {\npublic:\n    vector<vector<int>> dp;\n\n    bool check(int x, vector<int>& nums, int i) {\n        if (x == 0) {\n            return true;\n        }\n        if (i == nums.size()) {\n            return false;\n        }\n        if(dp[i][x]!=-1)\n        {\n            return dp[i][x];\n        }\n        bool ret = false;\n        for (int j = 0; !ret && j <= nums[i]&&x-j*i>=0; j++) {\n            ret = ret || check(x - j * i, nums, i + 1);\n        }\n        return dp[i][x] = ret;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int ret = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            vector<int> vals(11, 0);\n            int sum = 0, k;\n            for (k = 0; nums[i] != 0 && k < q.size(); k++) {\n                if (q[k][0] <= i && i <= q[k][1]) {\n                    vals[q[k][2]]++;\n                    sum += q[k][2];\n                    if (sum >= nums[i]) {\n                        dp =\n                            vector<vector<int>>(11, vector<int>(nums[i] + 1,-1));\n                        if (check(nums[i], vals, 1)) {\n                            nums[i] = 0;\n                        }\n                    }\n                }\n            }\n            if (nums[i] != 0) {\n                return -1;\n            }\n            ret = max(ret, k);\n        }\n        return ret;\n    }\n};","author":"cvnpko","submissionId":"1575202298"},[]]},{"921":[{"id":"921","fileName":"1575202302.txt","sourceCode":"/*\na[i] -= x + y + z\n\n(x, cnt)\n\n*/\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& queries) {\n        int n = a.size();\n        int m = queries.size();\n\n        auto is = [&](array<int, 11> fr, int val) {\n            vector<int> dp(val + 1, 0);\n            dp[0] = 1;\n            // cout << \"val:: \" << val << endl;\n            for(int j = 1; j <= 10; j++) {\n                if(!fr[j]) continue;\n                // cout << \"j:: \" << j << \" fr:: \" << fr[j] << endl;\n                \n                    for(int i = val; i >= 0; i--) {\n                        for(int k = 1; k <= fr[j]; k++) {\n                        if(dp[i]) {\n                            if(i + j * k <= val) {\n                                // cout << \"i:: \" << i <<  \" i + j *k:: \"  << i + j*k << endl;\n                                dp[i + j * k] = 1;\n                            }\n                        }\n                    }\n                }\n            }\n            return dp[val];\n        };\n\n        auto okk = [&](int len) {\n            // cout << \"len:: \" << len << endl;\n            vector<array<int, 11>> pref(n);\n            for(int i = 0; i < len; i++) {\n                int l = queries[i][0];\n                int r = queries[i][1];\n                int val = queries[i][2];\n                pref[l][val] += 1;\n                if(r + 1 < n) pref[r + 1][val] -= 1;\n            }\n            for(int i = 1; i < n; i++) {\n                for(int j = 0; j < 11; j++) {\n                    pref[i][j] += pref[i - 1][j];\n                }\n            }\n            for(int i = 0; i < n; i++) {\n                array<int, 11> fr = pref[i];\n                if(!is(fr, a[i])) return false;\n            }\n            return true;\n        };\n\n\n        \n        int l = 0, r = m, res = -1;\n        while(l <= r) {\n            int mid = (l + r) / 2;\n            if(okk(mid)) {\n                res = mid;\n                r = mid - 1;\n            }else {\n                l = mid + 1;\n            }\n        }\n        return res;\n    }\n};","author":"abhishek soni","submissionId":"1575202302"},[]]},{"922":[{"id":"922","fileName":"1575202577.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = sum(num > 0 for num in nums)\n        if m == 0: return 0\n        ans = [-1] * n\n        for i, num in enumerate(nums):\n            if num == 0: \n                ans[i] = 0\n                continue\n            seen = set([num])\n            for k, (l, r, val) in enumerate(queries):\n                if not l <= i <= r and num >= val: continue\n                if val in seen:\n                    ans[i] = k + 1\n                    break\n                for elem in seen.copy():\n                    if elem - val > 0:\n                        seen.add(elem - val)\n        return -1 if -1 in ans else max(ans)","author":"bambi","submissionId":"1575202577"},[]]},{"924":[{"id":"924","fileName":"1575202306.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        vector<int> minRequired(n, 1e9); // Stores the minimum query index required to make nums[i] zero.\n\n        // Count initial zeros\n        int zeroCount = count(nums.begin(), nums.end(), 0);\n        if (zeroCount == n) return 0; // If all elements are already zero, return 0.\n\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) {\n                minRequired[i] = 0;\n                continue;\n            }\n\n            vector<pair<int, int>> choice; // Stores {queryIndex, x}\n            for (int j = 0; j < q; j++) {\n                int l = queries[j][0], r = queries[j][1], x = queries[j][2];\n                if (l <= i && i <= r) {\n                    choice.push_back({j + 1, x}); // Store (1-based index, value)\n                }\n            }\n\n            int c = choice.size();\n            if (c == 0) continue; // If no query affects nums[i], skip.\n\n            vector<vector<int>> nxtIndex(c + 1, vector<int>(1001, 1e9));\n\n            for (int level = c - 1; level >= 0; level--) {\n                for (int value = 0; value <= 1000; value++) {\n                    nxtIndex[level][value] = 1e9;\n                    int x = choice[level].second;\n\n                    if (value == 0 || value == x) {\n                        nxtIndex[level][value] = level;\n                        continue;\n                    }\n\n                    // Carry forward the previous best index\n                    if (level + 1 < c) {\n                        nxtIndex[level][value] = nxtIndex[level + 1][value];\n                    }\n\n                    // Reduce value using x\n                    if (level + 1 < c && value - x >= 0) {\n                        nxtIndex[level][value] = min(nxtIndex[level][value], nxtIndex[level + 1][value - x]);\n                    }\n                }\n            }\n\n            int finalChoice = nxtIndex[0][nums[i]];\n            if (finalChoice != 1e9) {\n                minRequired[i] = choice[finalChoice].first;\n            }\n        }\n\n        int ans = *max_element(minRequired.begin(), minRequired.end());\n        return (ans == 1e9) ? -1 : ans;\n    }\n};","author":"BodaciousLord007","submissionId":"1575202306"},[]]},{"925":[{"id":"925","fileName":"1575202550.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, m = len(nums), len(queries)\n        idx_coins = [[] for _ in range(n)]\n        for j, (l, r, v) in enumerate(queries):\n            for i in range(l, r + 1):\n                idx_coins[i].append((j, v))\n        for i in range(n):\n            idx_coins[i].sort(key=lambda x: x[1])\n        def can_sum(i, k):\n            target = nums[i]\n            dp = [True] + [False] * target\n            for j, coin in idx_coins[i]:\n                if j < k:\n                    for s in range(target, coin - 1, -1):\n                        if dp[s - coin]:\n                            dp[s] = True\n            return dp[target]\n        thresholds = [0] * n\n        for i in range(n):\n            if nums[i] == 0:\n                continue\n            lo, hi, found = 0, m + 1, None\n            while lo < hi:\n                mid = (lo + hi) // 2\n                if can_sum(i, mid):\n                    found = mid\n                    hi = mid\n                else:\n                    lo = mid + 1\n            if found is None:\n                return -1\n            thresholds[i] = found\n        return max(thresholds)\n        ","author":"Aditya_Kathpalia","submissionId":"1575202550"},[]]},{"926":[{"id":"926","fileName":"1575202498.txt","sourceCode":"class Solution {\npublic:\n    int dp[1001][1001];\n\n    int solve(int i, int target, vector<int>& a, int n) {\n        if (target == 0) return i;\n        if (i == n) return 1e9;\n        if (dp[i][target] != -1) return dp[i][target];\n\n        int notTake = solve(i + 1, target, a, n);\n        int take = 1e9;\n        if (target >= a[i]) {\n            take = solve(i + 1, target - a[i], a, n);\n        }\n\n        return dp[i][target] = min(notTake, take);\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size();\n        vector<int> miniQ;\n\n        for (int i = 0; i < n; i++) {\n            vector<int> temp, tt;\n            for (int j = 0; j < q; j++) {\n                if (i >= queries[j][0] && i <= queries[j][1]) {\n                    temp.push_back(queries[j][2]);\n                    tt.push_back(j);\n                }\n            }\n\n            memset(dp, -1, sizeof(dp));\n            int ans = solve(0, nums[i], temp, temp.size());\n            if (ans >= 1e9) return -1;\n            if(ans == 0){\n                miniQ.push_back(0);\n            }else{\n                miniQ.push_back(tt[ans-1]+1);\n            }    \n        }\n\n        return *max_element(miniQ.begin(), miniQ.end());\n    }\n};\n","author":"ayman444","submissionId":"1575202498"},[]]},{"927":[{"id":"927","fileName":"1575202598.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] que) {\n        int n = nums.length;\n        int m = que.length;\n\n        List<BitSet> dp = new ArrayList<>();\n        for (int j = 0; j < n; j++) {\n            BitSet bs = new BitSet(1001);\n            bs.set(0);\n            dp.add(bs);\n        }\n\n        boolean fl = true;\n        for (int num : nums) {\n            if (num != 0) {\n                fl = false;\n                break;\n            }\n        }\n\n        if (fl) return 0;\n\n        for (int k = 0; k < m; k++) {\n            int l = que[k][0];\n            int r = que[k][1];\n            int v = que[k][2];\n\n            for (int j = l; j <= r; j++) {\n                BitSet bit = new BitSet(1001);\n                BitSet curr = dp.get(j);\n                for (int pos = curr.nextSetBit(0); pos >= 0; pos = curr.nextSetBit(pos + 1)) {\n                    if (pos + v < 1001) {\n                        bit.set(pos + v);\n                    }\n                }\n                curr.or(bit);\n\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    curr.clear(pos);\n                }\n            }\n\n            boolean flag = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp.get(j).get(nums[j])) {\n                    flag = false;\n                    break;\n                }\n            }\n\n            if (flag) return k + 1;\n        }\n\n        return -1;\n    }\n}\n","author":"Yash Jaiswal","submissionId":"1575202598"},[]]},{"928":[{"id":"928","fileName":"1575203016.txt","sourceCode":"class Solution {\npublic:\nint n,q;\nbitset<1001> dp[1001];\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries)\n    {\n        int n=nums.size();\n        int q=queries.size();\n        for(int i=0;i<n;i++)\n        {\n            dp[i]=0;\n            dp[i][0]=1;\n        }\n        bool shunya=true;\n        for(int i=0;i<n;i++)\n        {\n            shunya&= nums[i]==0;\n        }\n        if(shunya)\n        return 0;\n        for(int k=0;k<q;k++)\n        {\n            int left=queries[k][0];\n            int right=queries[k][1];\n            int value=queries[k][2];\n            for(int i= left ;i <=right; i++)\n            {\n                dp[i] |= (dp[i]<< value);\n                bitset<1001> mask;\n                mask.set();\n                mask>>=(1001 -(nums[i] +1));\n                dp[i ]&= mask;\n            }\n            bool hua=true;\n            for(int j=0;j<n;j++)\n            {\n                hua &= dp[j][nums[j]]!=0;\n            }\n            if(hua)\n            return k+1;\n        }\n        return -1;\n    }\n};","author":"Lokesh_Mehar","submissionId":"1575203016"},[]]},{"929":[{"id":"929","fileName":"1575202813.txt","sourceCode":"class Solution {\npublic:\n    bool possible (vector<int>& nums, vector<vector<int>>& q, int k){\n        int n = nums.size();\n        vector<int> diff (n+1, 0);\n        for (int i = 0; i < k; i++) {\n            int start = q[i][0], end = q[i][1], val = q[i][2];\n            diff[start] += val;\n            diff[end + 1] -= val;\n        }\n        vector <int> app (n, 0);\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += diff[i];\n            app[i] = sum;\n        }\n        for (int i = 0; i < n; i++) {\n            if (app[i] < nums[i]) return false; \n            int extra = app[i] - nums[i];\n            if (extra > 0) { \n                vector <bool> dp (nums[i] + 1, false);\n                dp[0] = true; \n                for (int j = 0; j < k; j++) {\n                    if (q[j][0] <= i && q[j][1] >= i) {\n                        int val = q[j][2];\n                        for (int k = nums[i]; k >= val; k--) {\n                            dp[k] = dp[k] || dp[k - val];\n                        }\n                    }\n                }\n                if (!dp[nums[i]]) return false; \n            }\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size(), l = 0, r = q.size(); \n        if (!possible (nums, q, r)) return -1; \n        while (l <= r){\n            int mid = l + (r - l) / 2; \n            if (possible (nums, q, mid)) r = mid - 1; \n            else l = mid + 1; \n        }\n        return l; \n    }\n};","author":"PRATBAN11","submissionId":"1575202813"},[]]},{"930":[{"id":"930","fileName":"1575202949.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        const int n = nums.size();\n        const int K = queries.size();\n        vector<vector<int>> dp(n, vector<int>(1001));\n        for (int i = 0; i < n; ++i)\n            dp[i][nums[i]] = 1;\n        if (accumulate(begin(nums), end(nums), 0) == 0) return 0;\n        for (int k = 0; k < K; ++k) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int v = queries[k][2];\n            for (int i = l; i <= r; ++i)\n                for (int j = 0; j <= 1000 - v; ++j)\n                    if (dp[i][j + v]) dp[i][j] = 1;\n            bool found = true;\n            for (int i = 0; i < n; ++i)\n                if (!dp[i][0]) found = false;\n            if (found) return k + 1;\n        }\n        return -1;\n    }\n};","author":"Huahua","submissionId":"1575202949"},[]]},{"931":[{"id":"931","fileName":"1575202933.txt","sourceCode":"class Solution:\n    def initializeBitsets(self, nums):\n        bitsets = [set() for _ in nums]\n        for bitset in bitsets:\n            bitset.add(0)\n        return bitsets\n\n    def checkAllZeros(self, nums):\n        return all(num == 0 for num in nums)\n\n    def applyQuery(self, bitsets, left, right, increment, nums):\n        for index in range(left, right + 1):\n            updatedSet = {value + increment for value in bitsets[index]}\n            bitsets[index].update(updatedSet)\n            bitsets[index] = {value for value in bitsets[index] if value <= 1000}\n\n    def checkAllAchieved(self, bitsets, nums):\n        return all(num in bitset for bitset, num in zip(bitsets, nums))\n\n    def minZeroArray(self, nums, queries):\n        if self.checkAllZeros(nums):\n            return 0\n\n        bitsets = self.initializeBitsets(nums)\n\n        for queryIndex, (left, right, increment) in enumerate(queries):\n            self.applyQuery(bitsets, left, right, increment, nums)\n\n            if self.checkAllAchieved(bitsets, nums):\n                return queryIndex + 1\n\n        return -1","author":"fEqwiiMfze","submissionId":"1575202933"},[]]},{"932":[{"id":"932","fileName":"1575203499.txt","sourceCode":"class Solution {\nint f(int ind, vector<vector<int>> &queries, int sum, int i, vector<int> &nums, vector<unordered_map<int, int>> &dp)\n{\n    if(sum == 0) return ind;\n    if(ind == queries.size()) return INT_MAX;\n    if(dp[ind].find(sum) != dp[ind].end()) return dp[ind][sum];\n    int ans = f(ind + 1, queries, sum, i, nums, dp);\n    if(sum >= queries[ind][2] && queries[ind][0] <= i && i <= queries[ind][1])\n    {\n        ans = min(ans, f(ind + 1, queries, sum - queries[ind][2], i, nums, dp));\n    }\n    return dp[ind][sum] = ans;\n}\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\n        int ans = -1;\n        \n        for(int i = 0; i < nums.size(); i++)\n            {\n                vector<unordered_map<int, int>> dp(queries.size() + 1);\n                int x  =f(0, queries, nums[i], i, nums, dp);\n                if(x == INT_MAX) return -1;\n                ans = max(ans, x);\n            }\n        return ans;\n    }\n};","author":"Shadab Raza","submissionId":"1575203499"},[]]},{"933":[{"id":"933","fileName":"1575203732.txt","sourceCode":"vector<pair<int,int>>v[11];\nint dp[1002][1002];\nclass Solution {\npublic:\n    \n    void ssum(vector<int>&v, int s) {\n        int n=v.size();\n        //memset(dp,0,sizeof(dp));\n        for(int i=0;i<=n;i++) {\n            dp[i][0]=1;\n        }\n        for(int i=1;i<=n;i++) {\n            for(int j=1;j<=s;j++) {\n                if(v[i-1]>j) {\n                    dp[i][j]=dp[i-1][j];\n                } else {\n                    dp[i][j]=dp[i-1][j] || dp[i-1][j-v[i-1]];\n                }\n            }\n        }\n    }\n    \n    \n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        int j=0, c0=0;\n        for(int i=0;i<n;i++) v[i].clear();\n        for(vector<int>p: queries) {\n            int l=p[0], r=p[1], val=p[2];\n            for(int i=l;i<=r;i++) v[i].push_back({val, j});\n            j++;\n        }\n        for(int i: nums) {\n            c0+=(i==0);\n        }\n        \n        if(c0==n) return 0;\n        int re=-1;\n        \n        \n        for(int i=0;i<n;i++) {\n           int lo=0, hi=v[i].size()-1, ans=-1;\n            while(lo<=hi) {\n                int mi=(lo+hi)/2;\n                vector<int>tmp;\n                for(int j=0;j<=mi;j++) {\n                    tmp.push_back(v[i][j].first);\n                }\n                ssum(tmp, nums[i]);\n                if(dp[tmp.size()][nums[i]]) ans=v[i][mi].second, hi=mi-1;\n                else lo=mi+1;\n            }\n            if(ans==-1) return -1;\n            re=max(re, ans+1);\n        }\n        return re;\n        \n        \n        \n        \n    }\n};","author":"SIDDHARTH","submissionId":"1575203732"},[]]},{"934":[{"id":"934","fileName":"1575203950.txt","sourceCode":"class Solution {\n    vector<int> count;\n    int total(){\n        int sum = 0;\n        for(int i=1; i<=10; ++i)\n            sum += i*count[i];\n        return sum;\n    }\n    bool canCreate(int val){ // construct val by count\n        int sum = total();\n        if(sum < val) return false;\n        else if(sum == val) return true;\n        // use DP\n        vector<bool> dp(val + 1, false);\n        dp[0] = true; \n        for(int i = 1; i <= 10; ++i) {\n            int num = i, max_count = count[i];\n            vector<bool> new_dp = dp;\n            for (int remainder = 0; remainder < num; remainder++) {\n                deque<int> dq;\n                for (int j = remainder; j <= val; j += num) {\n                    if (!dq.empty() && j - dq.front() > max_count * num)\n                        dq.pop_front();\n                    \n                    if (dp[j])\n                        dq.push_back(j);\n                    \n                    if (!dq.empty())\n                        new_dp[j] = true;\n                }\n            }\n            dp = new_dp;\n        }\n        return dp[val];\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<vector<int>> minus(11);\n        count.resize(11,0); // 1~10\n        int indQ = 0;\n        for(int i=0; i<nums.size(); ++i){\n            for(auto i : minus[i]){\n                if(i < 0)\n                    count[-i]--;\n                else\n                    count[i]++;\n            }\n            int val = nums[i];\n            if(val == 0) continue;\n            // check if cur can form val\n            while(indQ < queries.size() && canCreate(val) == false){\n                // add queries[indQ]\n                if(queries[indQ][1] >= i){\n                    minus[queries[indQ][1]+1].push_back(-1*queries[indQ][2]);\n                    if(queries[indQ][0] <= i) count[queries[indQ][2]]++;\n                    else minus[queries[indQ][0]].push_back(queries[indQ][2]);\n                    \n                }\n                ++indQ;\n            }\n            if(canCreate(val) == false) return -1; // all use, still cannot\n        }\n        return indQ;\n    }\n};","author":"william6715","submissionId":"1575203950"},[]]},{"935":[{"id":"935","fileName":"1575203785.txt","sourceCode":"class Solution {\nprivate:\n    bool check(int mid, vector<int>& nums, vector<vector<int>>& q) {\n\n        int n = nums.size();\n        vector<vector<int>> key(n,vector<int>());\n\n        for (int i = 0; i < mid; i++) {\n\n            for (int k = q[i][0]; k <= q[i][1]; k++) {\n                key[k].push_back(q[i][2]);\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n\n            if (nums[i] == 0) continue;\n            \n            if (!isValid(nums[i],key[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    bool isValid(int target, vector<int>& nums) {\n        \n        int n = nums.size();\n        vector<bool> key(target+1,false); key[0] = true;\n\n        for (auto num : nums) {\n\n            for (int i = target-num; i >= 0; i--) {\n\n                if (key[i]) key[i+num] = true;\n            }\n        }\n\n        return key[target];\n    }\n\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\n        int ans = -1;\n        int low = 0; int high = queries.size();\n\n        while (low <= high) {\n\n            int mid = low + (high-low)/2;\n\n            if (check(mid,nums,queries)) {\n                ans = mid; high = mid-1;\n            } else {\n                low = mid+1;\n            }\n        }\n\n        return ans;\n    }\n};","author":"Aditya Ranjan","submissionId":"1575203785"},[]]},{"936":[{"id":"936","fileName":"1575203812.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        List<Set<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            res.add(new HashSet<>());\n            res.get(i).add(0);\n        }\n        boolean[] done = new boolean[nums.length];\n        int ct = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 0) {\n                done[i] = true;\n                ct++;\n            }\n        }\n        if (ct == nums.length) return 0;\n        \n        for (int i = 0; i < queries.length; i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                if (done[j]) continue;\n                Set<Integer> set = new HashSet<>();\n                for (Integer v : res.get(j)) {\n                    if (v + val == nums[j]) {\n                        done[j] = true;\n                        ct++;\n                        break;\n                    }\n                    set.add(v+val);\n                }\n                if (!done[j]) {\n                    res.get(j).addAll(set);\n                }\n            }\n            if (ct == nums.length) return i + 1;\n        }\n        return -1;\n    }\n}","author":"chaoyue2500","submissionId":"1575203812"},[]]},{"937":[{"id":"937","fileName":"1575203628.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    // find the min index to make target 0\n    vector<pair<int, int>> arr;// val, index\n    int target;\n    int dp[1001][1001];\n    int n;\n    int ans = INT_MAX / 2;\n    \n    // sum in target, ind in arr\n    int rec(int sum, int ind) {  // return min index\n        // if(ind >= arr.size()) {\n        //     if(sum == 0) {\n        //         return ;\n        //     } else {\n        //         return INT_MAX / 2;\n        //     }\n        // }\n        // auto [val, qidx] = arr[ind];\n        // if(sum == 0) {\n        //     return \n        // }\n        if(sum < 0 || (ind >= arr.size() && sum != 0)) {\n            return INT_MAX / 2;\n        }\n        int &ret = dp[sum][ind];\n        if(ret != -1) return ret;\n        // not found\n        \n        // not take\n        ret = rec(sum, ind + 1);\n        // take\n        auto [val, qidx] = arr[ind];\n        if(sum - val > 0) {\n            ret = min(ret, rec(sum - val, ind + 1));\n        } else if(sum - val == 0) {\n            ans = min(ans, qidx);\n            return ret = qidx;\n        }\n        return ret;\n    }\n    \n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {  // needs to be exactly\n        n = nums.size();\n        vector<vector<pair<int, int>>> decs(n);  // val, index\n        for(int i = 0; i < q.size(); ++i) {\n            int l = q[i][0], r = q[i][1], val = q[i][2];\n            for(int j = l; j <= r; ++j) {\n                decs[j].push_back({val, i});\n            }\n        }\n        \n        int ret = -1;\n        for(int i = 0; i < n; ++i) {\n            arr = decs[i];\n            target = nums[i];\n            memset(dp, -1, sizeof dp);\n            ans = INT_MAX / 2;\n            if(target == 0) ans = -1;\n            else rec(target, 0);\n            // if(ans != INT_MAX / 2) {\n                // ret = min(ret, i - ans + 1);\n            ret = max(ret, ans);\n            \n            // cout << ans << endl;\n            // }\n        }\n        \n        return ret >= INT_MAX / 2 ? -1 : (ret + 1);\n    }\n};","author":"gy3T3vtplO","submissionId":"1575203628"},[]]},{"938":[{"id":"938","fileName":"1575204136.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        if sum(nums) == 0:\n            return 0\n        sets = [set() for _ in range(n)]\n        for idx, (beg, end, val) in enumerate(queries):\n            for i in range(beg, end + 1):\n                delta = set()\n                delta.add(val)\n                for cand in sets[i]:\n                    delta.add(cand + val)\n                sets[i].update(delta)\n            # print(f'{sets}')\n            if all(cur == 0 or cur in sets[i] for i, cur in enumerate(nums)):\n                # print('-' * 60)\n                return idx + 1\n        # print('-' * 60)\n        return -1","author":"Hong Hu","submissionId":"1575204136"},[]]},{"939":[{"id":"939","fileName":"1575204295.txt","sourceCode":"class Solution {\nbool check(vector<int>&v,int target,int mid)\n{\n    vector<vector<int>>dp(mid+1,vector<int>(target+1));\n    for(int i=mid;i>=0;i--)\n        {\n            dp[i][0]=1;\n        }\n    for(int i=mid-1;i>=0;i--)\n        {\n            for(int j=1;j<=target;j++)\n                {\n                    dp[i][j]=dp[i+1][j];\n                    if(j-v[i]>=0)\n                        dp[i][j]=(dp[i][j]||dp[i+1][j-v[i]]);\n                }\n        }\n    return dp[0][target];\n}\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<vector<int>>v(nums.size());\n        for(int i=0;i<nums.size();i++)\n            {\n                for(int j=0;j<queries.size();j++)\n                    {\n                        if(queries[j][0]<=i&&queries[j][1]>=i)\n                        {\n                            v[i].push_back(queries[j][2]);\n                        }\n                        else \n                        {\n                            v[i].push_back(0);\n                        }\n                    }\n            }\n        // for(int i=0;i<nums.size();i++)\n        //     {\n        //         for(int j=0;j<v[i].size();j++)\n        //             {\n        //                 cout<<v[i][j]<<\" \";\n        //             }\n        //         cout<<endl;\n        //     }\n        int ans=-1;\n        for(int i=0;i<nums.size();i++)\n            {\n                int s=0,e=v[i].size(),mid,pre=-1;\n                while(s<=e)\n                    {\n                        mid=s+(e-s)/2;\n                        if(check(v[i],nums[i],mid))\n                        {\n                            \n                            pre=mid;\n                            e=mid-1;\n                        }\n                        else s=mid+1;\n                    }\n                if(pre==-1)return -1;\n                ans=max(ans,pre);\n            }\n        return ans;\n    }\n};","author":"omkar","submissionId":"1575204295"},[]]},{"940":[{"id":"940","fileName":"1575204475.txt","sourceCode":"#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n\n        vector<vector<bool>> store(n, vector<bool>(1001, false));\n        for (int j = 0; j < n; j++) {\n            store[j][0] = true;\n        }\n\n        int check1 = 1;\n        for (int j = 0; j < n; j++) {\n            if (nums[j] != 0) {\n                check1 = 0;\n                break;\n            }\n        }\n\n        if (check1) return 0;\n\n        for (int k = 0; k < queries.size(); k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n                vector<bool> temp = store[j];  \n                for (int pos = 1000 - v; pos >= 0; pos--) {\n                    if (store[j][pos]) {\n                        temp[pos + v] = true;\n                    }\n                }\n                store[j] = temp;\n\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    store[j][pos] = false;\n                }\n            }\n\n            int check2 = 1;\n            for (int j = 0; j < n; j++) {\n                if (!store[j][nums[j]]) {\n                    check2 = 0;\n                    break;\n                }\n            }\n\n            if (check2) return k + 1;\n        }\n\n        return -1;\n    }\n};\n","author":"piyushagarwal_55","submissionId":"1575204475"},[]]},{"941":[{"id":"941","fileName":"1575204498.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        if all(x == 0 for x in nums):\n            return 0\n        \n        sums = [0] * n\n        dp = []\n        \n        for i in range(n):\n            target = nums[i]\n            newdp = [False] * (target + 1)\n            newdp[0] = True\n            dp.append(newdp.copy())\n        \n        for j in range(len(queries)):\n            l, r, val = queries[j]\n            for i in range(l, r + 1):\n                if nums[i] == 0:\n                    continue\n                    \n                sums[i] += val\n                new_t = nums[i]\n                new_dp = [False] * (new_t + 1)\n                for s in range(new_t + 1):\n                    if dp[i][s]:\n                        new_dp[s] = True\n                        if s + val <= new_t:\n                            new_dp[s + val] = True\n                dp[i] = new_dp\n\n            total = True\n            for i in range(n):\n                if nums[i] == 0:\n                    continue\n                if sums[i] < nums[i]:\n                    total = False\n                    break\n                if not dp[i][nums[i]]:\n                    total = False\n                    break\n            if total:\n                return j + 1\n        \n        return -1","author":"Sahil Raut","submissionId":"1575204498"},[]]},{"942":[{"id":"942","fileName":"1575204610.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int sum = accumulate(nums.begin(), nums.end(), 0);\n        if (!sum) return 0;\n        const int n = nums.size();\n        const int m = queries.size();\n        vector<unordered_set<int>> potentials(n, {0});\n\n        vector<bool> done(n, false);\n        int all_done = 0;\n        for (int i = 0; i < m; ++i) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            for (int j = l; j <= r; ++j) {\n                if (done[j]) continue;\n                auto& p = potentials[j];\n                if (p.size() == 1) {\n                    p.insert(val);\n                } else {\n                    unordered_set<int> tmp = p;\n                    for (const int k : tmp) {\n                        if (k + val > 1000 || p.count(k + val)) continue;\n                        p.insert(k + val);\n                    }\n                }\n                if (p.count(nums[j])) {\n                    done[j] = true;\n                    all_done++;\n                }\n            }\n            if (all_done == n)\n                return i+1;\n        }\n        return -1;\n    }\n};","author":"HarleyLiu","submissionId":"1575204610"},[]]},{"943":[{"id":"943","fileName":"1575204329.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        \n        int res=-1;\n       \n       for(int i=0;i<nums.length;i++){\n            int dp[][]=new int[1001][1001];\n           \n           int val= dfs(i,queries,0,nums[i],dp);\n           if(val>queries.length){\n               return -1;\n           }\n           res=Math.max(val,res);\n       }\n        \n      return res;  \n    }\n    \n    public int dfs(int index,int queries[][],int j, int value,int dp[][]){\n        \n        if(j>=queries.length){\n            if(value==0){\n                return 0;\n            }\n            return 1;\n        }\n     //   System.out.println(j+\" \"+value);\n        if(value==0)\n            return 0;\n        \n        if(dp[j][value]!=0){\n            return dp[j][value];\n        }\n        \n        int ans=100000;\n        \n        for(int i=j;i<queries.length;i++){\n             int l= queries[i][0];\n            int r=queries[i][1];\n            int val= queries[i][2];\n            \n            \n            \n            if(l<=index && r>=index && value-val>=0){\n               ans=Math.min(ans,i-j+1+dfs(index,queries,i+1,value-val,dp));\n            }  \n            \n            \n            \n        }\n       // ans=Math.min(ans,1+dfs(index,queries,j+1,value,dp));\n        \n        return dp[j][value]=ans;\n        \n    }\n    \n}","author":"kishan963","submissionId":"1575204329"},[]]},{"944":[{"id":"944","fileName":"1575204662.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int result = 0;\n        for(int i = 0; i < nums.size(); i++) if(nums[i] > 0) {\n            vector<bool> exists(1001, false);\n            exists[0] = true;\n            int j;\n            for(j = 0; j < queries.size(); j++) if(queries[j][0] <= i && i <= queries[j][1]) {\n                for(int t = exists.size() - 1; t >= 0; t--)\n                    if(exists[t] && t + queries[j][2] < (int)exists.size())\n                        exists[t + queries[j][2]] = true;\n                if(exists[nums[i]]) break;\n            }\n            if(j >= queries.size()) return -1;\n            result = max(result, j + 1);\n        }\n        return result;\n    }\n};","author":"Ting","submissionId":"1575204662"},[]]},{"945":[{"id":"945","fileName":"1575204619.txt","sourceCode":"class Solution {\npublic:\n    bool possible(multiset<int>& st, int target) {\n        vector<int> temp;\n        for(auto i : st) temp.push_back(i);\n\n        const int n = temp.size();\n\n        vector<vector<bool>> dp(target + 1, vector<bool>(n + 1, false));\n        for(int i = 0; i <= n; i++) {\n            dp[target][i] = true;\n        }\n\n        for(int i = target - 1; i >= 0; i--) {\n            for(int j = n - 1; j >= 0; j--) {\n                if(i + temp[j] <= target) {\n                    dp[i][j] = dp[i][j] or dp[i + temp[j]][j + 1];\n                }\n                dp[i][j] = dp[i][j] or dp[i][j + 1];\n            }\n        }\n\n        return dp[0][0];\n    }\n    bool valid(vector<int>& nums, vector<vector<int>>& queries, int mid) {\n        const int n =  nums.size(), m = queries.size();\n        vector<vector<int>> add(n + 1);\n        vector<vector<int>> rem(n + 1);\n\n        for(int i = 0; i < mid; i++) {\n            int u = queries[i][0], v = queries[i][1], val = queries[i][2];\n            add[u].push_back(val);\n            rem[v + 1].push_back(val); \n        }\n\n        multiset<int> st;\n        \n        for(int i = 0; i < n; i++) {\n            if(!add[i].empty()) {\n                for(auto j : add[i]) st.insert(j);\n            }\n            if(!rem[i].empty()){\n                for(auto j : rem[i]) st.erase(st.find(j));\n            }\n            if(!possible(st, nums[i])) return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int lo = 0, hi = queries.size();\n        int ans = -1;\n\n        while(lo <= hi) {\n            int mid = (lo + hi)/2;\n\n            if(valid(nums, queries, mid)) {\n                ans = mid;\n                hi = mid - 1;\n            }\n            else {\n                lo = mid + 1;\n            }\n        }\n\n        return ans;\n    }\n};","author":"Yash151","submissionId":"1575204619"},[]]},{"946":[{"id":"946","fileName":"1575204462.txt","sourceCode":"impl Solution {\n    pub fn min_zero_array(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> i32 {\n        let mut dp: Vec<Vec<bool>> = Vec::with_capacity(10);\n        for i in 0..nums.len() {\n            let mut sub_dp = vec![false; nums[i] as usize + 1];\n            sub_dp[0] = true;\n            dp.push(sub_dp);\n        }\n\n        let mut zeros = nums.iter().filter(|&&v| v == 0).count();\n        let mut k = 0;\n        while zeros < nums.len() && k < queries.len() {\n            let q = &queries[k];\n            let val = q[2];\n            for i in q[0]..=q[1] {\n                let i = i as usize;\n                if dp[i][nums[i] as usize] {\n                    continue;\n                }\n\n                for j in (val..=nums[i]).rev() {\n                    dp[i][j as usize] |= dp[i][(j - val) as usize];\n                }\n                if dp[i][nums[i] as usize] {\n                    zeros += 1;\n                }\n            }\n            k += 1;\n        }\n\n        if zeros < nums.len() {\n            -1\n        } else {\n            k as i32\n        }\n    }\n}\n","author":"stupid_panda","submissionId":"1575204462"},[]]},{"947":[{"id":"947","fileName":"1575204371.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        const int INF = 1e7;\n        vector<int> ans(n, INF);\n\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) {\n                ans[i] = 0;\n                continue;\n            }\n            vector<bool> dp(nums[i] + 1, false);\n            dp[0] = true;\n            for (int k = 0; k < q; k++) {\n                int l = queries[k][0], r = queries[k][1], v = queries[k][2];\n                if (l <= i && i <= r) {\n                    for (int j = nums[i]; j >= v; j--) {\n                        if (dp[j - v]) {\n                            dp[j] = true;\n                        }\n                    }\n                }\n                if (dp[nums[i]]) {\n                    ans[i] = k + 1;\n                    break;\n                }\n            }\n        }\n\n        int maxK = 0;\n        for (int i = 0; i < n; i++) {\n            if (ans[i] == INF) {\n                return -1;\n            }\n            maxK = max(maxK, ans[i]);\n        }\n        return maxK;\n    }\n};","author":"qzyq","submissionId":"1575204371"},[]]},{"948":[{"id":"948","fileName":"1575204836.txt","sourceCode":"class Solution:\n    def add(self, count, val):\n        for i in range(1000-val, -1, -1):\n            count[i+val] += count[i]\n    def delete(self, count, val):\n        for i in range(val, 1001):\n            count[i] -= count[i-val]\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        res = -1\n        heap = []\n        count = [1] + [0] * 1000\n        for i in range(len(nums)):\n            if not nums[i]: continue\n            while heap and heap[0][0] < i:\n                self.delete(count, heap[0][1])\n                heappop(heap)\n            for qid in range(len(queries)):\n                if count[nums[i]]: \n                    break\n                elif not queries[qid]:\n                    continue\n                elif queries[qid][0] <= i <= queries[qid][1]:\n                    self.add(count, queries[qid][2])\n                    heappush(heap, (queries[qid][1], queries[qid][2]))\n                    res = max(res, qid)\n                    queries[qid].clear()\n            if not count[nums[i]]:\n                return -1\n            \n        return res + 1","author":"r09922a12","submissionId":"1575204836"},[]]},{"949":[{"id":"949","fileName":"1575204861.txt","sourceCode":"class Solution:\n    def isSubsetSum(self, arr, target):\n        n = len(arr)\n        prev = [False] * (target + 1)\n        curr = [False] * (target + 1)\n    \n        prev[0] = True \n    \n        for i in range(1, n + 1):\n            for j in range(target + 1):\n                if j < arr[i - 1]:\n                    curr[j] = prev[j]\n                else:\n                    curr[j] = prev[j] or prev[j - arr[i - 1]]\n            prev = curr.copy() \n    \n        return prev[target]\n    \n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        left, right = 0, len(queries) + 1  # left =0\n        def can_zero_out(k):\n            contributions = defaultdict(list) \n            \n            for i in range(k):\n                l, r, val = queries[i]\n                for j in range(l, r + 1):\n                    contributions[j].append(val)\n            \n            for i in range(n):\n                if nums[i] == 0:\n                    continue  \n    \n                target = nums[i]\n                available_vals = contributions[i]\n                \n                if not available_vals or not self.isSubsetSum(available_vals, target):\n                    return False\n            \n            return True\n    \n        while left < right: \n            mid = (left + right) // 2\n            if can_zero_out(mid):\n                right = mid  \n            else:\n                left = mid + 1  \n    \n        return left if left <= len(queries) else -1 ","author":"Sanjeev","submissionId":"1575204861"},[]]},{"950":[{"id":"950","fileName":"1575204678.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\nprivate:\n    const int ADIPADAI_PARAVU = 1001;\n    \n    bool ellaElementsumZeroVa(const vector<int>& arayam) {\n        for (int enn : arayam) {\n            if (enn != 0) return false;\n        }\n        return true;\n    }\n    \n    bool ellaIlakkumSaathiyama(const vector<bitset<1001>>& saathiya_nilai, const vector<int>& arayam) {\n        for (int i = 0; i < arayam.size(); i++) {\n            if (!saathiya_nilai[i].test(arayam[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    void thuvalaiCheyyavum(vector<bitset<1001>>& saathiya_nilai, int idamirunthu, int idamvarai, int maatrumThogai, const vector<int>& arayam) {\n        for (int sthaanam = idamirunthu; sthaanam <= idamvarai; sthaanam++) {\n            bitset<1001> puriaThogai = saathiya_nilai[sthaanam];\n            puriaThogai <<= maatrumThogai;\n            saathiya_nilai[sthaanam] |= puriaThogai;\n            for (int nilai = arayam[sthaanam] + 1; nilai < ADIPADAI_PARAVU; nilai++) {\n                saathiya_nilai[sthaanam].reset(nilai);\n            }\n        }\n    }\n\npublic:\n    int minZeroArray(vector<int>& arayam, vector<vector<int>>& sodhanaigal) {\n        if (ellaElementsumZeroVa(arayam)) {\n            return 0;\n        }\n        int mozhumaiAlavu = arayam.size();\n        vector<bitset<1001>> saathiya_nilai(mozhumaiAlavu);\n        for (int i = 0; i < mozhumaiAlavu; i++) {\n            saathiya_nilai[i].reset();\n            saathiya_nilai[i].set(0); \n        }\n        for (int sodhanaiEnn = 0; sodhanaiEnn < sodhanaigal.size(); sodhanaiEnn++) {\n            const auto& sodhanai = sodhanaigal[sodhanaiEnn];\n            int idamirunthu = sodhanai[0] , idamvarai = sodhanai[1] , maatrumThogai = sodhanai[2];\n            thuvalaiCheyyavum(saathiya_nilai, idamirunthu, idamvarai, maatrumThogai, arayam);\n            if (ellaIlakkumSaathiyama(saathiya_nilai, arayam)) {\n                return sodhanaiEnn + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"Karthigaiselvamr05","submissionId":"1575204678"},[]]},{"951":[{"id":"951","fileName":"1575204843.txt","sourceCode":"class Solution {\n    bool check(vector<int>& a, vector<vector<int>>& q, int k) {\n        int n = a.size();\n        const int MAX=1000;\n        for(int i = 0; i < n; i++) {\n            vector<int> dp(MAX+1, 0);\n            dp[0] = 1;\n            for(int j = 0; j < k; j++) {\n                int l=q[j][0], r=q[j][1], val=q[j][2];\n                if(l<=i && i<=r) for (int x=MAX; x>=val; x--) dp[x]|=dp[x-val];\n            }\n            if(!dp[a[i]]) return false;\n        }\n        return true;\n    }\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int low = 0, high = q.size(), ans = -1;\n        while (low<=high) {\n            int mid = low+(high-low)/2;\n            if (check(a, q, mid)) ans=mid, high=mid-1;\n            else low=mid+1;\n        }\n        return ans;\n    }\n};","author":"Adit Shriyans","submissionId":"1575204843"},[]]},{"952":[{"id":"952","fileName":"1575204953.txt","sourceCode":"class Solution {\n    int findMinQueriesRequired(int idx, int target, vector<vector<int>>& queries) {\n        if (target == 0)\n            return 0;\n        vector<bool> dp(target + 1);\n        dp[0] = 1;\n        int queryCnt = 0;\n        for (auto& query: queries) {\n            queryCnt++;\n            int l = query[0], r = query[1], val = query[2];\n            if (idx < l || idx > r)\n                continue;\n            for (int j = target; j >= val; --j) {\n                dp[j] = dp[j] | dp[j - val];\n            }\n            if (dp[target])\n                return queryCnt;\n        }\n        return -1;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int maxQuery = 0;\n\n        for (int i=0; i<nums.size(); ++i) {\n            int curQuery = findMinQueriesRequired(i, nums[i], queries);\n            if (curQuery == -1)\n                return -1;\n            maxQuery = max(maxQuery, curQuery);\n        }\n        return maxQuery;\n    }\n};","author":"Anshul_G","submissionId":"1575204953"},[]]},{"953":[{"id":"953","fileName":"1575205122.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        steps = [-1] * len(nums)\n        for i, n in enumerate(nums):\n            if n == 0:\n                steps[i] = 0\n            sets = set()\n            sets.add(n)\n            for j, query in enumerate(queries):\n                new_set = set()\n                for x in sets:\n                    l, r, val = query\n                    if l <= i <= r:\n                        # print(x-val)\n                        if x - val == 0:\n                            steps[i] = j + 1\n                            break\n                        elif x - val > 0 and x - val not in sets:\n                            new_set.add(x-val)\n\n                if steps[i] >= 0:\n                    break\n                sets = sets.union(new_set)\n                # print(sets)\n        # print(steps)\n        if -1 in steps:\n            return -1\n        else:\n            return max(steps)\n\n            \n                        \n                        \n                        \n                    \n                    \n                \n            ","author":"roh019","submissionId":"1575205122"},[]]},{"954":[{"id":"954","fileName":"1575204957.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        #DP QUESTION\n        dp = [[[i, -1] for i in range(n+1)] for n in nums]\n        for d in dp:\n            if len(d)>0:\n                d[0][1] = 0 \n        counts = len(nums)-nums.count(0)\n        k = 0\n        # print(dp)\n        while counts > 0:\n            #print(counts)\n            if k == len(queries):\n                return -1\n            #print(dp)\n            for i in range(queries[k][0], queries[k][1]+1):\n               # print(dp[i][-1])\n                \n                #print(len(dp[i])>0, queries[k][2]<=nums[i], dp[i][-1][1]==-1)\n                if len(dp[i])>0 and queries[k][2]<=nums[i] and dp[i][-1][1]==-1:\n                    \n                    row = dp[i]\n                    #print(row, k)\n                    for n in range(queries[k][2], nums[i]+1):\n                        #print(n)\n                        if row[n-queries[k][2]][1]!=-1 and row[n-queries[k][2]][1]!=k+1 and row[n][1]==-1:\n                            #print(\"x\")\n                            row[n][1] = k+1\n                            #print(n, dp[i])\n                            if n == nums[i]:\n                                counts -= 1\n\n            k+=1\n            \n        return k","author":"westonz7042","submissionId":"1575204957"},[]]},{"955":[{"id":"955","fileName":"1575205147.txt","sourceCode":"#define vi vector<int>\n#define vvi vector<vi>\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define bs bitset<1001>\n#define pii pair<int, int>\n#define mii unordered_map<int, int>\n#define si set<int>\n#define usi unordered_set<int>\n#define qi queue<int>\n#define sti stack<int>\ntypedef pair<vi, vvi> pivv;\ntypedef unordered_map<int, vi> umvi;\ntypedef priority_queue<int> pqi;\ntypedef vector<pii> vpi;\nclass Solution {\npublic:\n    int minZeroArray(vi& _arrays, vvi& _queries) {\n        int n = sz(_arrays);\n        pivv unique_pair_list = {_arrays, _queries};\n        umvi extreneous_map;\n        vector<bs> __dp(n);\n        for (int j = 0; j < n; j++) __dp[j].reset(), __dp[j].set(0, true);\n        pqi point_queue;\n        usi redundant_set;\n        bool allZ = true;\n        for (int _number : _arrays) if (_number) { allZ = false; break; }\n        if (allZ) return 0;\n        si unnecessary_set;\n        sti irrelevant_stack;\n        for (int k = 0; k < sz(_queries); k++) {\n            int l = _queries[k][0], r = _queries[k][1], v = _queries[k][2];\n            for (int j = l; j <= r; j++) {\n                __dp[j] |= (__dp[j] << v);\n                for (int p = _arrays[j] + 1; p < 1001; p++) __dp[j].reset(p);\n            }\n            bool __allach = true;\n            for (int j = 0; j < n; j++) {\n                if (!__dp[j].test(_arrays[j])) { __allach = false; break; }\n            }\n            if (__allach) return k + 1;\n        }\n        return -1;\n    }\n};\n","author":"Shivam kumar","submissionId":"1575205147"},[]]},{"956":[{"id":"956","fileName":"1575205214.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int[][] queriesCopy = queries;\n        int lo = 0, hi = queries.length, ans = -1;\n        while (lo <= hi) {\n            int mid = (lo + hi) / 2;\n            if (canZero(nums, queriesCopy, mid)) {\n                ans = mid;\n                hi = mid - 1;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        return ans;\n    }\n    \n    private boolean canZero(int[] nums, int[][] queries, int k) {\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            List<Integer> vals = new ArrayList<>();\n            for (int j = 0; j < k; j++) {\n                if (queries[j][0] <= i && i <= queries[j][1]) {\n                    vals.add(queries[j][2]);\n                }\n            }\n            if (!subsetSum(vals, nums[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private boolean subsetSum(List<Integer> vals, int target) {\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n        for (int val : vals) {\n            for (int s = target; s >= val; s--) {\n                if (dp[s - val]) dp[s] = true;\n            }\n        }\n        return dp[target];\n    }\n}\n","author":"AbhimanyuBaskaran","submissionId":"1575205214"},[]]},{"957":[{"id":"957","fileName":"1575205389.txt","sourceCode":"class Solution {\n    int[] nums;\n    Map<Integer,Integer> map=new HashMap<>();\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length, sum = 0, k = 0;\n        this.nums=nums;\n        for(int i=0;i<n;i++){\n            k=Math.max(k,solve(queries,nums[i],i,0));\n            map=new HashMap<>();\n        }\n        if(k==100000000){\n            return -1;\n        }\n        return k;\n    }\n    int solve(int[][] queries,int num,int idx,int qi){\n        int key=num+1001*idx+ 10011*qi;\n        if(num==0){\n            return qi;\n        }\n        if(num<0 || qi==queries.length){\n            return 100000000;\n        }\n        if(map.containsKey(key)){\n            return map.get(key);\n        }\n        int r=100000000;\n        if(idx>=queries[qi][0] && idx<=queries[qi][1] && queries[qi][2]<=nums[idx]){\n            r=solve(queries,num-queries[qi][2],idx,qi+1);\n        }\n        r=Math.min(r,solve(queries,num,idx,qi+1));\n        map.put(key,r);\n        return r;\n    }\n}","author":"PRIYANKA","submissionId":"1575205389"},[]]},{"958":[{"id":"958","fileName":"1575205391.txt","sourceCode":"class Solution {\npublic:\n    typedef vector<int> vint;\n    typedef vector<vint> vvint;\n\n    bool __rec__(int i, const vector<int>& values, int req, vector<vector<int>>& memo) {\n        // cout << \"i : \" << i << \" , req : \" << req << endl;\n        if ( i == values.size() ) {\n            return req == 0;\n        }\n        if ( req == 0 )\n            return true;\n        if ( req < 0 )\n            return false;\n\n        if ( memo[i][req] != -1 )\n            return memo[i][req] == 1;\n\n        const bool answer = __rec__(i+1, values, req - values[i], memo) or __rec__(i+1, values, req, memo);\n        // memo[{i, req}] = answer;\n        memo[i][req] = (answer ? 1 : 0);\n        return answer;\n    }\n\n    bool is_valid(const vint& input, const vvint& request, int k) {\n        // cout << \"checking validity for : \" << k << endl;\n        vvint values(input.size());\n        for ( int i=0 ; i < k ; i++ ) {\n            for ( int j = request[i][0] ; j <= request[i][1] ; j++ )\n                    values[j].push_back(request[i][2]);\n        }\n\n        for ( int i=0 ; i < input.size() ; i++ ) {\n            vector<vector<int>> memo(values[i].size()+1, vector<int>(input[i]+1, -1));\n            if ( not __rec__(0, values[i], input[i], memo) )\n                return false;\n        }\n\n        return true;\n    }\n\n    int minZeroArray(vector<int>& input, vector<vector<int>>& request) {\n        int left = 0;\n        int right = request.size();\n\n        int answer = INT_MAX;\n        while ( left <= right ) {\n            int current = (left + right) / 2;\n            if ( is_valid(input, request, current) ) {\n                answer = min(answer, current);\n                right = current-1;\n            } else {\n                left = current+1;\n            }\n        }\n        return answer == INT_MAX ? -1 : answer;\n    }\n};","author":"DepressedDumbass","submissionId":"1575205391"},[]]},{"959":[{"id":"959","fileName":"1575205248.txt","sourceCode":"class Solution {\n  int minZeroArray(List<int> nums, List<List<int>> queries) {\n  int a = nums.length;\n  List<List<bool>> b =\n      List.generate(a, (_) => List<bool>.filled(1001, false));\n  for (int c = 0; c < a; c++) {\n    b[c][0] = true;\n  }\n  bool d = true;\n  for (var e in nums) {\n    if (e != 0) {\n      d = false;\n      break;\n    }\n  }\n  if (d) return 0;\n  for (int f = 0; f < queries.length; f++) {\n    int g = queries[f][0];\n    int h = queries[f][1];\n    int i = queries[f][2];\n    for (int j = g; j <= h; j++) {\n      List<bool> k = List<bool>.from(b[j]);\n      k = _s(k, i);\n      for (int l = 0; l < 1001; l++) {\n        b[j][l] = b[j][l] || k[l];\n      }\n      for (int m = nums[j] + 1; m < 1001; m++) {\n        b[j][m] = false;\n      }\n    }\n    bool n = true;\n    for (int o = 0; o < a; o++) {\n      if (!b[o][nums[o]]) {\n        n = false;\n        break;\n      }\n    }\n    if (n) return f + 1;\n  }\n  return -1;\n}\n\nList<bool> _s(List<bool> p, int t) {\n  List<bool> r = List<bool>.filled(1001, false);\n  for (int s = 0; s < 1001 - t; s++) {\n    if (p[s]) r[s + t] = true;\n  }\n  return r;\n}\n\n}","author":"VISHNUPPRIYAN","submissionId":"1575205248"},[]]},{"960":[{"id":"960","fileName":"1575205492.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int ans = -1, low = 0, high = queries.length;\n        while(low<=high){\n            int mid = low + (high-low)/2;\n            if(isPossible(nums, queries, mid)){\n                ans = mid;\n                high = mid-1;\n            }else{\n                low = mid+1;\n            }\n        }\n        return ans;\n    }\n\n    public boolean isPossible(int[] nums, int[][] queries, int k){\n        Map<Integer,List<Integer>> map = new HashMap<>();\n        int n = nums.length;\n        for(int i=0;i<n;i++){\n            map.put(i, new ArrayList<>());\n        }\n        for(int i=0;i<k;i++){\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n\n            for(int idx=l;idx<=r;idx++){\n                map.get(idx).add(val);\n            }\n        }\n        return check(map, nums);\n    }\n\n    public boolean check(Map<Integer,List<Integer>> map, int[] nums){\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]>0){\n                int[][] dp = new int[map.get(i).size()][nums[i]+1];\n                for(int[] sub : dp){\n                    Arrays.fill(sub, -1);\n                }\n                if(isSumExist(map.get(i), 0, nums[i], dp)==0){\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int isSumExist(List<Integer> list, int idx, int sum, int[][] dp){\n        if(idx==list.size()){\n            return sum==0?1:0;\n        }\n        if(sum<0){\n            return 0;\n        }\n\n        if(dp[idx][sum]!=-1){\n            return dp[idx][sum];\n        }\n        //take it\n        int take = isSumExist(list, idx+1, sum-list.get(idx), dp);\n        //not take it\n        int notTake = isSumExist(list, idx+1, sum, dp);\n        return dp[idx][sum] = (take==1 || notTake==1)?1:0;\n    }\n    \n}","author":"Rajendar Meti","submissionId":"1575205492"},[]]},{"961":[{"id":"961","fileName":"1575205407.txt","sourceCode":"#include <vector>\n#include <bitset>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& elements, vector<vector<int>>& operations) {\n        int size = elements.size();\n        pair<vector<int>, vector<vector<int>>> dataPair = {elements, operations};\n\n        vector<bitset<1001>> bitMasks = initializeBitMasks(size);\n        \n        if (checkIfAllZero(elements)) return 0;\n\n        for (int opIndex = 0; opIndex < operations.size(); opIndex++) {\n            applyOperation(bitMasks, elements, operations[opIndex]);\n\n            if (isTransformationComplete(bitMasks, elements)) return opIndex + 1;\n        }\n\n        return -1;\n    }\n\nprivate:\n    vector<bitset<1001>> initializeBitMasks(int size) {\n        vector<bitset<1001>> bitMasks(size);\n        for (int i = 0; i < size; i++) {\n            bitMasks[i].reset();\n            bitMasks[i].set(0, true);\n        }\n        return bitMasks;\n    }\n\n    bool checkIfAllZero(const vector<int>& elements) {\n        for (int value : elements) {\n            if (value != 0) return false;\n        }\n        return true;\n    }\n\n    void applyOperation(vector<bitset<1001>>& bitMasks, const vector<int>& elements, const vector<int>& operation) {\n        int start = operation[0], end = operation[1], shiftValue = operation[2];\n\n        for (int i = start; i <= end; i++) {\n            bitMasks[i] |= (bitMasks[i] << shiftValue);\n            for (int j = elements[i] + 1; j < 1001; j++) {\n                bitMasks[i].reset(j);\n            }\n        }\n    }\n\n    bool isTransformationComplete(const vector<bitset<1001>>& bitMasks, const vector<int>& elements) {\n        for (int i = 0; i < elements.size(); i++) {\n            if (!bitMasks[i].test(elements[i])) return false;\n        }\n        return true;\n    }\n};\n","author":"anshu156","submissionId":"1575205407"},[]]},{"962":[{"id":"962","fileName":"1575205019.txt","sourceCode":"class Solution {\npublic:\n    const int maxSum = 1001;\n    bool check(vector<int>&nums)\n    {\n        for(auto val : nums)\n            if(val != 0)\n                return false;\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int maxNums = -1;\n        int n = nums.size();\n        int m = queries.size();\n        //bool canAllBeZero = false;\n        if(check(nums))\n            return 0;\n        for(auto val : nums)\n            maxNums = max(maxNums, val);\n        \n        vector<bitset<1010>>dp(n);\n        \n        for(int i = 0; i < n; i++)\n            dp[i].set(0, true);\n        for(int j = 0; j < m; j++)\n        {\n            int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n            for(int i = l; i <= r; i++)\n            {\n                if(val <= maxSum)\n                    dp[i] |= (dp[i] << val);    \n            }\n            bool canAllBeZero = true;\n            for(int i = 0; i < n; i++)\n            {\n                if(nums[i] <= maxSum) \n                {\n                    if(! dp[i].test(nums[i])) \n                    {\n                        canAllBeZero = false;\n                        break;\n                    }\n                } \n                else \n                {\n                    canAllBeZero = false;\n                    break;\n                }\n            }\n            if(canAllBeZero)\n                return j + 1;\n        }\n        return -1;\n    }\n};","author":"Kai Nguyen","submissionId":"1575205019"},[]]},{"963":[{"id":"963","fileName":"1575205615.txt","sourceCode":"class Solution {\npublic:\n\n    bool target(vector<int> arr, int sum) {\n        int n = arr.size();\n        vector<bool> prev(sum + 1, false), curr(sum + 1);\n        \n        prev[0] = true;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= sum; j++) {\n                if (j < arr[i - 1])\n                    curr[j] = prev[j];\n                else\n                    curr[j] = (prev[j] || prev[j - arr[i - 1]]);\n            }\n            prev = curr;\n        }\n        return prev[sum];\n    }\n\n    bool possible(vector<int>& nums, vector<vector<int>>& qr, int mid)\n    {\n\n        vector<vector<int>> mat(nums.size());\n\n        for(int i=0; i<mid; i++)\n        {\n            int l = qr[i][0];\n            int r = qr[i][1];\n            int val = qr[i][2];\n\n            for(; l<=r; l++)\n            {\n                mat[l].push_back(val);\n            }\n        }\n\n        for(int i=0; i<nums.size(); i++)\n        {\n            if(!target(mat[i], nums[i]))\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& qr) {\n\n        int s = 0;\n        int e = qr.size();\n\n        int ans=-1;\n\n        while(s<=e)\n        {\n            int mid = s + (e-s)/2;\n\n            if(possible(nums, qr, mid))\n            {\n                ans = mid;\n                e = mid-1;\n            }\n            else\n            {\n                s = mid+1;\n            }\n        }\n\n        return ans;\n        \n    }\n};","author":"Samarth Patel","submissionId":"1575205615"},[]]},{"964":[{"id":"964","fileName":"1575205661.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> qsum(n);\n        for (auto &q:queries) {\n            for (int i = 0; i < n; i++) {\n            // for (int i = q[0]; i <= q[1]; i++) {\n                if (i >= q[0] && i <= q[1]) {\n                    // qsum[i][0] += q[2];\n                    qsum[i].push_back(q[2]);\n                }\n                else qsum[i].push_back(0);\n            }\n        }\n        \n        // int idx = 0;\n        // for (auto &it:qsum) {\n        //     cout << nums[idx++] << \": \";\n        //     for (auto &i:it) cout << i << \" \";\n        //     cout << endl; \n        // }\n        // cout << endl; \n        \n        auto subsetSum = [](vector<int> &subset, int k){\n            if (k == 0) return 0;\n            unordered_set<int> sums = {0};\n            for (int i = 0; i < subset.size(); i++) {\n                unordered_set<int> nsums = sums;\n                for (int s:sums) {\n                    if (s + subset[i] == k) {\n                        return i + 1;\n                    }\n                    nsums.insert(s + subset[i]);\n                }\n                sums = nsums;\n            }\n            return -1;\n        };\n        \n        int ans = -1;\n        for (int i = 0; i < n; i++) {\n            int t = subsetSum(qsum[i], nums[i]);\n            if (t == -1)    return -1;\n            ans = max(ans, t);\n        }\n        \n        return ans ;\n    }\n};","author":"zxc","submissionId":"1575205661"},[]]},{"965":[{"id":"965","fileName":"1575205692.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int low = -1;\n        int high = queries.length-1;\n        if(!isPos(nums,queries,high)) return -1;\n        while (low<=high) {\n            int mid = high - (high - low)/2;\n            if(isPos(nums, queries, mid)){\n                high = mid - 1;\n            }\n            else{\n                low = mid + 1;\n            }\n        }\n        return low+1;\n    }\n\n    boolean isPos(int nums[],int queries[][],int k){\n        int n = nums.length;\n        ArrayList<ArrayList<Integer>> arr = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            arr.add(new ArrayList<>());\n        }\n        for (int i = 0; i <=k; i++) {\n            int left = queries[i][0];\n            int right = queries[i][1];\n            int val = queries[i][2];\n            for (int j = left; j <= right; j++) {\n                arr.get(j).add(val);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if(!isSubsetSum(arr.get(i),nums[i])) return false;\n        }\n        return true;\n    }\n\n    boolean isSubsetSum(ArrayList<Integer> arr, int target) {\n        if(arr.size()==0){\n            if(target==0) return true;\n            else return false;\n        }\n        boolean dp[][] = new boolean[arr.size()][target+1];\n        for(int i=0;i<arr.size();i++)\n        dp[i][0] = true;\n        if(arr.get(0)<=target)\n        dp[0][arr.get(0)] = true;\n        \n        for(int i=1;i<arr.size();i++){\n            for(int t=1;t<=target;t++){\n                boolean notTake = dp[i-1][t];\n                boolean take = false;\n                if(arr.get(i)<=t)\n                take = dp[i-1][t-arr.get(i)];\n                dp[i][t] = take||notTake;\n            }\n        }\n        \n        return dp[arr.size()-1][target];\n    }\n}","author":"Soham","submissionId":"1575205692"},[]]},{"966":[{"id":"966","fileName":"1575205800.txt","sourceCode":"class Solution {\npublic:\n    bool ispos(vector<int>& nums, int target) {\n        int n = nums.size();\n        vector<vector<bool>> dp(n + 1, vector<bool>(target+1, 0));\n        dp[n][0] = true;\n        for (int i = n - 1; i >= 0; i--) {\n            dp[i][0] = true;\n            for (int j = 1; j <= target; j++) {\n                bool maxi = dp[i + 1][j];\n                if (j - nums[i] >= 0) {\n                    if (dp[i + 1][j - nums[i]] == 1) {\n                        maxi = 1;\n                    }\n                }\n                dp[i][j] = maxi;\n            }\n        }\n        return dp[0][target];\n    }\n    bool check(vector<int>& nums, vector<vector<int>>& queries, int k) {\n        int n = nums.size(), m = queries.size();\n        vector<vector<int>> v(n);\n        for (int i = 0; i < k; i++) {\n            int a = queries[i][0], b = queries[i][1], c = queries[i][2];\n            for (int j = a; j <= b; j++) {\n                v[j].push_back(c);\n            }\n        }\n        bool is_it = true;\n        for (int i = 0; i < n; i++) {\n            if (ispos(v[i], nums[i]) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        if (check(nums, queries, m) == false) {\n            return -1;\n        }\n        int l = 0, h = m - 1;\n        int ans = m;\n        while (l <= h) {\n            int mid = (l + h) / 2;\n            if (check(nums, queries, mid) == true) {\n                ans = mid;\n                h = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"Bollepalli Ram Teja","submissionId":"1575205800"},[]]},{"967":[{"id":"967","fileName":"1575205850.txt","sourceCode":"#include <bits/stdc++.h>\n\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimization (\"unroll-loops\")\n\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define vvc vector<vector<char>>\n#define vpi vector<pair<int,int>>\n#define vvs vector<vector<string>>\n#define ump unordered_map<int,int>\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#define sort(x) sort(all(x))\n#define MAX(x) *max_element(all(x))\n#define MIN(x) *min_element(all(x))\n#define ll long long\n\n#define FOR(i, a, b) for (int i = a; i < b; ++i)\n#define FORR(i, a, b) for (int i = a; i <= b; ++i)\n#define RF(i,a,b) for (int i = a; i >= b; i--)\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<bitset<1001>> dp(n);\n\n        FOR(i,0,n){\n            dp[i].reset();\n            dp[i].set(0, true);\n        }\n\n        bool flag = true;\n        FOR(i,0,n) {\n            if (nums[i] != 0) {\n                flag = false;\n                break;\n            }\n        }\n\n        if (flag == true) return 0;\n\n        FOR(k,0,(int)queries.size()) {\n            FORR(j , queries[k][0] , queries[k][1]) {\n                dp[j] |= (dp[j] << queries[k][2]);\n                for (int p = nums[j] + 1; p < 1001; p++) {\n                    dp[j].reset(p);\n                }\n            }\n\n            bool all = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j].test(nums[j])) {\n                    all = false;\n                    break;\n                }\n            }\n\n            if (all) return k + 1;\n        }\n\n        return -1;\n\n    }\n};\n\n\nauto init = []() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    return 'c';\n}();","author":"Ayush Rakwal","submissionId":"1575205850"},[]]},{"968":[{"id":"968","fileName":"1575205934.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] arr, int[][] q) {\n        \n        int res = 0;\n        for(int i = 0; i<arr.length; i++){\n            int x = helper(arr[i], i, arr, q);\n            if(x == Integer.MAX_VALUE) return -1;\n            res = Math.max(res, x);\n        }\n        return res;\n    }\n    \n    Integer[][] dp;\n    public int helper(int val, int inx, int[] arr, int[][] q){\n        dp = new Integer[val+1][q.length];\n        return solve(val, arr, q, inx, 0);\n    }\n    \n    public int solve(int val,int[] arr, int[][] q, int inx1, int inx2){\n        if(val == 0) return inx2;\n        if(inx2 >= q.length) return Integer.MAX_VALUE;\n        if(dp[val][inx2] !=null) return dp[val][inx2];\n        \n        int o1 = solve(val, arr, q, inx1, inx2+1);\n        \n        int o2 = Integer.MAX_VALUE;\n        \n        int l = q[inx2][0];\n        int r = q[inx2][1];\n        int d = q[inx2][2];\n        \n        if(inx1 >= l && inx1 <= r && val>=d){\n            o2 = solve(val-d, arr, q, inx1, inx2+1);\n        }\n        // System.out.println(inx2+\" \"+ o1+\" \"+o2);\n        return dp[val][inx2] = Math.min(o1,o2);\n    }\n}","author":"Jinal Patel","submissionId":"1575205934"},[]]},{"969":[{"id":"969","fileName":"1575206083.txt","sourceCode":"class Solution {\n    public:\n\nint maxSum(vector<int>& nums) {\n        int n = nums.size();\n        unordered_set<int>st;\n        for(auto x : nums){\n            st.insert(x);\n        }\n        int count=0;\n        for(auto x : st){\n            if(x>0)count+=x;\n        }\n        if(count==0){\n            sort(nums.begin(),nums.end());\n            count+=nums.back();\n        }\n        return count;\n    \n}\n        int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n            int n = nums.size();\n            int vrbjhdsfbvd=0;\n            int fjrshdbvjss=0;\n            int bvhrjsfbvj=0;\n            int nvfsrbjvdfv=0;\n            int bvjhbrdfsjvhs=0;\n            int bghjfsrbvd=0;\n            int vjhdfsbrvjss=0;\n            int bvjhsfbvrrjssdvf=0;\n            pair<vector<int> , vector<vector<int> > > pp = {nums,q};\n            int vqbjhdsfbvd=0;\n            int fjqshdbvjss=0;\n            int bvhqjsfbvj=0;\n            int nvfsqbjvdfv=0;\n            int bvjhbqdfsjvhs=0;\n            int bghjfsqbvd=0;\n            int vjhdfsbqvjss=0;\n            int bvjhsfbvqqjssdvf=0;\n            vector<bitset<1001>> dp(n);\n            int vbjhdsfbvd=0;\n            int fjshdbvjss=0;\n            int bvhjsfbvj=0;\n            int nvfsbjvdfv=0;\n            int bvjhbdfsjvhs=0;\n            int bghjfsbvd=0;\n            int vjhdfsbvjss=0;\n            int bvjhsfbvjssdvf=0;\n            for(int i=0;i<n;i++){\n                dp[i].reset();\n                int vbjhdsfbvd=0;\n            int fjshdbvjss=0;\n            int bvhjsfbvj=0;\n            int nvfsbjvdfv=0;\n            int bvjhbdfsjvhs=0;\n            int bghjfsbvd=0;\n            int vjhdfsbvjss=0;\n            int bvjhsfbvjssdvf=0;\n                dp[i].set(0,true);\n            }\n            bool flag=true;\n            for(int i=0;i<n;i++){\n                int vbjhdsfbvd=0;\n            int fjshdbvjss=0;\n            int bvhjsfbvj=0;\n            int nvfsbjvdfv=0;\n            int bvjhbdfsjvhs=0;\n            int bghjfsbvd=0;\n            int vjhdfsbvjss=0;\n            int bvjhsfbvjssdvf=0;\n                if(nums[i]!=0){\n                    flag=false;\n                    int vbjhdsfbvd=0;\n            int fjshdbvjss=0;\n            int bvhjsfbvj=0;\n            int nvfsbjvdfv=0;\n            int bvjhbdfsjvhs=0;\n            int bghjfsbvd=0;\n            int vjhdfsbvjss=0;\n            int bvjhsfbvjssdvf=0;\n                    break;\n                }\n            }\n            if(flag){\n                return 0;\n                int vbjhdsfbvd=0;\n            int fjshdbvjss=0;\n            int bvhjsfbvj=0;\n            int nvfsbjvdfv=0;\n            int bvjhbdfsjvhs=0;\n            int bghjfsbvd=0;\n            int vjhdfsbvjss=0;\n            int bvjhsfbvjssdvf=0;\n            }\n            for(int i=0;i<q.size();i++){\n                int xx = q[i][0];\n                int vbjhdsfbvd=0;\n            int fjshdbvjss=0;\n            int bvhjsfbvj=0;\n            int nvfsbjvdfv=0;\n            int bvjhbdfsjvhs=0;\n            int bghjfsbvd=0;\n            int vjhdfsbvjss=0;\n            int bvjhsfbvjssdvf=0;\n                int yy =q[i][1];\n                int vrrrrbjhdsfbvd=0;\n            int frjshdbvjss=0;\n            int bvrhjsfbvj=0;\n            int nvfrsbjvdfv=0;\n            int bvjhrbdfsjvhs=0;\n            int bghjfrsbvd=0;\n            int vjhdfsrbvjss=0;\n            int bvjhsfbrrvjssdvf=0;\n                int zz =q[i][2];\n                int vaaabjhdsfbvd=0;\n            int aafjshdbvjss=0;\n            int bvahjsfbvj=0;\n            int nvfasbjvdfv=0;\n            int bvjhabdfsjvhs=0;\n            int bghjfasbvd=0;\n            int vjhdfsabvjss=0;\n            int bvjhsfbaavjssdvf=0;\n                for(int j=xx;j<=yy;j++){\n                    int vbjhdsfbvd=0;\n            int fjshdbvjss=0;\n            int bvhjsfbvj=0;\n            int nvfsbjvdfv=0;\n            int bvjhbdfsjvhs=0;\n            int bghjfsbvd=0;\n            int vjhdfsbvjss=0;\n            int bvjhsfbvjssdvf=0;\n                    dp[j]|=(dp[j]<<zz);\n                    int vbyyyjhdsfbvd=0;\n            int fyyjshdbvjss=0;\n            int bvhyjsfbvj=0;\n            int nvfsybjvdfv=0;\n            int bvjhbydfsjvhs=0;\n            int bghjfsybvd=0;\n            int vjhdfsbyvjss=0;\n            int bvjhsfbvyyyjssdvf=0;\n                    for(int pos = nums[j]+1;pos<1001;pos++){\n                        int vbjhdsfbvd=0;\n            int fjshdbvjss=0;\n            int bvhjsfbvj=0;\n            int nvfsbjvdfv=0;\n            int bvjhbdfsjvhs=0;\n            int bghjfsbvd=0;\n            int vjhdfsbvjss=0;\n            int bvjhsfbvjssdvf=0;\n                        dp[j].reset(pos);\n                    }\n                }\n                bool ff1=true;\n                int vbdfddjhdsfbvd=0;\n            int dddfjshdbvjss=0;\n            int bvhdjsfbvj=0;\n            int nvfsdbjvdfv=0;\n            int bvjhbddfsjvhs=0;\n            int bghjfsdbvd=0;\n            int vjhdfsbdvjss=0;\n            int bvjhsfbvdddjssdvf=0;\n                for(int k=0;k<n;k++){\n                    int vbjhdsfbvd=0;\n            int fjshdbvjss=0;\n            int bvhjsfbvj=0;\n            int nvfsbjvdfv=0;\n            int bvjhbdfsjvhs=0;\n            int bghjfsbvd=0;\n            int vjhdfsbvjss=0;\n            int bvjhsfbvjssdvf=0;\n                    if(!dp[k].test(nums[k])){\n                        int vddddbjhdsfbvd=0;\n            int dddfjshdbvjss=0;\n            int bvhdjsfbvj=0;\n            int nvfsdbjvdfv=0;\n            int bvjhbddfsjvhs=0;\n            int bghjfsdbvd=0;\n            int vjhdfsbdvjss=0;\n            int bvjhsfbvddddjssdvf=0;\n                        ff1=false;\n                        int vbjhdsfbvd=0;\n            int fjshdbvjss=0;\n            int bvhjsfbvj=0;\n            int nvfsbjvdfv=0;\n            int bvjhbdfsjvhs=0;\n            int bghjfsbvd=0;\n            int vjhdfsbvjss=0;\n            int bvjhsfbvjssdvf=0;\n                        break;\n                    }\n                }\n                if(ff1){\n\n                    return i+1;\n                    int vbjhdsfbvd=0;\n            int fjshdbvjss=0;\n            int bvhjsfbvj=0;\n            int nvfsbjvdfv=0;\n            int bvjhbdfsjvhs=0;\n            int bghjfsbvd=0;\n            int vjhdfsbvjss=0;\n            int bvjhsfbvjssdvf=0;\n                }\n                \n            }\n            return -1;\n            int vbjrrhdsfbvd=0;\n            int fjshdrbvjss=0;\n            int bvhjsfrbvj=0;\n            int nvfsbjvrdfv=0;\n            int bvjhbdfsrjvhs=0;\n            int bghjfsbvdr=0;\n            int vjhdfsbvjsrs=0;\n            int bvjhsfbvjssrrrdvf=0;\n        }\n    };","author":"Prince Grewal","submissionId":"1575206083"},[]]},{"971":[{"id":"971","fileName":"1575205997.txt","sourceCode":"import java.math.BigInteger;\n\nclass Solution {\n    public int minZeroArray1F(int[] nums, int[][] queries) {\n        int n = nums.length, m = queries.length;\n        for (int j = 0; j < m; j ++) {\n            int l = queries[j][0], r = queries[j][1], d = queries[j][2], match = 1;\n            for (int i = l; i <= r; i ++) {\n                nums[i] -= d;\n            }\n            System.out.println(j + \" \" + Arrays.toString(nums));\n            for (int v : nums) {\n                if (v != 0) {\n                    match = 0;\n                    break;\n                }\n            }\n            if (match == 1) {\n                return j + 1;\n            }\n        }\n        return -1;\n    }\n    \n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length, m = queries.length;\n        BigInteger[] dp = new BigInteger[n];\n        for (int i = 0; i < n; i++) {\n            dp[i] = BigInteger.ONE; \n        }\n        \n        boolean allZero = true;\n        for (int i = 0; i < n; i++) {\n            if (!dp[i].testBit(nums[i])) { \n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) {\n            return 0;\n        }\n        \n        for (int k = 0; k < m; k++) {\n            int l = queries[k][0], r = queries[k][1], v = queries[k][2];\n            for (int i = l; i <= r; i++) {\n                dp[i] = dp[i].or(dp[i].shiftLeft(v));\n            }\n            allZero = true;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i].testBit(nums[i])) {\n                    allZero = false;\n                    break;\n                }\n            }\n            if (allZero) {\n                return k + 1; \n            }\n        }\n        return -1;\n    }\n}\n\n/*\n[2,0,2]\n[[0,2,1],[0,2,1],[1,1,3]]\n[4,3,2,1]\n[[1,3,2],[0,2,1]]\n[1,2,3,2,1]\n[[0,1,1],[1,2,1],[2,3,2],[3,4,1],[4,4,1]]\n[1,2,3,2,6]\n[[0,1,1],[0,2,1],[1,4,2],[4,4,4],[3,4,1],[4,4,5]]\n*/","author":"Lucas","submissionId":"1575205997"},[]]},{"973":[{"id":"973","fileName":"1575206114.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        # min and max of search space\n        m = len(queries)\n        n = len(nums)\n        # for each index store the set of all possible numbers it can have\n        d = defaultdict(set)\n        \n        isZero = set()\n        for i, num in enumerate(nums):\n            d[i].add(num)\n            if num == 0:\n                isZero.add(i)\n        if len(isZero) == n:\n            return 0\n                \n        \n        for index, query in enumerate(queries):\n            l, r, val = query\n            \n            for i in range(l, r+1):\n                if i in isZero:\n                    continue\n                updated = set()\n                for num in d[i]:\n                    if num-val == 0:\n                        updated.add(0)\n                        isZero.add(i)\n                        break\n                    elif num-val > 0:\n                        updated.add(num-val)\n                d[i].update(updated)\n                \n            if len(isZero) == n:\n                return index+1\n        return -1\n            \n\n\n        \n                    ","author":"Kuang Yu Heng","submissionId":"1575206114"},[]]},{"974":[{"id":"974","fileName":"1575206132.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int[] vlm = nums.clone();\n        int max_sum = 1000;\n        boolean[][] dp = new boolean[n][max_sum + 1];\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n        boolean allzero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                allzero = false;\n                break;\n            }\n        }\n        if (allzero) return 0;\n        int k = 0;\n        for (int[] query : queries) {\n            int l = query[0], r = query[1], val = query[2];\n            for (int i = l; i <= r; i++) {\n                for (int s = max_sum; s >= val; s--) {\n                    if (dp[i][s - val]) {\n                        dp[i][s] = true;\n                    }\n                }\n            }\n            k++;\n            boolean canzero = true;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i][nums[i]]) {\n                    canzero = false;\n                    break;\n                }\n            }\n            if (canzero) return k;\n        }\n        return -1;\n    }\n}\n","author":"nk348","submissionId":"1575206132"},[]]},{"975":[{"id":"975","fileName":"1575206165.txt","sourceCode":"# Find min index i so that vals[0..i] can yield a subset sum equal to x\ndef find_min_ind(x: int, vals: List[int]) -> int:\n    n = len(vals)\n    \n    if x == 0:\n        return -1\n    if n == 0:\n        return -2\n    \n    # dp[i][j] = whether a number i can be sum of a subset of vals[0..j]\n    # for i from 0 to x\n    dp = [[False] * n for _ in range(x+1)]\n    for j in range(n):\n        dp[0][j] = True\n    for i in range(x+1):\n        if vals[0] <= x:\n            dp[vals[0]][0] = True\n        for j in range(1, n):\n            if dp[i][j-1] or (i >= vals[j] and dp[i-vals[j]][j-1]):\n                dp[i][j] = True\n    \n    for j in range(n):\n        if dp[x][j]:\n            return j\n    return -2\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        k = -1\n        for t, d in enumerate(nums):\n            vals, indices = [], []\n            for i, q in enumerate(queries):\n                l, r, val = q[0], q[1], q[2]\n                if t >= l and t <= r:\n                    vals.append(val)\n                    indices.append(i)\n            ind = find_min_ind(d, vals)\n            #if len(vals) and ind >= 0:\n            #    print(d, vals, ind, indices[ind])\n            if ind >= 0:\n                k = max(k, indices[ind])\n            elif ind == -2:\n                return -1\n        \n        return (k+1)\n        ","author":"mpn","submissionId":"1575206165"},[]]},{"976":[{"id":"976","fileName":"1575206207.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int l = 0;\n        int r = queries.length;\n        int ans = -1;\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            if (check(nums, queries, mid)) {\n                ans = mid;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n    private boolean check(int[] nums, int[][] queries, int time) {\n        Map<Integer, List<Integer>> reduce = new HashMap<>();\n        Map<Integer, Integer> maxRed = new HashMap<>();\n        for (int i = 0; i < time; i++) {\n            int li = queries[i][0];\n            int ri = queries[i][1];\n            int vali = queries[i][2];\n            for (int j = li; j <= ri; j++) {\n                reduce.computeIfAbsent(j, k -> new ArrayList<>()).add(vali);\n                maxRed.put(j, maxRed.getOrDefault(j, 0) + vali);\n            }\n        }\n\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 0 || nums[i] == maxRed.getOrDefault(i, 0)) {\n                continue;\n            }\n            if (nums[i] > maxRed.getOrDefault(i, 0)) {\n                return false;\n            }\n            int num = nums[i];\n            List<Integer> red = reduce.get(i);\n            boolean[] dp = new boolean[num + 1];\n            dp[0] = true;\n            \n            for (int x : red) {\n                for (int j = num; j >= x; j--) {\n                    dp[j] |= dp[j - x];\n                }\n            }\n            \n            if (!dp[num]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}","author":"incognito1807","submissionId":"1575206207"},[]]},{"977":[{"id":"977","fileName":"1575206189.txt","sourceCode":"class Solution {\n public:\n  int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    if (ranges::max(nums) == 0) {\n      return 0;\n    }\n    int n = nums.size(), m = queries.size(), k = 0, i = 0;\n    vector<unordered_set<int>> diffArr(n, unordered_set<int>{0});\n    for (; k < m && i < n; ++k) {\n      int l = max(queries[k][0], i), r = queries[k][1], val = queries[k][2];\n      if (r < i) {\n        continue;\n      }\n      for (; l <= r; ++l) {\n        unordered_set<int> toAdd{};\n        for (int diff : diffArr[l]) {\n          toAdd.insert(diff + val);\n        }\n        diffArr[l].insert(toAdd.begin(), toAdd.end());\n      }\n      for (; i < n && diffArr[i].contains(nums[i]); ++i);\n    }\n    return i == n ? k : -1;\n  }\n};","author":"HowAbout3Sum","submissionId":"1575206189"},[]]},{"978":[{"id":"978","fileName":"1575206238.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int N = nums.length;\n        int M = queries.length;\n        \n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n        if (sum == 0) {\n            return 0;\n        }\n\n        int low = 1, high = M;\n        \n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (go(mid, nums, queries, N)) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        int ans = high + 1;\n        return ans > M ? -1 : ans;\n    }\n\n    private boolean go(int k, int[] nums, int[][] queries, int N) {\n        ArrayList<Integer>[] arr = new ArrayList[N];\n        for (int i = 0; i < N; i++) {\n            arr[i] = new ArrayList<>();\n        }\n        \n        for (int i = 0; i < k; i++) {\n            int li = queries[i][0], ri = queries[i][1], vali = queries[i][2];\n            for (int j = li; j <= ri; j++) {\n                arr[j].add(vali);\n            }\n        }\n\n        \n        for (int i = 0; i < N; i++) {\n            Map<String, Boolean> memo = new HashMap<>();\n            if (!helper(0, nums[i], arr, memo, i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean helper(int i, int val, ArrayList<Integer>[] arr, Map<String, Boolean> memo, int idx) {\n        if (val == 0) return true;\n        if (i == arr[idx].size()) return val == 0;\n\n        String key = i + \"-\" + val;\n        if (memo.containsKey(key)) {\n            return memo.get(key);\n        }\n\n        boolean x = helper(i + 1, val, arr, memo, idx);\n        boolean y = false;\n        if (arr[idx].get(i) <= val) {\n            y = helper(i + 1, val - arr[idx].get(i), arr, memo, idx);\n        }\n        \n        boolean result = x || y;\n        memo.put(key, result);\n        return result;\n    }\n}\n","author":"Ayush Rawat","submissionId":"1575206238"},[]]},{"979":[{"id":"979","fileName":"1575206177.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        // unordered_map<int,bool> m;\n        int mx = 0;\n        for(int id=0;id<nums.size();++id){\n            int i = nums[id];\n            // if(m.count(i)) continue;\n            int x = solve(id,i,queries);\n            if(x==-1) return -1;\n            // m[i]=1;\n            mx=max(mx, x);\n        }\n        // cout<<\"endn\";\n        return mx;\n    }\n    \n    int solve(int idx,int i,vector<vector<int>>&q){\n        // vector<int> dp(1001,0);\n        set<int> s;\n        if(i==0) return 0; \n        // dp[0]=1;\n        s.insert(0);\n        for(int j=0;j<q.size();++j){\n            if(idx<q[j][0]||idx>q[j][1]) continue;\n            set<int> t=s;\n            for(int x:t){\n                if(x+q[j][2]==i) {\n                    // cout << \"debug\" << i <<endl;\n                    return j+1;\n                }\n                else if(x+q[j][2]<i) s.insert(x+q[j][2]);\n            }\n            // s=t;\n        }\n        return -1;\n    }\n};","author":"Dibas Behera","submissionId":"1575206177"},[]]},{"980":[{"id":"980","fileName":"1575206330.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        index_values = {}\n        for i in range(len(nums)):\n            index_values[i] = set([0])\n \n        if sum(nums) == 0:\n            return 0\n\n        for k, query in enumerate(queries):\n            l, r, v = query\n            for i in range(l, r + 1):\n                new_values = set()\n                for value in index_values[i]:\n                    new_values.add(value + v)\n                index_values[i] = new_values.union(index_values[i])\n\n            all_found = True\n            for i in range(len(nums)):\n                if nums[i] not in index_values[i]:\n                    all_found = False\n                    break\n\n            if all_found:\n                return k + 1\n\n        return -1","author":"Litao Qiao","submissionId":"1575206330"},[]]},{"981":[{"id":"981","fileName":"1575206372.txt","sourceCode":"class Solution {\npublic:\n    int fint(int i, int sum, vector<pair<int, int>> &v, vector<vector<int>> &dp) {\n        int n = v.size();\n        if (i >= n || sum < 0) return INT_MAX;\n        \n        if (sum == 0) return i; // ?\n\n        if (dp[i][sum] != -1) return dp[i][sum];\n\n        if (sum - v[i].first == 0) return dp[i][sum] = v[i].second;\n        \n        int I = fint(i + 1, sum - v[i].first, v, dp);\n        int E = fint(i + 1, sum, v, dp);\n\n        return dp[i][sum] = min(I, E);\n    }\n\n    int f(vector<pair<int, int>> &v, int x) {\n        int n = v.size();\n        vector<vector<int>> dp(n + 1, vector<int> (x + 1, -1));\n        int ans = fint(0, x, v, dp);\n        return ans == INT_MAX ? -1: ans;\n    }\n\n    int minZeroArray(vector<int>& a, vector<vector<int>>& b) {\n        int n = a.size();\n        vector<vector<pair<int, int>>> ab(n);\n        for (int q = 0; q < b.size(); q++) {\n            int l = b[q][0], r = b[q][1], x = b[q][2];\n            for (int i = l; i <= r; i++) {\n                ab[i].push_back({x, q + 1});\n            }\n        }\n\n        int k = 0;\n        for (int i = 0; i < n; i++) {\n            if (a[i] == 0) continue;\n            int required = f(ab[i], a[i]);\n            \n            if (required == -1) {\n                return -1;\n            }\n            \n            k = max(k, required);\n        }\n\n        return k;\n    }\n};","author":"Viren Kathiriya","submissionId":"1575206372"},[]]},{"982":[{"id":"982","fileName":"1575206303.txt","sourceCode":"class Solution(object):\n    def minZeroArray(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: int\n        \"\"\"\n        a={}\n        n=len(nums)\n        for i in range(len(nums)):\n            if nums[i]>0:\n                a[i]=[nums[i]]\n            else:\n                n-=1\n                a[i]=[]\n        k=0\n        if n==0:\n            return 0\n        for l,r,v in queries:\n            for i in range(l,r+1):\n                if a[i]:\n                    x=a[i]\n                    if v in x:\n                        a[i]=[]\n                        n-=1\n                    else:\n                        a[i]=list(set(x+[t-v for t in x if t>v]))\n            k+=1\n            print(n,k,a)\n            if n==0:\n                return k\n        return -1\n            ","author":"ollimuh","submissionId":"1575206303"},[]]},{"983":[{"id":"983","fileName":"1575206457.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int[][] dp = new int[n][1001];\n        for (int[] d : dp) {\n            Arrays.fill(d, -1);\n            d[0] = 0;\n        }\n\n        boolean flag = true;\n        for (int j = 0; j < nums.length; ++j) {\n            if (dp[j][nums[j]] == -1) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) return 0;\n\n        \n        for (int i = 0; i < queries.length; ++i) {\n            int start = queries[i][0], end = queries[i][1], val = queries[i][2];\n            for (int j = start; j <= end; ++j) {\n                for (int k = nums[j]; k >= 0; --k) {\n                    if (dp[j][k] == 0 && k + val <= nums[j]) {\n                        dp[j][k + val] = 0;\n                    }\n                }\n            }\n            flag = true;\n            for (int j = 0; j < nums.length; ++j) {\n                if (dp[j][nums[j]] == -1) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) return i + 1;        \n        }\n        return -1;\n    }\n}","author":"randy","submissionId":"1575206457"},[]]},{"984":[{"id":"984","fileName":"1575206419.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        dp = [[False] * 1001 for _ in range(n)]\n        \n        for j in range(n):\n            dp[j][0] = True\n        \n        if all(num == 0 for num in nums):\n            return 0\n        \n        for k, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                for pos in range(1000, v - 1, -1):\n                    dp[j][pos] |= dp[j][pos - v]\n                for pos in range(nums[j] + 1, 1001):\n                    dp[j][pos] = False\n            \n            if all(dp[j][nums[j]] for j in range(n)):\n                return k + 1\n        \n        return -1    ","author":"Dhivyaa Murugesh","submissionId":"1575206419"},[]]},{"985":[{"id":"985","fileName":"1575206488.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ret = 0;\n        int m = queries.size();\n        for (int i = 0, e = nums.size(); i < e; ++i) {\n            int x = nums[i];\n            if (x == 0)\n                continue;\n            set<int> vals{x};\n            int j = 0;\n            for (; j < m; ++j) {\n                const auto& q = queries[j];\n                if (q[0] <= i && q[1] >= i) {\n                    for (auto v : vals) {\n                        int new_v = v - q[2];\n                        //cout << v << \" \" << new_v << \"n\";\n                        if (new_v >= 0) {\n\n                            vals.insert(new_v);\n                        }\n                    }\n                }\n\n                if (vals.count(0) == 1)\n                    break;\n            }\n            //cout << \"j=\" << j << \"n\";\n            if (j == m)\n                return -1;\n            ret = max(ret, j + 1);\n        }\n        return ret;\n    }\n};","author":"Weiming Zhao","submissionId":"1575206488"},[]]},{"986":[{"id":"986","fileName":"1575206398.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        res = 0\n        totalReduced = 0\n\n        @cache\n        def minQueries(i, bound, rem):\n            if rem == 0:\n                return i\n            if i == len(queries):\n                return math.inf\n            left, right = queries[i][0], queries[i][1]\n            if bound < left or bound > right:\n                return minQueries(i + 1, bound, rem)\n            if rem - queries[i][2] < 0:\n                return minQueries(i + 1, bound, rem)\n            elif rem - queries[i][2] == 0:\n                return i + 1\n            else:\n                return min(minQueries(i + 1, bound, rem), minQueries(i + 1, bound, rem - queries[i][2]))\n\n\n        for i, num in enumerate(nums):\n            res = max(res, minQueries(0, i, num))\n            if res == math.inf:\n                return -1\n        return res","author":"NIKONIKONI","submissionId":"1575206398"},[]]},{"987":[{"id":"987","fileName":"1575206529.txt","sourceCode":"class Solution {\nprivate:\n    #define INF (int)1e18\n    #define all(x) (x).begin(), (x).end()\n\n    using i64 = long long;\n    using u64 = unsigned long long;\n    \n    #ifdef LOCAL_RUN\n    #define Error(x...) { cout << \"(\" << #x << \")\" << \" = ( \"; printIt(x); }\n    #else\n    #define Error(x...) 42\n    #endif\n    template <typename T1> void printIt(T1 t1) { cout << t1 << \" )\" << endl; }\n    template <typename T1, typename... T2>\n    void printIt(T1 t1, T2... t2) { cout << t1 << \" , \"; printIt(t2...); }\n    // zx :)\n    #define popcount __builtin_popcountll\n    \npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        i64 n = nums.size();        \n        vector<bitset<1001>> dp(n, bitset<1001>().set(0)); \n\n        bool flag = true;\n        for (int j = 0; j < n; j++) {            \n            if (nums[j] != 0) {\n                flag = false;\n                break;\n            }        \n        }\n        if (flag) {\n            return 0;\n        }\n        for (int i = 0; i < queries.size(); i++) {\n            i64 left = queries[i][0], right = queries[i][1], val = queries[i][2];\n            for(int j = left; j <= right; j++) {                \n                dp[j] |= (dp[j] << val); \n                for (int pos = nums[j] + 1; pos < 1001; pos++) {                    \n                    dp[j].reset(pos);\n                }            \n            }\n            bool ok = true;\n            for (int j = 0; j < n; j++) {                \n                if (!dp[j].test(nums[j])) {\n                    ok = false;\n                    break;\n                }            \n            }\n            if (ok) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"Heisenberg","submissionId":"1575206529"},[]]},{"988":[{"id":"988","fileName":"1575206663.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<vector<pair<int, int>>> cover(n); // For each index, store (val, query index)\n        \n        // Preprocess which queries cover each index\n        for (int q_idx = 0; q_idx < m; ++q_idx) {\n            int l = queries[q_idx][0];\n            int r = queries[q_idx][1];\n            int val = queries[q_idx][2];\n            for (int i = l; i <= r; ++i) {\n                cover[i].emplace_back(val, q_idx);\n            }\n        }\n        \n        vector<int> x(n, -1); // x[i] will hold the last query index needed for nums[i]\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == 0) {\n                x[i] = -1;\n                continue;\n            }\n            \n            vector<pair<int, int>>& qs = cover[i];\n            unordered_map<int, int> dp;\n            dp[0] = -1; // Base case: sum 0 with no queries\n            \n            for (auto& p : qs) {\n                int val = p.first;\n                int idx = p.second;\n                unordered_map<int, int> new_dp(dp);\n                \n                for (auto& entry : dp) {\n                    int s = entry.first;\n                    int last = entry.second;\n                    int new_sum = s + val;\n                    if (new_sum > nums[i]) {\n                        continue; // Prune sums exceeding the target\n                    }\n                    auto it = new_dp.find(new_sum);\n                    if (it == new_dp.end() || idx < it->second) {\n                        new_dp[new_sum] = idx;\n                    }\n                }\n                \n                dp.swap(new_dp);\n            }\n            \n            if (!dp.count(nums[i])) {\n                return -1;\n            }\n            x[i] = dp[nums[i]];\n        }\n        \n        int max_x = -1;\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] != 0) {\n                if (x[i] == -1) {\n                    return -1;\n                }\n                if (x[i] > max_x) {\n                    max_x = x[i];\n                }\n            }\n        }\n        \n        return max_x == -1 ? 0 : max_x + 1;\n    }\n};","author":"Maria Moura","submissionId":"1575206663"},[]]},{"989":[{"id":"989","fileName":"1575206382.txt","sourceCode":"class Solution {\npublic:\n    \n    int dp[1001][1001];\n    \n    int func(int i,int j,int sum,int n,int m,vector<int>& nums, vector<vector<int>>& q){\n        if(sum==nums[i]) return 0;\n        if(i==n || j==m){\n            return 1e6;\n        }\n        if(dp[j][sum]!=-1) return dp[j][sum];\n        \n        int ans = 1e6;\n        \n        ans = min(ans,1+func(i,j+1,sum,n,m,nums,q));\n        if(q[j][0]<=i and q[j][1]>=i and q[j][2]+sum<=nums[i]){\n            ans = min(ans,1+func(i,j+1,sum+q[j][2],n,m,nums,q));\n        }\n        \n        return dp[j][sum] = ans;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n        int m = q.size();\n        \n        int ans = 0;\n        \n        for(int i=0;i<n;i++){\n            memset(dp,-1,sizeof(dp));\n            int curr = func(i,0,0,n,m,nums,q);\n            if(curr==1e6) return -1;\n            ans = max(ans,curr);\n        }\n        \n        return ans;\n    }\n};\n\n\n\n\n\n\n\n\n\n","author":"lomdu","submissionId":"1575206382"},[]]},{"990":[{"id":"990","fileName":"1575206528.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        # binary search for k\n        # nums len is only 10\n\n        n = len(nums)\n        vals = [[] for _ in range(n)]\n        for iq, query in enumerate(queries):\n            l, r, val = query\n            for i in range(l, r + 1):\n                vals[i].append((val, iq))\n        \n        # print(f'vals: {vals}')\n\n        @cache\n        def dp(nums_idx, k, curr_idx, target):\n            # print(nums_idx, k, curr_idx, target)\n            vls = vals[nums_idx]\n            if target == 0:\n                # print('2')\n                return True\n            if curr_idx >= len(vls) or vls[curr_idx][1] >= k:\n                # print('1')\n                return False\n            if target < 0:\n                # print('3')\n                return False\n            num = nums[i]\n\n            # skip\n            if dp(nums_idx, k, curr_idx + 1, target):\n                return True\n\n            # take\n            if dp(nums_idx, k, curr_idx + 1, target - vls[curr_idx][0]):\n                return True\n\n            return False\n                \n        def possible(k):\n            # check if subset of vals can equal num\n            for i in range(n):\n                if not dp(i, k, 0, nums[i]):\n                    # print(f'i={i} not possible with k={k}')\n                    return False\n            return True\n\n        left = 0\n        right = len(queries) + 1\n\n        found_ans = False\n        while left < right:\n            mid = (left + right) // 2\n            # print(f'BINARY SEARCH left={left}, right={right}, mid={mid}')\n            if possible(mid):\n                # print(f'{mid} was possible, setting right from {right} to {mid}')\n                right = mid\n                found_ans = True\n            else:\n                # print(f'{mid} was not possible, setting left from {left} to {mid}')\n                left = mid + 1\n            # print('n===========n')\n\n        dp.cache_clear()\n        return left if found_ans else -1\n            \n        ","author":"miqro","submissionId":"1575206528"},[]]},{"991":[{"id":"991","fileName":"1575206727.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        \n        int n = nums.size();\n        int m = queries.size();\n        \n        int sum = 0;\n        for(auto &i : nums) sum += i;\n        if(sum == 0) return 0;\n        \n        vector<int> dp(1001);\n        \n        auto get = [&](vector<int> &I, int x) ->int{\n            for(auto &i : dp) i = 0;\n            dp[0] = 1;\n            for(int i = 0; i < I.size(); i++){\n                int val = queries[I[i]][2];\n                for(int j = x; j >= val; j--) dp[j] |= dp[j - val];\n                if(dp[x]) return I[i];\n            }\n            return -1;\n        };\n        \n        int ans = 0;\n        for(int i = 0; i < n; i++){\n            vector<int> I;\n            for(int j = 0; j < m; j++)\n                if(i >= queries[j][0] and i <= queries[j][1]) I.push_back(j);\n            int res = get(I, nums[i]);\n            if(res == -1) return -1;\n            ans = max(ans, res + 1);\n        }\n        \n        return ans;\n        \n    }\n};","author":"KARAN SRIVASTAVA","submissionId":"1575206727"},[]]},{"992":[{"id":"992","fileName":"1575206680.txt","sourceCode":"class Solution {\n\n    int n;\n    List<Integer> ops;\n\n    int getMin(int pos, int val, Integer [][] dp){\n\n        if ( val == 0){\n            return pos-1;\n        }\n\n        if ( pos == ops.size()){\n            return Integer.MAX_VALUE;\n        }\n\n        if ( dp[pos][val] != null){\n            return dp[pos][val];\n        }\n        \n        int x1 = getMin(pos + 1, val, dp);\n        if ( ops.get(pos) <= val){\n            x1 =  Math.min(x1, getMin(pos + 1, val - ops.get(pos), dp));\n        }\n\n        return dp[pos][val] = x1;\n        \n    }\n\n    int find(List<Integer> opSeq, int val){\n\n        // we can include or exclude this operation\n        ops = opSeq;\n        Integer [][] dp = new Integer [opSeq.size()][val+1];\n        int ret = getMin(0, val, dp);\n        // System.out.println(opSeq + \" with val \" + val + \" returned \" + ret);\n        return ret;\n    }\n    \n    public int minZeroArray(int[] nums, int[][] queries) {\n        n = nums.length;\n        List<Integer> [] decs = new ArrayList [n];\n        List<Integer> [] appliedAt = new ArrayList [n];\n        for ( int i = 0 ; i < n ; i++){\n            decs[i] = new ArrayList<>();\n            appliedAt[i] = new ArrayList<>();\n        }\n\n        int idq = 1;\n        for ( int [] q : queries){\n            for ( int i = q[0]; i <= q[1]; i++){\n                decs[i].add(q[2]);\n                appliedAt[i].add(idq);\n            }\n            idq++;\n        }\n\n        int ans = 0;\n\n        for ( int i = 0 ; i < n ; i++){\n            if ( nums[i] == 0 ){\n                ans = Math.max(ans, 0);\n                continue;\n            }\n            int step = find(decs[i], nums[i]); // Minimum number of operation require to make it zero\n            if ( step == Integer.MAX_VALUE){\n                return -1; // not possible\n            }\n            ans = Math.max(ans, appliedAt[i].get(step));\n        }\n            \n        return ans;\n    }\n}","author":"rana_1234","submissionId":"1575206680"},[]]},{"993":[{"id":"993","fileName":"1575206778.txt","sourceCode":"class Xavlikor {\n    void xklm() {\n        int x = 0;\n        for (int i = 0; i < 10; i++) {\n            if (i % 2 == 0) {\n                x += i * 2 - 1;\n            } else {\n                x -= i * 3;\n            }\n        }\n    }\n}\n\nclass Zimvexar {\n    void zpxm() {\n        String dummy = \"NoiseStart\";\n        for (int i = 0; i < 5; i++) {\n            if (dummy.length() % 2 == 0) {\n                dummy += i + \"Extra\";\n            } else {\n                dummy = \"Reset\" + dummy;\n            }\n        }\n    }\n}\n\nclass Solution {\n    private boolean blxivar = false;\n    private boolean zmoxar = true;\n    private int pxarvin = 0;\n\n    private void kleriztan() {\n        pxarvin++;\n        if (pxarvin % 3 == 0) {\n            pxarvin *= 2;\n        } else {\n            pxarvin -= 3;\n        }\n    }\n\n    private void vlinzakor() {\n        pxarvin--;\n        int temp = 100;\n        do {\n            temp -= 7;\n        } while (temp > 0);\n    }\n\n    private void zimlexar() {\n        blxivar = !blxivar;\n        for (int i = 0; i < 10; i++) {\n            if (blxivar && i % 2 == 0) {\n                pxarvin += i * 2;\n            } else if (!blxivar && i % 3 == 0) {\n                pxarvin -= i * 3;\n            }\n        }\n    }\n\n    public int minZeroArray(int[] vaxzlefin, int[][] juveximrab) {\n        int xanibukal = vaxzlefin.length;\n        boolean[][] dp = new boolean[xanibukal][1001];\n\n        for (int j = 0; j < xanibukal; j++) {\n            dp[j][0] = true;\n            kleriztan();\n        }\n\n        boolean ranikastor = true;\n        for (int j = 0; j < xanibukal; j++) {\n            if (vaxzlefin[j] != 0) {\n                ranikastor = false;\n                vlinzakor();\n                break;\n            }\n        }\n\n        if (ranikastor) return 0;\n\n        for (int xilofran = 0; xilofran < juveximrab.length; xilofran++) {\n            int lokastiv = juveximrab[xilofran][0];\n            int remavind = juveximrab[xilofran][1];\n            int vinzarlex = juveximrab[xilofran][2];\n\n            for (int j = lokastiv; j <= remavind; j++) {\n                for (int pos = 1000; pos >= vinzarlex; pos--) {\n                    if (dp[j][pos - vinzarlex]) {\n                        dp[j][pos] = true;\n                        zimlexar();\n                    }\n                }\n            }\n\n            boolean zelamixor = true;\n            for (int j = 0; j < xanibukal; j++) {\n                if (!dp[j][vaxzlefin[j]]) {\n                    zelamixor = false;\n                    break;\n                }\n            }\n\n            if (zelamixor) return xilofran + 1;\n        }\n\n        return -1;\n    }\n}\n\nclass Yavxar {\n    void ypxm() {\n        int count = 0;\n        for (int i = 0; i < 20; i++) {\n            if (count % 2 == 0) {\n                count += 3;\n            } else {\n                count += 1;\n            }\n        }\n    }\n}","author":"Nithish Kumar","submissionId":"1575206778"},[]]},{"994":[{"id":"994","fileName":"1575206786.txt","sourceCode":"class Solution {\npublic:\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int ans = 0;\n        for (int i = 0; i < n; i++){\n            // set<int> choose;\n            int target = nums[i];\n            if (nums[i] == 0) continue;\n            vector<bool> choose(target + 1);\n            choose[0] = true;\n            \n            int j;\n            for (j = 0; j < queries.size(); j++){\n                if (queries[j][0] > i || queries[j][1] < i) continue;\n                vector<bool> tmp = choose;\n                for (int k = 0; k < choose.size(); k++){\n                    if (k + queries[j][2] >= choose.size()) break;\n                    if (choose[k])\n                        tmp[k + queries[j][2]] = true;\n                }\n                choose = tmp;\n                if (choose[target])\n                    break;\n            }\n            if (choose[target])\n                ans = max(ans, j + 1);\n            else{\n                // cout << i << 'n';\n                return -1;\n            }\n        }\n        return ans;\n    }\n};","author":"jerry5841314","submissionId":"1575206786"},[]]},{"995":[{"id":"995","fileName":"1575206917.txt","sourceCode":"class Solution {\nint n,m;\npublic:\n    bool check(vector<int>& nums, vector<vector<int>>& qe,int mid){\n        for(int i=0;i<n;i++){\n            vector<int>val;\n            for(int j=0;j<mid+1;j++){\n                if(qe[j][0]<=i&&qe[j][1]>=i){\n                    val.push_back(qe[j][2]);\n                }\n            }\n            queue<pair<int,int>>q;\n            q.push({nums[i],0});\n            bool flag=0;\n            // int ind=0;\n            int len=val.size();\n            set<pair<int,int>>us;\n            while(!q.empty()){\n                int t=q.front().first;\n                int ind=q.front().second;\n                q.pop();\n                // cout<<t<<\" \";\n                 if(t==0){\n                    flag=1;break;\n                }\n                if(t<0||ind>=len||us.find({t,ind})!=us.end()) continue;\n               \n                us.insert({t,ind});\n                q.push({t-val[ind],ind+1});\n                q.push({t,ind+1});\n                // ind++;\n            }\n            // cout<<endl;\n            if(!flag) return 0;\n        }\n        return 1;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        n=nums.size();\n        m=q.size();\n        int s=0,e=m-1;\n        int mid=(s+e)/2;\n        bool f=0;\n        for(int i=0;i<n;i++){\n            if(nums[i]!=0) f=1;\n        }\n        if(!f) return 0;\n        int ans=-1;\n        while(s<=e){\n            if(check(nums,q,mid)){\n                ans=mid+1;\n                e=mid-1;\n            }\n            else s=mid+1;\n            mid=(s+e)/2;\n        }\n        return ans;\n    }\n};","author":"Utkarsh Raghuvanshi","submissionId":"1575206917"},[]]},{"996":[{"id":"996","fileName":"1575206830.txt","sourceCode":"class Solution {\npublic:\n    int valid(vector<int> nums, vector<vector<int>>& q,int f){\n        if(f>=q.size()){\n            return -1;\n        }\n        int sum=0;\n        for(int i : nums){\n            sum+=i;\n        }\n        if(sum==0){\n            return f;\n        }\n        int n = (q[f][1]-q[f][0])+1;\n        for (int i = 0; i < (1 << n); i++) {\n            vector<int> subset;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) != 0) {\n                    subset.push_back(j+q[f][0]);\n                }\n            }\n            for(int &k : subset){\n                nums[i]-=q[f][2];\n            }\n            int val = valid(nums,q,f+1);\n            if(val!=-1){\n                return val;\n            }\n            for(int &k : subset){\n                nums[i]+=q[f][2];\n            }\n        }\n        return -1;\n    }\n    int minZeroArray(vector<int>& a, vector<vector<int>>&b) {\n        int c = a.size(), d = b.size();\n        vector<bitset<1001>> e(a.size()), z(a.size());\n        for (int i = 0; i < a.size(); i++) {\n            e[i].reset();\n            e[i].set(0, true);\n            z[i].reset();\n            for (int j = 0; j <= a[i]; j++){\n              z[i].set(j, true);  \n            } \n        }\n        bool fFlag = true;\n        for (int i = 0; i < c; i++) {\n            if (a[i] != 0) { \n                fFlag = false; break;\n            }\n        }\n        if (fFlag) return 0;\n        for (int i = 0; i < d; i++) {\n            int l = b[i][0]; \n            int r = b[i][1];\n            int m = b[i][2];\n            for (int j = l; j <= r; j++) e[j] |= ((e[j] << m) & z[j]);\n            bool ok = true;\n            for (int j = 0; j < c; j++) {\n                if (!e[j].test(a[j])) { ok = false; break; }\n            }\n            if (ok) \n                return i + 1;\n        }\n        return -1;\n    }\n};","author":"Dhanush krishna","submissionId":"1575206830"},[]]},{"997":[{"id":"997","fileName":"1575206937.txt","sourceCode":"class Solution {\n    int dp[1005][1005];\n    bool dfs(vector<int>& nums, int val, int n, int idx = 0) {\n        if(idx == n)\n            return val == 0;\n\n        if(dp[idx][val] != -1)\n            return dp[idx][val];\n        \n        bool ans = dfs(nums, val, n, idx + 1);\n\n        if(val >= nums[idx]) {\n            ans |= dfs(nums, val - nums[idx], n, idx + 1);\n        }\n\n        return dp[idx][val] = ans;\n    }\n    bool possible(vector<int>& nums, vector<vector<int>>& queries, int mid) {\n        int n = nums.size();\n\n        vector<vector<int>> red(n);\n        for(int i = 0; i <= mid; i++) {\n            for(int j = queries[i][0]; j <= queries[i][1]; j++) {\n                if(queries[i][2] <= nums[j])\n                    red[j].push_back(queries[i][2]);\n            }\n        }\n\n        for(int i = 0; i < n; i++) {\n            memset(dp, -1, sizeof(dp));\n            bool isAvailable = dfs(red[i], nums[i], red[i].size());\n\n            if(!isAvailable)\n                return false;\n        }\n\n        return true;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        bool okay = true;\n        for(auto x:nums) {\n            if(x) okay = false;\n        }\n\n        if(okay) return 0;\n        int l = 0, r = queries.size() - 1, ans = -1;\n\n        while(l <= r) {\n            int mid = (l + r) / 2;\n\n            if(possible(nums, queries, mid)) {\n                ans = mid + 1;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n\n        return ans;\n    }\n};","author":"Arjun Grover","submissionId":"1575206937"},[]]},{"999":[{"id":"999","fileName":"1575207054.txt","sourceCode":"class Solution {\n    static Boolean f(int n, int target, ArrayList<Integer> temp, Boolean[][] memo) {\n        if (target == 0) return true; \n        if (n == 0) return false;     \n\n        if (memo[n][target] != null) {\n            return memo[n][target];\n        }\n\n        if (temp.get(n-1) <= target) {\n            if (f(n-1, target - temp.get(n-1), temp, memo)) {\n                memo[n][target] = true;\n                return true;\n            }\n        }\n\n        memo[n][target] = f(n-1, target, temp, memo);\n        return memo[n][target];\n    }\n    public boolean check(int a[], int q[][], int mid) {\n        ArrayList<ArrayList<Integer>> list = new ArrayList<>();\n        for (int i = 0; i < a.length; i++) {\n            list.add(new ArrayList<>());\n        }\n        for (int i = 0; i <= mid; i++) {\n            for (int j = q[i][0]; j <= q[i][1]; j++) {\n                list.get(j).add(q[i][2]);\n            }\n        }\n        for (int i = 0; i < a.length; i++) {\n            ArrayList<Integer> temp = list.get(i);\n            Boolean[][] memo = new Boolean[temp.size() + 1][a[i] + 1];\n            if (!f(temp.size(), a[i], temp, memo)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    public int minZeroArray(int[] a, int[][] q) {\n        int n=a.length;\n        boolean flag=true;\n        for(int i=0;i<n;i++){\n            if(a[i] != 0){\n                flag=false;\n                break;\n            }\n        }\n        if(flag) return 0;\n        int l=0;\n        int h=q.length-1;\n        int ans=-1;\n        while(l <= h){\n            int mid=(l+h)/2;\n            if(check(a,q,mid)){\n                ans=mid+1;\n                h=mid-1;\n            }else{\n                l=mid+1;\n            }\n        }\n        return ans;\n    }\n}","author":"IamVengeance","submissionId":"1575207054"},[]]},{"1001":[{"id":"1001","fileName":"1575207096.txt","sourceCode":"int dp[11][1010];\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size(), m = q.size();\n        bool allzero = true;\n        for(int i = 0; i < n; i++) {\n            if(nums[i] != 0)\n                allzero = false;\n        }\n        if(allzero)\n            return 0;\n        \n        memset(dp, 0, sizeof(dp));\n        for(int j = 0; j < n; j++) {\n            dp[j][0] = 1;\n        }\n\n        for(int i = 0; i < m; i++) {\n            int l = q[i][0], r = q[i][1], val = q[i][2];\n            for(int j = 0; j < n; j++) {\n                if(l > j || r < j)\n                    continue;\n                int num = nums[j];\n                if(dp[j][num])\n                    continue;\n\n                for(int k = num; k - val >= 0; k--) {\n                    if(dp[j][k - val])\n                        dp[j][k] = true;\n                }\n            }\n\n            bool good = true;\n            for(int j = 0; j < n; j++) {\n                int num = nums[j];\n                good = good && dp[j][num];\n            }\n            if(good)\n                return i + 1;\n        }\n        return -1;\n    }\n};","author":"HFDnpkp1cs","submissionId":"1575207096"},[]]},{"1002":[{"id":"1002","fileName":"1575207537.txt","sourceCode":"class Solution {\npublic:\n    bool chk(vector<vector<pair<int,int>>>&v,int m,vector<int>&nums){\n        for(int i=0;i<nums.size();++i){\n            vector<bool>vv(nums[i]+1,0);\n            vv[0]=1;\n            for(auto &[k,e]:v[i]){\n                if(k<m){\n                    for(int j=nums[i];j>=e;--j){\n                        if(vv[j-e]){\n                            vv[j]=1;\n                        }\n                    }\n                } else {\n                    break;\n                }\n            }\n            if(!vv[nums[i]]) return 0;\n        }\n        return 1;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<vector<pair<int,int>>> v(nums.size());\n        for(int i=0;i<queries.size();++i){\n            auto e=queries[i];\n            for(int j=e[0];j<=e[1];++j){\n                v[j].push_back({i,e[2]});\n            }\n        }\n        int l=0,r=queries.size()+1,ans=-1;\n\n        while(l<r){\n            int m=(l+r)/2;\n            if(chk(v,m,nums)){\n                r=m;\n                ans=m;\n            }else {\n                l=m+1;\n            }\n\n        }\n\n        return ans;\n    }\n};","author":"ads169573","submissionId":"1575207537"},[]]},{"1003":[{"id":"1003","fileName":"1575207443.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        result = 0\n        for i, num in enumerate(nums):\n            if num == 0:\n                continue\n            c = [(j, q[2]) for j, q in enumerate(queries) if q[0] <= i <= q[1] and num >= q[2]]\n            # print(c)\n            sums = set()\n            sums.add(0)\n            found = False\n            for j, q in c:\n                if q == num:\n                    result = max(result, j + 1)\n                    found = True\n                    break\n                for s in set(sums):\n                    n = s + q\n                    if n == num:\n                        result = max(result, j + 1)\n                        found = True\n                        break\n                    if n < num:\n                        sums.add(n)\n                if found:\n                    break\n            if not found:\n                return -1\n        return result\n                \n            ","author":"seanzhoujobs","submissionId":"1575207443"},[]]},{"1004":[{"id":"1004","fileName":"1575207478.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        q = len(queries)\n        n = len(nums)\n        d = {}\n        for i in range(n):\n            if nums[i] != 0:\n                d[i] = set()\n                d[i].add(0)\n        for i in range(q):\n            if not d:\n                return i\n            for j in range(queries[i][0],queries[i][1]+1):\n                if j in d:\n                    t = []\n                    for k in d[j]:\n                        t.append(k+queries[i][2])\n                    d[j].update(t)\n                    if nums[j] in d[j]:\n                        d.pop(j)\n        if not d:\n            return q\n        return -1\n            \n            ","author":"latj","submissionId":"1575207478"},[]]},{"1005":[{"id":"1005","fileName":"1575207749.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        def pos1(dd, x):\n            #print(dd,x)\n            arr = [False]*1001\n            arr[0] = True\n            for k,v in dd.items():\n                for i in range(v):\n                    for j in reversed(range(k,1001)):\n                        arr[j] |= arr[j-k]\n                        if arr[x]:\n                            return True\n            return arr[x]\n\n        def pos(k):\n            dd = collections.defaultdict(int)\n            ll = []\n            for i,j,v in queries[:k]:\n                ll.append((i,v,+1))\n                ll.append((j+1,v,-1))\n            ll = sorted(ll, reverse=True)\n            for i,x in enumerate(nums):\n                while ll and ll[-1][0]<=i:\n                    _,v,add = ll.pop()\n                    dd[v] += add\n                if pos1(dd,x):\n                    continue\n                return False\n            return True\n\n        class sol:\n            def __getitem__(self, i):\n                return pos(i)\n\n        s = sol()\n        j = bisect.bisect_left(s,True,0,len(queries)+2)\n        return -1 if s[j]==False else j","author":"osxyz","submissionId":"1575207749"},[]]},{"1006":[{"id":"1006","fileName":"1575207777.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int max_num = *max_element(nums.begin(), nums.end());\n        vector<vector<bool>> mem(nums.size(), vector<bool>(max_num + 1, false));\n        \n        // Find zero elements\n        for (int i = 0; i < nums.size(); i++) {\n            mem[i][0] = true;\n        }\n        int done = count(nums.begin(), nums.end(), 0);\n        if (done == nums.size()) return 0;\n\n        // Apply queries\n        for (int k = 0; k < queries.size(); k++) {\n            // Update all numbers in range\n            for (int i = queries[k][0]; i <= queries[k][1]; i++) {\n                bool was_done = mem[i][nums[i]];\n\n                // Move backward in memory\n                int val = queries[k][2];\n                for (int j = max_num; j >= val; j--) {\n                    if (mem[i][j - val]) mem[i][j] = true;\n                }\n\n                // Check if there is a new combination equal to nums[i]\n                if (!was_done && mem[i][nums[i]]) {\n                    done++;\n                }\n            }\n\n\n            if (done == nums.size()) {\n                return k + 1;\n            }\n        }\n\n        return -1;\n    }\n};","author":"Hieu","submissionId":"1575207777"},[]]},{"1007":[{"id":"1007","fileName":"1575207786.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int i,j,n=nums.size(),m=queries.size(),ans=INT_MIN;\n        int num,l,r,val;\n\n        for(i=0;i<n;i++){\n            num=nums[i];\n            unordered_set<int> myset1,myset2;\n            myset1.insert(0);\n\n            //check when num is 0\n            if(num == 0){\n                ans=max(ans,0);\n                continue;\n            }\n                \n\n            for(j=0;j<m;j++){\n                l=queries[j][0];\n                r=queries[j][1];\n                val=queries[j][2];\n\n                //out of range\n                if(i>r || i<l)\n                    continue;\n\n                //update reachable states\n                for(auto itr:myset1){\n                    myset2.insert(itr);\n                    if(itr+val <= num)\n                        myset2.insert(itr+val);\n                }\n\n                myset1=myset2;\n                myset2.clear();\n\n                //we can reach num\n                if(myset1.count(num))\n                    break;\n            }\n\n            //not possible case\n            if(j==m){\n                return -1;\n            }\n            ans=max(ans,j+1);\n\n        }\n\n\n        return ans;\n    }\n};","author":"devpatel123","submissionId":"1575207786"},[]]},{"1008":[{"id":"1008","fileName":"1575208044.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        diffs = defaultdict(list)\n        for qi, (a, b, v) in enumerate(queries):\n            for i in range(a, b + 1):\n                diffs[i].append((v, qi))\n        res = -1\n        for i in range(n): \n            if nums[i] == 0:\n                res = max(res, 0)\n                continue \n            # print(i, diffs[i])\n            v = {nums[i]}\n            diffs[i].sort(key=lambda x: x[1])\n            for diff, qi in diffs[i]:\n                update = set(v)\n                for val in v:\n                    if val >= diff:\n                        update.add(val - diff)\n                v = update\n                # print(v)\n                if 0 in v: \n                    res = max(res, qi + 1)\n                    break\n            if 0 not in v:\n                return -1\n            # print(res)\n        return res\n","author":"Burger Monstah","submissionId":"1575208044"},[]]},{"1009":[{"id":"1009","fileName":"1575208052.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& arr, vector<vector<int>>& ops) {\n        int n = arr.size();\n        vector<vector<bool>> dp(n, vector<bool>(1001, false));\n\n        for (int i = 0; i < n; i++) dp[i][0] = true;\n\n        if (isAllZero(arr)) return 0;\n\n        for (int idx = 0; idx < ops.size(); idx++) {\n            if (applyOp(arr, dp, ops[idx])) {\n                return idx + 1;\n            }\n        }\n\n        return -1;\n    }\n\nprivate:\n    bool isAllZero(const vector<int>& arr) {\n        for (int val : arr) {\n            if (val) return false;\n        }\n        return true;\n    }\n\n    bool applyOp(vector<int>& arr, vector<vector<bool>>& dp, const vector<int>& op) {\n        int l = op[0], r = op[1], v = op[2];\n\n        for (int i = l; i <= r; i++) {\n            for (int j = 1000 - v; j >= 0; j--) {\n                if (dp[i][j]) {\n                    dp[i][j + v] = true;\n                }\n            }\n            for (int p = arr[i] + 1; p < 1001; p++) dp[i][p] = false;\n        }\n\n        for (int i = 0; i < arr.size(); i++) {\n            if (!dp[i][arr[i]]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n","author":"neelesh404","submissionId":"1575208052"},[]]},{"1010":[{"id":"1010","fileName":"1575207790.txt","sourceCode":"class Solution {\n    public int dp(int ele, ArrayList<Integer> queries, ArrayList<Integer> ind) {\n        if (ele == 0)\n            return 0;\n\n        // System.out.println(queries);\n        // System.out.println(ind);\n        \n        int n = queries.size();\n        boolean[][] dp = new boolean[n + 1][ele + 1];\n        \n        // for (int i = 0; i <= n; i++)\n        //     Arrays.fill(dp[i], Integer.MAX_VALUE);\n        \n        dp[0][ele] = true;\n        \n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= ele; j++) {\n                if (j + queries.get(i - 1) <= ele && dp[i - 1][j + queries.get(i - 1)]) {\n                    dp[i][j] = true;\n                }\n                dp[i][j] = dp[i][j] || dp[i - 1][j];\n            }\n        }\n        \n        for (int i = 1; i <= n; i++) {\n            if (dp[i][0])\n                return ind.get(i - 1) + 1;\n        }\n        return -1;\n    }\n    // public boolean checker(int[] nums, int[][] queries, int mid)\n    // {\n    //     int[] diff = new int[nums.length+1];\n    //     for(int i=0;i<=mid;i++)\n    //         {\n    //             diff[queries[i][0]] -= queries[i][2];\n    //             diff[queries[i][1]+1] += queries[i][2];\n    //         }\n\n    //     for(int i=1;i<nums.length;i++)\n    //         diff[i]+=diff[i-1];\n\n    //     for(int i=0;i<nums.length;i++)\n    //         {\n    //             if(nums[i] + diff[i] != 0)\n    //                 return false;\n    //         }\n    //     return true;\n    // }\n    public int minZeroArray(int[] nums, int[][] queries) {\nint ans1 = 0;\n        for(int i=0;i<nums.length;i++)\n            {\n                ArrayList<Integer> val = new ArrayList<>();\n                ArrayList<Integer> ind = new ArrayList<>();\n                for(int j=0;j<queries.length;j++)\n                    {\n                        if(i>=queries[j][0] && i<=queries[j][1])\n                        {val.add(queries[j][2]);\n                        ind.add(j);}\n                    }\n\n                int ans = dp(nums[i], val, ind);\n                if(ans == -1)\n                    return -1;\n                ans1=Math.max(ans, ans1);\n                \n            }\n        // if(ans == 0)\n        return ans1;\n        \n    }\n}","author":"tushar19280","submissionId":"1575207790"},[]]},{"1011":[{"id":"1011","fileName":"1575208135.txt","sourceCode":"class Solution {\npublic:\n    const int INF = INT_MAX / 2; \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& qs) {\n        int ret = 0;\n        for(int i = 0;i<nums.size();i++) {\n            vector<int> xs; \n            xs.push_back(0);\n            for(int j = 1;j<=qs.size();j++) {\n                auto& q = qs[j-1];\n                if(q[0] <= i && i <= q[1]) {\n                    xs.push_back(q[2]);\n                } else {\n                    xs.push_back(0);\n                }\n            }\n            // cout<<\"i= \"<<i<<\" xs = [\";\n            // for(int x : xs) {\n            //     cout<<x<<\" \";\n            // }\n            // cout<<\"]\"<<endl;\n            const int V = nums[i];\n            vector<vector<int>> dp(xs.size(), vector<int>(V + 1, INF));\n            for(int i = 0;i<dp.size();i++) {\n                dp[i][0] = 0;\n            }\n            \n            for(int i = 1;i<dp.size();i++) {\n                //cout<<\"i- \"<<i<<endl;\n                for(int j = 1;j<=V;j++) {\n                    //cout<<\"i= \"<<i<<\" j= \"<<j<<\" xs[i]= \"<<xs[i]<<endl;\n                    dp[i][j] = dp[i-1][j]; \n                    if(j >= xs[i]) {\n                        int pre = dp[i-1][j - xs[i]];\n                        //cout<<\"i= \"<<i<<\" j= \"<<j<<\" pre= \"<<pre<<endl;\n                        dp[i][j] = min(dp[i][j], max(i, pre));\n                    }\n                }\n            }\n            \n            //cout<<\"i= \"<<i<<\" nums[i]= \"<<nums[i]<<\" dp: \"<<endl;\n            // for(int i = 0;i<dp.size();i++) {\n            //     for(int j = 0;j<dp[i].size();j++) {\n            //         cout<<dp[i][j]<<\" \";\n            //     }\n            //     cout<<endl;\n            // }\n            \n            int res = dp[dp.size()-1][nums[i]];\n            //cout<<\"i= \"<<i<<\" nums[i]= \"<<nums[i]<<\" res= \"<<res<<endl;\n            ret = max(ret, res);\n            if(ret >= INF) {\n                return -1;\n            }\n        }\n        return ret; \n    }\n};","author":"Hanzhou Tang","submissionId":"1575208135"},[]]},{"1012":[{"id":"1012","fileName":"1575208417.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        int maxK = -1;\n        \n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            if (target == 0) continue;\n            \n            List<int[]> applicable = new ArrayList<>();\n            for (int j = 0; j < m; j++) {\n                int l = queries[j][0], r = queries[j][1];\n                if (i >= l && i <= r) {\n                    applicable.add(new int[]{j, queries[j][2]});\n                }\n            }\n            \n            if (applicable.isEmpty()) {\n                return -1;\n            }\n            \n            Set<Integer> sumPossible = new HashSet<>();\n            sumPossible.add(0);\n            int earliestJ = -1;\n            \n            for (int[] q : applicable) {\n                int j = q[0], val = q[1];\n                Set<Integer> newSums = new HashSet<>(sumPossible);\n                for (int s : sumPossible) {\n                    newSums.add(s + val);\n                }\n                if (newSums.contains(target)) {\n                    earliestJ = j;\n                    break;\n                }\n                sumPossible = newSums;\n            }\n            \n            if (earliestJ == -1) {\n                return -1;\n            }\n            if (earliestJ > maxK) {\n                maxK = earliestJ;\n            }\n        }\n        \n        return maxK == -1 ? 0 : maxK + 1;\n    }\n}","author":"jahnvi_7777","submissionId":"1575208417"},[]]},{"1013":[{"id":"1013","fileName":"1575208437.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n\n        # Initialize DP as sets\n        dp = [set() for _ in range(n)]\n        for j in range(n):\n            dp[j].add(0)\n\n        # Check if all elements are zero initially\n        if all(num == 0 for num in nums):\n            return 0\n\n        for k, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                # Update DP using new values\n                new_values = {x + v for x in dp[j]}\n                dp[j].update(new_values)\n\n                # Reset values greater than nums[j]\n                dp[j] = {x for x in dp[j] if x <= nums[j]}\n\n            # Check if all values are achieved\n            if all(nums[j] in dp[j] for j in range(n)):\n                return k + 1\n\n        return -1\n","author":"officialamit558","submissionId":"1575208437"},[]]},{"1014":[{"id":"1014","fileName":"1575208193.txt","sourceCode":"class Solution {\npublic:\n    int solve(int num, int k, int i, vector<vector<int>>& queries , vector<vector<int>>& dp){\n        if(num == 0) return 1;\n        if(num < 0 || k < 0) return 0;\n        if(dp[num][k] != -1) return dp[num][k];\n        \n        dp[num][k] = solve(num, k - 1, i, queries, dp);\n        if(i >= queries[k][0] && i <= queries[k][1]){\n            dp[num][k] |= solve(num - queries[k][2], k - 1, i, queries, dp);\n        }\n        return dp[num][k];\n    }\n    bool isPossible(vector<int>& nums, vector<vector<int>>& queries, int mid){\n        bool res = true;\n        for(int i = 0; i < nums.size(); i++){\n            vector<vector<int>> dp(nums[i] + 1, vector<int> (mid, -1));\n            res &= solve(nums[i], mid-1, i, queries, dp);\n            if(!res) return res;\n        }\n        return res;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int start = 0, end = queries.size();\n        int res = -1;\n        while(start < end){\n            int mid = start + (end - start)/2;\n            if(isPossible(nums,queries,mid)) {\n                end = mid - 1;\n                res = mid;\n            }\n            else start = mid + 1;\n        }\n        if(isPossible(nums,queries,start)) res = start;\n        return res;\n    }\n};","author":"Mohit_is_back","submissionId":"1575208193"},[]]},{"1015":[{"id":"1015","fileName":"1575208433.txt","sourceCode":"#include <vector>\n#include <bitset>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& array, vector<vector<int>>& operations) {\n        int length = array.size();\n        vector<bitset<1001>> state(length);\n        for (int i = 0; i < length; i++) \n            state[i].set(0);\n        \n        bool allElementsZero = true;\n        for (int value : array) {\n            if (value != 0) {\n                allElementsZero = false;\n                break;\n            }\n        }\n        if (allElementsZero) return 0;\n        \n        \n        for (int op = 0; op < operations.size(); op++) {\n            int start = operations[op][0];\n            int end = operations[op][1];\n            int increment = operations[op][2];\n            \n            for (int i = start; i <= end; i++) {\n                bitset<1001> temp = state[i];\n                temp = shiftLeft(temp, increment);\n                state[i] |= temp;\n                \n                for (int pos = array[i] + 1; pos < 1001; pos++) {\n                    state[i].reset(pos);\n                }\n            }\n            \n            bool targetAchieved = true;\n            for (int i = 0; i < length; i++) {\n                if (!state[i].test(array[i])) {\n                    targetAchieved = false;\n                    break;\n                }\n            }\n            \n            if (targetAchieved) return op + 1;\n        }\n        \n        return -1;\n    }\n\n    int solve(vector<int>& array , int b){\n        return array[0]+b;\n    }\n    \npublic:\n    bitset<1001> shiftLeft(const bitset<1001>& bitSet, int shift) {\n        bitset<1001> shifted;\n        for (int i = 0; i < 1001 - shift; i++) {\n            if (bitSet.test(i)) {\n                shifted.set(i + shift);\n            }\n        }\n        return shifted;\n    }\n};","author":"ADITYA PANDE","submissionId":"1575208433"},[]]},{"1016":[{"id":"1016","fileName":"1575208557.txt","sourceCode":"class Solution {\n    int fans=100000;\n    int sumReq=-1;\n    int dp[][];\n    int go(int ind, int st, int qi, int[][] qeuries){\n        if(st==sumReq){\n            // fans = Math.min(fans,ind);\n            return ind;\n        }\n        if(st>sumReq)return Integer.MAX_VALUE;\n        if(ind>=qeuries.length)return Integer.MAX_VALUE;\n        if(dp[ind][st]!=-1)return dp[ind][st];\n        if(qi >= qeuries[ind][0] && qi <= qeuries[ind][1])\n            return dp[ind][st] = Math.min(go(ind+1,st+qeuries[ind][2],qi,qeuries), \n                go(ind+1,st,qi,qeuries));\n        else return dp[ind][st] = go(ind+1,st,qi,qeuries);\n    }\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int ind=0;\n        int ans=-1;\n        // dp[i][sumtaken] - till i, sumtaken, \n        // returns trueor false if till i, we can make sumtaken\n        // dp[i][st] = dp[i+1][st+a[i]] || dp[i+1][st]\n        // if i==n return st==reqSum\n        int n = queries.length;\n        int mx=-1;\n        for(int x:nums)mx=Math.max(mx,x);\n        for(int x:nums){\n            sumReq = x;\n            // fans=100000;\n            dp = new int[n+1][mx+1];\n            for(int i=0;i<=n;i++){\n                for(int j=0;j<=mx;j++)dp[i][j]=-1;\n            }\n            fans = go(0,0,ind,queries);\n            // fans = dp[0][0];\n            // System.out.println(ind + \" \" + fans);\n            if(fans!=Integer.MAX_VALUE)ans = Math.max(ans,fans);\n            else return -1;\n            ind++;\n        }\n        return ans;\n    }\n}","author":"ppwani","submissionId":"1575208557"},[]]},{"1017":[{"id":"1017","fileName":"1575208559.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int mx = *max_element(nums.begin(),nums.end());\n        vector<vector<int>> dp(queries.size(),vector<int>(mx+1,0));\n        reverse(queries.begin(),queries.end());\n        int ans = 0;\n        for(int i = 0;i < nums.size();i++){\n            int req = nums[i];\n            if(!req) continue;\n            int currK = -1;\n            dp = vector<vector<int>>(queries.size()+1,vector<int>(req+1,0));\n            for(int j = 0;j <= queries.size();j++) dp[j][0] = 1;\n            for(int j = queries.size()-1;j >= 0;j--){\n                for(int x = 0;x < req+1;x++){\n                    // Take\n                    if(queries[j][0]<=i && queries[j][1]>=i && queries[j][2]<=x)\n                    dp[j][x] = max(dp[j][x],dp[j+1][x-queries[j][2]]);\n                    // notTake    \n                    dp[j][x] = max(dp[j][x],dp[j+1][x]);\n                }\n                if(dp[j][req] == 1){\n                    currK = j;\n                    break;\n                }\n            }\n            if(currK == -1) return -1;\n            ans = max(ans,(int)queries.size()-currK);\n        }\n        return ans;\n    }\n};","author":"Parth Vijay","submissionId":"1575208559"},[]]},{"1018":[{"id":"1018","fileName":"1575208465.txt","sourceCode":"class Solution {\n\nprivate:\n    \n    int getMinQuery(vector<int>& arr, int i, int sumTillNow, vector<vector<int>>& dp) {\n        \n        if (sumTillNow == 0) {\n            return 0;\n        }\n        \n        if (i >= arr.size()) {\n            return INT_MAX;\n        }\n        \n        if (sumTillNow - arr[i] == 0) {\n            return i+1;\n        }\n        \n        if (dp[i][sumTillNow] != -1) {\n            return dp[i][sumTillNow];\n        }\n        \n        int op1 = getMinQuery(arr, i+1, sumTillNow, dp);\n        int op2 = INT_MAX;\n        \n        if (sumTillNow - arr[i] > 0) {\n            op2 = getMinQuery(arr, i+1, sumTillNow-arr[i], dp);\n        }\n        \n        return dp[i][sumTillNow] = min(op1, op2);\n        \n    }\n    \n\npublic:\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        \n        vector<vector<int>> idxToArr(nums.size());\n        \n        for (auto q: queries) {\n            \n            int l = q[0];\n            int r = q[1];\n            int val = q[2];\n            \n            for (int i=0; i<nums.size(); i++) {\n                if (i >= l && i <= r) {\n                    idxToArr[i].push_back(val);\n                }\n                else {\n                    idxToArr[i].push_back(0);\n                }\n            }\n            \n        }\n        \n        int maxQuery = INT_MIN;\n        \n        for (int i=0; i<nums.size(); i++) {\n            vector<vector<int>> dp(idxToArr[i].size()+1, vector<int>(nums[i]+1, -1));\n            int minQuery = getMinQuery(idxToArr[i], 0, nums[i], dp);\n            maxQuery = max(maxQuery, minQuery);\n        }\n        \n        return maxQuery != INT_MAX ? maxQuery : -1;\n        \n        \n    }\n    \n};","author":"harsh peswani","submissionId":"1575208465"},[]]},{"1019":[{"id":"1019","fileName":"1575208567.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n\n        def go(i, v):\n            a = [0] * m\n            for k, (l, r, val) in enumerate(queries):\n                if l <= i and i <= r:\n                    a[k] = val\n\n            @cache\n            def dp(k, r):\n                if r == 0:\n                    return k\n                if k == m:\n                    return m + 1\n                tmp = dp(k+1, r)\n                if a[k] <= r:\n                    tmp = min(tmp, dp(k+1, r-a[k]))\n                return tmp\n            return dp(0, v)\n                    \n        \n        ans = [-1] * n\n        for i in range(n):\n            ans[i] = go(i, nums[i])\n            if ans[i] >= m + 1:\n                return -1\n        return max(ans)","author":"huggin","submissionId":"1575208567"},[]]},{"1020":[{"id":"1020","fileName":"1575208569.txt","sourceCode":"class Solution {\npublic:\nint minZeroArray(vector<int> &nums, vector<vector<int>> &queries) {\n  vector<vector<int>> subsets(nums.size(), vector<int>());\n  for (const auto &query : queries) {\n    for (int i = 0; i < nums.size(); ++i) {\n      if (i >= query[0] && i <= query[1]) {\n        subsets[i].push_back(query[2]);\n      } else {\n        subsets[i].push_back(0);\n      }\n      cout << subsets[i].back() << \" \";\n    }\n    cout << endl;\n  }\n\n  int k = -1;\n  for (int s = 0; s < nums.size(); ++s) {\n    int target = nums[s];\n    if (target == 0) {\n        k = max(0, k);\n        continue;\n    }\n    const auto &subset = subsets[s];\n    vector<bool> prev(target + 1, false);\n    vector<bool> curr(target + 1, false);\n    prev[0] = true;\n    int found = -1;\n    for (int i = 1; i <= subset.size(); ++i) {\n      for (int j = 0; j <= target; ++j) {\n        if (j < subset[i - 1]) {\n          curr[j] = prev[j];\n        } else if (prev[j]) {\n          curr[j] = prev[j];\n        } else {\n          curr[j] = prev[j - subset[i - 1]];\n        }\n      }\n      if (curr[target]) {\n        cout << \"found \" << i << \" for \" << s << endl;\n        found = i;\n        break;\n      }\n      swap(prev, curr);\n    }\n    if (found == -1)\n      return -1;\n    k = max(k, found);\n  }\n\n  return k;\n}\n\n};","author":"mustart","submissionId":"1575208569"},[]]},{"1021":[{"id":"1021","fileName":"1575208796.txt","sourceCode":"class Solution:\n    debugging = False\n\n    def is_subset_sum(self, val_counts: dict[int, int], target: int) -> bool:\n        '''Return True iff there's a way to select values from val_counts\n        such that they sum up to target'''\n        vals = list(val_counts.keys())\n        \n        @cache\n        def is_target_sum_from(cur_val_idx: int, target_remaining: int) -> bool:\n            if target_remaining == 0:\n                return True\n            if cur_val_idx == len(vals):\n                return False\n            cur_val = vals[cur_val_idx]\n            for num_val_to_use in range(val_counts[cur_val]+1):\n                next_target = target_remaining - num_val_to_use*cur_val\n                if next_target < 0:\n                    break\n                can_get_target_later = is_target_sum_from(\n                    cur_val_idx+1, next_target)\n                if can_get_target_later:\n                    return True\n            return False\n\n        return is_target_sum_from(cur_val_idx=0, target_remaining=target)\n\n    def can_zero(self, nums: List[int], queries: List[List[int]]) -> bool:\n        '''Return True iff we can zero all of nums with the given queries\n        For each query, add the val to a counter for each num it affects'''\n        val_counts_by_num = [defaultdict(int) for _ in range(len(nums))]\n        for l_idx, r_idx, val in queries:\n            for mid_idx in range(l_idx, r_idx+1):\n                val_counts_by_num[mid_idx][val] += 1\n        val_counts_by_num = [dict(counts) for counts in val_counts_by_num]\n        if self.debugging:\n            print(f't{queries=} -> {val_counts_by_num=}')\n        for num_idx in range(len(nums)):\n            cur_num = nums[num_idx]\n            if cur_num == 0:\n                continue\n            can_sum = self.is_subset_sum(val_counts_by_num[num_idx], cur_num)\n            if not can_sum:\n                return False\n        return True\n\n    def binary_search_approach(self, nums: List[int], queries: List[List[int]]) -> int:\n        '''Outer loop: try to zero all of nums with just queries[:k]'''\n        low = 1\n        high = len(queries)\n        while low <= high:\n            mid = (low + high) // 2\n            can_zero = self.can_zero(nums, queries[:mid])\n            if self.debugging:\n                print(f'{low=}, {high=} -> {mid=}, {can_zero=}')\n            if can_zero:\n                high = mid - 1\n            else:\n                low = mid + 1\n        if self.debugging:\n            print(f'final {low=}, {high=}')\n        return low if low <= len(queries) else -1\n        \n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if all(num == 0 for num in nums):\n            return 0\n        return self.binary_search_approach(nums, queries)","author":"lilganj710","submissionId":"1575208796"},[]]},{"1022":[{"id":"1022","fileName":"1575209077.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        int l = -1;\n        int r = m - 1;\n        int mid = 0;\n\n        auto check = [&](int mid) -> bool {\n            vector<vector<int>> tmp(n);\n            for (int i = 0; i <= mid; i++) {\n                int l = queries[i][0];\n                int r = queries[i][1];\n                int v = queries[i][2];\n                for (int j = l; j <= r; j++) {\n                    tmp[j].push_back(v);\n                }\n            }\n\n            return subsetSum(nums, tmp);\n\n        };\n\n        while (l <= r) {\n            mid = l + (r - l) / 2;\n            if (check(mid) == false) {\n                l = mid + 1;\n            } else {\n                r = mid - 1;\n            }\n        }\n\n        return l == m ? -1 : l + 1;    \n    }\n\n    bool subsetSum(vector<int>& nums, vector<vector<int>>& tmp) {\n        int n = nums.size();\n\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            vector<int>& vals = tmp[i];\n\n            bitset<1001> dp;\n            dp[0] = 1;\n\n            for (int v : vals) {\n                dp |= (dp << v);\n            }\n\n            if (!dp[target]) return false;\n        }\n\n        return true;\n    }\n};","author":"CHIA WEI","submissionId":"1575209077"},[]]},{"1023":[{"id":"1023","fileName":"1575209063.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:  \n        @cache\n        def backtrack(num, i, pos):\n            if num == 0:\n                return 0\n            if pos == len(queries):\n                return inf\n\n            l, r, val = queries[pos]\n            skip = 1 + backtrack(num, i, pos + 1)\n            use = inf\n            if l <= i <= r and num >= val:\n                used = backtrack(num - val, i, pos + 1)\n                if not isinf(used):\n                    use = 1 + used\n            return min(skip, use)\n\n        min_ops = -float('inf')\n        for i,num in enumerate(nums):\n            res = backtrack(num, i, 0)\n            if isinf(res):\n                return -1\n            min_ops = max(min_ops, res)\n        return min_ops","author":"swagggn0","submissionId":"1575209063"},[]]},{"1024":[{"id":"1024","fileName":"1575209294.txt","sourceCode":"class Solution {\nprivate:\n    bool canFormSubsetSum(const vector<int>& coins, int target) {\n        vector<bool> dp(target + 1, false);\n        dp[0] = true;\n        for (int coin : coins) {\n            for (int j = target; j >= coin; j--) {\n                dp[j] = dp[j] || dp[j - coin];\n            }\n        }\n        return dp[target];\n    }\n    \n    int check(vector<int>& nums, vector<vector<int>>& queries, int k) {\n        int n = nums.size();\n        vector<vector<int>> coins(n);\n        \n        for (int j = 0; j < k; j++) {\n            int l = queries[j][0], r = queries[j][1], v = queries[j][2];\n            for (int i = l; i <= r; i++) {\n                coins[i].push_back(v);\n            }\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if (nums[i] != 0 && coins[i].empty()) return 1;\n            int total = 0;\n            for (int coin : coins[i])\n                total += coin;\n            if (total < nums[i]) return 1;\n            \n            if (!canFormSubsetSum(coins[i], nums[i]))\n                return 1;\n        }\n        return 2;\n    }\n    \npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int m = queries.size();\n        \n        int l = 0, h = m;\n        int ans = -1;\n        while (l <= h) {\n            int mid = l + (h - l) / 2;\n            int res = check(nums, queries, mid);\n            if (res == 2) {\n                ans = mid;\n                h = mid - 1; \n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"Nishant Mohan","submissionId":"1575209294"},[]]},{"1025":[{"id":"1025","fileName":"1575209319.txt","sourceCode":"class Solution {\n    private Integer[][] memo;\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int m = queries.length, n = nums.length;\n        var vals = new ArrayList<List<Integer>>();\n        for (int j = 0; j < n; j++) {\n            vals.add(new ArrayList<>());\n        }\n        for (int i = 0; i < m; i++) {\n            int[] q = queries[i];\n            for (int j = 0; j < n; j++) {\n                if (q[0] <= j && j <= q[1]) {\n                    vals.get(j).add(q[2]);\n                } else {\n                    vals.get(j).add(0); // added\n                }\n            }\n        }\n        int ans = -1;\n        for (int j = 0; j < n; j++) {\n            memo = new Integer[vals.get(j).size()][nums[j]+1];\n            var res = dfs(0, nums[j], vals.get(j));\n            if (res == (int) 1e9) {\n                return -1;\n            }\n            ans = Math.max(ans, res);\n        }\n        return ans;\n    }\n    private int dfs(int i, int rem, List<Integer> vals) {\n        if (rem == 0) {\n            return i;\n            // return i+1;\n        } else if (i == vals.size()) {\n            return (int) 1e9;\n        } else if (memo[i][rem] == null) {\n            var ans = dfs(i+1, rem, vals);\n            if (vals.get(i) <= rem) {\n                ans = Math.min(ans, dfs(i+1, rem - vals.get(i), vals));\n            }\n            memo[i][rem] = ans;\n        }\n        return memo[i][rem];\n    }\n}\n/*\n    \n[2]\n[[0,0,6],[0,0,2],[0,0,9],[0,0,5],[0,0,10]]\n=> 2\n\nhidden wrong answer\n*/","author":"resotto","submissionId":"1575209319"},[]]},{"1026":[{"id":"1026","fileName":"1575209350.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        # return min non-negative k, such that processing the first k queries in sequence, nums becomes zero array (all elements are 0)\n        # if not exists, return -1\n        # query [l, r, val] is a subset of indices in the range [l, r] from nums, decrement value at each index by exactly val\n\n        # 1000 queries, nums in range 0->1000, nums.length only 10, val is only 10\n        \n        n = len(nums)\n        if sum(nums) == 0:\n            return 0\n        iToPoss = [[False] * (x+1) for x in nums]\n        # print(iToPoss)\n        for arr in iToPoss:\n            arr[0] = True\n        remainInds = set()\n        for i, val in enumerate(nums):\n            if val > 0:\n                remainInds.add(i)\n        for idx, query in enumerate(queries):\n            l, r, val = query\n            for i in range(l, r+1):\n                if i in remainInds:\n                    poss = iToPoss[i]\n                    for j in range(len(poss)-1, 0, -1):\n                        if (j-val) < 0:\n                            break\n                        if poss[j-val]:\n                            poss[j] = True\n                    if poss[-1] == True:\n                        remainInds.remove(i)\n            # print(iToPoss)\n            if len(remainInds) == 0:\n                return idx + 1\n\n        return -1","author":"hufflepuffpastry","submissionId":"1575209350"},[]]},{"1027":[{"id":"1027","fileName":"1575207610.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        qlen = len(queries)\n        \n        # Precompute, for each index i, the list of (query_index, decrement value)\n        # for queries that affect index i.\n        queries_by_index = [[] for _ in range(n)]\n        for j, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                queries_by_index[i].append((j, val))\n                \n        # Helper function: Given candidate k (first k queries are available),\n        # check for every index if a subset of queries (covering that index)\n        # sums exactly to nums[i].\n        def can_zero(k: int) -> bool:\n            for i in range(n):\n                target = nums[i]\n                # For k=0, we must have target == 0.\n                if k == 0:\n                    if target != 0:\n                        return False\n                    else:\n                        continue\n                # dp will be an integer bitmask; bit s is set if sum s is achievable.\n                dp = 1  # Only sum 0 is initially achievable.\n                # Only consider queries for index i with query index < k.\n                for j, v in queries_by_index[i]:\n                    if j >= k:\n                        continue\n                    # Update dp: you can either skip or use this query.\n                    dp |= dp << v\n                    # Limit dp to only consider sums up to target.\n                    # (All higher bits are not needed.)\n                    dp &= (1 << (target + 1)) - 1\n                    # Early exit if target is already reachable.\n                    if (dp >> target) & 1:\n                        # No need to process further queries for this index.\n                        break\n                if not ((dp >> target) & 1):\n                    return False\n            return True\n        \n        # Binary search on the number of queries needed.\n        # The search space is 0 ... qlen.\n        left, right = 0, qlen + 1  # right is an impossible candidate.\n        while left < right:\n            mid = (left + right) // 2\n            if can_zero(mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left if left <= qlen else -1\n\n# Example usages:\n# sol = Solution()\n\n# # Example 1:\n# nums1 = [2,0,2]\n# queries1 = [[0,2,1],[0,2,1],[1,1,3]]\n# print(sol.minZeroArray(nums1, queries1))  # Expected output: 2\n\n# # Example 2:\n# nums2 = [4,3,2,1]\n# queries2 = [[1,3,2],[0,2,1]]\n# print(sol.minZeroArray(nums2, queries2))  # Expected output: -1\n\n# # Example 3:\n# nums3 = [1,2,3,2,1]\n# queries3 = [[0,1,1],[1,2,1],[2,3,2],[3,4,1],[4,4,1]]\n# print(sol.minZeroArray(nums3, queries3))  # Expected output: 4\n\n# # Example 4:\n# nums4 = [1,2,3,2,6]\n# queries4 = [[0,1,1],[0,2,1],[1,4,2],[4,4,4],[3,4,1],[4,4,5]]\n# print(sol.minZeroArray(nums4, queries4))  # Expected output: 4\n","author":"Siva Sankar Reddy Asam","submissionId":"1575207610"},[]]},{"1028":[{"id":"1028","fileName":"1575209175.txt","sourceCode":"class Solution:\n    def minZeroArray(self, arr: List[int], q: List[List[int]]) -> int:\n        n, m = len(arr), len(q)\n\n        allzero = True\n        for x in arr:\n            if x != 0:\n                allzero = False\n                break\n        if allzero:\n            return 0\n\n        def check3(target, vals):\n            dp = [0]*(1+target)\n            dp[0] = 1\n\n            for v in vals:\n                for i in range(target, v-1, -1):\n                    dp[i] = max(dp[i], dp[i-v])\n            #     print(f\"check3 {v=} {dp=}\")\n            # print(f\"{target=} {vals=} {dp=}\")\n            return dp[-1] == 1\n            \n        def check2(k, i):\n            qs = []\n            \n            for l, r, v in q[:k+1]:\n                if l <= i <= r:\n                    qs.append(v)\n            res = check3(arr[i], qs)\n            # print(f\"check2 {k=} {i=} {arr[i]=} {qs=} {res=}\")\n            return res\n            \n        def check(k):\n            for i in range(n):\n                if not check2(k, i):\n                    return False\n            return True\n\n        # print(f\"n{check(2)=}n\")\n        if not check(m-1):\n            return -1\n            \n        l, r = 0, m-1\n        while r - l >= 1:\n            m = (l+r)//2\n            \n            if check(m):\n                # print(\"check ok\", l, r, m)\n                r = m\n            else:\n                l = m+1\n\n        return r+1","author":"asdfweasd","submissionId":"1575209175"},[]]},{"1029":[{"id":"1029","fileName":"1575209380.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size(), ans = 0; \n        \n        for (int i = 0; i < n; ++i) {\n            map<pair<int,int>, int> dp;\n            function<int(int, int)> dfs = [&](int idx, int val) -> int {\n                if (idx == m) return (val == 0) ? m : m+1;\n                if (val == 0) return idx; \n                if(dp.find({idx, val}) != dp.end())\n                    return dp[{idx, val}];\n                int res = dfs(idx + 1, val);\n                if (queries[idx][0] <= i && i <= queries[idx][1] && val >= queries[idx][2]) {\n                    res = min(res, dfs(idx + 1, val - queries[idx][2]));\n                }\n                return dp[{idx, val}] = res;\n            };\n\n            int x = dfs(0, nums[i]);\n            if (x > m) return -1;  \n            ans = max(ans, x);\n        }\n\n        return ans;\n    }\n};\n","author":"Abhay","submissionId":"1575209380"},[]]},{"1030":[{"id":"1030","fileName":"1575209388.txt","sourceCode":"class Solution(object):\n    def minZeroArray(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: int\n        \"\"\"\n        toRemove = [[] for _ in xrange(len(nums) + 1)]\n        toAdd = [[] for _ in xrange(len(nums) + 1)]\n        vals = [0] * len(queries)\n        n = max(nums)\n        qI = 0\n        currMax = 0\n        dp = [False] * (n + 1)\n        dp[0] = True\n        for i in xrange(len(nums)):\n            if len(toAdd[i]) > 0:\n                for j in toAdd[i]:\n                    vals[j] = queries[j][2]\n                for j in toAdd[i]:\n                    for k in xrange(n - 1, -1, -1):\n                        if dp[k]:\n                            if vals[j] + k <= n:\n                                dp[k + vals[j]] = True\n            if len(toRemove[i]) > 0:\n                for j in toRemove[i]:\n                    vals[j] = 0\n                dp = [False] * (n + 1)\n                dp[0] = True\n                for v in vals[:qI]:\n                    for k in xrange(n - 1, -1, -1):\n                        if dp[k]:\n                            if v + k <= n:\n                                dp[k + v] = True\n                #print vals[:qI], dp\n\n            while not dp[nums[i]]:\n                if qI == len(queries):\n                    return -1\n                toAdd[queries[qI][0]].append(qI)\n                toRemove[queries[qI][1] + 1].append(qI)\n                if queries[qI][0] <= i <= queries[qI][1]:\n                    v = queries[qI][2]\n                    vals[qI] = v\n                    for k in xrange(n - 1, -1, -1):\n                        if dp[k]:\n                            if v + k <= n:\n                                dp[k + v] = True\n                qI += 1\n                #print dp, nums[i]\n        return qI","author":"lsUGGYJUIX","submissionId":"1575209388"},[]]},{"1031":[{"id":"1031","fileName":"1575209440.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        size = len(nums)\n        bit_masks = self.initialize_bit_masks(size)\n        if self.are_all_zeros(nums):\n            return 0\n        for index, (start, end, value) in enumerate(queries):\n            self.update_bit_masks(bit_masks, nums, start, end, value)\n\n            if self.is_all_achieved(bit_masks, nums, size):\n                return index + 1\n        return -1\n\n    def initialize_bit_masks(self, size: int) -> List[List[bool]]:\n        bit_masks = [[False] * 1001 for _ in range(size)]\n        for idx in range(size):\n            bit_masks[idx][0] = True\n        return bit_masks\n\n    def are_all_zeros(self, nums: List[int]) -> bool:\n        return all(num == 0 for num in nums)\n\n    def update_bit_masks(self, bit_masks: List[List[bool]], nums: List[int], start: int, end: int, value: int) -> None:\n        for idx in range(start, end + 1):\n            for bit_position in range(1000, value - 1, -1):\n                if bit_masks[idx][bit_position - value]:\n                    bit_masks[idx][bit_position] = True\n            for bit_position in range(nums[idx] + 1, 1001):\n                bit_masks[idx][bit_position] = False\n\n    def is_all_achieved(self, bit_masks: List[List[bool]], nums: List[int], size: int) -> bool:\n        return all(bit_masks[idx][nums[idx]] for idx in range(size))","author":"SabarishK_Coder","submissionId":"1575209440"},[]]},{"1032":[{"id":"1032","fileName":"1575209458.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        q = len(queries)\n        n = len(nums)\n        left, right = 0, q + 1\n\n        def check(num: int) -> bool:\n            cnt = [[] for _ in range(n)]\n            for i in range(num):\n                l, r, v = queries[i]\n                for j in range(l, r + 1):\n                    cnt[j].append(v)\n            for i in range(n):\n                target = nums[i]\n                dp = {0}\n                for val in cnt[i]:\n                    new_dp = set(dp)\n                    for s in dp:\n                        new_sum = s + val\n                        if new_sum <= target:\n                            new_dp.add(new_sum)\n                    dp = new_dp\n                    if target in dp:\n                        break\n                if target not in dp:\n                    return False\n            return True\n\n        res = -1\n        while left < right:\n            mid = (left + right) // 2\n            if check(mid):\n                res = mid\n                right = mid\n            else:\n                left = mid + 1\n        return res\n","author":"hank95179","submissionId":"1575209458"},[]]},{"1033":[{"id":"1033","fileName":"1575209801.txt","sourceCode":"class Solution {\npublic:\n    int n;\n    bool check(vector<int>& temp,int target) \n    {\n        if(target==0) return true;\n        if(temp.empty()) return false;\n        int x=accumulate(temp.begin(),temp.end(),0);\n        if (x<target) return false;\n        vector<bool> dp(target+1,false);\n        dp[0]=true;\n        for(int num:temp) \n        {\n            for(int j=target;j>=num;j--) dp[j]=dp[j]||dp[j-num];\n        }\n        return dp[target];\n    }\n    bool check(int index,vector<vector<int>> &queries,vector<int> &arr)\n    {\n        map<int,vector<int>> data;\n        for(int i=0;i<index;i++)\n        {\n            int L=queries[i][0];\n            int R=queries[i][1];\n            int val=queries[i][2];\n            for(int j=L;j<=R;j++) data[j].push_back(val);\n        }\n        for(int i=0;i<n;i++)\n        {\n            bool res=check(data[i],arr[i]);\n            if(!res) return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& arr, vector<vector<int>>& queries) \n    {\n        n=arr.size();\n        int start=0;\n        int end=queries.size();\n        int mid;\n        int ans=-1;\n        while(start<=end)\n        {\n            mid=start+(end-start)/2;\n            if(check(mid,queries,arr))\n            {\n                ans=mid;\n                end=mid-1;\n            }\n            else start=mid+1;\n        }\n        return ans;\n    }\n};\n","author":"Dishank Patel","submissionId":"1575209801"},[]]},{"1034":[{"id":"1034","fileName":"1575209495.txt","sourceCode":"class Solution {\n    static boolean checkSubsetSum(int sum,List<Integer> tt) {\n        int n = tt.size();\n        boolean[][] dp = new boolean[n + 1][sum + 1];\n        for (int i = 0; i <= n; i++) {\n            dp[i][0] = true;\n        }\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= sum; j++) {\n                if (j < tt.get(i - 1)) {\n                    dp[i][j] = dp[i - 1][j];\n                }\n                else {\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - tt.get(i - 1)];\n                }\n            }\n        }\n\n        return dp[n][sum];\n    }\n    static boolean check(List<List<Integer>> ls , int[] nums) {\n        int n = nums.length;\n        for(int i=0;i<n;i++) {\n            if(checkSubsetSum(nums[i] , ls.get(i))) continue;\n            else return false;\n        }\n        return true;\n    }\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int ans = -1;\n        int cc =0;\n        for(int i:nums) {\n            if(i==0) cc++;\n        }\n        if(cc == nums.length) return 0;\n        int k = 0;\n        List<List<Integer>> ls = new ArrayList<>();\n        for(int i=0;i<nums.length;i++) ls.add(new ArrayList<>());\n        // System.out.println(ls);\n        for(int[] i:queries) {\n            for(int j=i[0];j<=i[1];j++) {\n                ls.get(j).add(i[2]);\n            }\n            k++;\n            if(check(ls,nums)) return k;\n        }\n        return -1;\n    }\n}","author":"Ram Koushik Mendru","submissionId":"1575209495"},[]]},{"1035":[{"id":"1035","fileName":"1575209924.txt","sourceCode":"class Solution {\n    bool canSubsetSum(vector<int>& arr, int target) {\n        if (target == 0) return true;\n        bitset<1001> dp;\n        dp[0] = 1;\n        for (int v : arr)\n            dp |= (dp << v);\n        return dp[target];\n    }\n\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size();\n        vector<vector<int>> queryMap(n);\n\n        int mini = *min_element(nums.begin(), nums.end());\n        int maxi = *max_element(nums.begin(), nums.end());\n        if (mini == 0 && maxi == 0) return 0;\n\n        for (int j = 0; j < q; j++) {\n            auto q = queries[j];\n            for (int i = q[0]; i <= q[1]; i++)\n                queryMap[i].push_back(q[2]);\n\n            bool flag = true;\n            for (int i = 0; i < n; i++) {\n                if (!canSubsetSum(queryMap[i], nums[i])) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) return j + 1;\n        }\n        return -1;\n    }\n};\n","author":"nktps40","submissionId":"1575209924"},[]]},{"1036":[{"id":"1036","fileName":"1575209545.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        # [2,0,2]\n        # [l,r,val]\n        # \n        # \n        # for each number in nums we need to go through queries and see if we can get a 0 out of it\n        # we have the number 4 -> [4 or 2] -> [4 or 3 or 1]\n        # omg its prefix\n        k = 0\n        for i, num in enumerate(nums):\n            if num == 0:\n                continue\n            # We do a prefix sum for each one\n            totals = set()\n            totals.add(num)\n            \n            prefix_sum = 0 \n            temp_k = 0\n            no_answer = True\n            \n            for l, r, val in queries:\n                temp_k += 1\n                if i >= l and i <= r:\n                    temp_totals = list(totals)\n                    \n                    for num1 in temp_totals:\n                        if num1 - val == 0:\n                            no_answer = False\n                            break\n                            \n                        totals.add(num1 - val)\n                        \n                if not no_answer:\n                    break\n                    \n            if no_answer:\n                return -1\n                \n            k = max(k, temp_k)\n            \n        return k\n\n\n        [4, 7, 1]\n        # 50 50 - val -> \n            \n        \n        \n        ","author":"JComf","submissionId":"1575209545"},[]]},{"1037":[{"id":"1037","fileName":"1575210250.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<bool>> dp(n, vector<bool>(1001, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (all_of(nums.begin(), nums.end(), [](int num) { return num == 0; })) {\n            return 0;\n        }\n\n        for (int k = 0; k < queries.size(); k++) {\n            int l = queries[k][0], r = queries[k][1], v = queries[k][2];\n\n            for (int i = l; i <= r; i++) {\n                for (int j = 1000; j >= 0; j--) {  \n                    if (j >= v && dp[i][j - v]) {  \n                        dp[i][j] = true;\n                    } \n                    if (j > nums[i]) {  \n                        dp[i][j] = false;\n                    }\n                }\n            }\n\n            bool allAchieved = true;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i][nums[i]]) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n\n            if (allAchieved) return k + 1;\n        }\n\n        return -1;\n    }\n};\n","author":"deSTROYer","submissionId":"1575210250"},[]]},{"1038":[{"id":"1038","fileName":"1575210171.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if all(x == 0 for x in nums):\n            return 0\n        max_j = -1\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                continue\n            target = nums[i]\n            Qi = []\n            for j in range(len(queries)):\n                l, r, val = queries[j]\n                if l <= i <= r:\n                    Qi.append((j, val))\n            if not Qi:\n                return -1\n            dp = {0: -1}\n            for (j, val) in Qi:\n                new_dp = {}\n                for s in dp:\n                    current_max_j = dp[s]\n                    if s in new_dp:\n                        if current_max_j < new_dp[s]:\n                            new_dp[s] = current_max_j\n                    else:\n                        new_dp[s] = current_max_j\n                    new_s = s + val\n                    if new_s > target:\n                        continue\n                    new_max_j = max(current_max_j, j)\n                    if new_s in new_dp:\n                        if new_max_j < new_dp[new_s]:\n                            new_dp[new_s] = new_max_j\n                    else:\n                        new_dp[new_s] = new_max_j\n                dp = new_dp\n            if target not in dp:\n                return -1\n            current_max = dp[target]\n            if current_max > max_j:\n                max_j = current_max\n        return max_j + 1 if max_j != -1 else 0\n\n","author":"S Yathissh","submissionId":"1575210171"},[]]},{"1039":[{"id":"1039","fileName":"1575210101.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l = 0;\n        int r = queries.size();\n        int result = INT_MAX;\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            int res = helper(nums, queries, mid);\n            if (res == -1) {\n                l = mid + 1;\n            } else {\n                result = min(result, mid);\n                r = mid - 1;\n            }\n        }\n        if (result == INT_MAX) return -1;\n        return result;\n    }\n    int helper(vector<int> nums, vector<vector<int>>& queries, int k) {\n        vector<vector<int>> coins(nums.size());\n        for (int q = 0; q < k; q++) {\n            int left = queries[q][0];\n            int right = queries[q][1];\n            int val = queries[q][2];\n            for (int i = left; i <= right; i++) coins[i].push_back(val);\n        }\n        for (int i = 0; i < nums.size(); i++) if (!makeable(coins[i], nums[i])) return -1;\n        return 0;\n    }\n    int makeable(vector<int>& coins, int num) {\n        vector<vector<int>> dp(num + 1, vector<int>(coins.size(), -1));\n        return dfs(dp, coins, num, 0);\n    }\n    int dfs(vector<vector<int>>& dp, vector<int>& coins, int num, int i) {\n        if (num < 0) return 0;\n        if (num == 0) return 1;\n        if (i == coins.size()) return 0;\n        if (dp[num][i] != -1) return dp[num][i];\n        return dp[num][i] = dfs(dp, coins, num - coins[i], i + 1) || dfs(dp, coins, num, i + 1);\n    }\n};","author":"Jacob Wu","submissionId":"1575210101"},[]]},{"1040":[{"id":"1040","fileName":"1575210281.txt","sourceCode":"class Solution {\n\n    bool exists(int num,vector<int>&pre,int i,vector<vector<int>>&dp){\n        if(num==0)return true;\n        if(num<0 || i>=pre.size())return false;\n        if(dp[num][i]!=-1)return dp[num][i];\n        // lu \n        // bool w1=false,w2=false;\n        // cout<<num<<\" \"<<i<<endl;\n        // // na lu\n        // if(exists(num,pre,i+1,dp))return dp[num][i]=true;\n        // if(pre[i]>0 && num-i>=0){\n        //     pre[i]--;\n        //     w1=exists(num-i,pre,i,dp);\n        //     pre[i]++;\n        // }\n        // if(w1)return dp[num][i]=true;\n        for(int j=0;j<=pre[i];j++){\n            pre[i]-=j;\n            bool sol=exists(num-j*i,pre,i+1,dp);\n            pre[i]+=j;\n            if(sol) return dp[num][i]=true;\n        }\n        return dp[num][i]=false;\n    }\n    \n    bool possible(vector<int>&nums,vector<vector<int>>&mp,vector<bool>&stored){\n        for(int i=0;i<nums.size();i++){\n            if(nums[i]>0 && !stored[i]){\n                vector<vector<int>>dp(nums[i]+1,vector<int>(11,-1));\n                if(!exists(nums[i],mp[i],1,dp))return false;\n                stored[i]=true;\n            }\n        }\n        return true;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n=nums.size(),m=q.size();\n        bool mila=false;\n        for(auto ele:nums)if(ele>0)mila=true;\n        if(!mila)return 0;\n        vector<vector<int>>mp(n,vector<int>(11,0));\n        vector<bool>stored(n,false);\n        for(int i=0;i<m;i++){\n            int l=q[i][0],r=q[i][1],val=q[i][2];\n            for(int j=l;j<=r;j++)mp[j][val]++;\n            if(i==6){\n                for(int i=0;i<n;i++){\n                    for(int j=0;j<11;j++){\n                        cout<<mp[i][j]<<\" \";\n                    }cout<<endl;\n                }\n            }\n            if(possible(nums,mp,stored)){\n                return i+1;\n            }\n        }\n\n        return -1;\n    }\n};","author":"Dhruv Verma","submissionId":"1575210281"},[]]},{"1041":[{"id":"1041","fileName":"1575210104.txt","sourceCode":"class Solution {\npublic:\n\n   int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n       int len = nums.size();\n        int opCount = queries.size();\n        vector<bitset<1001>> possibleVals(len);\n        \n       \n        \n       \n        for (int idx = 0; idx < len; ++idx) {\n            possibleVals[idx].set(0);\n        }\n        \n        \n        bool isZeroArray = true;\n        for (int& val : nums) {\n            if (val != 0) {\n                isZeroArray = false;\n                break;\n            }\n        }\n        \n        \n        if (isZeroArray) return 0;\n        \n       \n        for (int opIdx = 0; opIdx < opCount; ++opIdx) {\n             auto& op = queries[opIdx];\n            int leftBound = op[0];\n             int rightBound = op[1];\n             int addValue = op[2];\n            \n           \n            for (int elemIdx = leftBound; elemIdx <= rightBound; ++elemIdx) {\n                cout << 'v';\n                \n                \n                bitset<1001> newPossibilities;\n                \n                \n                for (int oldVal = 0; oldVal < 1001; ++oldVal) {\n                    if (!possibleVals[elemIdx][oldVal]) continue;\n                    \n                    if (oldVal + addValue < 1001) {\n                        newPossibilities.set(oldVal + addValue);\n                    }\n                }\n                \n       \n                possibleVals[elemIdx] |= newPossibilities;\n                \n               \n                int targetVal = nums[elemIdx];\n                for (int impossibleVal = targetVal + 1; impossibleVal < 1001; ++impossibleVal) {\n                    possibleVals[elemIdx].reset(impossibleVal);\n                }\n            }\n            \n           \n            \n            bool success = true;\n            for (int elemIdx = 0; elemIdx < len; ++elemIdx) {\n                if (!possibleVals[elemIdx][nums[elemIdx]]) {\n                    success = false;\n                    break;\n                }\n            }\n            \n         \n            if (success) {\n            \n                return opIdx + 1;\n            }\n        }\n      \n        return -1;\n   }\n};\n\n","author":"Aryan Nayar","submissionId":"1575210104"},[]]},{"1042":[{"id":"1042","fileName":"1575210274.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        int l = 0, r = q, ans = -1;\n        while (l <= r) {\n            int mid = (l + r) / 2; \n            bool all = true;\n            for (int ind = 0; ind < n; ind++) {\n                int target = nums[ind];\n                vector<bool> dp(target + 1, false);\n                dp[0] = true;\n                for (int i = 0; i < mid; i++) {\n                    if (queries[i][0] <= ind && queries[i][1] >= ind) {\n                        for (int j = target; j >= queries[i][2]; j--) {\n                            dp[j] = dp[j] || dp[j - queries[i][2]];\n                        }\n                    }\n                }\n                if (!dp[target]) {\n                    all = false;\n                    break;\n                }\n            }\n            if (all) {\n                ans = mid;  \n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"amit_n","submissionId":"1575210274"},[]]},{"1044":[{"id":"1044","fileName":"1575210306.txt","sourceCode":"class Solution {\npublic:\n   bool canMakeTarget(vector<int>& a, int target) {\n        bitset<1002> dp;\n        dp[0] = 1;\n        for(int x : a) dp |= dp << x;\n        return dp[target];\n    }\n    bool check(vector <int> & nums,vector <vector <int>> & queries,int mid,int & n){\n        vector <vector <int>> st(n);\n        for(int i = 0;i<=mid;i++){\n            int l = queries[i][0],r = queries[i][1],val = queries[i][2];\n            for(int j = l;j<=r;j++){\n                st[j].push_back(val);\n            }\n        }\n        // for(int i = 0;i<n;i++){\n        //     int len = st[i].size();\n        //     for(int j = 0;j<len;j++){\n        //         cout<<st[i][j]<<\" \"; \n        //     }\n        //     cout<<\"n\";\n        // }\n        // bool flag = true;\n        for(int i = 0;i<n;i++){\n            if(nums[i] == 0)continue;\n            if(canMakeTarget(st[i],nums[i]) == false){\n                return false;\n            }\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int len = queries.size();\n        bool flag = false;\n        for(int i  =0;i<n;i++)\n        {\n            if(nums[i] != 0){\n                flag = true;\n                break;\n            }\n        }\n        if(flag  == false){\n            return 0;\n        }\n        int lo = 0,hi = len-1;\n        int ans = -1;\n        while(lo <= hi){\n            int mid  = (lo + hi)/2;\n            if(check(nums,queries,mid,n)){\n                hi = mid-1;\n                ans = mid+1;\n            }\n            else{\n                lo = mid+1;\n            }\n        }\n        return ans;\n    }\n};","author":"sr6esI829x","submissionId":"1575210306"},[]]},{"1045":[{"id":"1045","fileName":"1575210310.txt","sourceCode":"class Solution {\npublic:\n    int dp[1001][1001];\n    bool help(int indx, int tar, vector<int> &arr){\n        if(tar==0) return true;\n        if(indx>=arr.size()) return false;\n\n        if(dp[indx][tar]!=-1) return dp[indx][tar];\n        bool notpick=help(indx+1,tar,arr);\n        bool pick=false;\n        if(tar-arr[indx]>=0){\n            pick=help(indx+1,tar-arr[indx],arr);\n        }\n        return dp[indx][tar]= notpick | pick;\n    }\n    bool check(vector<int>& nums, vector<vector<int>>& queries,int mid){\n        map<int,vector<int>> mp;\n        for(int it=0;it<mid;it++){\n            for(int i=queries[it][0];i<=queries[it][1];i++){\n                mp[i].push_back(queries[it][2]);\n            }\n        }\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            int tar=nums[i];\n            memset(dp,-1,sizeof(dp));\n            if(help(0,tar,mp[i])){\n                continue;\n            }\n            else{\n                return false;\n            }\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int low=0,high=queries.size();\n        int ans=INT_MAX;\n        while(low<=high){\n            int mid=(low+high)/2;\n            if(check(nums,queries,mid)){\n                high=mid-1;\n                ans=min(ans,mid);\n            }\n            else low=mid+1;\n        }\n        return ans==INT_MAX ? -1 : ans;\n \n    }\n};","author":"himanshu_sachan","submissionId":"1575210310"},[]]},{"1046":[{"id":"1046","fileName":"1575210379.txt","sourceCode":"class Solution {\npublic:\n    bool check(vector<int>& nums, int target) {\n        vector<bool> dp(target + 1, false);\n        dp[0] = true; \n    \n        for (int num : nums) {\n            for (int j = target; j >= num; --j) { \n                if (dp[j - num]) {\n                    dp[j] = true;\n                }\n            }\n        }\n        return dp[target];\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& qu) {\n        int l = 0;\n        int r = qu.size();\n        int ans = -1;\n        int n = nums.size();\n        while(l <= r){\n            int mid = (l + r + 1)/2;\n            vector<vector<int>>v(n);\n            for(int i = 0; i < mid; i++){\n                for(int j = qu[i][0]; j <= qu[i][1]; j++){\n                    v[j].push_back(qu[i][2]);\n                }\n            }\n            int f = 0;\n            for(int i = 0; i < n; i++){\n                vector<int>vv = v[i];  \n                if(check(vv, nums[i])){\n                    \n                }\n                else{\n                    f = 1;\n                }\n            }\n            if(f == 0){\n                ans = mid;\n                r = mid - 1;\n            }\n            else{\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"Sharath","submissionId":"1575210379"},[]]},{"1047":[{"id":"1047","fileName":"1575210347.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isSubsetSum(vector<int>& arr, int sum) {\n        int N = arr.size();\n        vector<vector<bool>> subset(N + 1, vector<bool>(sum + 1, false));\n\n        for (int i = 0; i <= N; i++) subset[i][0] = true;\n\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= sum; j++) {\n                subset[i][j] = subset[i - 1][j];\n                if (j >= arr[i - 1])\n                    subset[i][j] = subset[i][j] || subset[i - 1][j - arr[i - 1]];\n            }\n        }\n        return subset[N][sum];\n    }\n\n    bool poss(vector<int> &nums, int k, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> v(n);\n\n        for (int i = 0; i < k; i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                v[j].push_back(val);\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) continue;\n            if (v[i].empty() || !isSubsetSum(v[i], nums[i]))\n                return false;\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l = 0, r = queries.size(), ans = -1;\n        \n        while (r >= l) {\n            int m = (r + l) / 2;\n            if (poss(nums, m, queries)) {\n                ans = m;\n                r = m - 1;\n            } else {\n                l = m + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"Aditya Singh","submissionId":"1575210347"},[]]},{"1048":[{"id":"1048","fileName":"1575210396.txt","sourceCode":"typedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef vector<pii> vpii;\ntypedef vector<vi> vvi;\n\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#define fr(i, start, n) for (int i = start; i < n; i++)\n#define yes cout << \"YES\" << endl\n#define no cout << \"NO\" << endl\n\nconst ll MOD = 1e9 + 7;\n\nclass Solution {\npublic:\n\n    int find_min_k(int target, vvi &val){\n        int n = val.size();\n        vvi dp(target+1, vi(n,0));\n\n        for(int i = 0; i<n; i++){\n            dp[0][i] = 1;\n        }\n\n        for(int i = 1; i<=target; i++){\n            dp[i][0] = 0;\n        }\n\n        for(int i = 1; i<=target; i++){\n            for(int j = 1; j<n; j++){\n                int take = 0, nottake = 0;\n                if(i - val[j][0]>=0){\n                    take = dp[i - val[j][0]][j-1];\n                }\n                nottake = dp[i][j-1];\n\n                dp[i][j] = take || nottake;\n            }\n        }\n\n        int k = INT_MAX;\n\n        for(int i = 1; i<n; i++){\n            // cout<<dp[target][i]<<\" \";\n            if(dp[target][i]==1){\n                k = min(k, val[i][1]);\n            }\n        }\n        // cout<<endl;\n\n        return k==INT_MAX ? -1:k;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& que) {\n        int n = nums.size();\n        int q = que.size();\n        vi min_k(n, -1);\n\n        for(int i = 0; i<n; i++){\n            if(nums[i]==0){\n                min_k[i] = 0;\n                continue;\n            }\n            vvi temp;\n            temp.pb({0,0});\n            int k  = 1;\n            for(auto arr: que){\n                if(arr[0]<=i && arr[1]>=i){\n                    temp.pb({arr[2], k});\n                }\n                k++;\n            }\n\n            // for(auto v:temp){\n            //     cout<<v[0]<<\" \"<<v[1]<<\" \";\n            // }\n            // cout<<endl;\n            \n            min_k[i] = find_min_k(nums[i], temp);\n            // cout<<min_k[i]<<endl;\n            if(min_k[i]==-1){\n                return -1;\n            }\n        }\n\n        int ans = 0;\n        for(int a:min_k) ans = max(ans, a);\n\n        return ans;\n        \n    }\n};\n\n\n\n\n\n\n\n\n\n","author":"Siddhesh Pandey","submissionId":"1575210396"},[]]},{"1049":[{"id":"1049","fileName":"1575210437.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        vals = [[] for _ in range(n)]\n\n        count = sum(1 for x in nums if x > 0)\n        if count == 0:\n            return 0\n\n        def check(i,arr,tsum):\n            dp=[[-1]*(tsum+1) for _ in range(len(arr))]\n            def isPossible(i,rem):\n                if rem==0:return True\n                if rem<0 or i==len(arr):return False\n                if dp[i][rem]!=-1: return dp[i][rem]\n                ans = isPossible(i+1,rem) or isPossible(i+1,rem-arr[i])\n                dp[i][rem] = ans\n                return ans\n                \n            res = isPossible(i,tsum)\n            return res\n        \n        for k, (l, r, val) in enumerate(queries):\n            for i in range(l,r+1):vals[i].append(val)\n            if all(check(0,vals[i],num) for i,num in enumerate(nums)):return k+1\n\n        return -1\n","author":"Lokeshwar","submissionId":"1575210437"},[]]},{"1050":[{"id":"1050","fileName":"1575210657.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n\n        int len = queries.length;\n        if (!valid(nums, queries, len)) {\n            //try all\n            return -1;\n        }\n        int left = 0, right = len;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (valid(nums, queries, mid)) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return right + 1;\n    }\n\n    public boolean valid(int[] nums, int[][] q, int cnt) {\n        for (int i = 0; i < nums.length; ++i) {\n            if (!packValid(nums[i], q, cnt, i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean packValid(int sum, int[][] q, int cnt, int pos) {\n        boolean[][] pack = new boolean[cnt + 1][sum + 1];\n        pack[0][0] = true;\n        for (int i = 0 ; i <= cnt; ++i) {\n            for (int j = 0; j <= sum; ++j) {\n                if (i == 0) {\n                    continue;\n                } else if (j == 0) {\n                    pack[i][j] = true;\n                } else {\n                    if (pack[i - 1][j] || (q[i - 1][0] <= pos && q[i - 1][1] >= pos && j - q[i - 1][2] >= 0 && pack[i - 1][j - q[i - 1][2]])) {\n                        pack[i][j] = true;\n                    }\n                }\n            }\n            \n        }\n        return pack[cnt][sum];\n    }\n}","author":"litang","submissionId":"1575210657"},[]]},{"1051":[{"id":"1051","fileName":"1575210541.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int count = 0;\n        for(auto it:nums){\n            if(it==0){\n                count++;\n            }\n        }\n        if(count == nums.size()){\n            return 0;\n        }\n        vector<bitset<1001>> dp(nums.size());\n        for (int i = 0; i < nums.size(); i++) {\n            dp[i].reset();\n            dp[i].set(0, true);\n        }\n        int k = 0;\n        vector<int>arr(nums.begin(),nums.end());\n        for(int i = 0; i< queries.size();i++){\n            int x = queries[i][0];\n            int y = queries[i][1];\n            int val = queries[i][2];\n            for (int j = x; j <= y; j++) {\n                dp[j] |= (dp[j] << val);\n                for (int x1 = nums[j]+1; x1 <1001; x1++) {\n                    dp[j].reset(x1);\n                }\n            }\n            int c1 = 0;\n            for(int j = 0; j<nums.size();j++){\n                if(dp[j].test(nums[j])){\n                    c1++;\n                }\n            }\n            k++;\n            if(c1 == nums.size()){\n                return k;\n            }\n        }\n        return -1;\n    }\n};","author":"ANSH GUPTA","submissionId":"1575210541"},[]]},{"1053":[{"id":"1053","fileName":"1575210617.txt","sourceCode":"class Solution {\n    private Map<String, Integer> memo = new HashMap<>();\n\n    private int dp(int rem, int curIdx, int numIdx, int[][] queries) {\n        if (curIdx == queries.length) {\n            return (rem == 0) ? 0 : Integer.MAX_VALUE;\n        }\n        if (rem == 0) return 0;\n        if (rem < 0) return Integer.MAX_VALUE;\n\n        // Memoization key\n        String key = rem + \",\" + curIdx + \",\" + numIdx;\n        if (memo.containsKey(key)) return memo.get(key);\n\n        int left = queries[curIdx][0];\n        int right = queries[curIdx][1];\n        int val = queries[curIdx][2];\n\n        int ans = Integer.MAX_VALUE;\n        \n        // Use current query if numIdx is in the valid range\n        if (left <= numIdx && numIdx <= right) {\n            int useQuery = dp(rem - val, curIdx + 1, numIdx, queries);\n            if (useQuery != Integer.MAX_VALUE) {\n                ans = useQuery + 1;\n            }\n        }\n\n        // Skip the current query\n        int skipQuery = dp(rem, curIdx + 1, numIdx, queries);\n        if (skipQuery != Integer.MAX_VALUE) {\n            ans = Math.min(ans, skipQuery + 1);\n        }\n\n        memo.put(key, ans);\n        return ans;\n    }\n\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int ans = -1;\n\n        for (int i = 0; i < nums.length; i++) {\n            int res = dp(nums[i], 0, i, queries);\n            if (res == Integer.MAX_VALUE) return -1;  // If no valid solution, return -1\n            ans = Math.max(ans, res);\n        }\n\n        return ans;\n    }\n}\n","author":"Andy Gao","submissionId":"1575210617"},[]]},{"1054":[{"id":"1054","fileName":"1575210756.txt","sourceCode":"import java.util.*;\n\npublic class Solution {\n\n    // Lulli-Pulli template block (for future use)\n    interface DummyTemplate {\n        void lulliMethod();\n        int pulliMethod(int x);\n    }\n    // End of template block\n\n    public int minZeroArray(int[] lulliList, int[][] mulliQueries) {\n        int lulliSize = lulliList.length;\n        int mulliCount = mulliQueries.length;\n        \n        // Mulli-Pulli initialization block\n        boolean allZeroFlag = true;\n        for (int lulliItem : lulliList) {\n            if (lulliItem != 0) {\n                allZeroFlag = false;\n                break;\n            }\n        }\n        if (allZeroFlag) return 0;\n        // End initialization block\n\n        // Pulli-DP configuration (size 1001 for safety)\n        boolean[][] pulliDP = new boolean[lulliSize][1001];\n        for (int j = 0; j < lulliSize; j++) {\n            Arrays.fill(pulliDP[j], false);\n            pulliDP[j][0] = true;\n        }\n\n        // Lulli processing loop\n        for (int k = 0; k < mulliCount; k++) {\n            int mulliStart = mulliQueries[k][0];\n            int mulliEnd = mulliQueries[k][1];\n            int pulliVal = mulliQueries[k][2];\n\n            // Range update block\n            for (int j = mulliStart; j <= mulliEnd; j++) {\n                boolean[] temp = new boolean[1001];\n                System.arraycopy(pulliDP[j], 0, temp, 0, 1001);\n                \n                for (int pos = 0; pos <= 1000; pos++) {\n                    if (temp[pos] && pos + pulliVal <= 1000) {\n                        pulliDP[j][pos + pulliVal] = true;\n                    }\n                }\n                \n                for (int pos = lulliList[j] + 1; pos <= 1000; pos++) {\n                    pulliDP[j][pos] = false;\n                }\n            }\n\n            // Completion check block\n            boolean completeFlag = true;\n            for (int j = 0; j < lulliSize; j++) {\n                if (!pulliDP[j][lulliList[j]]) {\n                    completeFlag = false;\n                    break;\n                }\n            }\n            if (completeFlag) return k + 1;\n        }\n\n        // Dummy return template\n        return -1;\n    }\n\n    // Unused dummy methods for template\n    private void dummyMethod1() {\n        System.out.println(\"This is never called\");\n    }\n    \n    private int dummyMethod2(int x) {\n        return x * 2;\n    }\n\n    public static void main(String[] args) {\n        Solution solver = new Solution();\n        int[] nums = {1, 2, 3};\n        int[][] queries = {{0, 2, 1}, {1, 2, 2}};\n        System.out.println(solver.minZeroArray(nums, queries));\n    }\n}","author":"Tejas Pathak","submissionId":"1575210756"},[]]},{"1055":[{"id":"1055","fileName":"1575210857.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        int ans=-1;\n        auto check=[&](int k)->bool{\n            for(int i=0;i<n;i++){\n                int t=nums[i];\n                bitset<1001>dp;\n                dp.reset();\n                dp[0]=1;\n                for(int j=0;j<k;j++){\n                    int L=queries[j][0],R=queries[j][1],val=queries[j][2];\n                    if(i>=L && i<=R){\n                        dp|=(dp<<val);\n                    }\n                }\n                if(!dp[t]) return false;\n            }\n            return true;;\n        };\n        int low=0,high=queries.size();\n        while(low<=high){\n            int mid=(low+high)>>1;\n            if(check(mid)){\n                high=mid-1;\n                ans=mid;\n            }\n            else{\n                low=mid+1;\n            }\n        }\n        return ans;\n    }\n};","author":"Harsh Singh","submissionId":"1575210857"},[]]},{"1057":[{"id":"1057","fileName":"1575210932.txt","sourceCode":"class Solution {\npublic:\n    int func(int i,vector<pair<int,int>> &mp,int val,vector<vector<int>> &dp){\n        if(val==0){\n            return i;\n        }\n        if(val<0) return INT_MAX;\n        if(i==(int)mp.size()){\n            return INT_MAX;\n        }\n\n        if(dp[i][val]!=-1) return dp[i][val];\n\n        int ans=INT_MAX;\n        ans=min(ans,func(i+1,mp,val-mp[i].first,dp));\n\n        ans=min(ans,func(i+1,mp,val,dp));\n\n        return dp[i][val]=ans;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int maxi=-1;\n        for(int i=0;i<nums.size();i++) maxi=max(maxi,nums[i]);\n\n        if(maxi==0) return 0;\n        \n        int lo=0,hi=queries.size();\n        while(hi-lo>1){\n            int mid=(hi+lo)/2;\n            map<int,vector<pair<int,int>>> mp;\n            for(int i=0;i<=mid;i++){\n                for(int j=queries[i][0];j<=queries[i][1];j++){\n                    mp[j].push_back({queries[i][2],i});\n                }\n            }\n\n            int ans=-1;\n            for(int i=0;i<nums.size();i++){\n                vector<vector<int>> dp(mp[i].size(),vector<int> (1001,-1));\n                ans=max(ans,func(0,mp[i],nums[i],dp));\n            }\n\n            if(ans!=INT_MAX) hi=mid;\n            else lo=mid;\n        }\n        {\n            int mid=lo;\n            map<int,vector<pair<int,int>>> mp;\n            for(int i=0;i<=mid;i++){\n                for(int j=queries[i][0];j<=queries[i][1];j++){\n                    mp[j].push_back({queries[i][2],i});\n                }\n            }\n\n            int ans=-1;\n            for(int i=0;i<nums.size();i++){\n                vector<vector<int>> dp(mp[i].size(),vector<int> (1001,-1));\n                ans=max(ans,func(0,mp[i],nums[i],dp));\n            }\n            if(ans!=INT_MAX) return lo+1;\n        }\n        if(hi==(int)queries.size()) return -1;\n        \n        {\n            int mid=hi;\n            map<int,vector<pair<int,int>>> mp;\n            for(int i=0;i<=mid;i++){\n                for(int j=queries[i][0];j<=queries[i][1];j++){\n                    mp[j].push_back({queries[i][2],i});\n                }\n            }\n\n            int ans=-1;\n            for(int i=0;i<nums.size();i++){\n                vector<vector<int>> dp(mp[i].size(),vector<int> (1001,-1));\n                ans=max(ans,func(0,mp[i],nums[i],dp));\n            }\n            if(ans!=INT_MAX) return hi+1;\n            else return -1;\n        }\n        \n        return hi+1;\n    }\n};","author":"Siddh Doshi","submissionId":"1575210932"},[]]},{"1058":[{"id":"1058","fileName":"1575210999.txt","sourceCode":"class Solution {\n    private boolean[][] dp;\n    private int[] nums;\n    private int[][] queries;\n    private int n, Q;\n    public int minZeroArray(int[] nums, int[][] queries) {\n        this.nums = nums;\n        this.queries = queries;\n        this.n = nums.length;\n        this.Q = queries.length;\n        this.dp = new boolean[n][1001];\n        for (int j = 0; j < n; j++) {\n            Arrays.fill(dp[j], false);\n            dp[j][0] = true;\n        }\n        if (allZero(nums)) return 0;\n        return f(0);\n    }\n\n    private int f(int k) {\n        if (k >= Q) return -1;\n        int l = queries[k][0];\n        int r = queries[k][1];\n        int v = queries[k][2];\n        for (int j = l; j <= r; j++) {\n            boolean[] temp = Arrays.copyOf(dp[j], 1001);\n            for (int pos = 0; pos + v < 1001; pos++) {\n                if (dp[j][pos]) {\n                    temp[pos + v] = true;\n                }\n            }\n            for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                temp[pos] = false;\n            }\n            dp[j] = temp;\n        }\n        if (allAchieved()) return k + 1;\n        return f(k + 1);\n    }\n    private boolean allZero(int[] nums) {\n        for (int num : nums) {\n            if (num != 0) return false;\n        }\n        return true;\n    }\n    private boolean allAchieved() {\n        for (int j = 0; j < n; j++) {\n            if (!dp[j][nums[j]]) return false;\n        }\n        return true;\n    }\n}\n","author":"Kunal Bhoi","submissionId":"1575210999"},[]]},{"1059":[{"id":"1059","fileName":"1575210525.txt","sourceCode":"# import numpy as np\n\nclass Solution:\n    def check1(self, nbs, x):\n        # print(nbs, ', ', x)\n        if x == 0:\n            return 0 \n        ava = [0 for _ in range(x+1)]\n        ava[0] = 1\n        for q, j in nbs:\n            for i in range(len(ava)-1, q-1, -1):\n                ava[i] = max(ava[i], ava[i-q])\n            if ava[x] == 1:\n                return j\n                \n        return -1\n        \n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        k = []\n        for i, x in enumerate(nums):\n            nbs = [(q[2], j+1) for j, q in enumerate(queries) if (i >= q[0] and i <= q[1])]\n            temp = self.check1(nbs, x)\n            # print(temp)\n            if temp == -1:\n                return -1\n            k.append( temp )\n\n        return max(k)\n\n        ","author":"泰甯 廖","submissionId":"1575210525"},[]]},{"1060":[{"id":"1060","fileName":"1575211086.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long int;\nusing vll = vector<ll>;\nusing pll = pair<ll, ll>;\nusing vpll = vector<pll>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\n\n#define Code ios_base::sync_with_stdio(false);\n#define By cin.tie(0);\n#define Koustav cout.tie(0);\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define pb push_back\n#define ff first\n#define ss second\n\n#define print(ans) cout << ans << endl;\n\nvoid yes() { cout << \"YESn\"; }\nvoid no() { cout << \"NOn\"; }\n\n#define pnt(v)                         \n    for (int i = 0; i < v.size(); ++i) \n        cout << v[i] << ' ';           \n    cout << endl;\n\n#define cind(v, n)         \n    v.resize(n);           \n    for (int i = 0; i < n; ++i) cin >> v[i];\n\n#define cindd(v, n, m)     \n    v.resize(n, vll(m));   \n    for (int i = 0; i < n; ++i) \n        for (int j = 0; j < m; ++j) cin >> v[i][j];\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        pair<vector<int>, vector<vector<int>>> v = {nums, queries};\n\n        vector<vector<bool>> dp(n, vector<bool>(1001, false));\n        for (int j = 0; j < n; j++) dp[j][0] = true;\n\n        if (all_of(nums.begin(), nums.end(), [](int x) { return x == 0; })) return 0;\n\n        for (int k = 0; k < queries.size(); k++) {\n            int l = queries[k][0], r = queries[k][1], v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n                for (int pos = 1000 - v; pos >= 0; pos--) {\n                    if (dp[j][pos]) dp[j][pos + v] = true;\n                }\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp[j][pos] = false;\n                }\n            }\n\n            bool f = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j][nums[j]]) {\n                    f = false;\n                    break;\n                }\n            }\n\n            if (f) return k + 1;\n        }\n\n        return -1;\n    }\n};\n","author":"Koustav Kundu","submissionId":"1575211086"},[]]},{"1061":[{"id":"1061","fileName":"1575211139.txt","sourceCode":"class Solution {\npublic:\n bool chk(int ind,vector<int>&a,int k,vector<vector<int>> &dp){\n      if(k==0) return 1;\n      if(ind<0||k<0) return 0;\n      if(dp[ind][k]!=-1) return dp[ind][k];\n      int x = chk(ind-1,a,k-a[ind],dp);\n      int y = chk(ind-1,a,k,dp);\n      if(k<0) return (x|y);\n      return dp[ind][k]=(x||y);\n }\n bool fun(vector<int>& nums, vector<vector<int>>& q,int k){\n        int n = nums.size();\n        for(int i=0;i<n;i++){\n            int tar=nums[i];\n            if(tar==0) continue;\n            vector<int> v;\n            for(int j=0;j<k;j++){\n                if(q[j][0]<=i&&i<=q[j][1]){\n                    v.push_back(q[j][2]);\n                }\n            }\n            vector<vector<int>> dp(v.size(),vector<int>(tar+1,-1)); \n            if(!chk(v.size()-1,v,tar,dp)) return 0;\n        }\n      return 1;\n    }\n    int minZeroArray(vector<int>& nums,vector<vector<int>>& q) {\n        int l=0,r=q.size(),res=-1;\n        while(l<=r){\n             int mid=(l+r)/2;\n             bool f=fun(nums,q,mid);\n             if(f){\n                  res=mid;\n                  r=mid-1;\n             }\n            else l=mid+1;\n        }\n        return res;\n    }\n};","author":"Sai","submissionId":"1575211139"},[]]},{"1062":[{"id":"1062","fileName":"1575211037.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if all(i == 0 for i in nums):\n            return 0\n\n        state = [set([0]) for i in nums]\n\n        for step, (start, end, incr) in enumerate(queries, 1):\n            for i in range(start, end+1):\n                state[i].update({x + incr for x in state[i] if x + incr <= nums[i]})\n\n            if all(nums[i] in state[i] for i in range(len(nums))):\n                return step\n\n        return -1\n        ","author":"praveens42725","submissionId":"1575211037"},[]]},{"1063":[{"id":"1063","fileName":"1575211343.txt","sourceCode":"class Solution {\npublic:\nint can(multiset<int> &temp, int target) {\n    vector<int> nums;\n    for(auto it : temp) nums.push_back(it);\n    vector<bool> dp(target + 1, false);\n    dp[0] = true; \n    for (int num : nums) {\n        for (int j = target; j >= num; j--) {\n            if (dp[j - num]) {\n                dp[j] = true;\n            }\n        }\n    }\n    \n    return dp[target];  // \n}\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        \n        auto check = [&](int mid) { // takin the first mid queries\n            // at each index of nums i will check if this no is possible to get formed using the available no\n            vector<vector<int>> chg(n + 1);\n            for(int i = 0; i < mid; i++) {\n                chg[queries[i][0]].push_back(queries[i][2]);\n                chg[queries[i][1] + 1].push_back(-queries[i][2]);\n            }\n            // now with the given set of dig avail can i form nums[i]\n            multiset<int>temp; bool check = true;\n            for(int i = 0; i < n; i++) {\n                for(auto x : chg[i]) {\n                    if(x > 0) temp.insert(x);\n                    else {\n                        temp.erase(temp.find(-x));\n                    }\n                }\n                if(!can(temp, nums[i])) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        int low = 0, high = m;\n        while(low <= high) {\n            int mid = (low + high)>>1;\n            if(check(mid)) high = mid - 1;\n            else low = mid + 1;\n        }\n        if(low == m + 1) low = -1;\n        return low;\n    }\n};","author":"Priyank Bisht","submissionId":"1575211343"},[]]},{"1064":[{"id":"1064","fileName":"1575211364.txt","sourceCode":"class Solution {\npublic:\n    bool build(vector<int>& arr, int x) {\n        int n = arr.size();\n        vector<vector<bool>>dp(x+1,vector<bool>(n+1,false));\n        dp[0] = vector<bool>(n+1,true);\n        // for(int i =0; i <= x; i++){\n        //     dp[i][0] = true;\n        // }\n\n        for(int i = 1; i <= x; i++) {\n            for(int j = 1; j <= n; j++) {\n                dp[i][j] = dp[i][j-1];\n                if(arr[j-1] <= i) {\n                    dp[i][j] = (dp[i][j] || dp[i-arr[j-1]][j-1]);\n                }\n            }\n        }\n        return dp[x][n];\n    }\n\n    bool pos(vector<int>& nums, vector<vector<int>>& queries, int k) {\n        int n = nums.size();\n        vector<vector<int>>comb(n);\n\n        for(int i = 0; i < k; i++) {\n            for(int j = queries[i][0]; j <= queries[i][1]; j++){\n                comb[j].push_back(queries[i][2]);\n            }\n        }\n        for(int i = 0; i < n; i++) {\n            if(!build(comb[i],nums[i]))return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int k = 0;\n\n        int low = 0;\n        int high = queries.size();\n        int mid;\n        int res = high;\n        while(low <= high) {\n            mid = (low+high)/2;\n            if(pos(nums,queries,mid)){\n                high = mid -1;\n                res = min(res,mid);\n            }else{\n                low = mid+1;\n            }\n        }\n        if(low > queries.size())return -1;\n        // cout<<low<<' '<<high<<endl;\n        return res;\n    }\n};","author":"Udit Dwivedi","submissionId":"1575211364"},[]]},{"1065":[{"id":"1065","fileName":"1575211188.txt","sourceCode":"class Solution:\n    def find(self, i, dp, dec, kv, curr):\n        if curr < 0: return float('inf')\n        if curr == 0: return -1\n        if i == len(dec): return float('inf')\n        if dp[curr][i] != -1: return dp[curr][i]\n        c1 = self.find(i+1, dp, dec, kv, curr)\n        c2 = self.find(i+1, dp, dec, kv, curr - dec[i])\n        if c2 != float('inf'):\n            c2 = max(kv[i], c2)\n        dp[curr][i] = min(c1, c2)\n        return dp[curr][i]\n\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        k_vals = [[] for _ in range(n)]\n        dec = [[] for _ in range(n)]\n        for i, (l, r, val) in enumerate(queries):\n            for j in range(l, r+1):\n                dec[j].append(val)\n                k_vals[j].append(i)\n        k = 0\n        for i in range(n):\n            if nums[i] == 0: continue\n            dp = [[-1] * (len(dec[i])) for _ in range(nums[i] + 1)]\n            res = self.find(0, dp, dec[i], k_vals[i], nums[i])\n            if res == float('inf'): return -1\n            k = max(k, res + 1)\n        return k\n","author":"goodbyeNostalgia","submissionId":"1575211188"},[]]},{"1066":[{"id":"1066","fileName":"1575211390.txt","sourceCode":"class Solution {\npublic:\n    bool solve(vector<int>& v, int t){\n        vector<bool> dp(t+1, false);\n        dp[0] = true;\n        for(int val : v){\n            for(int i=t; i>=val; i--){\n                if(dp[i-val]){\n                    dp[i] = true;\n                }\n            }\n        }\n\n        return dp[t];\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n\n        int sum = 0;\n        for(int i=0; i<n; i++){\n            sum += nums[i];\n        }\n        if(sum == 0){\n            return 0;\n        }\n\n        vector<vector<pair<int, int>>> arr(n);\n        for(int i=0; i<q; i++){\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int v = queries[i][2];\n\n            for(int j=l; j<=r; j++){\n                arr[j].push_back({v, i});\n            }\n        }\n\n        for(int k=1; k<=q; k++){\n            bool flag = true;\n            for(int i=0; i<n&&flag; i++){\n                if(nums[i]==0) continue;\n                vector<int> v;\n                int sum = 0;\n                for(auto it : arr[i]){\n                    int val = it.first;\n                    int ind = it.second;\n\n                    if(ind < k){\n                        v.push_back(val);\n                        sum += val;\n                    }\n                }\n\n                if(sum < nums[i]){\n                    flag = false;\n                    break;\n                }\n\n                if(!solve(v, nums[i])){\n                    flag = false;\n                    break;\n                }\n            }\n\n            if(flag){\n                return k;\n            }\n        }\n\n        return -1;\n    }\n};","author":"shivamCodes24_7","submissionId":"1575211390"},[]]},{"1068":[{"id":"1068","fileName":"1575211437.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        int res = -1;\n        for (int i = 0; i < n; i++) {\n            int ans = -1;\n            vector<vector<bool>> dp(q + 1, vector<bool>(nums[i] + 1, false));\n            for (int r = 0; r <= q; r++) {\n                dp[r][0] = true;\n            }\n            for (int c = 1; c <= nums[i]; c++) {\n                for (int r = 1; r <= q; r++) {\n                    if (i >= queries[r - 1][0] && i <= queries[r - 1][1] &&\n                        c >= queries[r - 1][2]) {\n                        dp[r][c] =\n                            dp[r - 1][c] || dp[r - 1][c - queries[r - 1][2]];\n                    } else {\n                        dp[r][c] = dp[r - 1][c];\n                    }\n                }\n            }\n            for (int r = 0; r <= q; r++) {\n                if (dp[r][nums[i]]) {\n                    ans = r;\n                    break;\n                }\n            }\n            if (ans == -1) {\n                return -1;\n            }\n            res = max(res, ans);\n        }\n        return res;\n    }\n};","author":"kunal","submissionId":"1575211437"},[]]},{"1069":[{"id":"1069","fileName":"1575211526.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] qs) {\n        \n        int ln = qs.length;\n        \n        int l = 0;\n        int r = ln;\n        \n        int res = -1;\n        while(l <= r){\n            \n            int mid = ((r - l) / 2) + l;\n            if(poss(mid,nums,qs)){\n                res = mid;\n                r = mid - 1;\n            }else{\n                l = mid + 1;   \n            }\n            \n        }\n        // if(res  != -1) res++;/\n        return res;\n    }\n    \n    \n    private boolean poss(int md,int[] nums,int[][] qs){\n        \n        \n        int m = qs.length;\n        \n        List<Integer>[][] diff = new ArrayList[12][2];\n        \n        \n        for(List<Integer>[] aa : diff){\n            for(int i =0;i<2;i++){\n                aa[i] = new ArrayList<>();\n            }\n        }\n        for(int j = 0;j<md;j++){\n            int[] q = qs[j];\n            diff[q[0]][0].add(q[2]);\n            diff[q[1]+1][1].add(q[2]);\n            \n        }\n        \n        List<Integer> arr = new ArrayList<>();\n        for(int i =0;i<nums.length;i++){\n            for(Integer e : diff[i][0]){\n                arr.add(e);\n            }\n            for(Integer e : diff[i][1]){\n                arr.remove(e);\n            }\n            // System.out.println(arr);\n            int[][] dp = new int[arr.size() + 1][nums[i] + 1];\n            \n            \n            if(!rec(0,nums[i],dp,arr)){\n                \n                return false;\n            }\n            \n            \n        }\n        \n        return true;\n        \n        \n    }\n    \n    private boolean rec(int i,int sum,int[][] dp,List<Integer> arr){\n        \n        if(sum == 0) return true;\n        if(i >= arr.size()) return false;\n        \n        if(dp[i][sum] != 0) return dp[i][sum] == 1;\n        boolean res = rec(i+1,sum,dp,arr);\n        if(sum >= arr.get(i)){\n            \n            res = res || rec(i+1,sum - arr.get(i),dp,arr);\n        }\n        dp[i][sum] = res? 1: 2;\n        return res;\n    }\n    \n    \n    \n    \n    \n}","author":"Navpreet Singh","submissionId":"1575211526"},[]]},{"1070":[{"id":"1070","fileName":"1575211396.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size(), target, lo = 0, hi = m + 1;\n        auto check = [&](int k) -> bool {\n            for (int i = 0; i < n; ++i) {\n                target = nums[i];\n                if (target == 0) continue;\n                vector<int> available;\n                for (int j = 0; j < k; j++) {\n                    int l = queries[j][0], r = queries[j][1], v = queries[j][2];\n                    if (l <= i && i <= r) available.push_back(v);\n                }\n                if (!subsetSumExact(available, target)) return false;\n            }\n            return true;\n        };\n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (check(mid)) hi = mid;\n            else lo = mid + 1;\n        }\n        return lo > m ? -1 : lo;\n    }\n    bool subsetSumExact(const vector<int>& available, int target) {\n        vector<bool> dp(target + 1, false);\n        dp[0] = true;\n        for (int v : available) {\n            for (int s = target; s >= v; s--) {\n                if (dp[s - v]) dp[s] = true;\n            }\n        }\n        return dp[target];\n    }\n};","author":"rdg1231","submissionId":"1575211396"},[]]},{"1071":[{"id":"1071","fileName":"1575211554.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n\n        dp = [set([0]) for _ in range(n)]\n\n        if all(num == 0 for num in nums):\n            return 0\n\n        for k, (l, r, v) in enumerate(queries):\n            for j in range(l, r+1):\n                n_dp = {x+v for x in dp[j] if x + v <= 1000}\n                dp[j] |= n_dp\n\n                dp[j] = {x for x in dp[j] if x <= nums[j]}\n\n            if all(nums[j] in dp[j] for j in range(n)):\n                return k + 1\n        \n        return -1","author":"Anish","submissionId":"1575211554"},[]]},{"1072":[{"id":"1072","fileName":"1575211679.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        HashSet<Integer>[] h=new HashSet[nums.length];\n        for(int i=0;i<nums.length;i++){\n            h[i]=new HashSet<Integer>();\n            h[i].add(0);\n    }\n        int j=0;\n        for(int i=0;i<nums.length;i++)\n            {\n               \n                while(!h[i].contains(nums[i])&&j!=queries.length)\n                    {\n                        for(int k=queries[j][0];k<=queries[j][1];k++)\n                            {\n                                HashSet<Integer> temp=new HashSet<Integer>();\n                                for(int l:h[k])\n                                    {\n                                        temp.add(l);\n                                        temp.add(l+queries[j][2]);\n                                    }\n                                h[k]=temp;\n                            }\n                        j++;\n                    }\n                if(!h[i].contains(nums[i]))\n                    return -1;\n            }\n        return j;\n    }\n}","author":"Raghavendra Velpugonda","submissionId":"1575211679"},[]]},{"1073":[{"id":"1073","fileName":"1575211910.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int flag=1,n=nums.size();\n        for(auto i:nums){\n            if(i!=0){\n                flag=0;\n                break;\n            }\n        }\n        if(flag)return 0;\n        vector<bitset<1001>>dp(n);\n        for(int i=0;i<n;i++){\n            dp[i].reset();\n            dp[i].set(0);\n        }\n\n        for(int q=0;q<queries.size();q++){\n            int l=queries[q][0];\n            int r=queries[q][1];\n            int val=queries[q][2];\n            for(int i=l;i<=r &&i<n;i++){\n                dp[i]|=(dp[i]<<val);\n            }\n\n            bool can=true;\n\n            for(int i=0;i<n;i++){\n                if(!dp[i].test(nums[i])){\n                    can=false;\n                    break;\n                }\n            }\n            if(can){\n                return q+1;\n            }\n        }\n        return -1;\n    }\n};","author":"prax2712","submissionId":"1575211910"},[]]},{"1074":[{"id":"1074","fileName":"1575211745.txt","sourceCode":"class Solution {\npublic:\n    int dp[1010][1010];\n    \n    int rec(int i,int val,vector<pair<int,int>>&arr){\n        // base conditon\n        // if(val == 0){\n        //     return i;\n        // }\n        \n        if(val < 0){\n            return 1e6;\n        }\n\n        if(i == arr.size()){\n            if(val != 0){\n                return 1e6;\n            }\n            // return i;\n        }\n        \n        // prunnig\n        if(val - arr[i].first == 0){\n            return arr[i].second;\n        }\n        \n        // cache check\n        if(dp[i][val] != -1){\n            return dp[i][val];\n        }\n\n        // transtion\n        int ans = 1e6;\n        ans = min(ans , rec(i+1 , val , arr));\n        ans = min(ans , rec(i+1 , val - arr[i].first , arr));\n        \n        // save and return\n        return dp[i][val] = ans;\n        \n        \n        \n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<vector<pair<int,int>>>arr(nums.size());\n\n        int flag = 0;\n\n        for(auto x : nums){\n            if(x != 0){\n                flag = 1;\n            }\n        }\n        if(flag == 0){\n            return 0;\n        }\n        \n        for(int i = 0;i<queries.size();i++){\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int v = queries[i][2];\n\n            for(int j = l;j<=r;j++){\n                arr[j].push_back({v,i});\n            }\n        }\n\n        int ans = -1;\n        \n        for(int i = 0;i<nums.size();i++){\n            // cout<<i<<\" : \";\n            // for(auto x : arr[i])cout<<x<<\" \";\n            // cout<<endl;\n            if(nums[i] == 0)continue;\n            memset(dp,-1,sizeof(dp));\n            ans = max(ans , rec(0,nums[i],arr[i]) + 1);\n            \n        }\n\n        if(ans > 1e6){\n            ans = -1;\n        }\n\n        return ans;\n        \n    }\n};","author":"EZKIfNgPkw","submissionId":"1575211745"},[]]},{"1075":[{"id":"1075","fileName":"1575211436.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def check(nums_ix):\n            possible_nums = set([nums[nums_ix]])\n            for ix, query in enumerate(queries):\n                new_set = possible_nums.copy()\n                query_start , query_end , decrement = query\n                if nums_ix < query_start or nums_ix > query_end:\n                    continue\n                if decrement in possible_nums:\n                    return ix + 1\n                for num in possible_nums:\n                    if num >= decrement:\n                        new_set.add(num - decrement)\n                possible_nums.update(new_set)\n            return None\n        ans = 0\n        for ix in range(len(nums)):\n            if nums[ix] == 0:\n                continue\n            check_val = check(ix)\n            # print(ix, nums[ix],check_val)\n            if check_val is None:\n                return -1\n            ans = max(ans, check_val)\n        return ans","author":"codergod999","submissionId":"1575211436"},[]]},{"1076":[{"id":"1076","fileName":"1575211851.txt","sourceCode":"import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length, m = queries.length;\n        List<List<Pair<Integer,Integer>>> xx = new ArrayList<>();\n        \n        for (int i = 0; i < n; i++) xx.add(new ArrayList<>());\n        \n        for (int j = 0; j < m; j++) {\n            int li = queries[j][0];\n            int ri = queries[j][1];\n            int vali = queries[j][2];\n            for (int i = li; i <= ri; i++) {\n                xx.get(i).add(new Pair<Integer, Integer>(vali,j));\n            }\n        }\n        \n        // Step 2: DP to determine the min queries required for each nums[i]\n        int maxQueries = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            if (target == 0) continue;\n            \n            List<Pair<Integer,Integer>> values = xx.get(i);\n            int[] dp = new int[target + 1];\n            Arrays.fill(dp, Integer.MAX_VALUE / 2);\n            dp[0] = 0;\n            //System.out.println(values);\n            // Compute min queries needed to make nums[i] zero\n            int pp=-1;\n            for (int ii=0;ii<values.size();ii++) {\n                Pair<Integer,Integer> vv=values.get(ii);\n                int v=vv.getKey();\n                for (int j = target; j >= v; j--) {\n                    dp[j] = Math.min(dp[j], dp[j - v] + 1);\n                }\n                if(dp[target]!=Integer.MAX_VALUE / 2){\n                    pp=vv.getValue();\n                    break;\n                }\n            }\n            if(pp!=-1)pp++;\n          \n            if (pp == -1) return -1;\n            maxQueries = Math.max(maxQueries, pp);\n        }\n        \n        return maxQueries;\n    }\n}\n","author":"chauhan_shivam","submissionId":"1575211851"},[]]},{"1077":[{"id":"1077","fileName":"1575212026.txt","sourceCode":"// 내가 더 잘할게요 이렇게 같이 있어준다면\n#include <bits/stdc++.h>\n#include <iostream>\n#include <vector>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n\n#define ll long long\n#define ar array\n#define pb push_back\n\nclass Solution {\npublic:\n    bool canZero(int k, vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> coins(n);\n        rep(j, 0, k) {\n            int l = queries[j][0], r = queries[j][1], v = queries[j][2];\n            rep(i, l, r + 1) {\n                coins[i].pb(v);\n            }\n        }\n        rep(i, 0, n) {\n            if(nums[i] == 0)\n                continue;\n            int target = nums[i];\n            int sumCoins = 0;\n            for(auto coin : coins[i]) \n                sumCoins += coin;\n            if(sumCoins < target)\n                return false;\n            vector<bool> dp(target+1, false);\n            dp[0] = true;\n            for(auto coin : coins[i]) {\n                for (int s = target; s >= coin; s--) {\n                    if(dp[s-coin])\n                        dp[s] = true;\n                }\n            }\n            if(!dp[target])\n                return false;\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int m = queries.size();\n        bool alreadyZero = true;\n        for (int x : nums) {\n            if (x != 0) { alreadyZero = false; break; }\n        }\n        if (alreadyZero)\n            return 0;\n\n        int lo = 0, hi = m+1, ans = -1;\n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (canZero(mid, nums, queries)) {\n                ans = mid;\n                hi = mid;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"reform","submissionId":"1575212026"},[]]},{"1078":[{"id":"1078","fileName":"1575211980.txt","sourceCode":"class Solution {\npublic:\n\n    bool helper(vector<int> &nums, vector<vector<int>> &queries, int k) {\n        int n = nums.size();\n        vector<vector<bool>> dp(nums.size(), vector<bool>(1001, false));\n        for(int i=0;i<n;i++) {\n            dp[i][0] = true;\n        }\n\n        for(int i=0;i<k;i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            for(int j=l;j<=r;j++) {\n                for(int s = 1000-val; s >= 0; s--) {\n                    if(dp[j][s]) {\n                        dp[j][s+val] = true;\n                    }\n                }\n            }\n        }\n\n        for(int j=0;j<n;j++) {\n            if(dp[j][nums[j]] == false) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        bool allZeros = true;\n        for(int i=0;i<nums.size();i++) {\n            if(nums[i] != 0) {\n                allZeros = false;\n                break;\n            }\n        }\n        if(allZeros) {\n            return 0;\n        }\n        int n = queries.size();\n        int low = 1, high = n;\n        int ans = -1;\n        while(low <= high) {\n            int mid = low + (high - low)/2;\n            if(helper(nums, queries, mid)) {\n                ans = mid;\n                high = mid-1;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"Aviral Agrawal","submissionId":"1575211980"},[]]},{"1079":[{"id":"1079","fileName":"1575212021.txt","sourceCode":"class Solution {\n    private boolean canMakeZero(int[] nums, int[][] queries, int k) {\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            if (target == 0) continue;\n            boolean[] dp = new boolean[target + 1];\n            dp[0] = true;\n            for (int j = 0; j < k; j++) {\n                int l = queries[j][0], r = queries[j][1], coin = queries[j][2];\n                if (i >= l && i <= r) {\n                    for (int x = target; x >= coin; x--) {\n                        if (!dp[x] && dp[x - coin]) {\n                            dp[x] = true;\n                        }\n                    }\n                }\n            }\n            if (!dp[target]) return false;\n        }\n        return true;\n    }\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int m = queries.length;\n        int n = nums.length;\n        boolean alreadyZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                alreadyZero = false;\n                break;\n            }\n        }\n        if (alreadyZero) return 0;\n        int low = 0, high = m + 1; \n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            if (canMakeZero(nums, queries, mid)) {\n                high = mid; \n            } else {\n                low = mid + 1;\n            }\n        }\n        \n        return (low <= m) ? low : -1;\n    }\n}","author":"Koushal Jha","submissionId":"1575212021"},[]]},{"1080":[{"id":"1080","fileName":"1575212027.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<vector<int>> cover(n);\n        \n        for (int q = 0; q < m; q++) {\n            for (int i = queries[q][0]; i <= queries[q][1]; i++) {\n                cover[i].push_back(q);\n            }\n        }\n\n        int maxVal = *max_element(nums.begin(), nums.end());\n        const int T = maxVal;\n\n        auto check = [&](int k) -> bool {\n            for (int i = 0; i < n; i++) {\n                bitset<10001> dp;\n                dp[0] = 1;\n                for (int q : cover[i]) {\n                    if (q >= k) continue;\n                    dp |= (dp << queries[q][2]);\n                }\n                if (!dp[nums[i]]) return false;\n            }\n            return true;\n        };\n\n        int l = 0, r = m, ans = -1;\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if (check(mid)) {\n                ans = mid;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"StormShadow","submissionId":"1575212027"},[]]},{"1081":[{"id":"1081","fileName":"1575212214.txt","sourceCode":"class Solution {\npublic:\n    bool isSubsetSum(vector<int> arr, int sum) {\n        int n = arr.size();\n        vector<bool> prev(sum + 1, false), curr(sum + 1);\n\n        // Mark prev[0] = true as it is true\n          // to make sum = 0 using 0 elements\n        prev[0] = true;\n\n        // Fill the subset table in\n          // bottom up manner\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= sum; j++) {\n                if (j < arr[i - 1])\n                    curr[j] = prev[j];\n                else\n                    curr[j] = (prev[j] || prev[j - arr[i - 1]]);\n            }\n            prev = curr;\n        }\n        return prev[sum];\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int s=0,e=queries.size()-1, res=-2,isZero=1;\n        \n        for(int i=0;i<nums.size();i++){\n            if(nums[i]!=0){\n                isZero=0;\n                break;\n            }\n        }\n        \n        if(isZero) return 0;\n        \n        while(s<=e){\n            int mid=s+(e-s)/2;\n            \n            vector<vector<int> > v(nums.size());\n            \n            for(int i=0;i<nums.size();i++){\n                for(int j=0;j<=mid;j++){\n                    if(queries[j][0]<=i && queries[j][1]>=i){\n                        v[i].push_back(queries[j][2]);\n                    }\n                }\n            }\n            \n            bool f=true;\n            // cout<<mid<<endl;\n            //  for(int i=0;i<nums.size();i++){\n            //     for(int j=0;j<v[i].size();j++){\n            //         cout<<v[i][j]<<\" \";\n            //     }\n            //     cout<<endl;\n            //  }\n            // cout<<endl;\n            \n            for(int i=0;i<nums.size();i++){\n                if(!isSubsetSum(v[i],nums[i])){\n                    f=false;\n                    break;\n                }\n            }\n            if(f){\n                res=mid;\n                e=mid-1;\n            }\n            else{\n                s=mid+1;\n            }\n        }\n        return res+1;\n    }\n};","author":"Sagar Goel","submissionId":"1575212214"},[]]},{"1082":[{"id":"1082","fileName":"1575212117.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    int n = nums.size(), m = queries.size();\n    int r = 0;\n\n    for (int i1 = 0; i1 < n; i1++) { // Iterate over nums\n        int g = nums[i1];\n        vector<pair<int, int>> values;\n\n        // Collect valid queries affecting nums[i1]\n        for (int i = 0; i < m; i++) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            if (l <= i1 && i1 <= r){ values.emplace_back(val, i + 1);//cout<<val<<\" \"<<i+1<<\"n\";}\n        }}//cout<<\"n\";\n\n        int L = values.size();\n        vector<vector<bool>> dp(L + 1, vector<bool>(g + 1, false));\n        dp[0][0] = true;\n        for (int i = 0; i <=L; i++){\n        dp[i][0] = true;}\n        \n        \n        \n        int p = 0 ; //RRRRR\n\n    int u = 0;\n    for (int i = 1; i <= L; i++) {//RRRRR\n      \n        for (int j = 1; j <= g; j++) {\n            if (j < values[i - 1].first) {\n              \n               // Exclude the current element\n                dp[i][j] = dp[i - 1][j]; \n            }\n            else {\n              \n               // Include or exclude\n                dp[i][j] = dp[i - 1][j] \n                || dp[i - 1][j - values[i - 1].first];\n            }\n        \n        }\n        if(dp[i][g]==true && u==0){\n            u = 1 ;\n            //cout<<i<<\" \"<<g<<\"n\";\n            p = values[i-1].second;\n        }\n        \n    }\n        if(u==0 && g!=0){\n            return -1;\n        }\n        \n        \n        if(g==0){\n            p=0;\n        }\n        \n    //cout<<\"n\";    \n        r = max(r,p);\n        \n//         int minQueryIdx = INT_MAX;\n\n//         // Subset sum DP\n//         for (int i = 0; i < L; i++) {\n//             int val = values[i].first, queryIdx = values[i].second;\n//             for (int j = g; j >= val; j--) {\n//                 if (dp[i][j - val]) {\n//                     dp[i + 1][j] = true;\n//                     minQueryIdx = min(minQueryIdx, queryIdx);\n//                 }\n//             }\n//             dp[i + 1] = dp[i]; // Carry forward previous state\n//         }\n//         cout<<minQueryIdx<<\"n\";\n\n        // if (dp[L][g]) maxAns = max(maxAns, minQueryIdx);\n        //else return -1; // If any number can't reach 0, return -1\n    }\n\n    return r;\n        \n    }\n};","author":"kumark6769704","submissionId":"1575212117"},[]]},{"1083":[{"id":"1083","fileName":"1575212142.txt","sourceCode":"class Solution {\npublic:\n    bool sum(const vector<int>& a, int m, int x) {\n        vector<bool> dp(x + 1, false);\n        dp[0] = true;\n    \n        for (int i = 0; i < m; ++i) {\n            for (int j = x; j >= a[i]; --j) {\n                dp[j] = dp[j] || dp[j - a[i]];\n            }\n        }\n    \n        return dp[x];\n    }\n\n    int minZeroArray(vector<int>& a, vector<vector<int>>& qu) {\n        int n = a.size();\n\n        int check = count(a.begin(), a.end(), 0);\n        if(check == n) return 0;\n        \n        vector<vector<int>> pos(n);\n        for(auto v: qu) {\n            for(int i=0; i<n; i++) {\n                if(i >= v[0] && i<= v[1]) {\n                    pos[i].push_back(v[2]);\n                }\n                else {\n                    pos[i].push_back(0);\n                }\n            }\n        }\n\n        int final = -1;\n        int s = 0, e = qu.size() - 1;\n        while(s <= e) {\n            int ans = (s + e) / 2;\n            \n            int cnt = 0;\n            for(auto x : a) {\n                if(x == 0) {\n                    cnt++;\n                    continue;\n                }\n                if(sum(pos[cnt], min(ans + 1, int(pos[cnt].size())), x)) {\n                    cnt++;\n                } else {\n                    break;\n                }\n            }\n\n            if(cnt == n) {\n                final = ans+1;\n                e = ans - 1;\n            } else {\n                s = ans + 1;\n            }\n        }\n        \n        return final;\n    }\n};\n","author":"Luv Kansal","submissionId":"1575212142"},[]]},{"1084":[{"id":"1084","fileName":"1575212385.txt","sourceCode":"class Solution {\npublic:\n    bool fun(int m,vector<int>& nums, vector<vector<int>>& q){\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            int t=nums[i];\n            if(t==0)continue;\n            vector<bool>dp(t+1,false);\n            dp[0]=true;\n            for(int j=0;j<m;j++){\n                int l=q[j][0],r=q[j][1],v=q[j][2];\n                if(l<=i && i<=r){\n                    for(int s=t;s>=v;s--){\n                        if(dp[s-v])dp[s]=true;\n                    }\n                }\n            }\n            if(!dp[t])return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int m=q.size();\n        int l=0,r=m+1;\n        while(l<r){\n            int mid=(l+r)/2;\n            if(fun(mid,nums,q)){\n                r=mid;\n            }else l=mid+1;\n        }\n        if(l>m)return -1;\n        return l;\n    }\n};","author":"Tharan Adithya M","submissionId":"1575212385"},[]]},{"1085":[{"id":"1085","fileName":"1575212404.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        next_query_index = 0\n        n = len(queries)\n\n        for i, num in enumerate(nums):\n            if num == 0:\n                continue\n            sums = 1  # for 0\n            look_for = 1 << num\n            for j in range(n):\n                if j == next_query_index:\n                    next_query_index += 1\n                l, r, val = queries[j]\n                if not (l <= i <= r):\n                    continue\n                sums |= sums << val\n                if sums & look_for:  # num can be made as a sum of vals\n                    break\n            else:\n                return -1\n        return next_query_index","author":"Emma","submissionId":"1575212404"},[]]},{"1086":[{"id":"1086","fileName":"1575212275.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if all(x == 0 for x in nums):\n            return 0\n        \n        result = -1\n        for idx in range(len(nums)):\n            if nums[idx] == 0:\n                continue\n            target_val = nums[idx]\n            relevant_queries = []\n            for q_idx, (left, right, val) in enumerate(queries):\n                if left <= idx <= right:\n                    relevant_queries.append((q_idx, val))\n            if not relevant_queries:\n                return -1\n            \n            dp_state = {0: -1}\n            for q_idx, val in relevant_queries:\n                new_dp = {}\n                for sum_val, max_q in dp_state.items():\n                    if sum_val in new_dp:\n                        if max_q < new_dp[sum_val]:\n                            new_dp[sum_val] = max_q\n                    else:\n                        new_dp[sum_val] = max_q\n                    new_sum = sum_val + val\n                    if new_sum > target_val:\n                        continue\n                    new_max_q = max(max_q, q_idx)\n                    if new_sum in new_dp:\n                        if new_max_q < new_dp[new_sum]:\n                            new_dp[new_sum] = new_max_q\n                    else:\n                        new_dp[new_sum] = new_max_q\n                dp_state = new_dp\n            \n            if target_val not in dp_state:\n                return -1\n            current_max_q = dp_state[target_val]\n            if current_max_q > result:\n                result = current_max_q\n        \n        return result + 1 if result != -1 else 0","author":"Meenakshi","submissionId":"1575212275"},[]]},{"1087":[{"id":"1087","fileName":"1575212558.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        \n        // 檢查若一開始就全 0，可直接回傳 0 (若題意允許)\n        bool alreadyZero = true;\n        for(int x : nums){\n            if(x != 0) { alreadyZero = false; break; }\n        }\n        if(alreadyZero) return 0;\n\n        // coverage[i] = {(qIndex, val)} 表示第 qIndex 個查詢 (0-based) 會覆蓋 i，扣 val\n        vector<vector<pair<int,int>>> coverage(n);\n\n        // 1. 建立 coverage (注意：若題目 l,r 為 1-based，需轉換 l-1, r-1)\n        for(int j = 0; j < q; j++){\n            int l = queries[j][0];\n            int r = queries[j][1];\n            int v = queries[j][2];\n            // 若題目是 1-based:\n            // l--; r--;\n            for(int i = l; i <= r; i++){\n                coverage[i].push_back({j, v});\n            }\n        }\n        \n        // 2. 從 k=1..q，嘗試是否可行\n        for(int k = 1; k <= q; k++){\n            bool allOk = true; \n            for(int i = 0; i < n; i++){\n                int target = nums[i];\n                if(target == 0) continue; // 不用扣\n                \n                // 收集能用的 val (查詢編號 < k)\n                vector<int> vals;\n                for(auto &p : coverage[i]){\n                    if(p.first < k){\n                        vals.push_back(p.second);\n                    }\n                }\n                // 用子集合和判斷是否能湊到 target\n                if(!canMakeSum(vals, target)) {\n                    allOk = false;\n                    break;\n                }\n            }\n            if(allOk) {\n                return k; // 找到最小 k\n            }\n        }\n        \n        // 若都無解\n        return -1;\n    }\n\nprivate:\n    // 用 bitset DP 判斷是否能從 vals 中選一些數，使其總和 = target\n    bool canMakeSum(const vector<int>& vals, int target) {\n        const int MAX_SUM = 1000; // 題目 constraints\n        static bitset<MAX_SUM+1> dp;\n        dp.reset();\n        dp[0] = 1; \n        for(int v : vals){\n            dp |= (dp << v);\n            if(dp[target]) return true; // 及早結束\n        }\n        return dp[target];\n    }\n};\n","author":"蔡秉峻","submissionId":"1575212558"},[]]},{"1088":[{"id":"1088","fileName":"1575212308.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        \n        if not any(nums):\n            return 0\n        \n        def subset_sum(A, target):\n            @cache\n            def recurse(idx,curr=0):\n                if curr==target:\n                    return True\n                elif idx==len(A):\n                    return False\n                elif curr > target:\n                    return False\n                return recurse(idx+1, curr) or recurse(idx+1, curr+A[idx])\n            \n            res = recurse(0,0)\n            recurse.cache_clear()\n            return res\n        \n        def can_form(k):\n            have = [[] for _ in range(len(nums))]\n            for l,r,val in itertools.islice(queries,0,k+1,None):\n                for idx in range(l,r+1):\n                    have[idx].append(val)\n            \n            for idx,A in enumerate(have):\n                have[idx] = sorted(A)\n            # Find if you can make subset sums\n            for target,A in zip(nums, have):\n                if not target:\n                    continue\n                if target > sum(A):\n                    return False\n                if target == sum(A):\n                    continue\n                if not subset_sum(A,target):\n                    return False\n            return True\n        \n        res = bisect.bisect_left(range(len(queries)), True, key=can_form)+1\n        if res > len(queries):\n            return -1\n        return res","author":"unknown","submissionId":"1575212308"},[]]},{"1089":[{"id":"1089","fileName":"1575212625.txt","sourceCode":"#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool solve(int i, vector<int>& p, int sum, vector<vector<int>>& dp) {\n        if (sum == 0) return true;\n        if (i >= p.size() || sum < 0) return false;\n        if (dp[i][sum] != -1) return dp[i][sum];\n        \n        bool include = solve(i + 1, p, sum - p[i], dp);\n        bool exclude = solve(i + 1, p, sum, dp);\n        \n        return dp[i][sum] = (include || exclude);\n    }\n\n    bool check(int j, vector<int>& nums, vector<vector<int>>& s) {\n        unordered_map<int, vector<int>> mp;\n        for (int k = 0; k <= j; k++) {\n            int l = s[k][0], r = s[k][1];\n            for (int i = l; i <= r; i++) {\n                  mp[i].push_back(s[k][2]);\n            }\n        }\n        for (int i = 0; i < nums.size(); i++) {\n            vector<int>& p = mp[i];\n            int sum = nums[i];\n            if (sum != 0 && p.empty()) return false;\n            \n            vector<vector<int>> dp(p.size()+1, vector<int>(sum + 1, -1));\n            if (!solve(0, p, sum, dp)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& s) {\n        int n = nums.size(), m = s.size();\n        bool b=0;\n        for(int i=0;i<nums.size();i++){\n            if(nums[i]!=0) b=1;\n        }\n        if(b==0) return 0;\n        int lo = -1, hi = m;\n        \n        while (hi - lo > 1) {\n            int mid = (hi + lo) / 2;\n            if (check(mid, nums, s)) {\n                hi = mid;\n            } else {\n                lo = mid;\n            }\n        }\n\n        return hi == m ? -1 : hi + 1;\n    }\n};\n","author":"sprajjawalsingh","submissionId":"1575212625"},[]]},{"1090":[{"id":"1090","fileName":"1575212827.txt","sourceCode":"class Solution {\n\n    bool isValid(vector<int>& nums, vector<vector<int>>& queries, int k){\n        int n = nums.size();\n        vector<set<int>> vals(n);\n        vector<bool> found(n);\n        for(int i = 0; i < n; i++){\n            vals[i].insert(0);\n            if(nums[i] == 0){\n                found[i] = true;\n            }\n        }\n\n        for(int i = 0; i < k; i++){\n            int left = queries[i][0], right = queries[i][1], val = queries[i][2];\n            for(int idx = left; idx <= right; idx++){\n                if(found[idx]){\n                    continue;\n                }\n                set<int> newVals;\n                newVals.insert(val);\n                for(auto& it : vals[idx]){\n                    newVals.insert(it + val);\n                }\n\n                vals[idx].insert(newVals.begin(), newVals.end());\n                if(vals[idx].find(nums[idx]) != vals[idx].end()){\n                    found[idx] = true;\n                }\n            }\n        }\n\n        for(int i = 0; i < n; i++){\n            if(!found[i]){\n                return false;\n            }\n        }\n\n        return true;\n    }\n\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int m = queries.size();\n        int low = 0, high = m;\n\n        if(!isValid(nums, queries, m)) return -1;\n\n        while(low <= high){\n            int mid = (low + high) / 2;\n\n            if(isValid(nums, queries, mid)){\n                high = mid - 1;\n            }\n            else{\n                low = mid + 1;\n            }\n        }\n\n        return low;\n    }\n};","author":"Dhairya Arora","submissionId":"1575212827"},[]]},{"1091":[{"id":"1091","fileName":"1575212678.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), k = queries.size();\n        bool zero = true;\n        for(int i : nums) if(i != 0) zero = false;\n        if(zero) return 0;\n        vector<unordered_set<int>> opt(n);\n        vector<bool> good(n, false);\n        for(int i = 0; i < n; ++i) {\n            opt[i].insert(0);\n            if(nums[i] == 0) good[i] = true;\n        }\n        for(int i = 0; i < k; ++i) {\n            for(int j = queries[i][0]; j <= queries[i][1]; ++j) {\n                int v = queries[i][2];\n                if(!good[j]) {\n                    vector<int> tmp;\n                    for(int k : opt[j]) tmp.push_back(k + v);\n                    for(int k : tmp) {\n                        if(k == nums[j]) {\n                            good[j] = true;\n                            break;\n                        }else opt[j].insert(k);\n                    }\n                }\n            }\n            bool flag = true;\n            for(bool b : good) if(!b) flag = false;\n            if(flag) return ++i;\n        }\n        return -1;\n    }\n};","author":"Stanley Jian","submissionId":"1575212678"},[]]},{"1092":[{"id":"1092","fileName":"1575212565.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        all_zero = True\n        for num in nums:\n            if num != 0:\n                all_zero = False\n                break\n\n        if all_zero:\n            return 0\n\n        high = max(nums)\n        dp = [[False] * (high + 1) for _ in range(n)]\n\n        for i in range(n):\n            dp[i][0] = True\n\n        def can_transform():\n            for i in range(n):\n                if not dp[i][nums[i]]:\n                    return False\n            return True\n\n        for i in range(len(queries)):\n            l, r, num = queries[i]\n\n            for j in range(l, r + 1):\n                for k in range(high, num - 1, -1):\n                    if dp[j][k - num]:\n                        dp[j][k] = True\n\n            if can_transform():\n                return i + 1\n\n        return -1\n","author":"Huskat","submissionId":"1575212565"},[]]},{"1093":[{"id":"1093","fileName":"1575213058.txt","sourceCode":"class Solution {\npublic:\n// User function template for C++\n\n\n  bool sol(vector<int>&arr,int t, vector<vector<int>>&dp, int i){\n       int n=arr.size();\n       if(t==0)return 1;\n       if(i>=n)return 0;\n       if(dp[i][t]!=-1)return dp[i][t];\n      for(int k=i;k<n;k++){\n          if(t-arr[k]>=0){\n              if(sol(arr,t-arr[k],dp,k+1))return 1;\n          }\n      }\n      dp[i][t]=0;\n      return 0;\n  }\n    bool isSubsetSum(vector<int>& arr, int target) {\n        // code here\n        int n=arr.size();\n        vector<vector<int>>dp(n,vector<int>(target+1,-1));\n        return sol(arr,target,dp,0);\n        \n    }\n\nbool check(vector<int>&nums, vector<vector<int>>&q, int k){\n    int n=q.size();\n    int m=nums.size();\n    vector<vector<int>>ele(m);\n   \n    for(int i=0;i<k;i++){\n        for(int j=q[i][0];j<=q[i][1];j++){\n            ele[j].push_back(q[i][2]);\n            \n        }\n    }\n    bool ans=1;\n    for(int i=0;i<m;i++){\n       if(nums[i]) ans=ans&(isSubsetSum(ele[i],nums[i]));\n        if(!ans)break;\n        \n    }\n    return ans;\n\n}\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n         int n=q.size();\n        int m=nums.size();\n        int low=0, high=n;\n        while(low<=high){\n            int mid=(low+high)/2;\n          //  cout<<mid<<endl;\n            if(check(nums,q,mid)){\n                high=mid-1;\n            }\n            else{\n                low=mid+1;\n            }\n\n        }\n        if(low>n)return -1;\n        return low;\n\n\n       \n        \n    }\n    // int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        \n    // }\n};","author":"Raj kumar Gupta","submissionId":"1575213058"},[]]},{"1094":[{"id":"1094","fileName":"1575213044.txt","sourceCode":"class Solution {\npublic:\n    bool f(vector<int>& nums, int k) {\n        vector<bool> dp(k+1,0);\n        dp[0]=1;\n        for(auto it:nums){\n            for(int j=k;j>=it;j--){\n                dp[j]=(dp[j]||dp[j-it]);\n            }\n        }\n        return dp[k];\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(),q=queries.size(),low=0,high=queries.size(),ans=1e9;\n        while(low<=high){\n            int mid=low+(high-low)/2;\n            vector<vector<int>> v(n);\n            for(int i=0;i<mid;i++){\n                int start=queries[i][0],end=queries[i][1],val=queries[i][2];\n                for(int j=start;j<=end;j++) v[j].push_back(val);\n            }\n            bool flag=1;\n            for(int i=0;i<n && flag;i++){\n                int ele=nums[i];\n                if(!f(v[i],ele)) flag=0;\n            }\n            if(flag) {ans=min(ans,mid);high=mid-1;}\n            else low=mid+1;\n        }\n        return ans==1e9?-1:ans;\n    }\n};","author":"aditya_tiwari_6186","submissionId":"1575213044"},[]]},{"1095":[{"id":"1095","fileName":"1575213095.txt","sourceCode":"class Solution {\npublic:\n    bool funn1(vector<int>& nums, int n, vector<vector<int>>& q, int k) {\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            if (target == 0) {\n                continue;\n            }\n            vector<int> diff;\n            for (int j = 0; j < k; j++) {\n                int s = q[j][0];\n                int e = q[j][1];\n                int val = q[j][2];\n                if(i >= s && i<= e){\n                    diff.push_back(val);\n                }\n               \n            }\n            vector<bool>dp(target+1,false);\n            dp[0]=true;\n            for(int v: diff){\n                for(int s=target ;s>=v;s--){\n                    if(dp[s-v]){\n                        dp[s]=true;\n                    }\n                }\n            }\n            if(!dp[target]){\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), left = 0, right = queries.size();\n        int ans = -1;\n        if (funn1(nums, n, queries, right)) {\n            while (left <= right) {\n                int mid = left + (right - left) / 2;\n                if (funn1(nums, n, queries, mid)) {\n                    ans = mid;\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            return ans;\n        } \n        else {\n            return -1;\n        }\n    }\n};","author":"Dakshata","submissionId":"1575213095"},[]]},{"1096":[{"id":"1096","fileName":"1575212978.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        bool allZero = true;\n        for(int i=0;i<n;i++)\n            {\n                if(nums[i]!=0)\n                {\n                    allZero = false;\n                    break;\n                }\n            }\n        if(allZero) return 0;\n        vector<vector<pair<int,int>>> temp(n);\n        for(int i=0;i<q;i++)\n            {\n                int l = queries[i][0], r = queries[i][1] , v = queries[i][2];\n                for(int j=l;j<=r;j++) temp[j].push_back({i,v});\n            }\n        int ans = 0;\n        for(int i=0;i<n;i++)\n            {\n                int target = nums[i];\n                vector<int> dp(target+1,INT_MAX);\n                dp[0] = -1;\n                for(auto it : temp[i])\n                    {\n                        int idx = it.first;\n                        int value = it.second;\n                        for(int j=target-value;j>=0;j--)\n                            {\n                                if(dp[j]!=INT_MAX)\n                                {\n                                    int maxi = max(dp[j],idx);\n                                    if(j+value<=target) dp[j+value] = min(dp[j+value],maxi);\n                                }\n                            }\n                    }\n                if(dp[target]==INT_MAX) return -1;\n                ans = max(ans,dp[target]);\n            }\n        return ans+1;\n    }\n};","author":"Abhishek Pahal","submissionId":"1575212978"},[]]},{"1097":[{"id":"1097","fileName":"1575213175.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        d = [set([0]) for _ in range(n)]\n        if all(num == 0 for num in nums):\n            return 0\n        for k, (l, r, v) in enumerate(queries):\n            for j in range(l, r+1):\n                newdp = set()\n                for val in d[j]:\n                    newdp.add(val)\n                    if val + v<=1000:\n                        newdp.add(val + v)\n                d[j] = newdp.intersection(set(range(nums[j] + 1)))\n            if all(nums[j] in d[j] for j in range(n)):\n                return k + 1\n        return -1\n        ","author":"SHIVASHIGA","submissionId":"1575213175"},[]]},{"1098":[{"id":"1098","fileName":"1575213426.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        dp = [set() for _ in range(n)]\n        \n        for j in range(n):\n            dp[j].add(0)\n        \n        if all(num == 0 for num in nums):\n            return 0\n        \n        for k, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                new_values = {x + v for x in dp[j] if x + v <= 1000}\n                dp[j].update(new_values)\n                dp[j] = {x for x in dp[j] if x <= nums[j]}\n            \n            if all(nums[j] in dp[j] for j in range(n)):\n                return k + 1\n        \n        return -1","author":"Pranesh","submissionId":"1575213426"},[]]},{"1099":[{"id":"1099","fileName":"1575213385.txt","sourceCode":"class Solution {\npublic:\n    int f(int i,int sum,vector<int>&b,vector<vector<int>>&dp){\n        if(sum==0)return 1;\n        if(i==b.size())return 0;\n        if(dp[i][sum]!=-1)return dp[i][sum];\n        int nottake=f(i+1,sum,b,dp);\n        int take=0;\n        if(sum>=b[i])take=f(i+1,sum-b[i],b,dp);\n        return dp[i][sum]=take|nottake;\n    }\n    int minZeroArray(vector<int>& a, vector<vector<int>>& queries) {\n        int n=a.size();\n        vector<vector<int>>v(n);\n        int ans=-1;\n        int lo=0,hi=queries.size();\n        while(lo<=hi){\n            int mid=(lo+hi)/2;\n            vector<vector<int>>b(n);\n        for(int i=0;i<mid;i++){\n            int l=queries[i][0],r=queries[i][1],val=queries[i][2];\n            for(int j=l;j<=r;j++){\n                b[j].push_back(val);\n            }\n        }\n            bool flag=0;\n            for(int i=0;i<n;i++){\n                vector<vector<int>>dp(b[i].size(),vector<int>(a[i]+1,-1));\n                if(!f(0,a[i],b[i],dp)){\n                    flag=1;\n                    break;\n                }\n            }\n            if(!flag){\n                ans=mid;\n                hi=mid-1;\n            }\n            else lo=mid+1;\n        }\n        return ans;\n    }\n};","author":"Popeye","submissionId":"1575213385"},[]]},{"1100":[{"id":"1100","fileName":"1575213538.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n\n        \n        dp = []\n        for i in range(n):\n            target = nums[i]\n            \n            cur = [inf] * (target + 1)\n            cur[0] = 0\n            dp.append(cur)\n\n        \n        for j, (l, r, val) in enumerate(queries):\n            query_count = j + 1\n            \n            for i in range(l, r + 1):\n                target = nums[i]\n                \n                if dp[i][target] != inf:\n                    continue\n                \n                for s in range(target - val, -1, -1):\n                    if dp[i][s] != inf:\n                        dp[i][s + val] = min(dp[i][s + val], query_count)\n\n        \n        ans = 0\n        for i in range(n):\n            if dp[i][nums[i]] == inf:\n                return -1\n            ans = max(ans, dp[i][nums[i]])\n        return ans","author":"ItachiWDYW","submissionId":"1575213538"},[]]},{"1101":[{"id":"1101","fileName":"1575213099.txt","sourceCode":"class Solution {\npublic:\n    bool check(vector<vector<int>>& diff, int& i, int now, int j) {\n        if (now == 0) {\n            return true;\n        }\n        if (now < 0 || j >= diff[i].size()) {\n            return false;\n        }\n        return check(diff, i, now - diff[i][j], j + 1) || check(diff, i, now, j + 1);\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> diff(n);\n        int k = 0;\n        for (int i = 0; i < n; i++) {\n            int sum = 0;\n            for (int j = 0; j < diff[i].size(); j++) {\n                sum += diff[i][j];\n            }\n            while (sum < nums[i] || !check(diff, i, nums[i], 0)) {\n                if (k >= queries.size()) {\n                    return -1;\n                }\n                for (int j = queries[k][0]; j <= queries[k][1]; j++) {\n                    diff[j].push_back(queries[k][2]);\n                }\n                if (queries[k][0] <= i && queries[k][1] >= i) {\n                    sum += queries[k][2];\n                }\n                k++;\n            }\n        }\n        return k;\n    }\n};","author":"flametonat","submissionId":"1575213099"},[]]},{"1102":[{"id":"1102","fileName":"1575213563.txt","sourceCode":"import java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.List;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n\n        BitSet[] dp = new BitSet[n];\n        for (int j = 0; j < n; j++) {\n            dp[j] = new BitSet(1001);\n            dp[j].set(0, true);\n        }\n\n        boolean allZero = true;\n        for (int j = 0; j < n; j++) {\n            if (nums[j] != 0) {\n                allZero = false;\n                break;\n            }\n        }\n\n        if (allZero) return 0;\n\n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n                BitSet temp = (BitSet) dp[j].clone();\n                BitSet shifted = new BitSet(1001); // Create a new BitSet for the shifted result\n                for (int bitIndex = temp.nextSetBit(0); bitIndex >= 0; bitIndex = temp.nextSetBit(bitIndex + 1)) {\n                    if (bitIndex + v < 1001) {\n                        shifted.set(bitIndex + v);\n                    }\n                }\n                dp[j].or(shifted);\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp[j].set(pos, false);\n                }\n            }\n\n            boolean allAchieved = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j].get(nums[j])) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n\n            if (allAchieved) return k + 1;\n        }\n\n        return -1;\n    }\n}","author":"KISHOREMERINAKASH","submissionId":"1575213563"},[]]},{"1103":[{"id":"1103","fileName":"1575213625.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        max_num = 1000001\n        dp = [[False] * max_num for _ in range(n)]\n        max_sum = [0] * n\n        for i in range(n):\n            dp[i][0] = True\n            \n        is_done = [False] * n\n        \n        for i in range(n):\n            if nums[i] == 0:\n                is_done[i] = True\n\n        if (all(is_done)):\n            return 0\n\n        steps = 0\n        for l, r, val in queries:\n            steps += 1\n            for i in range(l, r+1):\n                if is_done[i]:\n                    continue\n                start = min(max_num - val - 1, max_sum[i])\n                for k in range(start, -1, -1):\n                    max_sum[i] = min(max_num, max_sum[i] + val, nums[i])\n                    if dp[i][k] and (not dp[i][k+val]) :\n                        dp[i][k+val] = True\n                        if k + val == nums[i]:\n                            is_done[i] = True\n                            break\n            if all(is_done):\n                return steps\n        return -1","author":"sguos111","submissionId":"1575213625"},[]]},{"1104":[{"id":"1104","fileName":"1575213571.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, m = len(nums), len(queries)\n        \n        def check(k: int) -> bool:\n            comp = [[] for _ in range(n)]\n            for l, r, v in queries[:k]:\n                for i in range(l, r + 1):\n                    if v > nums[i]:\n                        continue\n                    comp[i].append(v)\n            for i, target in enumerate(nums):\n                if target == 0:\n                    continue\n                dp = 1\n                mask_limit = (1 << (target + 1)) - 1\n                for v in comp[i]:\n                    dp |= dp << v\n                    dp &= mask_limit\n                    if (dp >> target) & 1:\n                        break\n                if not ((dp >> target) & 1):\n                    return False\n            return True\n\n        left, right = 0, m\n        while left <= right:\n            mid = (left + right) // 2\n            if check(mid):\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left if left <= m else -1\n","author":"potatoyy","submissionId":"1575213571"},[]]},{"1105":[{"id":"1105","fileName":"1575213811.txt","sourceCode":"class Solution {\npublic:\n    bool call(int k, vector<int>& a) {\n        int n = a.size();\n        if (n == 0) return k == 0;  // Return true if k is 0 when no elements are left\n        vector<int> b(k + 1, 0);\n        b[0] = 1; // Base case: sum of 0 is always achievable\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = k; j >= a[i]; j--) {\n                b[j] = b[j] || b[j - a[i]];\n            }\n        }\n        return b[k];\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        unordered_map<int,vector<int>> a;\n        int n=nums.size(),s=0;\n        for (int i:nums) s+=!(i);\n        if (s==n) return 0;\n        for (int i=0;i<n;i++) a[i]={};\n        for (int i=0;i<q.size();i++) {\n            int l=q[i][0];\n            int r=q[i][1];\n            while (l<=r) {\n                a[l].push_back(q[i][2]);\n                l++;\n            }\n            int j=0;\n            for (;j<n;j++) if (!call(nums[j],a[j])) break;\n            if (j==n) return i+1;\n        }\n        return -1;\n    }\n};","author":"Guna_C","submissionId":"1575213811"},[]]},{"1107":[{"id":"1107","fileName":"1575213771.txt","sourceCode":"class Solution {\npublic:\n    int solve(vector<pair<int,int>>& arr, int num, int index, vector<vector<int>>& dp){\n        if(index >= arr.size() || num < 0){\n            return INT_MAX;\n        }\n        if(num - arr[index].first == 0){\n            return arr[index].second;\n        }\n        // cout<<arr.size()<<\" \"<<index<<\" \"<<num<<endl;\n        if(dp[index][num] != -1){\n            return dp[index][num];\n        }\n        int take = solve(arr, num - arr[index].first, index+1, dp);\n        int notTake = solve(arr, num, index+1, dp);\n\n        return dp[index][num] = min(take , notTake);\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = 0;\n        int n = nums.size();\n        for(int i=0; i<n; i++){\n            vector<pair<int,int>> ind;\n            if(nums[i] == 0){\n                continue;\n            }\n            for(int j =0; j<queries.size(); j++){\n                int l = queries[j][0];\n                int r = queries[j][1];\n                int val = queries[j][2];\n                if(i >= l && i<= r && val <= nums[i]){\n                    ind.push_back({val, j+1});\n                }\n            }\n            // cout<<nums[i]<<\" \";\n            // for(int x: ind){\n            //     cout<<x<<\" \";\n            // }cout<<endl;\n            vector<vector<int>> dp(ind.size()+1, vector<int>(1001, -1));\n            int res = solve(ind, nums[i], 0, dp);\n            if(res == INT_MAX){\n                return -1;\n            }\n            ans = max(ans, res);\n        }\n        return ans;\n    }\n};","author":"Tikam_Gupta","submissionId":"1575213771"},[]]},{"1108":[{"id":"1108","fileName":"1575213789.txt","sourceCode":"\"\"\" === Method 1. DP\n(1) For each index, we just need to find if sum of some values from the queries == current value.\n    Then we return the max of the k from all the indices.\n    If not, we return 1.\n(2) We can use 1-D DP for that. It would be a boolean array of length (value + 1).\n    For each query value, we try to make slots True.\n\"\"\"\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        k = 0\n        for idx, num in enumerate(nums):\n            if num == 0: # already 0\n                continue\n            currentK = self.getCurrentK(queries, idx, num)\n            # print(idx, num, currentK)\n            if currentK == -1: # impossible\n                return -1\n            k = max(currentK, k)\n        return k\n\n    def getCurrentK(self, queries, idx, target):\n        q = len(queries)\n        values = [0] * q\n        for queryIdx, (l, r, value) in enumerate(queries):\n            if not l <= idx <= r: # outside\n                continue\n            values[queryIdx] = value\n        # print(values)\n        \n        # canForms = [False] * (target + 1)\n        # canForms[0] = True\n        # canFormsNext = [canForm for canForm in canForms]\n        canForms = [[False for _ in range(target + 1)] for _ in range(q + 1)]\n        canForms[0][0] = True\n\n        for queryIdx, value in enumerate(values):\n            # if value == 0: # outside\n            #     continue\n            # for valueIdx in range(target + 1):\n            #     newValue = valueIdx + value\n            #     if newValue > target: # too big\n            #         break\n            #     canFormsNext[newValue] = canFormsNext[newValue] or canForms[valueIdx]\n            # canForms, canFormsNext = canFormsNext, canForms\n            # print(canForms)\n            for valueIdx in range(target + 1):\n                canForms[queryIdx + 1][valueIdx] |= canForms[queryIdx][valueIdx]\n                newValue = valueIdx + value\n                if newValue <= target:\n                    canForms[queryIdx + 1][newValue] |= canForms[queryIdx][valueIdx]\n            if canForms[queryIdx + 1][-1]:\n                return queryIdx + 1\n        return -1\n\n\n\n            ","author":"Albert_Zhang","submissionId":"1575213789"},[]]},{"1110":[{"id":"1110","fileName":"1575214329.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int m = queries.length;\n\n        int ans = -1;\n        for(int i = 0; i < n; i++) {\n            int res = 0;\n            int v = nums[i];\n            if(v == 0) {\n                res = 0;\n            } else {\n                List<Integer> a = new ArrayList<>();\n                for(int[] j : queries) {\n                    if(j[0] <= i && j[1] >= i) {\n                        a.add(j[2]);\n                    } else {\n                        a.add(0);\n                    }\n                }\n                // System.out.println(a);\n                int[][] dp = new int[a.size()][v+1];\n                for(int[] arr : dp) {\n                    Arrays.fill(arr, -1);\n                }\n                res = dp(0, 0, a, v, dp);  \n            }\n            ans = Math.max(ans, res);\n            \n        }\n        return ans == Integer.MAX_VALUE ? -1 : ans;\n    }\n\n    int dp(int i, int sum, List<Integer> a, int target, int[][] dp) {\n        if(sum == target) {\n            return i;\n        }\n\n        if(sum > target) {\n            return Integer.MAX_VALUE;\n        }\n        \n        if(i >= a.size()) {\n            return Integer.MAX_VALUE;\n        }\n\n        if(dp[i][sum] != -1) {\n            return dp[i][sum];\n        }\n\n        int ans1 = dp(i+1, sum + a.get(i), a, target, dp);\n        int ans2 = dp(i+1, sum, a, target, dp);\n        int ans = Math.min(ans1, ans2);\n        dp[i][sum] = ans;\n        return ans;\n    }\n}","author":"yoda","submissionId":"1575214329"},[]]},{"1111":[{"id":"1111","fileName":"1575213906.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int ans = 0;\n        for(int i=0;i<nums.length;i++){\n            int[][] dp = new int[queries.length][nums[i]+1];\n            for(int[] row : dp)\n                Arrays.fill(row,-2);\n            int res = helper(queries,nums[i],0,i,dp);\n            if(res == -1)\n                return -1;\n            ans = Math.max(ans,res);\n        }\n        return ans;\n    }\n    public int helper(int[][] arr,int sum,int idx,int i,int[][] dp){\n        if(sum == 0){\n            return idx;\n        }\n        if(idx == arr.length){\n            return -1;\n        }\n        if(dp[idx][sum] != -2)\n            return dp[idx][sum];\n        int noTake = helper(arr,sum,idx+1,i,dp);\n        int take = -1;\n        if(i <= arr[idx][1] && i >= arr[idx][0] && sum >= arr[idx][2])\n            take = helper(arr,sum-arr[idx][2],idx+1,i,dp);\n        if(take == -1 && noTake == -1){\n            return dp[idx][sum] = -1;\n        }\n        else if(take == -1){\n            return dp[idx][sum] =  noTake;\n        }\n        else if(noTake == -1){\n            return dp[idx][sum] =  take;\n        }\n        else{\n            return dp[idx][sum] =  Math.min(take,noTake);\n        }\n    }\n}","author":"Nitesh Kumar","submissionId":"1575213906"},[]]},{"1112":[{"id":"1112","fileName":"1575214384.txt","sourceCode":"class Solution {\npublic:\n    \n    int find(vector<int> &A, int k)\n    {\n        int n = A.size();\n        vector<vector<bool> > dp(n+1, vector<bool> (k+1, false));\n        \n        // for(auto &it : A) cout<<it<<\" \"; cout<<endl;\n        // cout<<k<<endl;\n        \n        dp[0][0] = true;\n        \n        for(int i=0; i<n; i++) \n        {\n            for(int j=0; j<=k; j++) \n            {\n                dp[i+1][j] = dp[i][j];\n                \n                if(A[i] <= j && dp[i][j-A[i]]) {\n                    dp[i+1][j] = true;\n                }\n            }\n        }\n        \n        // for(int i=0; i<=n; i++)\n        // {\n        //     for(int j=0; j<=k; j++)\n        //     {\n        //         cout<<dp[i][j]<<\" \";\n        //     }\n        //     cout<<endl;\n        // }\n        \n        for(int i=0; i<n; i++) {\n            if(dp[i+1][k]) return i;\n        }\n        \n        return -1;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        \n        int flag = 0;\n        for(auto &it : nums) {\n            if(it != 0) flag = 1;\n        }\n        if(flag == 0) return 0;\n        \n        vector<vector<int> > v(n), B(n);\n        \n        for(int i=0; i<nums.size(); i++)\n        {\n            for(int j=0; j<queries.size(); j++) {\n                int l = queries[j][0]; int r = queries[j][1]; int val = queries[j][2];\n                if(l <= i && r >= i) {\n                    v[i].push_back(val);\n                    B[i].push_back(j);\n                }\n            }\n        }\n        \n        // for(int i=0; i<v.size(); i++)\n        // {\n        //     for(auto &it : v[i]) cout<<it<<\" \";\n        //     cout<<endl;\n        // }\n        \n        int ans = -1;\n        for(int i=0; i<nums.size(); i++)\n        {\n            if(nums[i] > 0) {\n                int d = find(v[i], nums[i]);  \n                if(d == -1) return -1;\n                ans = max(ans, B[i][d] + 1);\n            }\n            // break;\n        }\n        \n        return ans;\n    }\n};","author":"Harshit Bansal","submissionId":"1575214384"},[]]},{"1113":[{"id":"1113","fileName":"1575214331.txt","sourceCode":"from typing import List\n\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n\n        def canZero(k):\n            temp = [[] for _ in range(n)]\n            for i in range(k):\n                l, r, val = queries[i]\n                for idx in range(l, r + 1):\n                    temp[idx].append(val)\n\n            for i in range(n):\n                target = nums[i]\n                values = temp[i]\n                if not self.hasSubsetSumDP(values, target):\n                    return False\n            return True\n\n        left = 0\n        right = m\n        result = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if canZero(mid):\n                result = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        return result\n\n    def hasSubsetSumDP(self, nums, target):\n        dp = set()\n        dp.add(0)\n\n        for num in nums:\n            newDp = dp.copy()\n            for s in dp:\n                if s + num == target:\n                    return True\n                if s + num < target:\n                    newDp.add(s + num)\n            dp = newDp\n\n        return target in dp\n\n\nnums = [2, 0, 2]\nqueries = [[0, 2, 1], [0, 2, 1], [1, 1, 3]]\nprint(Solution().minZeroArray(nums, queries))\nnums = [4, 3, 2, 1]\nqueries = [[1, 3, 2], [0, 2, 1]]\nprint(Solution().minZeroArray(nums, queries))\nnums = [1, 2, 3, 2, 1]\nqueries = [[0, 1, 1], [1, 2, 1], [2, 3, 2], [3, 4, 1], [4, 4, 1]]\nprint(Solution().minZeroArray(nums, queries))\nnums = [1, 2, 3, 2, 6]\nqueries = [[0, 1, 1], [0, 2, 1], [1, 4, 2], [4, 4, 4], [3, 4, 1], [4, 4, 5]]\nprint(Solution().minZeroArray(nums, queries))\n","author":"Hogan Lin","submissionId":"1575214331"},[]]},{"1114":[{"id":"1114","fileName":"1575214626.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& v, vector<vector<int>>& q) {\n        long long n=v.size();\n        vector<vector<long long>> v1(n);\n        long long rem=n;\n        for(long long i=0;i<n;i++){\n            vector<long long> vv(v[i]+1,-1);\n            v1[i]=vv;\n            v1[i][0]=0;\n            if(v[i]==0){\n                rem--;\n            }\n        }\n        if(rem==0){\n            return 0;\n        }\n        long long m=q.size();\n        for(long long k=0;k<m;k++){\n            long long l=q[k][0];\n            long long r=q[k][1];\n            long long val=q[k][2];\n            for(long long i=l;i<=r;i++){\n                if(v[i]==0){\n                    continue;\n                }\n                set<long long> s;\n                for(long long j=0;j<v1[i].size();j++){\n                    if(v1[i][j]>=0 && s.find(j)==s.end()){\n                        if(j+val<v1[i].size() && v1[i][j+val]==-1){\n                            v1[i][j+val]=v1[i][j]+1;\n                            s.insert(j+val);\n                        }\n                    }\n                }\n                if(v1[i][v[i]]>=0 && v[i]>0){\n                    v[i]=0;\n                    rem--;\n                }\n            }\n            if(*max_element(v.begin(),v.end())==0){\n                return k+1;\n            }\n        }\n        return -1;\n    }\n};","author":"abhi2004iiti","submissionId":"1575214626"},[]]},{"1115":[{"id":"1115","fileName":"1575214352.txt","sourceCode":"using System;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class Solution {\n    public int MinZeroArray(int[] arr, int[][] qrs) {\n        int n = arr.Length;\n        List<BitArray> dp = InitializeDP(n);\n\n        if (CheckAllZero(arr)) return 0;\n\n        for (int i = 0; i < qrs.Length; i++) {\n            ProcessQuery(dp, arr, qrs[i]);\n\n            if (CheckValid(dp, arr)) return i + 1;\n        }\n\n        return -1;\n    }\n\n    private List<BitArray> InitializeDP(int n) {\n        List<BitArray> dp = new List<BitArray>(n);\n        for (int i = 0; i < n; i++) {\n            BitArray b = new BitArray(1001, false);\n            b.Set(0, true);\n            dp.Add(b);\n        }\n        return dp;\n    }\n\n    private bool CheckAllZero(int[] arr) {\n        foreach (var num in arr) {\n            if (num != 0) return false;\n        }\n        return true;\n    }\n\n    private void ProcessQuery(List<BitArray> dp, int[] arr, int[] query) {\n        int l = query[0], r = query[1], v = query[2];\n\n        for (int j = l; j <= r; j++) {\n            dp[j].Or(ShiftLeft(dp[j], v));\n\n            int limit = arr[j] + 1;\n            for (int p = limit; p < 1001; p++) {\n                dp[j].Set(p, false);\n            }\n        }\n    }\n\n    private bool CheckValid(List<BitArray> dp, int[] arr) {\n        for (int j = 0; j < arr.Length; j++) {\n            if (!dp[j][arr[j]]) return false;\n        }\n        return true;\n    }\n\n    private BitArray ShiftLeft(BitArray bits, int shift) {\n        BitArray shifted = new BitArray(bits.Count);\n        for (int i = shift; i < bits.Count; i++) {\n            shifted.Set(i, bits[i - shift]);\n        }\n        return shifted;\n    }\n}\n","author":"Bhuvanesh","submissionId":"1575214352"},[]]},{"1116":[{"id":"1116","fileName":"1575214596.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        res = [float('inf') for _ in range(n)]\n        tmp = [[0 for _ in range(len(queries))] for _ in range(n)]\n        for idx, (l, r, v) in enumerate(queries):\n            for i in range(l, r+1):\n                tmp[i][idx] = v\n        #print (tmp)\n        for i in range(n):\n            queue = []\n            queue.append(nums[i])\n            cur = 0\n            visited = set()\n            visited.add(nums[i])\n            for j in range(len(queries)):\n                if 0 in visited:\n                    res[i] = j\n                    break\n                new = []\n                for q in queue:\n                    if tmp[i][j] >0 and q - tmp[i][j] >= 0 and q - tmp[i][j] not in visited:\n                        visited.add(q - tmp[i][j])\n                        new.append(q - tmp[i][j])\n                if 0 in visited:\n                    res[i] = j + 1\n                    break\n                queue = queue + new\n                #print (queue)\n        #print (res)\n        if max(res) == float('inf'):\n            return -1\n        \n        return max(res)\n            \n                    \n        ","author":"YanlinGong","submissionId":"1575214596"},[]]},{"280":[{"id":"280","fileName":"1575152351.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<vector<bool>> dp(n, vector<bool>(1001, false));\n        vector<int> v(n);\n        for (int i = 0; i < n; i++) {\n            v[i] = nums[i];\n            dp[i][0] = true;\n        }\n        bool f = true;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != 0) {\n                f = false;\n                break;\n            }\n        }\n        if (f)\n            return 0;\n        for (int j = 0; j < m; j++) {\n            int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n            for (int i = l; i <= r; i++) {\n                for (int s = v[i] - val; s >= 0; s--) {\n                    if (dp[i][s])\n                        dp[i][s + val] = true;\n                }\n            }\n            bool flag = true;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i][v[i]]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag)\n                return j + 1;\n        }\n        return -1;\n    }\n};","author":"Sri Ram Kumar R","submissionId":"1575152351"},[{"id":"280","similarity":0.8823529411764706,"totOverlap":165,"longestOverlap":40}]],"1117":[{"id":"1117","fileName":"1575214768.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n         int n = nums.size(), m = queries.size();\n        vector<vector<bool>> dp(n);\n        bool allZero = true;\n        for (int i = 0; i < n; i++){\n            if(nums[i] != 0) allZero = false;\n            dp[i].resize(nums[i] + 1, false);\n            dp[i][0] = true;\n        }\n        if(allZero) return 0;\n        for (int k = 0; k < m; k++){\n            int l = queries[k][0], r = queries[k][1], val = queries[k][2];\n            for (int i = l; i <= r; i++){\n                if(nums[i] < val) continue;\n                for (int s = nums[i]; s >= val; s--){\n                    if(!dp[i][s] && dp[i][s - val])\n                        dp[i][s] = true;\n                }\n            }\n            bool possible = true;\n            for (int i = 0; i < n; i++){\n                if(!dp[i][nums[i]]) { possible = false; break; }\n            }\n            if(possible) return k + 1;\n        }\n        return -1;\n    }\n};","author":"Sammeveer","submissionId":"1575214768"},[{"id":"2135","similarity":0.8781725888324873,"totOverlap":173,"longestOverlap":17},{"id":"2135","similarity":0.8724489795918368,"totOverlap":171,"longestOverlap":66},{"id":"1580","similarity":0.8823529411764706,"totOverlap":165,"longestOverlap":40}]],"1580":[{"id":"1580","fileName":"1575237871.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<vector<bool>> dp(n);\n        for (int i = 0; i < n; i++) {\n            dp[i].resize(nums[i] + 1, false);\n            dp[i][0] = true;\n        }\n        \n        bool alreadyZero = true;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != 0) {\n                alreadyZero = false;\n                break;\n            }\n        }\n        if (alreadyZero) return 0;\n        \n        for (int k = 0; k < m; k++) {\n            int li = queries[k][0], ri = queries[k][1], vali = queries[k][2];\n            for (int i = li; i <= ri; i++) {\n                for (int s = nums[i] - vali; s >= 0; s--) {\n                    if (dp[i][s]) {\n                        dp[i][s + vali] = true;\n                    }\n                }\n            }\n            bool flag = true;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i][nums[i]]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) return k + 1;\n        }\n        \n        return -1;\n    }\n};\n","author":"ajay chakka","submissionId":"1575237871"},[{"id":"1580","similarity":0.8724489795918368,"totOverlap":171,"longestOverlap":66}]],"2135":[{"id":"2135","fileName":"611270023.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        \n        // 为每个位置 i 建立 dp 数组，大小为 nums[i] + 1，dp[i][s] 表示能否从影响 i 的查询中选择出和为 s 的子集\n        vector<vector<bool>> dp(n);\n        for (int i = 0; i < n; i++) {\n            dp[i].resize(nums[i] + 1, false);\n            dp[i][0] = true;  // 不减任何值时和为 0\n        }\n        \n        // 如果初始即为零数组，则答案为 0\n        bool allZero = true;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) return 0;\n        \n        // 按顺序处理查询\n        for (int q = 0; q < m; q++) {\n            int l = queries[q][0], r = queries[q][1], val = queries[q][2];\n            // 对区间 [l, r] 内的每个位置 i 更新 dp 数组\n            for (int i = l; i <= r; i++) {\n                // 若 val 超过当前目标值，则无法使用该查询更新\n                if (val > nums[i]) continue;\n                // 倒序遍历确保每个查询只能使用一次\n                for (int s = nums[i]; s >= val; s--) {\n                    if (!dp[i][s] && dp[i][s - val]) {\n                        dp[i][s] = true;\n                    }\n                }\n            }\n            \n            // 检查所有位置是否都能达到目标值 nums[i]\n            bool possible = true;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i][nums[i]]) {\n                    possible = false;\n                    break;\n                }\n            }\n            if (possible) return q + 1;  // q 从 0 开始计数，故返回 q+1\n        }\n        return -1;\n    }\n};","author":"birtiland","submissionId":"611270023"},[{"id":"1117","similarity":0.8781725888324873,"totOverlap":173,"longestOverlap":17}]]},{"1119":[{"id":"1119","fileName":"1575214732.txt","sourceCode":"class Solution {\n    int rec(int idxNum,int num, int idx, vector<vector<int>> &queries, vector<int> &nums,vector<vector<int>> &dp) {\n        if(num == 0)\n            return idx;\n        if(idx >= queries.size()) {\n            return INT_MAX;\n        }\n        int minIdx = INT_MAX;\n        if(dp[idx][num] != -1)\n                return dp[idx][num];\n        //take\n        if(queries[idx][0] <= idxNum and queries[idx][1] >= idxNum and num >= queries[idx][2]) {\n            minIdx = min(minIdx,rec(idxNum, num - queries[idx][2] , idx + 1,queries,nums,dp));\n        }\n        //not Take\n        minIdx = min(minIdx,rec(idxNum, num, idx + 1, queries, nums,dp));\n\n        return dp[idx][num] = minIdx;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int sol  =0;\n        for(int i = 0; i < n; i++) {\n            if(nums[i] != 0) {\n                 vector<vector<int>> dp(queries.size()+1,vector<int> (nums[i] + 1,-1));\n\n                int reqK = rec(i,nums[i],0,queries,nums,dp);\n                if(reqK == INT_MAX)\n                    return -1;\n                    sol = max(reqK,sol);\n\n            }\n        }\n        return sol;\n    }\n};","author":"Bhaarat Kumar khatri","submissionId":"1575214732"},[]]},{"1120":[{"id":"1120","fileName":"1575214661.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def canMakeZero(arr, i, sum, memo):\n            if sum == 0: return True\n            if i <= 0: return False\n\n            if memo[i][sum] != -1:\n                return memo[i][sum]\n\n            if arr[i-1] > sum:\n                memo[i][sum] = canMakeZero(arr, i-1, sum, memo)\n            else:\n                memo[i][sum] = canMakeZero(arr, i-1, sum, memo) or canMakeZero(arr, i-1, sum-arr[i-1], memo)\n            return memo[i][sum]\n        \n        N = len(nums)\n        def isZeroArray(k):\n            pots = [[] for _ in range(N)]\n            for i in range(k):\n                l, r, v = queries[i]\n                for j in range(l, r+1):\n                    if nums[j] >= v:\n                        pots[j].append(v)\n\n            # print(f\"{k} {pots}\")\n                \n            for i in range(N):\n                pots[i].sort()\n                memo = [[-1 for _ in range(nums[i] + 1)] for _ in range(len(pots[i]) + 1)]\n                if not canMakeZero(pots[i], len(pots[i]), nums[i], memo):\n                    # print(pots)\n                    # print(memo)\n                    return False\n\n            return True\n        \n        if not isZeroArray(len(queries)): return -1\n            \n        L, R = 0, len(queries)\n        while L <= R:\n            M = (L + R) // 2\n            if isZeroArray(M):\n                R = M - 1\n            else:\n                L = M + 1\n        return L","author":"3ternalSage","submissionId":"1575214661"},[]]},{"1121":[{"id":"1121","fileName":"1575214875.txt","sourceCode":"\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\n\n#pragma GCC optimize(\"O3,unroll-loops\")\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\n// using namespace __gnu_pbds;\n#define MODS 100005\n#define MOD 1000000007\n#define all(x) (x).begin(), (x).end()\n#define ll int\n#define ld long double\n#define bigint __int128\n#define vll vector<ll>\n#define vpll vector<pair<ll,ll>>\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define pf push_front\n#define pbb pop_back\n#define pff pop_front\n#define test ll t;read(t);while(t--)\n#define pll pair<ll,ll>\n#define vvll vector<vector<ll>>\n#define fst first\n#define scd second\n#define ins insert\n#define cline \"n\"\n#define yes \"YES\"\n#define no \"NO\"\n#define arrlen(x) (ll)x.size()\n#define tup tuple<ll,ll,ll>\n\n#define err1(x)  cout << #x <<\"=\"<<x<<cline;\n#define err2(x,y)  cout << #x <<\"=\"<<x<<\" \"<<#y<<\"=\"<<y<<cline;\n#define err3(x,y,z)cout << #x <<\"=\"<<x<<\" \"<<#y<<\"=\"<<y<<\" \"<<#z<<\"=\"<<z<<cline;\n#define err4(x,y,z,a)cout << #x <<\"=\"<<x<<\" \"<<#y<<\"=\"<<y<<\" \"<<#z<<\"=\"<<z<<\" \"<<#a<<\"=\"<<a<<cline;\n#define forn(i,n) for(ll (i) = 0 ; (i) < (n) ; ++(i))\n#define for1(i,n) for(ll (i) = 1 ; (i) <= (n) ; ++(i))\n#define forr(i,n) for(ll (i) = (n)-1 ; (i)>=0 ; --(i))\n#define forab(i,a,b,c) for(ll (i) = a ; (i) <= (b) ; (i)+=(c))\n#define forba(i,b,a,c) for(ll (i) = b ; (i) >= (a) ; (i)+=(c))\n\n// #define pbds tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update>\n\n#ifndef ONLINE_JUDGE\n#define err(x)    cout << #x <<\"=\"; _print(x); cout << cline;\n#else\n#define err(x)\n#endif\n\nstruct myhash\n{\n    static uint64_t fxn(uint64_t x)\n    {\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n \n    size_t operator ()(uint64_t x) const\n    {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return fxn(x + FIXED_RANDOM);\n    }\n};\n\ntemplate <typename T>                                           void read(T &x){cin >> x;}\ntemplate <typename T , typename T0>                             void read(T &x,T0 &y){cin >> x >> y;}\ntemplate <typename T , typename T0 , typename T1>               void read(T &x,T0 &y,T1 &z){cin >> x >> y >> z;}\ntemplate <typename T , typename T0 , typename T1 , typename T2> void read(T &x,T0 &y,T1 &z,T2 &w){cin >> x >> y >> z >> w;}\ntemplate <typename T , typename T0>                             void read(pair< T , T0 > &p){cin >> p.fst >>p.scd;}\ntemplate <typename T>                                           void read(vector< T > &oneD,ll n){forn(i,n){T x;read(x);oneD.push_back(x);}}\ntemplate <typename T>                                           void read(T oneD[] , ll n){for(ll i=0;i<n;i++){read(oneD[i]);}}\ntemplate <typename T>                                           void write(T x){cout << x << \" \";}\ntemplate <typename T>                                           void wrtline(T x){cout << x << cline;}\ntemplate <typename T , typename T0>                             void write(T x,T0 y){cout << x << \" \" << y << \"n\";}\ntemplate <typename T , typename T0 , typename T1>               void write(T x,T0 y,T1 z){cout << x << \" \" << y << \" \" << z << \"n\";}\ntemplate <typename T , typename T0 , typename T1 , typename T2> void write(T x,T0 y,T1 z,T2 w){cout << x << \" \" << y << \" \" << z << \" \" << w << \"n\";}\ntemplate <typename T , typename T0>                             void write(pair< T , T0 > &p){write(p.fst);write(p.scd);cout << cline;}\ntemplate <typename T>                                           void write(vector< T > &oneD,ll n){for(ll i=0;i<n;i++){cout<<oneD[i]<<\" \";}cout << cline;}\ntemplate <typename T>                                           void write(T oneD[] ,ll n){for(ll i=0;i<n;i++){write(oneD[i]);}cout <<cline;}\ntemplate <typename T>                                           void write(vector<vector<T>> &rc,ll n,ll m,ll w){forn(i,n){forn(j,m){cout<<setw(w)<<rc[i][j]<<\" \";}cout<<cline;}}\ntemplate <typename T>                                           void _print(T t) {cout << t;}\ntemplate <class T, class V>                                     void _print(pair <T, V> p);\ntemplate <class T>                                              void _print(vector <T> v);\ntemplate <class T>                                              void _print(set <T> v);\ntemplate <class T, class V>                                     void _print(map <T, V> v);\ntemplate <class T>                                              void _print(multiset <T> v);\ntemplate <class T>                                              void _print(set <T, greater<T>> v);\ntemplate <class T, class V>                                     void _print(map <T, V, greater<T>> v);\ntemplate <class T>                                              void _print(multiset <T, greater<T>> v);\ntemplate <class T, class V>                                     void _print(unordered_set <T, myhash> v);\ntemplate <class T, class V>                                     void _print(unordered_map <T, V, myhash> v);\ntemplate <class T>                                              void _print(stack<T> st);\ntemplate <class T>                                              void _print(queue<T> q);\ntemplate <class T>                                              void _print(deque<T> dq);\ntemplate <class T>                                              void _print(priority_queue<T> pq);\ntemplate <class T>                                              void _print(priority_queue<T,vector<T>,greater<T>> pq);\ntemplate <class T, class V>                                     void _print(pair <T, V> p) {cout << \"{\"; _print(p.fst); cout << \",\"; _print(p.scd); cout << \"}\";}\ntemplate <class T>                                              void _print(vector <T> v) {cout << \"[ \"; for (T i : v) {_print(i); cout << \" \";} cout << \"]\";}\ntemplate <class T>                                              void _print(set <T> v) {cout << \"[ \"; for (T i : v) {_print(i); cout << \" \";} cout << \"]\";}\ntemplate <class T>                                              void _print(set <T, greater<T>> v) {cout << \"[ \"; for (T i : v) {_print(i); cout << \" \";} cout << \"]\";}\ntemplate <class T>                                              void _print(priority_queue <T> pq) {cout << \"[ \"; while(!pq.empty()) {T temp=pq.top(); pq.pop(); _print(temp); cout << \" \";} cout << \"]\";}\ntemplate <class T>                                              void _print(priority_queue <T,vector<T>,greater<T>> pq) {cout << \"[ \"; while(!pq.empty()) {T temp=pq.top(); pq.pop(); _print(temp); cout << \" \";} cout << \"]\";}\ntemplate <class T>                                              void _print(stack <T> st) {cout << \"[ \"; while(!st.empty()) {T temp=st.top(); st.pop(); _print(temp); cout << \" \";} cout << \"]\";}\ntemplate <class T>                                              void _print(queue <T> q) {cout << \"[ \"; while(!q.empty()) {T temp=q.front(); q.pop(); _print(temp); cout << \" \";} cout << \"]\";}\ntemplate <class T>                                              void _print(deque <T> dq) {cout << \"[ \"; while(!dq.empty()) {T temp=dq.front(); dq.pop_front(); _print(temp); cout << \" \";} cout << \"]\";}\ntemplate <class T>                                              void _print(multiset <T> v) {cout << \"[ \"; for (T i : v) {_print(i); cout << \" \";} cout << \"]\";}\ntemplate <class T>                                              void _print(multiset <T, greater<T>> v) {cout << \"[ \"; for (T i : v) {_print(i); cout << \" \";} cout << \"]\";}\ntemplate <class T, class V>                                     void _print(map <T, V> v) {cout << \"[ \"; for (auto i : v) {_print(i); cout << \" \";} cout << \"]\";}\ntemplate <class T, class V>                                     void _print(map <T, V, greater<T>> v) {cout << \"[ \"; for (auto i : v) {_print(i); cout << \" \";} cout << \"]\";}\ntemplate <class T>                                              void _print(unordered_set <T, myhash> v) {cout << \"[ \"; for (auto i : v) {_print(i); cout << \" \";} cout << \"]\";}\ntemplate <class T, class V>                                     void _print(unordered_map <T, V, myhash> v) {cout << \"[ \"; for (auto i : v) {_print(i); cout << \" \";} cout << \"]\";}\n\nll dp[1001][1001];\nclass Solution {\npublic:\n    bool dynamic(ll indx,vll &options,ll sum){\n        if(sum<0){\n            return 0;\n        }\n        if(sum==0){\n            return 1;\n        }\n        if(indx==arrlen(options)){\n            return 0;\n        }\n        if(dp[indx][sum]!=-1){\n            return dp[indx][sum];\n        }\n        return dp[indx][sum]=dynamic(indx+1,options,sum-options[indx])|dynamic(indx+1,options,sum);\n    }\n    int minZeroArray(vector<int>& c, vector<vector<int>>& q) {\n        ll n=arrlen(c),m=arrlen(q);\n        vll ansarr;\n        forn(i,n){\n            ll l=0,r=m,mid,ans=-1;\n            while(l<=r){\n                mid=(l+r)/2;\n                vll options;\n                forn(j,mid){\n                    if(i>=q[j][0] and i<=q[j][1]){\n                        options.pb(q[j][2]);\n                    }\n                }\n                forn(x,1001){\n                    forn(y,1001){\n                        dp[x][y]=-1;\n                    }\n                }\n                bool answer=dynamic(0,options,c[i]);\n                if(answer){\n                    ans=mid;\n                    r=mid-1;\n                }\n                else{\n                    l=mid+1;\n                }\n            }\n            if(ans==-1){\n                return -1;\n            }\n            ansarr.pb(ans);\n        }\n        return *max_element(all(ansarr));\n    }\n};","author":"kelvin_0179","submissionId":"1575214875"},[]]},{"1122":[{"id":"1122","fileName":"1575214820.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, q = len(nums), len(queries)\n        data = (nums.copy(), queries.copy())\n        dp = [1 for _ in range(n)]  \n        masks: List[int] = []\n        for j in range(n): masks.append((1 << (nums[j] + 1)) - 1)\n        all_done = True\n        for j in range(n):\n            if nums[j] != 0:\n                all_done = False\n                break\n        if all_done: return 0\n            \n        for i, (l, r, val) in enumerate(queries):\n            for j in range(l, r + 1):\n                dp[j] = dp[j] | ((dp[j] << val) & masks[j])    \n            all_possible = True\n            for j in range(n):\n                if (dp[j] >> nums[j]) & 1 == 0:\n                    all_possible = False\n                    break\n            if all_possible: return i + 1\n        return -1","author":"Vaibhav Tanwar","submissionId":"1575214820"},[]]},{"1123":[{"id":"1123","fileName":"1575214903.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        boolean isZeroArray = true;\n        for(int i=0;i<n;i++) {\n            if(nums[i]!=0) {\n                isZeroArray = false;\n                break;\n            } \n        }\n        \n        if(isZeroArray) return 0;\n        \n        int max = 0;\n        for(int i=0;i<n;i++) {\n            if(nums[i]==0) continue;\n            Integer dp[][] = new Integer[queries.length][nums[i]+1];\n            int zeroInd = findZeroInd(nums[i], i, 0, queries, 1001, dp);\n            if(zeroInd>=1001) return -1;\n            max = Math.max(max, zeroInd);\n        }\n        \n        return max;\n    }\n    \n    public int findZeroInd(int target, int ind, int curInd, int[][] queries, int lastIndex, Integer dp[][]) {\n        if(target==0) return lastIndex;\n        if(curInd>=queries.length) return 1001;\n        if(dp[curInd][target]!=null) return dp[curInd][target];\n        if(queries[curInd][0]>ind || queries[curInd][1]<ind) return findZeroInd(target,ind,curInd+1,queries,lastIndex,dp);\n        int ans = findZeroInd(target,ind,curInd+1,queries,lastIndex,dp);\n        if(queries[curInd][2]<=target) {\n            ans = Math.min(ans, findZeroInd(target-queries[curInd][2],ind,curInd+1,queries,curInd+1,dp));\n        }\n        return dp[curInd][target] = ans;\n    }\n}","author":"Kasoji Sampath","submissionId":"1575214903"},[]]},{"1124":[{"id":"1124","fileName":"1575214968.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        res=[]\n        import collections\n        from collections import defaultdict\n        \n        for index, n in enumerate(nums):\n            if n==0:\n                continue\n            zero_flag=False\n            s=set()\n            for i,q in enumerate(queries):\n                l,r,val=q\n                if l<=index<=r:\n                    new_s=set([val])\n                    for ele in s:\n                        new_s.add(ele)\n                        new_s.add(ele+val)\n                    \n                    s=new_s\n                    if n in new_s:\n                        zero_flag=True\n                        res.append(i)\n                        #print('n, res ',n,res)\n                        break\n                        \n                    \n            if zero_flag==False:\n                return -1\n        if len(res)>0:\n            return max(res)+1\n        return 0","author":"CSris","submissionId":"1575214968"},[]]},{"1125":[{"id":"1125","fileName":"1575214986.txt","sourceCode":"class Solution {\npublic:\n    bool match1(vector<int> &b,vector<unordered_set<int>> &vm){\n        int n = b.size();\n        for(int i  = 0;i <n;i++){\n            if(b[i] == 0) continue;\n            if(vm[i].find(b[i]) == vm[i].end()){\n                return false;\n            }\n            // if(a[i] < b[i]){\n            //     return false;\n            // }\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        // vector<int> prefix(n,0);\n        int m = queries.size();\n        vector<unordered_set<int>> vm(n);\n        if(match1(nums,vm)) return 0;\n        for(int i = 0;i <m;i++){\n            int l = queries[i][0], r = queries[i][1],val = queries[i][2];\n            for(int j = l; j <= r; j++){\n                unordered_set<int> temp = vm[j];\n                for (int x : temp) {\n                    vm[j].insert(x + val);\n                }\n                vm[j].insert(val);\n            }\n            if(match1(nums,vm)) return i+1;\n        }\n        return -1;\n    }\n};","author":"Anand Jaiswal","submissionId":"1575214986"},[]]},{"1126":[{"id":"1126","fileName":"1575215012.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        bool flag = false;\n        int n = nums.size();\n        for (auto x : nums) {\n            if (x != 0) {\n                flag = true;\n                break;\n            }\n        }\n        function<bool(int)> checker = [&](int mid) -> bool {\n            for (int i = 0; i < n; i++) {\n\n                int key = nums[i];\n                vector<int> dp(key + 1);\n                dp[0] = 1;\n                for (int j = 0; j < mid; j++) {\n                    if (queries[j][0] <= i && i <= queries[j][1]) {\n                        int temp = queries[j][2];\n                        for (int kk = key; kk >= temp; kk--) {\n                            dp[kk] = dp[kk] | dp[kk - temp];\n                        }\n                    }\n                }\n                if (!dp[key]) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        if (flag) {\n            int lo = 1, hi = queries.size(), ans = -1;\n            while (lo <= hi) {\n                int mid = lo + (hi - lo) / 2;\n                if (checker(mid)) {\n                    ans = mid;\n                    hi = mid - 1;\n                } else {\n                    lo = mid + 1;\n                }\n            }\n            return ans;\n        } else {\n            return 0;\n        }\n    }\n};","author":"Soumya Dhakad","submissionId":"1575215012"},[]]},{"1127":[{"id":"1127","fileName":"1575214823.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n=len(nums)\n        dp=[set() for _ in range(n)]\n        for j in range(n):\n            dp[j].add(0)\n            \n        all_z=all(x==0 for x in nums)\n        if all_z:\n            return 0\n        \n        for k in range(len(queries)):\n            l,r,v=queries[k]\n            for j in range(l,r+1):\n                shift=set()\n                \n                for i in range(1001-v):\n                    if i in dp[j]:\n                        shift.add(i+v)\n                        \n                dp[j].update(shift)\n                for pos in range(nums[j]+1,1001):\n                    dp[j].discard(pos)\n                    \n            all_achi=all(nums[j] in dp[j] for j in range(n))\n            if all_achi:\n                return k+1\n        return -1","author":"Rishvanjas Eshwar","submissionId":"1575214823"},[]]},{"1128":[{"id":"1128","fileName":"1575215013.txt","sourceCode":"class Solution {\npublic:\n    int helpr(vector<vector<int>>& q,int index,int target,int& ti,vector<vector<int>>& dp){\n        if(target==0)return index;\n        if(index==q.size() || target<0)return 1e9;\n        if(dp[index][target]!=-1)return dp[index][target];\n        \n        int ans=1e9;\n        if(ti>=q[index][0] && ti<=q[index][1])ans=min(ans,helpr(q,index+1,target-q[index][2],ti,dp));\n        ans=min(ans,helpr(q,index+1,target,ti,dp));\n        return dp[index][target]=ans;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int ans=0;\n        \n        for(int i=0;i<nums.size();i++){\n            vector<vector<int>>dp(q.size(),vector<int>(1001,-1));\n            int temp=helpr(q,0,nums[i],i,dp);\n            ans=max(ans,temp);\n            if(ans==1e9)return -1;\n        }\n        return ans;\n    }\n};","author":"oxidisingojha","submissionId":"1575215013"},[]]},{"1129":[{"id":"1129","fileName":"1575215097.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        k = -1\n        for i, n in enumerate(nums):\n            if n == 0:\n                continue\n            store = [False] * (n + 1)\n            store[n] = True\n            found = False\n            for j, q in enumerate(queries):\n                # print(f\"Processing query {q} for index {i} with value {n}\")\n                if q[0] <= i <= q[1] and q[2] <= n:\n                    val = q[2]\n                    # print(f\"Processing query {q} for index {i} with value {val}\")\n                    if store[val]:\n                        found = True\n                        k = max(k, j)\n                        break\n                    else:\n                        for s in range(val, n + 1):\n                            # print(s)\n                            if store[s]:\n                                store[s - val] = True\n            if not found:\n                return -1\n        return k + 1","author":"Harry Wang","submissionId":"1575215097"},[]]},{"1130":[{"id":"1130","fileName":"1575215027.txt","sourceCode":"class Solution {\npublic:\nbool check(int i,int sum,vector<int> &v,vector<vector<int>> &dp){\n    int n = v.size();\n    if(sum == 0) return 1;\n    if(i >= n) return 0;\n    if(dp[i][sum] != -1) return dp[i][sum];\n    int pick = 0,skip = 0;\n    if(v[i] <= sum) pick = check(i+1,sum-v[i],v,dp);\n    skip = check(i+1,sum,v,dp);\n    return dp[i][sum] = pick | skip;\n}\n\nint sol(int k,vector<int> &a,vector<vector<int>>& q){\n    int n = a.size() , m = q.size();\n    vector<int> p(n+1);\n    for(int i=0;i<=k;i++){\n        int l=q[i][0],r = q[i][1],val = q[i][2];\n        p[l] += val;\n        p[r+1] -= val;\n    }\n    for(int i=1;i<=n;i++) p[i] += p[i-1];\n    for(int i=0;i<n;i++){\n        if(p[i] < a[i]) return 0;\n        if(p[i] > a[i]){\n            vector<int> v;\n            for(int j=0;j<=k;j++){\n                int l=q[j][0],r = q[j][1],val = q[j][2];\n                if(l <= i && r >= i) v.push_back(val);\n            }\n            int sz = v.size();\n            vector<vector<int>> dp(sz+1,vector<int>(a[i]+1,-1));\n            if(!check(0,a[i],v,dp)) return 0;\n        }\n    }\n    return 1;\n}\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size() , m = q.size(), l = 0,r = m-1,ans = 1e9;\n        \n        bool f = 0;\n        for(auto i : a) if(i != 0) f = 1;\n        if(f == 0) return 0;\n        \n        while(l <= r){\n            int mid = (l + r)/2;\n            if(sol(mid,a,q)){\n                ans = mid;\n                r = mid - 1;\n            }\n            else l = mid + 1;\n        }\n        if(ans == 1e9) return -1;\n        return ans+1;\n    }\n};","author":"Gaurav Kumar Jangam","submissionId":"1575215027"},[]]},{"1131":[{"id":"1131","fileName":"1575215088.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n#define siddhantnema ios_base::sync_with_stdio(0); cin.tie(0);\n#define ll long long\n#define forn(_i, N) for (ll _i = 0; _i < N; _i++)\n#define trc(x) cout << #x << \" -> \" << x << 'n';\n#define len(x) (ll)x.size()\n\nbool DP[1005][1005][2][15];\nclass Solution\n{\npublic:\n    void rec(int ele, int pos, vector<vector<int>> &queries, bool taken, set<int> &ans, int idx)\n    {\n        if(ele < 0)\n        {\n            return;\n        }\n        DP[ele][pos][taken][idx] = true;\n        if(ele == 0 and taken)\n        {\n            ans.insert(pos);\n        }\n        if(pos == queries.size()) return;\n        int l = queries[pos][0], r = queries[pos][1], val = queries[pos][2];\n\n        //take\n        if(l <= idx and idx <= r)\n        {\n            if(ele - val >= 0 and not DP[ele - val][pos + 1][true][idx])\n            rec(ele - val, pos + 1, queries, true, ans, idx);\n        }\n        if(not DP[ele][pos + 1][taken][idx])\n            rec(ele, pos + 1, queries, taken, ans, idx);\n\n    }\n    int minZeroArray(vector<int> &nums, vector<vector<int>> &queries)\n    {\n        int N = len(nums);\n        forn(i, 1001)\n            forn(j, queries.size() + 1)\n                forn(k, 2)\n                    forn(x, N)\n                        DP[i][j][k][x] = false;\n                \n        map<int, set<int>> ok;\n        forn(i, N)\n        {\n            set<int> tmp;\n            if(nums[i] == 0)\n            {\n                tmp.insert(0);\n            }\n            rec(nums[i], 0, queries, false, tmp, i);\n            \n            ok[i] = tmp;\n        }\n        // for(auto [k, vec]: ok)\n        // {\n        //     cout << k << \" :\";\n        //     for(int i: vec)\n        //         cout << i << ' ';\n        //     cout << 'n';\n        // }\n        for(int i = 0; i <= queries.size(); i++)\n        {\n            bool uh = true;\n            forn(j, N)\n            {\n                if(ok[j].empty())\n                    return -1;\n                auto iter = lower_bound(ok[j].begin(), ok[j].end(), i);\n                if(iter != ok[j].end())\n                {\n                    uh &= ((*iter == i) or ((*ok[j].begin()) == 0));\n\n                }\n                \n            }\n            if(uh)\n                    return i;\n        }\n        \n        return -1;\n\n\n    }\n};","author":"Siddhant Nema","submissionId":"1575215088"},[]]},{"1133":[{"id":"1133","fileName":"1575215351.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        \n        \"\"\"\n        q = [l, r, val]\n        1. 在 [l, r] 之间 选择任意 x >= val 全部减去 但这样可能也不一定对 因为比如\n\n        [4, 5, 4]\n        q1 [0,2] val = 4 \n        q2 [0,2] val = 5  \n        可能会return -1\n        \n        2. 但是 x < val是肯定不能动的\n        \n        那对于1的情况，可能可以同时查看本来的值？e.g.如果本来等于5\n        也不对。。\n        [4, 5, 4]\n        q1 [0,2] val = 4  【4， 4， 4】\n        q2 [0,2] val = 3  【4， 【4，3】，4】\n        q3 [0,2] val = 2\n        \n        3. 暴力？ n = 10\n        反向间数组？\n        \n        \n        \"\"\"\n        def subset_sum(arr, target):\n            dp = [False] * (target + 1)\n            dp[0] = True\n            for num in arr:\n                for j in range(target, num - 1, -1):  # Traverse backwards\n                    dp[j] |= dp[j - num]  # If sum j-num was possible, sum j is also possible\n\n            return dp[target]\n\n        \n        def helper(idx, sm, k, cur, arr):\n            if sm == k:\n                return True\n\n            if idx == len(arr):\n                return sm == k\n\n            # skip the current element arr[ind] \n            cur_res = helper(idx + 1, sm, k, cur, arr) \n            if cur_res:\n                return True\n            return helper(idx + 1, sm + arr[idx], k, cur + [arr[idx]], arr)\n\n        # possible sum\n        # [4, 4 +3, 3]\n        # [4 + 3 + 2]\n        # [2, 3, 4] -> [2, 5, 8] # 1000\n\n        pos = [SortedList() for i in range(len(nums))]\n        # dp = [[False] * (nums[j] + 1) for j in range(len(nums))]\n        non_zeros = set([i for i in range(len(nums)) if nums[i] != 0])\n        if len(non_zeros) == 0:\n            return 0\n        \n        for i, (l, r, val) in enumerate(queries):\n            for j in range(l, r + 1):\n                if j not in non_zeros: continue\n                if nums[j] < val: continue\n                pos[j].add(val)\n                if subset_sum(pos[j], nums[j]):\n                    non_zeros.remove(j)\n                if len(non_zeros) == 0:\n                    return i + 1\n        return -1\n                # list of pos[j] : sum == nums[j]\n            ","author":"silencea","submissionId":"1575215351"},[]]},{"1134":[{"id":"1134","fileName":"1575215187.txt","sourceCode":"class Solution {\npublic:\n     bool is_sum(vector<int>& arr, int target) {\n        int n = arr.size();\n        vector<vector<bool>>dp(n+1,vector<bool>(target+1,false));\n        for(int i =0;i<=n;i++)\n        {\n            dp[i][0] = true;\n        }\n        \n        for(int i =1;i<=n;i++)\n        {\n            for(int j =1;j<=target;j++)\n            {\n                if(j>=arr[i-1])\n                {\n                    dp[i][j] = dp[i-1][j-arr[i-1]]||dp[i-1][j];\n                }\n                else\n                {\n                    dp[i][j] = dp[i-1][j];\n                }\n            }\n        }\n        return dp[n][target];\n        \n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n        vector<vector<int>> v(n);\n        bool check = true;\n        for(int i =0;i<n;i++)\n            {\n                if(nums[i]!=0)\n                {\n                    check =false;\n                }\n            }\n        if(check)\n        {\n            return 0;\n        }\n\n        for (int i = 0; i < q.size(); i++) {\n            int l = q[i][0];\n            int r = q[i][1];\n            int val = q[i][2];\n            for (int j = l; j <= r; j++) {\n                v[j].push_back(val);\n            }\n            bool f =true;\n            for (int j = 0; j < n; j++) {\n                if(nums[j]==0)\n                {\n                    continue;\n                }\n                else if(v[j].size()==0)\n                {\n                    f = false;\n                    break;\n                }\n                if (is_sum(v[j], nums[j])==false) {\n                    f = false;\n                    break;\n                }\n            }\n            if(f)\n            {\n                return (i+1);\n            }\n        }\n        return -1;\n    }\n};","author":"Dark_Days","submissionId":"1575215187"},[]]},{"1135":[{"id":"1135","fileName":"1575215264.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n#define FAST                 \n    ios::sync_with_stdio(0); \n    cin.tie(0);\n#define cinline(s) getline(cin, s)\n#define ENDL \"n\"\n#define SCANINT(A) scanf(\"%d\", &A)\n#define SCANDOUBLE(A) scanf(\"%lf\", &A)\n#define SCANSTR(A) scanf(\"%s\", A)\n#define SCANCH(A) scanf(\"%c\", A)\n#define SCANLL(A) scanf(\"%lld\", &A)\n#define SCANLD(A) scanf(\"%Lf\", &A)\n#define PRINTINT(A) printf(\"%d\", (A))\n#define PRINTSTR(A) printf(\"%s\", (A))\n#define PRINTLL(A) printf(\"%lld\", (A))\n#define PRINTLD(A) printf(\"%Lf\", (A))\n#define PRINTEND printf(\"n\")\ntypedef long long ll;\ntypedef unsigned long long int ulli;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int, int> pairInt;\n#define MP make_pair;\n#define PB push_back;\n#define b2e(a) a.begin(), \n               a.end()\n#define e2b(a) a.rbegin(), a.rend()\n#define FORI(i, a, b) for (ll i = a; i <= b; i++)\n#define RFORI(i, a, b) for (ll i = a; i >= b; i--)\n#define FORN(i, a, b) for (ll i = a; i < b; i++)\n#define RFORN(i, a, b) for (ll i = a; i > b; i--)\n#define NTIMES(i, n) for (ll i = 1; i <= n; i++)\n\nclass Solution\n{\npublic:\n    int minZeroArray(vector<int> &nums, vector<vector<int>> &queries)\n    {\n        int nSize = nums.size();\n        int qSize = queries.size();\n        pair<vector<int>, vector<vector<int>>> tracker = {nums, queries};\n\n        vector<bitset<1010>> cache(nSize);\n        FORN(i, 0, nSize)\n        {\n            cache[i].reset();\n            cache[i].set(0, true);\n        }\n\n        bool weZeroes = true;\n        FORN(j, 0, nSize)\n        {\n            if (nums[j] != 0)\n            {\n                weZeroes = false;\n                break;\n            }\n        }\n\n        if (weZeroes)\n            return 0;\n        FORN(i, 0, qSize)\n        {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int v = queries[i][2];\n\n            for (int j = l; j <= r; j++)\n            {\n                cache[j] |= (cache[j] << v);\n                FORN(k, nums[j] + 1, 1010)\n                {\n                    cache[j].reset(k);\n                }\n            }\n\n            bool valid = true;\n            FORN(j, 0, nSize)\n            {\n                if (!cache[j].test(nums[j]))\n                {\n                    valid = false;\n                    break;\n                }\n            }\n\n            if (valid)\n                return i + 1;\n        }\n\n        return -1;\n    }\n};","author":"hamzahossain","submissionId":"1575215264"},[]]},{"1136":[{"id":"1136","fileName":"1575215610.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        vector<vector<bool>> dp(n,vector<bool>(1001,false));\n        int cnt=0;\n        for(int i=0;i<n;++i){\n            dp[i][0]=true;\n            if(nums[i]==0) cnt++;\n        }\n        if(cnt==n) return 0;\n        int m=queries.size();\n        for(int i=0;i<m;++i){\n            int l=queries[i][0];\n            int r=queries[i][1];\n            int val=queries[i][2];\n            for(int j=l;j<=r;++j){\n                for(int k=nums[j]-val;k>=0;--k){\n                    if(dp[j][k]) dp[j][k+val]=true;\n                }\n            }\n            int x=0;\n            for(;x<n;++x){\n                if(!dp[x][nums[x]]) break;\n            }\n            if(x==n) return i+1;\n        }\n        return -1;\n    }\n};","author":"hawkvs","submissionId":"1575215610"},[]]},{"1137":[{"id":"1137","fileName":"1575215272.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public boolean allZero(int nums[]) {\n        int all = 1;\n        for (int num : nums) {\n            if (num != 0) {\n                all = 0;\n                break;\n            }\n        }\n        if (all == 1) return true;\n        return false;\n        \n    }\n    public boolean check(int mid, int[] originalNums, int[][] queries) {\n        int n = originalNums.length;\n        int[] nums = new int[n]; \n        for(int i = 0; i < n; i++) {\n            nums[i] = originalNums[i];\n        }\n        List<List<Integer>> dec = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            dec.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i <= mid; i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n\n            for (int j = l; j <= r; j++) {\n                dec.get(j).add(val);\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (!subset_prob(nums[i], dec.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean subset_prob(int target, List<Integer> dec) {\n        if (target == 0) return true;\n        if (dec.isEmpty()) return false;\n\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n\n        for (int val : dec) {\n            for (int j = target; j >= val; j--) {\n                dp[j] |= dp[j - val];\n            }\n        }\n        return dp[target];\n    }\n\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int lo = 0, hi = queries.length - 1;\n        int ans = -1;\n\n        if(allZero(nums)) return 0;\n\n        while (lo <= hi) {\n            int mid = (lo + hi) / 2;\n            if (check(mid, nums, queries)) {\n                ans = mid + 1;\n                hi = mid - 1; \n            } \n            else {\n                lo = mid + 1;\n            }\n        }\n        return ans;\n    }\n}\n","author":"pri_singh","submissionId":"1575215272"},[]]},{"1138":[{"id":"1138","fileName":"1575215456.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        map<int, vector<int>> m;\n        int ans = -1;\n        const int INF = 1000000000;\n        for(auto &q : queries) {\n            for (int j = 0; j < q[0]; j++) m[j].push_back(0);\n            for (int j = q[0]; j <= q[1]; j++) m[j].push_back(q[2]);\n            for (int j = q[1] + 1; j < nums.size(); j++) m[j].push_back(0);\n        }\n        for (int i = 0; i < nums.size(); i++) {\n            vector<int>& v = m[i];\n            int target = nums[i];\n            int L = v.size();\n            int best = INF;\n            if(target == 0) {\n                best = 0;\n            } else {\n                vector<bool> dp(target + 1, false);\n                dp[0] = true;\n                for (int pos = 0; pos < L; pos++) {\n                    vector<bool> ndp = dp;\n                    for (int s = 0; s <= target; s++) {\n                        if(dp[s] && s + v[pos] <= target)\n                            ndp[s + v[pos]] = true;\n                    }\n                    dp = ndp;\n                    if(dp[target]) {\n                        best = pos + 1;\n                        break;\n                    }\n                }\n            }\n            ans = max(ans, best);\n        }\n        return (ans == INF ? -1 : ans);\n    }\n};\n","author":"Ankur karn","submissionId":"1575215456"},[]]},{"1139":[{"id":"1139","fileName":"1575215645.txt","sourceCode":"class Solution {\npublic:\n    bool isPos(vector<int>nums,vector<vector<int>>& que,int k){\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            vector<bool>arr(1001,false);\n            arr[0]=true;\n            for(int j=0;j<=k;j++){\n                if(que[j][0]<=i && i<=que[j][1]){\n                    int val=que[j][2];\n                    for(int s=1000;s>=val;s--){\n                        if(arr[s-val]) arr[s]=true;\n                    }\n                }\n            }\n            if(!arr[nums[i]]) return false;\n        }\n        return true;\n        // vector<int>spl(n+1,0);\n        // for(int i=0;i<=k;i++){\n        //     spl[que[i][0]]-=que[i][2];\n        //     spl[que[i][1]+1]+=que[i][2];\n        // }\n        // long long sum=0;\n        // for(int i=0;i<n;i++){\n        //     sum+=spl[i];\n        //     if(sum+nums[i]>0) return false;\n        // }\n        // return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        int cnt=0;\n        for(int i=0;i<n;i++) if(nums[i]==0) cnt++;\n        if(cnt==n) return 0;\n        int ans=-1;\n        int low=0,high=queries.size()-1;\n        while(low<=high){\n            int mid=(low+high)/2;\n            if(isPos(nums,queries,mid)){\n                ans=mid+1;\n                high=mid-1;\n            }\n            else low=mid+1;\n        }\n        return ans;\n    }\n};","author":"Sahil Singh","submissionId":"1575215645"},[]]},{"1140":[{"id":"1140","fileName":"1575215426.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        \n        bottom = 0\n        top = len(queries) + 1\n        \n        if all([i == 0 for i in nums]):\n            return 0\n        \n        \n        def canz(tarjan, arr):\n            \n            bas = [0 for i in range(11)]\n            basis = set()\n            basis.add(0)\n            for i in arr:\n                nb = set()\n                for bas in basis:\n                    nb.add(bas)\n                    if bas + i <= tarjan:\n                        nb.add(bas + i)\n                basis = nb\n            # print(basis, tarjan, arr, tarjan in basis)\n            return tarjan in basis\n                    \n                    \n                    \n            \n        def can(idx):\n            solarvaunt = [[] for i in nums]\n            for ea in queries[:idx + 1]:\n                for j in range(ea[0], ea[1] + 1):\n                    solarvaunt[j].append(ea[2])\n            if all([canz(nums[j], solarvaunt[j]) for j in range(len(nums))]):\n                return True\n            return False\n        \n        \n        if not can(len(queries) + 1):\n            return -1\n        while bottom < top:\n            middle = (bottom + top) >> 1\n            if can(middle):\n                top = middle\n            else:\n                bottom = middle + 1\n    \n        return bottom + 1\n        \n            \n        \n        \n        ","author":"JJZin","submissionId":"1575215426"},[]]},{"1141":[{"id":"1141","fileName":"1575215469.txt","sourceCode":"class Solution {\npublic:\n    bool solve(int n, int target, vector<int>& nums, vector<vector<int>> &dp)\n    {\n        if(target == 0)\n        {\n            return true;\n        }\n        if(n == 0)\n        {\n            return target == nums[0];\n        }\n        if(dp[n][target] != -1)\n        {\n            return dp[n][target];\n        }\n        bool nottake = solve(n-1, target, nums, dp);\n        bool take = false;\n        if(nums[n] <= target)\n        {\n            take = solve(n-1, target - nums[n], nums,dp);\n        }\n        dp[n][target] = take || nottake;\n        return dp[n][target];\n    }\n    bool check(vector<int>& nums, vector<vector<int>>& queries, int mid)\n    {\n        int n = nums.size();\n        vector<vector<int>> temp(n);\n        for (int i = 0; i < mid; i++)\n        {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for (int i = l; i <= r; i++)\n            {\n                temp[i].push_back(val);\n            }\n        }\n        for(int i = 0; i < n; i++)\n        {\n            if(temp[i].empty())\n            {\n                if(nums[i] != 0)\n                {\n                    return false;\n                }\n                else\n                {\n                    continue;\n                }\n            }\n            vector<vector<int>> dp(temp[i].size(), vector<int> (nums[i] + 1,-1));\n            if(!solve(temp[i].size() - 1, nums[i], temp[i], dp))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l = 0;\n        int h = queries.size();\n        int ans = -1;\n        while(l <= h)\n            {\n                int mid = (l + h)/2;\n                if(check(nums, queries, mid))\n                {\n                    ans = mid;\n                    h = mid - 1;\n                }\n                else\n                {\n                    l = mid + 1;\n                }\n            }\n        return ans;\n    }\n};","author":"Mihir Pandit","submissionId":"1575215469"},[]]},{"1142":[{"id":"1142","fileName":"1575215757.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        largest = max(nums)\n        if all(num == 0 for num in nums):\n            return 0\n                \n        dp = [[False] * (largest + 1) for _ in range(n)]\n        for i in range(n):\n            dp[i][0] = True\n\n        for query_index in range(len(queries)):\n            l, r, val = queries[query_index]\n\n            for i in range(l, r + 1):\n                for sub in range(largest, val - 1, -1):\n                    if dp[i][sub - val]:\n                        dp[i][sub] = True\n\n            success = True\n            for j in range(n):\n                if not dp[j][nums[j]]:\n                    success = False\n                    break\n\n            if success:\n                return query_index + 1\n\n        return -1\n        ","author":"Lrdinsu","submissionId":"1575215757"},[]]},{"1143":[{"id":"1143","fileName":"1575215755.txt","sourceCode":"class Solution {\npublic:\n\n    bool rec(int idx, int sum, vector<int>& v, vector<vector<int>>& dp){\n        int n = v.size();\n        if(sum == 0)\n            return 1;\n        if(idx == n || sum < 0)\n            return 0;\n        if(dp[idx][sum] != -1)\n            return dp[idx][sum];\n        else\n            return dp[idx][sum] = rec(idx+1,sum-v[idx],v,dp)|rec(idx+1,sum,v,dp);\n    }\n    bool check(int q, vector<int>& nums, vector<vector<int>>& queries){\n        int n = nums.size();\n        vector<vector<int>> u(n);\n        for(int i = 0; i < q; i++){\n            for(int j = queries[i][0]; j <= queries[i][1]; j++)\n            u[j].push_back(queries[i][2]);\n        }\n        vector<vector<int>> dp;\n        for(int i = 0; i < n; i++){\n            dp.resize(u[i].size(), vector<int> (nums[i]+1,-1));\n            if(!rec(0, nums[i], u[i], dp))\n            return 0;\n            dp.clear();\n        }\n        return 1;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size();\n        int start = 0, end = q, ans = -1;\n        while(start <= end){\n            int mid = end-(end-start)/2;\n            if(check(mid, nums, queries)){\n                ans = mid;\n                end = mid-1;\n            }\n            else\n            start = mid+1;\n        }\n        return ans;\n    }\n};","author":"Raj kharkwal","submissionId":"1575215755"},[]]},{"1144":[{"id":"1144","fileName":"1575215578.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size();\n        \n        int l = 0, r = q + 1; \n        while(l < r) {\n            int mid = l + (r - l) / 2;\n            if(check(nums, queries, mid)) r = mid;\n            else l = mid + 1;\n        }\n        return (l > q ? -1 : l);\n    }\nprivate:\n    bool check(const vector<int>& nums, const vector<vector<int>>& qs, int k) {\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            if (target == 0)\n                continue;\n            vector<int> coins;\n            for (int j = 0; j < k; j++) {\n                int l = qs[j][0], r = qs[j][1], v = qs[j][2];\n                if (i >= l && i <= r)\n                    coins.push_back(v);\n            }\n            \n            bitset<1001> dp;\n            dp.reset();\n            dp[0] = 1;\n            for (int c : coins) {\n                dp |= (dp << c);\n            }\n            if (!dp[target]) return false;\n        }\n        return true;\n    }\n};\n","author":"Devu Gupta","submissionId":"1575215578"},[]]},{"1145":[{"id":"1145","fileName":"1575215778.txt","sourceCode":"class Solution {\nprivate:\n    int solveForMinQueries(int ind, int n, vector<vector<int>>& queries, int val, int index, vector<vector<int>>& dp){\n        if(ind == n){\n            if(val == 0){\n                return n - 1;\n            }\n            return INT_MAX;\n        }\n        if(val == 0){\n            return max(ind - 1, 0);\n        }\n        if(dp[ind][val] != -1){\n            return dp[ind][val];\n        }\n        int mini = INT_MAX;\n        mini = min(mini, solveForMinQueries(ind + 1, n, queries, val, index, dp));\n        if(index >= queries[ind][0] && index <= queries[ind][1] && (val - queries[ind][2]) >= 0){\n            mini = min(mini, solveForMinQueries(ind + 1, n, queries, val - queries[ind][2], index, dp));\n        }\n        return dp[ind][val] = mini;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int i,j,k;\n        bool flag = true;\n        for(i=0;i<nums.size();i++){\n            if(nums[i] != 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            return 0;\n        }\n        vector<vector<int>> dp(queries.size(), vector<int> (1001, -1));\n        int maxi = 0;\n        for(i=0;i<nums.size();i++){\n            maxi = max(maxi, solveForMinQueries(0, queries.size(), queries, nums[i], i, dp));\n            for(j=0;j<queries.size();j++){\n                for(k=0;k<1001;k++){\n                    dp[j][k] = -1;\n                }\n            }    \n        }\n        if(maxi == INT_MAX){\n            return -1;\n        }\n        return maxi + 1;\n    }\n};","author":"Daksh Govani","submissionId":"1575215778"},[]]},{"1146":[{"id":"1146","fileName":"1575215867.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int rst = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != 0) {\n                int[][] memo = new int[nums[i] + 1][queries.length];\n                int v = helper(nums[i], i, queries, 0, memo);\n                if (v == -1) {\n                    return -1;\n                }\n                rst = Math.max(rst, v + 1);\n            }\n        }\n\n        return rst;\n    }\n    private int helper(int val, int id1, int[][] queries, int index, int[][] memo) {\n        if (index >= queries.length && val != 0) {\n            return -1;\n        }\n        if (id1 < queries[index][0] || id1 > queries[index][1]) {\n            return helper(val, id1, queries, index + 1, memo);\n        }\n        \n        if (val < queries[index][2]) {\n            return helper(val, id1, queries, index + 1, memo);\n        }\n        if (val == queries[index][2]) {\n            return index;\n        }\n        if (memo[val][index] != 0) {\n            return memo[val][index];\n        }\n        \n        int first = helper(val, id1, queries, index + 1, memo);\n        if (first == -1) {\n            int a = helper(val - queries[index][2], id1, queries, index + 1, memo);\n            memo[val][index] = a;\n            return a;\n        }\n        \n        int second = helper(val - queries[index][2], id1, queries, index + 1, memo);\n        if (second == -1) {\n            memo[val][index] = first;\n            return first;\n        }\n\n         int a = Math.min(first, second);\n        memo[val][index] = a;\n        return a;\n        \n    }\n}","author":"HuangJM926","submissionId":"1575215867"},[]]},{"1147":[{"id":"1147","fileName":"1575215769.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n\n        auto subset_sum = vector<vector<bool>>(n, vector<bool>(1001, false));\n        auto subset_sum_prev = vector<vector<bool>>(n, vector<bool>(1001, false));\n        for (auto i = 0; i < n; ++i) {\n            subset_sum[i][0] = true;\n            subset_sum_prev[i][0] = true;\n        }\n\n        auto cnt = 0;\n\n        auto complete = true;\n        for (auto i = 0; i < n; ++i) {\n            if (!subset_sum[i][nums[i]]) {\n                complete = false;\n                break;\n            }\n        }\n        if (complete) return cnt;\n        \n        for (auto& q: queries) {\n            ++cnt;\n\n            for (auto j = q[0]; j <= q[1]; ++j) {\n                for (auto k = 0; k + q[2] <= 1000; ++k) {\n                    subset_sum[j][k+q[2]] = \n                        subset_sum[j][k+q[2]] || subset_sum_prev[j][k];\n                }\n                for (auto k = 0; k <= 1000; ++k) {\n                    subset_sum_prev[j][k] = subset_sum[j][k];\n                }\n            }\n            auto complete = true;\n            for (auto i = 0; i < n; ++i) {\n                if (!subset_sum[i][nums[i]]) {\n                    complete = false;\n                    break;\n                }\n            }\n            if (complete) return cnt;\n        }\n\n        return -1;\n    }\n};","author":"user4121G","submissionId":"1575215769"},[]]},{"1148":[{"id":"1148","fileName":"1575215847.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        ans=-1\n        not_pos=False\n        for i in range(len(nums)):\n            arr=[]\n            indices=[]\n            num=nums[i]\n            for j in range(len(queries)):\n                l, r, v = queries[j]\n                if i>=l and i<=r:\n                    arr.append(v)\n                    indices.append(j)\n            k=self.isSubsetSum(arr,num)\n            if k!=-1:\n                if k==0:\n                    ans=max(ans,0)\n                else:\n                    x=indices[k-1]\n                    ans=max(ans,x+1)\n            else:\n                not_pos=True\n        if not_pos:\n            return -1\n        return ans    \n\n    def isSubsetSum(self,arr, sum):\n        n = len(arr)\n    \n        dp = [[False] * (sum + 1) for _ in range(n + 1)]\n\n        for i in range(n + 1):\n            dp[i][0] = True\n    \n        for i in range(1, n + 1):\n            for j in range(1, sum + 1):\n                if j < arr[i - 1]:  \n                    dp[i][j] = dp[i - 1][j]\n                else:                    \n                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n    \n        \n        for i in range(n+1):\n            if dp[i][sum]:\n                return i\n        return -1        ","author":"spiraling_up","submissionId":"1575215847"},[]]},{"1149":[{"id":"1149","fileName":"1575215958.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        num_queries = defaultdict(list)\n\n        for k, (l, r, v) in enumerate(queries, 1):\n            for i in range(l, r+1):\n                num_queries[i].append((k, v))\n\n        # print(num_queries)\n\n        needed = 0\n        for i, n in enumerate(nums):\n            if not n:\n                continue\n\n            required = {n}\n            for k, v in num_queries[i]:\n                if v in required:\n                    needed = max(needed, k)\n                    break\n\n                for x in tuple(required):\n                    if v > x:\n                        continue\n\n                    required.add(x - v)\n            else:\n                # print(\"couldn't find\", i, f\"({n})\")\n                return -1\n\n        return needed\n","author":"cefqrn","submissionId":"1575215958"},[]]},{"1151":[{"id":"1151","fileName":"1575215966.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        qi = pre = 0\n        q_size = len(queries)\n        size = len(nums)\n\n        def check(counter, target):\n            \n            # print(['check', counter, target])\n            if target == 0:\n                # print('target is 0')\n                return True\n\n            total = 0\n            for v, freq in counter.items():\n                total += v * freq\n            if total < target:\n                # print('total < target', [total, target])\n                return False\n            \n            dp = set([0])\n            for v, freq in counter.items():\n                new_dp = dp\n                for f in range(1, freq + 1):\n                    new_dp = new_dp | set(x + f * v for x in dp)\n                    # print(new_dp)\n                    if target in new_dp:\n                        return True\n                dp = new_dp\n            return False\n            \n        \n        pre = Counter()\n        diff_add = [Counter() for _ in range(size + 1)]\n        diff_rmv = [Counter() for _ in range(size + 1)]\n      \n        for i, n in enumerate(nums):\n            pre = pre + diff_add[i] - diff_rmv[i]\n\n            res = False\n            while qi < q_size + 1:\n                res = check(pre, n)\n                if res or qi == q_size:\n                    break\n                    \n                q1, q2, val = queries[qi]\n                if i < q1:\n                    diff_add[q1][val] += 1\n                    diff_rmv[q2 + 1][val] += 1\n                elif q1 <= i <= q2:\n                    pre[val] += 1 \n                    diff_rmv[q2 + 1][val] += 1\n                qi += 1\n                # print(['update', pre, qi])\n\n            if not res:\n                return -1\n\n            # if pre < n or pre > n:\n            #     return -1\n\n        return qi","author":"Wombat","submissionId":"1575215966"},[]]},{"1152":[{"id":"1152","fileName":"1575215970.txt","sourceCode":"class Solution {\npublic:\n    int solve(vector<pair<int,int>>& arr,int val,int n,vector<vector<int>>& dp){\n        if(n==arr.size()){\n            return INT_MAX;\n        }\n        if(arr[n].first==val){\n            return arr[n].second;\n        }\n        if(dp[n][val]!=-1){\n            return dp[n][val];\n        }\n        int ans=INT_MAX;\n        ans=solve(arr,val,n+1,dp);\n        if(arr[n].first<=val){\n            int value=solve(arr,val-arr[n].first,n+1,dp);\n            ans=min(ans,value);\n        }\n        // int m=arr.size();\n        // vector<vector<int>> dp(m+1,vector<int>(val+1,INT_MAX));\n        // if(arr[1].first<=val)dp[1][arr[1].first]=arr[1].second;\n        // for(int i)\n        return dp[n][val]=ans;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        vector<vector<pair<int,int>>> arr(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<queries.size();j++){\n                int l=queries[j][0];\n                int r=queries[j][1];\n                if(i>=l && i<=r){\n                    arr[i].push_back({queries[j][2],j});\n                }\n            }\n        }\n        int mx=-1;\n        for(int i=0;i<n;i++){\n            if(nums[i]==0)continue;\n            int k=arr[i].size();\n            vector<vector<int>> dp(k+1,vector<int>(nums[i]+1,-1));\n            int v=solve(arr[i],nums[i],0,dp);\n            if(v==INT_MAX)return -1;\n            mx=max(mx,v);\n           \n        }\n        return mx+1;\n       \n    }\n};","author":"dilpreet singh","submissionId":"1575215970"},[]]},{"1153":[{"id":"1153","fileName":"1575216528.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        \n        auto valid = [&](int m) -> bool {\n            vector<vector<int>> values(n + 1);\n            for (int i = 0; i < m; i++) {\n                vector<int>& q = queries[i];\n                \n                for (int j = q[0]; j <= q[1]; j++)\n                    values[j].push_back(q[2]);\n            }\n            \n            for (int i = 0; i < n; i++) {\n                if (nums[i] == 0)\n                    continue;\n\n                vector<int>& options = values[i];\n                vector<bool> dp (nums[i] + 1, false);\n                dp[0] = true;\n\n                for (int option : options) \n                    for (int x = nums[i]; x >= option; x--)\n                        if (dp[x - option])\n                            dp[x] = true;\n\n                if (!dp[nums[i]])\n                    return false;\n            }\n            \n            return true;\n        };\n        \n        int l = 0; \n        int r = m;\n        int best = -1;\n        \n        while (l <= r) { \n            int m = (l + r) / 2;\n\n            if (valid(m)) {\n                r = m - 1;\n                best = m;\n            } else \n                 l = m + 1;\n        }\n\n        return best; \n    }\n};","author":"boredfunn","submissionId":"1575216528"},[]]},{"1154":[{"id":"1154","fileName":"1575216639.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& qu) {\n        int l,r,mid,i,n=nums.size(),q=qu.size();\n        vector<vector<int>> dp(n,vector<int>(1001,q+1));\n        for(i=0;i<n;i++){\n            dp[i][0]=0;\n        }\n        for(i=0;i<q;i++){\n            int a = qu[i][0];\n            int b = qu[i][1];\n            int val = qu[i][2];\n            for(l = a;l<=b;l++){\n                for(mid = 1000-val;mid>=0;mid--){\n                    if(dp[l][mid]<(q+1)){\n                        dp[l][mid+val] = min(dp[l][mid+val], i+1);\n                    }\n                }\n            }\n        }\n        int ans = -1;\n        for(i=0;i<n;i++){\n            ans = max(ans, dp[i][nums[i]]);\n        }\n        if(ans>q) return -1;\n        return ans;\n    }\n};","author":"Vineet Gupta","submissionId":"1575216639"},[]]},{"1155":[{"id":"1155","fileName":"1575216084.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        matrix = [[] for _ in range(len(nums))]\n        for j, [l, r, v] in enumerate(queries):\n            for i in range(l, r + 1):\n                matrix[i].append((v, j + 1))\n        def backtrack(nums, index, cur_sum, target):\n            if cur_sum == target:\n                return nums[index - 1][1]\n            if index == len(nums):\n                return inf\n            res = min(backtrack(nums, index + 1, cur_sum, target), backtrack(nums, index + 1, cur_sum + nums[index][0], target))\n            return res\n        # print(matrix)\n        res = -1\n        for i, array in enumerate(matrix):\n            target = nums[i]\n            if target == 0:\n                res = max(res, 0)\n                continue\n            @cache\n            def recur(index, cur_sum):\n                if cur_sum == target:\n                    return array[index - 1][1]\n                if index == len(array):\n                    return inf\n                return min(recur(index + 1, cur_sum + array[index][0]), recur(index + 1, cur_sum))\n            tmp = recur(0, 0)\n            # print(array, tmp)\n            if tmp == inf:\n                return -1\n            res = max(res, tmp)\n        return res\n\n        ","author":"Oh a clown","submissionId":"1575216084"},[]]},{"1156":[{"id":"1156","fileName":"1575216588.txt","sourceCode":"class Solution {\npublic:\n    const int INF = 1e6;\n    int dp[1001][1001];\n    int solve(int i, int target, vector<vector<int>> &arr) {\n        int n = arr.size();\n        if(target < 0) return INF;\n        if(i >= n) return target == 0 ? 0 : INF;\n        if(dp[i][target] != -1) return dp[i][target];\n        return dp[i][target] = min(solve(i+1,target,arr),max(arr[i][1],solve(i+1,target-arr[i][0],arr)));\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<vector<vector<int>>> list(n);\n        for(int i = 0; i < m; i++) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for(int j = l; j <= r; j++)\n                list[j].push_back({val,i});\n        }\n        int ans = 0;\n        for(int i = 0; i < n; i++) {\n            memset(dp,-1,sizeof(dp));\n            if(nums[i] == 0) continue;\n            ans = max(ans,1+solve(0,nums[i],list[i]));\n        }\n        return ans >= INF ? -1 : ans;\n    }\n};","author":"Manas Kumar","submissionId":"1575216588"},[]]},{"1157":[{"id":"1157","fileName":"1575216748.txt","sourceCode":"class Solution {\npublic:\n    int dp[1005][1005];\n\n    int poss(int sum, vector<vector<int>>& queries, int n, int ind,int ind1) {\n        if (sum < 0) return 0;\n        if (sum == 0) return 1;\n        if (ind >= n) return 0; \n        if (dp[ind][sum] != -1) return dp[ind][sum];\n        int ans = 0;\n        if(ind1>=queries[ind][0] && ind1 <= queries[ind][1])\n        ans = (poss(sum - queries[ind][2], queries, n, ind + 1,ind1));\n        ans= (ans|poss(sum, queries, n, ind + 1,ind1));\n        return dp[ind][sum] = ans;\n    }\n\n    bool possible(int n, vector<vector<int>>& queries, vector<int>& nums) {\n        for (int i = 0; i < nums.size(); i++) { \n            memset(dp, -1, sizeof(dp)); \n            if (!poss(nums[i], queries, n, 0,i)) return false;\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int start = 0, end = queries.size(), mid;\n        \n        while (start < end) { \n            mid = (start + end) / 2;\n            if (possible(mid, queries, nums)) {\n                end = mid;\n            } else {\n                start = mid + 1;\n            }\n        }\n        \n        return (possible(start, queries, nums)) ? start : -1;\n    }\n};\n","author":"sharit vaishnav","submissionId":"1575216748"},[]]},{"1158":[{"id":"1158","fileName":"1575216596.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        memo = {}\n        def canAdd(i: int, num: int, change: List[int], counts: Dict[int, int]) -> bool:\n            # print(i, num, change, counts, memo)\n            if num == 0:\n                return True\n            elif num < 0 or i == len(change) or change[i] > num:\n                return False\n            key = (i, num)\n            if key in memo:\n                return memo[key]\n\n            for take in range(counts[change[i]], -1, -1):\n                memo[key] = canAdd(i + 1, num - (change[i] * take), change, counts)\n                if memo[key]:\n                    return True\n            return False\n        \n        def valid(k: int) -> bool:\n            add = [[] for _ in range(len(nums))]\n            sub = [[] for _ in range(len(nums))]\n            for i in range(k):\n                query = queries[i]\n                add[query[0]].append(query[2])\n                if query[1] < len(nums) - 1:\n                    sub[query[1] + 1].append(query[2])\n\n            # print('aaa', k, add, sub)\n            changes = {}\n            for i in range(len(nums)):\n                for j in add[i]:\n                    changes[j] = changes.get(j, 0) + 1\n                for j in sub[i]:\n                    changes[j] -= 1\n                    if changes[j] == 0:\n                        changes.pop(j)\n\n                nonlocal memo\n                memo = {}\n                if not canAdd(0, nums[i], sorted(changes.keys()), changes):\n                    return False\n            # print(memo)\n            return True\n\n        if not valid(len(queries)):\n            return -1\n        \n        left = 0\n        right = len(queries)\n        while left < right:\n            # memo = {}\n            mid = (left + right) // 2\n            if valid(mid):\n                right = mid\n            else:\n                left = mid + 1\n\n        return left\n\n\n        # 0\n        # 2\n        # 6\n        # 8\n        ","author":"messyhair","submissionId":"1575216596"},[]]},{"1159":[{"id":"1159","fileName":"1575216835.txt","sourceCode":"class Solution {\npublic:\n//     bool chk2(int i,vector<int>& nums, map<int,vector<int>>& mp,int curr,int j){\n//         if(curr==nums[i])return 1;\n//         if(j>=mp[i].size())return 0;\n//         bool take=0;\n//         if(mp[i][j]+curr<=nums[i]){\n//             take=chk2(i,nums,mp,curr+mp[i][j],j+1);\n//         }\n//         bool not_take=chk2(i,nums,mp,curr,j+1);\n//         return (take|not_take);\n        \n//     }\n    \n    bool chk2(int i, vector<int>& nums, map<int,vector<int>>& mp, int curr, int j, vector<vector<int>>& memo) {\n        if (curr == nums[i]) return true;\n        if (j >= mp[i].size()) return false;\n\n        if (memo[curr][j] != -1) return memo[curr][j];\n\n        bool take = false;\n        if (curr + mp[i][j] <= nums[i]) {\n            take = chk2(i, nums, mp, curr + mp[i][j], j + 1, memo);\n        }\n        bool not_take = chk2(i, nums, mp, curr, j + 1, memo);\n\n        return memo[curr][j] = (take || not_take);\n    }\n    bool chk(vector<int>& nums, map<int,vector<int>>& mp){\n        for(int i=0;i<nums.size();i++){\n            vector<vector<int>> memo(1001, vector<int>(mp[i].size(), -1));\n            if(!chk2(i,nums,mp,0,0,memo)){\n                return 0;\n            }\n        }\n        return 1;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        if (all_of(nums.begin(), nums.end(), [](int x) { return x == 0; })) {\n    return 0;\n}\n        int ans=-1;\n        int l=0,h=queries.size()-1;\n        while(l<=h){\n            int m=l+((h-l)/2);\n            map<int,vector<int>>mp;\n            for(int j=0;j<=m;j++){\n                for(int i=queries[j][0];i<=queries[j][1];i++){\n                    mp[i].push_back(queries[j][2]);\n                }\n            }\n            \n            if(chk(nums,mp)){\n                ans=m+1;h=m-1;\n            }\n            else l=m+1;\n        }\n        return ans;\n    }\n};","author":"Bhavya Mehta","submissionId":"1575216835"},[]]},{"1160":[{"id":"1160","fileName":"1575216777.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<bool>> dp(n, vector<bool>(1010, false));\n        bool flag = true;\n        for (int i = 0; i < n; ++i)\n        {\n            /* code */dp[i][0] = true;\n            if (nums[i] != 0)flag = false;\n        }\n        if (flag) return 0;\n        for (int i = 0; i < queries.size(); ++i)\n        {\n            /* code */for (int j = queries[i][0]; j <= queries[i][1]; ++j)\n            {\n                /* code */for (int k = nums[j]; k >= queries[i][2]; --k)\n                {\n                    /* code */if (!dp[j][k] && dp[j][k - queries[i][2]]) {\n                        dp[j][k] = true;\n                    }\n                }\n            }\n            bool flag = true;\n            for (int i = 0; i < n; ++i)\n            {\n                /* code */if (dp[i][nums[i]]) {\n\n                    continue;\n                }\n                flag = false;\n            }\n            if (flag)return i + 1;\n        }\n        return -1;\n    }\n};\n","author":"tejkumar_40","submissionId":"1575216777"},[]]},{"1161":[{"id":"1161","fileName":"1575216872.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n\n        auto ok = [&](int m) {\n            vector<vector<int>> a(n, vector<int> (11, 0)), dp(11, vector<int> (1005, -1));\n\n            for(int id = 0; id <= m; id++) {\n                int l = queries[id][0], r = queries[id][1], val = queries[id][2];\n                for(int i = l; i <= r; i++) a[i][val]++;\n            }\n\n            auto f = [&](int i, int tar, int id, auto && f) -> int {\n                if(tar == 0) return 1;\n                if(i == 11) return 0;\n\n                if(dp[i][tar] != -1) return dp[i][tar];\n\n                int ans = 0;\n                for(int j = 0; j <= a[id][i]; j++) {\n                    int s = j * i;\n                    if(tar - s >= 0) ans = max(ans, f(i + 1, tar - s, id, f));\n                    else break;\n                }\n\n                return dp[i][tar] = ans;\n            };\n\n            for(int i = 0; i < n; i++) {\n                dp.assign(11, vector (1005, -1));\n                if(!f(0, nums[i], i, f)) return 0;\n            }\n\n            return 1;\n        };\n        \n        if(*max_element(nums.begin(), nums.end()) == 0) return 0;\n\n        int l = 0, r = queries.size() - 1, ans = -1;\n        while(l <= r) {\n            int m = (l + r) / 2;\n            if(ok(m)) ans = m + 1, r = m - 1;\n            else l = m + 1;\n        }\n        return ans;\n    }\n};","author":"Akash0P","submissionId":"1575216872"},[]]},{"1162":[{"id":"1162","fileName":"1575216800.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        int q=queries.size();\n        vector<vector<int>> dp(n, vector<int>(1001, 0));\n         for (int j = 0; j < n; j++) {\n            dp[j][0] = 1;\n        }\n        int f=0;\n        for(int i=0;i<n;i++){\n            if(nums[i]>0){\n                f=1;break;\n            }\n            \n            \n        }\n        if(f==0)return 0;\n        else{\n            for(int i=0;i<q;i++){\n                int l=queries[i][0];\n                int r=queries[i][1];\n                int val=queries[i][2];\n                for(int j=l;j<r+1;j++){\n                     for (int s = 1000 - val; s >= 0; s--) {  \n                    if (dp[j][s]) {\n                        dp[j][s + val] = 1;  \n                    }\n                }\n                    \n                    \n                    \n                    \n                }\n                int p=0;\n                  for (int j = 0; j < n; j++) {\n                if (dp[j][nums[j]]==false) {\n                    p = 1;\n                    break;\n                }\n            }\n            if (p==0) return i + 1;\n                \n                \n                \n                \n                \n                \n            }\n            \n            return -1;\n            \n            \n            \n        }\n        \n        \n        \n        \n    }\n};","author":"AbhishekMondal23","submissionId":"1575216800"},[]]},{"1163":[{"id":"1163","fileName":"1575216970.txt","sourceCode":"class Solution {\n    int dfs(int v, vector<pair<int, int>>& val, int i, vector<vector<int>>& dp)\n    {\n        if (i == size(val))\n            return 1e9;\n\n        if (dp[v][i] != -1)\n            return dp[v][i];\n\n        auto [vv, ii] = val[i];\n\n        if (v == vv)\n            return ii + 1;\n\n        int dont = dfs(v, val, i + 1, dp);\n        int take = v > vv ? dfs(v - vv, val, i + 1, dp) : 1e9;\n\n        return dp[v][i] = min(dont, take);\n    }\n\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = size(nums);\n        int m = size(queries);\n\n        vector<vector<pair<int, int>>> val(n);\n\n        for (int i = 0; i < m; ++i)\n        {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int v = queries[i][2];\n\n            for (int j = l; j <= r; ++j)\n                val[j].push_back({v, i});\n        }\n\n        #if 0\n        for (int i = 0; i < n; ++i)\n        {\n            cout << nums[i] << \": \";\n\n            for (auto [vv, ii] : val[i])\n                cout << vv << \",\" << ii << \" \";\n\n            cout << \"n\";\n        }\n        #endif\n\n        int ans = 0;\n\n        for (int i = 0; i < n; ++i)\n        {\n            if (nums[i] == 0)\n                continue;\n\n            vector<vector<int>> dp(nums[i] + 1, vector<int>(size(val[i]), -1));\n            \n            int r = dfs(nums[i], val[i], 0, dp);\n\n            //cout << nums[i] << \" \" << r << \"n\";\n            \n            ans = max(ans, r);\n        }\n\n        return ans == 1e9 ? -1 : ans;\n    }\n};","author":"ttn","submissionId":"1575216970"},[]]},{"1164":[{"id":"1164","fileName":"1575217112.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        d = [set([0]) for _ in range(n)]\n        if all(x == 0 for x in nums):\n            return 0\n        for i, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                s = set()\n                for x in d[j]:\n                    s.add(x + v)\n                d[j].update(s)\n                f = set()\n                for x in d[j]:\n                    if x <= 1000:\n                        f.add(x)\n                d[j] = f\n            if all(nums[j] in d[j] for j in range(n)):\n                return i + 1\n\n        return -1","author":"Lavanya Immaneni","submissionId":"1575217112"},[]]},{"1167":[{"id":"1167","fileName":"1575217076.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number}\n */\nvar minZeroArray = function(nums, queries) {\n  let n = nums.length, q = queries.length;\n  const vals = Array.from({length: n}, () => []);\n\n  let flag = false;\n  for (let j = 0; j < n; j++) {\n    if (nums[j] !== 0) {\n      flag = true;\n      break;\n    }\n  }\n  if (!flag)\n    return 0;\n  for (let i = 0; i < q; i++) {\n    for (let k = queries[i][0]; k <= queries[i][1]; k++) {\n      vals[k].push([queries[i][2], i]);\n    }\n  }\n\n  function solve(idx) {\n    let target = nums[idx];\n    const mem = Array.from({length: vals[idx].length + 1}, () => new Array(vals[idx].length + 1));\n    function rec(i = 0, cur = 0, lastUsed = -1) {\n      // console.log(cur)\n      if (cur > target)\n        return Infinity;\n      if (cur === target)\n        return lastUsed;\n      if (i >= vals[idx].length)\n        return Infinity;\n      if (mem[i][cur] !== undefined)\n        return mem[i][cur];\n\n      let res1 = rec(i + 1, cur + vals[idx][i][0], vals[idx][i][1]);\n      let res2 = rec(i + 1, cur, lastUsed);\n      return mem[i][cur] = Math.min(res1, res2);\n    }\n    // console.log(target, vals[idx], rec() + 1);\n    return rec() + 1;\n  }\n\n  let res = 0;\n  for (let i = 0; i < n; i++) {\n    res = Math.max(res, solve(i));\n    if (!Number.isFinite(res))\n      return -1;\n  }\n  return res;\n};","author":"Kanat","submissionId":"1575217076"},[]]},{"1169":[{"id":"1169","fileName":"1575217233.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& que) {\n        int l = nums.size();\n        int n = que.size();\n        int nflg = 0;\n        for(int i  = 0 ; i < l; i++){\n            if(nums[i] != 0){\n                nflg = 1;\n            }\n        }\n        if(nflg == 0) return 0;\n        int ans = -1;\n        for (int i = 0; i < l; i++) {\n            int wt = nums[i];\n            if(wt == 0) continue;\n            vector<int> ind;\n            vector<int> temp;\n            for (int j = 0; j < n; j++) {\n                if (que[j][0] <= i && que[j][1] >= i) {\n                    temp.push_back(que[j][2]);\n                    ind.push_back(j);\n                }\n            }\n            if(temp.size() == 0) return -1;\n            // for(auto j : ind) cout << j << \" \";\n            // cout << \"n\";\n            vector<vector<int>> dp(temp.size(), vector<int>(1001, 0));\n            dp[0][temp[0]] = 1;\n            dp[0][0] = 1;\n            if (dp[0][wt]) {\n                ans = max(ans, ind[0]+ 1);\n                continue;\n            }\n            int flg = 0;\n            for (int j = 1; j < temp.size(); j++) {\n                for (int k = 0; k <= 1000; k++) {\n                    dp[j][k] |= dp[j - 1][k];\n                    if (k - temp[j] >= 0)\n                        dp[j][k] |= dp[j - 1][k - temp[j]];\n                }\n                if (dp[j][wt]) {\n                    ans = max(ans, ind[j] + 1);\n                    flg = 1;\n                }\n                if (flg)\n                    break;\n            }\n\n            // for (int j = 0; j < temp.size(); j++) {\n            //     for (int k = 0; k <= 6; k++) {\n            //             cout << dp[j][k] << \" \";\n            //     }\n            //     cout << \"n\";\n            // }\n            // cout << \"n\";\n\n            if(flg == 0){\n                return -1;\n            }\n        }\n\n        return ans;\n    }\n};","author":"marmick Mathur","submissionId":"1575217233"},[]]},{"1170":[{"id":"1170","fileName":"1575217357.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<bitset<1001>> dp(n);\n\n        bool allZero = true;\n        for (int j = 0; j < n; j++) {\n            dp[j].set(0);\n            if (nums[j] != 0) allZero = false;\n        }\n\n        if (allZero) return 0;\n\n        for (int k = 0; k < queries.size(); k++) {\n            int l = queries[k][0], r = queries[k][1], v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n                dp[j] |= (dp[j] << v);\n                dp[j] &= bitset<1001>().set() >> (1001 - nums[j] - 1);\n            }\n\n            bool allAchieved = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j][nums[j]]) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n\n            if (allAchieved) return k + 1;\n        }\n        return -1;\n    }\n};\n","author":"RB245","submissionId":"1575217357"},[]]},{"1171":[{"id":"1171","fileName":"1575217430.txt","sourceCode":"class Solution {\npublic:\nint subsetSumHelper(int idx, int currSum, int n, vector<int>& v, vector<vector<int>>& dp) {\n    if (currSum == 0) return 1;\n    if (currSum < 0 || idx == n) return 0;\n    if (dp[idx][currSum] != -1) return dp[idx][currSum];\n\n    int ans = subsetSumHelper(idx + 1, currSum, n, v, dp);\n    ans |= subsetSumHelper(idx + 1, currSum - v[idx], n, v, dp);\n\n    return dp[idx][currSum] = ans;\n}\nint helper(vector<int>& v, vector<vector<int>>& queries, int mid) {\n    int n = v.size();\n    vector<vector<int>> temp(n);\n\n    for (int i = 0; i < n; i++) \n        temp[i].push_back(0);\n\n    for (int i = 0; i < mid; i++) {\n        int u = queries[i][0], v = queries[i][1], val = queries[i][2];\n        for (int j = u; j <= v; j++) \n            temp[j].push_back(val);\n    }\n\n    bool flag = true;\n    for (int i = 0; i < n; i++) {\n        int len = temp[i].size();\n        vector<vector<int>> dp(len + 1, vector<int>(1001, -1));\n        int canAchieveSum = subsetSumHelper(0, v[i], len, temp[i], dp);\n        if (canAchieveSum == 0) {\n            flag = false;\n            break;\n        }\n    }\n    return flag;\n}\n\nint minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    int n = nums.size();\n    int low = 0 , high = queries.size() , mid ; \n    int ans = 1e9 ; \n    while(low <= high){\n        mid = (low + high) / 2 ; \n        int temp = helper(nums , queries , mid) ; \n        if(temp){\n            ans = min(ans , mid) ; \n            high = mid - 1 ; \n        }\n        else{\n            low = mid + 1 ; \n        }\n    }\n    if(ans == 1e9)\n        ans = -1 ; \n    return ans ;        \n}\n\n};","author":"Abhishek12115047","submissionId":"1575217430"},[]]},{"1172":[{"id":"1172","fileName":"1575217286.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        c = (1 << n) - 1\n        cur = 0\n        possible_values = [set([0]) for _ in range(n)]\n        for i in range(n):\n            if nums[i] in possible_values[i]:\n                cur |= (1 << i)\n        if cur == c: return 0\n        for i in range(len(queries)):\n            l, r, val = queries[i]\n            for j in range(l, r + 1):\n                if (1 << j) & cur != 0: continue\n                pv = possible_values[j]\n                for k in list(pv):\n                    pv.add(k + val)\n                if nums[j] in pv: cur |= (1 << j)\n            if cur == c: return (i + 1)\n        return -1","author":"Anton","submissionId":"1575217286"},[]]},{"1174":[{"id":"1174","fileName":"1575217661.txt","sourceCode":"class Solution {\npublic:\n    \n    bool dfs(vector<vector<int>>& dp, vector<int>& arr, int target, int idx, int mid) {\n        if (idx > mid) {\n            return target == 0;\n        }\n        if (target == 0) {\n            return true;\n        }\n        if (dp[idx][target] != -1) {\n            return dp[idx][target];\n        }\n        \n        // not use this idx;\n        bool res = dfs(dp, arr, target, idx + 1, mid);\n        if (res) {\n            dp[idx][target] = res;\n            return true;\n        }\n        // use this idx\n        if (arr[idx] <= target) {\n            res |= dfs(dp, arr, target - arr[idx], idx + 1, mid);\n        }\n        dp[idx][target] = res;\n        return res;\n    }\n    \n    bool check(vector<vector<int>>& arr, vector<int>& nums, int mid) {\n        for (int j = 0; j < nums.size(); j++) {\n            vector<vector<int>> dp(mid + 1, vector<int>(nums[j] + 1, -1));\n            if (!dfs(dp, arr[j], nums[j], 0, mid)) {\n                // cout << i << ' ' << j << 'n';\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size(), sum = 0;\n        for (auto& v : nums) sum += v;\n        if (sum == 0) return 0;\n        vector<vector<int>> arr(n, vector<int>(q));\n        for (int i = 0; i < q; i++) {\n            for (int j = 0; j < n; j++) {\n                if (j >= queries[i][0] && j <= queries[i][1]) {\n                    arr[j][i] = queries[i][2];\n                }\n            }\n        }\n        vector<int> minn(n, q + 1);\n        for (int i = 0; i < n; i++) {\n            int l = 0, r = q, res = q + 1;\n            while (l < r) {\n                int mid = l + (r - l) / 2;\n                vector<vector<int>> dp(mid + 1, vector<int>(nums[i] + 1, -1));\n                if (dfs(dp, arr[i], nums[i], 0, mid)) {\n                    res = mid;\n                    r = mid;\n                } else {\n                    l = mid + 1;\n                }\n            }\n            minn[i] = res;\n        }\n        int maxn = 0;\n        for (auto& v : minn) maxn = max(maxn, v);\n        return maxn >= q + 1 ? -1 : maxn + 1;\n    }\n};\n/*\n[5]\n[[0,0,4],[0,0,7],[0,0,1],[0,0,10],[0,0,1],[0,0,10]]\n[9,1]\n[[1,1,7],[1,1,4],[0,1,5],[0,1,4],[1,1,2],[1,1,5],[0,1,2],[0,0,9],[0,0,4],[0,0,5],[0,0,6],[1,1,2],[0,0,4],[0,0,8],[1,1,2],[0,1,8],[1,1,2],[1,1,9],[1,1,7],[1,1,3],[1,1,5],[0,1,10],[1,1,9],[1,1,9],[1,1,3],[1,1,2],[0,0,4],[1,1,8],[1,1,8],[1,1,5],[0,1,3],[1,1,3],[1,1,5],[0,0,10],[0,1,7],[1,1,8],[0,0,8],[1,1,4],[0,0,4],[0,1,3],[0,1,5],[0,1,2],[1,1,2],[1,1,8],[1,1,7],[1,1,4],[1,1,1],[0,1,9]]\n[3,13,9]\n[[0,0,6],[2,2,8],[0,0,4],[2,2,6],[1,2,3],[2,2,1],[0,0,6],[1,2,4],[2,2,1],[0,0,2],[1,1,8],[0,2,8],[2,2,6],[1,2,2],[0,2,7],[1,1,8],[1,2,5],[0,0,4],[1,1,5],[0,0,10],[1,1,9],[1,1,10],[1,2,9],[1,1,1],[0,0,6],[0,2,4],[1,1,3],[1,2,5],[2,2,10],[2,2,3],[1,1,2],[0,1,8],[1,2,9],[2,2,5],[2,2,3],[1,1,9],[1,1,7],[0,0,8],[2,2,9],[1,1,5],[2,2,9],[2,2,7],[1,1,8],[1,2,3],[2,2,6],[1,2,10],[0,0,5],[2,2,10],[2,2,4]]\n3\n*/","author":"k487237","submissionId":"1575217661"},[]]},{"1175":[{"id":"1175","fileName":"1575217513.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if sum(nums) == 0:\n            return 0\n            \n        answer = -float(\"inf\")\n        for i in range(len(nums)):\n            queries_so_far = []\n            found = False\n            \n            for j in range(len(queries)):\n                left, right, value = queries[j]\n                \n                if left <= i <= right:\n                    queries_so_far.append(value)\n\n                    can_use_queries = self.subset_possible(queries_so_far, nums[i])\n                \n                    if can_use_queries:\n                        answer = max(answer, j+1)\n                        found = True\n                        break\n\n            if not found:\n                return -1\n                \n        return answer if answer != -float(\"inf\") else -1 \n\n    def subset_possible(self, array, target):\n\n        @cache\n        def recurse(i, target):\n            if target == 0:\n                return True\n            elif target < 0:\n                return False\n            elif i == len(array):\n                return False\n\n            return recurse(i+1, target) or recurse(i+1, target - array[i])\n\n        return recurse(0, target) ","author":"KidusTegene","submissionId":"1575217513"},[]]},{"1176":[{"id":"1176","fileName":"1575217572.txt","sourceCode":"import java.util.*;\n\npublic class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        boolean[][] dp = new boolean[n][1001];\n        \n        int j = 0;\n        while (j < n) {\n            dp[j][0] = true;\n            j++;\n        }\n        \n        j = 0;\n        boolean allZero = true;\n        while (j < n) {\n            if (nums[j] != 0) {\n                allZero = false;\n                break;\n            }\n            j++;\n        }\n        if (allZero) return 0;\n        \n        int qIndex = 0;\n        while (qIndex < queries.length) {\n            int l = queries[qIndex][0];\n            int r = queries[qIndex][1];\n            int v = queries[qIndex][2];\n            \n            int index = l;\n            while (index <= r) {\n                boolean[] shifted = new boolean[1001];\n                int i = 0;\n                while (i < 1001 - v) {\n                    if (dp[index][i]) {\n                        shifted[i + v] = true;\n                    }\n                    i++;\n                }\n                i = 0;\n                while (i < 1001) {\n                    dp[index][i] = dp[index][i] || shifted[i];\n                    i++;\n                }\n                i = nums[index] + 1;\n                while (i < 1001) {\n                    dp[index][i] = false;\n                    i++;\n                }\n                index++;\n            }\n            \n            boolean allAchieved = true;\n            j = 0;\n            while (j < n) {\n                if (!dp[j][nums[j]]) {\n                    allAchieved = false;\n                    break;\n                }\n                j++;\n            }\n            if (allAchieved) return qIndex + 1;\n            qIndex++;\n        }\n        return -1;\n    }\n}\n","author":"roshan187","submissionId":"1575217572"},[]]},{"1177":[{"id":"1177","fileName":"1575217662.txt","sourceCode":"class Solution {\nprivate:\n    static const int MAX_N = 10 + 5;\n    static const int MAX_M = 1000 + 5;\n\n    vector <int> offsets[MAX_N];\n    bool dp[MAX_M];\n\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n\n        for(int i = 0; i < queries.size(); i++){\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int v = queries[i][2];\n            for(int j = 0; j < n; j++){\n                if(l <= j && j <= r){\n                    offsets[j].push_back(v);\n                }else{\n                    offsets[j].push_back(0);\n                }\n            }\n        }\n        int answer = 0;\n        for(int _ = 0; _ < n; _++){\n            int x = nums[_];\n            for(int i = 0; i < MAX_M; i++){\n                dp[i] = false;\n            }\n            dp[0] = true;\n            if(dp[x] == true){\n                answer = max(answer, 0);\n                continue;\n            }\n            for(int i = 0; i < offsets[_].size(); i++){\n                int v = offsets[_][i];\n                for(int j = MAX_M - 1 - v; j >= 0; j--){\n                    dp[j + v] |= dp[j];\n                }\n                if(dp[x] == true){\n                    answer = max(answer, i+1);\n                    break;\n                }\n            }\n            if(dp[x] == false){\n                return -1;\n            }\n        }\n        return answer;\n    }\n};","author":"Nima","submissionId":"1575217662"},[]]},{"1178":[{"id":"1178","fileName":"1575217674.txt","sourceCode":"class Solution {\npublic:\n    int canSum(vector<pair<int,int>>& nums, int target) {\n        bitset<10001> dp;\n        //vector<int> last(10001, -1);\n\n        dp[0] = 1;\n        int last=-2;\n        for (auto x : nums) {\n            //cout<<x.first<<\" \"<<x.second<<endl;\n            for (int j = target; j >= x.first; j--) {\n                if (dp[j - x.first] && !dp[j]) {\n                    dp[j] = 1;\n                    //last[j] = x.second;\n                }\n                if(dp[target]==1){\n                    return x.second;\n                }\n            }\n        }\n\n        return -2;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        map<int, vector<pair<int,int>>> gfg;\n        int ans=-1;\n        int j=0;\n        for (auto it : queries) {\n            int l = it[0];\n            int r = it[1];\n            int val = it[2];\n            for (int i = l; i <= r; i++) {\n                gfg[i].push_back({val,j});\n            }\n            j++;\n        }\n        int n = nums.size();\n        //vector<vector<int>> kgf(n + 1, vector<int>(1001, 0));\n        for(int i=0;i<n;i++){\n            if(nums[i]==0){\n                continue;\n            }\n            int a=canSum(gfg[i],nums[i]);\n            //cout<<a<<endl;\n            if(a==-2){\n                return -1;\n            }\n            ans=max(ans,a);\n        }\n        return ans+1;\n    }\n};","author":"mZSGkLlyq4","submissionId":"1575217674"},[]]},{"1180":[{"id":"1180","fileName":"1575217784.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        \n        int l = 0 , h = queries.length;\n        int res = -1;\n        while(l<=h){\n            int mid = (l+h)/2;\n            if(possible(mid,nums,queries)) {\n                res = mid;\n                h=mid-1;\n            } else l=mid+1;\n        }\n        return res;\n        \n        \n    }\n    public boolean possible(int mid,int nums[],int[][] queries){\n        int n = nums.length;\n        List<Integer> val[]=new ArrayList[n];\n        for(int i = 0;i<n;i++) val[i]=new ArrayList<>();\n        for(int i=0;i<mid;i++){\n            int q[]=queries[i];\n            int l = q[0], r=q[1], value = q[2];\n            for(int j=l;j<=r;j++) val[j].add(value);\n        }\n        for(int i=0;i<n;i++){\n            if(!sumPossible(nums[i],val[i])) return false;\n        }\n        return true;\n    }\n    public boolean sumPossible(int sum ,List<Integer> nums){\n        \n        boolean arr[]=new boolean[sum+1];\n        arr[0]=true;\n        for(int val : nums){\n            for(int i=sum-val;i>=0;i--) {\n                if(arr[i]) arr[i+val]=true;\n            }\n        }\n        return arr[sum];\n    }\n}\n\n","author":"YouKnowMe","submissionId":"1575217784"},[]]},{"1181":[{"id":"1181","fileName":"1575217728.txt","sourceCode":"import java.util.AbstractMap;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        HashMap<Integer, List<Map.Entry<Integer, Integer>>> table = new HashMap<>();\n\n        for (int j = 0; j < nums.length; j++) {\n            List<Map.Entry<Integer, Integer>> list = new ArrayList<>();\n            for (int i = 0; i < queries.length; i++) {\n                int l = queries[i][0];\n                int r = queries[i][1];\n                int val = queries[i][2];\n                if (j >= l && j <= r) {\n                    list.add(new AbstractMap.SimpleEntry<>(val, i));\n                }\n            }\n            table.put(j, list);\n        }\n\n        int result = Integer.MIN_VALUE;\n\n        for (Map.Entry<Integer, List<Map.Entry<Integer, Integer>>> entry : table.entrySet()) {\n            // solve this problem\n\n            // 17     1 3 5 2 10 1\n\n            // select min k first elements to make the sum 17\n            int[][] dp = new int[entry.getValue().size()][nums[entry.getKey()] + 1];\n            for (int[] arr: dp) Arrays.fill(arr, -1);\n            if (nums[entry.getKey()] == 0) {\n                result = Math.max(result, 0);\n                continue;\n            }\n            int subproblemIndex = solve(0, nums[entry.getKey()], entry.getValue(), dp);\n            if (subproblemIndex == Integer.MAX_VALUE) return -1;\n            else result = Math.max(result, subproblemIndex + 1);\n        }\n        return result;\n    }\n\n    // value and index\n    int solve(int i, int target, List<Map.Entry<Integer, Integer>> arr, int[][] dp) {\n        if (i == arr.size()) return Integer.MAX_VALUE;\n        if (target < 0) return Integer.MAX_VALUE;\n\n        if (dp[i][target] != -1) return dp[i][target];\n        if (target == arr.get(i).getKey()) {\n            dp[i][target] = arr.get(i).getValue();\n            return dp[i][target];\n        }\n\n        int take = solve(i + 1, target - arr.get(i).getKey(), arr, dp);\n        int notTake = solve(i + 1, target, arr, dp);\n\n        dp[i][target] = Math.min(take, notTake);\n        return dp[i][target];\n    }\n}","author":"srknzl","submissionId":"1575217728"},[]]},{"1182":[{"id":"1182","fileName":"1575217820.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        vector<vector<pair<int, int>>> coverage(n);\n        for (int j = 0; j < q; ++j) {\n            int l = queries[j][0];\n            int r = queries[j][1];\n            int val = queries[j][2];\n            for (int i = l; i <= r; ++i) {\n                coverage[i].emplace_back(j, val);\n            }\n        }\n\n        vector<vector<int>> prefix_sums(n);\n        vector<vector<bitset<1001>>> dp(n);\n\n        for (int i = 0; i < n; ++i) {\n            int m = coverage[i].size();\n            vector<int> prefix(m + 1, 0);\n            vector<bitset<1001>> dp_i(m + 1);\n\n            dp_i[0][0] = true;\n\n            for (int s = 1; s <= m; ++s) {\n                int val = coverage[i][s-1].second;\n                prefix[s] = prefix[s-1] + val;\n                dp_i[s] = dp_i[s-1] | (dp_i[s-1] << val);\n            }\n\n            prefix_sums[i] = prefix;\n            dp[i] = dp_i;\n        }\n\n        int left = 0, right = q;\n        int ans = -1;\n\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            bool valid = true;\n\n            for (int i = 0; i < n; ++i) {\n                int target = nums[i];\n                if (target == 0) continue;\n\n                auto& cov = coverage[i];\n                int pos = upper_bound(cov.begin(), cov.end(), make_pair(mid-1, 0), \n                    [](const pair<int, int>& a, const pair<int, int>& b) {\n                        return a.first < b.first;\n                    }) - cov.begin();\n\n                int sum = prefix_sums[i][pos];\n                if (sum < target) {\n                    valid = false;\n                    break;\n                }\n                if (sum == target) {\n                    continue;\n                }\n                if (!dp[i][pos][target]) {\n                    valid = false;\n                    break;\n                }\n            }\n            if (valid) {\n                ans = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        if(ans !=-1) return ans;\n        else return -1;\n    }\n};","author":"Abhishek Choudhary","submissionId":"1575217820"},[]]},{"1183":[{"id":"1183","fileName":"1575217852.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        pair<vector<int>,vector<vector<int>>>p={nums,queries};\n        vector<bitset<1002>>dp(n);\n        bool f=1;\n        for(int i=0;i<n;i++){\n            dp[i].reset();\n            dp[i].set(0,true);\n        }\n        for(int i=0;i<n;i++){\n            if(nums[i]!=0){\n                f=0;\n                break;\n            }\n        }\n        if(f)return 0;\n        for(int i=0;i<queries.size();i++){\n            for(int j=queries[i][0];j<=queries[i][1];j++){\n                dp[j]=dp[j]|(dp[j]<<queries[i][2]);\n                for(int k=nums[j]+1;k<1001;k++)dp[j].reset(k);\n            }\n            bool curr=true;\n            for(int j=0;j<n;j++){\n                if(!dp[j].test(nums[j])){\n                    curr=false;\n                    break;\n                }\n            }\n            if(curr)return i+1;\n        }\n        return -1;\n    }\n};","author":"Neha garg","submissionId":"1575217852"},[]]},{"1184":[{"id":"1184","fileName":"1575217832.txt","sourceCode":"class Solution {\npublic:\n    int MAX = 100000;\n    int solve( int n,int idx, vector<int>&arr, vector<vector<int>> &dp ) {\n        if( idx == arr.size() )\n            return MAX;\n        if( n - arr[idx] == 0 )\n            return idx;\n        if( dp[n][idx] != -1 )\n            return dp[n][idx];\n        int a=MAX,b;\n        if( n - arr[idx] > 0 )\n            a = solve( n - arr[idx], idx+1, arr, dp  );\n        b = solve( n, idx+1, arr, dp );\n        return dp[n][idx] = min( a,b );\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int> final(nums.size(),-1);\n        for( int i=0; i<nums.size(); ++i ) {\n            if( nums[i] == 0 ) {\n                final[i] = 0;\n                continue;\n            }\n            int n = nums[i];\n            vector<int> indexToNumQ;\n            vector<int> arr;\n            for( int  j=0; j< queries.size(); ++j ) {\n                // building arr and indexToNumQ\n                if( i>= queries[j][0] && i<=queries[j][1] ) {\n                    arr.push_back(queries[j][2]);\n                    indexToNumQ.push_back(j+1);\n                }\n            }\n            if( arr.size() == 0 )\n                return -1;\n            vector<vector<int>> dp(n+1,vector<int>(arr.size(),-1));\n            int x = solve( n, 0, arr, dp );\n            if( x == MAX )\n                return -1;\n            final[i] = indexToNumQ[ x ];\n        }\n        int ans=-1;\n        for( auto i : final )\n            ans = max(ans,i);\n        return ans;\n    }\n};","author":"Alan S Paul","submissionId":"1575217832"},[]]},{"1185":[{"id":"1185","fileName":"1575217858.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int ans = -1;\n        for(int i = 0; i<n; i++) {\n            int q = queries.size();\n            vector<vector<int>> dp(q, vector<int> (nums[i]+1, -1));\n            int temp = dfs(queries, i, 0, nums[i], dp);\n            ans = max(ans, temp);\n        }\n        return ans == INT_MAX ? -1 : ans;\n    }\n    \n    int dfs(vector<vector<int>>& queries, int index, int start, int target, vector<vector<int>> &dp) {\n        if (target == 0)\n            return start;\n        if (target < 0 || start == queries.size())\n            return INT_MAX;\n        \n        if (dp[start][target] != -1)\n            return dp[start][target];\n        \n        int temp = INT_MAX;\n        if (queries[start][0] <= index && queries[start][1] >= index)\n            temp = dfs(queries, index, start + 1, target - queries[start][2], dp);\n        return dp[start][target] = min(dfs(queries, index, start + 1, target, dp), temp);\n    }\n};\n// a0*val0 + a1*val1 + a2*val2 + ... + an*valn = nums[0];\n// b0*val0 + b0*val1 + ....                    = nums[1];\n// 球a0,a1, ... b0, b1, ...","author":"s985060740","submissionId":"1575217858"},[]]},{"1186":[{"id":"1186","fileName":"1575218007.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        if(allZeroes(nums))\n            return 0;\n        ArrayList<ArrayList<Integer>> list = new ArrayList<>();\n        int n = nums.length;\n        for(int i=0;i<n;i++)\n            list.add(new ArrayList<>());\n        for(int i=0;i<queries.length;i++) {\n            int start = queries[i][0], end = queries[i][1];\n            for(int j=start;j<=end;j++)\n                list.get(j).add(queries[i][2]);\n            if(isPossible(nums, list))\n                return i+1;\n        }\n        return -1;\n    }\n\n    private boolean isPossible(int[] nums, ArrayList<ArrayList<Integer>> list) {\n        int n = nums.length;\n        for(int i=0;i<n;i++) {\n            if(nums[i] == 0)\n                continue;\n            int m = list.get(i).size();\n            int[][] dp = new int[m][nums[i]+1];\n            for(int[] rows : dp)\n                Arrays.fill(rows,-1);\n            if(check(list.get(i),0, nums[i],dp) == 0)\n                return false;\n        }\n        return true;\n    }\n\n    private int check(ArrayList<Integer> list, int i, int sum, int[][] dp) {\n        int n = list.size();\n        if(sum == 0)\n            return 1;\n        if(sum<0 || i == n)\n            return 0;\n        if(dp[i][sum] != -1)\n            return dp[i][sum];\n        int ans = 0;\n        ans |= check(list,i+1,sum-list.get(i),dp);\n        ans |= check(list,i+1,sum,dp);\n        return dp[i][sum] = ans;\n    }\n\n    private boolean allZeroes(int[] nums) {\n        for(int num : nums) {\n            if(num>0)\n                return false;\n        }\n        return true;\n    }\n}","author":"yashwanth73","submissionId":"1575218007"},[]]},{"1187":[{"id":"1187","fileName":"1575218076.txt","sourceCode":"//* sometimes pragmas don't work, if so, just comment it!\n//? #pragma GCC optimize (\"Ofast\")\n//? #pragma GCC target (\"avx,avx2\")\n//! #pragma GCC optimize (\"trapv\")\n\n//! #undef _GLIBCXX_DEBUG //? for Stress Testing\n\n#include <bits/stdc++.h> //? if you don't want IntelliSense\n\nusing namespace std;\n\n// building blocks\nusing ll  = long long;\nusing db  = long double; // or double, if TL is tight\nusing str = string;      // yay python!\n\n//? priority_queue for minimum\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\nusing ull  = unsigned long long;\n//? using i64  = long long;\n//? using u64  = uint64_t;\n//? using i128 = __int128;\n//? using u128 = __uint128_t;\n//? using f128 = __float128;\n\n\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n\n#define mp make_pair\n#define f  first\n#define s  second\n\n\n\n#define tcT template <class T\n#define tcTU tcT, class U\n//! ^ lol this makes everything look weird but I'll try it\n\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n#define ts to_string\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\n\n\nconst int MOD = 1e9 + 7;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18;  //? not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  //? for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\n\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits set\nconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\n\t                         // USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n}  // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n}  // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n}  // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n}  // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n}  // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi);  // assuming f is increasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi);  // assuming f is decreasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) {  // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void safeErase(T &t, const U &u) {\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n}\n\n\n\n#define tcTUU tcT, class ...U\n\ninline namespace IO {\n#define SFINAE(x, ...)                                                         \n\ttemplate <class, class = void> struct x : std::false_type {};              \n\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}\n\nSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));\nSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));\nSFINAE(IsTuple, typename std::tuple_size<T>::type);\nSFINAE(Iterable, decltype(std::begin(std::declval<T>())));\n\ntemplate <auto &is> struct Reader {\n\ttemplate <class T> void Impl(T &t) {\n\t\tif constexpr (DefaultI<T>::value) is >> t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tfor (auto &x : t) Impl(x);\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\n\t\t} else static_assert(IsTuple<T>::value, \"No matching type for read\");\n\t}\n\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }\n};\n\ntemplate <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }\n#define def(t, args...)                                                        \n\tt args;                                                                    \n\tre(args);\n\ntemplate <auto &os, bool debug, bool print_nd> struct Writer {\n\tstring comma() const { return debug ? \",\" : \"\"; }\n\ttemplate <class T> constexpr char Space(const T &) const {\n\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? 'n'\n\t\t                                                             : ' ';\n\t}\n\ttemplate <class T> void Impl(T const &t) const {\n\t\tif constexpr (DefaultO<T>::value) os << t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tif (debug) os << '{';\n\t\t\tint i = 0;\n\t\t\tfor (auto &&x : t)\n\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\n\t\t\tif (debug) os << '}';\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tif (debug) os << '(';\n\t\t\tstd::apply(\n\t\t\t    [this](auto const &...args) {\n\t\t\t\t    int i = 0;\n\t\t\t\t    (((i++) ? (os << comma() << \" \", Impl(args)) : Impl(args)),\n\t\t\t\t     ...);\n\t\t\t    },\n\t\t\t    t);\n\t\t\tif (debug) os << ')';\n\t\t} else static_assert(IsTuple<T>::value, \"No matching type for print\");\n\t}\n\ttemplate <class T> void ImplWrapper(T const &t) const {\n\t\tif (debug) os << \"033[0;31m\";\n\t\tImpl(t);\n\t\tif (debug) os << \"033[0m\";\n\t}\n\ttemplate <class... Ts> void print(Ts const &...ts) const {\n\t\t((Impl(ts)), ...);\n\t}\n\ttemplate <class F, class... Ts>\n\tvoid print_with_sep(const std::string &sep, F const &f,\n\t                    Ts const &...ts) const {\n\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << 'n';\n\t}\n\tvoid print_with_sep(const std::string &) const { os << 'n'; }\n};\n\ntemplate <class... Ts> void pr(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print(ts...);\n}\ntemplate <class... Ts> void ps(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print_with_sep(\" \", ts...);\n}\n}  // namespace IO\n\ninline namespace Debug {\n\n#ifdef LOCAL\n#include \"helpers/debug.h\"\n\n#define chk(...) if (!(__VA_ARGS__)) cerr << \"033[41m\" << \"Line(\" << __LINE__ << \") -> function(\" \n\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"033[0m\" << \"n\", exit(0);\n\n#define MACRO(code) do {code} while (false)\n#define RAYA MACRO(cerr << \"033[101m\" << \"================================\" << \"033[0m\" << endl;)\n#else\n//? #define dbg(...)\n\n#define chk(...)\n//? #define RAYA\n#endif\n\nconst auto beg_time = std::chrono::high_resolution_clock::now();\n// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\ndouble time_elapsed() {\n\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\n\t                                beg_time)\n\t    .count();\n}\n}  // namespace Debug\n\n\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), \"r\", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), \"w\", stdout); }\nvoid setIO(str s = \"\") {\n\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\n\t//? cout << fixed << setprecision(12);\n    //? cerr << fixed << setprecision(12);\n\tcin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + \".in\"), setOut(s + \".out\");  // for old USACO\n}\n}  // namespace FileIO\n\n\n\n//? Custom Helpers\ntemplate <typename T>\ninline T gcd(T a, T b) { while (b != 0) swap(b, a %= b); return a; }\n\nlong long binpow(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = res * a;\n        a = a * a;\n        b >>= 1;\n    }\n    return res;\n}\n\nconst int dddx[8]{1, 0, -1,  0, 1,  1, -1, -1};\nconst int dddy[8]{0, 1,  0, -1, 1, -1,  1, -1};\n\nusing vvi = V<vi>;\nusing vvl = V<vl>;\nusing vvb = V<vb>;\n//? /Custom Helpers\n\n#define RAYA ps(\"================================\")\n\nconst string PAIR_LEFT = \"(\";\nconst string PAIR_RIGHT = \")\";\nconst string IT_LEFT = \"[\";\nconst string IT_RIGHT = \"]\";\nconst string PAIR_SEP = \", \";\nconst string IT_SEP = \", \";\n \n// const string PAIR_LEFT = \"(\";\n// const string PAIR_RIGHT = \")\";\n// const string IT_LEFT = \"[\";\n// const string IT_RIGHT = \"]\";\n// const string PAIR_SEP = \" \";\n// const string IT_SEP = \" \";\n \n// const string PAIR_LEFT = \"{\";\n// const string PAIR_RIGHT = \"}\";\n// const string IT_LEFT = \"{\";\n// const string IT_RIGHT = \"}\";\n// const string PAIR_SEP = \", \";\n// const string IT_SEP = \", \";\n \n// benq - print any container + pair\ntemplate<typename T, typename = void> struct is_iterable : false_type {};\ntemplate<typename T> struct is_iterable<T, void_t<decltype(begin(declval<T>())),decltype(end(declval<T>()))>> : true_type {};\ntemplate<typename T> typename enable_if<is_iterable<T>::value&&!is_same<T, string>::value,ostream&>::type operator<<(ostream &cout, T const &v);\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << PAIR_LEFT << p.f << PAIR_SEP << p.s << PAIR_RIGHT; }\ntemplate<typename T> typename enable_if<is_iterable<T>::value&&!is_same<T, string>::value,ostream&>::type operator<<(ostream &cout, T const &v) {\n    cout << IT_LEFT; \n    for (auto it = v.begin(); it != v.end();) {\n        cout << *it;\n        if (++it != v.end()) cout << IT_SEP;\n    }\n    return cout << IT_RIGHT;\n}\ntemplate<typename A, typename B> istream& operator>>(istream& cin, pair<A, B> &p) {\n    cin >> p.first;\n    return cin >> p.second;\n}\n \nvoid dbg_out() { cout << endl; }\ntemplate<typename Head, typename... Tail> \nvoid dbg_out(Head H, Tail... T) { cout << ' ' << H; dbg_out(T...); }\n#define dbg(...) cout << \"(\" << #__VA_ARGS__ << \"): \", dbg_out(__VA_ARGS__)\n\n//* Template\n//* /Template\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        bool todozero=true;\n        each(e,nums){\n            if(e!=0){\n                todozero=false;\n                break;\n            }\n        }\n        if(todozero){\n            return 0;\n        }\n        int tam=queries.size(),n=nums.size();\n        vector<vi> values(n);\n        FOR(i,0,tam){\n            FOR(it,queries[i][0],queries[i][1]+1){\n                values[it].pb(queries[i][2]);\n            }\n            bool ok=true;\n            FOR(j,0,n){\n                int len=values[j].size();\n                vvi dp(len,vi(nums[j]+1,0));\n                if(len>0){\n                    dp[0][0]=1;\n                    if(values[j][0]<=nums[j])\n                        dp[0][values[j][0]]=1;\n                }\n                FOR(k,1,len){\n                    FOR(it,0,nums[j]+1){\n                        dp[k][it]=dp[k-1][it];\n                        if(it >= values[j][k] && dp[k-1][it-values[j][k]]){\n                            dp[k][it]=1;\n                        }\n                    }\n                }\n                if(len==0){\n                    if(nums[j]!=0){\n                        ok=false;\n                        break;\n                    }\n                }\n                if(len>=1 && !dp[len-1][nums[j]]){\n                    ok=false;\n                    break;\n                }\n            }\n            if(ok){\n                return i+1;\n            }\n        }\n        return -1;\n    }\n};","author":"Diego Alonso Huamani Luque","submissionId":"1575218076"},[]]},{"1188":[{"id":"1188","fileName":"1575218021.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        bool flag = true;\n        for(auto &num:nums){\n            if(num != 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag) return 0;\n        \n        vector<bitset<1001>> bits(n,bitset<1001>(0));\n        for(int i=0;i<n;i++){\n            bits[i].set(0,1);\n        }\n\n        for(int i=0;i<queries.size();i++){\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n\n            for(int j=l;j<=r;j++){\n                bits[j] |= (bits[j] << val);\n                for(int k = nums[j]+1;k<1001;k++){\n                    bits[j].reset(k);\n                }\n            }\n\n            bool allZero = true;\n            for(int j=0;j<n;j++){\n                if(bits[j][nums[j]] == 0){\n                    allZero = false;\n                    break;\n                }\n            }\n            if(allZero) return i+1;\n        }\n        return -1;\n            \n    }\n};","author":"Sourabh awasthy","submissionId":"1575218021"},[]]},{"1189":[{"id":"1189","fileName":"1575218053.txt","sourceCode":"class Solution {\npublic:\n    int isZeroArray(int n, vector<bitset<1001>> &dp, vector<int> &nums){\n        for (int i = 0; i < n; ++i)\n            if (!dp[i].test(nums[i])) return false;\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size();\n        vector<bitset<1001>> dp(n);\n        for (int i = 0; i < n; ++i) dp[i].set(0);\n        \n        if (isZeroArray(n, dp, nums)) return 0;\n        for (int i = 0; i < q; ++i) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for (int j = l; j <= r; ++j)\n                dp[j] |= (dp[j] << val);\n            if (isZeroArray(n, dp, nums)) return i + 1;\n        }\n        return -1;\n    }\n};","author":"Nitin Bhatt","submissionId":"1575218053"},[]]},{"1191":[{"id":"1191","fileName":"1575218235.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = -1;\n        int qsz = queries.size();\n        int nsz = nums.size();\n\n\n        for(int i=0; i < nsz; ++i){\n            vector<int> vals;\n            \n            for(int j=0; j < qsz; ++j){\n                if(i <= queries[j][1] && i >= queries[j][0] && \n                    nums[i] >= queries[j][2])\n                {\n                    vals.push_back(queries[j][2]);\n                }\n                else{\n                    vals.push_back(0);\n                }\n            }\n\n            // cout << \"Printing vals:n\";\n            // for(auto& v: vals){\n            //     cout << v << \" \";\n            // }\n            // cout << \"n\";\n\n            // now minimum number of starting vals to process to make nums[i] -> 0\n            // generally we pick or not pick each val and check next\n            // but we see repeating subproblems -> so make dp\n\n            int tempAns = INT_MAX;\n\n            vector<int> dp(nums[i]+1, INT_MAX);\n            dp[0] = 0;\n\n            for(int j=0; j < qsz && dp[nums[i]] == INT_MAX; ++j){\n                if(vals[j] == 0){\n                    continue;\n                }\n                else{\n                    for(int k = nums[i]; k >= vals[j]; --k){\n                        if(dp[k] == INT_MAX && dp[k-vals[j]] != INT_MAX){\n                            dp[k] = j+1; //need to process j+1 queries\n                        }\n                    }\n                }\n            }\n\n            // cout << \"dp[nums[i]] : \" << dp[nums[i]] << endl;\n            if(dp[nums[i]] != INT_MAX){\n                // we achieved something\n                ans = max(ans, dp[nums[i]]);\n            }\n            else{\n                return -1;\n            }\n        }\n\n        return ans; //we processed all elements\n        \n    }\n};","author":"JerMan","submissionId":"1575218235"},[]]},{"1192":[{"id":"1192","fileName":"1575218297.txt","sourceCode":"class Solution {\npublic:\n    bool _knapsack(const vector<int> &a, int v) {\n        int m = a.size();\n        vector<bool> f(vector<bool>(v+1, false));\n        f[0] = true;\n        for (int i = 0; i < m; ++i){\n            for (int j = v; j >= a[i]; --j){\n                f[j] = (f[j] || f[j-a[i]]);\n            }\n        }\n        return f[v];\n    }\n\n    bool check(int k, const vector<int>& nums, const vector<vector<int>>& queries){\n        for (int i = 0; i < nums.size(); ++i){\n            vector<int> a(0);\n            for (int j = 0; j < k; ++j){\n                auto q = queries[j];\n                int l = q[0], r = q[1], val = q[2];\n                if (i < l || i > r) continue;\n                a.push_back(val);\n            }\n            if (_knapsack(a, nums[i]) == false) return false;\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l = 0, r = queries.size();\n        int k = -1;\n        while (l <= r){\n            int m = (l+r)/2;\n            if (check(m, nums, queries)) {\n                k = m;\n                r = m-1;\n            } else l = m+1;\n        }\n        return k;\n        // for (int i = l; i <= r; ++i){\n        //     if (check(i, nums, queries)) return i;\n        // }\n        // return -1;\n    }\n};","author":"Lulu","submissionId":"1575218297"},[]]},{"1193":[{"id":"1193","fileName":"1575218342.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        int ans = -1;\n        for(int i=0;i<n;i++)\n            {\n                // whats the first idx where ar[i] becomes 0.\n                //\n                vector<vector<bool>> dp(2,vector<bool>(nums[i]+1,0));\n                dp[0][0] = 1;\n                if(nums[i] == 0) \n                {\n                    ans = max(ans,0);\n                    continue;\n                }\n                int idx = -1;\n\n                for(int j=0;j<m;j++)\n                    {\n                        int l = queries[j][0];\n                        int r = queries[j][1];\n                        int val = queries[j][2];\n\n                        if(l<=i && r>=i && val<=nums[i])\n                        {\n                            \n                        }\n                        else\n                        {\n                            continue;\n                        }\n\n                        dp[0][0] = 1;\n                        for(int k=0;k<val;k++)\n                            {\n                                dp[1][k] = dp[0][k];\n                            }\n                        for(int k=val;k<=nums[i];k++)\n                            {\n                                dp[1][k] = (dp[0][k-val] || dp[0][k]);\n                            }\n                        \n                        \n\n                        if(dp[1][nums[i]]== 1)\n                        {\n                            idx = j+1;\n                            break;\n                        }\n\n                        //dp[0] = dp[1];\n                        for(int k=0;k<=nums[i];k++)\n                            {\n                                dp[0][k] = dp[1][k];\n                                dp[1][k]=0;\n                            }\n                    }\n\n                \n                if(idx == -1)\n                {\n                    return -1;\n                }\n                ans = max(ans,idx);\n            }\n\n        return ans;\n    }\n};","author":"Ankit Anvesh","submissionId":"1575218342"},[]]},{"1194":[{"id":"1194","fileName":"1575218519.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<unordered_set<int> > v(n);\n        \n        for (int i = 0; i < n; i++) {\n            v[i].insert(nums[i]);\n        }\n\n        int cnt = 0;\n        for (auto st: v) {\n            if (st.find(0) != st.end()) {\n                cnt++;\n            }\n        }\n        if (cnt == n) return 0;\n\n        for (int i = 0; i < m; i++) {\n            vector<int> q = queries[i];\n            int l = q[0], r = q[1], val = q[2];\n\n            for (int j = l; j <= r; j++) {\n                if (v[j].find(0) != v[j].end()) continue;\n                \n                vector<int> tmp;\n                for (int e: v[j]) {\n                    if (v[j].find(e - val) == v[j].end()) {\n                        tmp.push_back(e - val);\n                    }\n                }\n\n                for (int e: tmp) {\n                    v[j].insert(e);\n                }\n            }\n\n            int cnt = 0;\n            for (auto st: v) {\n                if (st.find(0) != st.end()) {\n                    cnt++;\n                }\n            }\n            if (cnt == n) return i + 1;\n        }\n\n        return -1;\n    }\n};","author":"akms","submissionId":"1575218519"},[]]},{"1195":[{"id":"1195","fileName":"1575218045.txt","sourceCode":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_N 1000  // Based on problem constraints\n\n// Function to check if all elements in the array are zero\nbool allZero(int* nums, int numsSize) {\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] != 0) return false;\n    }\n    return true;\n}\n\n// Function to perform the Zero Array Transformation\nint minZeroArray(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize) {\n    if (allZero(nums, numsSize)) return 0; // If all are already zero, return 0\n\n    // 2D DP table: `dp[i][j]` tracks if `nums[i]` can become `j`\n    bool dp[MAX_N][MAX_N + 1] = {false}; \n\n    // Initialize DP table\n    for (int i = 0; i < numsSize; i++) {\n        dp[i][0] = true;  // Zero is always achievable\n    }\n\n    // Process queries\n    for (int k = 0; k < queriesSize; k++) {\n        int l = queries[k][0];\n        int r = queries[k][1];\n        int v = queries[k][2];\n\n        for (int i = l; i <= r; i++) {\n            // Shift DP values for index `i`\n            for (int j = MAX_N; j >= v; j--) {\n                if (dp[i][j - v]) dp[i][j] = true;\n            }\n\n            // Clear values beyond nums[i]\n            for (int j = nums[i] + 1; j <= MAX_N; j++) {\n                dp[i][j] = false;\n            }\n        }\n\n        // Check if all nums[i] can be achieved\n        bool allAchieved = true;\n        for (int i = 0; i < numsSize; i++) {\n            if (!dp[i][nums[i]]) {\n                allAchieved = false;\n                break;\n            }\n        }\n\n        if (allAchieved) return k + 1;\n    }\n\n    return -1; // Not possible to transform the array to all zeroes\n}\n","author":"CHEEMALADINNE YASWANTH","submissionId":"1575218045"},[]]},{"1173":[{"id":"1173","fileName":"1575217381.txt","sourceCode":"\nclass Solution {\npublic:\n    int gettingAnswer(vector<int> &numbers, vector<vector<int>> &operations)\n    {\n        int arraySize = numbers.size();\n        vector<bitset<1001>> possibleValues(arraySize);\n    \n        for (int index = 0; index < arraySize; index++) {\n            possibleValues[index].set(0);\n        }\n    \n        if (all_of(numbers.begin(), numbers.end(), [](int x) { return x == 0; })) {\n            return 0;\n        }\n    \n        for (int operationIndex = 0; operationIndex < operations.size(); operationIndex++) {\n            int startPos = operations[operationIndex][0];\n            int endPos = operations[operationIndex][1];\n            int addValue = operations[operationIndex][2];\n    \n            for (int pos = startPos; pos <= endPos; pos++) {\n                bitset<1001> shiftedValues;\n                \n                for (int currentVal = 0; currentVal < 1001 - addValue; currentVal++) {\n                    if (possibleValues[pos][currentVal]) {\n                        shiftedValues.set(currentVal + addValue);\n                    }\n                }\n                \n                possibleValues[pos] |= shiftedValues;\n    \n                for (int val = numbers[pos] + 1; val < 1001; val++) {\n                    possibleValues[pos].reset(val);\n                }\n            }\n    \n            bool targetAchieved = true;\n            for (int index = 0; index < arraySize; index++) {\n                if (!possibleValues[index][numbers[index]]) {\n                    targetAchieved = false;\n                    break;\n                }\n            }\n    \n            if (targetAchieved) {\n                return operationIndex + 1;\n            }\n        }\n    \n        return -1;\n    }\n\n    int minZeroArray(vector<int>& numbers, vector<vector<int>>& operations) \n    {\n        return gettingAnswer(numbers, operations);\n    }\n};\n","author":"Rohit Kumar","submissionId":"1575217381"},[{"id":"1173","similarity":0.8538812785388128,"totOverlap":187,"longestOverlap":49}]],"1196":[{"id":"1196","fileName":"1575218409.txt","sourceCode":"\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<bitset<1001>> dp(n);\nwhile(true)break;\n        int gg=0;\n        for(int i=0;i<3;i++){\n            gg++;\n        }\n        for (int j = 0; j < n; j++) {\n            dp[j].set(0);\n        }\n\n        bool allZero = all_of(nums.begin(), nums.end(), [](int x) { return x == 0; });\n        if (allZero) return 0;\n\n        for (int k = 0; k < queries.size(); k++) {\n            int l = queries[k][0], r = queries[k][1], v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n                bitset<1001> shifted;\n                for (int i = 0; i < 1001 - v; i++) {\n                    if (dp[j][i]) {\n                        shifted.set(i + v);\n                    }\n                }\n                dp[j] |= shifted;\n\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp[j].reset(pos);\n                }\n            }\n\n            bool allAchieved = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j][nums[j]]) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n\n            if (allAchieved) return k + 1;\n        }\n        return -1;\n    }\n};\n\n","author":"Shivam Mishra","submissionId":"1575218409"},[{"id":"1581","similarity":0.8909952606635071,"totOverlap":188,"longestOverlap":53},{"id":"1581","similarity":0.8538812785388128,"totOverlap":187,"longestOverlap":49}]],"1581":[{"id":"1581","fileName":"1575238119.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int sizeofnums=nums.size();\n         vector<bitset<1001>> dp(sizeofnums);\n\n        for (int z = 0; z < sizeofnums; z++) {\n            dp[z].set(0);\n        }\n\n        bool zerofull = all_of(nums.begin(), nums.end(), [](int d) { return d == 0; });\n        if (zerofull) {\n            return 0;\n            }\nint sizeofqueries=queries.size();\n        for (int p = 0; p < sizeofqueries; p++) {\n            int a = queries[p][0], b = queries[p][1], c = queries[p][2];\n\n            for (int z = a; z<= b; z++) {\n                bitset<1001> change;\n                for (int i = 0; i < 1001 - c; i++) {\n                    if (dp[z][i]) {\n                        change.set(i + c);\n                    }\n                }\n                dp[z] |= change;\n\n                for (int pos = nums[z] + 1; pos < 1001; pos++) {\n                    dp[z].reset(pos);\n                }\n            }\n\n            bool m = true;\n            for (int h = 0; h < sizeofnums; h++) {\n                if (!dp[h][nums[h]]) {\n                    m = false;\n                    break;\n                }\n            }\n\n            if (m) {\n                return p + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"Pavani","submissionId":"1575238119"},[{"id":"1196","similarity":0.8909952606635071,"totOverlap":188,"longestOverlap":53}]]},{"1198":[{"id":"1198","fileName":"1575218645.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def check(k):\n            if k == m:\n                return False\n            for idx, num in enumerate(nums):\n                if num == 0:\n                    continue\n                if not subset_sum(k, num, idx):\n                    return False\n            return True\n        def subset_sum(k, x, idx):\n            dp = [False] * (x + 1)\n            dp[0] = True\n            for l, r, num in queries[:k+1]:\n                if l <= idx <= r: \n                    for current_sum in range(x, num-1, -1):\n                        if dp[current_sum - num]:\n                            dp[current_sum] = True\n            return dp[x]\n        n = len(nums)\n        m = len(queries)\n        if sum(nums) == 0:\n            return 0\n        l, r = 0, m\n        while l < r:\n            mid = (l+r)//2\n            if check(mid):\n                r = mid\n            else:\n                l = mid+1\n        if l == m:\n            return -1\n        return l+1","author":"Yang","submissionId":"1575218645"},[]]},{"1199":[{"id":"1199","fileName":"1575218527.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        List<Integer> arr[] = new ArrayList[nums.length];\n        boolean flag = true;\n        for(int i = 0 ; i < nums.length ; i++){\n            if(nums[i] != 0) flag = false;\n            arr[i] = new ArrayList<>();}\n        if(flag) return 0;\n        for(int i = 0 ; i < queries.length ; i++){\n            for(int j = queries[i][0] ; j <= queries[i][1] ; j++){\n                arr[j].add(queries[i][2]);\n            }\n            if(check(arr , nums)) return (i+1);\n        }\n        return -1;\n    }\n\n    boolean check(List<Integer> arr[] , int nums[]){\n        boolean t = true;\n        for(int i = 0 ; i < nums.length ; i++){\n            if(nums[i] == 0) continue;\n            if(!isSubsetSum(arr[i] , nums[i])) return false;\n        }\n        return true;\n    }\n     public boolean isSubsetSum(List<Integer> arr, int K) {\n        int n = arr.size();\n        boolean[] dp = new boolean[K + 1];\n        dp[0] = true; // Base case\n\n        for (int num : arr) {\n            for (int j = K; j >= num; j--) { // Traverse backwards\n                dp[j] |= dp[j - num];\n            }\n        }\n        return dp[K];\n    }\n}","author":"Lakshya Thakur","submissionId":"1575218527"},[]]},{"1200":[{"id":"1200","fileName":"1575218679.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n         int n=nums.size();\n        vector<vector<int>> v(n,vector<int>(1001,0));\n        int hp=0;\n        for(auto i:nums)\n            {\n                if(i==0)\n                    hp++;\n            }\n        for(int i=0;i<n;i++)\n            v[i][0]=1;\n        if(hp==n)\n            return 0;\n        for(int x=0;x<queries.size();x++)\n            {\n                for(int i=queries[x][0];i<=queries[x][1];i++)\n                    {\n                        int val=queries[x][2];\n                        for(int j=nums[i];j>=0;j--)\n                            {\n                                if(v[i][j]==1 && (j+val)<=1000)\n                                {\n                                    if(j+val==nums[i] && v[i][nums[i]]==0)\n                                        hp++;\n                                    v[i][j+val]=1;\n                                }\n                            }\n                        v[i][val]=1;\n                    }\n                if(hp==n)\n                    return x+1;\n            }\nreturn -1;\n    }\n};","author":"srirammarni99","submissionId":"1575218679"},[]]},{"1201":[{"id":"1201","fileName":"1575218963.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<vector<bool>> visit(nums.size(), vector<bool>(1050));\n        bool allZ = true;\n        for (int i = 0; i < nums.size(); ++i) {\n            allZ &= (nums[i] == 0);\n            visit[i][0] = true;\n        }\n        \n        if (allZ) return 0;\n\n        for (int k = 0; k < queries.size(); ++k) {\n            auto& q = queries[k];\n            for (int i = q[0]; i <= q[1]; ++i) {\n                for (int j = nums[i]; j - q[2] >= 0; --j) {\n                    if (visit[i][j - q[2]]) {\n                        visit[i][j] = true;\n                    }\n                }\n            }\n            bool p = true;\n            for (int i = 0; i < nums.size() && p; ++i) {\n                 p = visit[i][nums[i]];\n            }\n            if (p) return k + 1;\n        }\n        return -1;\n    }\n};","author":"Jing-You","submissionId":"1575218963"},[]]},{"1202":[{"id":"1202","fileName":"1575218933.txt","sourceCode":"class Solution {\npublic:\n    bool fn(vector<int> nums, vector<vector<int>>& queries,int mid){\n        int n = nums.size();\n        map<int,vector<int>> m;\n        for(int i=0;i<=mid;i++){\n            int a = queries[i][0];\n            int b = queries[i][1];\n            for(int j=a;j<=b;j++){\n                m[j].push_back(queries[i][2]);\n            }\n        }\n        for(int j=0;j<n;j++){\n            if(m.find(j)==m.end()){\n                if(nums[j]!=0){\n                    return false;\n                }\n            }\n            else{\n                int t = nums[j];\n                if(t==0){\n                    continue;\n                }\n                vector<bool> dp(t+1,false);\n                dp[0] = true;\n                for(auto &x:m[j]){\n                    for(int s= t;s>=x;s--){\n                        if(dp[s-x]){\n                            dp[s] = true;\n                        }\n                    }\n                }\n                if(dp[t]==0) return false;\n            }\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        int low =0;\n        int high = m-1;\n        int res = -1;\n        int ct=0;\n        for(int i=0;i<n;i++){\n            if(nums[i]==0) ct++;\n        }\n        if(ct==n) return 0;\n        while(low<=high){\n            int mid = low+(high-low)/2;\n            // cout<<\"mid \"<<mid<<endl;\n            if(fn(nums,queries,mid)){\n                res = mid+1;\n                high = mid-1;\n            }\n            else{\n                low = mid+1;\n            }\n            \n        }\n        return res;\n    }\n};","author":"Pranav Bansal","submissionId":"1575218933"},[]]},{"1203":[{"id":"1203","fileName":"1575219034.txt","sourceCode":"class Solution {\npublic:\n    int minI(const vector<vector<int>>& nums, int target) {\n        int n = nums.size();\n        vector<int> dp(target + 1, INT_MAX);\n        dp[0] = 0;\n    \n        int minIndex = INT_MAX;\n    \n        for (int i = 0; i < n; ++i) {\n            for (int j = target; j >= nums[i][0]; --j) {\n                if (dp[j - nums[i][0]] != INT_MAX) {\n                    dp[j] = min(dp[j], i + 1);\n                    if (j == target) {\n                        minIndex = min(minIndex, dp[j]);\n                    }\n                }\n            }\n        }\n    \n        return minIndex == INT_MAX ? -1 : minIndex - 1;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = -1, n = nums.size();\n        for(int i=0; i<n; i++){\n            if(nums[i] == 0) continue;\n            vector<vector<int>> v;\n            for(int j=0; j<queries.size(); j++){\n                if(i>=queries[j][0] and i<=queries[j][1]) v.push_back({queries[j][2], j});\n            }\n            if(minI(v, nums[i]) == -1) return -1;\n            ans = max(ans, v[minI(v, nums[i])][1]);\n        }\n        return ans+1;\n    }\n};","author":"Mani Deep Adepu","submissionId":"1575219034"},[]]},{"1204":[{"id":"1204","fileName":"1575219100.txt","sourceCode":"class Solution {\nprivate:\n    bool solve(vector<int>&ele, vector<vector<int>>&dp, int i, int j){\n        int m = dp.size(), n = dp[0].size();\n        if(i==m)return false;\n        if(dp[i][j]!=-1)return dp[i][j];\n        if(ele[i]==j)return dp[i][j] = 1;\n        dp[i][j] = solve(ele,dp,i+1,j);\n        if(dp[i][j]!=1 && ele[i]<j){\n            dp[i][j] = solve(ele,dp,i+1,j-ele[i]);\n        }\n        return dp[i][j];\n    }\n    bool check_sum(int sum, vector<int>ele){\n        int n = ele.size();\n        if(n==0)return false;\n        vector<vector<int>>dp(n,vector<int>(sum+1,-1));\n        return solve(ele,dp,0,sum);\n    }\n    bool possible(vector<int>& nums, vector<vector<int>>& queries, int k){\n        int n = nums.size(), q = queries.size();\n        vector<vector<int>> mat(n);\n        for(int i =0; i<k; i++){\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for(int j = l; j<=r; j++){\n                mat[j].push_back(val);\n            }\n        }\n        for(int i=0; i<n; i++){\n            if(nums[i]!=0){\n                if(!check_sum(nums[i],mat[i]))return false;\n            }\n        }\n        return true;\n    }\n\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size();\n        int l = 0, r = q, mid;\n        // F F F T T T -- first T\n        while(l<r){\n            mid = (l+r)/2;\n            if(possible(nums,queries,mid)){\n                r = mid;\n            }\n            else l = mid+1;\n        }\n        return possible(nums,queries,l)? l:-1;\n        \n    }\n};","author":"gutu","submissionId":"1575219100"},[]]},{"1205":[{"id":"1205","fileName":"1575219157.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& operations) {\n        int left = 0, right = operations.size(), result = -1;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (isPossible(nums, operations, mid)) {\n                result = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return result;\n    }\n\nprivate:\n    bool isPossible(vector<int>& nums, vector<vector<int>>& operations, int timeLimit) {\n        unordered_map<int, vector<int>> reductions;\n        unordered_map<int, int> maxReduction;\n\n        for (int i = 0; i < timeLimit; i++) {\n            int leftIndex = operations[i][0], rightIndex = operations[i][1], value = operations[i][2];\n            for (int j = leftIndex; j <= rightIndex; j++) {\n                reductions[j].push_back(value);\n                maxReduction[j] += value;\n            }\n        }\n\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == 0 || nums[i] == maxReduction[i]) continue;\n            if (nums[i] > maxReduction[i]) return false;\n\n            int targetValue = nums[i];\n            vector<int>& availableReductions = reductions[i];\n            vector<bool> dp(targetValue + 1, false);\n            dp[0] = true;\n\n            for (int reductionValue : availableReductions) {\n                for (int j = targetValue; j >= reductionValue; j--) {\n                    dp[j] = dp[j] || dp[j - reductionValue];\n                }\n            }\n\n            if (!dp[targetValue]) return false;\n        }\n\n        return true;\n    }\n};","author":"Huệ Trần","submissionId":"1575219157"},[]]},{"1206":[{"id":"1206","fileName":"1575219312.txt","sourceCode":"class Solution {\npublic:\n    bool fun(int ind, int target, vector<int>& arr, vector<vector<int>>& dp) {\n        if (target == 0) return true;\n        if (ind < 0) return false;\n        if (dp[ind][target] != -1) return dp[ind][target];\n\n        bool no = fun(ind - 1, target, arr, dp);\n        bool taken = false;\n        if (arr[ind] <= target) \n            taken = fun(ind - 1, target - arr[ind], arr, dp);\n        \n        return dp[ind][target] = (no || taken);\n    }\n\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        map<int, vector<int>> m;\n        int n = a.size();\n        int ans = 0;\n        int sum = accumulate(a.begin() , a.end() , 0ll);\n        if(sum == 0)return 0;\n        for (auto &x : q) {\n            ans++;\n            for (int i = x[0]; i <= x[1]; i++) {\n                m[i].push_back(x[2]);\n            }\n            int f = 0;\n            for (int i = 0 ; i < n ; i++) {\n                int target = a[i];\n                vector<vector<int>> dp(m[i].size(), vector<int>(target + 1, -1));\n                \n                if (!fun(m[i].size() - 1, target, m[i], dp)) {\n                    f = 1;\n                    break;\n                }\n            }\n            if(f == 0) return ans;\n        }\n\n        return -1;\n\n    }\n};\n","author":"NityaJangra","submissionId":"1575219312"},[]]},{"1207":[{"id":"1207","fileName":"1575219184.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n        vector<bitset<1001>> dp(n);\n\n        for (int i = 0; i < n; i++) {\n            dp[i].set(0);\n        }\n\n        if (all_of(nums.begin(), nums.end(), [](int x) { return x == 0; })) return 0;\n\n        for (int k = 0; k < q.size(); k++) {\n            applyQuery(dp, nums, q[k]);\n\n            if (isAchieved(dp, nums)) return k + 1;\n        }\n        return -1;\n    }\n\nprivate:\n    void applyQuery(vector<bitset<1001>>& dp, vector<int>& nums, vector<int>& query) {\n        int l = query[0], r = query[1], v = query[2];\n\n        for (int i = l; i <= r; i++) {\n            bitset<1001> temp;\n            for (int j = 0; j < 1001 - v; j++) {\n                if (dp[i][j]) {\n                    temp.set(j + v);\n                }\n            }\n            dp[i] |= temp;\n\n            for (int p = nums[i] + 1; p < 1001; p++) {\n                dp[i].reset(p);\n            }\n        }\n    }\n\n    bool isAchieved(const vector<bitset<1001>>& dp, const vector<int>& nums) {\n        for (int i = 0; i < nums.size(); i++) {\n            if (!dp[i][nums[i]]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n","author":"201130","submissionId":"1575219184"},[]]},{"1208":[{"id":"1208","fileName":"1575219399.txt","sourceCode":"class Solution{\n     boolean canSubtract(int key, int index, int[][] queries, int k){\n        boolean[] dp = new boolean[key + 1];\n        dp[0] = true;\n        boolean temp = dp[0];\n        for(int i = 0; i < k; i++){\n            int val = queries[i][2];\n            int l = queries[i][0], r = queries[i][1];\n            if(index < l) continue;\n            if(index > r) continue;\n            for(int s = key - val; s >= 0; s--){\n                if(dp[s]==true) dp[s + val] = true;\n            }\n        }\n        return dp[key];\n    }\n    \n    public int minZeroArray(int[] nums, int[][] queries){\n        int start = 0, end = queries.length, ans = -1;\n        while(start <= end){\n            int mid = start +(end - start) / 2;\n            if(isPossible(nums, queries, mid)){\n                int temp = ans;\n                ans = mid; \n                end = mid - 1;\n            } else start = mid + 1;\n        }\n        return ans;\n    }\n    boolean isPossible(int[] nums, int[][] queries, int k){\n        for(int i = 0; i < nums.length; i++){\n            if(nums[i] == 0) continue;\n            else if(!canSubtract(nums[i], i, queries, k)) return false;\n        }\n        return true;\n    }\n   \n}","author":"Ananya","submissionId":"1575219399"},[]]},{"1209":[{"id":"1209","fileName":"1575219167.txt","sourceCode":"class Solution {\n    bool f(vector<int>& a, int t) {\n    int n = a.size();\n    vector<bool> dp(t + 1, 0);\n    dp[0] = 1;\n    \n    for (int x : a)\n        for (int j = t; j >= x; j--)\n            dp[j] =dp[j]| dp[j - x];\n\n    return dp[t];\n}\n\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size(), k = -1, s = q.size();\n        vector<vector<int>> dp(n);\n        for (int i = 0; i < n; i++) {\n            while (!f(dp[i],nums[i])) {\n                k++;\n                if (k == s)\n                    return -1;\n                for (int j = max(i, q[k][0]); j <= q[k][1]; j++)\n                    dp[j].push_back(q[k][2]);\n            }\n        }\n        return k + 1;\n    }\n};","author":"Vansh_Bhardwaj","submissionId":"1575219167"},[]]},{"1211":[{"id":"1211","fileName":"1575219322.txt","sourceCode":"from math import gcd\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        n = len(nums)\n        dp = [1 for _ in range(n)]\n        masks = [ (1 << (target + 1)) - 1 for target in nums ]\n        \n        def all_satisfied():\n            for j in range(n):\n                if ((dp[j] >> nums[j]) & 1) == 0:\n                    return False\n            return True\n\n        if all_satisfied():\n            return 0\n    \n        for k, (l, r, v) in enumerate(queries, 1):\n            for j in range(l, r + 1):\n                dp[j] |= (dp[j] << v)\n                dp[j] &= masks[j]\n            if all_satisfied():\n                return k\n        return -1\n        \n        ","author":"Arya veer Singh Chauhan","submissionId":"1575219322"},[]]},{"1212":[{"id":"1212","fileName":"1575219497.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int ans = -1;\n        for(int i = 0 ; i < nums.size() ; i ++){\n            const int sz = nums[i] + 10;\n            vector<int>dp(sz,0);\n            dp[0] = 1;\n            int minK = 1e9;\n            if(nums[i] == 0) {\n                minK = 0;\n            }\n            for(int k = 0 ; k < q.size() ; k ++){\n                if(q[k][0] > i || q[k][1] < i) continue;\n                for(int j = sz - 1 ; j >= q[k][2] ; j --){\n                    dp[j] |= dp[j - q[k][2]];\n                }\n                if(dp[nums[i]]){\n                    minK = min(k + 1,minK);\n                    break;\n                }\n            }\n            if(!dp[nums[i]]) return -1;\n            ans = max(ans,minK);\n        }\n\n        return ans;\n    }\n};","author":"Mercer_2","submissionId":"1575219497"},[]]},{"1213":[{"id":"1213","fileName":"1575219478.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if sum(nums)==0:\n            return 0\n        x=[{0} for _ in range(len(nums))]\n        for i in range(len(queries)):\n            for j in range(queries[i][0],queries[i][1]+1):\n                if x[j]==True:\n                    continue\n                for num in list(x[j]):\n                    x[j].add(num+queries[i][2])\n                if nums[j] in x[j]:\n                    x[j]=True\n            if all(x[j]==True for j in range(len(nums))):\n                return i+1\n        return -1\n                    \n        ","author":"jiahandu","submissionId":"1575219478"},[]]},{"1214":[{"id":"1214","fileName":"1575219414.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        \n        def valid(memo, decVal):\n            curIndex = len(memo)\n            n = len(memo[0])\n            memo.append([False for _ in range(n)])\n            for j in range(n):\n                # If we don't include nums[i-1]\n                memo[curIndex][j] = memo[curIndex - 1][j]\n\n                # If we include nums[i-1]\n                if j - decVal >= 0:\n                    memo[curIndex][j] = memo[curIndex][j] or memo[curIndex - 1][j - decVal]\n            return memo[-1][-1]\n\n        \n        solved = 0\n        for num in nums:\n            if num == 0:\n                solved += 1\n                \n        if solved == len(nums):\n            return 0\n        \n        dp = []\n        for num in nums:\n            innerDP = [[False for _ in range(num + 1)]]\n            innerDP[0][0] = True  # Empty subset sums to 0\n            dp.append(innerDP)\n        \n        for i in range(len(queries)):\n            l, r, val = queries[i]\n            for index in range(l, r+1):\n                if nums[index] == 0:\n                    continue\n                if valid(dp[index], val):\n                    solved += 1\n                    nums[index] = 0\n                    if solved == len(nums):\n                        return i + 1\n        return -1\n        ","author":"lijustin111","submissionId":"1575219414"},[]]},{"1216":[{"id":"1216","fileName":"1575219619.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n\n        int n = nums.length;\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0)\n                continue;\n            int cur = Integer.MAX_VALUE;\n            boolean dp[] = new boolean[nums[i] + 1];\n            dp[0] = true;\n            for (int j = 0; j < queries.length; j++) {\n                if (i >= queries[j][0] && i <= queries[j][1]) {\n                    for (int k = nums[i]; k >= queries[j][2]; k--)\n                        dp[k] |= dp[k - queries[j][2]];\n                    if (dp[dp.length - 1]) {\n                        cur = j + 1;\n                        break;\n                    }\n                }\n            }\n            ans = Math.max(ans, cur);\n        }\n        return ans == Integer.MAX_VALUE ? -1 : ans;\n    }\n\n\n    private static void tr(Object... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n}","author":"bluesky999","submissionId":"1575219619"},[]]},{"1217":[{"id":"1217","fileName":"1575219551.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        ama=1\n        base=-ama\n        \n        ila=0\n        ama=1\n        arr = [[ila] * 1001 for _ in range(n)] \n        for i in range(n):\n            arr[i][ila] = ama \n        kodi = ama\n        for j in range(n):\n            if nums[j] != ila:\n                kodi = ila\n                break\n        if kodi == ama:\n            return ila\n        for nam in range(len(queries)):\n            minus,plus,val= queries[nam]\n            for ijk in range(minus, plus + ama):\n                temp = [ila] * 1001 \n                for mo in range(1001 - val):\n                    if arr[ijk][mo]:\n                        temp[mo + val] = ama\n                for keo in range(1001):\n                    arr[ijk][keo] = arr[ijk][keo] or temp[keo]           \n                for l in range(nums[ijk] + ama, 1001):\n                    arr[ijk][l] = ila        \n            kodi = ama\n            for j in range(n):\n                if not arr[j][nums[j]]:\n                    kodi = ila\n                    break   \n            if kodi == ama:\n                return nam + ama   \n        return base\n            ","author":"Sharavana kumar S","submissionId":"1575219551"},[]]},{"1218":[{"id":"1218","fileName":"1575219656.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        vector<int> earliest(n, -1);\n        \n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) {\n                earliest[i] = 0;\n                continue;\n            }\n            \n            vector<bool> dp(1001, false);\n            dp[nums[i]] = true;\n            for (int j = 0; j < q; j++) {\n                vector<bool> newDp = dp;\n                int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                bool inRange = (i >= l && i <= r);\n                if (inRange) {\n                    for (int v = 0; v <= 1000; v++) {\n                        if (!dp[v]) continue;\n                        if (v >= val) {\n                            newDp[v - val] = true;\n                        }\n                    }\n                }\n                dp = move(newDp);\n                if (dp[0]) {\n                    earliest[i] = j + 1;\n                    break;\n                }\n            }\n        }\n        \n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (earliest[i] == -1)\n                return -1;\n            ans = max(ans, earliest[i]);\n        }\n        return ans;\n    }\n};\n","author":"NEZYA","submissionId":"1575219656"},[]]},{"1219":[{"id":"1219","fileName":"1575219688.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        min_k_required = [0] * n  # For indices already 0, k = 0.\n        \n        for i in range(n):\n            A = nums[i]  # original value at index i\n            # If the element is already 0, no queries are needed.\n            if A == 0:\n                min_k_required[i] = 0\n                continue\n            \n            # Build a list of queries (as (global_index, v)) that affect index i.\n            queries_for_i = []\n            for k, (l, r, v) in enumerate(queries):\n                if l <= i <= r:\n                    queries_for_i.append((k, v))\n            \n            # If no query affects index i and A > 0, it's impossible.\n            if not queries_for_i:\n                return -1\n            \n            # Use DP to track reachable sums for index i.\n            reachable = {0}\n            earliest = None  # the minimal query count (k) at which A is reachable.\n            \n            for (k, v) in queries_for_i:\n                # Make a copy of the current reachable set; skipping is always allowed.\n                new_reachable = set(reachable)\n                for s in reachable:\n                    if s + v <= A:\n                        new_reachable.add(s + v)\n                reachable = new_reachable\n                \n                if A in reachable:\n                    earliest = k + 1  # queries are 0-indexed; we need count.\n                    break\n            \n            if earliest is None:\n                # For index i, it's not possible to achieve exactly A.\n                return -1\n            else:\n                min_k_required[i] = earliest\n\n        return max(min_k_required)\n\n\n","author":"Adittya Narayan","submissionId":"1575219688"},[]]},{"1220":[{"id":"1220","fileName":"1575219766.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        cat = defaultdict(list)\n\n        for j,q in enumerate(queries):\n            l,r,val = q\n            for k in range(l,r+1):\n                cat[k].append([-val,j])\n\n        #print(cat)\n\n        dp = {}\n\n        self.res = -1\n        self.cat = None\n        self.dp = {}\n        self.curr = None\n\n        def search(n,i):\n            n,i = int(n),int(i)\n            if i>=len(self.cat):\n                return 1e9\n            elif self.curr<=i:\n                return self.curr\n\n            res = 1e9\n\n            for j in range(i,len(self.cat)):\n                v,k = self.cat[j]\n                n2 = int(n+v)\n\n                if n2==0:\n                    res = min(res,k)\n                    continue\n                elif n2<0:\n                    continue\n                else:\n                    nextt = (n2,j+1)\n\n                    if nextt in self.dp:\n                        res0 = self.dp[nextt]\n                    else:\n                        res0 = search(n2,j+1)\n                    res = min(res,res0)\n\n            self.dp[(n,i)] = res\n            self.curr = min(self.curr,res)\n            return res\n                \n        \n        for i,n in enumerate(nums):\n            self.cat = cat[i]\n\n            if n==0:\n                continue\n            elif len(self.cat)==0 and n>0:\n                return -1 \n            self.dp = {}\n            self.curr = 1e9\n            res0 = search(n,0)\n\n            #print(i,n,res0)\n\n            if res0>=1000:\n                return -1\n            else:\n                self.res = max(self.res,res0)\n\n        return self.res+1\n        ","author":"forquant","submissionId":"1575219766"},[]]},{"814":[{"id":"814","fileName":"1575194870.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums, queries):\n        n = len(nums)\n        dp = [set([0]) for _ in range(n)]\n        if all(num == 0 for num in nums):\n            return 0\n\n        for k, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                new_values = {x + v for x in dp[j]}\n                dp[j].update(new_values)\n                dp[j] = {x for x in dp[j] if x <= nums[j]}\n            if all(nums[j] in dp[j] for j in range(n)):\n                return k + 1\n\n        return -1\n","author":"suhitha carolin","submissionId":"1575194870"},[{"id":"998","similarity":0.8666666666666667,"totOverlap":78,"longestOverlap":21},{"id":"814","similarity":0.8666666666666667,"totOverlap":78,"longestOverlap":35}]],"998":[{"id":"998","fileName":"1575206936.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums, queries):\n        n = len(nums)\n        dp = [set([0]) for _ in range(n)]\n\n        if all(x == 0 for x in nums):\n            return 0\n\n        for i, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                dp[j] |= {x + v for x in dp[j]}\n                dp[j] = {x for x in dp[j] if x <= nums[j]}\n\n            if all(nums[j] in dp[j] for j in range(n)):\n                return i + 1\n\n        return -1\n","author":"Rajiv Ratan","submissionId":"1575206936"},[{"id":"814","similarity":0.8666666666666667,"totOverlap":78,"longestOverlap":21}]],"1052":[{"id":"1052","fileName":"1575210785.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n=len(nums)\n        dp=[set([0]) for _ in range(n)]\n        if all(x==0 for x in nums):\n            return 0\n        for k,(l,r,v) in enumerate(queries):\n            for j in range(l,r+1):\n                shifted = {i+v for i in dp[j] if i+v<1001}\n                dp[j]|=shifted\n                dp[j]={x for x in dp[j] if x<=nums[j]}\n            if all(nums[j] in dp[j] for j in range(n)):\n                return k+1\n        return -1","author":"jii_xd","submissionId":"1575210785"},[{"id":"1052","similarity":0.865979381443299,"totOverlap":84,"longestOverlap":29}]],"1165":[{"id":"1165","fileName":"1575216908.txt","sourceCode":"class Solution:\n    def minZeroArray(self, array: List[int], queries: List[List[int]]) -> int:\n        l=len(array)\n        state=[set([0]) for _ in range(l)]\n        if all(value==0 for value in array):\n            return 0\n        for oi,(start,end,inc) in enumerate(queries):\n            for i in range(start,end+1):\n                ns={x+inc for x in state[i]}\n                state[i].update(ns)\n                state[i]={x for x in state[i] if x<=array[i]}\n\n            if all(array[i] in state[i] for i in range(l)):\n                    return oi+1\n        return -1\n        ","author":"Monish","submissionId":"1575216908"},[{"id":"1165","similarity":0.8736842105263158,"totOverlap":83,"longestOverlap":23}]],"1221":[{"id":"1221","fileName":"1575219717.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n=len(nums)\n        dp=[set([0]) for _ in range(n)]\n        if all(x==0 for x in nums):\n            return 0\n        for k,(l,r,v) in enumerate(queries):\n            for j in range(l,r+1):\n                s={x+v for x in dp[j] if x+v<1001}\n                dp[j]|=s\n                dp[j]={x for x in dp[j] if x<=nums[j]}\n            if all(nums[j] in dp[j] for j in range(n)):\n                return k+1\n        return -1","author":"Devi_Sanjana","submissionId":"1575219717"},[{"id":"1274","similarity":0.90625,"totOverlap":87,"longestOverlap":29},{"id":"1221","similarity":0.865979381443299,"totOverlap":84,"longestOverlap":29},{"id":"1274","similarity":0.8736842105263158,"totOverlap":83,"longestOverlap":23},{"id":"1165","similarity":0.8666666666666667,"totOverlap":78,"longestOverlap":35}]],"1274":[{"id":"1274","fileName":"1575222602.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        dp = [set([0]) for _ in range(n)]\n        \n        if all(num == 0 for num in nums):\n            return 0\n        \n        for k, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                new_dp = {x + v for x in dp[j] if x + v <= 1000}\n                dp[j].update(new_dp)\n                dp[j] = {x for x in dp[j] if x <= nums[j]}\n            \n            if all(nums[j] in dp[j] for j in range(n)):\n                return k + 1\n        \n        return -1\n        ","author":"Sahil Kumar Naik","submissionId":"1575222602"},[{"id":"1221","similarity":0.90625,"totOverlap":87,"longestOverlap":29}]]},{"1223":[{"id":"1223","fileName":"1575219827.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n        pair<vector<int>, vector<vector<int>>> a = {nums, q};\n        vector<bitset<1111>> dp(n);\n        int i = 0;\n        for (; i < n; i++) {\n            dp[i].reset();\n            dp[i].set(0, true);\n        }\n        int bz = 1;\n        i = 0 ;\n        while (i < n) {\n            if (nums[i]) {\n                bz = 0;\n                break;\n            }\n            i++;\n        }\n        if (bz)\n            return 0;\n        i = 0;\n        while (i < q.size()) {\n            for (int x = q[i][0]; x <= q[i][1]; x++) {\n                dp[x] = dp[x] | (dp[x] << q[i][2]);\n                int p = nums[x] + 1;\n                while (p <= 1000) {\n                    dp[x].reset(p);\n                    p++;\n                }\n            }\n            int aa = 1;\n            int z = 0;\n            while (z < n) {\n                if (!dp[z].test(nums[z])) {\n                    aa = 0;\n                    break;\n                }\n                z++;\n            }\n            if(aa)return i+1;\n            i++;\n        }\n        return -1;\n    }\n};","author":"deepankcod","submissionId":"1575219827"},[]]},{"1224":[{"id":"1224","fileName":"1575219776.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<bitset<1001>> dp(n);\n\n        for (int j = 0; j < n; j++) {\n            dp[j].set(0);\n        }\n\n        bool zeroFull = true;\n        for(int i : nums)\n            if(i!=0){\n                zeroFull = false;\n                break;\n            }\n        \n        if (zeroFull) return 0;\n\n        for (int k = 0; k < queries.size(); k++) {\n            int l = queries[k][0], r = queries[k][1], v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n                bitset<1001> shifted;\n                for (int i = 0; i < 1001 - v; i++) {\n                    if (dp[j][i]) {\n                        shifted.set(i + v);\n                    }\n                }\n                dp[j] |= shifted;\n\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp[j].reset(pos);\n                }\n            }\n\n            zeroFull = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j][nums[j]]) {\n                    zeroFull = false;\n                    break;\n                }\n            }\n\n            if (zeroFull) return k + 1;\n        }\n        return -1;\n    }\n};","author":"ABHAY SINGH PATEL","submissionId":"1575219776"},[]]},{"1225":[{"id":"1225","fileName":"1575219876.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        prefix = [[] for i in range(len(nums))]\n        for i, q in enumerate(queries):\n            l,r,v = q\n            for j in range(l,r+1):\n                prefix[j].append((i+1,v))\n\n\n        def koko(k):\n            for i in range(len(nums)):\n                s = []\n                for j in range(len(prefix[i])):\n                    if prefix[i][j][0] > k:\n                        break\n                    s.append(prefix[i][j][1])\n                if nums[i] == 0:\n                    continue\n                if sum(s) < nums[i]:\n                    return False\n\n                dp = [0] * (nums[i]+1)\n                dp[0] = True\n                for v in s:\n                    for x in range(nums[i],v-1,-1):\n                        if dp[x-v]: dp[x] = True\n                    if dp[nums[i]]:\n                        break\n                if not dp[nums[i]]:\n                    return False \n            return True\n\n        l,r = 0,len(queries)\n        res = -1\n        while l <= r:\n            m = (l + r)//2\n            if koko(m):\n                res = m\n                r = m-1\n            else:\n                l = m+1\n        return res","author":"biehenjia","submissionId":"1575219876"},[]]},{"1226":[{"id":"1226","fileName":"1575219899.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int> mn(nums.size(), -1);\n        for (int i=0; i<nums.size(); i++) {\n            if (nums[i]==0)\n                mn[i] = 0;\n        }\n        vector<vector<int>> dp(nums.size(), vector<int>(1001,0));\n        for (int i=0; i<queries.size(); i++) {\n            vector<vector<int>> tmp(nums.size(), vector<int>(1001,0));\n            for (int k=0; k<nums.size(); k++) {\n                if (i==0)\n                    tmp[k][0] = 1;\n                else {\n                    for (int j=0; j<1001; j++) {\n                        tmp[k][j] = dp[k][j];\n                    }\n                }\n            }\n            for (int k=queries[i][0]; k<=queries[i][1]; k++) {\n                if (i==0) {\n                    tmp[k][queries[i][2]] = 1;\n                }\n                else {\n                    for (int j=0; j<1001; j++) {\n                        if (j-queries[i][2]>=0 && dp[k][j-queries[i][2]])\n                            tmp[k][j] = 1;\n                    }\n                }\n            }\n            for (int k=0; k<nums.size(); k++) {\n                if (tmp[k][nums[k]] == 1) {\n                    // cout << i << \" \" << k << \" yes\" << endl; \n                    if (mn[k] == -1)\n                        mn[k] = i+1;\n                }\n            }\n            dp = tmp;\n        }\n        int ans = mn[0];\n        for (int i=0; i<mn.size(); i++) {\n            if (mn[i]==-1)\n                return -1;\n            ans = max(ans, mn[i]);\n        }\n        return ans;\n    }\n};","author":"drem357","submissionId":"1575219899"},[]]},{"1227":[{"id":"1227","fileName":"1575219862.txt","sourceCode":"#include <vector>\n#include <bitset>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        \n        // Check if a given prefix of queries (first k queries) can make nums a Zero Array.\n        auto canAchieve = [&](int k) -> bool {\n            for (int j = 0; j < n; j++) {\n                int target = nums[j];\n                // If no subtraction is needed, skip this index.\n                if (target == 0) continue;\n                \n                // dp[s] == true means we can obtain sum s using queries affecting index j.\n                bitset<1001> dp;\n                dp.reset();\n                dp.set(0, true);\n                \n                // Create a mask that keeps only sums up to 'target'\n                bitset<1001> mask;\n                mask.reset();\n                for (int s = 0; s <= target; s++) {\n                    mask.set(s, true);\n                }\n                \n                // Process the first k queries\n                for (int i = 0; i < k; i++) {\n                    int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n                    if(j >= l && j <= r) {\n                        dp |= (dp << val);\n                        dp &= mask; // Only keep sums up to target.\n                    }\n                }\n                // If we cannot exactly reach target, then prefix k fails.\n                if(!dp.test(target))\n                    return false;\n            }\n            return true;\n        };\n        \n        \n        int lo = 0, hi = m + 1; \n        while(lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            if(canAchieve(mid))\n                hi = mid;\n            else\n                lo = mid + 1;\n        }\n        return (lo == m + 1 ? -1 : lo);\n    }\n};\n","author":"Bhavik Joshi","submissionId":"1575219862"},[]]},{"1228":[{"id":"1228","fileName":"1575219987.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        int[][] values = new int[n][m];\n        int max = -1;\n\n        for (int j = 0; j < m; j++) {\n            for (int i = queries[j][0]; i <= queries[j][1]; i++) {\n                values[i][j] = queries[j][2];\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) {\n                continue;\n            }\n            int[] vals = values[i];\n            int index = findMinimumHighestIndex(vals, nums[i]);\n            if (index == -1) {\n                return -1;\n            }\n            if (index > max) {\n                max = index;\n            }\n        }\n        \n\n        return max + 1;\n    }\n\n    private int findMinimumHighestIndex(int[] values, int target) {\n        int n = values.length;\n\n        int[][] dp = new int[n + 1][target + 1];\n        for (int[] row : dp) {\n            Arrays.fill(row, Integer.MAX_VALUE);\n        }\n        dp[0][0] = -1;\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= target; j++) {\n                // out\n                dp[i][j] = dp[i - 1][j];\n                // in\n                if (j >= values[i - 1] && dp[i - 1][j - values[i - 1]] != Integer.MAX_VALUE) {\n                    dp[i][j] = Math.min(dp[i][j], i - 1);\n                }\n            }\n        }\n\n        int index = dp[n][target];\n        return index == Integer.MAX_VALUE ? -1 : index;\n    }\n}","author":"BryanBat","submissionId":"1575219987"},[]]},{"1229":[{"id":"1229","fileName":"1575220025.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        n = len(nums)\n        q = len(queries)\n\n        dp = [1] * n\n\n        masks = [(1 << (nums[j]+1))-1 for j in range(n)]\n\n        if all(x == 0 for x in nums):\n            return 0\n\n        for i in range(q):\n            l, r, v = queries[i]\n            for j in range(l,r+1):\n                dp[j] = (dp[j] | dp[j] << v) & masks[j]\n\n            if all((dp[j] >> nums[j]) & 1 for j in range(n)):\n                return i + 1\n\n        return -1","author":"Mojtaba Yousefi","submissionId":"1575220025"},[]]},{"1230":[{"id":"1230","fileName":"1575219976.txt","sourceCode":"\n\nclass Solution {\npublic:\n    bool chk(const vector<int>& a) {\n        for (int x : a)\n            if (x != 0)\n                return false;\n        return true;\n    }\n    \n    bool ss(int t, const vector<int>& c) {\n        vector<bool> dp(t + 1, false);\n        dp[0] = true;\n        for (int coin : c)\n            for (int s = t; s >= coin; s--)\n                if (dp[s - coin])\n                    dp[s] = true;\n        return dp[t];\n    }\n    \n    int minZeroArray(vector<int>& a, vector<vector<int>>& qu) {\n        vector<int> v = a;\n        if (chk(v))\n            return 0;\n        int n = v.size();\n        int m = qu.size();\n        for (int k = 1; k <= m; k++) {\n            bool all = true;\n            for (int i = 0; i < n; i++) {\n                vector<int> c;\n                for (int j = 0; j < k; j++)\n                    if (qu[j][0] <= i && i <= qu[j][1])\n                        c.push_back(qu[j][2]);\n                if (!ss(v[i], c)) {\n                    all = false;\n                    break;\n                }\n            }\n            if (all)\n                return k;\n        }\n        return -1;\n        \n    }\n};","author":"Prashasth23","submissionId":"1575219976"},[]]},{"1231":[{"id":"1231","fileName":"1575220172.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        non_zero = {}\n        for i, num in enumerate(nums):\n            if num == 0:\n                continue \n            non_zero[i] = set([num])\n        if len(non_zero) == 0:\n            return 0\n        for idx, query in enumerate(queries):\n            l, r, val = query\n            cp = dict(non_zero)\n            for i in non_zero.keys():\n                rem = False\n                if i < l or i > r:\n                    continue \n                new_set = set(non_zero[i])\n                for s in non_zero[i]:\n                    if s - val == 0:\n                        del cp[i]\n                        rem = True \n                        break \n                    new_set.add(s - val)\n                if len(cp) == 0:\n                    return idx + 1\n                if not rem:\n                    cp[i] = new_set\n            non_zero = dict(cp)\n        return -1","author":"Mina Refaat","submissionId":"1575220172"},[]]},{"1232":[{"id":"1232","fileName":"1575220278.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        dp=[]\n        for _ in range(len(nums)):\n            dp.append({0})\n        f=1\n        for i in nums:\n            if(i!=0):\n                f=0\n        if(f==1):\n            return 0\n        for x,(a,b,c) in enumerate(queries):\n            for i in range(a,b+1):\n                s=set()\n                for j in dp[i]:\n                    s.add(j)\n                    if(j+c <= nums[i]):\n                        s.add(j+c)\n                dp[i]=s\n            f=1\n            for i in range(len(nums)):\n                if(nums[i] not in dp[i]):\n                    f=0\n            if(f==1):\n                return x+1\n        return -1\n","author":"shivabalajipatel","submissionId":"1575220278"},[]]},{"1233":[{"id":"1233","fileName":"1575220392.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size();\n        vector<vector<pair<int, int>>> s(n);\n    \n        for (int i = 0; i < q.size(); ++i) {\n            int l = q[i][0], r = q[i][1], v = q[i][2];\n            for (int j = l; j <= r; ++j) s[j].emplace_back(v, i);\n        }\n    \n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            int t = a[i];\n            if (t == 0) continue;\n    \n            auto& l = s[i];\n            if (l.empty()) return -1;\n    \n            vector<bool> dp(t + 1, false);\n            dp[0] = true;\n            int idx = -1, sum = 0;\n    \n            for (int j = 0; j < l.size(); ++j) {\n                int v = l[j].first, o = l[j].second;\n                sum += v;\n                for (int k = t; k >= v; --k) if (dp[k - v]) dp[k] = true;\n                if (sum >= t && dp[t]) { idx = o; break; }\n            }\n    \n            if (idx == -1) return -1;\n            ans = max(ans, idx + 1);\n        }\n\n        return ans;\n    }\n};","author":"Sachin Kumar","submissionId":"1575220392"},[]]},{"1234":[{"id":"1234","fileName":"1575220241.txt","sourceCode":"  // --------------- Templates -------------- //\n  \n  /* clang-format off */\n  \n  /*\n      ___      _                ____ \n    /   |    (_)___ ___  __   / __ )\n   / /| |   / / __ `/ / / /  / __  |\n  / ___ |  / / /_/ / /_/ /  / /_/ / \n  /_/  |_|_/ /__,_/__, /  /_____/  \n        /___/      /____/            \n  */\n  \n  #include <bits/stdc++.h>\n  #pragma GCC optimize(\"O3,unroll-loops\")\n  #pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\n  using namespace std;\n  \n  // Data Types\n  #define ll long long\n  #define ld long double\n  #define ull unsigned long long\n  #define ui unsigned int\n  #define str string\n  #define ch char\n  #define db double\n  #define fl float\n  \n  // Containers\n  #define v vector\n  #define vi vector<int>\n  #define vl vector<long long>\n  #define vd vector<double>\n  #define vs vector<string>\n  #define vc vector<char>\n  #define vb vector<bool>\n  #define vivi vector<vector<int>>\n  #define vivc vector<vector<char>>\n  #define vivs vector<vector<string>>\n  #define vivl vector<vector<long long>>\n  #define vivd vector<vector<double>>\n  #define vvb vector<vector<bool>>\n  #define pii pair<int, int>\n  #define pll pair<long long, long long>\n  #define pic pair<int, char>\n  #define pci pair<char, int>\n  #define vpii vector<pair<int,int>>\n  #define umii unordered_map<int,int>\n  #define umsi unordered_map<string, int>\n  #define umci unordered_map<char, int>\n  #define usi unordered_set<int>\n  #define uss unordered_set<string>\n  #define usc unordered_set<char>\n  #define usl unordered_set<long long>\n  #define usd unordered_set<double>\n  #define pq priority_queue\n  #define umset unordered_multiset\n  #define mset multiset\n  \n  // Methods\n  #define pb push_back\n  #define pp pop_back\n  #define puf push_front\n  #define pof pop_front\n  #define fr front\n  #define bk back\n  #define in insert\n  #define ff first\n  #define ss second\n  #define burn erase\n  #define mp make_pair\n  #define elif else if\n  \n  // Macros\n  #define fast_io ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n  #define all(x) x.begin(), x.end()\n  #define rall(x) x.rbegin(), x.rend()\n  #define sorta(x) sort(all(x))\n  #define sortd(x) sort(rall(x))\n  #define rev(x) reverse(all(x))\n  #define test int tc = 1; cin >> tc; while(tc--)\n  #define maxi(x) *max_element(all(x))\n  #define mini(x) *min_element(all(x))\n  #define pq priority_queue\n  \n  // Constants\n  #define MOD 1000000007\n  #define PI 3.1415926535897932384626433832795\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vvb dp(n);\n        for (int j = 0; j < n; j++) {\n            dp[j].resize(nums[j] + 1, false);\n            dp[j][0] = true;\n        }\n        int q = queries.size();\n        for (int i = 0; i <= q; i++) {\n            bool ok = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j][nums[j]]) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) return i;\n                if (i < q) {\n                int l = queries[i][0];\n                int r = queries[i][1];\n                int val = queries[i][2];\n                for (int j = l; j <= r && j < n; j++) {\n                    for (int s = nums[j]-val; s >= 0; s--) {\n                        if (dp[j][s])\n                            dp[j][s + val] = true;\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n};","author":"Ajay B","submissionId":"1575220241"},[]]},{"1235":[{"id":"1235","fileName":"1575220422.txt","sourceCode":"class Solution {\nprivate:\n    bool helper(vector<vector<int>>& dp, int n, int ind, int sum,\n                vector<int>& arr) {\n        if (sum == 0) {\n            return true;\n        }\n        if (ind == -1) {\n            return false;\n        }\n        if (dp[ind][sum] != -1) {\n            return dp[ind][sum];\n        }\n        int notpick = helper(dp, n, ind - 1, sum, arr);\n        int pick = 0;\n        if (arr[ind] <= sum) {\n            pick = helper(dp, n, ind - 1, sum - arr[ind], arr);\n        }\n        return dp[ind][sum] = pick || notpick;\n    }\n    bool check0(vector<int>& arr, int sum, int n) {\n        vector<vector<int>> dp(n, vector<int>(sum + 1, -1));\n        sort(arr.begin(),arr.end());\n        return helper(dp, n, n - 1, sum, arr);\n    }\n    bool bs(vector<int>& nums, vector<vector<int>>& q, int sz, int n) {\n        multiset<int> st;\n        vector<vector<int>> mark(n + 1);\n        for (int i = 0; i <= sz; i++) {\n            int l = q[i][0];\n            int r = q[i][1];\n            int val = q[i][2];\n            mark[l].push_back(val);\n            mark[r + 1].push_back(val*(-1));\n        }\n        \n        for (int i = 0; i < n; i++) {\n            int msz = mark[i].size();\n            for (int j = 0; j < msz; j++) {\n                if (mark[i][j] > 0) {\n                    st.insert(mark[i][j]);\n                } else {\n                    auto it = st.find(abs(mark[i][j]));\n                    if (it != st.end()) {\n                        st.erase(it);\n                    }\n                    \n                }\n            }\n            vector<int> arr;\n            for (auto it : st) {\n                arr.push_back(it);\n            }\n            if (nums[i] == 0) {\n                continue;\n            }\n            if (arr.empty()) {\n                return false;\n            }\n            if (!check0(arr, nums[i], arr.size())) {\n                return false;\n            }\n        }\n        return true;\n    }\n\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n        bool found=false;\n        for(int i=0;i<n;i++){\n            if(nums[i]!=0){\n                found=true;\n                break;\n            }\n        }\n        if(!found){\n            return 0;\n        }\n        int m = q.size();\n        int low = 0;\n        int high = m - 1;\n        int ans = -1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (bs(nums, q, mid, n)) {\n                ans = mid + 1;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"Devansh Shankhdhar","submissionId":"1575220422"},[]]},{"1236":[{"id":"1236","fileName":"1575220640.txt","sourceCode":"class Solution(object):\n    def minZeroArray(self, nums, queries):\n        n = len(nums)\n        dp = [set() for _ in range(n)]\n        \n        for j in range(n):\n            dp[j].add(0)\n\n        zeros = all(num == 0 for num in nums)\n        if zeros:\n            return 0\n\n        for k in range(len(queries)):\n            l, r, v = queries[k]\n\n            for j in range(l, r + 1):\n                temp = dp[j].copy()\n                temp.update({x + v for x in dp[j] if x + v < 1001})\n                dp[j] = temp\n                dp[j] = {x for x in dp[j] if x <= nums[j]}\n\n            all_zero = all(nums[j] in dp[j] for j in range(n))\n            if all_zero:\n                return k + 1\n\n        return -1","author":"ShashankVinnakota","submissionId":"1575220640"},[]]},{"1237":[{"id":"1237","fileName":"1575220609.txt","sourceCode":"class Solution {\n   public int minZeroArray(int[] nums, int[][] queries) {\n        \n    \tint n = nums.length;\n    \t\n    \tArrayList<int[]>[] lst = new ArrayList[n];\n    \t\n    \tfor(int i=0;i<n;i++){\n    \t\tlst[i] = new ArrayList<>();\n    \t}\n    \t\n    \tint qnum= 0;\n    \tfor(int q[] : queries){\n    \t\t\n    \t\tqnum++;\n    \t\tint l = q[0];\n    \t\tint r = q[1];\n    \t\tint val = q[2];\n    \t\t\n\t\t\tint x[] = {val,qnum};\n    \t\tfor(int i=l;i<=r;i++){    \t\t\t\n    \t\t\tlst[i].add(x);    \t\t\t\n    \t\t}\n    \t\t\n    \t}\n    \t\n    \tint res[] = new int[n];\n    \tArrays.fill(res, 0);\n    \t\n    \tfor(int i=0;i<n;i++){\n    \t\t\n    \t\tif(nums[i]==0){\n    \t\t\tres[i]=0;\n    \t\t\tcontinue;\n    \t\t}\n    \t\t\n    \t\t\n    \t\tint minq = getMin(nums[i],lst[i]);\n    \t\t\n    \t\tif(minq==-1)\n    \t\t\treturn -1;\n    \t\t\n    \t\tres[i] = minq;\n    \t\t\n    \t}\n    \t\n    \tint result = Arrays.stream(res).max().getAsInt();\n    \t\n    \treturn result;\n    }\n\t\n\t\n    private int getMin(int sum, ArrayList<int[]> lst) {\n    \t\n       int N = lst.size() ;\n       boolean ar[]=new boolean[sum+1];\n\n        ar[0]=true;        \n        for(int i=0;i<N;i++){\n        \t\n        \tint start  = lst.get(i)[0];\n        \tint qnum = lst.get(i)[1];\n        \t\n            for(int j=sum;j>=start;j--){        \n                ar[j] = ar[j]  |ar[j-start];        \n            }\n            \n            if(ar[sum]) return qnum;\n                   \n        }\n        \n        return -1;\n\t}\n\n\n}","author":"iamcodebug","submissionId":"1575220609"},[]]},{"1239":[{"id":"1239","fileName":"1575220666.txt","sourceCode":"class Solution {\npublic:\n    int minIndexCal(int target, const vector<pair<int, int>>& queries) {\n        if (target == 0)\n            return 0;\n    \n        const int INF = 1e9;\n        vector<int> dp(target + 1, INF);\n        dp[0] = 0;\n    \n        for (const auto& [queryIdx, weight] : queries) {\n            for (int s = target - weight; s >= 0; s--) {\n                if (dp[s] != INF) {\n                    dp[s + weight] = \n                        min(dp[s + weight], queryIdx + 1);\n                }\n            }\n        }\n        return (dp[target] == INF ? -1 : dp[target]);\n    }\n\n    int minZeroArray(vector<int>& targets, vector<vector<int>>& queries) {\n        int n = targets.size();\n        vector<vector<pair<int, int>>> weights(n);\n        for(int j=0; j<queries.size(); j++) {\n            int l = queries[j][0];\n            int r = queries[j][1];\n            int w = queries[j][2];\n            for(int i = l; i <= r; i++)\n                weights[i].push_back({j, w});\n        }\n        \n        int minIdex = 0;\n        for(int i=0; i<n; i++) {\n            int minIdxTarget = minIndexCal(targets[i], weights[i]);\n            if(minIdxTarget == -1)\n                return -1;\n            minIdex = max(minIdex, minIdxTarget);\n        }\n        return minIdex;\n    }\n};","author":"Traveler","submissionId":"1575220666"},[]]},{"1240":[{"id":"1240","fileName":"1575220679.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& b) {\n        int n = a.size();\n        unordered_map<int, vector<bool>> memo;\n\n        for (int i = 0; i < n; i++) {\n            memo[i] = vector<bool>(1001, false);\n            memo[i][0] = true;\n        }\n\n        bool allZero = true;\n        for (int i = 0; i < n; i++) {\n            if (a[i] != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) return 0;\n\n        for (int idx = 0; idx < b.size(); idx++) {\n            int l = b[idx][0];\n            int r = b[idx][1];\n            int v = b[idx][2];\n\n            for (int j = l; j <= r; j++) {\n                vector<bool> temp = memo[j];\n                for (int pos = 1000 - v; pos >= 0; pos--) {\n                    if (memo[j][pos]) {\n                        temp[pos + v] = true;\n                    }\n                }\n                memo[j] = temp;\n                for (int pos = a[j] + 1; pos < 1001; pos++) {\n                    memo[j][pos] = false;\n                }\n            }\n\n            bool allReached = true;\n            for (int i = 0; i < n; i++) {\n                if (!memo[i][a[i]]) {\n                    allReached = false;\n                    break;\n                }\n            }\n            if (allReached) return idx + 1;\n        }\n        return -1;\n    }\n};\n","author":"Saksham Sapra","submissionId":"1575220679"},[]]},{"1241":[{"id":"1241","fileName":"1575220763.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        if (isZeroArray(nums)) {\n            return 0;\n        }\n        int low = 1;\n        int high = queries.length;\n        int result = -1;\n        while (low <= high) {\n            int middle = low + (high - low) / 2;\n            if (isFeasible(middle, nums, queries)) {\n                result = middle;\n                high = middle - 1;\n            } else {\n                low = middle + 1;\n            }\n        }\n        return result;\n    }\n    public boolean isFeasible(int k, int[] nums, int[][] queries) {\n        for (int i = 0; i < nums.length; i++) {\n            int target = nums[i];\n            if (target == 0) {\n                continue;\n            }\n            boolean[] dp = new boolean[target + 1];\n            dp[0] = true;\n            for (int j = 0; j < k; j++) {\n                if (queries[j][0] <= i && i <= queries[j][1]) {\n                    int v = queries[j][2];\n                    for (int t = target; t >= v; t--) {\n                        if (dp[t - v]) {\n                            dp[t] = true;\n                        }\n                    }\n                }\n            }\n            if (!dp[target]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    public boolean isZeroArray(int[] nums) {\n        for (int num : nums) {\n            if (num != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}","author":"solved3","submissionId":"1575220763"},[]]},{"1242":[{"id":"1242","fileName":"1575220733.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        List<int[]>[] numOperations=new ArrayList[nums.length];\n        for(int i=0;i<nums.length;i++){\n            numOperations[i]=new ArrayList<>();\n        } \n        for(int i=0;i<queries.length;i++){\n            for(int k=queries[i][0];k<=queries[i][1];k++){\n                numOperations[k].add(new int[]{queries[i][2],i});\n            }\n        }\n        int ans=-1;\n        for(int i=0;i<nums.length;i++){\n            boolean[] myMap=new boolean[nums[i]+1];\n            myMap[nums[i]]=true;\n            if(nums[i]==0)continue;\n            int curAns=0;\n            for(int k=0;k<numOperations[i].size();k++){\n                for(int j=1;j<=nums[i];j++){\n                    if(myMap[j]==false)continue;\n                    if(j<numOperations[i].get(k)[0])continue; \n                    if(j==numOperations[i].get(k)[0]){\n                        myMap[0]=true;\n                        curAns=numOperations[i].get(k)[1];\n                        break;\n                    }\n                    myMap[j-numOperations[i].get(k)[0]]=true;\n                } \n                if(myMap[0])break;\n            } \n            if(myMap[0]==false){\n                return -1; \n            }else{\n                ans=Math.max(ans,curAns);\n            }\n        }\n        return ans+1;\n    }\n}\n","author":"OAACKY","submissionId":"1575220733"},[]]},{"1243":[{"id":"1243","fileName":"1575220764.txt","sourceCode":"class Solution {\npublic:\n    int helper2(int i, int sum, int index, vector<vector<int>>& queries, vector<vector<int>>& dp){\n        int n = queries.size();\n\n        if(sum == 0){\n            return i;\n        }\n        else if(i == n){\n            return INT_MAX;\n        }\n\n        if(dp[i][sum] != -1){\n            return dp[i][sum];\n        }\n\n        int ans1 = helper2(i+1, sum, index, queries, dp);\n        int ans2 = INT_MAX;\n\n        auto query = queries[i];\n        int l = query[0];\n        int r = query[1];\n        int val = query[2];\n\n        if(index >= l && index <= r && sum >= val){\n            ans2 = helper2(i+1, sum - val, index, queries, dp);\n        }\n\n        return dp[i][sum] = min(ans1, ans2);\n    }\n\n    int helper(int index, int num, vector<vector<int>>& queries){\n        vector<vector<int>> dp(queries.size(), vector<int>(num + 1, -1));\n\n        int ans = helper2(0, num, index, queries, dp);\n\n        return ans == INT_MAX ? -1: ans;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n\n        int maxK = -1;\n\n        for(int i = 0; i < n; i++){\n            int ans = helper(i, nums[i], queries);\n\n            if(ans == -1) return -1;\n\n            maxK = max(maxK, ans);\n            \n        }\n\n        return maxK;\n    }\n};","author":"gandhisamay200","submissionId":"1575220764"},[]]},{"1244":[{"id":"1244","fileName":"1575220840.txt","sourceCode":"class Solution {\npublic:\n    int knapsack (vector <int> &v, int tgt) {\n        int q = v.size();\n        vector <vector <bool>> dp(q, vector <bool> (tgt + 1));\n        dp[0][0] = 1;\n        for (int j = 1; j <= tgt; j ++) {\n            if (v[0] == j) dp[0][j] = 1;\n            else dp[0][j] = 0;\n        }\n        if (dp[0][tgt]) return 1;\n        for (int i = 1; i < q; i ++) {\n            for (int j = 0; j <= tgt; j ++) {\n                dp[i][j] = dp[i - 1][j] | (j >= v[i] ? dp[i - 1][j - v[i]] : 0);\n            }\n            if (dp[i][tgt]) return i + 1;\n        }\n        return q + 1;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size(), ans = 0;\n        for (int i = 0; i < n; i ++) {\n            int tgt = nums[i];\n            if (tgt == 0) continue;\n            vector <int> v(q);\n            for (int j = 0; j < q; j ++) {\n                if (i >= queries[j][0] && i <= queries[j][1]) {\n                    v[j] = queries[j][2];\n                }\n                else {\n                    v[j] = 0;\n                }\n            }\n            ans = max(ans, knapsack(v, tgt));\n            if (ans > q) return -1;\n        }\n        return ans;\n    }\n};","author":"forasssk","submissionId":"1575220840"},[]]},{"1245":[{"id":"1245","fileName":"1575221145.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if all(nums[i] == 0 for i in range(len(nums))): return 0\n        sett = [set([0]) for _ in range(len(nums))]\n        res = [-1] * len(nums)\n        for i in range(len(queries)):\n            l = queries[i][0]\n            r = queries[i][1]\n            v = queries[i][2]\n            for j in range(l, r + 1):\n                if res[j] != -1: continue\n                tmp = set()\n                for n in sett[j]:\n                   tmp.add(n + v)    \n                sett[j] = tmp | sett[j]\n            for k in range(len(nums)):\n                if nums[k] in sett[k]:\n                    res[k] = 1\n            if all(res[j] != -1 for j in range(len(nums))):\n                return i + 1      \n        return -1\n                ","author":"yao","submissionId":"1575221145"},[]]},{"1246":[{"id":"1246","fileName":"1575220770.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] values, int[][] operations) \n    {\n        int size = values.length;\n        BitSet[] bitSets = initializeBitSets(size);\n        \n        if(areAllZeros(values)) return 0;\n\n        for(int index=0; index<operations.length;index++) \n        {\n            applyOperation(bitSets, values, operations[index]);\n            if(allTargetsMet(bitSets, values)) \n            {\n                return index + 1;\n            }\n        }\n        return -1;\n    }\n    \n    private BitSet[] initializeBitSets(int size) \n    {\n        BitSet[] bitSets = new BitSet[size];\n        for(int i=0;i<size;i++) \n        {\n            bitSets[i] = new BitSet(1001);\n            bitSets[i].set(0, true);\n        }\n        return bitSets;\n    }\n\n    private boolean areAllZeros(int[] values) {\n        for(int value : values) {\n            if (value != 0) return false;\n        }\n        return true;\n    }\n\n   \n    private void applyOperation(BitSet[] bitSets, int[] values, int[] operation) {\n        int start = operation[0], end = operation[1], increment = operation[2];\n\n        for(int i=start;i<=end;i++) \n        {\n            BitSet shiftedSet = shiftLeft(bitSets[i], increment);\n            bitSets[i].or(shiftedSet);\n            limitBitSet(bitSets[i], values[i]);\n        }\n    }\n\n    \n    private BitSet shiftLeft(BitSet bitSet, int shift) \n    {\n        BitSet shiftedSet = new BitSet(1001);\n        for(int i=0;i+shift<1001;i++) \n        {\n            if(bitSet.get(i)) \n            {\n                shiftedSet.set(i + shift);\n            }\n        }\n        return shiftedSet;\n    }\n\n    \n    private void limitBitSet(BitSet bitSet, int maxLimit) \n    {\n        for(int pos=maxLimit+1; pos<1001;pos++) \n        {\n            bitSet.clear(pos);\n        }\n    }\n\n    \n    private boolean allTargetsMet(BitSet[] bitSets, int[] values) \n    {\n        for(int i=0;i<values.length;i++) \n        {\n            if(!bitSets[i].get(values[i])) \n            {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n","author":"Atharva Hon","submissionId":"1575220770"},[]]},{"1247":[{"id":"1247","fileName":"1575220902.txt","sourceCode":"class Solution {\npublic:\n    bool form(vector<int>& h, int v, int r){\n        for(int i = 1001; i>=0; i--){\n            if(i-v>=0){\n                if(h[i-v]){\n                    h[i] = 1;\n                    if(i==r) return true;\n                }\n            }\n            else break;\n        }\n        return false;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(); \n        vector<vector<int>> m(n, vector<int>(1002, 0));\n        for(int i = 0; i<n; i++) m[i][0] = 1;\n        int formed = 0;\n        vector<int> done(n, 0);\n        for(int i = 0; i<n; i++) if(nums[i]==0) {done[i] = 1; formed++;};\n        if(formed==n) return 0;\n        for(int j = 0; j<queries.size(); j++){\n            auto l = queries[j][0]; \n            auto r = queries[j][1]; \n            auto v = queries[j][2]; \n            for(int i = l; i<=r; i++){\n                if(done[i]) continue;\n                auto can = form(m[i], v, nums[i]);\n                if(can){\n                    done[i] = 1;\n                    formed++;\n                    if(formed==n) return j+1;\n                }\n            }\n        }\n        return -1;\n    }\n};","author":"rranjik","submissionId":"1575220902"},[]]},{"1248":[{"id":"1248","fileName":"1575220905.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        if all(num == 0 for num in nums):\n            return 0\n        ops_per_index = [[] for _ in range(n)]\n        for idx, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                ops_per_index[i].append((idx, val))\n        low, high, answer = 1, len(queries), -1\n        while low <= high:\n            mid = (low + high) // 2\n            if self.canTransformToZero(nums, ops_per_index, mid):\n                answer = mid\n                high = mid - 1\n            else:\n                low = mid + 1  \n        return answer\n    def canTransformToZero(self, nums: List[int], ops_per_index: List[List[tuple]], k: int) -> bool:\n        for i in range(len(nums)):\n            target = nums[i]\n            dp = [False] * (target + 1)\n            dp[0] = True\n            for op_idx, val in ops_per_index[i]:\n                if op_idx < k:\n                    for s in range(target, val - 1, -1):\n                        if dp[s - val]:\n                            dp[s] = True\n            if not dp[target]:\n                return False\n        return True\n","author":"Shri Varshini","submissionId":"1575220905"},[]]},{"1249":[{"id":"1249","fileName":"1575221381.txt","sourceCode":"class Solution {\npublic:\n    \n    bool coinChange(vector<int>& coins,int amount,int index,\n                    vector<vector<bool>>& dp){\n        if(amount == 0){\n            return true;\n        }\n        if(index == coins.size() || amount<0){\n            return false;\n        }\n\n        if(dp[index][amount] != 0){\n            return dp[index][amount];\n        }\n        return (coinChange(coins,amount,index+1,dp) || \n            coinChange(coins,amount-coins[index],index+1,dp));\n    }\n\n    bool possible(vector<int>& nums, \n                vector<vector<int>>& queries,int limit){\n        \n        int n = nums.size();\n        int q = queries.size();\n        vector<vector<int>> range(n);\n        for(int i = 0; i<limit; i++){\n            int l = queries[i][0];\n            int r = queries[i][1];\n            for(int j = l; j<=r; j++){\n                range[j].push_back(queries[i][2]);\n            }\n        }\n\n          for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            if (target != 0 && range[i].empty()) return false;\n\n        map<int, int> dp;\n        dp[0] = 1; \n        for (int v : range[i]) {\n            map<int, int> new_dp = dp;\n            for (auto& [sum, _] : dp) {\n                int new_sum = sum + v;\n                if (new_sum <= target) {\n                    new_dp[new_sum] = 1;\n                }\n            }\n            dp = new_dp;\n        }\n       if (dp.find(target) == dp.end()) return false;\n    }\n\n    return true;\n    }\n\nbool bs(vector<int>& nums, vector<vector<bool>>& rec,int limit){\n    int n = nums.size();\n    for(int i = 0; i<n; i++){\n        if(rec[i][limit]==false){\n            return false;\n        }\n    }\n    return true;\n    \n     }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        int l = 0;\n        int h = queries.size();\n        \n        int ans = -1;\n        while(l<=h){\n            int m = l + (h-l)/2;\n            if(possible(nums,queries,m)){\n                ans = m;\n                h=m-1;\n            } else {\n                l=m+1;\n            }\n        }\n\n        return ans;\n    }\n};","author":"Harshit","submissionId":"1575221381"},[]]},{"1250":[{"id":"1250","fileName":"1575221417.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<bool>> dp(n, vector<bool>(1001, false));\n        for (int i = 0; i < n; i++) dp[i][0] = true;\n        bool flag = true;\n        for(int i=0;i<n;i++){\n            if(nums[i]!=0) flag = false;\n        }\n        if(flag){\n            return 0;\n        }\n        for (int k = 0; k < queries.size(); k++) {\n            int l = queries[k][0], r = queries[k][1], v = queries[k][2];\n            for (int i = l; i <= r; i++) {\n                vector<bool> curr = dp[i]; \n                for (int s = 1000 - v; s >= 0; s--) { \n                    if (dp[i][s]) curr[s + v] = true;\n                }\n                \n                dp[i] = curr; \n            }\n\n            bool flag = true;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i][nums[i]]) {\n                    flag = false;\n                    break;\n                }\n            }\n\n            if (flag) return k + 1;\n        }\n\n        return -1;\n    }\n};","author":"Sarvagya_Gupta73","submissionId":"1575221417"},[]]},{"1251":[{"id":"1251","fileName":"1575221485.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        boolean flag = true;\n        for (int ele : nums) {\n            if (ele != 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) return 0;\n        \n        int left = 0, right = queries.length - 1, ret = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (helper(mid, nums, queries)) {\n                ret = mid + 1;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ret;\n    }\n    \n    private boolean helper(int k, int[] nums, int[][] queries) {\n        int n = nums.length;\n        List<Integer>[] list = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            list[i] = new ArrayList<>();\n        }\n        for (int i = 0; i <= k; i++) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                list[j].add(val);\n            }\n        }\n       \n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            if (target == 0) continue;\n            boolean[] dp = new boolean[target + 1];\n            dp[0] = true;\n            for (int v : list[i]) {\n                for (int s = target; s >= v; s--) {\n                    if (dp[s - v]) {\n                        dp[s] = true;\n                    }\n                }\n            }\n            if (!dp[target]) return false;\n        }\n        return true;\n    }\n}\n","author":"Naveen Chhipa","submissionId":"1575221485"},[]]},{"1252":[{"id":"1252","fileName":"1575221586.txt","sourceCode":"class Solution {\npublic:\n    // bool isPossible(int m, auto &nums, auto &queries) {\n    //     // cout << \" processing m \" << m << endl;\n    //     int n = nums.size();\n    //     vector<int> counts(n+2,0);\n    //     for(int i = 0 ; i <= m ; i++) {\n    //         counts[queries[i][0]]+= queries[i][2];\n    //         counts[queries[i][1] + 1] -= queries[i][2];\n    //     }\n    //     int cur = 0;\n    //     for(int i = 0 ; i < (int)nums.size() ; i++) {\n    //         cur += counts[i];\n    //         if(cur < nums[i]) return false;\n    //     }\n    //     return true;\n    // }\n    \n    int getAns(int ind, int val, auto &queries) {\n        vector<int> dp(val + 50 , 0);\n        dp[0] = 1;\n        if(val == 0) return 0;\n        // cout << \" processing ind \" << ind << \" val \" << val << endl;\n        for(int i = 0 ; i < (int) (queries.size()) ; i++) {\n            if(queries[i][0] > ind || queries[i][1] < ind) continue;\n            for(int j = val + 20 ; j >= 1 ; j--) {\n                if(j-queries[i][2] >= 0 && dp[j-queries[i][2]]) {\n                    dp[j] = 1;\n                }\n            }\n            \n            if(dp[val]) {\n                return i+1;\n            }\n        }\n        return 1e9;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n//         int sum = 0;\n//         for(auto &x: nums) sum += x;\n//         if(sum == 0) return 0;\n        \n//         int l = 0, r = queries.size();\n        \n//         while(l < r) {\n//             int m = (l + r) / 2;\n//             if(isPossible(m,nums, queries)) {\n//                 r = m;\n//             } else {\n//                 l = m+1;\n//             }\n//         }\n//         if(l == (int)queries.size()) {\n//             return -1;\n//         }\n//         return l + 1;\n        int ans = 0;\n        for(int i = 0; i < (int)nums.size() ; i++) {\n            ans = max(ans, getAns(i,nums[i], queries));\n            if(ans == 1e9) {\n                return -1;\n            }\n        }\n        \n        return ans;\n    }\n};\n\n/*\n\n[2]\n[[0,0,6],[0,0,2],[0,0,9],[0,0,5],[0,0,10]]\n\n*/","author":"Neer N Patel","submissionId":"1575221586"},[]]},{"1253":[{"id":"1253","fileName":"1575221424.txt","sourceCode":"class Solution {\npublic:\n\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        map<int,vector<pair<int,int>>> mp;\n        for(int i=0;i<queries.size();i++){\n            int l=queries[i][0];\n            int h=queries[i][1];\n            for(int j=l;j<=h;j++){\n                mp[j].push_back({queries[i][2],i});\n            }\n        }\n        int k=0;\n        for(int i=0;i<nums.size();i++){\n            if(nums[i]!=0 && mp.find(i)==mp.end()){\n                return -1;\n            }\n        }\n        for(auto &item:mp){\n            int target=nums[item.first];\n            if(target==0){\n                continue;\n            }\n            set<int> s;\n            bool flag=true;\n            for(int j=0;j<item.second.size();j++){\n                vector<int> temp;\n                for(auto &item2:s){\n                    int tempp1=item2;\n                    int tempp2=item.second[j].first;\n                    temp.push_back(tempp1+tempp2);\n                }\n                temp.push_back(item.second[j].first);\n                for(auto &it:temp){\n                    s.insert(it);\n                }\n                if(s.count(target)>0){\n                    k=max(k,item.second[j].second+1);\n                    flag=false;\n                    break;\n                }\n            }\n            if(flag){\n                k=INT_MAX;\n            }\n            \n        }\n        if(k==INT_MAX){\n            return -1;\n        }\n        else{\n            return k;\n        }\n    }\n};","author":"CHIRAG SHARMA","submissionId":"1575221424"},[]]},{"1254":[{"id":"1254","fileName":"1575221428.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        data = []\n        for num in nums:\n            curr_set = set()\n            curr_set.add(num)\n            data.append(curr_set)\n\n        # print(data)\n        k = 0\n        for query in queries:\n            if self.checkZeroArray(data):\n                return k\n            l = query[0]\n            r = query[1]\n            v = query[2]\n            for i in range(l, r+1):\n                curr_set = data[i]\n                new_set = curr_set.copy()\n                for val in curr_set:\n                    new_set.add(val - v)\n                data[i] = new_set\n            k += 1\n    \n        return k if self.checkZeroArray(data) else -1\n\n    def checkZeroArray(self, data: List) -> bool:\n        for d_set in data:\n            if 0 not in d_set:\n                return False\n        return True\n    ","author":"MIB","submissionId":"1575221428"},[]]},{"1255":[{"id":"1255","fileName":"1575221737.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<unordered_set<int>> dp(n);\n\n        // Initialize dp[j] with {0} for each index\n        for (int j = 0; j < n; j++) {\n            dp[j].insert(0);\n        }\n\n        // Check if already a zero array\n        if (all_of(nums.begin(), nums.end(), [](int x) { return x == 0; })) {\n            return 0;\n        }\n\n        // Process each query\n        for (int k = 0; k < queries.size(); k++) {\n            int l = queries[k][0], r = queries[k][1], val = queries[k][2];\n\n            // Update possible values at each affected index\n            for (int j = l; j <= r; j++) {\n                unordered_set<int> newValues;\n                for (int x : dp[j]) {\n                    if (x + val <= 1000) newValues.insert(x + val);\n                }\n                dp[j].insert(newValues.begin(), newValues.end());\n\n                // Remove values exceeding nums[j]\n                for (auto it = dp[j].begin(); it != dp[j].end();) {\n                    if (*it > nums[j]) it = dp[j].erase(it);\n                    else ++it;\n                }\n            }\n\n            // Check if nums can be reduced to zero\n            bool allAchieved = true;\n            for (int j = 0; j < n; j++) {\n                if (dp[j].find(nums[j]) == dp[j].end()) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n\n            if (allAchieved) return k + 1;\n        }\n\n        return -1;\n    }\n};\n","author":"Syaapaa","submissionId":"1575221737"},[]]},{"1256":[{"id":"1256","fileName":"1575221630.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& que) {\n        int n = nums.size(), q = que.size();\n        vector<vector<pair<int, int>>> vv(n);\n        for (int i = 0; i < q; i++) {\n            for (int j = que[i][0]; j <= que[i][1]; j++) {\n                vv[j].push_back({que[i][2], i});\n            }\n        }\n        // for(int i=0;i<n;i++){\n        //     for(auto it:vv[i]) cout << it.first <<\" \";\n        //     cout << endl;\n        // }\n        \n        function<int(vector<pair<int, int>>, int)> fxn =\n            [&](vector<pair<int, int>> vec, int cur) {\n\n                // cout << cur << endl;\n\n                set<int> s;\n                s.insert(0);\n\n                for (auto it : vec) {\n                    set<int> ss;\n                    for (auto itt : s) {\n                        ss.insert(itt + it.first);\n                        if (itt + it.first == cur){\n                            cout << it.second<< endl;\n                            return (it.second);\n                        }\n                    }\n                    for(auto it:ss) s.insert(it);\n                }\n                cout << -1 << endl;\n                return -1;\n            };\n\n        int ans = -1;\n        // for(int i=0;i<n;i++) cout << nums[i] << endl;\n        for (int i = 0; i < n; i++) {\n            cout<<\"* \" << nums[i] << endl;\n            ans = max(ans, fxn(vv[i], nums[i])+1);\n            if(nums[i]!=0&&fxn(vv[i], nums[i])==-1) return -1;\n        }\n        if (ans == 1e6)\n            return -1;\n        else\n            return ans;\n    }\n};","author":"Romit Sovakar","submissionId":"1575221630"},[]]},{"1257":[{"id":"1257","fileName":"1575221794.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        # coded by Arun Pranav A T\n        n = len(nums)\n        dp = [set([0]) for _ in range(n)]\n        if all(num == 0 for num in nums):\n            return 0\n        for ind, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                dp[i] |= {val + num for num in dp[i] if val + num <= 1000}\n                dp[i] = {num for num in dp[i] if num <= nums[i]}\n            if all(nums[i] in dp[i] for i in range(n)):\n                return ind + 1\n        return -1","author":"Arun Pranav A T","submissionId":"1575221794"},[]]},{"1258":[{"id":"1258","fileName":"1575221897.txt","sourceCode":"class Solution {\npublic:\n    int helper(int i, int val, vector<pair<int, int>>& v,\n               vector<vector<int>>& dp) {\n        if (val == 0) {\n            return 0;\n        }\n        if (i >= v.size())\n            return 1e5;\n        if (dp[i][val] != -1)\n            return dp[i][val];\n        int take = 1e5;\n        int nottake = helper(i + 1, val, v, dp);\n\n        if (v[i].first <= val) {\n            int x = helper(i + 1, val - v[i].first, v, dp);\n\n            if (x != 1e5) {\n                take = max(v[i].second, x);\n            }\n        }\n\n        return dp[i][val] = min(take, nottake);\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n\n        unordered_map<int, vector<pair<int, int>>> mp;\n\n        for (int i = 0; i < q.size(); i++) {\n            for (int j = q[i][0]; j <= q[i][1]; j++) {\n                mp[j].push_back({q[i][2], i});\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (mp.find(i) != mp.end())\n                sort(mp[i].begin(), mp[i].end(),\n                     [](const pair<int, int>& a, const pair<int, int>& b) {\n                         return a.second < b.second;\n                     });\n        }\n        int maxi = -1;\n        for (int i = 0; i < n; i++) {\n\n            int val = nums[i];\n\n            if (val == 0)\n                continue;\n            if (mp.find(i) == mp.end() || mp[i].empty())\n                return -1;\n            vector<pair<int, int>>& v = mp[i];\n            vector<vector<int>> dp(v.size() + 1, vector<int>(val + 1, -1));\n            int ans = helper(0, val, v, dp);\n            if (ans == 1e5)\n                return -1;\n            maxi = max(ans, maxi);\n        }\n        return (maxi==-1 ? 0:maxi + 1);\n    }\n};","author":"Tanay Gupta","submissionId":"1575221897"},[]]},{"1259":[{"id":"1259","fileName":"1575221870.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n=len(nums)\n        m=len(queries)\n        if all(i==0 for i in nums):\n            return 0\n        def makezeroes(k: int)->bool:\n            for j in range(n):\n                goal=nums[j]\n                if goal==0:\n                    continue\n                vals=[]\n                for i in range(k):\n                    left,right,val=queries[i]\n                    if left<=j and j<=right:\n                        vals.append(val)\n                dp=1\n                for vertex in vals:\n                    dp|=(dp<<vertex)\n                if goal>1000 or not(dp&(1<<goal)):\n                    return False\n            return True\n        for k in range(1,m+1):\n            if makezeroes(k):\n                return k\n        return -1\n        \n        ","author":"Sonakshi_08","submissionId":"1575221870"},[]]},{"1260":[{"id":"1260","fileName":"1575221600.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n\n        def can_form_zero_array(k):\n            coverage = [[] for _ in range(n)]\n            for i in range(k):\n                l, r, val = queries[i]\n                for j in range(l, r + 1):\n                    coverage[j].append(val)\n    \n            for i in range(n):\n                target = nums[i]\n                vals = coverage[i]\n                if target == 0:\n                    continue\n                if not vals:\n                    return False\n                dp = [False] * (target + 1)\n                dp[0] = True\n                for val in vals:\n                    for x in range(target, val - 1, -1):\n                        if dp[x - val]:\n                            dp[x] = True\n                if not dp[target]:\n                    return False\n            return True\n    \n        left, right = 0, len(queries)\n        res = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if can_form_zero_array(mid):\n                res = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n    \n        return res","author":"Rithik Bansal","submissionId":"1575221600"},[]]},{"1261":[{"id":"1261","fileName":"1575221856.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        start = 1\n        end = len(queries)\n        ans = -1\n        if not self.check(nums, queries):\n            return -1\n        if all(x == 0 for x in nums):\n            return 0\n        while start <= end:\n            mid = start + (end - start) // 2\n            if self.check(nums, queries[:mid]):\n                end = mid - 1\n                ans = mid\n            else:\n                start = mid + 1\n        return ans\n\n    def check(self, arr, q):\n        sweep = [[] for _ in range(len(arr))]\n        for i, j, v in q:\n            for k in range(i, j+1):\n                sweep[k].append(v)\n        #print(sweep)\n        for i, e in enumerate(arr):\n            if not self.can_make_zero(e, sweep[i]):\n                return False\n        return True\n\n    def can_make_zero(self, e, arr, index=0, memo=None):\n        if memo is None:\n            memo = {}\n        if (e, index) in memo:\n            return memo[(e, index)]\n        if e == 0:\n            return True\n        if e < 0 or index >= len(arr):\n            return \n        if self.can_make_zero(e, arr, index + 1, memo):\n            memo[(e, index)] = True\n            return True\n        if self.can_make_zero(e - arr[index], arr, index + 1, memo):\n            memo[(e, index)] = True\n            return True\n        memo[(e, index)] = False\n        return False\n            \n            ","author":"Aziz Jabbar Shiddiq","submissionId":"1575221856"},[]]},{"1262":[{"id":"1262","fileName":"1575221903.txt","sourceCode":"class Solution(object):\n    def minZeroArray(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: int\n        \"\"\"\n        x = [[] for _ in range(len(nums))]\n\n        for i in range(len(queries)):\n            [l, r, val] = queries[i]\n            for k in range(l, r + 1):\n                x[k].append([val, i])\n\n        def check(index):\n            dp = {}\n\n            def BFS(arr, i, sum, target):\n                if(sum == target):\n                    return i - 1\n                if(sum > target):\n                    return 1000000000\n                if(i == len(arr)):\n                    return 1000000000\n\n                if((sum, i) in dp):\n                    return dp[(sum, i)]\n\n                ans = min(BFS(arr, i + 1, sum + arr[i], target), BFS(arr, i + 1, sum, target))\n                dp[(sum, i)] = ans\n                return ans\n\n            arr = []\n            for i in x[index]:\n                arr.append(i[0])\n            target = nums[index]\n\n            res = BFS(arr, 0, 0, target)\n            if(res == 1000000000):\n                return -1\n            else:\n                return x[index][res][1] + 1\n\n                \n\n        ans = 0\n        for i in range(len(nums)):\n            if(nums[i] != 0):\n                index = check(i)\n                if(index == -1):\n                    return -1\n                else:\n                    ans = max(ans, index)\n        return ans","author":"saivardhan_1999","submissionId":"1575221903"},[]]},{"1263":[{"id":"1263","fileName":"1575221930.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& arr, vector<vector<int>>& ops) {\n     int size = arr.size();\n        vector<bitset<1001>> status(size);\n       for(int i=0;i<1;i++){\n       }\n        for (bitset<1001>& bits : status) bits.set(0);\n\n        bool isZero = true;\n        for (int num : arr) {\n            if (num != 0) {\n                isZero = false;\n                break;\n            }\n        }\n\n        for(int j=1;j>=0;j--){\n            \n        }\n        if (isZero) return 0;\n\n        for (size_t step = 0; step < ops.size(); ++step) {\n            int start = ops[step][0], end = ops[step][1], value = ops[step][2];\n\n            for (int i = start; i <= end; ++i) {\n                bitset<1001> shiftBits;\n                \n                for (int j = 0; j <= 1000 - value; ++j) {\n                    if (status[i].test(j)) {\n                        shiftBits.set(j + value);\n                    }\n                }\n\n                status[i] |= shiftBits;\n\n                for (int pos = arr[i] + 1; pos < 1001; ++pos) {\n                    status[i].reset(pos);\n                }\n            }\n\n            bool achieved = true;\n            for (int i = 0; i < size; ++i) {\n                if (!status[i][arr[i]]) {\n                    achieved = false;\n                    break;\n                }\n            }\n\n            if (achieved) return step + 1;\n        }\n        if(true){\n        return -1;\n        }else{\n        return -1;\n        }\n    }\n};","author":"leetcode","submissionId":"1575221930"},[]]},{"1264":[{"id":"1264","fileName":"1575221939.txt","sourceCode":"class Solution {\n\n    static boolean subsetsum(ArrayList<Integer> arr, int sum) {\n        int n = arr.size();\n        boolean[] prev = new boolean[sum + 1];\n        boolean[] curr = new boolean[sum + 1];\n\n        prev[0] = true;\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= sum; j++) {\n                if (j < arr.get(i-1)) {\n                    curr[j] = prev[j];\n                }\n                else {\n                    curr[j]\n                        = prev[j] || prev[j - arr.get(i-1)];\n                }\n            }\n\n            System.arraycopy(curr, 0, prev, 0, sum + 1);\n        }\n        return prev[sum];\n    }\n\n    \n    public boolean check(ArrayList<ArrayList<Integer>> al, int[] nums){\n        int n = nums.length;\n\n        \n        for(int i=0;i<n;i++){\n            ArrayList<Integer> temp = al.get(i);\n            Collections.sort(temp);\n            \n            if(!subsetsum(temp, nums[i])){\n                return false;\n            }\n            \n        }\n        return true;\n    }\n    public int minZeroArray(int[] nums, int[][] q) {\n        int n = nums.length;\n        \n        int summ = 0;\n        for(int i=0;i<n;i++){\n            summ+= nums[i];\n        }\n        if(summ==0)\n        {\n            return 0;\n        }\n        \n        ArrayList<ArrayList<Integer>> al = new ArrayList<ArrayList<Integer>>();\n        for(int i=0;i<n;i++){\n            al.add(new ArrayList<>());\n        }\n        for(int i=0;i<q.length;i++){\n            int l = q[i][0];\n            int r = q[i][1];\n            int v = q[i][2];\n            for(int j=l;j<=r;j++){\n                al.get(j).add(v);\n            }\n\n            if(check(al, nums)){\n                return i+1;\n            }\n                \n        }\n\n        return -1;\n    }\n}","author":"anmol dogra","submissionId":"1575221939"},[]]},{"1265":[{"id":"1265","fileName":"1575222138.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, a: List[int], q: List[List[int]]) -> int:\n        n = len(a)\n        m = len(q)\n        \n        res = -1\n        left, right = 0, m\n\n        while left <= right:\n            mid = left + (right - left) // 2\n            b = [[] for _ in range(n)]\n\n            for i in range(mid):\n                for j in range(q[i][0], q[i][1] + 1):\n                    b[j].append(q[i][2])\n\n            ok2 = True  \n            for i in range(n):\n                c = b[i]\n                dp = [[-1] * (a[i] + 1) for _ in range(len(c) + 1)]\n\n                def dfs(j, k):\n                    if k == 0:\n                        return True\n                    if j == len(c):\n                        return False\n                    if dp[j][k] != -1:\n                        return dp[j][k]\n                    \n                    take = dfs(j + 1, k - c[j]) if k >= c[j] else False\n                    skip = dfs(j + 1, k)\n                    \n                    dp[j][k] = take or skip\n                    return dp[j][k]\n\n                if not dfs(0, a[i]):\n                    ok2 = False\n                    break  \n\n            if ok2:\n                res = mid \n                right = mid - 1  \n            else:\n                left = mid + 1 \n\n        return res\n","author":"nazeeeef007","submissionId":"1575222138"},[]]},{"1267":[{"id":"1267","fileName":"1575222340.txt","sourceCode":"class Solution {\npublic:\nvoid dd(vector<bool>&arr, int s){\n        for(int i=1000;i>=s;i--) arr[i]= arr[i-s];\n        for(int i=0;i<s;i++) arr[i]=false;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        vector<vector<bool>>v(n,vector<bool>(1001,false));\n        for (int i=0;i<n;i++) v[i][0]=true;\n\n        bool flag = true;\n        for(int it: nums){\n            if(it!=0){\n                flag=false;\n                break;\n            }\n        }\n        if(flag) return 0;\n        for (int op = 0; op < queries.size(); op++) {\n            int s = queries[op][0];\n            int e = queries[op][1];\n            int increment = queries[op][2];\n\n            for(int i=s;i<=e;i++){\n                vector<bool>temp=v[i];\n                dd(temp, increment);\n                for (int j = 0; j < 1001; j++) {\n                    v[i][j] = v[i][j] || temp[j];\n                }\n                for (int p=nums[i] + 1; p< 1001; p++) {\n                    v[i][p] = false;\n                }\n            }\n\n            bool targetAchieved = true;\n            for (int i = 0; i < n; i++) {\n                if (!v[i][nums[i]]) {\n                    targetAchieved = false;\n                    break;\n                }\n            }\n\n            if (targetAchieved) return op + 1;\n        }\n\n        return -1;\n    }\n};","author":"Ashish Singh","submissionId":"1575222340"},[]]},{"1268":[{"id":"1268","fileName":"1575222295.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool calc(long long val, vector<int> &has) {\n        vector<int> dp(val + 1, 0); // Using vector<int> instead of vector<bool>\n        dp[0] = 1;\n\n        for(int num : has) {\n            for(long long j = val; j >= num; j--) {\n                dp[j] = dp[j] | dp[j - num]; // Fixed bitwise OR assignment\n            }\n        }\n        return dp[val];\n    }\n\n    bool isPossible(int mid, vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> has(n);\n\n        // Apply queries up to 'mid'\n        for(int i = 0; i <= mid; i++) {\n            int from = queries[i][0];\n            int to = queries[i][1];\n            int val = queries[i][2];\n\n            for(int z = from; z <= to; z++) {\n                has[z].push_back(val);\n            }\n        }\n\n        // Check if all nums[z] can be formed\n        for(int z = 0; z < n; z++) {\n            if (!calc(nums[z], has[z])) return false;\n        }\n\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int left = 0, right = queries.size() - 1, ans = -1;\n         bool alreadyPossible = true;\n        for (int z = 0; z < nums.size(); z++) {\n            vector<int> empty; // No elements to use\n            if (!calc(nums[z], empty)) {\n                alreadyPossible = false;\n                break;\n            }\n        }\n        if (alreadyPossible) return 0;\n\n        while(left <= right) {\n            int mid = left + (right - left) / 2;\n            if (isPossible(mid, nums, queries)) {\n                ans = mid + 1; // Store potential answer\n                right = mid - 1; // Try for a smaller index\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return ans;\n    }\n};\n","author":"Somya Singh","submissionId":"1575222295"},[]]},{"1269":[{"id":"1269","fileName":"1575222325.txt","sourceCode":"class Solution {\npublic:\n    bool check(int sum,vector<int>&vals){\n        vector<bool> dp(sum+1,false);\n        dp[0]=true;\n        for(auto it:vals){\n            for(int s=sum;s>=it;s--){\n                dp[s]=dp[s]||dp[s-it];\n            }\n        }\n        return dp[sum];\n    }\n    bool isPossible(vector<int>& nums, vector<vector<int>>& q,int limit){\n        int n=nums.size();\n        vector<vector<int>>values(n);\n        for(int i=0;i<=limit;i++){\n            int l=q[i][0];\n            int r=q[i][1];\n            int val=q[i][2];\n            for(int j=l;j<=r;j++){\n                values[j].push_back(val);\n            }\n        }\n        for(int i=0;i<n;i++){\n            if(nums[i]==0)continue;\n            if(!check(nums[i],values[i]))return false;\n        }\n        return true;\n        \n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n=nums.size();\n        vector<int>temp(n,0);\n        if(nums==temp)return 0;\n        int low=0;\n        int high=q.size()-1;\n        int ans=-1;\n        while(low<=high){\n            int mid=(low+high)/2;\n            if(isPossible(nums,q,mid)){\n                ans=mid+1;\n                high=mid-1;\n            }\n            else low=mid+1;\n        }\n        return ans;\n    }\n};","author":"Saddam Hussain","submissionId":"1575222325"},[]]},{"1270":[{"id":"1270","fileName":"1575222230.txt","sourceCode":"import java.util.*;\n\npublic class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        List<BitSet> bitSetList = new ArrayList<>(n);\n\n        for (int i = 0; i < n; i++) {\n            BitSet bitSet = new BitSet(1001);\n            bitSet.set(0);\n            bitSetList.add(bitSet);\n        }\n\n        boolean allZeros = true;\n        for (int num : nums) {\n            if (num != 0) {\n                allZeros = false;\n                break;\n            }\n        }\n\n        if (allZeros) return 0;\n\n        for (int k = 0; k < queries.length; k++) {\n            int left = queries[k][0];\n            int right = queries[k][1];\n            int value = queries[k][2];\n\n            for (int j = left; j <= right; j++) {\n                BitSet current = (BitSet) bitSetList.get(j).clone();\n                current.or(shiftLeft(bitSetList.get(j), value));\n\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    current.clear(pos);\n                }\n\n                bitSetList.set(j, current);\n            }\n\n            boolean allAchieved = true;\n            for (int j = 0; j < n; j++) {\n                if (!bitSetList.get(j).get(nums[j])) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n\n            if (allAchieved) return k + 1;\n        }\n\n        return -1;\n    }\n\n    private BitSet shiftLeft(BitSet bitSet, int positions) {\n        BitSet result = new BitSet(bitSet.length() + positions);\n        for (int i = bitSet.nextSetBit(0); i >= 0; i = bitSet.nextSetBit(i + 1)) {\n            result.set(i + positions);\n        }\n        return result;\n    }\n}","author":"KOVID TIWARI","submissionId":"1575222230"},[]]},{"1271":[{"id":"1271","fileName":"1575222590.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n=nums.length;\n        boolean[][] dp=new boolean[n][1001];\n        for(int i=0;i<n;i++){\n            dp[i][0]=true;\n        }\n        boolean flag=true;\n        for(int i:nums){\n            if(i!=0){\n                flag=false;\n                break;\n            }\n        }\n        if(flag==true) return 0;\n        int m=queries.length;\n        for(int i=0;i<m;i++){\n            int l=queries[i][0];\n            int r=queries[i][1];\n            int val=queries[i][2];\n            for(int j=l;j<=r;j++){\n                boolean[] arr=dp[j].clone();\n                for(int k=0;k<=1000-val;k++){\n                    if(dp[j][k]) arr[val+k]=true;\n                }\n                for(int k=nums[j]+1;k<=1000;k++){\n                    arr[k]=false;\n                }\n                dp[j]=arr;\n            }\n            boolean x=true;\n            for(int y=0;y<n;y++){\n                if(dp[y][nums[y]]==false){\n                    x=false;\n                    break;\n                }\n            }\n            if(x) return i+1;\n        }\n        return -1;\n    }\n}","author":"Karthikeya chodisetti","submissionId":"1575222590"},[]]},{"1272":[{"id":"1272","fileName":"1575222396.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<vector<int>> queriesForIndices(n);\n        for (int i = 0; i < m; ++i) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            for (int j = l; j <= r; ++j) {\n                queriesForIndices[j].push_back(i);\n            }\n        }\n        \n        vector<int> k_j(n, -1);\n        for (int j = 0; j < n; ++j) {\n            unordered_set<int> possibleSums;\n            possibleSums.insert(0);\n            int currentSum = 0;\n            int target = nums[j];\n            if (target == 0) {\n                k_j[j] = 0;\n                continue;\n            }\n            int earliest = -1;\n            for (int q : queriesForIndices[j]) {\n                int val = queries[q][2];\n                unordered_set<int> newSums;\n                for (int s : possibleSums) {\n                    int newSum = s + val;\n                    if (newSum == target) {\n                        earliest = q + 1; \n                        break;\n                    }\n                    if (newSum < target) {\n                        newSums.insert(newSum);\n                    }\n                }\n                if (earliest != -1) break;\n                possibleSums.insert(newSums.begin(), newSums.end());\n            }\n            k_j[j] = earliest;\n        }\n        \n        int max_k = -1;\n        for (int j = 0; j < n; ++j) {\n            if (k_j[j] == -1) return -1;\n            if (k_j[j] > max_k) max_k = k_j[j];\n        }\n        return max_k;\n    }\n};","author":"Vishesh Chaitanya","submissionId":"1575222396"},[]]},{"1273":[{"id":"1273","fileName":"1575222599.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n\n        auto validPrefix = [&](int k) -> bool {\n\n            const int MAXSUM = 1001;\n            vector<bitset<MAXSUM>> dp(n), mask(n);\n\n            for (int i = 0; i < n; i++) {\n                dp[i].reset();\n                dp[i].set(0, true);\n                mask[i].reset();\n \n                for (int s = 0; s <= nums[i]; s++) {\n                    mask[i].set(s, true);\n                }\n            }\n\n            for (int j = 0; j < k; j++) {\n                int l = queries[j][0];\n                int r=queries[j][1];\n                int val=queries[j][2];\n                for (int i = l; i <= r; i++) {\n\n                    bitset<MAXSUM> shifted = dp[i] << val;\n\n                    shifted &= mask[i];\n                    dp[i] |= shifted;\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                if (!dp[i].test(nums[i]))\n                    return false;\n            }\n            return true;\n        };\n        int left = 0,\n            right = m + 1; \n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (validPrefix(mid))\n                right = mid;\n            else\n                left = mid + 1;\n        }\n\n        return (left > m ? -1 : left);\n    }\n};","author":"Rishabh Kumar Sharma","submissionId":"1575222599"},[]]},{"1275":[{"id":"1275","fileName":"1575222386.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        cur_sum = sum(nums)\n        num_zero = nums.count(0)\n        if num_zero == n:\n            return 0\n        min_k = 0\n        # for i in range(n):\n        #     if nums[i] != 0:\n        #         cur_min = math.inf\n        #         for j in range(m):\n        # def dfs(state, i):\n        #     if cur_sum == 0:\n        #         return 0\n        #     else:\n        #         new_arr = []\n        #         l, r, val = queries[i]\n        #         for j in range(l, r + 1):\n        #             if val <= state[j]:\n        # pos = [[0]] * n\n        for i in range(n):\n            if nums[i] != 0:\n                cur_min = -1\n                ls = [0]\n                vis = set([0])\n                for j in range(m):\n                    l, r, val = queries[j]\n                    if l <= i and i <= r:\n                        nn = len(ls)\n                        for idx in range(nn):\n                            next = ls[idx] + val\n                            if next <= nums[i] and next not in vis:\n                                ls.append(next)\n                                vis.add(next)\n                        if nums[i] in vis:\n                            cur_min = j + 1\n                            break\n                else:\n                    return -1\n                \n                if cur_min != -1:\n                    #print(cur_min)\n                    min_k = max(min_k, cur_min)\n        return min_k\n                \n                        \n                    \n            \n        # for idx, (l, r, val) in enumerate(queries):\n        #     for i in range(l, r + 1):\n        #         if val <= nums[i]:\n        #             nums[i] -= val\n        #             #print(nums)\n        #             if nums[i] == 0 and not vis[i]:\n        #                 vis[i] = 1\n        #                 num_zero += 1\n        #             if num_zero == n:\n        #                 return idx + 1\n        #print(nums)\n        return -1 if min_k == math.inf else min_k","author":"Yuxuan Liu","submissionId":"1575222386"},[]]},{"1276":[{"id":"1276","fileName":"1575222736.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& qr) {\n        int n = nums.size();\n        vector<bitset<1001>> tmpp(n, bitset<1001>().set(0));\n        vector<int> res;\n        map<int,int> mp;\n        int chk=0;\n        if (all_of(nums.begin(), nums.end(), [](int x) { return x==0; })) return 0;\n        int i=0;\n        int q=qr.size();\n        while(i<q){\n            int xx=qr[i][0];\n            int aa=xx;\n            aa++;\n            int yy=qr[i][1];\n            aa=yy;\n            aa++;\n            int zz=qr[i][2];\n            aa=zz;\n            aa++;\n            int j=xx;\n            while(j<=yy){\n                tmpp[j] |= (tmpp[j]<<zz);\n                for (int x=nums[j]+1; x<1001; x++) tmpp[j].reset(x);\n                j++;\n            }\n            bool chh = true;\n            bool tt=0;\n            j=0;\n            while(j<n){\n                if (!tmpp[j].test(nums[j])) {\n                    chh=false;\n                    break;\n                }\n                j++;\n            }\n            j=0;\n            aa++;\n            if(chh==true){\n                int ans = i+1;\n                return (ans);\n            }\n            aa--;\n            i++;\n        }\n        return -1;\n    }\n};","author":"Krishna Mohan","submissionId":"1575222736"},[]]},{"1277":[{"id":"1277","fileName":"1575222746.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (a); i < (b); i++)\n#define allZero(arr) all_of(arr.begin(), arr.end(), [](int x) { return x == 0; })\n#define vevot(type, name, size) vector<type> name(size)\n#define vecBitset(n, size) vector<bitset<size>> dp(n)\n#define dpMacro(n, size) vecBitset(n, size)\n#define retSize(arr) (int)(arr.size())\n\nclass Solution {\npublic:\n    void applyQuery(int l, int r, int v, vector<bitset<1001>>& dp, vector<int>& nums) {\n        loop(j, l, r + 1) {\n            bitset<1001> shifted;\n            loop(i, 0, 1001 - v) if (dp[j][i]) shifted.set(i + v);\n            dp[j] |= shifted;\n            loop(pos, nums[j] + 1, 1001) dp[j].reset(pos);\n        }\n    }\n\n    bool helper(bitset<1001>& bset, int num) {\n        return bset[num];\n    }\n\n    bool checkAllAchieved(vector<bitset<1001>>& dp, vector<int>& nums) {\n        loop(j, 0, retSize(nums)) if (!helper(dp[j], nums[j])) return false;\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = retSize(nums);\n        dpMacro(n, 1001);\n        vevot(int, temp, n);\n\n        loop(j, 0, n) dp[j].set(0);\n\n        if (allZero(nums)) return 0;\n\n        loop(k, 0, retSize(queries)) {\n            applyQuery(queries[k][0], queries[k][1], queries[k][2], dp, nums);\n            if (checkAllAchieved(dp, nums)) return k + 1;\n        }\n        return -1;\n    }\n};\n","author":"ANKIT KUMAR","submissionId":"1575222746"},[]]},{"1278":[{"id":"1278","fileName":"1575222683.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n\n       Set<Integer>[] u = new HashSet[nums.length];\n    \n       for(int i =0; i<nums.length; i++){\n           if(nums[i]>0){\n                u[i] = new HashSet<>();\n                u[i].add(nums[i]);\n           }\n       }\n\n        if(allNull(u)) return 0;\n\n        for(int j =0; j<queries.length; j++){\n\n            int[] q = queries[j];\n            \n            for(int i = q[0]; i<= q[1]; i++){\n                u[i] = apply(u[i], q[2]);\n            }\n            if(allNull(u)) return j+1;\n        }\n        \n\n        \n        return -1;\n    }\n\n\n    boolean allNull(Set<Integer>[] s){\n        for(Set<Integer> x: s){\n            if(x!=null) return false;\n        }\n        return true;\n    }\n\n    Set<Integer> apply(Set<Integer> os, int x){\n        if(os == null ) return null;\n\n        Set<Integer> set = new HashSet<>();\n\n        for( int i : os){\n            if(i == x) return null;\n            if(i>x)\n                set.add(i-x);\n            set.add(i);\n        }\n        return set;\n        \n    }\n}","author":"Utkarsh Deepak","submissionId":"1575222683"},[]]},{"1279":[{"id":"1279","fileName":"1575222802.txt","sourceCode":"#include <vector>\n#include <bitset>\nusing namespace std;\n\n#define BIT bitset<1001>\n#define PB push_back\n#define SZ(x) ((int)(x).size())\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RST(x, y) (x).reset(y)\n#define SET(x, y) (x).set(y, true)\n#define OR(x, y) (x |= y)\n#define TST(x, y) (x.test(y))\n#define RET return\n#define VEC vector\n#define INT int\n\nclass Solution {\npublic:\n    INT minZeroArray(VEC<INT>& a, VEC<VEC<INT>>& q) {\n        INT n = SZ(a);\n        VEC<BIT> dp(n);\n        ini(dp, n);\n\n        if (chk(a, n)) RET 0;\n\n        REP(k, SZ(q)) {\n            upd(dp, q[k], a, n);\n            if (chk2(dp, a, n)) RET k + 1;\n        }\n        RET -1;\n    }\n\nprivate:\n    void ini(VEC<BIT>& dp, INT n) {\n        REP(j, n) {\n            dp[j].reset();\n            SET(dp[j], 0);\n        }\n    }\n\n    bool chk(VEC<INT>& a, INT n) {\n        REP(j, n) if (a[j] != 0) RET false;\n        RET true;\n    }\n\n    void upd(VEC<BIT>& dp, VEC<INT>& q, VEC<INT>& a, INT n) {\n        INT l = q[0], r = q[1], v = q[2];\n        FOR(j, l, r + 1) {\n            OR(dp[j], (dp[j] << v));\n            FOR(p, a[j] + 1, 1001) RST(dp[j], p);  // Fix: Reset specific bits, not the whole dp[j]\n        }\n    }\n\n    bool chk2(VEC<BIT>& dp, VEC<INT>& a, INT n) {\n        REP(j, n) if (!TST(dp[j], a[j])) RET false;\n        RET true;\n    }\n};\n","author":"Sᴀʙᴀʀɪ ɴᴀᴛʜᴀɴ .S","submissionId":"1575222802"},[]]},{"1280":[{"id":"1280","fileName":"1575222811.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int canmake(int i, vector<int>& vals, int target, vector<vector<int>>& dp) {\n        if(target == 0) return 1;\n        if(i == vals.size()) return 0;\n        if(dp[i][target] != -1) return dp[i][target];\n        int notPick = canmake(i + 1, vals, target, dp);\n        int pick = 0;\n        if(target >= vals[i]) pick = canmake(i + 1, vals, target - vals[i], dp);\n        return dp[i][target] = (notPick || pick);\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int m = queries.size(), n = nums.size();\n        bool allZero = true;\n        for (int x : nums) {\n            if (x != 0) { allZero = false; break; }\n        }\n        if(allZero) return 0;\n        for (int k = 1; k <= m; k++) {\n            bool poss = true;\n            for (int j = 0; j < n; j++) {\n                vector<int> vals;\n                for (int i = 0; i < k; i++) {\n                    if(queries[i][0] <= j && j <= queries[i][1])\n                        vals.push_back(queries[i][2]);\n                }\n                int target = nums[j];\n                if(target != 0) {\n                    if(vals.empty()) { poss = false; break; }\n                    vector<vector<int>> dp(vals.size() + 1, vector<int>(target + 1, -1));\n                    if(!canmake(0, vals, target, dp)) { poss = false; break; }\n                }\n            }\n            if(poss) return k;\n        }\n        return -1;\n    }\n};\n","author":"AAR","submissionId":"1575222811"},[]]},{"1281":[{"id":"1281","fileName":"1575222858.txt","sourceCode":"class Solution {\npublic:\n\n\n    bool check(int m, vector<int>&nums, vector<vector<int>>&q){\n        int n=nums.size();\n         for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            vector<int> coins;\n            \n            for (int j = 0; j < m; j++) {\n                int l = q[j][0], r = q[j][1], v = q[j][2];\n                if (l <= i && i <= r) {\n                    coins.push_back(v);\n                }\n            }\n             unordered_map<int, bool> memo;\n            memo[0] = true;\n            for (int coin : coins) {\n                unordered_map<int, bool> newDp = memo;\n                for (auto [sum, _] : memo) {\n                    int ns = sum + coin;\n                    if (ns > target) continue;\n                    newDp[ns] = true;\n                }\n                memo = newDp;\n            }\n            if (!memo.count(target)) return false;\n        }\n        \n        return true;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        bool f=true;\n        for(int i=0;i<n;i++){\n            if(nums[i]>0)f=false;\n        }\n        if(f)return 0;\n        bool flag=false;\n        int l=1;\n        int h=queries.size();\n        while(l<=h){\n            int m=l+(h-l)/2;\n            if(check(m,nums,queries)){\n                flag=true;\n                h=m-1;\n            }\n            else l=m+1;\n        }\n        if(flag)return l;\n        return -1;\n    }\n};","author":"viking","submissionId":"1575222858"},[]]},{"1282":[{"id":"1282","fileName":"1575222996.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        bool ans = true;\n        for(int i = 0; i < n; i++)\n            if(nums[i])\n            {\n                ans = false;\n                break;\n            }\n        if(ans)\n            return 0;\n        vector<unordered_set<int>> seen(n);\n        for(int i = 0; i < n; i++)\n            seen[i].insert(0);\n        for(int i = 0; i < queries.size(); i++)\n        {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n\n            for(int j = l; j <= r; j++)\n            {\n                //cout << \"for set : \" << j << \" \";\n                //unordered_set<int>& curr = seen[j];\n                vector<int> temp;\n                for(auto x : seen[j])\n                {\n                    //cout << x + val << \" \";\n                    temp.push_back(x + val);\n                }\n                for(auto x : temp)\n                    seen[j].insert(x);\n            }\n            bool ans = true;\n            for(int j = 0; j < n; j++)\n            {\n                if(nums[j] != 0)\n                {\n                    if(seen[j].find(nums[j]) == seen[j].end())\n                        ans = false;\n                    else\n                        nums[j] = 0;\n                }\n            }\n            if(ans)\n                return i + 1;\n        }\n        return -1;\n    }\n};","author":"Dhananjay kumar","submissionId":"1575222996"},[]]},{"1283":[{"id":"1283","fileName":"1575223019.txt","sourceCode":"#define PRINT_MAT(m) {        \n    for (auto& v: (m)) {      \n        for (auto& i: v) {    \n            cout << i << \" \"; \n        }                     \n        cout << endl;         \n    }                         \n    cout << endl;             \n}\n\n#define PRINT_VEC(v) {    \n    for (auto& i: (v)) {  \n        cout << i << \" \"; \n    }                     \n    cout << endl;         \n}\n\n#define PRINT_MAP(m) {                                     \n    for (auto& p: (m)) {                                   \n        cout << \"(\" << p.first << \",\" << p.second << \") \"; \n    }                                                      \n    cout << endl;                                          \n}\n\nclass Solution {\n    bool satisfies(vector<vector<bool>>& dp) {\n        for (auto& v: dp) {\n            if (!v.back()) {\n                return false;\n            }\n        }\n        return true;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int sz = nums.size(), k = 0, qsz = queries.size();\n        vector<vector<bool>> dp(sz);\n        vector<bool> done(sz, false);\n        for (int i = 0; i < sz; i++) {\n            dp[i].resize(nums[i] + 1, false);\n            dp[i][0] = true;\n        }\n        if (satisfies(dp)) {\n            return 0;\n        }\n        for (int i = 0; i < qsz; i++) {\n            auto& q = queries[i];\n            for (int j = q[0]; j <= q[1]; j++) {\n                if (dp[j].back()) {\n                    continue;\n                }\n                auto& v = dp[j];\n                int vsz = v.size();\n                for (int k = vsz - 1; k >= q[2]; k--) {\n                    dp[j][k] = dp[j][k] || dp[j][k - q[2]];\n                }\n            }\n            // for (auto& v: dp) {\n            //     for (auto e: v) {\n            //         cout << e << \" \";\n            //     }\n            //     cout << endl;\n            // }\n            // cout << endl;\n            if (satisfies(dp)) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"guins_j","submissionId":"1575223019"},[]]},{"1284":[{"id":"1284","fileName":"1575223171.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums, queries):\n        n = len(nums)\n        \n        # Initialize dp array with sets, each position can initially be 0\n        dp = [set([0]) for _ in range(n)]\n        \n        # Check if all numbers are already zero\n        allZero = all(num == 0 for num in nums)\n        if allZero:\n            return 0\n        \n        # Process each query\n        for k, (l,r,v) in enumerate(queries):\n            \n            # Update dp for range [l, r]\n            for j in range(l, r + 1):\n                # Add shifted values (equivalent to bitset << v)\n                new_values = {x + v for x in dp[j]}\n                dp[j].update(new_values)\n                # Remove values exceeding nums[j]\n                dp[j] = {x for x in dp[j] if x <= nums[j]}\n            \n            # Check if all target numbers are achievable\n            allAchieved = all(nums[j] in dp[j] for j in range(n))\n            if allAchieved:\n                return k + 1\n        \n        return -1","author":"hcwu99","submissionId":"1575223171"},[]]},{"1285":[{"id":"1285","fileName":"1575223000.txt","sourceCode":"#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool Issum(vector<int>& v, int num) {\n        int n = v.size();\n        vector<bool> dp(num + 1, false);\n        dp[0] = true; \n\n        for (int val : v) {  \n            if (val > num) continue;\n            for (int j = num; j >= val; j--) { \n                dp[j] = dp[j] || dp[j - val]; \n            }\n        }\n        return dp[num]; \n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = queries.size();\n        int p = nums.size();\n        int s = 0, e = n;\n        int anss = n+1; \n\n        while (s <= e) {\n            int m = (e - s) / 2 + s;\n            \n            vector<vector<int>> q(p);\n            for (int i = 0; i < m; i++) {\n                int a = queries[i][0], b = queries[i][1], c = queries[i][2];\n                for (int j = a; j <= b && j < p; j++) { \n                    q[j].push_back(c);\n                }\n            }\n\n            bool allz = true;\n            for (int i = 0; i < p; i++) {\n                if (q[i].size() == 0) {\n                    if (nums[i] == 0) continue;\n                    else {\n                        allz = false;\n                        break;\n                    }\n                }\n                if (!Issum(q[i], nums[i])) {\n                    allz = false;\n                    break;\n                }\n            }\n\n            if (allz) {\n                anss = m;\n                e = m - 1;\n            } else {\n                s = m + 1;\n            }\n        }\n\n        if(anss == n+1)return -1; else return anss;\n    }\n};\n","author":"devanshksg","submissionId":"1575223000"},[]]},{"1286":[{"id":"1286","fileName":"1575223201.txt","sourceCode":"class Solution {\npublic:\n\n    bool f(vector<int>& nums, vector<vector<int>>& queries, int mid) {\n        \n        int n= nums.size();\n\n     for(int i=0; i<n; i++){\n         int req= nums[i];\n         vector<bool> dp(req+1, 0);\n         dp[0]= true;\n        for(int j=0; j<mid; j++){\n            int l= queries[j][0];\n            int r= queries[j][1];\n            int val= queries[j][2];\n\n            if(l<=i && r>=i){\n                for(int sum= req; sum>= val; sum--){\n                    dp[sum]= dp[sum]|| dp[sum-val];\n                }\n            }\n        }\n         if(dp[req]== false)\n             return false;\n     }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\n        int ans= -1;\n        int n= nums.size();\n        int left= 0;\n        int right=queries.size();\n\n        while(left<=right){\n            int mid= left + (right-left)/2;\n\n            if(f(nums, queries, mid)== true){\n                ans= mid;\n                right= mid-1;\n            }\n            else{\n               left = mid+1;\n            }\n        }\n\n        return ans;\n    }\n};","author":"anmol3008","submissionId":"1575223201"},[]]},{"1287":[{"id":"1287","fileName":"1575223225.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if sum(nums) == 0:\n            return 0\n        n = len(nums)\n        cnt = [set([0]) for _ in range(n)]\n        for ans, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                for x in list(cnt[i]):\n                    cnt[i].add(x + val)\n            if all(nums[i] in cnt[i] for i in range(n)):\n                return ans + 1\n        return -1        ","author":"hanbro0112","submissionId":"1575223225"},[]]},{"1288":[{"id":"1288","fileName":"1575223251.txt","sourceCode":"import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public static void main(String[] args) {\n//        System.out.println(new Solution().minZeroArray(new int[]{2, 0, 2}, new int[][]{{0, 2, 1}, {0, 2, 1}, {1, 1, 3}}));\n        System.out.println(new Solution().minZeroArray(new int[]{10}, new int[][]{{0, 0, 4}, {0, 0, 8}, {0, 0, 1}, {0, 0, 10}, {0, 0, 10}}));\n//        System.out.println(new Solution().ableToNullify(new int[]{10}, new List[]{List.of(4, 8)}));\n    }\n\n    public int minZeroArray(int[] nums, int[][] queries) {\n\n        int low = 0;\n        int high = queries.length;\n        while (low < high) {\n            int mid = Math.floorDiv(low + high, 2);\n\n            final List<Integer>[] apply = apply(nums, queries, mid);\n\n            if (ableToNullify(nums, apply)) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        if (low == queries.length && !ableToNullify(nums, apply(nums, queries, low))) {\n            return -1;\n        } else {\n            return low;\n        }\n    }\n\n    private static List<Integer>[] apply(int[] nums, int[][] queries, int mid) {\n\n        List<Integer>[] mem = new List[nums.length];\n        for (int i = 0; i < mem.length; i++) {\n            mem[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < mid; i++) {\n            var query = queries[i];\n            for (int j = query[0]; j <= query[1]; j++) {\n                mem[j].add(query[2]);\n            }\n        }\n        return mem;\n    }\n\n    boolean ableToNullify(int[] nums, List<Integer>[] lists) {\n        for (int i = 0; i < nums.length; i++) {\n            if (!subsetSumToK(lists[i], nums[i], 0, new int[lists[i].size()][1001])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    boolean subsetSumToK(List<Integer> list, int target, int ptr, int[][] mem) {\n        if (target < 0) return false;\n        if (ptr == list.size()) {\n            return target == 0;\n        }\n\n        if (mem[ptr][target] != 0) {\n            return mem[ptr][target] == 1;\n        }\n        boolean tryUse = subsetSumToK(list, target - list.get(ptr), ptr + 1, mem);\n        boolean tryNotUse = subsetSumToK(list, target, ptr + 1, mem);\n\n        mem[ptr][target] = (tryUse || tryNotUse) ? 1 : 2;\n        return tryUse || tryNotUse;\n    }\n}","author":"Sydney Burgess","submissionId":"1575223251"},[]]},{"1289":[{"id":"1289","fileName":"1575223341.txt","sourceCode":"class Solution {\npublic:\n    bool solFunc(vector<int>& arr, int i, int target, vector<vector<int>>& mem) {\n        if(i==arr.size()) {\n            return (target == 0);\n        }\n        \n        if(mem[i][target] != -1)\n            return mem[i][target];\n        \n        bool tk=false, nt=false;\n        if(target>=arr[i]) {\n            tk = solFunc(arr, i+1, target-arr[i], mem);\n        }\n        nt = solFunc(arr, i+1, target, mem);\n        \n        mem[i][target] = (tk | nt);\n        return mem[i][target];\n    }\n    bool check(vector<int>&arr, int target) {\n        vector<vector<int>> mem(arr.size(), vector<int>(target+1, -1));\n        return solFunc(arr, 0, target, mem);\n    }\n    bool isPossible(vector<int> nums, vector<vector<int>>& queries, int k) {\n        int n = nums.size();\n        vector<vector<int>> diff(n);\n        for(int i=0; i<k; i++) {\n            for(int j=queries[i][0]; j<=queries[i][1]; j++) {\n                diff[j].push_back(queries[i][2]);\n            }\n        }\n        for(int i=0; i<n; i++) {\n            if(!check(diff[i], nums[i]))\n                return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int q = queries.size();\n        int l=0, r=q, k=-1;\n        int mid;\n        while(l<=r) {\n            mid = l + (r-l)/2;\n            // cout<<mid<<\" \";\n            if(isPossible(nums, queries, mid)) {\n                k = mid;\n                r = mid-1;\n            } else {\n                l = mid+1;\n            }\n        }\n        return k;\n    }\n};","author":"Sourav Mandal","submissionId":"1575223341"},[]]},{"1290":[{"id":"1290","fileName":"1575223454.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        \"\"\"\n        10 -> set(10, 6, 5)\n\n        10 -> [(4,1) 8 1 10 10]\n        2 0 2\n\n        2 \n        0, 4, 8, 1, 5, 9, 10\n        \n\n         0 T\n         1 T\n         2 F\n         3 F\n         4 T\n         5 T\n         6 F\n         7 F\n         8 T\n         9 T\n        10 T  \n    \n\n        0, 6, \n        \"\"\"\n\n        def becomes_zero(arr, amount):\n            values = set([0])\n\n            for val, k in arr:\n                new_set = values.copy()\n                for elem in values:\n                    if elem + val == amount:\n                        return k\n                    if elem + val < amount:\n                        new_set.add(elem + val)\n                values = new_set\n\n            return float(\"inf\")\n            \n        \n        n = len(nums)\n        data = [[] for _ in range(n)]\n\n        k = 1\n        for l, r, val in queries:\n            for i in range(l, r+1):\n                if val <= nums[i]:\n                    data[i].append((val, k))\n            k += 1\n\n        # print(data)\n        answer = 0\n        for i in range(len(data)):\n            k = becomes_zero(data[i], nums[i])\n            if nums[i] == 0:\n                continue\n            if k == float(\"inf\"):\n                return -1\n            answer = max(answer, k)\n\n        return answer\n\n        \n        ","author":"FabianColque","submissionId":"1575223454"},[]]},{"1292":[{"id":"1292","fileName":"1575223523.txt","sourceCode":"class Solution\n{\n    public int minZeroArray (int[] nums, int[][] queries)\n    {\n        int len1 = nums.length;\n        int len2 = queries.length;\n        int maxInd = -1;\n        for (int ind1=0;ind1<len1;ind1++)\n        {\n            if (nums[ind1] == 0)\n            {\n                maxInd = Math.max (maxInd, 0);\n                continue;\n            }\n            boolean[] bool = new boolean[nums[ind1] + 1];\n            bool[0] = true;\n            for (int ind2=0;ind2<len2;ind2++)\n            {\n                int l = queries[ind2][0];\n                int r = queries[ind2][1];\n                int val = queries[ind2][2];\n                if (ind1 >= l && ind1 <= r)\n                {\n                    for (int k=nums[ind1];k>=0;k--)\n                    {\n                        if (bool[k] && k + val <= nums[ind1])\n                        {\n                            bool[k + val] = true;\n                        }\n                        if (bool[nums[ind1]])\n                        {\n                            maxInd = Math.max (maxInd, ind2 + 1);\n                            break;\n                        }\n                    }\n                }\n                if (bool[nums[ind1]])\n                {\n                    break;\n                }\n            }\n            if (!bool[nums[ind1]])\n            {\n                return -1;\n            }\n        }\n        return maxInd;\n    }\n}","author":"Rahul Ahuja","submissionId":"1575223523"},[]]},{"1293":[{"id":"1293","fileName":"1575223531.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n=nums.length;\n        int q = queries.length;\n        int low=0;\n        int high=q;\n        int ans=-1;\n        while(low<=high){\n            int mid = (low+high)/2;\n            if(check(nums, queries, mid)){\n                ans=mid;\n                high=mid-1;\n            }\n            else low = mid+1;\n        }\n\n        return ans;\n    }\n\n    public boolean check(int[] nums, int[][] queries, int q){\n        // int[] temp = Arrays.copyOf(nums);\n\n        int n=nums.length;\n        boolean[] ans=new boolean[n];\n        // ArrayList<Integer>[] arr=new ArrayList[n];\n        // for(int i=0;i<n;i++) arr[i]=new ArrayList<>();\n        for(int i=0;i<n;i++){\n            int num = nums[i];\n            ArrayList<Integer> arr=new ArrayList<>();\n            for(int j=0;j<q;j++){\n                int l = queries[j][0];\n                int r = queries[j][1];\n                int val = queries[j][2];\n                if(i>=l && i<=r) arr.add(val);\n            }\n            if(check2(arr, num)) ans[i]=true;\n        }\n        for(int i=0;i<n;i++){\n            if(!ans[i]) return false;\n        }\n        return true;\n            \n        \n    }\n\n    public boolean check2(ArrayList<Integer> arr, int target){\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n\n        for (int num : arr) {\n            for (int j = target; j >= num; j--) {\n                dp[j] = dp[j] || dp[j - num];\n            }\n        }\n        return dp[target];\n    }\n}","author":"rutul21","submissionId":"1575223531"},[]]},{"1294":[{"id":"1294","fileName":"1575223721.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        elements_queries = [[] for _ in range(n)]\n        \n        # 收集每个元素对应的查询索引\n        for j, q in enumerate(queries):\n            l, r, val = q\n            for i in range(l, r + 1):\n                elements_queries[i].append(j)\n        \n        max_k = 0\n        for i in range(n):\n            d_i = nums[i]\n            if d_i == 0:\n                continue  # 该元素的k_i为0，无需处理\n            \n            q_list = elements_queries[i]\n            dp = {0: -1}  # 初始状态：和为0时，最大查询索引为-1（未使用任何查询）\n            \n            for j in q_list:\n                l, r, val = queries[j]\n                tmp = {}\n                for s in list(dp.keys()):\n                    current_max_j = dp[s]\n                    new_s = s + val\n                    new_max_j = max(current_max_j, j)\n                    if new_s > d_i:\n                        continue\n                    # 更新临时字典\n                    if new_s in tmp:\n                        if new_max_j < tmp[new_s]:\n                            tmp[new_s] = new_max_j\n                    else:\n                        tmp[new_s] = new_max_j\n                # 合并临时字典到dp中\n                for s in tmp:\n                    if s in dp:\n                        if tmp[s] < dp[s]:\n                            dp[s] = tmp[s]\n                    else:\n                        dp[s] = tmp[s]\n            \n            if d_i not in dp:\n                return -1\n            k_i = dp[d_i] + 1  # 转换为前k个查询\n            if k_i > max_k:\n                max_k = k_i\n        \n        # 检查所有元素是否满足条件\n        for num in nums:\n            if num != 0:\n                break\n        else:\n            return 0\n        \n        return max_k if max_k != 0 else -1","author":"mingliang meng","submissionId":"1575223721"},[]]},{"1295":[{"id":"1295","fileName":"1575223865.txt","sourceCode":"class Solution {\n    \n    int k;\n    \n    public int minZeroArray(int[] nums, int[][] queries) {\n        // 思考，直接想到的解法是：对于每一个位置，找到最小的k，然后找所有数的最大k，如果有没办法到-1的，那最后就是-1\n        // dfs超时\n        // 改成bfs呢，会更快吗？\n        // 每一次操作，这个num可以删，可以不删\n        int n = nums.length;\n        \n        int result = Integer.MIN_VALUE;\n        boolean neg = false;\n        for(int i=0; i<n; i++){\n            int num = nums[i];\n            k = bfs(queries, num, i);\n            if(k == -1){\n                return -1; // 提前停止\n            } else{\n                result = Math.max(result, k);\n            }\n        }\n        return result;\n    }\n    \n    \n    private int bfs(int[][] queries, int num, int targetIdx){\n        if(num == 0){\n            return 0;\n        }\n        // 每一步 使用、不用都放进去\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(num);\n        for(int i=0; i<queries.length; i++){\n            int[] query = queries[i];\n            if(query[0] > targetIdx || query[1] < targetIdx){\n                continue;\n            } else{\n                // 相交，可能操作\n                int size = queue.size();\n                Set<Integer> set = new HashSet<>();\n                while(size > 0){\n                    int cur = queue.remove();\n                    if(cur >= query[2]){\n                        int next = cur - query[2];\n                        set.add(next);\n                        if(next == 0){\n                            return i+1;\n                        }\n                    }\n                    set.add(cur);\n                    size--;\n                }\n                for(int s : set){\n                    queue.offer(s);\n                }\n            }\n        }\n        return -1;\n    }\n    \n}","author":"Gong Shize","submissionId":"1575223865"},[]]},{"1296":[{"id":"1296","fileName":"1575223780.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if not queries or not nums:\n            return -1\n        if nums == [0] * len(nums):\n            return 0\n        \n        n, m = len(nums), len(queries)\n        maxK = -1\n        for i, num in enumerate(nums):\n            sumSet = {0}  \n            for k in range(m):\n                li, ri, vali = queries[k]\n                if li <= i <= ri:\n                    tempset = copy.copy(sumSet)\n                    for s in tempset:\n                        sumSet.add(s + vali)\n                if num in sumSet:\n                    maxK = max(k, maxK)\n                    break  \n            if num not in sumSet:\n                return -1 \n    \n        return maxK + 1 if maxK != -1 else -1\n                \n            ","author":"ChengErJun","submissionId":"1575223780"},[]]},{"1297":[{"id":"1297","fileName":"1575223777.txt","sourceCode":"\nclass Solution {\npublic:\n    \n    \n    bool targetSum(vector<int> &arr,int k){\n        \n        if(arr.size() == 0)\n            return k == 0;\n        \n        int n = arr.size();\n        vector<bool> prev(k + 1, false);\n\n         // Base case: If the target sum is 0, we can always achieve it by taking no elements\n         prev[0] = true;\n\n         // Base case: If the first element of 'arr' is less than or equal to 'k', set prev[arr[0]] to true\n         if (arr[0] <= k) {\n             prev[arr[0]] = true;\n         }\n\n         // Iterate through the elements of 'arr' and update the DP table\n         for (int ind = 1; ind < n; ind++) {\n             // Initialize a new row 'cur' to store the current state of the DP table\n             vector<bool> cur(k + 1, false);\n\n             // Base case: If the target sum is 0, we can achieve it by taking no elements\n             cur[0] = true;\n\n             for (int target = 1; target <= k; target++) {\n                 // If we don't take the current element, the result is the same as the previous row\n                 bool notTaken = prev[target];\n\n                 // If we take the current element, subtract its value from the target and check the previous row\n                 bool taken = false;\n                 if (arr[ind] <= target) {\n                     taken = prev[target - arr[ind]];\n                 }\n\n                 // Store the result in the current DP table row for the current subproblem\n                 cur[target] = notTaken || taken;\n             }\n\n             // Update 'prev' with the current row 'cur' for the next iteration\n             prev = cur;\n         }\n\n         // The final result is stored in prev[k]\n         return prev[k];\n    }\n    \n    bool getMinimumK(vector<int> &nums,vector<vector<int>> &queries,int idxQ){\n        int n = nums.size();\n        \n        vector<vector<int>> avlValues(n);\n        \n        for(int q=0;q<=idxQ;q ++){\n            int l = queries[q][0], r = queries[q][1], val = queries[q][2];\n            \n            for(int i=l;i<=r;i++)\n                avlValues[i].push_back(val);\n        }\n        bool poss = true;\n        \n        for(int i=0;i<n;i++){\n            poss &= targetSum(avlValues[i], nums[i]);\n        }\n        return poss;\n    }\n    \n    bool checkZero(vector<int> &nums){\n        return nums == vector<int> (nums.size(),0);\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        \n        if(checkZero(nums))\n            return 0;\n        \n        int lo = 0,hi = queries.size()-1;\n        \n        while (hi - lo > 1) {\n            int mid = (hi+lo)/2;\n            \n            \n            // Check possible\n            if(getMinimumK(nums, queries, mid))\n                hi = mid;\n            else\n                lo = mid;\n        }\n        \n        if(getMinimumK(nums, queries, lo))\n            return lo + 1;\n        else if(getMinimumK(nums, queries, hi))\n            return hi+1;\n        else\n            return -1;\n    }\n};","author":"Harmandeep Singh","submissionId":"1575223777"},[]]},{"1298":[{"id":"1298","fileName":"1575223967.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int[] d = new int[nums.length];\n        int min = 0;\n        boolean ok = false;\n        for(int i = 0; i < nums.length; i++) {\n            if(nums[i]==0) continue;\n\n            ok = true;\n            List<int[]> q = new ArrayList<>();\n             \n            for(int j = 0; j < queries.length; j++) {\n                if(i>=queries[j][0] && i<= queries[j][1]) {\n                    q.add(new int[]{j, queries[j][2]});\n                }\n            }\n\n            /*\n                 ((pick, notpick) ,target)\n            \n            \n            */\n            int ans = -1;\n            boolean[][] dp = new boolean[q.size()+1][nums[i]+1];\n            for(int j = 0; j < dp.length; j++) dp[j][0] = true;\n\n            for(int j = 1; j < dp.length; j++) {\n                for(int k = 1; k < dp[j].length; k++) {\n                   dp[j][k] = dp[j-1][k];\n                   if(k >= q.get(j-1)[1]) {\n                       dp[j][k] |= dp[j-1][k-q.get(j-1)[1]];\n                   }\n                }\n\n                if(dp[j][nums[i]]) {\n                    ans = q.get(j-1)[0];\n                    break;\n                }\n            }\n\n            if(ans==-1) {\n                return -1;\n            }\n\n            // System.out.println(nums[i]+\" \"+ans);\n\n            min = Math.max(min, ans+1);\n        }\n\n        return ok? min: 0;\n    }\n}","author":"B Jagdish Reddy","submissionId":"1575223967"},[]]},{"1299":[{"id":"1299","fileName":"1575223898.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size(), nq = q.size();\n        int sum = accumulate(a.begin(), a.end(), 0);\n        if(!sum)    return 0;\n        unordered_map< int, vector<vector<int>> > mp;\n        for(int i=0; i<n; i++){\n            mp[i+1] = {};\n        }\n        for(int i=0; i<nq; i++){\n            int l = q[i][0];\n            int r = q[i][1];\n            int val = q[i][2];\n            for(int j=l; j <= r; j++){\n                mp[j+1].push_back({val, i+1});\n            }\n            // for(int j=0; j<n; j++){\n            //     if(j >= l && j <= r){\n            //         mp[j+1].push_back(val);\n            //     }\n            // }\n        }\n        int res = INT_MIN;\n        for(auto it : mp){\n            // vector<int> t = it.second;\n            int nt = it.second.size();\n            int tgt = a[it.first-1];\n            int op = help(tgt, nt, it.second);\n            \n            // cout << \"tgt = \"<<tgt << \", id= \"<< it.first-1 <<  endl;\n            // for(auto e : it.second){\n            //     cout << e[0] << \", \";\n            // }\n            // cout << \" OP = \"<< op << endl;\n            // cout << \"n--n\";\n            \n            if(op == -1)    \n                return -1;\n            res = max(res, op);\n        }\n        // cout << \"----n\";\n        return res;\n    }\n    int help(int tgt, int n, vector<vector<int>> &v){\n        if(!tgt)    return 0;\n        if(!n)  return -1;\n        vector<vector<int>> dp(n, vector<int>(tgt + 5, -1));\n        int op = fun(0, n, 0, tgt, dp, v);\n        return (op == -3 ? -1 : op);\n    }\n    int fun(int id, int n, int sum , int tgt, vector<vector<int>> &dp, vector<vector<int>> &v){\n        if(id >= n || sum > tgt)\n            return -3;\n        if(dp[id][sum] != -1)   \n                return dp[id][sum];\n        // pick \n        int b = v[id][0];\n        if(sum + b == tgt)  return v[id][1];\n        \n        int notPick = fun(id+1, n, sum , tgt, dp, v);\n        int pick = fun(id+1, n, sum + b, tgt, dp , v);\n        \n        if(pick == -3 && notPick == -3){\n            return dp[id][sum] = -3;\n        }\n        \n        if(pick == -3)  return dp[id][sum] = notPick;\n        else if(notPick == -3)  return dp[id][sum] = pick;\n        \n        return  dp[id][sum] = min(pick, notPick);\n    }\n};\n\n// [2,0,2]\n// [[0,2,1],[0,2,1],[1,1,3]]\n// [4,3,2,1]\n// [[1,3,2],[0,2,1]]\n// [1,2,3,2,1]\n// [[0,1,1],[1,2,1],[2,3,2],[3,4,1],[4,4,1]]\n// [1,2,3,2,6]\n// [[0,1,1],[0,2,1],[1,4,2],[4,4,4],[3,4,1],[4,4,5]]\n// [6,20,5,12,2]\n// [[3,3,5],[4,4,2],[4,4,3],[2,2,1],[2,3,4],[2,4,8],[3,4,3],[2,2,9],[4,4,3],[4,4,5]]","author":"Gopal Krushna","submissionId":"1575223898"},[]]},{"1300":[{"id":"1300","fileName":"1575224015.txt","sourceCode":"#define ll long long\n#define llint long long int\n#define double long double\n#define rep(i, a, b) for (int i = a; i <= b; i++)\n#define repL(i, a, b) for (long long i = a; i <= b; i++)\n#define nl 'n'\n#define yes cout << \"YES\" << nl\n#define no cout << \"NO\" << nl\ntypedef vector<int> vi;\ntypedef vector<ll> viL;\ntypedef vector<double> viD;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pll;\nconst int mod = 1e9 + 7;\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define F first\n#define S second\n#define PB push_back\n#define vvi vector<vector<int>>\n#define vviL vector<vector<ll>>\n#define vviD vector<vector<double>>\nclass Solution {\npublic:\n    int minZeroArray(vi& nums, vvi& queries) {\n        int n=nums.size();\n        vector<vector<bool>>check(n, vector<bool>(1001, false));\n        rep(i,0,n-1)check[i][0]=true;\n        bool isZ = all_of(all(nums), [](int x) {return x == 0;});\n        if (isZ) return 0;\n        rep(k,0,queries.size()-1){\n            int l=queries[k][0],r=queries[k][1],val=queries[k][2];\n            rep(i,l,r){\n                for(int j=1000-val;j>=0;j--)if(check[i][j])check[i][j+val]=true;\n            }\n            bool found = true;\n            rep(i,0,n-1){\n                if (!check[i][nums[i]]) {\n                    found = false;\n                    break;\n                }\n            }\n            if (found) return k + 1;\n        }\n        return -1;\n    }\n};","author":"Conqueror61m","submissionId":"1575224015"},[]]},{"1301":[{"id":"1301","fileName":"1575224314.txt","sourceCode":"class Solution:\n    def minZeroArray(self, A: List[int], Q: List[List[int]]) -> int:\n\n        if all(x == 0 for x in A):\n            return 0\n\n        def calc(el, arr):\n            if el == 0:\n                return True\n            if not arr:\n                return False\n            dp = [[False] * (len(arr) + 1) for _ in range(el + 1)]\n            for j in range(len(arr) + 1):\n                dp[0][j] = True\n            for i in range(1, el + 1):\n                for j in range(1, len(arr) + 1):\n                    dp[i][j] = dp[i][j - 1]\n                    if i >= arr[j - 1]:\n                        dp[i][j] = dp[i][j] or dp[i - arr[j - 1]][j - 1]\n            #print(f'{el}, {dp}')\n            return dp[-1][-1]\n\n        def canDo(x):\n            arr = defaultdict(list)\n            for kk in range(x):\n                i, j, v = Q[kk]\n                for idx in range(i, j + 1):\n                    arr[idx].append(v)\n            for i, a in enumerate(A):\n                #print(f'eval - {x}, {a}, {arr[i]}')\n                if not calc(a, arr[i]):\n                    return False\n            return True\n\n        # for i in range(1, len(Q) + 1):\n        #     if canDo(i):\n        #         return i\n        # return -1\n        \n        l, r = 1, len(Q) + 1\n        while l < r:\n            m = (l + r) // 2\n            if canDo(m):\n                r = m\n            else:\n                l = m + 1\n        return l if l <= len(Q) else -1\n        ","author":"ddveloper","submissionId":"1575224314"},[]]},{"1302":[{"id":"1302","fileName":"1575224394.txt","sourceCode":"class Solution {\npublic:\nint dp[1001][1001];\nint rec(vector<int>& nums, vector<vector<int>>& q,int i,int j,int num){\n\nif(num==0) return j-1;\n    if(j>=q.size()) return INT_MAX;\n    if(dp[j][num]!=-1) return dp[j][num];\n    int l=q[j][0];\n    int h=q[j][1];\n    int val=q[j][2];\n    int take=INT_MAX,nottake=INT_MAX;\n    if(i>=l&&i<=h){\n        if(val<=num){\n            take=min(take,rec(nums,q,i,j+1,num-val));\n        }\n    }\n    nottake=min(nottake,rec(nums,q,i,j+1,num));\n    return dp[j][num]=min(take,nottake);\n}\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n=nums.size();\n        int n2=q.size();\n        int ans=INT_MIN;\n        for(int i=0;i<n;i++){\n            memset(dp,-1,sizeof(dp));\n            ans=max(ans,rec(nums,q,i,0,nums[i]));\n        }\n        if(ans==INT_MAX) return -1;\n        return ans+1;\n    }\n};","author":"Ronak Rewar","submissionId":"1575224394"},[]]},{"1303":[{"id":"1303","fileName":"1575224437.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        vector<bool>zeo(n, false);\n        int z = 0, lasi = 0;\n        for(int i = 0; i < n; ++i){\n            if(nums[i] == 0){\n                zeo[i] = true;\n                ++z;\n            }\n        }\n        if(z == n){\n            return 0;\n        }\n        vector<vector<int>>pos(n);\n        vector<vector<bool>>ist(n, vector<bool>(1001, false));\n        vector<int> mink(n, -1);\n        vector<int>::iterator itr;\n        vector<int> cur;\n        for(int i = 0; i < q; ++i){\n            \n            int st = queries[i][0];\n            int en = queries[i][1];\n            int dec = queries[i][2];\n            for(int j = st; j <= en; ++j){\n                cur.clear();\n                if(mink[j] != -1 || zeo[j]){\n                    continue;\n                }\n                for(itr = pos[j].begin(); itr!= pos[j].end(); ++itr){\n                    if((*itr) + dec <=  nums[j] && (!ist[j][(*itr) + dec])){\n                         cur.push_back((*itr) + dec);\n                        ist[j][(*itr) + dec] = true;\n                    }\n                }\n                for(itr = cur.begin(); itr != cur.end(); ++itr){\n                    if((*itr) == nums[j]){\n                        mink[j] = i;\n                        ++z;\n                        lasi = i;\n                        \n                        break;\n                    }\n                    pos[j].push_back(*itr);\n                }\n                pos[j].push_back(dec);\n                if(dec == nums[j] && mink[j] == -1){\n                    mink[j] = i;\n                    ++z;\n                    lasi = i;\n                }\n            }\n            if(z == n){\n                return lasi + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"Krish_Kodes","submissionId":"1575224437"},[]]},{"1304":[{"id":"1304","fileName":"1575224381.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        k = 0\n        lnq = len(queries)\n        # dp = [[0]*lnq for _ in range(n)]\n\n        @cache\n        def func(i,value,k):\n            if value == 0:\n                # print(k)\n                return k\n            if k == lnq:\n                return float(\"inf\")\n            l, r, val = queries[k]\n            if i in range(l,r+1):\n                # if value == val:\n                #     return k + 1\n                if value >= val:\n                    take = func(i,value-val,k+1)\n                    not_take = func(i,value,k+1)\n                    return min(take,not_take)\n            return func(i,value,k+1)\n            \n        \n        # for num in nums\n        ans = 0\n        for i in range(n):\n            ans = max(ans,func(i,nums[i],0))\n            if ans == float(\"inf\"):\n                return -1\n        \n        # for i in range(n):\n        return ans","author":"Adarsh Gorai","submissionId":"1575224381"},[]]},{"1305":[{"id":"1305","fileName":"1575224362.txt","sourceCode":"#include <vector>\n#include <bitset>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isZeroArray(const vector<int>& nums) {\n        for (int num : nums) {\n            if (num != 0) {\n                return false;\n            }\n        }for (int i = 0; i < 1000; i++) {\n             }\n        return true;\n    }\n\n    void updateStates(vector<bitset<1001>>& states, const vector<int>& nums, int start, int end, int value) {\n        for (int i = 0; i < 1000; i++) {\n             }\n        for (int i = start; i <= end; i++) {\n            bitset<1001> temp;\n            \n            for (int i = 0; i < 1000; i++) {\n             }for (int j = 0; j < 1001 - value; j++) {\n                if (states[i][j]) {\n                    temp.set(j + value);\n                }\n            }\n            states[i] |= temp;\n            for (int i = 0; i < 1000; i++) {\n             }for (int i = 0; i < 1000; i++) {\n             }\n            for (int j = nums[i] + 1; j < 1001; j++) {\n                states[i].reset(j);\n            }\n        }\n    }\n\n    bool canConvertToZero(const vector<int>& nums, const vector<bitset<1001>>& states) {\n        for (int i = 0; i < 1000; i++) {\n             }\n        for (int i = 0; i < nums.size(); i++) {\n            if (!states[i][nums[i]]) {\n                return false;\n            }\n        }for (int i = 0; i < 1000; i++) {\n             }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        \n        for (int i = 0; i < 1000; i++) {\n             }\n        vector<bitset<1001>> states(n);\nfor (int i = 0; i < 1000; i++) {\n             }\n        for (int i = 0; i < n; i++) {\n            states[i].set(0);\n        }\nfor (int i = 0; i < 1000; i++) {\n             }\n        if (isZeroArray(nums)) {\n            return 0;\n        }\nfor (int i = 0; i < 1000; i++) {\n             }\n        for (int q = 0; q < queries.size(); q++) {\n            \n            updateStates(states, nums, queries[q][0], queries[q][1], queries[q][2]);\n            if (canConvertToZero(nums, states)) {\n                return q + 1;\n            }\n        }\nfor (int i = 0; i < 1000; i++) {\n             }\n        return -1;\n    }\n};\n","author":"Subrat Shakya","submissionId":"1575224362"},[]]},{"1306":[{"id":"1306","fileName":"1575224490.txt","sourceCode":"class Solution {\npublic:\n\nbool isSubsetSum(vector<int>& nums, int target) {\n    int n = nums.size();\n    vector<bool> dp(target + 1, false);\n    dp[0] = true;\n\n    for (int num : nums) {\n        for (int j = target; j >= num; --j) {\n            if (dp[j - num]) dp[j] = true;\n        }\n    }\n    \n    return dp[target];\n}\n\nbool isPoss(vector<int>nums,vector<vector<int>>&queries,int k){\n    int n = nums.size();\n    map<int,vector<int>>mp;\n    int cnt = 0;\n\n    for(int i=0;i<=k;i++){\n        int l = queries[i][0];\n        int r = queries[i][1];\n        for(int a=l;a<=r;a++){\n            mp[a].push_back(queries[i][2]);\n        }\n    }\n\n    for(auto it:mp){\n        sort(it.second.begin(),it.second.end());\n    }\n    // if(k==0){\n    //     for(auto it:mp[0])cout<<it<<\" \";\n    // }\n\n    for(int i=0;i<n;i++){\n        int sum = nums[i];\n        if(isSubsetSum(mp[i],sum))cnt++;\n    }\n\n    return cnt>=n;\n}\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n          int n = queries.size();\n\n        int ans = -1;\n\n        int s=0,e=n-1;\n        int c = 0;\n        for(auto it:nums)if(it<=0)c++;\n        if(c==nums.size())return 0;\n\n        while(s<=e){\n            int mid = (s + ((e-s)>>1));\n            // cout<<s<<' '<<e<<\" \"<<mid<<\" \";\n            if(isPoss(nums,queries,mid)){\n                ans = mid;\n                e = mid-1;\n            }\n            else {\n                s = mid+1;\n            }\n        }\n\n        return ans == -1 ? -1 : ans+1;\n    }\n};","author":"ROHIT","submissionId":"1575224490"},[]]},{"1307":[{"id":"1307","fileName":"1575224684.txt","sourceCode":"class Solution {\npublic:\n    bool targetPoss(vector<int>&temp,int tar,int ind,int sum,vector<vector<int>>&dp){\n        if(ind >= temp.size()){\n            if(sum == tar){\n                return true;\n            }\n            return false;\n        }\n        if(sum > tar){\n            return false;\n        }\n        if(dp[ind][sum] != -1){\n            return dp[ind][sum];\n        }\n        bool ans1 = targetPoss(temp,tar,ind+1,sum+temp[ind],dp);\n        bool ans2 = targetPoss(temp,tar,ind+1,sum,dp);\n        return dp[ind][sum] =  ans1 || ans2;\n    }\n    bool solve(vector<int>&nums,int n,vector<vector<int>>&queries,int k){\n        vector<vector<int>>temp(n,vector<int>());\n        for(int i =0;i<k;i++){\n            int u = queries[i][0];\n            int v = queries[i][1];\n            int val = queries[i][2];\n            for(int i=u;i<=v;i++){\n                temp[i].push_back(val);\n            }\n        }\n        for(int i =0;i<n;i++){\n            int tar = nums[i];\n            vector<int>& var = temp[i];\n            vector<vector<int>>dp(var.size(),vector<int>(tar+1,-1));\n            bool temp1 = targetPoss(var,tar,0,0,dp);\n            if(temp1 == false){\n                return false;\n            }\n        }\n        return true;\n        \n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int flag =0;\n        for(int i =0;i<n;i++){\n            if(nums[i] != 0){\n                flag =1;\n                break;\n            }\n        }\n        if(flag == 0){\n            return 0;\n        }\n        int ans =-1;\n        int st =1;\n        int end = queries.size();\n        while(st <= end){\n            int mid = (st + (end-st)/2);\n            if(solve(nums,n,queries,mid)){\n                ans = mid;\n                end = mid-1;\n            }\n            else{\n                st = mid+1;\n            }\n        }\n        return ans;\n    }\n};","author":"Piyush Jindal","submissionId":"1575224684"},[]]},{"1308":[{"id":"1308","fileName":"1575224756.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& arr, vector<vector<int>>& queries) {\n        int sum = accumulate(arr.begin(), arr.end(), 0);\n        if (sum == 0) {\n            return 0;\n        }\n        int ans = 0, n = arr.size();\n        vector<int> dp(1001, 0);\n        for (int i = 0; i < n; i++) {\n            dp[arr[i]] = 1;\n            for (int k = 0; k < queries.size(); k++) {\n                if (queries[k][0] <= i && queries[k][1] >= i) {\n                    int val = queries[k][2];\n                    if (dp[val]) {\n                        dp[0] = 1;\n                        ans = max(ans, k + 1);\n                        break;\n                    }\n                    for (int j = val; j <= arr[i]; j++) {\n                        if (dp[j]) {\n                            dp[j - val] = 1;\n                        }\n                    }\n                }\n            }\n            if (!dp[0]) {\n                return -1;\n            }\n            fill(dp.begin(), dp.end(), 0);\n        }\n        return ans;\n    }\n};","author":"whitemagic7456","submissionId":"1575224756"},[]]},{"1309":[{"id":"1309","fileName":"1575224459.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int top = 0, bot = queries.length, output = -1;\n        while(top<=bot){\n            int mid = (bot-top)/2 + top;\n            int temp[] = nums.clone();\n            HashMap<Integer,Integer> cal = new HashMap<>();\n            HashMap<Integer,List<Integer>> yo = new HashMap<>();\n            HashMap<Integer,List<Integer>> kl = new HashMap<>();\n            for(int i=0;i<mid;i++){\n                int row[] = queries[i];\n                yo.computeIfAbsent(row[0],s->new ArrayList<>()).add(row[2]);\n                kl.computeIfAbsent(row[1]+1,s->new ArrayList<>()).add(row[2]);\n            }\n            boolean check = true;\n            HashMap<Integer,Integer> process = new HashMap<>();\n            for(int i=0;i<temp.length;i++) { \n                List<Integer> process1 = kl.getOrDefault(i,new ArrayList<>());\n                for(int j:process1) { process.put(j,process.getOrDefault(j,0)-1); if(process.get(j) <= 0) process.remove(j); }\n                List<Integer> process2 = yo.getOrDefault(i,new ArrayList<>());\n                for(int j:process2) { process.put(j,process.getOrDefault(j,0)+1); }\n                List<Integer> process3 = new ArrayList<>();\n                for(int k:process.keySet()) for(int j=0;j<process.get(k);j++) process3.add(k);\n                //System.out.println(i+\"   \"+mid+\"  \"+process+\"   \"+process3+\"   \"+yo+\"   \"+kl);\n                check &= find(process3,temp[i]);\n                \n            }\n            if(check) { bot = mid-1; output = mid; }\n            else top = mid+1;\n        }\n        return output;\n    }\n    public boolean find(List<Integer> nums, int target) {\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n\n        for (int num : nums) {\n            for (int j = target; j >= num; j--) {\n                dp[j] = dp[j] || dp[j - num];\n            }\n        }\n        return dp[target];\n    }\n}","author":"jeet_jeet","submissionId":"1575224459"},[]]},{"1310":[{"id":"1310","fileName":"1575224685.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int m = queries.size(), n = nums.size();\n        vector<vector<pair<int,int>>> cover(n);\n        for (int j = 0; j < m; j++) {\n            int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n            for (int i = l; i <= r; i++) {\n                cover[i].push_back({j, val});\n            }\n        }\n        auto canAchieveCandidate = [&](int k) -> bool {\n            for (int i = 0; i < n; i++) {\n                int target = nums[i];\n                vector<int> coins;\n                for (auto &p : cover[i]) {\n                    if (p.first < k)\n                        coins.push_back(p.second);\n                }\n                vector<bool> dp(target + 1, false);\n                dp[0] = true;\n                for (int coin : coins) {\n                    for (int s = target; s >= coin; s--) {\n                        if (dp[s - coin])\n                            dp[s] = true;\n                    }\n                }\n                if (!dp[target])\n                    return false;\n            }\n            return true;\n        };\n        int left = 0, right = m, ans = -1;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (canAchieveCandidate(mid)) {\n                ans = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"chintapaktamtam","submissionId":"1575224685"},[]]},{"1311":[{"id":"1311","fileName":"1575224571.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def is_possible(num, new_nums):\n            n = len(new_nums)\n            dp = [[0 for _ in range(num + 1)] for _ in range(n + 1)]\n            dp[0][0] = 1\n            dp = [0] * (num + 1)\n            dp[0] = 1\n            for i in range(1, n + 1):\n                new_dp = [0] * (num + 1)\n                for j in range(num + 1):\n                    new_dp[j] = dp[j]\n                    prev = j - new_nums[i - 1]\n                    if prev >= 0:\n                        new_dp[j] += dp[prev]\n                dp = new_dp[::]\n            \n            return dp[num] != 0\n        \n        def is_valid(idx):\n            for i in range(n):\n                new_nums = []\n                for l, r, val in queries[:idx]:\n                    if l <= i <= r:\n                        new_nums.append(val)\n                if not is_possible(nums[i], new_nums):\n                    return False\n            return True\n        \n        n = len(nums)\n        q = len(queries)\n        if nums == [0] * n:\n            return 0\n        \n        lower = 0\n        upper = q\n        \n        if not is_valid(q):\n            return -1\n        \n        while lower < upper:\n            mid = (lower + upper) // 2\n            \n            if is_valid(mid):\n                upper = mid\n            else:\n                lower = mid + 1\n                \n        return lower","author":"Dang Huy Nguyen","submissionId":"1575224571"},[]]},{"1312":[{"id":"1312","fileName":"1575224919.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length,left = 0,right = queries.length;\n        if(!canMakeZeroArray(nums,right,queries)){\n            return -1;\n        }\n        while(left <= right){\n            int mid = left + (right-left)/2;\n            if(canMakeZeroArray(nums,mid,queries)){\n                right = mid-1;\n            }\n            else{\n                left = mid+1;\n            }\n        }\n        return left;\n    }\n    private boolean canMakeZeroArray(int[] nums,int k,int[][] queries){\n        int n = nums.length;\n        List<List<Integer>> list = new ArrayList<>();\n        for(int i=0;i<n;i++){\n            list.add(new ArrayList<>());\n        }\n        for(int i=0;i<k;i++){\n            int start = queries[i][0];\n            int end = queries[i][1];\n            int val = queries[i][2];\n            for(int x=start;x<=end;x++){\n                list.get(x).add(val);\n            }\n        }\n        for(int i=0;i<n;i++){\n            if(nums[i] == 0){\n                continue;\n            }\n            if(!targetSumPossible(list.get(i),nums[i])){\n                return false;\n            }\n        }\n        return true;\n    }\n    private boolean targetSumPossible(List<Integer> arr,int target){\n        int n = arr.size();\n        boolean[] dp = new boolean[target+1];\n        dp[0] = true;\n        for(int num:arr){\n            for(int j=target;j>=num;j--){\n                dp[j] = dp[j] || dp[j-num];\n            }\n        }\n        return dp[target];\n    }\n}","author":"Manideep Arruri","submissionId":"1575224919"},[]]},{"1313":[{"id":"1313","fileName":"1575224830.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        dp = []\n        for i in range(n):\n            clist = deque([[False]*(nums[i]+1)])\n            clist[0][0] = True\n            dp.append(clist)\n        res = []\n        cvalid = 0\n        for num in nums:\n            if num == 0:\n                res.append(True)\n            else:\n                res.append(False)\n                cvalid += 1\n        if cvalid == 0:\n            return 0\n\n        for i, (l, r, val) in enumerate(queries, 1):\n            for j in range(l,r+1):\n                if not res[j]:\n                    dp[j].append([val for val in dp[j][-1]])\n                    for k in range(nums[j],val-1,-1):\n                        dp[j][-1][k] |= dp[j][-2][k-val]\n\n                    if dp[j][-1][-1]:\n                        res[j] = True\n                        cvalid -= 1\n                        if cvalid == 0:\n                            return i\n\n                    dp[j].popleft()\n\n        return -1\n        ","author":"Practicer","submissionId":"1575224830"},[]]},{"1314":[{"id":"1314","fileName":"1575224789.txt","sourceCode":"class Solution:\n    def getSubsets(self, state):\n        subset = state\n        while subset:\n            yield subset\n            subset = (subset - 1) & state\n    \n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        @cache\n        def dfs(idx, j, num):\n            if idx == len(queries):\n                if num == 0: return 0\n                return len(queries) + 1\n            \n            if num == 0:\n                return 0\n\n            answer = dfs(idx+1, j, num) + 1\n            \n            l, r, v = queries[idx]\n            if l <= j and r >= j and v <= num:\n                answer = min(answer, dfs(idx+1, j, num-v) + 1)\n            return answer\n        \n        \n        n = len(nums)\n        m = len(queries)\n        result = [m+1] * n\n        for i in range(n):\n            result[i] = dfs(0, i, nums[i])\n            dfs.cache_clear()\n\n        answer = max(result)\n        if answer > m: return -1\n        return answer\n        \n            \n            \n            \n        \n        ","author":"Max Chang","submissionId":"1575224789"},[]]},{"1315":[{"id":"1315","fileName":"1575224720.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int ab=0;\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==0) ab++;\n        }\n        if(ab==nums.length) return 0;\n        int n = nums.length;\n        int qlen = queries.length;\n        \n        // Precompute for each index a list of queries (by their order and their value) that affect that index.\n        List<int[]>[] affect = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            affect[i] = new ArrayList<>();\n        }\n        // For each query, add it to all indices in its range.\n        for (int qi = 0; qi < qlen; qi++) {\n            int l = queries[qi][0], r = queries[qi][1], val = queries[qi][2];\n            l = Math.max(l, 0);\n            r = Math.min(r, n - 1);\n            for (int i = l; i <= r; i++) {\n                affect[i].add(new int[]{qi, val});\n            }\n        }\n        \n        // Binary search: find the minimum prefix (first mid queries) that can reduce every nonzero nums[i] to zero.\n        int lo = 1, hi = qlen;\n        int ans = -1;\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            boolean allZero = true;\n            // Check each position in nums\n            for (int i = 0; i < n; i++) {\n                if (nums[i] == 0) continue;\n                // Gather applicable query values for index i with query index < mid.\n                List<Integer> values = new ArrayList<>();\n                int total = 0;\n                for (int[] qdata : affect[i]) {\n                    if (qdata[0] < mid) {\n                        values.add(qdata[1]);\n                        total += qdata[1];\n                    } else {\n                        // Since queries are added in order, break early.\n                        break;\n                    }\n                }\n                // If available sum is less than needed, it's impossible.\n                if (total < nums[i]) {\n                    allZero = false;\n                    break;\n                }\n                \n                // Use BitSet DP for subset sum.\n                if (!subsetSum(nums[i], values)) {\n                    allZero = false;\n                    break;\n                }\n            }\n            if (allZero) {\n                ans = mid;\n                hi = mid - 1;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        return ans;\n    }\n    \n    // DP using BitSet: returns true if some subset of values sums exactly to target.\n    private boolean subsetSum(int target, List<Integer> values) {\n        BitSet dp = new BitSet(target + 1);\n        dp.set(0); // sum 0 is always achievable.\n        for (int v : values) {\n            // Shift dp left by v\n            dp.or(shiftLeft(dp, v, target));\n            if (dp.get(target)) {\n                return true;\n            }\n        }\n        return dp.get(target);\n    }\n    \n    // Shifts the BitSet dp to the left by v and returns a new BitSet,\n    // only keeping indices up to target.\n    private BitSet shiftLeft(BitSet dp, int v, int target) {\n        BitSet shifted = new BitSet(target + 1);\n        for (int i = dp.nextSetBit(0); i >= 0 && i + v <= target; i = dp.nextSetBit(i + 1)) {\n            shifted.set(i + v);\n        }\n        return shifted;\n    }\n}","author":"Abhinav","submissionId":"1575224720"},[]]},{"1316":[{"id":"1316","fileName":"1575225016.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n        if(*max_element(begin(nums),end(nums)) ==0) return 0;\n        set<int> s;\n        vector<vector<bool>> v(n);\n        for (int i=0;i<n; i++) {\n            v[i].resize(nums[i] + 1, false);\n            v[i][0] = true;\n            if (nums[i] == 0)\n                s.insert(i);\n        }\n        for (int i=0; i<q.size(); i++) {\n            int a=q[i][0],b = q[i][1],c = q[i][2];\n            for (int j = a; j <= b; j++) {\n                if (!s.count(j) && c <= nums[j]) {\n                    for (int t = nums[j]; t >= c; t--) {\n                        v[j][t] = v[j][t] || v[j][t - c];\n                    }\n                    if (v[j][nums[j]])\n                        s.insert(j);\n                }\n            }\n            if (s.size() == n)\n                return i + 1;\n        }\n        return -1;\n    }\n};\n","author":"Divyansh Aggarwal","submissionId":"1575225016"},[]]},{"1317":[{"id":"1317","fileName":"1575224958.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        int miniidx=-1;\n        int sz=queries.size();\n        int flg=0;\n        for(int i=0;i<n;i++){\n            if(nums[i]>0)flg=1;\n        }\n        if(!flg)return 0;\n        for(int i=0;i<n;i++){\n            int target=nums[i];\n            vector<vector<bool>>dp(sz+1,vector<bool>(target+1,false));\n            for(int j=0;j<sz;j++)dp[j][0]=true;\n            for(int idx=0;idx<sz;idx++){\n                for(int t=0;t<=target;t++){\n                    if(idx>0)dp[idx][t]=dp[idx-1][t];\n                if(queries[idx][0]<=i&&queries[idx][1]>=i&&t>=queries[idx][2]){\n                    if(idx>0)\n                    dp[idx][t]=(dp[idx][t]||(dp[idx-1][t-queries[idx][2]]));\n                    else{\n                        dp[idx][t]=(t==queries[idx][2]);\n                    }\n                }\n            }\n            }\n            int curr=1e9;\n            for(int j=0;j<sz;j++){\n                if(dp[j][target]){\n                    curr=j;\n                        break;\n                }\n            }\n            if(curr==1e9)return -1;\n            miniidx=max(miniidx,curr);\n        }\n        if(miniidx==-1)return -1;\n        return miniidx+1;\n    }\n};","author":"Tanmay khandelwal","submissionId":"1575224958"},[]]},{"1318":[{"id":"1318","fileName":"1575225196.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size(), INF = 1000000000, overall = 0;\n        vector<vector<int>> midQueries = queries;\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            vector<int> dp(target + 1, INF);\n            dp[0] = 0;\n            int earliest = INF;\n            for (int j = 0; j < q; j++) {\n                int l = midQueries[j][0], r = midQueries[j][1], val = midQueries[j][2];\n                if (i >= l && i <= r)\n                    for (int s = target - val; s >= 0; s--)\n                        if (dp[s] != INF && s + val <= target)\n                            dp[s + val] = min(dp[s + val], j + 1);\n                if (dp[target] != INF) { earliest = dp[target]; break; }\n            }\n            if (earliest == INF) return -1;\n            overall = max(overall, earliest);\n        }\n        return overall;\n    }\n};","author":"Prashun Raj","submissionId":"1575225196"},[]]},{"1319":[{"id":"1319","fileName":"1575224925.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(),q=queries.size();\n        int l=0,r=q,ans=q+1;\n        vector<vector<pair<int,int>>>ic(n);\n        for(int i=0;i<q;i++){\n            for(int j=queries[i][0];j<=queries[i][1];j++){\n                ic[j].push_back({i,queries[i][2]});\n            }\n        }\n        for(int i=0;i<n;i++)sort(ic[i].begin(),ic[i].end());\n        function<bool(int, int, int, int, vector<pair<int, int>>&, vector<vector<int>>&) > dpc =\n            [&](int i, int cs, int tv, int mid, vector<pair<int, int>>& curr, vector<vector<int>>& dp) -> bool {\n                if(cs==tv)return true;\n                if(cs>tv)return false;\n                if(i>=curr.size())return false;\n                if(curr[i].first>=mid)return false;\n                if(dp[i][cs]!=-1)return dp[i][cs];\n                bool ntk=dpc(i+1,cs,tv,mid,curr,dp);\n                bool tk=false;\n                if (cs + curr[i].second <= tv)tk =dpc(i+1,cs+curr[i].second,tv,mid,curr,dp);;\n                return dp[i][cs]=(tk||ntk);\n           };\n        auto f=[&](int mid)->bool{\n          for(int i=0;i<n;i++){\n              auto curr=ic[i];\n              vector<vector<int>>dp(curr.size()+1,vector<int>(nums[i]+1,-1));\n              if(!dpc(0,0,nums[i],mid,curr,dp))return false;\n          }\n          return true;\n        };\n        while(l<=r){\n            int mid=(l+r)>>1;\n            if(f(mid)){\n                ans=mid;\n                r=mid-1;\n            }else{\n                l=mid+1;\n            }\n        }\n        if(ans==q+1)return -1;\n        return ans;\n    }\n};","author":"ARYAN PUNDIR","submissionId":"1575224925"},[]]},{"1320":[{"id":"1320","fileName":"1575225059.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        \n        int st1 = 0;\n        int length = nums.size();\n        vector<bitset<1001>> bitsetTracker(length);\n        int mxt = 5;\n        map < int , int > mp;\n        \n        for( auto it : nums ) {\n            mp[it]++;\n            st1++;\n            \n            if( st1 > mxt) {\n                break;\n            }\n        }\n        \n        int count = 0;\n        for (int i = 0; i < length; i++) {\n            count++;\n            bitsetTracker[i].reset();\n            bitsetTracker[i].set(0);\n        }\n        \n        set< int > st;\n        int st2 = 0;\n        for( auto it : nums ) {\n            st.insert(it);\n            st2++;\n            \n            if( st2 > mxt) {\n                break;\n            }\n        }\n        \n        bool check = true;\n        int totalC =0;\n        bool hasNonZero = false;\n        for (int i = 0; i < length; i++) {\n            totalC++;\n            if (nums[i] != 0) {\n                hasNonZero = true;\n                totalC--;\n                check = false;\n                break;\n            }\n        }\n        if (!hasNonZero) return 0;\n        \n        \n        map < int , int > bigMap;\n        int dp1 = 0;\n        int dp2 = 0;\n        set< int > bigSet;\n        int insertCount = mxt; \n        \n        for (int qIndex = 0; qIndex < queries.size(); qIndex++) {\n            \n            int FindChhotaEle = 0;\n            int start = queries[qIndex][0];\n            int end = queries[qIndex][1];\n            set< int > unicSet1;\n            int increment = queries[qIndex][2];\n            \n            for (int i = start; i <= end; i++) {\n                bitsetTracker[i] |= (bitsetTracker[i] << increment);\n                for (int pos = nums[i] + 1; pos < 1001; pos++) {\n                    //unicSet1.insert(FindChhotaEle);\n                    bitsetTracker[i].reset(pos);\n                     if(insertCount > 0) {\n                         dp1++;\n                    bigMap[dp1]++;\n                    FindChhotaEle--;\n                    unicSet1.insert(FindChhotaEle);\n                    insertCount--;\n                     }\n                    \n                }\n            }\n            /* int count = 0;\n        for (int i = 0; i < length; i++) {\n            count++;\n            bitsetTracker[i].reset();\n            bitsetTracker[i].set(0);\n        }\n        \n        set< int > st;\n        int st2 = 0;\n        for( auto it : nums ) {\n            st.insert(it);\n            st2++;\n            \n            if( st2 > mxt) {\n                break;\n            }\n        } */\n            \n            int tc = 0;\n            bool isPossible = true;\n            for (int i = 0; i < length; i++) {\n                bool c = true;\n                //set< int > gg;\n                if (!bitsetTracker[i].test(nums[i])) {\n                    isPossible = false;\n                    dp2++;\n                    bigSet.insert(dp2);\n                    c= false;\n                    tc++;\n                    break;\n                }\n            }\n            if (isPossible) return qIndex + 1;\n        }\n        return -1;\n    }\n};","author":"BrainNotFound","submissionId":"1575225059"},[]]},{"1321":[{"id":"1321","fileName":"1575225157.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = max(nums)\n        if all([nums[i] == 0 for i in range(n)]):\n            return 0\n        \n        dp = [[False]*(m+1) for _ in range(n)]\n        for i in range(n):\n            dp[i][0] = True\n        count = 1\n        for l, r, val in queries:\n            for i in range(l, r+1):\n                if not dp[i][nums[i]]:\n                    for j in range(nums[i], val-1, -1):\n                        if dp[i][j-val]:\n                            dp[i][j] = True\n            completed = True\n            for i in range(n):\n                if not dp[i][nums[i]]:\n                    completed = False\n                    break\n            if completed:\n                return count\n            else:\n                count += 1\n        return -1","author":"fast benz","submissionId":"1575225157"},[]]},{"1322":[{"id":"1322","fileName":"1575225155.txt","sourceCode":"from functools import cache\nimport math\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        m = defaultdict(list)\n        for x in range(len(queries)):\n            i,j,v = queries[x]\n            for k in range(i,j+1):\n                m[k].append((v, x))\n\n        @cache\n        def f(n, i, count, vali):\n            if n==0:\n                return count\n            currVals = m[i]\n            if vali >= len(currVals):\n                return math.inf\n            currVal, currValIndex = currVals[vali]\n            currk = math.inf\n            diff = n-currVal\n            if diff >= 0:\n                currk = min(currk, f(diff, i, currValIndex+1, vali+1))\n            currk = min(currk, f(n, i, currValIndex+1, vali+1))\n            return currk\n\n        k = 0\n        for i in range(len(nums)):\n            ret = f(nums[i], i, 0, 0)\n            if ret == math.inf:\n                return -1\n            k = max(k, ret)\n\n        return k\n\n        \n            \n        ","author":"Jake Barris","submissionId":"1575225155"},[]]},{"1323":[{"id":"1323","fileName":"1575225232.txt","sourceCode":"class Solution {\npublic:\n    int dp[1001][1001];\n    int f2(int i,int t,vector<int>& a){\n        if(t == 0) return 1;\n        if(i == a.size()) return 0;\n        if(dp[i][t] != -1) return dp[i][t];\n        if(a[i] <=t) return dp[i][t] = f2(i+1,t-a[i],a) || f2(i+1,t,a);\n        return dp[i][t] = f2(i+1,t,a);\n    }\n    int f(int mid,vector<vector<int>>& q,vector<int>& nums){\n        int n = nums.size();\n        vector<int> a[n];\n        for(int i=0;i<mid;i++){\n            int l = q[i][0] , r = q[i][1] , v = q[i][2];\n            //cout<<l<<\" \"<<\" \"<<r<<endl;\n            for(int j=l;j<=r;j++) a[j].push_back(v);\n        }\n        // if(mid == 5){\n        //     for(int i=0;i<n;i++){\n        //         for(auto j:a[i]) cout<<j<<\" \";\n        //         cout<<endl;\n        //     }\n        // }\n        int ans = 1;\n        for(int i=0;i<n;i++) {\n            int l = a[i].size();\n            int t = nums[i];\n            for(int j=0;j<l;j++) for(int k=0;k<=t;k++) dp[j][k] = -1;\n            int x = f2(0,t,a[i]);\n            //if(mid == 5) cout<<x<<endl;\n            ans = (ans&x);\n            if(ans == 0) return 0;\n        }\n        return 1;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l = 0 , r= queries.size() , ans = -1;\n        while(l<=r){\n            int mid = (l+r)/2;\n            //cout<<mid<<endl;\n            if(f(mid,queries,nums)){\n                ans = mid;\n                r = mid-1;\n            }else l = mid+1;\n        }\n        return ans;\n    }\n};","author":"Ishan Gupta","submissionId":"1575225232"},[]]},{"1324":[{"id":"1324","fileName":"1575225108.txt","sourceCode":"class Solution {\npublic:\n    int n, m;\n    // bool can(vector<int>& nums, vector<vector<int>>& queries, int k){\n    //     vector<vector<int>> idxs(n);\n    //     for(int i = 0; i < k; i++){\n    //         int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n    //         for(int j = l; j <= r; j++){\n    //             idxs[j].push_back(val);\n    //         }\n    //     }\n\n    // }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        this->n = nums.size();\n        this->m = queries.size();\n        vector<int> req(n, INT_MAX);\n        for(int i = 0; i < n; i++){\n            if(nums[i] == 0){\n                req[i] = 0;\n                continue;;\n            }\n            vector<int> pos(1001, 0);\n            pos[0] = 1;\n            for(int j = 0; j < m; j++){\n                int val = 0;\n                if(queries[j][0] <= i && queries[j][1] >= i) val = queries[j][2];\n                vector<int> copy = pos;\n                for(int x = 0; x <= 1000; x++){\n                    if(pos[x] && x + val <= 1000){ \n                        copy[x + val] = 1;\n                    }\n\n                }\n                if(copy[nums[i]]) {\n                    req[i] = j + 1;\n                    break;\n                }      \n                swap(copy, pos);\n            }\n        }\n        int val = *max_element(req.begin(), req.end());\n        if(val == INT_MAX) return -1;\n        return val;\n    }\n};\n","author":"Suyash Jain","submissionId":"1575225108"},[]]},{"1325":[{"id":"1325","fileName":"1575225309.txt","sourceCode":"class Solution {\npublic:\n  bool check(int num, const vector<int>& arr ) {\n    int arr_size = arr.size();\n    // bool res = solve(arr, num, arr_size);\n    // return res;\n\n    vector<vector<bool>> L(num+1, vector<bool>(arr_size+1,false));\n    for ( int i = 0; i <= num; ++i ) {\n      for ( int j = 0; j <= arr_size; ++j ) {\n        if ( i == 0 ) {\n          L[i][j] = true;\n        }\n        else if ( j == 0 ) {\n          L[i][j] = false;\n        }\n        else {\n          bool t1 = L[i][j-1];\n          bool t2 = false;\n          if ( i - arr[j-1] >= 0 ) {\n            t2 = L[i - arr[j-1]][j-1];\n          }\n          bool sp = t1 || t2;\n          L[i][j] = sp;\n        }        \n      }\n    }\n    int res = L[num][arr_size];\n    return res;\n  }\n  \n  bool check(const vector<int>& nums, const vector<vector<int>>& queries, int k) {\n    int nums_size = nums.size();\n    vector<vector<int>> Q;\n    Q.resize(nums_size);\n    for ( int i = 0; i < k; ++i ) {\n      int l = queries[i][0];\n      int r = queries[i][1];\n      int val = queries[i][2];\n      for ( int j = l; j <= r; ++j ) {\n        Q[j].push_back(val);\n      }\n    }\n\n    for ( int i = 0; i < nums_size; ++i ) {\n      int num = nums[i];\n      bool p = check(num, Q[i]);\n      if ( !p ) {\n        return false;\n      }\n    }\n    return true;\n  }\n  \n  int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\n    int num_queries = queries.size();\n    int lo = 0;\n    int hi = num_queries+1;\n\n    while ( lo < hi ) {\n      // dbg(\"============\");\n      int k = (lo + hi ) / 2;\n      // dbg(lo);\n      // dbg(hi);\n      // dbg(k);      \n      bool p = check(nums, queries, k);\n      // dbg(p);\n      if ( p ) {\n        hi = k;\n      }\n      else {\n        lo = k + 1;\n      }\n    }\n    if ( lo == num_queries+1 ) {\n      return -1;\n    }\n    else {\n      return lo;\n    }\n  }  \n\n};","author":"John Friend","submissionId":"1575225309"},[]]},{"473":[{"id":"473","fileName":"1575169666.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        dp = [set() for _ in range(n)]\n\n        for j in range(n):\n            dp[j].add(0)\n\n        all_zero = all(num == 0 for num in nums)\n        if all_zero:\n            return 0\n\n        for k, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                new_dp = {x + v for x in dp[j]}\n                dp[j].update(new_dp)\n                dp[j] = {x for x in dp[j] if x < 1001}\n\n            all_achieved = all(nums[j] in dp[j] for j in range(n))\n            if all_achieved:\n                return k + 1\n\n        return -1\n\n","author":"Mohamed Abubakkar S","submissionId":"1575169666"},[{"id":"473","similarity":0.8846153846153846,"totOverlap":92,"longestOverlap":26}]],"1326":[{"id":"1326","fileName":"1575225447.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        d= [set() for _ in range(n)]\n        for j in range(n):\n            d[j].add(0)\n        if all(num == 0 for num in nums):\n            return 0\n        for u, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                up= {x + v for x in d[j]}  \n                d[j].update(up)\n                d[j] = {x for x in d[j] if x <= 1000} \n            if all(nums[j] in d[j] for j in range(n)):\n                return u + 1\n\n        return -1\n","author":"MADHASU SHIVA RAMA KRISHNA","submissionId":"1575225447"},[{"id":"1441","similarity":0.8648648648648649,"totOverlap":96,"longestOverlap":31},{"id":"1326","similarity":0.8846153846153846,"totOverlap":92,"longestOverlap":26}]],"1441":[{"id":"1441","fileName":"1575230657.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        dp = [set() for _ in range(n)]\n        \n        for j in range(n):\n            dp[j].add(0)\n        \n        if all(x == 0 for x in nums):\n            return 0\n        \n        for k, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                shifted = {i + v for i in dp[j] if i + v < 1001}\n                dp[j].update(shifted)\n                dp[j] = {x for x in dp[j] if x <= nums[j]}\n            \n            if all(nums[j] in dp[j] for j in range(n)):\n                return k + 1\n        \n        return -1","author":"hepzeyyy","submissionId":"1575230657"},[{"id":"1326","similarity":0.8648648648648649,"totOverlap":96,"longestOverlap":31}]]},{"1327":[{"id":"1327","fileName":"1575225286.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        // 檢查初始狀態：若所有 cell 已為 0，則答案為 0\n        bool allZero = true;\n        for (int x : nums) {\n            if (x != 0) { allZero = false; break; }\n        }\n        if (allZero) return 0;\n        \n        // 定義函數：使用前 k 個查詢能否使每個 cell 成功凈減到 0\n        auto canAchieve = [&](int k) -> bool {\n            for (int i = 0; i < n; i++) {\n                int target = nums[i];\n                // 收集前 k 個查詢中覆蓋 cell i 的所有 vali\n                vector<int> vals;\n                int total = 0;\n                for (int j = 0; j < k; j++) {\n                    int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                    if (l <= i && i <= r) {\n                        vals.push_back(val);\n                        total += val;\n                    }\n                }\n                // 如果累計值都不足以達到 target，直接返回 false\n                if (target > total) return false;\n                // 用位元組 dp 來解 subset sum\n                // dp[s] = true 表示 s 可達；最大 s 為 target，target 不會超過 10* k (k <= 1000 => 10,000)\n                bitset<10001> dp;\n                dp.reset();\n                dp[0] = 1;\n                for (int v : vals) {\n                    dp |= (dp << v);\n                    if (dp[target]) break;\n                }\n                if (!dp[target]) return false;\n            }\n            return true;\n        };\n        \n        // 二分搜尋最小的 k\n        int lo = 0, hi = m + 1;\n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (canAchieve(mid))\n                hi = mid;\n            else\n                lo = mid + 1;\n        }\n        return (lo > m) ? -1 : lo;\n    }\n};\n\n\n/*\n[8]\n[[0,0,9],[0,0,9],[0,0,1],[0,0,6],[0,0,1]]\nans = 5\n\n[12,12]\n[[0,1,4],[0,0,4],[0,0,8],[1,1,8],[0,0,1],[0,0,8],[0,1,4],[0,0,2],[1,1,3],[0,0,8],[0,0,3],[1,1,4],[0,1,7],[0,1,1],[0,1,7],[0,0,7],[1,1,8],[1,1,4],[0,1,1],[1,1,4],[0,0,10],[1,1,1],[1,1,8],[1,1,9],[1,1,4],[1,1,8],[1,1,4],[0,1,1],[1,1,7],[0,1,10],[1,1,7],[0,1,2],[1,1,10],[1,1,4],[0,0,10],[0,0,6],[0,0,5]]\n[14,8,15,14]\n[[0,1,6],[0,0,1],[0,1,3],[1,1,9],[0,3,10],[2,3,6],[0,0,8],[2,3,8],[0,1,9],[1,2,5],[0,3,10],[0,2,8],[0,1,3],[3,3,6],[1,1,4],[1,2,8],[0,2,5],[0,0,10],[1,3,1],[2,3,2],[1,3,2],[0,1,5],[0,0,1],[0,1,6],[3,3,8],[2,2,10],[3,3,10],[0,2,7],[1,2,10],[1,3,7],[2,2,5],[3,3,9],[0,3,10],[0,2,3],[3,3,1],[3,3,7],[1,1,6],[3,3,9],[0,3,10],[2,3,2],[1,3,3]]\n*/","author":"jcs_v1","submissionId":"1575225286"},[]]},{"1328":[{"id":"1328","fileName":"1575225543.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = -1;\n        int m = queries.size();\n        int n = nums.size();\n        int l = 0;\n        int r = m;\n        // vector<int> cache(1001, m);\n        \n        \n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            vector<vector<int>> join(n);\n            vector<vector<int>> leave(n);\n            \n            for (int i = 0; i < mid; i++) {\n                join[queries[i][0]].push_back(queries[i][2]);\n                leave[queries[i][1]].push_back(queries[i][2]);\n            }\n            \n            bool pass = true;\n            map<int, int> curr;\n            for (int i = 0; i < n; i++) {\n                for (auto x : join[i]) curr[x] += 1;\n                \n                int a = nums[i];\n                vector<int> dp(a+1, 0);\n                dp[0] = 1;\n                for (auto& [k, v] : curr) {\n                    if (k > a) break;\n                    vector<int> dp2 = dp;\n                    for (int j = 1; j <= v; j++) {\n                        for (int x = 0; x + k * j <= a; x++) {\n                            dp2[x + k * j] |= dp[x];\n                        }\n                    }\n                    swap(dp, dp2);\n                }\n                \n                if (dp[a] != 1) {\n                    pass = false;\n                    break;\n                }\n                \n                for (auto x : leave[i]) curr[x] -= 1;\n            }\n            \n            if (pass) {\n                ans = mid;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        \n        return ans;\n    }\n};","author":"huzy","submissionId":"1575225543"},[]]},{"1329":[{"id":"1329","fileName":"1575225375.txt","sourceCode":"class Solution:\n    # W441 @ 1h13m : 2m task + 21m idea + 18m code + 4 tests + 7m BUG | TOTAL = 62 min\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        # queries.sort()\n\n        k = 0\n        all_decrements = defaultdict(int)\n        starts = [[] for idx in range(n)]\n        ends = [[] for idx in range(n + 1)]\n        for idx, num in enumerate(nums):\n            for prev_delta in ends[idx]:\n                all_decrements[prev_delta] -= 1\n            for new_delta in starts[idx]:\n                all_decrements[new_delta] += 1\n            if num == 0:\n                continue\n\n            possible_sums = set([0])\n            for dec in all_decrements:\n                for _ in range(all_decrements[dec]):\n                    possible_sums |= set(v + dec for v in possible_sums)\n            \n            # need to get enough ops to decrement the value\n            fixed = False\n            while num not in possible_sums and k < m:\n                left, right, delta = queries[k]\n                k += 1\n                # if k in [4,5]: print(f\"DBG: v[{idx}]={num}, sums = {possible_sums}, decs={all_decrements}\")\n                if right < idx:\n                    continue\n                if left > idx:\n                    starts[left].append(delta)\n                else:\n                    all_decrements[delta] += 1\n                    possible_sums |= set(v + delta for v in possible_sums)\n                ends[right + 1].append(delta)\n            if num not in possible_sums:\n                # print(f\"failed at {idx}\")\n                return -1\n\n        return k\n\n\"\"\"Ideas:\n- solved all previous problems recently, remember all BS / greedy solutions\n- struggling with checking if a certain sum is possible given an array of current increments\n\"\"\"\n","author":"sergey_chebotarev","submissionId":"1575225375"},[]]},{"1330":[{"id":"1330","fileName":"1575225348.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        n = len(nums)\n\n        def is_zero(k):\n            # All of the possible subtractions to be made, sorted by index\n            summed = [[] for _ in range(n)]\n            for q in queries[:k]:\n                l, r, val = q\n                for i in range(l, r + 1):\n                    summed[i].append(val)\n\n            for i in range(n):\n                # Evaluate whether this is possible\n                target = nums[i]\n                options = summed[i]\n\n                @lru_cache(maxsize=None)\n                def can_sum(index, current):\n                    # Sum looks good\n                    if current == target:\n                        return True\n\n                    # Sum is impossible\n                    if index >= len(options) or current > target:\n                        return False\n\n                    # Skip num\n                    if can_sum(index + 1, current):\n                        return True\n\n                    # Use num\n                    if can_sum(index + 1, current + options[index]):\n                        return True\n\n                    return False\n\n                # Can't sum, prefix not possible for one number or more\n                if not can_sum(0, 0):\n                    return False\n\n            return True\n\n        if all(x == 0 for x in nums):\n            return 0\n\n\n        lo, hi = 1, len(queries)\n        ans = -1\n\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if is_zero(mid):\n                ans = mid\n                hi = mid - 1\n            else:\n                lo = mid + 1\n\n        return ans\n                ","author":"Mike Scornavacca","submissionId":"1575225348"},[]]},{"1331":[{"id":"1331","fileName":"1575225456.txt","sourceCode":"\n//C++ 17\n#include <bits/stdc++.h>\n\n#define ll signed long long\n#define ld long double\n// #define endl 'n'\n#define all(x) (x).begin(),(x).end()\n#define ar array\n#define vt vector\n#define vi vector<int>\n#define pb push_back\n#define sz(x) int((x).size())\n#define M(a,b) (((a-1)%b)+1)\n#define yes(a) {cout<<((a)?\"YES\":\"NO\");return ;}\n#define yr(a,b) if(a)yes(b)\n#define cdiv(a,b) ((a+(b)-1)/(b))\n#define cfind(sr,el) (sr.find(el)!=sr.end())\n\n#define EACH(iterable) for(auto & itr : iterable)\n#define FOR_MAIN(i,s,e,u) for(int i = s ; i < e;i+=u)\n#define FOR_1(n) FOR_MAIN(i,0,n,1)\n#define FOR_2(i,n) FOR_MAIN(i,0,n,1)\n#define FOR_3(i,s,e) FOR_MAIN(i,s,e,1)\n#define FOR_4(i,s,e,u) FOR_MAIN(i,s,e,u)\n#define GET_LOOP(a,b,c,d,e,...) e\n#define FOR(...) GET_LOOP(__VA_ARGS__,FOR_4,FOR_3,FOR_2,FOR_1)(__VA_ARGS__)\n#define GI_1(x) >>x\n#define GI_2(a,b)     GI_1(a)GI_1(b)\n#define GI_3(a,b,c)   GI_2(a,b)GI_1(c)\n#define GI_4(a,b,c,d) GI_3(a,b,c)GI_1(d)\n#define GI(...) int __VA_ARGS__ ;cin GET_LOOP(__VA_ARGS__,GI_4,GI_3,GI_2,GI_1)(__VA_ARGS__)\nusing namespace std;\n\n#ifdef LOCAL\n    #include \"algorithms/dbg.h\"\n#else\n    #define dbg(...)\n    #define dbgarr(...)\n    #define PTC // cout<<\"Case #\"<<i<<\": \"\n#endif\n\nconst int mod = 1'0;//998'244'353;\nconst int UL5 = 5'00'007,UL6  = 1'000'007,UL25 = 2'00'007,UL8  = 1'00'000'007;\ntemplate<class T1,class T2> inline bool umax(T1 &a,const T2 &b){return (a < b)?a = b,1:0;} // a==b\ntemplate<class T1,class T2> inline bool umin(T1 &a,const T2 &b){return (a > b)?a = b,1:0;}\ntemplate<class T> void input(T arr[] , int n){ FOR(n) cin>>arr[i]; }\ntemplate<class T> void print(const T arr[] , int n){ FOR(n)cout<<arr[i]<<' ';}\ntemplate<class T> istream& operator >> (istream& in ,vector<T>& arr){ EACH(arr) in>>itr; return in; }\ntemplate<class T> ostream& operator << (ostream& out, const vector<T>& arr){ EACH(arr) out<<itr<<\" \"; return out; }\ntemplate<class T,size_t size> istream& operator >> (istream& in ,ar<T,size>& arr){ FOR(size) in>>arr[i]; return in; }\ntemplate<class T,size_t size> ostream& operator << (ostream& out ,const ar<T,size>& arr){ FOR(size) out<<arr[i]<<' '; return out; }\ntemplate<class T1,class  T2> istream& operator >> (istream& in ,pair<T1,T2>& p){ in>>p.first>>p.second; return in; }\ntemplate<class T1, class T2> ostream& operator << (ostream& out ,const pair<T1,T2>& p){ out<<p.first<<\" \"<<p.second; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const deque<T>& arr){ EACH(arr) out<<itr<<\" \"; return out; }\n\n\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        if(accumulate(all(nums),0)==0){\n            return 0;\n        }\n        int n = nums.size();\n        int m = queries.size();\n        int s=  0,e = m;\n        while(s<e){\n            int mid = s+(e-s)/2;\n            // int pre[n+1];\n            vector<int> pre[n+1];\n            multiset<int> to_rem[n+1];\n            memset(pre,0,sizeof(pre));\n            for(int i = 0 ;i<=mid;i++){\n                pre[queries[i][0]].push_back(queries[i][2]);\n                to_rem[queries[i][1]+1].insert(queries[i][2]);\n            }\n            bool pos = 1;\n            for(int i = 0 ;i<n;i++){\n                if(i){\n                    for(int j: pre[i-1]){\n                        auto it = to_rem[i].find(j);\n                        if(it!=to_rem[i].end()){\n                            to_rem[i].erase(it);\n                        }\n                        else{\n                            pre[i].push_back(j);\n                        }\n                    }\n                }\n                if(to_rem[i].size()!=0){\n                    cout<<\"FAILURE\"<<endl;\n                }\n                // cout<<mid<<endl;\n                // cout<<pre[i]<<endl;\n                if(!can_make(pre[i], nums[i])){\n                    pos = 0;\n                    break;\n                }\n            }\n            if(!pos){\n                s = mid+1;\n            }\n            else{\n                e = mid;\n            }\n        }\n        \n        return s==m?-1:++s;\n    }\n    bool can_make(vector<int>& pre, int val){\n        int dp[val+1];\n        memset(dp,0,sizeof(dp));\n        dp[0] = 1;\n        for(int i: pre){\n            for(int j = val;j>=i;j--){\n                dp[j]|=dp[j-i];\n            }\n        }\n        return dp[val]==1;\n    }\n};\n\n\n\n\n\n","author":"CHANDRAPRABHU","submissionId":"1575225456"},[]]},{"1332":[{"id":"1332","fileName":"1575225633.txt","sourceCode":"class Solution {\n    public int canSum(List<int[]> nums, int target) {\n        BitSet dp = new BitSet(10001);\n        dp.set(0);\n        int last = -2;\n\n        for (int[] x : nums) {\n            for (int j = target; j >= x[0]; j--) {\n                if (dp.get(j - x[0]) && !dp.get(j)) {\n                    dp.set(j);\n                }\n                if (dp.get(target)) {\n                    return x[1];\n                }\n            }\n        }\n\n        return -2;\n    }\n    public int minZeroArray(int[] nums, int[][] queries) {\n        Map<Integer, List<int[]>> gfg = new HashMap<>();\n        int ans = -1;\n        int j = 0;\n\n        for (int[] it : queries) {\n            int l = it[0], r = it[1], val = it[2];\n            for (int i = l; i <= r; i++) {\n                gfg.putIfAbsent(i, new ArrayList<>());\n                gfg.get(i).add(new int[]{val, j});\n            }\n            j++;\n        }\n\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) continue;\n            int a = canSum(gfg.getOrDefault(i, new ArrayList<>()), nums[i]);\n            if (a == -2) return -1;\n            ans = Math.max(ans, a);\n        }\n        return ans + 1;\n    }\n}","author":"phemon3466","submissionId":"1575225633"},[]]},{"1333":[{"id":"1333","fileName":"1575225583.txt","sourceCode":"class Solution {\nprivate:\n    bool check(vector<int>& nums, vector<vector<int>>& queries, int k) {\n        int n = nums.size();\n        \n        for(int i=0; i<n; i++) {\n            vector<int> vals;\n            for(int j=0; j<k; j++){\n                int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                if(l <= i && i <= r)\n                    vals.push_back(val);\n            }\n\n            vector<bool> dp(nums[i]+1, false);\n            dp[0] = true;\n            for(int val : vals){\n                for(int s=nums[i]; s>=val; s--){\n                    dp[s] = dp[s] || dp[s-val];\n                }\n            }\n\n            if(!dp[nums[i]]) return false;\n        }\n        return true;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = queries.size();\n        int l = 0, r = n + 1;\n        \n        while (l < r) {\n            int mid = (l + r) / 2;\n            bool result = check(nums, queries, mid);\n            // cout << \"result: \" << result << endl;\n            if (result) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l <= n ? l : -1;\n    }\n};","author":"tsehsuan1102","submissionId":"1575225583"},[]]},{"1334":[{"id":"1334","fileName":"1575225566.txt","sourceCode":"def can_complete(num, vals, i=0) -> bool:\n    if num == 0 or sum(vals[i:]) == num:\n        return True\n    elif num < 0:\n        return False\n    elif i == len(vals):\n        return False\n\n    if can_complete(num-vals[i], vals, i+1) or can_complete(num, vals, i+1):\n        return True\n\n    return False\n    \n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, m = len(nums), len(queries)\n        \n        # Check for zero array\n        completed = [False]*n\n        for i in range(n):\n            if nums[i] == 0:\n                completed[i] = True\n\n        if all(completed):\n            return 0\n        \n\n        \n        vals = [[] for _ in range(n)]\n        k = 0\n        for l, r, val in queries:\n            k += 1\n            for i in range(l, r+1):\n                if not completed[i]:\n                    vals[i].append(val)\n                    if sum(vals[i]) >= nums[i] and can_complete(nums[i], vals[i]):\n                        completed[i] = True       \n\n            if all(completed):\n                break\n\n        return -1 if not all(completed) else k","author":"KNuggies","submissionId":"1575225566"},[]]},{"1335":[{"id":"1335","fileName":"1575225683.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(),max1;\n        int q=queries.size();\n        max1=0;\n        for(int i=0;i<n;i++){\n            if(nums[i]==0)continue;\n            map<int,int>m;\n            int t=0;\n            m[nums[i]]++;\n            for(int z=0;z<q;z++){\n                int val=queries[z][2];\n                if(queries[z][0]<=i && queries[z][1]>=i){\n                    if(m.find(val)!=m.end()){\n                        t=1;\n                        max1=max(max1,z+1);\n                        break;\n                    }\n                    vector<int>v;\n                    for(auto p:m){\n                        if(p.first>val)\n                        v.push_back(p.first-val);\n                    }\n                    for(auto p:v){\n                        m[p]++;\n                    }\n                    //cout<<m.size()<<\" \"<<v.size()<<endl;\n                }\n            }\n            //cout<<i<<\" \";\n            if(t==0)return -1;\n            m.clear();\n        }\n        //cout<<endl;\n        return max1;\n    }\n};","author":"giridhar123456","submissionId":"1575225683"},[]]},{"1336":[{"id":"1336","fileName":"1575225644.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        \n        int n=nums.size();\n        bool ok=true;\n        \n        for(int i=0;i<n;i++){\n            if(nums[i]){\n                ok=false;\n                break;\n            }\n        }\n        \n        if(ok)return 0;\n        \n        int m=queries.size();\n        \n        vector<vector<bool>> dp(1001,vector<bool>(n)),prv(1001,vector<bool>(n));\n        for(int i=0;i<n;i++){\n            prv[0][i]=true;\n        }\n        \n        for(int k=0;k<m;k++){\n            ok=true;\n            for(int j=0;j<n;j++){\n                for(int i=0;i<=1000;i++){\n                    dp[i][j]=prv[i][j];\n                    if(dp[i][j]==false){\n                        if(queries[k][0]<=j && queries[k][1]>=j && i>=queries[k][2]){\n                            dp[i][j]=prv[i-queries[k][2]][j];\n                        }\n                    }\n                }\n                if(dp[nums[j]][j]==false)ok=false;\n            } \n            if(ok)return k+1;\n            swap(dp,prv);\n        }\n        return -1;\n    }\n};","author":"Lovish Dua","submissionId":"1575225644"},[]]},{"1337":[{"id":"1337","fileName":"1575225676.txt","sourceCode":"class Solution {\npublic:\n#define ll int\nbool isSubsetSum(const vector<int>& vec, int targetSum) {\n    int n = vec.size();\n    // Create a DP table. dp[i][j] is true if sum j can be achieved with first i elements.\n    vector<vector<bool>> dp(n + 1, vector<bool>(targetSum + 1, false));\n\n    // Initialize: A sum of 0 is always possible with 0 elements.\n    for (int i = 0; i <= n; i++)\n        dp[i][0] = true;\n\n    // Fill the DP table\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= targetSum; j++) {\n            if (vec[i - 1] > j)\n                dp[i][j] = dp[i - 1][j]; // Ignore current element\n            else\n                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - vec[i - 1]];\n        }\n    }\n\n    return dp[n][targetSum];\n}\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n       ll n = nums.size(),m = queries.size();\nauto Ok = [&](ll k) -> bool{\n    vector<ll>temp = nums;\n    for(ll j=0;j<n;j++){\n        vector<ll>add;\n    for(ll i=0;i<k;i++){\n      ll l = queries[i][0],r = queries[i][1], val = queries[i][2];\n         if(j>=l && j<=r) add.push_back(val); \n       }  \n      // sort(add.begin(),add.end(),greater<ll>();\n      if(isSubsetSum(add,temp[j])) temp[j]=0; \n    }\n    bool fg=true;\n  for(ll i=0;i<n;i++){\n      if(temp[i]>0) fg=false;\n  }   \n    return fg;\n  };\n  ll lo=0,hi=m,ans=m+1;\n  while(hi-lo>=0){\n    ll mid = (hi+lo)/2;\n    if(Ok(mid)){\n        ans = min(ans,mid);\n        hi = mid-1;\n    }\n    else lo = mid+1;\n  }  \n    if(ans==m+1) return -1;\n        return ans;\n    }\n};","author":"Aun Abbas","submissionId":"1575225676"},[]]},{"1338":[{"id":"1338","fileName":"1575225688.txt","sourceCode":"class Solution {\n    \n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        boolean[][] dp;\n        boolean isAllZero = true;\n        \n        for (int num : nums) {\n            if (num != 0) isAllZero = false;\n        }\n        \n        if (isAllZero) return 0;\n        \n        dp = new boolean[n][];\n        for (int i = 0; i < n; i++) {\n            dp[i] = new boolean[nums[i] + 1];\n            dp[i][0] = true;\n        }\n\n        for (int mid = 0; mid < queries.length; mid++) {\n            int l = queries[mid][0], r = queries[mid][1], val = queries[mid][2];\n\n            for (int i = l; i <= r; i++) {\n                for (int j = dp[i].length - 1 - val; j >= 0; j--) {\n                    if (dp[i][j]) dp[i][j + val] = true;\n                }\n            }\n\n            boolean isZeroArray = true;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i][nums[i]]) {\n                    isZeroArray = false;\n                    break;\n                }\n            }\n\n            if (isZeroArray) return mid + 1;\n        }\n\n        return -1;\n    }\n}\n","author":"shuaibahmedshaikh7","submissionId":"1575225688"},[]]},{"1339":[{"id":"1339","fileName":"1575225649.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], qs: List[List[int]]) -> int:\n        n = len(nums)\n        nq = len(qs)\n        \n        def check(x):\n            vs = [[] for _ in range(n)]\n            for i in range(x):\n                l, r, v = qs[i]\n                for j in range(l, r+1):\n                    vs[j].append(v)\n            for i in range(n):\n                b = [0] * (nums[i] + 1)\n                b[0] = 1\n                for v in vs[i]:\n                    for j in range(nums[i], 0, -1):\n                        if j - v >= 0 and b[j - v]:\n                            b[j] = 1\n                if not b[nums[i]]:\n                    return False\n            return True\n        \n        if not check(nq):\n            return -1\n        if max(nums) == 0:\n            return 0\n        l, r = 1, nq\n        while l < r:\n            mi = (l + r) >> 1\n            if check(mi):\n                r = mi\n            else:\n                l = mi + 1\n        return l","author":"xs_pg","submissionId":"1575225649"},[]]},{"1340":[{"id":"1340","fileName":"1575225732.txt","sourceCode":"class Solution {\n    void printA(vector<unordered_set<int>>& A) {\n        cout << \" A \" << endl;\n        for(int j = 0; j < A.size(); j++) {\n            for(auto& a: A[j]) {\n                cout << \" \" << a;\n            }\n            cout << endl;\n        }\n        cout << endl;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<unordered_set<int>> A(n, {0});\n        bool bFinished = true;\n        \n        for(auto& num: nums) {\n            if(num) {\n                bFinished = false;\n                break;\n            }\n        }\n\n        if(bFinished) return 0;\n\n\n        for(int i = 0; i < queries.size(); i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n\n            //cout << \" i \" << i << \" l \" << l << \" r \" << r << \" val \" << val << endl;\n            //printA(A);\n\n            for(int j = l; j <= r; j++) {\n                unordered_set<int> next({0});\n                for(auto& a: A[j]) {\n                    int next_a = a + val;\n                    next.insert(a);\n                    if(next_a <= nums[j]) {\n                        next.insert(next_a);\n                    }\n                }\n                A[j] = next;\n            }\n            //printA(A);\n\n            bFinished = true;\n            for(int j = 0; j < n; j++) {\n                if(!A[j].count(nums[j])) {\n                    bFinished = false;\n                    break;\n                }\n            }\n            \n            if(bFinished) return i + 1;\n        }\n\n        return -1;\n    }\n};","author":"溫俊維","submissionId":"1575225732"},[]]},{"1341":[{"id":"1341","fileName":"1575225913.txt","sourceCode":"import java.util.*;\nclass Solution\n{\n    public int minZeroArray(int[] a, int[][] q) {\n        int n=a.length;\n        BitSet[] dp=new BitSet[n];\n        for(int j=0;j<n;j++)\n        {\n            dp[j]=new BitSet(1001);\n            dp[j].set(0);\n        }\n        boolean p=Arrays.stream(a).allMatch(x->x==0);\n        if(p)\n            return 0;\n        for(int k=0;k<q.length;k++)\n        {\n            int l=q[k][0],r=q[k][1],v=q[k][2];\n            for (int j=l;j<=r;j++)\n            {\n                BitSet s=new BitSet(1001);\n                for (int i=0;i<1001-v;i++)\n                    if (dp[j].get(i))\n                        s.set(i+v);\n                dp[j].or(s);\n                dp[j].clear(a[j]+1, 1001);\n            }\n            boolean x = true;\n            for(int j=0;j<n;j++)\n                if (!dp[j].get(a[j]))\n                {\n                    x=false;\n                    break;\n                }\n            if(x)\n                return k+1;\n        }\n        return -1;\n    }\n}","author":"Arkaprabha De","submissionId":"1575225913"},[]]},{"1342":[{"id":"1342","fileName":"1575225766.txt","sourceCode":"class Solution {\npublic:\n    bool solve(const vector<int>& coins, int target, int p) {\n        vector<bool> dp(target + 1, false);\n        dp[0] = true;\n        for (int c : coins) {\n            for (int t = target; t >= c; t--) {\n                if (dp[t - c])\n                    dp[t] = true;\n            }\n        }\n        int k = dp[target];\n        return k;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        \n        int m = queries.size();\n        unordered_map<int,int>x;\n        int n = nums.size();\n\n        \n        \n        vector<vector<pair<int, int>>> iqs(n);\n        for (int i = 0; i < m; i++) {\n            int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                iqs[j].push_back({i, v});\n            }\n        }\n\n        int k = 0;\n        int hi = m + 1 -k;\n        \n        int lo = 0;\n        \n        while (lo < hi) {\n            int md = lo + (hi - lo) / 2;\n            bool pos = true;\n            for (int j = 0; j < n; j++) {\n                vector<int> cns;\n                for (auto &pr : iqs[j]) {\n                    if (pr.first < md)\n                        cns.push_back(pr.second);\n                }\n                if (!solve(cns, nums[j], 0)) {\n                    pos = false;\n                    break;\n                }\n            }\n            if (pos) {\n                hi = md;\n            } else {\n                lo = md + 1;\n            }\n        }\n        \n        if (lo > m) {\n            return -1;\n        } else {\n            int res=  lo;\n            return res;\n        }\n    }\n};\n","author":"piyushlokhande07","submissionId":"1575225766"},[]]},{"1343":[{"id":"1343","fileName":"1575225845.txt","sourceCode":"class Solution {\n    boolean subset(int arr[],int i,int t,Map<String,Boolean> m)\n    {\n        if(t==0) return true;\n        if(i>=arr.length) return false;\n        String key=i+\",\"+t;\n        if(m.containsKey(key)) return m.get(key);\n        if(subset(arr,i+1,t,m))\n        {\n            m.put(key,true);\n            return true;\n        }\n        if(arr[i]<=t && subset(arr,i+1,t-arr[i],m))\n        {\n            m.put(key,true);\n            return true;\n        }\n        m.put(key,false);\n        return false;\n    }\n    boolean solve(int nums[],int q[][],int mid)\n    {\n        int n=nums.length;\n        for(int i=0;i<n;i++)\n            {\n                int t=nums[i];\n                if(t==0) continue;\n                List<Integer> list=new ArrayList<>();\n                for(int j=0;j<=mid;j++)\n                    {\n                        if(i>=q[j][0] && i<=q[j][1])\n                        {\n                            list.add(q[j][2]);\n                        }\n                    }\n                int arr[]=new int[list.size()];\n                Map<String,Boolean> m=new HashMap<>();\n                for(int k=0;k<arr.length;k++)\n                    {\n                        arr[k]=list.get(k);\n                    }\n                if(!subset(arr,0,t,m)) return false;\n            }\n        return true;\n        \n    }\n    public int minZeroArray(int[] nums, int[][] q) {\n        int n=nums.length;\n        boolean b=false;\n        for(int i=0;i<n;i++)\n            {\n                if(nums[i]>0)\n                {\n                    b=true;\n                    break;\n                }\n            }\n        if(!b) return 0;\n        int s=0;\n        int e=q.length-1;\n        int ans=-2;\n        while(s<=e)\n            {\n                int mid=s+(e-s)/2;\n                if(solve(nums,q,mid))\n                {\n                    ans=mid;\n                    e=mid-1;\n                }\n                else s=mid+1;\n            }\n        return ans+1;\n    }\n}","author":"Tipris SravanKumar","submissionId":"1575225845"},[]]},{"1344":[{"id":"1344","fileName":"1575226003.txt","sourceCode":"#define dbg(x...) cout << \"[\" << __LINE__ - 9 << \"]t[ \" << #x << \" ]tt\"; debug_struct::_print(x); cout << endl;\n#define debug(x,y...) cout << \"[\" << __LINE__ - 9 << \"]t[ \" << #x << \" ]tt\"; debug_struct::_print(y); cout << endl;\n#define crndl cout << endl;\n\n// #define dbg(...) ;\n// #define debug(...) ;\n// #define crndl ;\n\nstruct debug_struct {\n    template <typename T> static void _print(T t) { cout << t; }\n    static void _print() { return; }\n    template <class T> static void _print(vector <T> v) {cout << \"[ \"; for (T i : v) {_print(i); cout << \" \";} cout << \"]\";}\n    template <class T> static void _print(deque <T> d) {cout << \"[ \"; for (T i : d) {_print(i); cout << \" \";} cout << \"]\";}\n    template <class T> static void _print(queue <T> q) {cout << \"[ \"; while (!q.empty()) {_print(q.front()); cout << \" \"; q.pop();} cout << \"]\";}\n    template <class T> static void _print(stack<T> s) { cout << \"[ \"; while (!s.empty()) { _print(s.top()); cout << \" \"; s.pop(); } cout << \"]\"; }\n    template <class T, size_t S> static void _print(array<T, S> a) {cout << \"[ \"; for (T i : a) {_print(i); cout << \" \";} cout << \"]\";}\n    template <class T, class V> static void _print(set <T, V> st) {cout << \"[ \"; for (T i : st) {_print(i); cout << \" \";} cout << \"]\";}\n    template <class T, class V> static void _print(multiset <T, V> st) {cout << \"[ \"; for (T i : st) {_print(i); cout << \" \";} cout << \"]\";}\n    template <class T, class V> static void _print(priority_queue<T, vector<T>, V> pq) {cout << \"[ \"; while (!pq.empty()) {_print(pq.top()); cout << \" \"; pq.pop();} cout << \"]\";}\n    template <class T, class V> static void _print(pair <T, V> p) {cout << \"{\"; _print(p.first); cout << \",\"; _print(p.second); cout << \"}\";}\n    template <class T, class V> static void _print(T a[], V n) { cout << \"[ \"; for(int i = 0; i < n; i++) { _print(a[i]); cout << \" \"; } cout << \"]\"; }\n    template <class T, class V> static void _print (T* a, V n, V m) { cout << \"[ \"; for(int i = 0; i < n; i++) { _print(a + i * m, m); cout << \" \"; } cout << \"]\"; }\n    template <class T, class V, class Compare> static void _print(unordered_map <T, V, Compare> mp) {cout << \"[ \"; for (auto &i : mp) {_print(i); cout << \" \";} cout << \"]\";}\n    template <class T, class V, class Compare> static void _print(map <T, V, Compare> mp) {cout << \"[ \"; for (auto &i : mp) {_print(i); cout << \" \";} cout << \"]\";}\n    template <class T, class... V> static void _print(T t, V... v) { _print(t); if (sizeof...(v)) { cout << \", \"; _print(v...); } }\n    // template<typename T, typename ComparatorFn> static void _print(oset<T, ComparatorFn> st) {cout << \"[ \"; for (auto i : st) {_print(i); cout << \" \";} cout << \"]\";}\n};\n\nclass Solution {\npublic:\n    bool tryDp(vector<int> &a, int target) {\n        int n = a.size();\n        vector<int> dp(target + 1);\n        dp[0] = 1;\n        for (int i = 0; i < n; i++) {\n            vector<int> ndp = dp;\n            for (int j = 0; j <= target; j++) {\n                if (dp[j] && j + a[i] <= target) ndp[j + a[i]] = 1;\n            }\n            dp = ndp;\n        }\n        dbg(dp);\n        return dp[target];\n    }\n    \n    bool canDo(vector<int> &nums, vector<vector<int>> &queries, int nq) {\n        int n = nums.size();\n        dbg(nq);\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            vector<int> a;\n            for (int j = 0; j < nq; j++) {\n                if (i >= queries[j][0] && i <= queries[j][1]) {\n                    a.push_back(queries[j][2]);\n                }\n            }\n            if (!tryDp(a, target)) return false;\n        }\n        return true;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int s = 0, e = queries.size(), ans = -1;\n        while (s <= e) {\n            int m = (s + e) / 2;\n            if (canDo(nums, queries, m)) ans = m, e = m - 1;\n            else s = m + 1;\n            crndl;\n        }\n        return ans;\n    }\n};","author":"systumm","submissionId":"1575226003"},[]]},{"1345":[{"id":"1345","fileName":"1575225954.txt","sourceCode":"class Solution {\npublic:\n    vector<vector<vector<int>>> dp;\n\n    int solve(vector<vector<int>>& q, int x, int id, int i) {\n        if(i >= q.size()) return (x == 0) ? i : 1e9;\n        if(x == 0) return i;\n        if(dp[i][x][id] != -1) return dp[i][x][id];\n        int nottake = solve(q, x, id, i + 1);\n        int take = 1e9;\n        if((q[i][0] <= id && q[i][1] >= id) && x >= q[i][2])\n            take = solve(q, x - q[i][2], id, i + 1);\n        return dp[i][x][id] = min(take, nottake);\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int cnt = 0;\n        for(int i=0; i<nums.size(); i++){\n            if(nums[i]==0) cnt++;\n        }\n        if(cnt == nums.size()) return 0;\n        int n = nums.size();\n        int maxX = *max_element(nums.begin(), nums.end());\n        dp.assign(q.size(), vector<vector<int>>(maxX + 1, vector<int>(n, -1)));\n        int ans = -1;\n        for(int i = 0; i < n; i++) {\n            if(nums[i] == 0) continue;\n            int a = solve(q, nums[i], i, 0);\n            if(a >= 1e9) return -1;\n            ans = max(a, ans);\n        }\n        return ans;\n    }\n};\n","author":"IronEdge","submissionId":"1575225954"},[]]},{"1346":[{"id":"1346","fileName":"1575226146.txt","sourceCode":"void isPossible(int val, vector<int>& v, int pos, int& ans, vector<bool>& dp) {\n\n    if (pos == v.size()) return;\n\n    for (int i = val-1; i >= 0; i--) {\n        if (dp[i]) {\n            dp[i + v[pos]] = true;\n        }\n        if (dp[val]) {\n            ans = min(ans, pos + 1);\n        }\n    }\n\n    isPossible(val, v, pos + 1, ans, dp);\n}\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> v(n);\n\n        for (auto q : queries) {\n            for (int i = 0; i < q[0]; i++) {\n                v[i].push_back(0);\n            }\n            for (int i = q[0]; i <= q[1]; i++) {\n                v[i].push_back(q[2]);\n            }\n            for (int i = q[1] + 1; i < nums.size(); i++) {\n                v[i].push_back(0);\n            }\n        }\n\n        int ans = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == 0) continue;\n\n            int temp = 10000;\n            vector<bool> dp(1050);\n            dp[0] = true;\n\n            isPossible(nums[i], v[i], 0, temp, dp);\n            if (temp == 10000) {\n                return -1;\n            }\n            ans = max(ans, temp);\n        }\n        return ans;\n    }\n}; ","author":"Zhe Hou","submissionId":"1575226146"},[]]},{"1347":[{"id":"1347","fileName":"1575225985.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        int[][] arr= new int[n][m+1];\n        int index =1;\n        for(int[] query : queries){\n            int l =query[0];\n            int r = query[1];\n            int val = query[2];\n            for(int i=l;i<=r;i++){\n                arr[i][index] =val;\n            }\n            index++;\n        }\n        System.out.println(Arrays.deepToString(arr));\n        int[] min_k = new int[n];\n        Arrays.fill(min_k, -1);\n        Map<Integer, Integer> map;\n        for(int i = 0 ; i< n; i ++){\n            map = new HashMap<>();\n            map.put(0,0);\n            int target = nums[i];\n            if(target==0) {\n                min_k[i]=0;\n                continue;\n            }\n            min_k[i] = find(arr[i], target);\n        }\n        //System.out.println(Arrays.deepToString(arr));\n        //System.out.println(Arrays.toString(min_k));\n        int ans =0;\n        for(int i =0 ; i < n ;i++){\n            if(min_k[i]==-1) return -1;\n            ans  =Math.max(min_k[i],ans);\n        }\n        return ans;\n    }\n    public int find (int[] arr, int target){\n        boolean[] dp = new boolean[target + 1];\n        dp[0]= true;\n        for(int i =0 ; i < arr.length;i++){\n            if(arr[i]>target) continue;\n             for (int j = target; j >=arr[i]; j--) {\n                dp[j] = dp[j] || dp[j - arr[i]];\n            }\n            if (dp[target]) return i;\n        }\n        return -1;\n    }\n}","author":"lmaosuvuong","submissionId":"1575225985"},[]]},{"1348":[{"id":"1348","fileName":"1575226222.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), k = 0;\n        vector<int> finish(n);\n        int pending = n;\n        vector<unordered_set<int>> st(n);\n        for(auto& _st: st)\n            _st.insert(0);\n        for(int i = 0; i < n; i++) {\n            if (nums[i] == 0) {\n                finish[i] = 1;\n                --pending;\n            }\n        }\n        if (pending == 0)\n            return 0;\n        for(const auto & q: queries) {\n            ++k;\n            int l = q[0], r = q[1], v = q[2];\n            for(int i = l; i <= r; i++) {\n                if (finish[i] == 1 || v > nums[i])\n                    continue;\n                if (v == nums[i]) {\n                    finish[i] = 1;\n                    if (--pending == 0)\n                        return k;\n                    continue;\n                }\n                unordered_set<int> tmp;\n                for(const auto& existing: st[i]) {\n                    tmp.insert(existing+v);\n                }\n                if (tmp.find(nums[i]) != tmp.end()) {\n                    finish[i] = 1;\n                    if (--pending == 0)\n                        return k;\n                } else {\n                    for(const auto& _v: tmp)\n                        st[i].insert(_v);\n                }\n            }\n        }\n        return -1;\n        \n    }\n};","author":"HeadingWest","submissionId":"1575226222"},[]]},{"1349":[{"id":"1349","fileName":"1575226394.txt","sourceCode":"class Solution {\npublic:\n    vector<vector<int>> qTemp;\n    bool isPossible(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<vector<int>> valsAtIndex(n);\n\n        for (int q = 0; q < k; ++q) {\n            int l = qTemp[q][0], r = qTemp[q][1], val = qTemp[q][2];\n            for (int i = l; i <= r; ++i) {\n                valsAtIndex[i].push_back(val);\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            int target = nums[i];\n            if (target == 0)\n                continue;\n\n            int totalSum =\n                accumulate(valsAtIndex[i].begin(), valsAtIndex[i].end(), 0);\n            if (totalSum < target)\n                return false;\n\n            bitset<10001> dp;\n            dp[0] = 1;\n            for (int v : valsAtIndex[i]) {\n                dp |= (dp << v);\n            }\n\n            if (!dp[target])\n                return false;\n        }\n\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        qTemp = queries;\n\n        int n = nums.size();\n        int left = 0;\n        int right = queries.size();\n        int res = -1;\n\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (isPossible(nums, mid)) {\n                res = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return res;\n    }\n};","author":"Ashish Agarwal","submissionId":"1575226394"},[]]},{"1350":[{"id":"1350","fileName":"1575226190.txt","sourceCode":"class Solution {\n\n    public boolean canBeZeroed(int target, List<Integer> w){\n        // System.out.println(target+\" \"+w);\n        if(target==0)return true;\n        if(w.size()==0){\n            return target==0;\n        }        \n        boolean dp[][] = new boolean[w.size()][target+1];\n        // System.out.println(target+\" \"+w);\n        if(w.get(0)<=target){\n            dp[0][w.get(0)] = true;\n        }\n        dp[0][0] = true;\n        for(int i=1;i<w.size();i++){\n            int e = w.get(i);             \n            for(int j=0;j<=target;j++){\n                dp[i][j] = dp[i-1][j];\n            }\n            if(e<=target){\n                dp[i][e] = true;\n            }\n            for(int j=0;j<=target;j++){\n                if(e+j<=target){\n                    dp[i][e+j] = dp[i][e+j]||dp[i-1][j];\n                }\n            }\n        }\n        return dp[w.size()-1][target];\n    }\n    \n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int zeroes=0;\n        for(int x : nums){\n            if(x==0)zeroes++;\n        }\n        if(zeroes==n){\n            return 0;\n        }\n        ArrayList<Integer> q[] = new ArrayList[n];\n        for(int i=0;i<n;i++)q[i] = new ArrayList();\n        int nq = 0;\n        boolean canz[] = new boolean[n];\n        int sums[] = new int[n];\n        for(int query[] : queries){\n            nq++;\n            for(int i=query[0];i<=query[1];i++){\n                q[i].add(query[2]);\n                sums[i]+=query[2];\n            }\n            int can = 0;\n            for(int i=0;i<n;i++){\n                if(canz[i]){\n                    can++;\n                    continue;\n                }\n                boolean result = (sums[i]>=nums[i]) && (canz[i]||canBeZeroed(nums[i],q[i]));\n                canz[i] = canz[i]||result;\n                if(canz[i]){\n                    can++;\n                }\n            }\n            if(can==n)return nq;\n        }\n        return -1;\n    }\n}","author":"prudvinit","submissionId":"1575226190"},[]]},{"1351":[{"id":"1351","fileName":"1575226208.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        l = 0\n        r = len(queries)\n        ans = -1\n        n = len(nums)\n\n        def canForm(vals, target):\n            sum_ = sum(vals)\n            if sum_ < target:\n                return False\n            if target in vals or sum_ == target:\n                return True\n\n            valid = False\n            def backtrack(i, curr):\n                nonlocal valid\n                if valid:\n                    return\n\n                if curr > target:\n                    return\n\n                if curr == target:\n                    valid = True\n                    return\n                    \n                if i == len(vals):\n                    if curr == target:\n                        valid = True\n                    return\n\n                backtrack(i+1, curr+vals[i])\n                backtrack(i+1, curr)\n\n            backtrack(0, 0)\n            return valid\n            \n            \n\n        def good(k):\n            # print(k)\n            ops = [[] for _ in range(n)]\n            for i in range(k):\n                l, r, v = queries[i]\n                for idx in range(l, r+1):\n                    ops[idx].append(v)\n\n            for i in range(len(ops)):\n                ops[i].sort()\n\n            # print(ops)\n            valid = True\n            for i in range(n):\n                num = nums[i]\n                if num == 0:\n                    continue\n                # curr = 0\n                # for op in ops[i]:\n                #     curr += op\n                #     if curr == num:\n                #         break\n                #     elif curr > num:\n                #         valid = False\n                #         break\n                # if curr < num:\n                #     valid = False\n                #     break\n                # if not valid:\n                #     break\n                if not canForm(ops[i], num):\n                    valid = False\n                    break\n\n            # print(valid)\n            return valid\n                \n        \n        while l <= r:\n            mid = (l+r) // 2\n            if good(mid):\n                ans = mid\n                r = mid - 1\n            else:\n                l = mid + 1\n\n        return ans\n        \n        ","author":"aiden99","submissionId":"1575226208"},[]]},{"1352":[{"id":"1352","fileName":"1575226627.txt","sourceCode":"class Solution {\nint solve(int num , vector<vector<int>>&queries,int index,int i,vector<vector<int>>&dp){\n    if(index==queries.size() && num>0){\n        return 1e9;\n    }\n    if(num<0){\n        return 1e9;\n            }\n    if(num==0){\n        return index;\n    }\n    if(dp[num][index]!=-1){\n        return dp[num][index];\n    }\n    int notpick = solve(num,queries,index+1,i,dp);\n    int pick = 1e9;\n    int low = queries[index][0];\n    int high = queries[index][1];\n    int val = queries[index][2];\n    if(i>=low && i<=high){\n        pick = solve(num-val,queries,index+1,i,dp);\n    }\n    return dp[num][index]=min(pick,notpick);\n}\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        int m = queries.size();\n        vector<int>temp(n);\n        for(int i=0;i<n;i++){\n            vector<vector<int>>dp(nums[i]+1,vector<int>(m,-1));\n            temp[i] = solve(nums[i],queries,0,i,dp);\n        }\n        int maxi = -1e9;\n        for(auto i : temp){\n            maxi = max(i,maxi);\n        }\n        if(maxi ==-1e9 || maxi ==1e9){\n            return -1;\n        }\n        return maxi;\n    }\n};","author":"Ravish Singla","submissionId":"1575226627"},[]]},{"1353":[{"id":"1353","fileName":"1575226422.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        int k =-1;\n        Set<Integer>[]vals =  new Set[n];\n        for(int i=0;i<m;i++){\n          int zeroCount = 0;\n            for(int o=0;o<n;o++){\n                if((vals[o]!=null && vals[o].contains(nums[o])) || nums[o] == 0){\n                    zeroCount++;\n                }\n               // System.out.println(vals[o]);\n            }\n            if(zeroCount == n){\n                k=i;\n                break;\n            }\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            for(int j=l;j<=r;j++){\n                if(vals[j] == null){\n                    vals[j] = new HashSet<>();\n                }\n            }\n            for(int j=l;j<=r;j++){\n                Set<Integer> temp = new HashSet<>(vals[j]);\n                if(temp.size() == 0){\n                    vals[j].add(val);\n                    continue;\n                }\n                for(int cur : temp){\n                    vals[j].add(cur+val);\n                }\n                vals[j].add(val);\n\n            }\n            zeroCount=0;\n            for(int o=0;o<n;o++){\n                if((vals[o]!=null && vals[o].contains(nums[o])) || nums[o] == 0){\n                    zeroCount++;\n                }\n               // System.out.println(vals[o]);\n\n            }\n            if(zeroCount == n){\n                k=i+1;\n                break;\n            }\n            \n        }\n        return k;\n    }\n}","author":"utuk123","submissionId":"1575226422"},[]]},{"1354":[{"id":"1354","fileName":"1575226519.txt","sourceCode":"class Solution {\npublic:\n    bool check(vector<int> &a, vector<vector<int>> &q, int k) {\n        int n = a.size();\n        vector<map<int, int>> dec(n);\n    \n        for (int i = 0; i < k; i++) {\n            int l = q[i][0], r = q[i][1], v = q[i][2];\n            for (int j = l; j <= r; j++) {\n                dec[j][v]++;\n            }\n        }\n    \n        for (int i = 0; i < n; i++) {\n            int required = a[i];\n            if (required == 0) continue;\n    \n            bitset<1001> dp;\n            dp[0] = 1;\n    \n            for (auto& entry : dec[i]) {\n                int value = entry.first, count = entry.second;\n                bitset<1001> newDp = dp;\n                for (int j = 0; j < count; j++) {\n                    newDp |= (newDp << value);\n                }\n                dp = newDp;\n            }\n    \n            if (!dp[required]) return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int left = 0, right = q.size(), result = -1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (check(a, q, mid)) {\n                result = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return result;\n    }\n};","author":"abcd","submissionId":"1575226519"},[]]},{"1355":[{"id":"1355","fileName":"1575226689.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        return sln1(nums, queries);\n    }\n\n    private int sln1(int[] nums ,int[][] qs){\n        int n = nums.length;\n        int m = qs.length;\n        \n        int l = -1, r = m-1;\n        int res = -1;\n        while(l<=r){\n            int mid = l+r>>1;\n            int[][] arr = new int[n+1][11];\n\n            for(int i = 0;i<=mid;i++){\n                int left = qs[i][0];\n                int right = qs[i][1];\n                int v = qs[i][2];\n                arr[left][v]++;\n                arr[right+1][v]--;\n            }\n            int[] prev = new int[11];\n            boolean valid = true;\n            for(int i =0 ;i<n;i++){\n                for(int j = 0;j<prev.length;j++) arr[i][j] += prev[j];\n                if(!helper(arr[i] ,nums[i])){\n                    valid = false;\n                    break;\n                }\n                prev = arr[i];\n            }\n            if(valid){\n                res = mid+1;\n                r = mid-1;\n            }else{\n                l = mid+1;\n            }\n        }\n        return res;\n    }\n\n    private boolean helper(int[] arr, int t ){\n        boolean[] dp = new boolean[t+1];\n        dp[0] = true;\n        for(int k = 0;k<arr.length;k++){\n            int v = arr[k];\n            for(int j = 0;j<v;j++){\n                for(int i = t;i>=k;i--){\n                    dp[i] = dp[i] || dp[i-k];\n                }\n            }\n        }\n        return dp[t];\n    }\n}","author":"REED_W","submissionId":"1575226689"},[]]},{"1356":[{"id":"1356","fileName":"1575226523.txt","sourceCode":"class Solution(object):\n    def minZeroArray(self, nums, queries):\n        n = len(nums)\n        max_k = 0\n        for i in range(n):\n            target = nums[i]\n            if target == 0:\n                current_k = 0\n            else:\n                S = []\n                for j in range(len(queries)):\n                    l, r, val = queries[j]\n                    if l <= i <= r:\n                        S.append((j, val))\n                achievable = {0}\n                current_k = -1\n                found = False\n                for (j_idx, val) in S:\n                    new_achievable = set(achievable)\n                    for s in list(achievable):  # Iterate over a copy to avoid modification during iteration\n                        new_sum = s + val\n                        new_achievable.add(new_sum)\n                    if target in new_achievable:\n                        current_k = j_idx + 1\n                        found = True\n                        break\n                    achievable = new_achievable\n                if not found:\n                    return -1\n            if current_k > max_k:\n                max_k = current_k\n        return max_k if max_k != -1 else 0\n        ","author":"Vardhan Dongre","submissionId":"1575226523"},[]]},{"1357":[{"id":"1357","fileName":"1575226713.txt","sourceCode":"class Solution {\npublic:\n    int dp[1010][1010];\n    int rec(int i,int cs,vector<vector<int>>& queries,int& tar,int& idx){\n        if(cs==tar){\n            return 0;\n        }\n        if(i>=queries.size()){\n            if(cs==tar) return 0;\n            return 1e9;\n        }\n        if(dp[i][cs]!=-1) return dp[i][cs];\n        int ans=1e9;\n        if(idx>=queries[i][0] && idx<=queries[i][1]){\n            if(cs+queries[i][2]<=tar)ans=min(ans,1+rec(i+1,cs+queries[i][2],queries,tar,idx));\n        }\n        ans=min(ans,1+rec(i+1,cs+0,queries,tar,idx));\n        return dp[i][cs]=ans;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        int qs=queries.size();\n        vector<int> narr(11,1e9);\n        for(int id=0;id<n;id++){\n            memset(dp,-1,sizeof(dp));\n            narr[id]=rec(0,0,queries,nums[id],id);\n        }\n        int fans=0;\n        for(int i=0;i<n;i++){\n            fans=max(fans,narr[i]);\n        }\n        return (fans==1e9)?-1:fans;\n    }\n};","author":"Srikar","submissionId":"1575226713"},[]]},{"1358":[{"id":"1358","fileName":"1575226671.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        hashMap = defaultdict(list)\n        count = 1\n        for l, r, val in queries:\n            for i in range(l, r + 1):\n                hashMap[i].append([count, val])\n            count += 1\n        # print(hashMap)\n        dp = {}\n\n        def minQuery(val, i, arr):\n            if (val, i) in dp:\n                return dp[(val, i)]\n            if val == 0:\n                return i - 1\n            if val < 0 or i >= len(arr):\n                return float('inf')\n\n            tmp = min(\n                minQuery(val, i + 1, arr),\n                minQuery(val - arr[i][1], i + 1, arr)\n            )\n            dp[(val, i)] = tmp\n            return tmp\n\n        res = -float('inf')\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                continue\n            dp = {}\n            a = minQuery(nums[i], 0, hashMap[i])\n            if a == float('inf'):\n                # print(i, nums[i])\n                return -1\n            res = max(res, hashMap[i][a][0])\n        if res == -float('inf'):\n            return 0\n        return res\n\n","author":"Stephen Sun","submissionId":"1575226671"},[]]},{"1359":[{"id":"1359","fileName":"1575226730.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number}\n */\nvar minZeroArray = function(nums, queries) {\n    let dp;\n\n    let best = 0;\n    for(let i = 0; i < nums.length; ++i) {\n        dp = [];\n        let steps = Math.max(best, dfs(i, 0));\n        if(steps >= Infinity) { return -1; }\n\n        best = Math.max(best, steps);\n    }\n\n    return best;\n\n    function dfs(digit, qIdx) {\n        if(nums[digit] === 0) {\n            return qIdx;\n        }\n        \n        if(qIdx >= queries.length) { return Infinity; }\n\n        let dpIdx = nums[digit]*queries.length + qIdx;\n        if(dp[dpIdx]) { return dp[dpIdx]; }\n\n        let best = Infinity;\n\n        let attempted = false;\n\n        for(let i = qIdx; i < queries.length; ++i) {\n            let [l, r, val] = queries[i];\n            if(!(l <= digit && r >= digit && val <= nums[digit])) { continue; }\n\n            attempted = true;\n            qIdx = i;\n\n            nums[digit] -= val;\n            best = Math.min(best, dfs(digit, i+1));\n            nums[digit] += val;\n            break;\n        }\n\n        if(attempted && best > (qIdx+1)) {\n            best = Math.min(best, dfs(digit, qIdx+1));\n        }\n\n        dp[dpIdx] = best;\n\n        return best;\n        \n    }\n};\n","author":"Michael","submissionId":"1575226730"},[]]},{"1360":[{"id":"1360","fileName":"1575226997.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if not any(nums):\n            return 0\n\n        arr = []\n        dp = {}\n        def get_min(curr, rem):\n            if rem == 0:\n                return curr-1\n            if rem < 0 or curr == len(arr):\n                return float('inf')\n            if (curr, rem) not in dp:\n                dp[(curr, rem)] = min(get_min(curr+1, rem-arr[curr][1]), get_min(curr+1, rem))\n            return dp[(curr, rem)]\n\n        min_k = 0\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                for k, (l, r, v) in enumerate(queries):\n                    if l <= i and i <= r:\n                       arr.append((k, v))\n                idx = get_min(0, nums[i])\n                dp.clear()\n                if idx == float('inf'):\n                    return -1\n                min_k = max(min_k, arr[idx][0]+1)\n                arr.clear()\n\n        return min_k","author":"Harshit Allumolu","submissionId":"1575226997"},[]]},{"1361":[{"id":"1361","fileName":"1575227062.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    // Function to check if we can make all nums[i] zero using first 'k' queries\n    bool canMakeZero(vector<int>& nums, vector<vector<int>>& queries, int k) {\n        int n = nums.size();\n        vector<vector<int>> applied_values(n);  // Store applied values for each index\n\n        // Apply first k queries\n        for (int i = 0; i < k; i++) {\n            int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                applied_values[j].push_back(v);\n            }\n        }\n\n        // Check if each nums[i] can be reduced to 0 using a subset of applied values\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) continue;\n            if (applied_values[i].empty()) return false;  // No values available to reduce nums[i]\n            \n            // Check if a subset of applied_values[i] can sum to nums[i]\n            int target = nums[i];\n            int sz = applied_values[i].size();\n            vector<bool> dp(target + 1, false);\n            dp[0] = true;\n\n            for (int val : applied_values[i]) {\n                for (int sum = target; sum >= val; sum--) {\n                    dp[sum] = dp[sum] || dp[sum - val];\n                }\n            }\n            if (!dp[target]) return false;\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int left = 0, right = queries.size(), ans = -1;\n\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (canMakeZero(nums, queries, mid)) {\n                ans = mid;\n                right = mid - 1;  // Try to minimize k\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"manoharsingh2402","submissionId":"1575227062"},[]]},{"1362":[{"id":"1362","fileName":"1575226901.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<int>ans(n,-1);\n        for(int i = 0; i < n; i++)\n            {\n                if(nums[i] == 0)\n                {\n                    ans[i] = 0;\n                    continue;\n                }\n                \n                unordered_set<int>s1;\n                s1.insert(nums[i]);\n                for(int j = 0; j < m; j++)\n                    {\n                        if(queries[j][0] <= i && queries[j][1] >= i)\n                        {\n                            vector<int>r;\n                            if(s1.count(queries[j][2]))\n                            {\n                                ans[i] = j + 1;\n                                break;\n                            }\n                            for(auto k : s1)\n                                {\n                                    if(k - queries[j][2] > 0)\n                                    {\n                                        if(!s1.count(k - queries[j][2]))\n                                        {\n                                             r.push_back(k - queries[j][2]);\n                                        }\n                                    }\n                                }\n                            for(int k =0; k < r.size(); k++)\n                                {\n                                    s1.insert(r[k]);\n                                }\n                        }\n                    }\n                if(ans[i] == -1)\n                {\n                    return -1;\n                }\n            }\n        int final_ans = INT_MIN;\n        for(int i = 0; i < n; i++)\n            {\n                final_ans = max(final_ans,ans[i]);\n            }\n        return final_ans;\n    }\n};","author":"Dhruvin Gandhi","submissionId":"1575226901"},[]]},{"1363":[{"id":"1363","fileName":"1575227131.txt","sourceCode":"#include <vector>\n#include <bitset>\n#include <functional>\n#include <memory>\n#include <string>\nusing namespace std;\n\n// Custom alias types for ultra uniqueness\nusing infinity_gauntlet = vector<int>;\nusing multiverse_portals = vector<vector<int>>;\nusing reality_stone = bitset<1001>;\nusing reality_matrix = vector<reality_stone>;\n\nclass Solution {\nprivate:\n    // Custom villain structure\n    struct villain_profile {\n        string alias;\n        int power_level;\n        \n        villain_profile(string v, int p): alias(v), power_level(p) {}\n    };\n    \n    // Collection of villain references\n    vector<shared_ptr<villain_profile>> supervillain_roster;\n    \n    // Initialize villain roster - uniquely decorative\n    void assemble_legion_of_doom() {\n        supervillain_roster.push_back(make_shared<villain_profile>(\"Thanos\", 1001));\n        supervillain_roster.push_back(make_shared<villain_profile>(\"Joker\", 876));\n        supervillain_roster.push_back(make_shared<villain_profile>(\"Magneto\", 950));\n    }\n    \n    // Function 1: Using lambda within a function for ultra uniqueness\n    void apocalypse_initialize_dimension(reality_matrix& scarlet_witch_weaving, int darkseid_count) {\n        // Ultra unique: using reference capture lambda\n        auto necromancer_spell = [&scarlet_witch_weaving](int idx) -> void {\n            scarlet_witch_weaving[idx].reset();\n            scarlet_witch_weaving[idx].set(0, true);\n        };\n        \n        // Ultra unique: reversed counting\n        int thanos_counter = darkseid_count;\n        while (thanos_counter-- > 0) {\n            necromancer_spell(thanos_counter);\n        }\n    }\n    \n    // Function 2: Using recursion for ultra uniqueness\n    bool doctor_doom_analyze_zero_pattern(const infinity_gauntlet& cosmic_cubes, int mystique_limit, int current_idx = 0) {\n        // Ultra unique: recursive approach with base case\n        if (current_idx >= mystique_limit) return true;\n        if (cosmic_cubes[current_idx] != 0) return false;\n        \n        // Ultra unique: tail recursion\n        return doctor_doom_analyze_zero_pattern(cosmic_cubes, mystique_limit, current_idx + 1);\n    }\n    \n    // Function 3: Using function pointers for ultra uniqueness\n    void hydra_execute_command(reality_matrix& mysterio_illusions, \n                              const infinity_gauntlet& power_gems, \n                              const vector<int>& sinister_directive) {\n        \n        // Ultra unique: creating function objects for operations\n        function<void(int, int, int)> red_skull_operation = [&](int pos, int shift, int target) {\n            mysterio_illusions[pos] |= (mysterio_illusions[pos] << shift);\n            \n            // Ultra unique: reverse direction iteration\n            for (int i = 1000; i > target; i--) {\n                if (i > power_gems[pos]) {\n                    mysterio_illusions[pos].reset(i);\n                }\n            }\n        };\n        \n        // Ultra unique: simultaneous index calculation\n        int kingpin_start = sinister_directive[0];\n        int penguin_end = sinister_directive[1];\n        int green_goblin_shift = sinister_directive[2];\n        \n        // Ultra unique: dynamic step calculation\n        int step = (kingpin_start <= penguin_end) ? 1 : -1;\n        \n        // Process the range with calculated step\n        while (kingpin_start != penguin_end + step) {\n            red_skull_operation(kingpin_start, green_goblin_shift, power_gems[kingpin_start]);\n            kingpin_start += step;\n        }\n    }\n    \n    // Function 4: Using custom iterator pattern for ultra uniqueness\n    bool loki_verify_illusion(const reality_matrix& dormammu_dimensions, \n                             const infinity_gauntlet& infinity_stones, \n                             int galactus_size) {\n        \n        // Ultra unique: create a custom verification tracker\n        struct villain_tracker {\n            int position;\n            bool success;\n            villain_tracker(): position(0), success(true) {}\n            \n            // Ultra unique: compound operation\n            bool advance_and_check(const reality_matrix& dims, const infinity_gauntlet& stones, int limit) {\n                while (position < limit && success) {\n                    success = dims[position].test(stones[position]);\n                    position++;\n                }\n                return success;\n            }\n        };\n        \n        // Ultra unique: using the custom tracker\n        villain_tracker brainiac_scanner;\n        return brainiac_scanner.advance_and_check(dormammu_dimensions, infinity_stones, galactus_size);\n    }\n\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        // Ultra unique: initialization of villain roster\n        assemble_legion_of_doom();\n        \n        // Ultra unique: typedef usage and dramatic naming\n        typedef int apocalypse_countdown;\n        apocalypse_countdown magneto_power_level = nums.size();\n        \n        // Ultra unique: nested pair with custom types\n        pair<infinity_gauntlet&, multiverse_portals&> doctor_strange_multiverse = {nums, queries};\n        \n        // Ultra unique: custom allocation with unique_ptr\n        unique_ptr<reality_matrix> lex_luthor_mind_control = \n            make_unique<reality_matrix>(magneto_power_level);\n        \n        // Function 1: Initialize the reality dimensions\n        apocalypse_initialize_dimension(*lex_luthor_mind_control, magneto_power_level);\n        \n        // Function 2: Check zero pattern with recursion\n        if (doctor_doom_analyze_zero_pattern(doctor_strange_multiverse.first, magneto_power_level)) {\n            return 0;\n        }\n        \n        // Ultra unique: processing with do-while and ternary\n        apocalypse_countdown riddler_counter = -1;\n        const apocalypse_countdown ultron_limit = queries.size();\n        \n        do {\n            riddler_counter++;\n            // Function 3: Process current directive\n            hydra_execute_command(*lex_luthor_mind_control, nums, queries[riddler_counter]);\n            \n            // Function 4: Verify the current state\n            if (loki_verify_illusion(*lex_luthor_mind_control, nums, magneto_power_level)) {\n                return riddler_counter + 1;\n            }\n        } while (riddler_counter < ultron_limit - 1);\n        \n        // Ultra unique: dramatic return statement\n        return supervillain_roster[0]->power_level > 1000 ? -1 : -1;\n    }\n};","author":"M_faiz_conquer","submissionId":"1575227131"},[]]},{"1364":[{"id":"1364","fileName":"1575227358.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int max = -1;\n        int n = queries.length;\n        for (int i = 0; i < nums.length; i++) {\n            int num = nums[i];\n            boolean[][] dp = new boolean[n + 1][num + 1];\n            for (int j = 0; j <= n; j++) {\n                dp[j][0] = true;\n            }\n            for (int j = 1; j <= queries.length; j++) {\n                int l = queries[j - 1][0];\n                int r = queries[j - 1][1];\n                int val = queries[j - 1][2];\n                if (i < l || i > r) {\n                    if (num >= 0) System.arraycopy(dp[j - 1], 1, dp[j], 1, num);\n                    continue;\n                }\n                for (int k = 1; k <= num; k++) {\n                    dp[j][k] = dp[j - 1][k];\n                    if (k >= val) {\n                        dp[j][k] = dp[j][k] || dp[j - 1][k - val];\n                    }\n                }\n            }\n            boolean find = false;\n            for (int j = 0; j <= n; j++) {\n                if (dp[j][num]) {\n                    find = true;\n                    max = Math.max(max, j);\n                    break;\n                }\n            }\n            if (!find) {\n                return -1;\n            }\n        }\n        return max;\n    }\n}","author":"jason1116","submissionId":"1575227358"},[]]},{"1365":[{"id":"1365","fileName":"1575227402.txt","sourceCode":"class Solution {\npublic:\nint minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    std::vector<std::vector<std::pair<int32_t, int32_t>>> d(nums.size());\n    for (size_t i = 0; i < queries.size(); ++i) {\n        //li, ri, val\n        int32_t l = queries[i][0];\n        int32_t r = queries[i][1];\n        int32_t val = queries[i][2];\n        \n        for (int32_t j = l; j <= r; ++j) {\n            d[j].emplace_back(std::make_pair(val, i + 1));\n        }\n    }\n    \n    int32_t answ = 0;\n    \n    std::vector<int8_t> can(1001, 0);\n    for (size_t i = 0; i < nums.size(); ++i) { // 10\n        int32_t x = nums[i];\n        const auto& dm = d[i];\n        \n        if (x == 0) {\n            continue;\n        }\n        \n        std::fill(can.begin(), can.end(), 0);\n        can[0] = 1;\n        \n        for (int32_t j = 0; j < d[i].size(); ++j) { // 1000\n            int32_t cVal = d[i][j].first;\n            for (int32_t v = x; v >= 0; --v) {\n                if (v >= cVal) {\n                    can[v] |= can[v - cVal];\n                }\n            }\n            \n            if (can[x]) {\n                answ = std::max(d[i][j].second, answ);\n                break;\n            }\n        }\n        \n        if (!can[x]) {\n            return -1;\n        }\n    }\n    \n    return answ;\n}\n};","author":"vdeviatkov","submissionId":"1575227402"},[]]},{"1366":[{"id":"1366","fileName":"1575227354.txt","sourceCode":"class Solution {\n    int dfs_find_min_idx(int target, int idx, vector<pair<int, int>> &q, vector<vector<int>> &dp) {\n        if (target == 0) {\n            return q[idx - 1].second;\n        }\n        if (idx == q.size()) {\n            return INT_MAX;\n        }\n        if (dp[target][idx] != -1) {\n            return dp[target][idx];\n        }\n\n        dp[target][idx] = dfs_find_min_idx(target, idx + 1, q, dp);\n        if (target >= q[idx].first) {\n            dp[target][idx] = min(dp[target][idx], dfs_find_min_idx(target - q[idx].first, idx + 1, q, dp));\n        }\n        return dp[target][idx];\n    }\n\n    void init_dp(vector<vector<int>> &dp) {\n        for (int i = 0; i < dp.size(); ++i) {\n             for (int j = 0; j < dp[i].size(); ++j) {\n                 dp[i][j] = -1;\n             }\n        }\n        return;\n    }\n\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int const NLEN = nums.size();\n        int const QLEN = queries.size();\n        \n        vector qOnIdx(NLEN, vector<pair<int, int>>());\n        for (int i = 0; i < QLEN; ++i) {\n            for (int j = queries[i][0]; j <= queries[i][1]; ++j) {\n                qOnIdx[j].push_back({queries[i][2], i});\n            }\n        }\n\n        int maxVal = *max_element(nums.begin(), nums.end());\n        vector dp(maxVal + 1, vector<int>(QLEN));\n        int ans = -1;\n\n        for (int i = 0; i < NLEN; ++i) {\n            init_dp(dp);\n            if (nums[i] > 0) {\n                ans = max(ans, dfs_find_min_idx(nums[i], 0, qOnIdx[i], dp));\n            }\n        }\n\n        return (ans == INT_MAX) ? -1 : ans + 1;\n    }\n};","author":"syujy","submissionId":"1575227354"},[]]},{"1367":[{"id":"1367","fileName":"1575227410.txt","sourceCode":"class Solution {\npublic:\n    int func(vector<vector<int>>& queries, int i, int val, int idx, vector<vector<int>>& dp) {\n        if(val == 0) return 0;\n        if(i == queries.size() || val < 0) return INT_MAX;\n        if(dp[i][val] != -1) return dp[i][val];\n\n        int take = INT_MAX;\n        if(idx >= queries[i][0] && idx <= queries[i][1]) {\n            int res = func(queries, i + 1, val - queries[i][2], idx, dp);\n            if(res != INT_MAX) take = 1 + res;\n        }\n\n        int nottake = INT_MAX;\n        int res = func(queries, i + 1, val, idx, dp);\n        if(res != INT_MAX) nottake = 1 + res;\n\n        return dp[i][val] = min(take, nottake);\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        int ans = 0;\n\n        for(int i = 0; i < n; i++) {\n            vector<vector<int>> dp(1001, vector<int>(1001, -1));\n            int res = func(queries, 0, nums[i], i, dp);\n            if(res == INT_MAX) return -1;\n            ans = max(ans, res);\n        }\n        \n        return ans;\n    }\n};","author":"Om Kumar","submissionId":"1575227410"},[]]},{"1368":[{"id":"1368","fileName":"1575227413.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<vector<pair<int, int>>> v(n); // Stores relevant queries for each index\n        vector<int> required_ks(n, -1); // Stores the required k for each index\n\n        // Step 1: For each index in nums, collect all queries that affect it\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == 0) {\n                required_ks[i] = 0; // No queries needed for zero elements\n                continue;\n            }\n            for (int pos = 0; pos < m; ++pos) {\n                int l = queries[pos][0];\n                int r = queries[pos][1];\n                int val = queries[pos][2];\n                if (l <= i && i <= r) {\n                    v[i].push_back({pos, val}); // Store query position and value\n                }\n            }\n        }\n\n        // Step 2: For each index, compute the minimum k using dynamic programming\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == 0) continue; // Skip zero elements\n\n            unordered_map<int, int> dp; // Tracks the earliest query index for each sum\n            dp[0] = -1; // Base case: sum 0 can be achieved before any queries\n            int target = nums[i];\n\n            for (const auto& query : v[i]) {\n                int pos = query.first;\n                int val = query.second;\n\n                // Create a copy of current dp to avoid modifying it while iterating\n                auto current_dp = dp;\n                for (const auto& entry : current_dp) {\n                    int s = entry.first;\n                    int p = entry.second;\n                    int new_s = s + val;\n\n                    if (new_s > target) continue; // Skip sums exceeding the target\n\n                    // Update dp with the earliest query index for the new sum\n                    if (dp.find(new_s) == dp.end() || dp[new_s] > pos) {\n                        dp[new_s] = pos;\n                    }\n                }\n            }\n\n            // Check if the target sum is achievable\n            if (dp.find(target) == dp.end()) {\n                return -1; // Target sum cannot be achieved\n            }\n            required_ks[i] = dp[target] + 1; // Store the required k for this index\n        }\n\n        // Step 3: Determine the overall minimum k\n        int max_k = 0;\n        for (int k : required_ks) {\n            if (k == -1) return -1; // If any index cannot be zeroed, return -1\n            max_k = max(max_k, k);\n        }\n\n        return max_k > m ? -1 : max_k; // Ensure k does not exceed the number of queries\n    }\n};","author":"ankit2002sethi","submissionId":"1575227413"},[]]},{"1369":[{"id":"1369","fileName":"1575227447.txt","sourceCode":"class Solution {\n\n    \n    public boolean fun(int nums[], int q[][], int k){\n        int n = nums.length;\n        // int sum=0;\n            // Arrays.fill(dp, -1);\n\n        for(int i=0; i<n; i++){\n            int t = nums[i];\n            int dp[] = new int[t+1];\n\n            if(t == 0) continue;\n\n            int sum=0;\n            List<Integer> li = new ArrayList();\n            for(int j=0; j<k; j++){\n                int lf = q[j][0];\n                     int rt=q[j][1], val=q[j][2];\n                if(lf <= i && i <= rt){\n                    li.add(val);\n                    sum += val;\n                }\n                // sum += val;\n            }\n        // System.out.println(sum+\"t\"+li+\"t\"+t+\"t\"+i);\n            // if(sum > t){\n            //     continue;\n            // }\n            if(sum < t) return false;\n\n            dp[0] =1 ;\n            for(int e : li){\n                for(int j=t; j>=e; j--){\n                    if(dp[j] == 1) continue;\n                    if(dp[j-e] == 1) dp[j] = 1;\n                }\n            }\n            if(dp[t] == 0) return false;\n            // f(i, v);\n        }\n        \n        return true;\n    }\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int l=0, h=queries.length, ans=-1;\n\n        while(l <= h){\n            int md = l + (h-l)/2;\n            // System.out.println(l+\"t\"+h+\"t\"+md);\n            if(fun(nums, queries, md)){\n                ans = md;\n                h = md - 1;\n            }\n            else l = md+1;\n        }\n        return ans;\n    }\n}","author":"Lokesh Negi","submissionId":"1575227447"},[]]},{"1370":[{"id":"1370","fileName":"1575227480.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size();\n        using vi = vector<int>;\n        using vvi = vector<vector<int>>;\n\n        auto ok = [](int s, vi &b) -> bool {\n            if (s == 0) return true;\n            vi dp(s + 1, 0);\n            dp[0] = 1;\n            for (int i : b) {\n                for (int j = s; j >= i; j--) {\n                    dp[j] = dp[j] | dp[j - i];\n                }\n            }\n            return dp[s] == 1;\n        };\n\n        auto check = [&](int k) -> bool {\n            vvi b(n);\n            for (int i = 0; i < k; i++) {\n                for (int j = q[i][0]; j <= q[i][1]; j++) {\n                    b[j].push_back(q[i][2]);\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                if (!ok(a[i], b[i])) return false;\n            }\n            return true;\n        };\n\n        int l = 0, r = q.size(), ans = 1e9;\n        while (l <= r) {\n            int m = (l + r) / 2;\n            if (check(m)) {\n                ans = min(ans, m);\n                r = m - 1;\n            } else {\n                l = m + 1;\n            }\n        }\n        return (ans == 1e9) ? -1 : ans;\n    }\n};\n","author":"LeeMinHoon","submissionId":"1575227480"},[]]},{"1371":[{"id":"1371","fileName":"1575227587.txt","sourceCode":"#include<bits/stdc++.h>\nusing namespace std;\nclass Solution{\npublic:\nint minZeroArray(vector<int>&nums,vector<vector<int>>&queries){\n    int n = nums.size();\n    vector<bitset<1001>>dp(n);\n    for(int j = 0;j<n;j++){\n        dp[j].set(0);\n    }\n    if(all_of(nums.begin(),nums.end(),[](int x){ return x == 0;})){\n        return 0;\n    }\n    for(int k = 0;k<queries.size();k++){\n        int l = queries[k][0],r=queries[k][1],v=queries[k][2];\n        for(int j = l;j<=r;j++){\n            bitset<1001>shifted;\n            for(int i = 0;i<=1000-v;i++){\n                if(dp[j][i]){\n                    shifted.set(i+v);\n                }\n            }\n            dp[j]|=shifted;\n            for(int i = nums[j]+1;i<=1000;i++){\n            dp[j].reset(i);\n        }\n        }\n        if(all_of(dp.begin(),dp.end(),[&](bitset<1001>&b){ return b[nums[&b-dp.data()]];})){\n            return k+1;\n        }\n    }\n    return -1;\n}\n};","author":"Praveen18_official","submissionId":"1575227587"},[]]},{"1372":[{"id":"1372","fileName":"1575227544.txt","sourceCode":"class Solution {\n    map< pair<int, vector<int>>, bool> dp;\n\n    bool isOk(int tar, vector<int>& freq){\n        // cout << tar <<\" -> \";\n        // for(auto& x: freq) cout << x <<\" \";\n        // cout <<\"n\";\n        if(tar == 0) return true;\n\n        int sum = 0;\n        for(int i=1; i<=10; i++) {\n            if( tar > sum && (((tar-sum) % i) == 0) && ((tar-sum)/i <= freq[i]) ) return true;\n            sum += (i* freq[i]);\n            if(sum == tar) return true;\n        }\n        if(sum < tar) return false;\n        if(dp.find({tar, freq}) != dp.end()) return dp[{tar, freq}];\n        bool flag = false;\n        for(int i=1; i<=10; i++){\n            if(i > tar) break;\n            if(freq[i] == 0) continue;\n            \n            tar -= i;\n            freq[i]--;\n            flag = isOk(tar, freq);\n            tar += i;\n            freq[i]++;\n            if(flag) break;\n        }\n        dp[{tar, freq}] = flag;\n        return flag;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& qu) {\n        vector<int> active(11, 0);\n        multimap<int, int> remove;\n\n        int i = 0;\n        int n = nums.size();\n        int k = 0;\n        //queue<vector<int>> avl;\n        multimap<int, vector<int>> avl;\n        for(auto& x: qu){\n            while(i < n){\n                if(isOk(nums[i], active) == false) break;\n                while(remove.size() > 0){\n                    auto it = remove.begin();\n                    if(it->first == i) {  active[it->second]--; remove.erase(it); }\n                    else break;\n                }\n                i++;\n                while(avl.size() > 0 && (avl.begin()->first) <= i){\n                    vector<int> nxt = avl.begin()->second;\n                    avl.erase(avl.begin());\n                    active[nxt[2]]++;\n                    remove.insert({nxt[1], nxt[2]});\n                }\n            }\n            if(i == n) return k;\n            k++;\n            if(x[1] < i) continue;\n            if(x[0] > i){ avl.insert({x[0], x}); continue; }\n            active[x[2]]++;\n            remove.insert({x[1], x[2]});\n        }\n        while(i < n){\n            if(isOk(nums[i], active) == false) break;\n            while(remove.size() > 0){\n                auto it = remove.begin();\n                if(it->first == i) {  active[it->second]--; remove.erase(it); }\n                else break;\n            }\n            i++;\n            while(avl.size() > 0 && (avl.begin()->first) <= i){\n                    vector<int> nxt = avl.begin()->second;\n                    avl.erase(avl.begin());\n                    active[nxt[2]]++;\n                    remove.insert({nxt[1], nxt[2]});\n                }\n        }\n        if(i == n) return k;\n        return -1;\n    }\n};","author":"Anand Amar","submissionId":"1575227544"},[]]},{"1373":[{"id":"1373","fileName":"1575227491.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        \n        bool flag=true;\n        for(auto it:nums)\n        {\n            if(it!=0)\n            {\n                flag=false;\n                break;\n            }\n        }\n        if(flag)\n        {\n            return 0;\n        }\n        int ans=0;\n        for(int i=0;i<nums.size();i++)\n        {\n            bool flag=false;\n            vector<vector<int>>dp(queries.size()+1,vector<int>(nums[i]+1,0));\n            dp[0][0]=1;\n            for(int j=1;j<=queries.size();j++)\n            {\n                for(int k=0;k<=nums[i];k++)\n                {\n                    dp[j][k]=dp[j-1][k];\n                    if(queries[j-1][0]<=i && queries[j-1][1]>=i)\n                    {\n                        int val=queries[j-1][2];\n\n                            \n                            if(k>=val && dp[j-1][k-val]==1)\n                            {\n                                dp[j][k]=1;\n                            }\n                    }\n                }\n                if(dp[j][nums[i]]==1)\n                {\n                    ans=max(ans,j);\n                    flag=true;\n                    break;\n                }\n            }\n            if(flag==false)\n            {\n                return -1;\n            }\n        }\n        return ans;\n    }\n};","author":"Shivam Gupta","submissionId":"1575227491"},[]]},{"1374":[{"id":"1374","fileName":"1575227550.txt","sourceCode":"from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        \n        def subset_sum(values, indices, target):\n            \n            dp = {0: -1}  \n\n            for val, query_idx in zip(values, indices):\n                new_dp = dict(dp)  \n                for s in dp:\n                    new_sum = s + val\n                    if new_sum == target:\n                        return max(dp[s], query_idx) \n                    if new_sum <= target and new_sum not in new_dp:\n                        new_dp[new_sum] = max(dp[s], query_idx)\n                dp = new_dp \n\n            return -1  \n\n        n = len(nums)\n        q = len(queries)\n        graph = defaultdict(list)  \n        last_query_index = -1  \n\n        \n        for i, (l, r, val) in enumerate(queries):\n            for index in range(l, r + 1):\n                graph[index].append((val, i))  \n\n        \n        for index in range(n):\n            if nums[index] == 0:\n                continue  \n            \n            values = [v[0] for v in graph[index]] \n            indices = [v[1] for v in graph[index]]  \n\n            last_used = subset_sum(values, indices, nums[index])  \n            \n            if last_used == -1:\n                return -1  \n            \n            last_query_index = max(last_query_index, last_used)  \n\n        return last_query_index + 1  \n","author":"Maanit Goyal","submissionId":"1575227550"},[]]},{"1375":[{"id":"1375","fileName":"1575227617.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, m = len(nums), len(queries)\n        ans = 0\n        \n        def solve(num, qi, ni):\n            if dp.get((num, qi), None) == None:\n                if qi == 0:\n                    dp[(num, qi)] = num == 0 or (queries[qi][0] <= ni <= queries[qi][1] and num == queries[qi][2])\n                else:\n                    dp[(num, qi)] = (queries[qi][0] <= ni <= queries[qi][1] and num >= queries[qi][2] and solve(num - queries[qi][2], qi-1, ni)) or solve(num, qi-1, ni)\n            return dp[(num, qi)]\n            \n        for i in range(n):\n            if nums[i] == 0: continue\n            j = 0\n            dp = {}\n            while j < m:\n                if solve(nums[i], j, i):\n                    ans = max(ans, j+1)\n                    break\n                j += 1\n            if j == m:\n                ans = -1\n                break\n        return ans","author":"Manki Min","submissionId":"1575227617"},[]]},{"1376":[{"id":"1376","fileName":"1575227659.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int low = 0, high = queries.size();\n        int res = -1;\n\n        while(low <= high)\n        {\n            int mid = low + (high - low) / 2;\n            \n            if(isValid(nums, queries, mid)) {\n                res = mid;\n                high = mid - 1;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n\n        return res;\n    }\n\n    bool isValid(vector<int>& nums, vector<vector<int>>& queries, int k) \n    {\n        for(int idx=0;idx<nums.size();idx++)\n        {\n            int target = nums[idx];\n            vector<vector<int>> dp(k + 1, vector<int>(target + 1, -1));\n            if(!solve(idx, 0, k, 0, target, queries, dp)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool solve(int numIdx, int idx, int k, int sum, int target, vector<vector<int>>& queries, vector<vector<int>>& dp) \n    {\n        if(sum > target) {\n            return 0;\n        }\n        \n        if(sum == target) {\n            return 1;\n        }\n\n        if(idx == k) {\n            return 0;\n        }\n\n        if(dp[idx][sum] != -1) {\n            return dp[idx][sum];\n        }\n\n        int left = queries[idx][0];\n        int right = queries[idx][1];\n        int value = queries[idx][2];\n\n        int res = 0;\n\n        // the idx is in range of query\n        if(numIdx >= left and numIdx <= right)\n        {\n            // either exclude or include\n            int exc = solve(numIdx, idx + 1, k, sum, target, queries, dp);\n            int inc = solve(numIdx, idx + 1, k, sum + value, target, queries, dp);\n            res = exc || inc;\n        }\n        else {\n            // if not in range, can only skip\n            res = solve(numIdx, idx + 1, k, sum, target, queries, dp);\n        }\n\n        return dp[idx][sum] = res;\n    }\n};","author":"noob_bacha","submissionId":"1575227659"},[]]},{"1377":[{"id":"1377","fileName":"1575227635.txt","sourceCode":"\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        \n        int sl = 0;\n        int m = q.size();\n        int n = nums.size();\n        vector<int> r_k(n, -1);\n\n        for (int i = 0; i < n;i++) {\n            int gh = nums[i];\n            if (gh == 0) {\n                r_k[i] = 0;\n                continue;\n            }\n             unordered_map<int, int> dpp;\n            dpp[0] = -1;\n            vector<pair<int, int>> qlv;\n            for (int j = 0;j<m;j++) {\n                int le = q[j][0];\n                int ri = q[j][1];\n                int value = q[j][2];\n                if (le <= i && i <= ri)   qlv.emplace_back(j, value);\n                \n            }\n\n            for (auto fg : qlv) {\n                sl += fg.second;\n            }\n            if (sl < gh) {\n                return -1;\n            }\n            for (auto pd : qlv) {\n                int j = pd.first;\n                int value = pd.second;\n                unordered_map<int, int> n_dp(dpp);\n                for (auto e : dpp) {\n                    int cm = e.first;\n                    int cj = e.second;\n                    int nm = cm + value;\n                    if (nm > gh) continue;\n                    int nj = max(cj, j);\n                    if (n_dp.find(nm) == n_dp.end() || nj < n_dp[nm]) {\n                        n_dp[nm] = nj;\n                    }\n                }\n                dpp.swap(n_dp);\n            }\n\n            if (dpp.find(gh) == dpp.end()) {\n                return -1;\n            }\n            r_k[i] = dpp[gh] + 1;\n        }\n\n        int max_k = 0;\n        for (auto k : r_k) {\n            if (k == -1) return -1;\n            if (k > max_k) {\n                max_k = k;\n            }\n        }\n        return max_k;\n    }\n};\n","author":"vanshgupta_25","submissionId":"1575227635"},[]]},{"1378":[{"id":"1378","fileName":"1575227666.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<unordered_set<int>> dp(n);\n        bool z = true;\n\n        for (int x : nums) {\n            if (x != 0) {\n                z = false;\n                break;\n            }\n        }\n        if (z) return 0;\n\n        for (int i = 0; i < n; i++) dp[i].insert(0);\n\n        for (int i = 0; i < queries.size(); i++) {\n            int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n            bool ok = true;\n\n            for (int j = l; j <= r; j++) {\n                unordered_set<int> newSet;\n                for (int x : dp[j]) {\n                    if (x + v < 1001) newSet.insert(x + v);\n                }\n                for (int x : newSet) dp[j].insert(x);\n            }\n\n            for (int j = 0; j < n; j++) {\n                if (dp[j].find(nums[j]) == dp[j].end()) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) return i + 1;\n        }\n        return -1;\n    }\n};\n","author":"priyanshu sharma","submissionId":"1575227666"},[]]},{"1379":[{"id":"1379","fileName":"1575227674.txt","sourceCode":"class Solution {\npublic:\n    int dp[1001][1001];\n    int f(int sum,int i,vector<pair<int,int>> &v)\n    {\n        if(sum==0)\n            return v[i-1].second+1;\n        if(i==v.size() || sum<0)\n            return INT_MAX;\n        // if(sum==3)\n            // cout<<sum<<\" \"<<i<<\" \"<<v[i].first<<\" \"<<v[i].second<<endl;\n        if(dp[sum][i]!=-1)\n            return dp[sum][i];\n        return dp[sum][i]=min(f(sum-v[i].first,i+1,v),f(sum,i+1,v));\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        memset(dp,-1,sizeof(dp));\n        vector<vector<pair<int,int>>> v(n);\n        int q=queries.size();\n        for(int i=0;i<q;i++)\n        {\n            for(int j=queries[i][0];j<=queries[i][1];j++)\n                {\n                    v[j].push_back({queries[i][2],i});\n                }\n        }\n        int ans=0;\n        for(int i=0;i<n;i++)\n            {\n                memset(dp,-1,sizeof(dp));\n                if(nums[i]==0)\n                    continue;\n                if(v[i].size()==0)\n                    return -1;\n                int x=f(nums[i],0,v[i]);\n                // cout<<nums[i]<<\" \"<<x<<endl;\n                if(x==INT_MAX)\n                    return -1;\n                ans=max(ans,x);\n                // cout<<ans<<endl;\n            }\n        return ans;\n    }\n};","author":"dhruveel_gajipara","submissionId":"1575227674"},[]]},{"1380":[{"id":"1380","fileName":"1575227707.txt","sourceCode":"\n\nclass Solution {\n    \n    int minSum(vector<pair<int,int>> &vals, int num, int index, vector<vector<int>> &DP)\n    {\n        int sum = 0;\n        if(num < 0 || index >= vals.size()) return INT_MAX;\n        if(DP[num][index] != -1) return DP[num][index];\n        \n        for(auto c : vals) sum += c.first;\n        if(sum < num) return INT_MAX;\n        if(num - vals[index].first == 0) return  vals[index].second + 1;\n        \n        int take = INT_MAX, noTake = INT_MAX;\n        take = minSum(vals, num - vals[index].first, index+1, DP);\n        noTake = minSum(vals, num, index+1, DP);\n        \n        DP[num][index] =  min(take, noTake);\n        return min(take, noTake);\n    }\n    int check(vector<vector<int>>& queries, int num, int index)\n    {\n        vector<pair<int,int>> vals;\n        for(int i=0; i<queries.size(); i++)\n        {\n            if(queries[i][0] <= index && queries[i][1] >= index)\n            {\n                vals.push_back({queries[i][2], i});\n            }\n        }\n        vector<vector<int>> DP(num + 1, vector<int>(vals.size(), -1));\n        int ans = minSum(vals, num, 0, DP);\n        return ans;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = 0;\n        for(int i=0; i<nums.size(); i++)\n        {\n            if(nums[i] == 0) continue;\n            int k = check(queries, nums[i], i);\n            if(k == INT_MAX) return -1;\n            ans = max(ans, k);\n        }\n        return ans == INT_MAX ? -1 : ans;\n    }\n};","author":"Arjun","submissionId":"1575227707"},[]]},{"1381":[{"id":"1381","fileName":"1575227678.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, q = len(nums), len(queries)\n\n        def f(k):\n            for i in range(n):\n                c = sorted([queries[j][2] for j in range(k) if queries[j][0] <= i <= queries[j][1]])\n\n                if sum(c) < nums[i]: return False\n                \n                dp = 1\n                for co in c:\n                    dp |= dp << co\n\n                    if (dp >> nums[i]) & 1:\n                        break\n\n                if ((dp >> nums[i]) & 1) == 0:\n                    return False\n            return True\n\n        lo, hi = 0, q\n        ans = -1\n        while lo <= hi:\n            m = (lo + hi) // 2\n\n            if f(m):\n                hi = m - 1\n                ans = m\n            else:\n                lo = m + 1\n        return ans\n                        \n                ","author":"newbie","submissionId":"1575227678"},[]]},{"1382":[{"id":"1382","fileName":"1575227745.txt","sourceCode":"class Solution{\npublic:\n    int minZeroArray(vector<int>&a,vector<vector<int>>&q){\n        int n=a.size(),m=q.size(),M=1000;\n        vector<vector<bool>> dp(n,vector<bool>(M+1,false));\n        for(int i=0;i<n;i++)\n            dp[i][0]=true;\n        \n        bool f=true;\n        for(int i=0;i<n;i++)\n            if(a[i]!=0){\n                f=false;\n                break;\n            }\n        if(f)return 0;\n        \n        for(int j=0;j<m;j++){\n            int l=q[j][0],r=q[j][1],v=q[j][2];\n            for(int i=l;i<=r;i++)\n                for(int k=M;k>=v;k--)\n                    if(dp[i][k-v])\n                        dp[i][k]=true;\n            \n            bool f2=true;\n            for(int i=0;i<n;i++)\n                if(a[i]>M||!dp[i][a[i]]){\n                    f2=false;\n                    break;}\n            if(f2)\n                return j+1;\n        }\n        return -1;\n    }\n};\n","author":"Sahil Srivastava","submissionId":"1575227745"},[]]},{"1383":[{"id":"1383","fileName":"1575227817.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        Pair<int[], int[][]> dataPair = new Pair<>(nums, queries);\n\n        BitSet[] dp = new BitSet[n];\n        for (int i = 0; i < n; i++) {\n            dp[i] = new BitSet(1001);\n            dp[i].set(0, true);\n        }\n\n        boolean isAllZero = Arrays.stream(nums).allMatch(num -> num == 0);\n        if (isAllZero) return 0;\n\n        for (int queryIndex = 0; queryIndex < queries.length; queryIndex++) {\n            int left = queries[queryIndex][0];\n            int right = queries[queryIndex][1];\n            int value = queries[queryIndex][2];\n\n            for (int i = left; i <= right; i++) {\n                dp[i].or(shiftLeft(dp[i], value));\n\n                for (int pos = nums[i] + 1; pos < 1001; pos++) {\n                    dp[i].clear(pos);\n                }\n            }\n\n            boolean allTargetsMet = true;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i].get(nums[i])) {\n                    allTargetsMet = false;\n                    break;\n                }\n            }\n\n            if (allTargetsMet) return queryIndex + 1;\n        }\n\n        return -1;\n    }\n\n    private BitSet shiftLeft(BitSet bitset, int positions) {\n        BitSet shifted = new BitSet(bitset.length() + positions);\n        for (int i = bitset.nextSetBit(0); i >= 0; i = bitset.nextSetBit(i + 1)) {\n            shifted.set(i + positions);\n        }\n        return shifted;\n    }\n\n    private static class Pair<A, B> {\n        A first;\n        B second;\n\n        Pair(A first, B second) {\n            this.first = first;\n            this.second = second;\n        }\n    }\n}\n","author":"iamsharmasawan","submissionId":"1575227817"},[]]},{"1384":[{"id":"1384","fileName":"1575227791.txt","sourceCode":"class Solution {\n    bool solve(int i,int s,vector<int>&arr,vector<vector<int>>&dp){\n        int n=arr.size();\n        if(s==0) return 1;\n        if(i>=n) return 0;\n        if(dp[i][s]!=-1) return dp[i][s];\n        bool a,b;\n        a=b=0;\n        b=solve(i+1,s,arr,dp);\n        if(s-arr[i]>=0){\n            a=solve(i+1,s-arr[i],arr,dp);\n        }\n        return dp[i][s]=a || b; \n        \n    }\n    bool check(vector<int>&nums,vector<vector<int>>&q,int k){\n        \n        int n=nums.size();\n        vector<vector<int>>arr(n);\n        for(int i=0;i<=k;i++){\n            int l=q[i][0];\n            int r=q[i][1];\n            int v=q[i][2];\n            for(int j=l;j<=r;j++){\n                arr[j].push_back(v);\n            }\n            \n        }\n        \n        for(int i=0;i<n;i++){\n            vector<vector<int>>dp(arr[i].size(),vector<int>(nums[i]+1,-1));\n            bool f=solve(0,nums[i],arr[i],dp);\n            if(!f) return 0;\n        }\n        return 1;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int l=0;\n        int r=q.size()-1;\n        int ans=r;\n        bool f=0;\n        for(auto i:nums){\n            if(i!=0) f=1;\n        }\n        if(f==0) return 0;\n        f=0;\n        while(l<=r){\n            int m=l+(r-l)/2;\n            if(check(nums,q,m)){\n                f=1;\n                ans=m;\n                r=m-1;\n            }\n            else l=m+1;\n        }\n        if(f==0) return -1;\n        return ans+1;\n    }\n};","author":"_Sahil_22","submissionId":"1575227791"},[]]},{"1385":[{"id":"1385","fileName":"1575227859.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        List<Set<Integer>> l=new ArrayList<>();\n        int z=0;\n        for(int i=0;i<nums.length;i++){\n            Set<Integer> st=new HashSet<>();\n            st.add(0);\n            if(nums[i]!=0)z++;\n                l.add(st);}\n        if(z==0)return 0;\n        for(int i=0;i<queries.length;i++){\n            int s=queries[i][0];\n            int e=queries[i][1];\n            int val=queries[i][2];\n            for(int k=s;k<=e;k++){\n                Set<Integer> temp=new HashSet<>();\n                for(int j:l.get(k))temp.add(j);\n                for(int j:l.get(k)){\n                    temp.add(j+val);\n                }\n                l.set(k,temp);\n            }\n            int f=1;\n\n            for(int j=0;j<nums.length;j++){\n                if(l.get(j).contains(nums[j])==false){f=-1;break;}\n            }\n            if(f==1)return i+1;\n        }\n        return -1;\n    }\n}","author":"Mayank","submissionId":"1575227859"},[]]},{"1386":[{"id":"1386","fileName":"1575227854.txt","sourceCode":"#define ff first\n#define ss second\n\nclass Solution {\n\n    int get_max(vector<pair<int, int>> a, int t) {\n        if (t == 0) return 0;\n        int n = a.size();\n        \n        vector<vector<int>> dp(n, vector<int>(t + 1, -1));\n        \n        auto fun = [&](int i, int ts, auto fun) -> int {\n            if (i == n) {\n                return 1e9;\n            }\n            \n            if (dp[i][ts] != -1) {\n                return dp[i][ts];\n            }\n            \n            int best = 1e9;\n            if (a[i].ff <= ts) {\n                if (a[i].ff == ts) {\n                    return dp[i][ts] = a[i].ss;\n                }\n                \n                best = fun(i + 1, ts - a[i].ff, fun);\n            }\n            \n            int skip = fun(i + 1, ts, fun);\n            \n            return dp[i][ts] = min(best, skip);\n        };\n        \n        int x = fun(0, t, fun);\n        \n        // cout << t << \" => n\";\n        // for (auto it : a) {\n        //     cout << it.ff << \" \" << it.ss << \"n\";\n        // }\n        // cout << x << \"nn\";\n        if (x == 1e9) return -1;\n        return x;\n    } \n    \npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size();\n        \n        map<int, vector<pair<int, int>>> mp;        \n        for (int k = 0; k < q; ++k) {\n            int s = queries[k][0], e = queries[k][1];\n            \n            for (int i = s; i <= e; ++i) {\n                mp[i].push_back({queries[k][2], k + 1});\n            }\n        }\n        \n        int ans = -1;\n        \n        for (int i = 0; i < n; ++i) {\n            int cur = get_max(mp[i], nums[i]);\n            if (cur == -1) return -1;\n            \n            ans = max(ans, cur);\n        }\n        \n        return ans;\n    }\n};","author":"oe63OuofTY","submissionId":"1575227854"},[]]},{"1387":[{"id":"1387","fileName":"1575227897.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def log(*args):\n            print(*args)\n        \"\"\"\n        subset\n        任意選\n        但是一次必須扣val，或是不扣\n        所以像是\n        [2,2] quries = [[0,1,5]]就不行，因為扣太多\n\n        先暴力\n\n        O(nqm)\n        queries <= 1000\n        \"\"\"\n        def sol1():\n            n = len(nums)\n            isZeros = [False] * n\n            remainNonzero = 0\n            for i in range(n):\n                if nums[i] == 0:\n                    isZeros[i] = True\n                else:\n                    remainNonzero += 1\n                    \n            if remainNonzero == 0:\n                return 0\n\n            \n            possibleSet = [set() for _ in range(n)]\n            for i in range(n):\n                possibleSet[i].add(nums[i])\n            \n            for i in range(len(queries)):\n                l, r, val = queries[i]\n\n                for j in range(l, r + 1):\n                    if isZeros[j] == True:\n                        continue\n                        \n                    newSet = set(possibleSet[j])\n                    for x in possibleSet[j]:\n                        if x - val >= 0:\n                            newSet.add(x - val)\n                    possibleSet[j] = newSet\n\n                    if 0 in possibleSet[j]:\n                        isZeros[j] = True\n                        remainNonzero -= 1\n\n                \n                if remainNonzero == 0:\n                    return i + 1\n            return -1\n        return sol1()","author":"locus","submissionId":"1575227897"},[]]},{"1388":[{"id":"1388","fileName":"1575227855.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<vector<int>> a(queries.size(), vector<int>(nums.size()));\n        for (int i = 0; i < queries.size(); i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int v = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                a[i][j] = v;\n            }\n        }\n        int ans = 0 ; ;\n        for (int i = 0; i < nums.size(); i++) {\n            int x = nums[i];\n            vector<int> dp(x + 1, -2);\n            dp[0] = -1 ;\n            for (int j = 0; j < a.size(); j++) {\n                for (int k = x; k >= a[j][i]; k--) { \n                    if (dp[k - a[j][i]] != -2) {\n                        if(dp[k]!=-2)dp[k] = min(dp[k] , j) ;\n                        else dp[k] = j ;\n                    }\n                }\n            }\n            ans = max(ans , dp[x] + 1) ;\n            if(dp[x] == -2){\n                return -1 ;\n            }\n        }\n        return ans ;\n    }\n};","author":"Prathamesh Khanna","submissionId":"1575227855"},[]]},{"1389":[{"id":"1389","fileName":"1575228004.txt","sourceCode":"class Solution {\npublic:\n    int ans = -1;\n    bool solve(int i, int t, int m, int &maxi, vector<pair<int, int>> &arr, \nvector<vector<int>> &dp){\n        if(t == 0){\n            maxi = min(maxi, m);\n            return true;\n        }\n        if(i == arr.size() || t < 0) return false;\n        if(dp[i][t] != -1) return dp[i][t];\n\n        int take = solve(i+1, t - arr[i].first, arr[i].second, maxi, arr, dp);\n        int nt = solve(i+1, t, m, maxi, arr, dp);\n\n        return dp[i][t] = (take | nt);\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\n       int n = nums.size(), q = queries.size();\n        vector<vector<pair<int, int>>> arr(n);\n\n        for(int i = 0; i < q; i++){\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n\n            for(int j = l; j <= r; j++){\n                arr[j].push_back({val, i});\n            }\n        }\n\n        for(int i = 0; i < n; i++){\n            int target = nums[i];\n            vector<pair<int, int>> v = arr[i];\n            vector<vector<int>> dp(v.size(), vector<int> (target+1, -1));\n            int maxi = 1e9;\n            if(solve(0, target, -1, maxi, v, dp)){\n                ans = max(ans, maxi);\n            }\n            else return -1;\n        }\n        return ans + 1;\n        \n    }\n};","author":"HARSH_KANOO","submissionId":"1575228004"},[]]},{"1390":[{"id":"1390","fileName":"1575227918.txt","sourceCode":"from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        \n        \n        dp = [0] * n  \n        for j in range(n):\n            dp[j] = 1  \n\n        \n        all_zero = all(num == 0 for num in nums)\n        if all_zero:\n            return 0\n\n        for k in range(len(queries)):\n            l, r, v = queries[k]\n\n            for j in range(l, r + 1):\n                dp[j] = dp[j] | (dp[j] << v) \n                for pos in range(nums[j] + 1, 1001):\n                    dp[j] &= ~(1 << pos)   \n\n        \n            all_achieved = True\n            for j in range(n):\n                if not (dp[j] & (1 << nums[j])):  \n                    all_achieved = False\n                    break\n\n            if all_achieved:\n                return k + 1\n\n        return -1\n","author":"RIKESH YADAV","submissionId":"1575227918"},[]]},{"1391":[{"id":"1391","fileName":"1575227985.txt","sourceCode":"class Solution {\npublic:\n    bool canZero(int mid, vector<int>& nums, vector<vector<int>>& q, int n) {\n        vector<vector<int>> dp(n, vector<int>(mid + 1, 0)); //dp[i][j] = total decrement at i using j queries\n        \n        //for each index, track possible decrements\n        for(int i = 0; i < n; i++){\n            vector<bool> possible(nums[i] + 1, false); //can we achieve this decrement???\n            possible[0] = true; // Empty subset\n            \n            for(int j = 0; j < mid; j++){\n                int l = q[j][0], r = q[j][1], x = q[j][2];\n                if(i < l || i > r) continue; // i not in range\n                \n                //shift possible values by x\n                for(int val = nums[i]; val >= x; val--){\n                    if(possible[val - x]){\n                        possible[val] = true;\n                    }\n                }\n            }\n            if(!possible[nums[i]]) return false; //cannot make nums[i] exactly 0\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n\n        int low = 0;\n        int high = queries.size();  // applying all queries\n\n        int res = -1;\n\n        while(low <= high){\n            int mid = low + (high - low) / 2;\n\n            if(canZero(mid, nums, queries, n)){\n                res = mid;\n                high = mid-1;\n            }\n            else{\n                low = mid + 1;\n            }\n        }\n\n        return res;\n    }\n};","author":"Harsh Dadhich","submissionId":"1575227985"},[]]},{"1392":[{"id":"1392","fileName":"1575227961.txt","sourceCode":"#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define ll                      long long\n#define ar                      array\n// #define int                     ll\n#define sz(v)                   (int)(v.size())\n#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define ld                      long double\n#define ull                     unsigned long long\n#define fo(i,a,b)               for(int i = a; i<=b ; i++)\n#define rfo(i,a,b)              for(int i = a; i>=b ; i--)\n#define vii                     vector<int>\n#define pq                      priority_queue\n#define uomii                   unordered_map<int,int,best_hash>\n#define all(v)                  v.begin(),v.end()\n#define mp                      make_pair\n#define pb                      push_back\n#define pob                     pop_back\n#define ff                      first\n#define ss                      second\n#define pii                     pair<int,int>\n#define mii                     map<int,int>\n#define vvii                    vector<vii>\n#define mod                     1000000007\n#define inf                     5e18\n#define pi                      3.1415926535897932384626433832795\n#define cz(x)                   63 - __builtin_clzll(x)\n\n\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n\n// https://codeforces.com/blog/entry/68809\n\nvoid __print(int x) {cout << x;}\nvoid __print(long x) {cout << x;}\nvoid __print(unsigned x) {cout << x;}\nvoid __print(unsigned long x) {cout << x;}\nvoid __print(unsigned long long x) {cout << x;}\nvoid __print(float x) {cout << x;}\nvoid __print(double x) {cout << x;}\nvoid __print(long double x) {cout << x;}\nvoid __print(char x) {cout << ''' << x << ''';}\nvoid __print(const char *x) {cout << '\"\"' << x << '\"\"';}\nvoid __print(const string &x) {cout << '\"\"' << x << '\"\"';}\nvoid __print(bool x) {cout << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? \",\" : \"\"), __print(i); cout << \"}\";}\nvoid _print() {cout << \"]n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define pr(x...) cout << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define pr(x...)\n#endif\n\n// https://codeforces.com/blog/entry/62393\n\nstruct best_hash {\n\tstatic uint64_t splitmix64(uint64_t x) {\n\n\t\tx += 0x9e3779b97f4a7c15;\n\t\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n\t\tx = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n\t\treturn x ^ (x >> 31);\n\t}\n\n\tsize_t operator()(uint64_t x) const {\n\t\tstatic const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n\t\treturn splitmix64(x + FIXED_RANDOM);\n\t}\n};\n\n\n/* ------------------------------- REAL CODING STARTS NOW --------------------------- */\n\n\nint dp[1002][1002];\nint n;\n\nclass Solution {\npublic:\n\n\tint kroCheck(int pos, int K, int cursum, vvii &queries, int loc) {\n\t\tif (cursum < 0) return false;\n\t\tif (cursum == 0) return true;\n\t\tif (pos == K) return false;\n\t\tint &ans = dp[pos][cursum];\n\t\tif (ans != -1) return ans;\n\t\tans = false;\n\t\tans = kroCheck(pos + 1, K, cursum, queries, loc);\n\t\tif (ans) return true;\n\n\t\tint l = queries[pos][0], r = queries[pos][1], val = queries[pos][2];\n\t\tif (loc >= l and loc <= r) {\n\t\t\tans |= kroCheck(pos + 1, K, cursum - val, queries, loc);\n\t\t}\n\t\treturn ans;\n\t}\n\n\tint minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\t\tn = sz(nums);\n\t\tint z = sz(queries);\n\n\t\tint mx = 0;\n\t\tfor (auto &i : nums) mx = max(mx, i);\n\t\tif (mx == 0) return 0;\n\n\t\tauto possible = [&](int K) -> bool{\n\n\t\t\tbool ok = true;\n\t\t\tfo(i, 0, n - 1) {\n\t\t\t\t// check if it possible to make it zero using first K queries\n\t\t\t\tfo(pos, 0, K - 1) {\n\t\t\t\t\tfo(cursum, 0, nums[i]) dp[pos][cursum] = -1;\n\t\t\t\t}\n\t\t\t\tif (!kroCheck(0, K, nums[i], queries, i)) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ok;\n\t\t};\n\n\t\tint low = 1, high = z, mid, ans = -1;\n\t\twhile (low <= high) {\n\t\t\tmid = (low + high) / 2;\n\t\t\tif (possible(mid)) {\n\t\t\t\tans = mid;\n\t\t\t\thigh = mid - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n","author":"Yatin Kwatra","submissionId":"1575227961"},[]]},{"1393":[{"id":"1393","fileName":"1575228099.txt","sourceCode":"class Solution {\npublic:\n    bool isPos(vector<int>& nums, vector<vector<int>>& queries,int k) {\n        int n = nums.size();\n        for (int j = 0; j < n; j++) {\n            int tar = nums[j];\n            if (tar == 0)\n                continue;\n\n            vector<bool> dp(tar + 1, false);\n            dp[0] = true;\n            for (int i = 0; i < k; i++) {\n                if (queries[i][0] <= j && j <= queries[i][1]) {\n                    int val = queries[i][2];\n                    for (int sum = tar; sum >= val; sum--) {\n                        if (dp[sum - val])\n                            dp[sum] = true;\n                    }\n                }\n            }\n            if (!dp[tar])\n                return false;\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int q = queries.size();\n        int s = 0, e = q;\n        int ans = -1;\n\n        while (s <= e) {\n            int mid = s + (e - s) / 2;\n\n            if (isPos(nums, queries, mid)) {\n                ans = mid;\n                e = mid - 1;\n            } else {\n                s = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"tanmayshingde8","submissionId":"1575228099"},[]]},{"1394":[{"id":"1394","fileName":"1575228162.txt","sourceCode":"class Solution {\npublic:\n    pair<bool, int> f(int target, vector<pair<int, int>>& v) {\n        int n = v.size();\n        vector<pair<bool, int>> dp(target + 1, {false, INT_MAX});\n        dp[0] = {true, -1};\n        for (auto& [num, i] : v) {\n            for (int j = target; j >= num; j--) {\n                if (dp[j - num].first) {\n                    int max_index = max(dp[j - num].second, i);\n                    if (!dp[j].first || max_index < dp[j].second) {\n                        dp[j].first = true;\n                        dp[j].second = max_index;\n                    }\n                }\n            }\n        }\n        if (dp[target].first) {\n            return {true, dp[target].second};\n        }\n        return {false, -1};\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n        map<int, vector<pair<int, int>>> mp;\n        for (int i = 0; i < q.size(); i++) {\n            int li = q[i][0], ri = q[i][1], vali = q[i][2];\n            for (int j = li; j <= ri; j++) {\n                mp[j].push_back({vali, i});\n            }\n        }\n        int result = 0;\n        for (int j = 0; j < n; j++) {\n            if (mp.find(j) == mp.end()) {\n                if (nums[j] == 0) continue;\n                else return -1;\n            }\n            auto res = f(nums[j], mp[j]);\n            if (!res.first) return -1;\n            int m_j = res.second;\n            result = max(result, m_j + 1);\n        }\n        return result;\n    }\n};","author":"Giriraj bidwai","submissionId":"1575228162"},[]]},{"1395":[{"id":"1395","fileName":"1575228115.txt","sourceCode":"class Solution {\npublic:\n    int n, m;\n   bool fnd(vector<int>& v, int s) {\n    bitset<1001> dp;  \n    dp[0] = 1;\n    for (int num : v) {\n        dp |= (dp << num); \n    }\n    return dp[s]; \n}\n    bool check(int ans, vector<int> &nums, vector<vector<int>> &q) {\n        \n        map<int,vector<int>> ind;\n        for (int i = 0; i <=ans; i++) {\n            for(int j=q[i][0];j<=q[i][1];j++){\n                ind[j].push_back(q[i][2]);\n            }\n        }\n        for(int i=0;i<n;i++){\n            vector<int> v;\n            for(auto it:ind[i]){\n                v.push_back(it);\n            }\n            if(v.size()==0 && nums[i]!=0) return false;\n            sort(v.begin(),v.end());\n            if(fnd(v,nums[i])==false){\n                return false;\n            }\n                \n            \n        }\n        \n        return true;\n    }\n    \n    int minZeroArray(vector<int> &nums, vector<vector<int>> &q) {\n        n = nums.size();\n        m = q.size();\n        int lo = 0, hi = m - 1, ans = -1;\n        bool f=0;\n        for(int i=0;i<n;i++){\n            if(nums[i]>0){\n                f=1;\n                break;\n            }\n        }\n        if(f==0) return 0;\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (check(mid, nums, q)) {\n                ans = mid;\n                hi = mid - 1;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        if(ans==-1){\n            return -1;\n        }\n        return ans+1;\n    }\n};","author":"Rahul Kumar","submissionId":"1575228115"},[]]},{"1396":[{"id":"1396","fileName":"1575228247.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& v, vector<vector<int>>& q) {\n        int n = v.size();\n        int m = q.size();\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            int req = v[i];\n            if (req == 0) {\n                ans = max(ans, 0);\n                continue;\n            }\n\n            vector<bool> dp(1001, false);\n            dp[0] = true;\n            int jal = -1;\n            bool flag = false;\n\n            for (int j = 0; j < m; ++j) {\n                int l = q[j][0];\n                int r = q[j][1];\n                int d = q[j][2];\n                if (i < l || i > r) {\n                    continue;\n                }\n\n                vector<bool> new_dp = dp;\n                for (int k = 1000; k >= 0; --k) {\n                    if (dp[k] && k + d <= 1000) {\n                        new_dp[k + d] = true;\n                    }\n                }\n\n                if (new_dp != dp) {\n                    dp = new_dp;\n                    if (dp[req] && jal == -1) {\n                        jal = j + 1;\n                        flag = true;\n                    }\n                }\n            }\n\n            if (jal == -1 && !flag) {\n                return -1;\n            }\n\n            ans = max(ans, jal);\n        }\n\n        return ans;\n    }\n};\n","author":"Mogu Mogu","submissionId":"1575228247"},[]]},{"1397":[{"id":"1397","fileName":"1575228216.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        \n\n        auto canAchieve = [&](int X) -> bool {\n\n            vector<bitset<1001>> possible(n);\n            for (int j = 0; j < n; j++) {\n                possible[j].reset();\n                possible[j].set(0, true); \n            }\n\n            for (int i = 0; i < X; i++){\n                int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n                for (int j = l; j <= r; j++){\n\n                    possible[j] |= (possible[j] << val);\n                }\n            }\n\n            for (int j = 0; j < n; j++){\n                if (!possible[j].test(nums[j]))\n                    return false;\n            }\n            return true;\n        };\n        \n\n        int lo = 0, hi = q + 1;\n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (canAchieve(mid)) hi = mid;\n            else lo = mid + 1;\n        }\n        \n        return lo > q ? -1 : lo;\n    }\n\n\n};","author":"Abhi25jk","submissionId":"1575228216"},[]]},{"1398":[{"id":"1398","fileName":"1575228582.txt","sourceCode":"class Solution {\npublic:\n    bool calc(int tar, vector<int>&arr )\n    {\n        vector<int>dp(tar+1,0);\n        dp[0]=1;\n        for(auto it:arr)\n        {\n            for(int i=tar;i>=it;i--)\n            {\n                dp[i]|=dp[i-it];\n            }\n        }\n        return dp[tar];\n    }\n    bool check(int n,vector<int>&nums, vector<vector<int>>&queries)\n    {\n        int m=nums.size();\n        bool res=1;\n        for(int i=0;i<m;i++)\n        {\n            vector<int>arr;\n            for(int j=0;j<n+1;j++)\n            {\n                if(queries[j][0]<=i && queries[j][1]>=i)\n                {\n                    arr.push_back(queries[j][2]);\n                }\n            }\n            res&=calc(nums[i],arr);\n        }\n        return res;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        bool flag=0;\n        for(auto it:nums)\n        {\n            flag|=(it!=0);\n        }\n        if(flag==0)\n        {\n            return 0;\n        }\n        int n=queries.size();\n        int l=0;\n        int r=n-1;\n        int ans=-1;\n        while(l<=r)\n        {\n            int mid=l+(r-l)/2;\n            if(check(mid,nums,queries))\n            {\n                ans=mid+1;\n                r=mid-1;\n            }\n            else\n            {\n                l=mid+1;\n            }\n        }\n        return ans;\n    }\n};","author":"Monolith","submissionId":"1575228582"},[]]},{"1399":[{"id":"1399","fileName":"1575228273.txt","sourceCode":"class Solution {\npublic:\n\n   bool isSubsetSumRec(vector<int>& arr, int n, int sum,\n                   vector<vector<int>> &memo) {\n  \n    // If the sum is zero, we found a subset\n    if (sum == 0)\n        return 1;\n\n    // If no elements are left\n    if (n <= 0)\n        return 0;\n\n    // If the value is already\n      // computed, return it\n    if (memo[n][sum] != -1)\n        return memo[n][sum];\n\n    // If the last element is greater than\n      // the sum, ignore it\n    if (arr[n - 1] > sum)\n        return memo[n][sum] = isSubsetSumRec(arr, n - 1, sum, memo);\n    else {\n      \n        // Include or exclude the last element\n        return memo[n][sum] = isSubsetSumRec(arr, n - 1, sum, memo) ||\n                              isSubsetSumRec(arr, n - 1, sum - arr[n - 1], memo);\n    }\n}\n\n\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<bool> done(nums.size(),false);\n        vector<vector<int>> vals(nums.size());\n        \n        for(int i=0;i<queries.size();i++){\n            for(int j=queries[i][0];j<=queries[i][1];j++){\n                vals[j].push_back(queries[i][2]);\n            }\n\n             for(int j=0;j<nums.size();j++){\n                 if(nums[j]==0){\n                     done[j]=true;\n                 }\n             }\n\n            \n            bool flag = true;\n        \n            for(int j=nums.size()-1;j>=0;j--){\n                if(done[j]==false){\n                    flag = false;\n                    vector<vector<int>> memo(vals[j].size() + 1, vector<int>(nums[j] + 1, -1));\n                    if(isSubsetSumRec(vals[j],vals[j].size(),nums[j],memo)){\n                        done[j]=true;\n                    }\n                    else{\n                        break;\n                    }\n                }\n            }\n\n            if(flag==true){\n                return i;\n            }\n            \n        }\n\n        bool stag = true;\n\n        for(int j=0;j<nums.size();j++){\n                if(done[j]==false){\n                    stag = false;\n                    \n                    }\n                }\n\n        if(stag==true) return queries.size();\n\n\n        \n\n        return -1;\n        \n       \n    }\n};","author":"Niket Mishra","submissionId":"1575228273"},[]]},{"1401":[{"id":"1401","fileName":"1575228620.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        int mx = ranges::max(nums);\n        vector f(n, vector(mx + 1, false));\n        for (int i = 0; i < n; i++) {\n            f[i][0] = true;\n        }\n\n        int s = reduce(nums.begin(), nums.end(), 0);\n        if (s == 0) {\n            return 0;\n        }\n        \n        for (int k = 0; k < m; k++) {\n            auto& q = queries[k];\n            int l = q[0], r = q[1], v = q[2];\n\n            int ok = 0;\n            for (int i = 0; i < n; i++) {\n                if (i >= l and i <= r) {\n                    for (int j = nums[i]; j >= v; j--) {\n                        if (f[i][j - v]) {\n                            f[i][j] = true;\n                        }\n                    }\n                }\n                ok += f[i][nums[i]];\n            }\n            if (ok == n) {\n                return k + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"Bean","submissionId":"1575228620"},[]]},{"1402":[{"id":"1402","fileName":"1575228741.txt","sourceCode":"class Solution {\npublic:\n    bool target(vector<int>& nums, int target){\n        int n = nums.size();\n        vector<bool> dp(target+1, false);\n        dp[0] = 1;\n        for(int it : nums){\n            for(int j = target; j >= it; j--){\n                dp[j] = dp[j] || dp[j-it];\n            }\n        }\n        return dp[target];\n    }\n    bool check(vector<int>& nums, vector<vector<int>>& queries, int k){\n        int n = nums.size();\n        vector<int> temp = nums;\n        vector<vector<int>> mp(n);\n        for(int i = 0; i < k; i++){\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for(int j = l; j <= r; j++){\n                mp[j].push_back(val);\n            }\n        }\n        for(int i = 0; i < n; i++){\n            vector<int>& nn = mp[i];\n            if(!target(nn, nums[i]))\n                return 0;\n        }\n        return 1;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        bool f=1;\n        for(int it : nums){\n            if(it != 0){\n                f = 0;\n                break;\n            }\n        }\n        if(f) return 0;\n        int ans = -1;\n        int l = 1, r = q;\n        while(l <= r){\n            int mid = (l + r) / 2;\n            if(check(nums, queries, mid)){\n                ans = mid;\n                r = mid - 1;\n            }\n            else{\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"S Rithish","submissionId":"1575228741"},[]]},{"1403":[{"id":"1403","fileName":"1575228686.txt","sourceCode":"class Solution:\n    from collections import defaultdict\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:          \n        #total = sum(nums)\n        nonzero = set()\n        d = defaultdict(set)\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                nonzero.add(i)\n        if len(nonzero) == 0:\n            return 0\n        for i in range(len(queries)):\n            l,r, val = queries[i]\n            for j in range(l,r+1):\n                if j not in nonzero:\n                    continue\n                current_set = d[j]\n                new_n = val\n                target = nums[j]\n                #print(j, current_set)\n                if target - new_n in current_set or target == new_n:\n                    nonzero.remove(j)\n                    if len(nonzero) == 0:\n                        return i + 1\n                else:\n                    ls = current_set.copy()\n                    for e in ls:\n                        current_set.add(e+new_n)\n                    current_set.add(new_n)\n            #print(nonzero)\n            #print(d)\n        return -1\n                    \n                    \n                \n            \n        \n            \n\n        \n        ","author":"leaven12","submissionId":"1575228686"},[]]},{"1404":[{"id":"1404","fileName":"1575228409.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n#define dbg(...) __f(#__VA_ARGS__,__VA_ARGS__)\n// trace std::pair\ntemplate<class L,class R> std::ostream& operator<<(std::ostream& os,std::pair<L,R>& P){\n\treturn os<<\"{\"<<P.first<<\":\"<<P.second<<\"}\";\n}\n// trace std::vector\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::vector<T>& V){\n\tos<<\"[ \";for(auto v:V)os<<v<<\" \";return os<<\"]\";\n}\n// trace std::map;\ntemplate<class L,class R> std::ostream& operator<<(std::ostream& os,std::map<L,R>& MP) {\n\tos<<\"[ \";for(auto& P : MP) os<<P<<\" \";return os<<\"]\";\n}\n// trace unordred_std::map\ntemplate<class L,class R> std::ostream& operator<<(std::ostream& os,std::unordered_map<L,R>& MP) {\n\tos<<\"[ \";for(auto& P : MP) os<<P<<\" \";return os<<\"]\";\n}\n// trace std::set\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::set<T>& S){\n\tos<<\"[ \";for(auto s:S)os<<s<<\" \";return os<<\"]\";\n}\n// Debugging for std::set<int, std::greater<int>> (custom comparator)\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T, std::greater<T>>& S) {\n\tos << \"[ \";\n\tfor (auto s : S) os << s << \" \";\n\treturn os << \"]\";\n}\n// trace std::unordered_set\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::unordered_set<T>& S){\n\tos<<\"[ \";for(auto s:S)os<<s<<\" \";return os<<\"]\";\n}\n// trace std::multiset\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::multiset<T>& S){\n\tos<<\"[ \";for(auto s:S)os<<s<<\" \";return os<<\"]\";\n}\n// Debugging for std::set<int, std::greater<int>> (custom comparator)\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, std::multiset<T, std::greater<T>>& S) {\n\tos << \"[ \";\n\tfor (auto s : S) os << s << \" \";\n\treturn os << \"]\";\n}\n// std::stack FUN\ntemplate <class T>\nvoid F_Stack(std::stack<T> st, std::string& cont) {\n\tif (st.empty()) return;\n\tT mem = st.top();\n\tst.pop();\n\tF_Stack(st, cont);\n\t// Use stringstream to handle any type T\n\tstd::stringstream ss;\n\tss << mem;\n\tcont += \" \" + ss.str();\n}\n// trace std::stack                                                  \ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::stack<T> st) {\n\tos<<\"[\";std::string cont=\"\";F_Stack(st,cont);return os<<cont<<\" ]\";\n}\n// track std::queue\ntemplate<class T> std::ostream& operator<<(std::ostream& os,std::queue<T> q) {\n\tos<<\"[ \";while(!q.empty()) os<<q.front()<<\" \",q.pop();return os<<\"]\";\n}\n// Debugging for std::deque\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, std::deque<T>& D) {\n\tos << \"[ \";\n\tfor (auto& d : D) os << d << \" \";\n\treturn os << \"]\";\n}\n// dbg std::std::array\ntemplate<class T, size_t S> std::ostream& operator<<(std::ostream& os,std::array<T, S> V){\n\tos<<\"[ \";for(auto v:V)os<<v<<\" \";return os<<\"]\";\n}\n// Debugging for max-heap (default priority queue)\ntemplate <class T>\nvoid F_PriorityQueue(std::priority_queue<T> pq, std::string& cont) {\n\twhile (!pq.empty()) {\n\t\tT mem = pq.top();\n\t\tpq.pop();\n\t\t\n\t\t// Use stringstream for general types\n\t\tstd::stringstream ss;\n\t\tss << mem;\n\t\tcont += \" \" + ss.str();\n\t}\n}\n\n// Debugging for min-heap (custom comparator)\ntemplate <class T>\nvoid F_MinPriorityQueue(std::priority_queue<T, std::vector<T>, std::greater<T>> pq, std::string& cont) {\n\twhile (!pq.empty()) {\n\t\tT mem = pq.top();\n\t\tpq.pop();\n\t\t\n\t\t// Use stringstream for general types\n\t\tstd::stringstream ss;\n\t\tss << mem;\n\t\tcont += \" \" + ss.str();\n\t}\n}\n\n// Debug function for priority queue (max-heap)\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> pq) {\n\tos << \"[\";\n\tstd::string cont = \"\";\n\tF_PriorityQueue(pq, cont);\n\treturn os << cont << \" ]\";\n}\n\n// Debug function for min-heap priority queue\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> pq) {\n\tos << \"[\";\n\tstd::string cont = \"\";\n\tF_MinPriorityQueue(pq, cont);\n\treturn os << cont << \" ]\";\n}\n\n\n// for last arg.\ntemplate<typename Arg1>\nvoid __f(const char* name,Arg1&& arg1){\n\tstd::cout<<name<<\" : \"<<arg1<<std::endl;\n}\n// for variable arg\ntemplate <typename Arg1,typename... Args>\nvoid __f(const char* names,Arg1&& arg1,Args&&... args){\n\tconst char* comma=strchr(names+1,',');std::cout.write(names,comma-names)<<\" : \"<<arg1<<\" | \";__f(comma+1,args...);\n}\n\n\n// X.find_by_order(k) return iterator to kth element. 0 indexed.\n// X.order_of_key(k) returns count of elements strictly less than k.\n\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// template <class T>\n// using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\n\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define sz(x) ((ll)(x).size())\n#define nl 'n'\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define uniq(x) {x.erase(unique(all(x)), x.end()); }\n\nusing ll = long long int;\nusing i128 = __int128;\nusing pii = pair<ll,ll>;\nusing mii = map<ll,ll>;\t\nusing umii = unordered_map<ll,ll>;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vvii = vector<vpii>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\nusing vvvl = vector<vvl>;\nusing vvpii = vector<vpii>;\ntemplate<class T> using _priority_queue = priority_queue<T, vector<T>, greater<T>>;\n\ntemplate<class T, class U> bool chmin(T& a, const U& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T, class U> bool chmax(T& a, const U& b) { return a < b ? a = b, 1 : 0; }\n\n\nconst ll INF = 1e12;\nconst ll N = 1e5+5;\n\n// #define dbg(...)\n// Think about corner cases before submitting\n\n\ntemplate<class T, class U> auto min(const T& a, const U& b) -> typename std::common_type<T, U>::type { return b < a ? b : a; }\ntemplate<class T, class U> auto max(const T& a, const U& b) -> typename std::common_type<T, U>::type { return b > a ? b : a; }\n\n#define here() dbg(__LINE__)\nconst ll MX = 10005;\n\nclass Solution {\npublic:\n\n        \n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = sz(nums), q = sz(queries);\n\n        auto pos = [&](int target, vector<int>& vals) {\n            vector<int> dp(target + 1, 0);\n            dp[0] = 1;\n            for (int i = 0; i < sz(vals); i++) {\n                vector<int> ndp(target + 1, 0);\n                for (int j = 0; j <= target; j++) {\n                    ndp[j] |= dp[j];\n                    if (vals[i] <= j) ndp[j] |= dp[j - vals[i]];\n                }\n                swap(dp, ndp);\n            }\n            return dp[target];\n        };\n        \n        auto get = [&](int idx) {\n            vvpii diff(n + 1);\n            for (int i = 0; i < idx; i++) {\n                int l = queries[i][0];\n                int r = queries[i][1];\n                int k = queries[i][2];\n                diff[l].pb({1, k});\n                diff[r + 1].pb({-1, k});\n            }\n            vector<int> cnt(11, 0);\n            for (int i = 0; i < n; i++) { \n                for (auto &ops : diff[i]) {\n                    int op = ops.fi, val = ops.se;\n                    cnt[val] += op;\n                }\n\n\n                vector<int> vals;\n                for (int k = 1; k <= 10; k++) {\n                    for (int j = 0; j < cnt[k]; j++)\n                        vals.push_back(k);\n                }\n\n                // dbg(i, nums[i], vals);\n                if (pos(nums[i], vals)) {\n                    continue;\n                } else {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        // dbg(get(2));\n        int low = 0, high = q, ans = -1;\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            int ok = get(mid);\n            // dbg(mid, ok);\n            if (ok) {\n                ans = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return ans;\n        // return -1;\n    }\n};","author":"Rushikesh Kulkarni","submissionId":"1575228409"},[]]},{"1405":[{"id":"1405","fileName":"1575228983.txt","sourceCode":"class Solution {\npublic:\n    int knapsack(int idx, int value, vector<vector<int>>& queries) {\n        vector<int> dp(value + 1, 0);\n        dp[0] = 1;\n        if (value == 0) return 0; \n        for (int k = 0; k < queries.size(); ++k) {\n            auto& query = queries[k];\n            if (idx <= query[1] && idx >= query[0]) {\n                for (int j = dp.size() - 1; j >= 0; --j) {\n                    if (j - query[2] >= 0) {\n                        dp[j] |= dp[j-query[2]];\n                    }\n                }\n            }\n            if (dp[value]) {\n                return k+1;\n            }\n        }\n        return INT_MAX;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int k = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n            int res = knapsack(i, nums[i], queries);\n            if (res == INT_MAX) {\n                return -1;\n            }\n            k = max(k, res);\n        }\n\n        return k;\n    }\n};","author":"law","submissionId":"1575228983"},[]]},{"1406":[{"id":"1406","fileName":"1575228855.txt","sourceCode":"class Solution {\npublic:\n\n    // bool helper(vector<int>& arr, int target, int index,vector<vector<int>>& dp){\n        \n    //     if(target == 0) return true; \n        \n    //     if(index == arr.size()) return false; \n        \n        \n    //     if(dp[target][index] != -1) return dp[target][index]; \n        \n    //     if(arr[index] <= target){\n    //         //we can either take it in the subset or not take it in the subset \n    //         return  dp[target][index] = helper(arr,target-arr[index],index+1,dp) || helper(arr,target,index+1,dp);\n    //     }\n    //     else{\n    //         //in this case we simply can't take it \n    //         return  dp[target][index] = helper(arr,target,index+1,dp); \n    //     }\n    // }\n\n\n    bool check(vector<int>& nums,vector<vector<int>>& queries,int k,int n,int m){\n        unordered_map<int,vector<int>> mp; \n\n        for(int i=0;i<=k;i++){\n            int start = queries[i][0]; \n            int end = queries[i][1]; \n            int val = queries[i][2]; \n            for(int j=start;j<=end;j++){\n                mp[j].push_back(val); \n            }\n        }\n\n        for(int i=0;i<n;i++){\n            if(nums[i] == 0) continue; \n\n            if(mp.find(i) == mp.end()) return false; \n            int req = nums[i]; \n            vector<int> v = mp[i]; \n            // if (v.empty()) return false;\n            // vector<vector<int>> dp(req+1,vector<int>(v.size()+1,-1)); \n            // if(!helper(v,req,0,dp)){\n            //     return false; \n            // }\n            bitset<10001> dp; // Assuming nums[i] ≤ 10^4\n            dp[0] = 1;\n            for (int x : v) dp |= (dp << x);\n\n            if (!dp[req]) return false; // If subset sum is not possible\n        }\n        return true; \n        \n    }\n\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(); \n        int m = queries.size(); \n\n        int cnt = count(nums.begin(),nums.end(),0); \n        if(cnt == n) return 0; \n        int low = 0; \n        int high = m-1; \n\n        int ans = INT_MAX; \n        while(low <= high){\n            int mid = low + (high - low)/2; \n\n            if(check(nums,queries,mid,n,m)){\n                ans = mid; \n                high = mid-1; \n            }else low = mid + 1;\n        }\n\n        return ans == INT_MAX ? -1 : ans + 1; \n    }\n};","author":"phantom_07","submissionId":"1575228855"},[]]},{"1407":[{"id":"1407","fileName":"1575228888.txt","sourceCode":"using System;\nusing System.Collections.Generic;\n\npublic class Solution {\n    public int MinZeroArray(int[] numbers, int[][] queries) {\n        int size = numbers.Length;\n        var dataPair = new Tuple<int[], int[][]>(numbers, queries);\n        \n        var bitMasks = InitializeBitMasks(size);\n        if (CheckAllZero(numbers)) return 0;\n\n        for (int queryIndex = 0; queryIndex < queries.Length; queryIndex++) {\n            int left = queries[queryIndex][0];\n            int right = queries[queryIndex][1];\n            int shiftValue = queries[queryIndex][2];\n\n            ApplyBitMask(bitMasks, numbers, left, right, shiftValue);\n\n            if (CheckAllNumbersAchieved(bitMasks, numbers)) {\n                return queryIndex + 1;\n            }\n        }\n        return -1;\n    }\n\n    private List<HashSet<int>> InitializeBitMasks(int size) {\n        var bitMasks = new List<HashSet<int>>(size);\n        for (int i = 0; i < size; i++) {\n            bitMasks.Add(new HashSet<int> { 0 });\n        }\n        return bitMasks;\n    }\n\n    private bool CheckAllZero(int[] numbers) {\n        foreach (var num in numbers) {\n            if (num != 0) return false;\n        }\n        return true;\n    }\n\n    private void ApplyBitMask(List<HashSet<int>> bitMasks, int[] numbers, int left, int right, int shiftValue) {\n        for (int i = left; i <= right; i++) {\n            var updatedSet = new HashSet<int>(bitMasks[i]);\n            foreach (var value in bitMasks[i]) {\n                updatedSet.Add(value + shiftValue);\n            }\n            bitMasks[i] = updatedSet;\n            bitMasks[i].RemoveWhere(pos => pos > 1000);\n        }\n    }\n\n    private bool CheckAllNumbersAchieved(List<HashSet<int>> bitMasks, int[] numbers) {\n        for (int i = 0; i < numbers.Length; i++) {\n            if (!bitMasks[i].Contains(numbers[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n","author":"harishnachiappanr","submissionId":"1575228888"},[]]},{"1408":[{"id":"1408","fileName":"1575228998.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int len = nums.size();\n        vector<int> a = nums;\n        int res = -1;\n        vector<vector<bool>> dp(len + 1);\n        for (int i = 0; i < len; i++) {\n            dp[i].assign(nums[i] + 1, false);\n            dp[i][0] = true;\n        }\n        bool z = true;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] != 0) {\n                z = false;\n                break;\n            }\n        }\n        if (z) {return 0;}\n        for (int k = 0; k < queries.size(); k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int val = queries[k][2];\n            for (int i = l; i <= r; i++) {\n                for (int s = nums[i]; s >= val; s--) {\n                    if (!dp[i][s] && dp[i][s - val]) {\n                        dp[i][s] = true;\n                    }\n                }\n            }\n            bool z1 = true;\n            for (int i = 0; i < len; i++) {\n                if (!dp[i][nums[i]]) {\n                    z1 = false;\n                    break;\n                }\n            }\n            if (z1) {\n                return k + 1;\n            }\n        }\n        return res;\n    }\n};","author":"was024","submissionId":"1575228998"},[]]},{"1409":[{"id":"1409","fileName":"1575229161.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        if(count(nums.begin(),nums.end(),0)==n) return 0;\n        vector<set<int>> v1(n);\n        for (int i = 0; i < n; i++) v1[i].insert(0);\n\n    \n        for (int i = 0; i < m; i++) {\n            int l = queries[i][0],r = queries[i][1], val = queries[i][2];\n\n            for (int j = l; j <= r ;j++) {\n                set<int> st;\n                for (int it : v1[j]) {\n                    st.insert(it+val);\n                }\n                v1[j].insert(st.begin(), st.end());\n\n          \n                auto it = v1[j].upper_bound(nums[j]);\n                v1[j].erase(it, v1[j].end());\n            }\n\n         \n            bool flag = true;\n            for (int k = 0; k < n; k++) {\n                if (v1[k].find(nums[k]) == v1[k].end()) {\n                    flag = false;\n                    break;\n                }\n            }\n\n            if (flag) return i + 1;  \n        }\n\n        return -1;  \n    }\n};\n","author":"Vasu Tayal","submissionId":"1575229161"},[]]},{"1410":[{"id":"1410","fileName":"1575229144.txt","sourceCode":"\nclass Solution {\npublic:\n\t// vector<vector<int>> dp;\n\tunordered_map<int, unordered_map<int, int>> dp;\n\n\tint rec(int& ind, int sum, int qind, vector<vector<int>>& queries) {\n\t\tif (sum == 0)\n\t\t\treturn qind;\n\t\tif (qind == queries.size() || sum < 0)\n\t\t\treturn INT_MAX;\n\t\tif (dp.find(sum) != end(dp) && dp[sum].find(qind) != end(dp[sum]))\n\t\t\treturn dp[sum][qind];\n\t\tint ans = INT_MAX;\n\t\tif (ind >= queries[qind][0] && ind <= queries[qind][1]) {\n\t\t\tans = rec(ind, sum - queries[qind][2], qind + 1, queries);\n\t\t}\n\t\treturn dp[sum][qind] = min(ans, rec(ind, sum, qind + 1, queries));\n\t}\n\n\t// void cleanDP() {\n\t// \tfor (int i = 0; i < dp.size(); ++i)\n\t// \t{\n\t// \t\tfor (int j = 0; j < dp[i].size(); ++j)\n\t// \t\t{\n\t// \t\t\tdp[i][j] = -1;\n\t// \t\t}\n\t// \t}\n\t// }\n\n\tint minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\t\tdp.clear();\n\t\t// dp.resize(1001, vector<int>(queries.size(), -1));\n\t\tint ans = -1;\n\t\tfor (int i = 0; i < nums.size(); ++i)\n\t\t{\n\t\t\tint currAns = rec(i, nums[i], 0, queries);\n\t\t\tif (currAns == INT_MAX)\n\t\t\t\treturn -1;\n\t\t\tans = max(ans, currAns);\n\t\t\tdp.clear();\n\t\t}\n\t\treturn ans;\n\t}\n};\n","author":"rupakkkk","submissionId":"1575229144"},[]]},{"1411":[{"id":"1411","fileName":"1575229187.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\n        int maxK = 0; \n        for(int i = 0; i < nums.size(); i++) {\n            if(nums[i] == 0)\n                continue;\n            vector<bool> dp(1001);\n            dp[0] = 1;\n            for(int j = 0; j < queries.size(); j++) {\n                if(queries[j][0] <= i && i <= queries[j][1]) {\n                    for(int k = nums[i]; k >= queries[j][2]; k--) {\n                        dp[k] = dp[k] || dp[k - queries[j][2]];\n                    }\n                }\n\n                if(dp[nums[i]]) {\n                    maxK = max(maxK, j + 1);\n                    break;\n                }\n            }\n\n            if(!dp[nums[i]]) {\n                return -1;\n            }\n        }\n        return maxK;\n    }\n};","author":"振群 高","submissionId":"1575229187"},[]]},{"1412":[{"id":"1412","fileName":"1575229232.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        if all(num == 0 for num in nums):\n            return 0\n\n        sets = [set([0]) for _ in range(n)]\n        def check():\n            for i in range(n):\n                if nums[i] not in sets[i]:\n                    return False\n            return True\n            \n        for j, (l, r, v) in enumerate(queries):\n            for i in range(l, r + 1):\n                old_set = sets[i]\n                new_set = copy.deepcopy(old_set)\n                for old_val in old_set:\n                    new_set.add(old_val + v)\n                sets[i] = new_set\n            if check():\n                return j + 1\n        return -1\n            ","author":"Alexey Andronov","submissionId":"1575229232"},[]]},{"1413":[{"id":"1413","fileName":"1575229252.txt","sourceCode":"from typing import List\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        a = len(nums)\n        d = [0] * a  \n        for j in range(a):\n            d[j] = 1 << 0  \n        if all(n == 0 for n in nums):\n            return 0\n        for k, q in enumerate(queries):\n            x, c, v = q\n            for j in range(x, c + 1):\n                d[j] |= (d[j] << v)  \n                for p in range(nums[j] + 1, 1001):\n                    d[j] &= ~(1 << p)\n            if all((d[j] & (1 << nums[j])) != 0 for j in range(a)):\n                return k + 1  \n        return -1  \n","author":"Nihitha_devi_S","submissionId":"1575229252"},[]]},{"1414":[{"id":"1414","fileName":"1575229358.txt","sourceCode":"class Solution {\npublic:\n    bool subsetSumToK(int n, int k, vector<int> &arr) {\n    vector<bool> prev(k + 1, false);\n\n    prev[0] = true;\n\n    if (arr[0] <= k) {\n        prev[arr[0]] = true;\n    }\n\n    for (int ind = 1; ind < n; ind++) {\n        vector<bool> cur(k + 1, false);\n\n        cur[0] = true;\n\n        for (int target = 1; target <= k; target++) {\n            bool notTaken = prev[target];\n\n            bool taken = false;\n            if (arr[ind] <= target) {\n                taken = prev[target - arr[ind]];\n            }\n\n            cur[target] = notTaken || taken;\n        }\n\n        prev = cur;\n    }\n\n    return prev[k];\n}\n    int solve(vector<int>& nums, vector<vector<int>>& queries,int mid){\n        vector<int> arr(nums.size()+1,0);\n          vector<vector<int>> p(nums.size());\n        for(int i =0; i<mid; i++){\n            arr[queries[i][0]]+=queries[i][2];\n            arr[queries[i][1]+1]-=queries[i][2];\n            for(int j =queries[i][0]; j<=queries[i][1]; j++){\n                p[j].push_back(queries[i][2]);\n            }\n        }      \n        for(int i =1; i<arr.size(); i++){\n            arr[i] = arr[i]+arr[i-1];\n        }\n        for(int i =0; i<nums.size(); i++){\n            if(nums[i]<arr[i]){\n                if(!subsetSumToK(p[i].size(),nums[i],p[i])) return false;\n            }\n            else if(nums[i]>arr[i]) return false;\n            else continue;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int st = 0;\n        int end = queries.size();\n        while(st<=end){\n            int mid = (st+end)/2;\n            if(solve(nums,queries,mid)) end = mid-1;\n            else st = mid+1;\n        }\n        return (st >queries.size()? -1: st);\n    }\n};","author":"Ayushman Barick","submissionId":"1575229358"},[]]},{"1415":[{"id":"1415","fileName":"1575229371.txt","sourceCode":"class Solution {\npublic:\n\n vector<int>v;\n vector<vector<int>>dp;\n\n    bool fun(int i,int n,int sum){\n        if(sum==0) return 1;\n        if(i==n || sum<0) return 0;\n        if(dp[i][sum]!=-1) return dp[i][sum];\n\n        return dp[i][sum]=fun(i+1,n,sum-v[i]) || fun(i+1,n,sum);\n}\n    \n    bool fun(int n, int mid, vector<int>& nums, vector<vector<int>>& queries) {\n        \n        for(int j=0;j<n;j++){\n            v.clear();\n            dp.clear();\n        for(int i=0;i<=mid;i++){\n            if(queries[i][0]<=j && queries[i][1]>=j){\n                v.push_back(queries[i][2]);\n            }\n        }\n            dp.resize(v.size(),vector<int>(1e4+1,-1));\n            if(!fun(0,v.size(),nums[j])) return 0;\n        }\n\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<int> pre(n, 0); // Initialize prefix sum array\n\n        bool f=1;\n\n        for(int i=0;i<n;i++){\n            if(nums[i]!=0) {\n                f=0;\n                break;\n            }\n        }\n\n        if(f) return 0;\n\n        int low = 0, high = m - 1, ans = -1;\n\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (fun(n, mid, nums, queries)) {\n                ans = mid; // Store the potential answer\n                high = mid - 1; // Try for a smaller value\n            } else {\n                low = mid + 1;\n            }\n        }\n        if(ans==-1) return -1;\n        return ans+1;\n    }\n};","author":"saichandu47","submissionId":"1575229371"},[]]},{"1416":[{"id":"1416","fileName":"1575229330.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if max(nums) == min(nums) == 0: return 0\n            \n        subtractors = { }\n        affectors = { }\n        for idx, query in enumerate(queries):\n            left, right, val = query\n\n            for num_idx in range(left, right + 1):\n                if num_idx not in affectors:\n                    affectors[num_idx] = list( )\n                    subtractors[num_idx] = list( )\n                affectors[num_idx].append(idx)\n                subtractors[num_idx].append(val)\n\n        result = -1\n        for num_idx in range(len(nums)):\n            if nums[num_idx] == 0: continue\n            if num_idx not in affectors: return -1\n            k = -1\n            encountered = set([nums[num_idx]])\n            for affector, subtractor in zip(affectors[num_idx], subtractors[num_idx]):\n                if subtractor in encountered:\n                    k = affector; break\n\n                temp = set( )\n                for num in encountered:\n                    if num - subtractor > 0: temp.add(num - subtractor)\n                encountered = encountered.union(temp)\n\n            if k == -1: return -1\n            result = max(result, k)\n        return result + 1","author":"Benjamin Banaga","submissionId":"1575229330"},[]]},{"1417":[{"id":"1417","fileName":"1575229432.txt","sourceCode":"class Solution:\n\n    def dict_to_array(self, d):\n        result = []\n        for key, count in d.items():\n            result.extend([key] * count)\n        return result\n    \n    def can_form_target(self, diff_dict, target):\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        nums = self.dict_to_array(diff_dict)\n    \n        for num in nums:\n            for t in range(target, num - 1, -1):\n                if dp[t - num]:\n                    dp[t] = True\n    \n        return dp[target]\n    \n    def check_subsum(self, values, target, current_sum, total_count, count):\n        if current_sum == target:\n            return True\n        elif target == 0:\n            return True\n        elif count > total_count:\n            return False\n        elif len(values.keys()) == 0:\n            return False\n        elif current_sum > target:\n            return False\n\n\n        # print(values)\n        # print(current_sum)\n        \n        res = False\n        keys = list(values.keys())\n        for key in keys:\n            values[key] -= 1\n            if values[key] == 0:\n                del values[key]\n            res1 = self.check_subsum(values, target, current_sum + key, total_count, count+1)\n            if key in values:\n                values[key] += 1\n            else:\n                values[key] = 1\n            res2 = self.check_subsum(values, target, current_sum, total_count, count+1)\n            res = res or res1 or res2\n            if res is True:\n                return res\n\n        return res\n    \n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        total_sum = 0\n        diff_arr = [dict() for _ in range(n+1)]\n        k = 0\n\n        for i in range(n):\n            #while self.check_subsum(diff_arr[i], nums[i], 0, sum(diff_arr[i].values()), 0 ) == False:\n            while self.can_form_target(diff_arr[i], nums[i]) == False:\n                k+=1\n\n                if k > len(queries):\n                    return -1\n\n                left,right,val = queries[k-1]\n                if right >= i:\n                    for j in range(max(left, i), right+1):\n                        if val in diff_arr[j]:\n                            diff_arr[j][val] += 1\n                        else:\n                            diff_arr[j][val] = 1\n\n        return k","author":"Kevin Cui","submissionId":"1575229432"},[]]},{"1418":[{"id":"1418","fileName":"1575229617.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int left = -1;\n        int right = queries.size()-1;\n        while(left<=right) {\n            int mid = left +(right-left)/2;\n            // cout<<left<<\" \"<<mid<<\" \"<<right<<endl;\n            auto nums1=nums;\n            if(ok(mid , nums1, queries)) {\n                right = mid-1;\n            }else{\n                left = mid+1;\n            }\n        }\n        return (left+1)==queries.size()+1?-1:left+1;\n    }\n    bool ok (int mid, vector<int>& nums, vector<vector<int>>& qu) {\n        vector<vector<int>>d(nums.size());\n        for(int i =0 ; i <= mid; i++) {\n            for(auto l = qu[i][0]; l <= qu[i][1];l++) {\n                d[l].push_back(qu[i][2]);\n            }\n        }\n        for(int i = 0; i < nums.size(); i++) {\n            if(nums[i]==0)continue;\n            sort(d[i].begin(), d[i].end());\n            vector<int>dp(nums[i]+1, 0);\n            // cout<<i<<\"xxx \"<<endl;\n            // for(int j: d[i])cout<<j<<\" \";\n            // cout<<endl;\n            dp[0]=1;\n            for(int k=0;k<d[i].size();k++) {\n                // auto dp1 = dp;\n                vector<int>dp1(nums[i]+1,0);\n                // dp.clear();\n                \n                for(int j = nums[i]; j>=0; j--) {\n                    // dp1[j] = dp[j];\n                    \n                    if(j>=d[i][k]){\n                        dp1[j] = max(dp[j-d[i][k]], dp1[j]);\n                        // cout<<mid<<\" \"<,j << \" \"<< d[i][k]<<endl;\n                        \n                    }\n                    dp1[j]=max(dp[j], dp1[j]);\n                }\n                swap(dp,dp1);\n            }\n            \n            if(dp[nums[i]]==0)return false;\n        }\n        return true;\n    }\n    \n};\n// [9]\n// [[0,0,7],[0,0,3],[0,0,8],[0,0,3],[0,0,6],[0,0,5]]\n// 5","author":"zerox130617","submissionId":"1575229617"},[]]},{"1419":[{"id":"1419","fileName":"1575229601.txt","sourceCode":"class Solution {\n    fun minZeroArray(nums: IntArray, queries: Array<IntArray>): Int {\n        val q = queries.size\n        var res = -1\n\n        for ((i, num) in nums.withIndex()) {\n            val memo = Array(q) { IntArray(num + 1) }\n            val neededQueries = minZeroArray(queries, i, 0, num, memo)\n            if (neededQueries == -1) return -1\n            res = maxOf(res, neededQueries)\n        }\n\n        return res\n    }\n\n    fun minZeroArray(queries: Array<IntArray>, i: Int, j: Int, remain: Int, memo: Array<IntArray>): Int {\n        val q = queries.size\n\n        if (remain == 0) return j\n        if (j == q) return -1\n        \n        if (memo[j][remain] != 0) return memo[j][remain]\n\n        val (l, r, v) = queries[j]\n\n        val skip = minZeroArray(queries, i, j + 1, remain, memo)\n\n        if (i !in l..r || v > remain) {\n            memo[j][remain] = skip\n            return skip\n        }\n\n        val notSkip =  minZeroArray(queries, i, j + 1, remain - v, memo)\n        \n        var res = 0\n\n        if (skip == -1) {\n            res = notSkip\n        }\n        else if (notSkip == -1) {\n            res = skip\n        }\n        else {\n            res = minOf(skip, notSkip)\n        }\n\n        memo[j][remain] = res\n        return res\n    }\n}","author":"alexxpasta","submissionId":"1575229601"},[]]},{"1420":[{"id":"1420","fileName":"1575229503.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size();\n        vector<vector<pair<int, int>>> c(n);\n        for(int i = 0; i < q.size(); ++i)\n        {\n            for(int j = q[i][0]; j <= q[i][1]; ++j)\n            {\n                c[j].push_back({q[i][2], i});\n            }\n        }\n        int ans = -1;\n        for(int i = 0; i < n; ++i)\n        {\n            if(a[i] == 0)\n            {\n                ans = max(ans, 0);\n                continue;\n            }\n            int t = -1;\n            bitset<1005> bt = 1;\n            bt = (bt << a[i]);\n            for(int j = 0; j < c[i].size(); ++j)\n            {\n                bt |= (bt >> c[i][j].first);\n                if(bt[0])\n                {\n                    t = c[i][j].second + 1;\n                    break;\n                }\n            }\n            if(t == -1)\n            {\n                ans = -1;\n                break;\n            }\n            ans = max(ans, t);\n        }\n        return ans;\n    }\n};","author":"Speedster1010","submissionId":"1575229503"},[]]},{"1421":[{"id":"1421","fileName":"1575229670.txt","sourceCode":"class Solution {\n    int INF = (int) 1e7;\n    Integer[][] dp;\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int qs = queries.length;\n        int res = -1;\n        for(int i = 0; i < n; i++) {\n            dp = new Integer[qs][nums[i] + 1];\n            int v = dfs(nums[i], i, queries, 0);\n            // System.out.println(i + \" \" + v);\n            if(v >= INF) {\n                return -1;\n            }\n            res = Math.max(res, v);\n        }\n\n        return res;\n    }\n\n    int dfs(int num, int pos, int[][] qs, int idx) {\n        if(num == 0) {\n            return 0;\n        }\n        if(num < 0 || idx == qs.length) {\n            return INF;\n        }\n        if(dp[idx][num] != null) {\n            return dp[idx][num];\n        }\n        int curr = dfs(num, pos, qs, idx + 1);\n        if(qs[idx][0] <= pos && qs[idx][1] >= pos && num >= qs[idx][2]) {\n            curr = Math.min(curr, dfs(num - qs[idx][2], pos, qs, idx + 1));\n        }\n        return dp[idx][num] = 1 + curr;\n    }\n}","author":"Algernon_5","submissionId":"1575229670"},[]]},{"1422":[{"id":"1422","fileName":"1575229628.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& arr, vector<vector<int>>& qry) {\n        // int l=0,r=q.size();\n        // bool ye=0;\n        // while(l<=r){\n        //     int m=(l+r)/2;\n        //     vector<int> a(n.size());\n        //     for(int t=0;t<m;t++){\n        //         a[q[t][0]]+=q[t][2];\n        //         if(q[t][1]<((int)n.size())-1)\n        //         a[q[t][1]+1]-=q[t][2];\n        //     }\n        //     bool ze=1;\n        //     int su=0;\n        //     for(int t=0;t<n.size();t++){\n        //         su+=a[t];\n        //         if(n[t]-su>0){\n        //             ze=0;\n        //             break;\n        //         }\n        //     }\n        //     if(ze){ye=1;\n        //         r=m-1;\n        //     }\n        //     else\n        //         l=m+1;\n        // }\n        // if(!ye)\n        //     return -1;\n        // else\n        //     return l;\n        int ans=-1;\n        vector<bitset<1010>>dp(arr.size());\n        bool alz=1;\n        vector<int> bb(arr.size());\n        for(int r=0;r<arr.size();r++){\n            bb[r]=arr[r];\n        }\n        for(int r=0;r<arr.size();r++){\n            dp[r].reset().set(0,1);\n            if(arr[r]!=0)\n                alz=0;\n        }\n        if(alz)\n            return 0;\n        for(int e=0;e<qry.size();e++){\n            for(int t=qry[e][0];t<=qry[e][1];t++){\n                dp[t]|=(dp[t]<<qry[e][2]);\n                for(int y=arr[t];y<1001;y++)\n                    if(y!=arr[t])\n                    dp[t].reset(y);\n            }\n            bool ach=1;\n            for(int t=0;t<arr.size() && ach;t++){\n                if(!dp[t].test(arr[t]))\n                    ach=0;\n            }\n            if(ach){ans=e+1;\n                    break;\n                }\n        }\n        return ans;\n    }\n};","author":"Gorripati Rithwik Reddy","submissionId":"1575229628"},[]]},{"1423":[{"id":"1423","fileName":"1575229615.txt","sourceCode":"// class Solution {\n\n//     void orIt(vector<bool>& v1 , int x , int n){\n//         if(x > n)\n//             return;\n//         v1[x] = true;\n//         for(int i = 0 ; i < x && i+x < n ; i++){\n//             if(v1[i])\n//                 v1[i+x] = true; \n//         }\n//     }\n\n// public:\n//     int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n\n//         int n = nums.size();\n//         if(count(nums.begin() , nums.end() , 0) == n)\n//             return 0;\n        \n\n//         vector<vector<bool>> ref(n , vector<bool>(1001 , false));\n//         for(auto& i : ref)\n//             i[0] = true;\n\n\n//         for (int k = 0; k < q.size(); k++) {\n//             int l = q[k][0];\n//             int r = q[k][1];\n//             int v = q[k][2];\n\n//             for (int j = l; j <= r; j++) {\n//                 // dp[j] |= (dp[j] << v);\n//                 orIt(ref[j] , v , nums[j]);\n//                 // for (int pos = nums[j] + 1; pos < 1001; pos++) {\n//                 //     dp[j].reset(pos);\n//                 // }\n//             }\n\n//             bool b = true;\n//             for (int j = 0; j < n && b; j++) {\n//                 // if (!dp[j].test(nums[j])) {\n//                 //     allAchieved = false;\n//                 //     break;\n//                 // }\n//                 if(!ref[j][nums[j]])\n//                     b = false;\n//             }\n\n//             if (b) return k + 1;\n//         }\n\n//         return -1;\n//     }\n// };\n\nclass Solution {\nprivate:\n\n    void orIt(vector<bool>& v1, int x, int n) {\n        if(x == 0) \n            return; \n        \n        vector<bool> temp = v1;\n        for(int i = 0; i <= n; i++) {\n            if(v1[i] && i + x <= n) {\n                temp[i + x] = true;\n            }\n        }\n        temp[x] = true;\n        \n        v1 = temp;\n    }\n\n    bool f(int mid , vector<vector<bool>> ref , vector<int>& nums , vector<vector<int>>& q){\n\n        int n = nums.size();\n        for(int k = 0; k <= mid; k++) {\n            int l = q[k][0] , r = q[k][1] , v = q[k][2];\n            \n            for(int j = l; j <= r; j++){\n                if(nums[j] > 0)\n                    orIt(ref[j], v, nums[j]);\n            }\n            \n        }\n\n        bool b = true;\n        for(int j = 0; j < n; j++){\n            if(!ref[j][nums[j]]){\n                b = false;\n                break;\n            }\n        }\n\n        return b;\n        \n    }\n    \npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        \n        int n = nums.size() , nq = q.size();       \n        if(count(nums.begin(), nums.end(), 0) == n)\n            return 0;\n        \n\n        vector<vector<bool>> ref(n , vector<bool>(1001 , false));\n        for(int i = 0; i < n; i++) {\n            ref[i][0] = true; \n        }\n\n        int low = 0 , high = nq-1 , ans = -1;\n\n        while(low <= high){\n\n            int mid = low + (high - low)/2;\n            if(f(mid , ref , nums  , q)){\n                ans = mid+1;\n                high = mid-1;\n            }\n            else\n                low = mid+1;\n            \n        }\n\n        return ans;\n        \n    }\n};","author":"Probie_17","submissionId":"1575229615"},[]]},{"1424":[{"id":"1424","fileName":"1575229748.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        # this was binary search before. Is it still? \n        # If it works for k, it will still work for k + 1. \n        # Might be BSA\n        # less than ten numbers \n        # numbers less than 1000\n\n        # how many queries does it take to reduce index i? \n        # this is like a knapsack. with discrete sum T, it might take O(QT) to see if they work. \n        # might be like O(n^2 logn)\n\n        # Lets focus on the values for a given index.\n        # say after processing the queries, we can have values of length Q, (may be zero if idx was not in range)\n        # Run standard DP on this. \n        Q = len(queries)\n        N = len(nums)\n        moves_req = [0] * N\n        # get the values offered to each index at each turn \n        idx_to_values = defaultdict(list)\n        for l, r, v in queries:\n            for idx in range(N):\n                if l <= idx <= r:\n                    idx_to_values[idx].append(v)\n                else:\n                    idx_to_values[idx].append(0)\n        \n    \n        \n\n        # now for each idx, determine the min steps to get it to zero.\n        # we want the max of these\n        for idx in range(N):\n            @cache        \n            def DP(i, targ):\n                \n                \"\"\"True if we can get target down to zero from index i in the value arr for idx\"\"\"\n                if targ == 0:\n                    #print(f'we can get to zero with {i} queries for {idx}')\n                    return i \n                if i == Q:\n                    return -1\n                if targ < 0:\n                    return -1\n                    \n                val = idx_to_values[idx][i]\n                #print(f'using {val} with target {targ}')\n                use = DP(i + 1, targ - val)\n                lose = DP(i + 1, targ)\n                if use >= 0 and lose >= 0:\n                    moves_req[idx] = min(use, lose)\n                    return min(use, lose)\n                if use >= 0:\n                    #print(use)\n                    moves_req[idx] = use\n                    return use\n                elif lose>=0:\n                    moves_req[idx] = lose\n                    return lose\n                else:\n                    #print(i)\n                    moves_req[idx] = -1\n                    return -1 \n            DP(0, nums[idx])\n        M = min(moves_req)\n        if M == -1:\n            return -1 \n        \n        return max(moves_req)\n                    \n            \n\n            \n            \n            \n        \n        \n        \n        \n        ","author":"Connor Colombe","submissionId":"1575229748"},[]]},{"1425":[{"id":"1425","fileName":"1575229779.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        l, r = 0, len(queries)\n\n        if not self._isAllZero(nums, queries, len(queries)):\n            return -1\n\n        res = 0\n        while l <= r:\n            mid = l + (r-l) // 2\n            #print(f'l = {l}, r = {r}, mid = {mid}')\n            if not self._isAllZero(nums, queries, mid): \n                l = mid + 1\n            else:\n                res = mid\n                r = mid - 1\n\n        return res\n            \n    def _isAllZero(self, nums, queries, k):\n\n        idx_to_decrements = {idx:[] for idx in range(len(nums))}\n        \n        for i in range(k):\n            l, r, decrement_value = queries[i]\n            for j in range(l, r + 1):\n                idx_to_decrements[j].append(decrement_value)\n        print(idx_to_decrements)\n        for idx in idx_to_decrements:\n            if not self.isSubsetSum(idx_to_decrements[idx], nums[idx]):\n                #print(f'Not possible to sum to {nums[idx]} using {idx_to_decrements[idx]} for idx {idx}')\n                return False\n\n        return True\n\n    def isSubsetSum(self, arr, sum):\n        n = len(arr)\n        prev = [False] * (sum + 1)\n        curr = [False] * (sum + 1)\n    \n        # Base case: sum 0 can always \n        # be achieved\n        prev[0] = True\n    \n        # Fill the dp table in a\n        # bottom-up manner\n        for i in range(1, n + 1):\n            for j in range(sum + 1):\n                if j < arr[i - 1]:\n                    curr[j] = prev[j]\n                else:\n                    curr[j] = prev[j] or prev[j - arr[i - 1]]\n            prev = curr.copy() \n    \n        return prev[sum]","author":"edwardxiaoyicong","submissionId":"1575229779"},[]]},{"1426":[{"id":"1426","fileName":"1575229792.txt","sourceCode":"class Solution {\npublic:\n    int zm(vector<vector<int>>& queries,int ind,int tot,int i, vector<vector<int>> &dp){\n        if(tot==0){\n            dp[i][tot]=i-1;\n            return i-1;\n        }\n        if(i==queries.size()){\n            dp[i][tot]=INT_MAX;\n            return INT_MAX;\n        }\n        if (dp[i][tot] != -1) {\n            return dp[i][tot];\n        }\n        if(dp[i+1][tot]==-1){\n            dp[i+1][tot]=zm(queries,ind,tot,i+1,dp);\n        }\n        int l=dp[i+1][tot];\n        if(queries[i][0]<=ind && queries[i][1]>=ind && tot>=queries[i][2]){\n            if(dp[i+1][tot-queries[i][2]]==-1){\n                dp[i+1][tot-queries[i][2]]=zm(queries,ind,(tot-queries[i][2]),i+1,dp);\n            }\n            l=min(dp[i+1][tot-queries[i][2]],l);\n        }\n        dp[i][tot]=l;\n        return l;\n        \n    }\n    int mnz(vector<vector<int>>& queries,int ind,int tot){\n        if(tot==0){\n            return -1;\n        }\n        \n        vector<vector<int>> dp(queries.size()+1,vector<int> (tot+1,-1));\n        zm(queries,ind,tot,0,dp);\n        int l=dp[0][tot];\n        // if(l==INT_MAX){\n        //     return -1;\n        // }\n        return l;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans=-1;\n        \n        for(int i=0;i<nums.size();i++){\n            \n            int l=mnz(queries,i,nums[i]);\n            if(l==INT_MAX){\n                return -1;\n            }\n            if(ans<l){\n                ans=l;\n            }\n        }\n        \n        return ans+1;\n    }\n};","author":"Kunal Gupta","submissionId":"1575229792"},[]]},{"1427":[{"id":"1427","fileName":"1575229871.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<vector<pair<int,int>>> v(nums.size());\n        for(int i=0;i<queries.size();i++){\n            for(int j=queries[i][0];j<=queries[i][1];j++){\n                v[j].push_back({queries[i][2],i+1});\n            }\n        }\n        vector<int> maxi(nums.size(),INT_MAX);\n        for(int i=0;i<nums.size();i++){\n            int targetsum=nums[i];\n            if(targetsum==0) {\n                maxi[i]=0;\n                continue;\n            }\n            else if(v[i].size()==0) continue;\n            else {\n                vector<vector<bool>> dp(v[i].size()+1,vector<bool>(targetsum+1,false));\n                 vector<vector<int>> index(v[i].size()+1,vector<int>(targetsum+1,INT_MAX));\n                for(int j=0;j<=v[i].size();j++) dp[j][0]=true; \n                for(int j=1;j<=v[i].size();j++){\n                    for(int k=0;k<=targetsum;k++){\n                        dp[j][k]=dp[j-1][k];\n                        if(k>=v[i][j-1].first) dp[j][k]=dp[j][k] || dp[j-1][k-v[i][j-1].first];\n                         index[j][k] = index[j - 1][k];\n                        if(dp[j][k]) index[j][k]=min(index[j][k],v[i][j-1].second);\n                    }\n                }\n                \n                maxi[i]=index[v[i].size()][targetsum];\n            }\n        }\n        int maxim=*max_element(maxi.begin(),maxi.end());\n        if(maxim==INT_MAX) return -1;\n        else return maxim;\n    }\n};","author":"satyamg_07","submissionId":"1575229871"},[]]},{"1428":[{"id":"1428","fileName":"1575230007.txt","sourceCode":"class Solution {\npublic:\n    int dp[1001][1001];\n    bool sol(vector<int>&v,int idx,int sum){\n        if(sum==0){\n            return true;\n        }\n        else if(idx==v.size()){\n            return false;\n        }\n        else if(dp[idx][sum]!=-1){\n            return dp[idx][sum];\n        }\n        else\n        {\n            \n            int ans = false;\n            if(v[idx]<=sum){\n                ans = sol(v,idx+1,sum-v[idx]);\n            }\n            return dp[idx][sum] = sol(v,idx+1,sum) || ans;\n        }\n    }\n    bool check(vector<int>&nums,int mid,vector<vector<int>>&q){\n        int n=nums.size();\n        vector<unordered_map<int,int>>helper(n);\n        for(int i=0;i<=mid;i++){\n            int start = q[i][0];\n            int end = q[i][1]+1;\n            int val = q[i][2];\n            helper[start][val]++;\n            if(end<n){\n                helper[end][val]--;\n            }\n        }\n        unordered_map<int,int>m;\n        // cout<<\"For mid :: \"<<mid<<endl;\n        for(int i=0;i<n;i++){\n            for(auto &it:helper[i]){\n                m[it.first]+=it.second;\n            }\n            vector<int>v;\n            for(auto &it:m){\n                int times = it.second;\n                while(times--)\n                v.push_back(it.first);\n            }\n           \n            memset(dp,-1,sizeof(dp));\n            if(!sol(v,0,nums[i])){\n                return false;\n            }\n            \n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int low =0 ;\n        int n=q.size();\n        int high = n-1;\n        int ans = -1;\n        int count=0;\n        for(auto &i:nums){\n            if(i==0){\n                count++;\n            }\n        }\n        if(count==nums.size()){\n            return 0;\n        }\n        while(low<=high){\n            int mid = (low+high)/2;\n            if(check(nums,mid,q)){\n                ans = mid+1;\n                high = mid -1;\n            }\n            else{\n                low = mid+1;\n            }\n        }\n        return ans;\n    }\n};","author":"CASIO-FX69","submissionId":"1575230007"},[]]},{"1430":[{"id":"1430","fileName":"1575230139.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        boolean[][] test = new boolean[n][1001];\n        int zz=0;\n        while(zz<nums.length){\n            test[zz][0] = true;\n            zz++;\n        }\n        boolean zero=true;\n        for(int i:nums)\n            {\n                if(i!=0) zero=false;\n            }\n        if (zero) return 0;\n        \n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0], r = queries[k][1], v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n                boolean[] shift = new boolean[1001];\n\n                for (int i = 0; i < 1001 - v; i++) {\n                    if (test[j][i]) {\n                        shift[i + v] = true;\n                    }\n                }\n\n                for (int i = 0; i < 1001; i++) {\n                    test[j][i] |= shift[i];\n                }\n\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    test[j][pos] = false;\n                }\n            }\n\n            boolean achieved = true;\n            int tt = 0;\n            while (tt < n) {\n                if (!test[tt][nums[tt]]) {\n                    achieved = false;\n                    break;\n                }\n                tt++;\n                }\n\n            if (achieved) return k + 1;\n        }\n        return -1;\n    }\n}","author":"Sumith_15","submissionId":"1575230139"},[]]},{"1431":[{"id":"1431","fileName":"1575230113.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        dp = [[[False for k in range(nums[i] + 1)] for j in range(len(queries) + 1)] for i in range(len(nums))]\n        for i in range(len(nums)):\n            dp[i][0][nums[i]] = True\n\n        for j in range(1, len(queries) + 1):\n            for i in range(len(nums)):\n                for k in range(nums[i] + 1):\n                    dp[i][j][k] = dp[i][j - 1][k]\n                    l, r, val = queries[j - 1][0], queries[j - 1][1], queries[j - 1][2]\n                    if i >= l and i <= r and k + val <= nums[i]:\n                        dp[i][j][k] = dp[i][j][k] or dp[i][j - 1][k + val]\n\n        # print(dp)\n        ans = 0\n        for j in range(len(queries), -1, -1):\n            for i in range(len(nums)):\n                # print(i, j, dp[i][j][0])\n                if not dp[i][j][0]:\n                    return -1 if j + 1 > len(queries) else j + 1\n        return ans","author":"yw w","submissionId":"1575230113"},[]]},{"1432":[{"id":"1432","fileName":"1575230184.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        dp = [[False] * (num + 1) for num in nums]\n        n  = len(nums)\n        m  = len(queries)\n        res = 0\n        min_val = [0] * n\n        for a in range(n):\n            dp[a][nums[a]] = True\n            min_val[a] = nums[a]\n            \n        if (all(row[0] for row in dp)):\n            return res\n        \n        for b in range(m):\n            l = queries[b][0]\n            r = queries[b][1]\n            val = queries[b][2]\n            for i in range(l, r + 1):\n                for j in range(val, len(dp[i])):\n                    if dp[i][j] == True:\n                        dp[i][j - val] = True\n                        min_val[i] = min(min_val[i], j - val)\n            res = res + 1\n            if (all(row[0] for row in dp)):\n                return res\n\n        return -1\n                \n                    \n        \n        ","author":"YitLuo","submissionId":"1575230184"},[]]},{"1433":[{"id":"1433","fileName":"1575230205.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int q = queries.size();\n        int ans = 0;\n        int n = nums.size();\n        // int zeros = 0;\n        for(int i=0;i<n;i++){\n            int ind = -1;\n            int tar = nums[i];\n            if(tar == 0){\n                continue;\n            }\n            set<int> st;\n            for(int j=0;j<q;j++){\n                int l = queries[j][0];\n                int r = queries[j][1];\n                int val = queries[j][2];\n                if(i>=l && i<=r){\n                    vector<int> tmp = {val};\n                    for(int it: st){\n                        tmp.push_back(it+val);\n                    }\n                    for(int it: tmp){\n                        st.insert(it);\n                    }\n                    if(st.find(tar) != st.end()){\n                        ind = j+1;\n                        break;\n                    }\n                }\n            }\n            if(ind == -1) return -1;\n            ans = max(ans, ind);\n        }\n\n        return ans;      \n    }\n};","author":"Ujjawal Lele","submissionId":"1575230205"},[]]},{"1434":[{"id":"1434","fileName":"1575230228.txt","sourceCode":"class Solution {\npublic:\n    int Memo(vector<vector<int>>& q,int i,int Sum,int& idx,vector<vector<int>>& dp){\n        if(Sum==0) return i;\n        if(Sum<0 || i>=q.size()) return INT_MAX;\n        if(dp[i][Sum]!=-1) return dp[i][Sum];\n        int res = INT_MAX;\n        if(idx>=q[i][0] && idx<=q[i][1]){\n            res = Memo(q,i+1,Sum-q[i][2],idx,dp);\n        }\n        res = min(res,Memo(q,i+1,Sum,idx,dp));\n        return dp[i][Sum] = res;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int res = 0;\n        for(int i=0;i<nums.size();i++){\n            if(nums[i]==0) continue;\n            vector<vector<int>> dp(queries.size(),vector<int>(1001,-1));\n            auto ans = Memo(queries,0,nums[i],i,dp);\n            res = max(ans,res);\n        }\n        return (res==INT_MAX)?-1:res;\n    }\n};","author":"Bhagyesh Nimbalkar","submissionId":"1575230228"},[]]},{"1435":[{"id":"1435","fileName":"1575230421.txt","sourceCode":"class Solution {\npublic:\n     bool check(vector<int>& nums, vector<vector<int>>& queries, int mid) {\n        int n = nums.size(); \n        for (int ind = 0; ind < n; ind++) {\n            int num = nums[ind]; \n            vector<int> dp(1001, 0);\n            dp[0] = 1;\n            for (int i = 0; i < mid; i++) {\n                int l = queries[i][0], r = queries[i][1], value = queries[i][2];\n                if (l <= ind && ind <= r) {  \n                    for (int sum = 1000; sum >= value; sum--) {\n                        dp[sum] |= dp[sum - value];\n                    }\n                }\n            }\n            if (!dp[num]) return false;\n        }\n        return true; \n    } \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int low=0,high=queries.size(),mid,ans=-1;\n        while(low<=high){\n            mid = (low+high)/2;\n            // memset(dp,0,sizeof(dp));\n            if(check(nums,queries,mid)){\n                ans = mid;\n                high = mid-1;\n            }\n            else low = mid+1;\n        }\n        return ans;\n    }\n};","author":"VVS Raghavendra","submissionId":"1575230421"},[]]},{"1436":[{"id":"1436","fileName":"1575230218.txt","sourceCode":"class Solution {\npublic:\n    bool canCreateZero(const vector<int>& nums,\n                       const vector<vector<int>>& queries, int k) {\n        int n = (int)nums.size();\n\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n\n            vector<int> vals;\n            for (int q = 0; q < k; q++) {\n\n                if ((int)queries[q].size() < 3)\n                    continue;\n                int l = queries[q][0], r = queries[q][1], val = queries[q][2];\n\n                if (l < 0)\n                    l = 0;\n                if (r >= n)\n                    r = n - 1;\n                if (i >= l && i <= r) {\n                    vals.push_back(val);\n                }\n            }\n\n            vector<bool> dp(target + 1, false);\n            dp[0] = true;\n            for (int v : vals) {\n\n                for (int s = target; s >= v; s--) {\n                    if (dp[s - v]) {\n                        dp[s] = true;\n                    }\n                }\n            }\n            if (!dp[target]) {\n\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int m = (int)queries.size();\n\n        for (int k = 0; k <= m; k++) {\n            if (canCreateZero(nums, queries, k)) {\n                return k;\n            }\n        }\n        return -1;\n    }\n};","author":"mouseaccel","submissionId":"1575230218"},[]]},{"1437":[{"id":"1437","fileName":"1575230481.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int rec(int k, vector<bitset<1001>> dp, const vector<int>& nums, const vector<vector<int>>& queries) {\n        int n = nums.size();\n        if (k == queries.size()) return -1;\n        int l = queries[k][0], r = queries[k][1], v = queries[k][2];\n        for (int j = l; j <= r; j++) {\n            dp[j] |= (dp[j] << v);\n            for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                dp[j].reset(pos);\n            }\n        }\n        bool check = true;\n        for (int j = 0; j < n; j++) {\n            if (!dp[j].test(nums[j])) {\n                check = false;\n                break;\n            }\n        }\n        if (check) return k + 1;\n        return rec(k + 1, dp, nums, queries);\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<bitset<1001>> dp(n);\n        for (int j = 0; j < n; j++) {\n            dp[j].set(0);\n        }\n        bool check = true;\n        for (int j = 0; j < n; j++) {\n            if (nums[j] != 0) {\n                check = false;\n                break;\n            }\n        }\n        if (check) return 0;\n        return rec(0, dp, nums, queries);\n    }\n};\n","author":"nayan8804","submissionId":"1575230481"},[]]},{"1438":[{"id":"1438","fileName":"1575230511.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if max(nums)==0: return 0\n            \n        def possible(q:int)-> bool:\n            for i,num in enumerate(nums):\n                qs = []\n                for qu in queries[:q+1]:\n                    if qu[0]<=i<=qu[1]:\n                        qs.append(qu[2])\n                                        \n                @cache\n                def valid(ind:int,remaining:int) -> bool:\n                    if remaining ==0: return True\n                    elif remaining<0: return False\n                    elif ind<0: return False\n                    return valid(ind-1,remaining) or valid(ind-1,remaining-qs[ind])\n                if not valid(len(qs)-1,num): return False\n\n            return True\n        \n        low,high = 0,len(queries)\n        while low<high:\n            mid = (low+high)//2\n            if possible(mid):\n                high = mid\n            else:\n                low = mid+1\n        return low+1 if low+1<=len(queries) else -1","author":"iamcoder1","submissionId":"1575230511"},[]]},{"1439":[{"id":"1439","fileName":"1575230522.txt","sourceCode":"def helper(nums, queries):\n    if all(x==0 for x in nums): return 0\n    dp = [[False]*1001 for _ in nums]\n    for row in dp: row[0] = True\n    for i, (l, r, v) in enumerate(queries):\n        for j in range(l, r+1):\n            shifted = [False]*1001\n            for s in range(1001 - v):\n                if dp[j][s]: shifted[s+v] = True\n            for s in range(1001):\n                dp[j][s] |= shifted[s]\n            for s in range(nums[j]+1, 1001):\n                dp[j][s] = False\n        if all(dp[idx][nums[idx]] for idx in range(len(nums))):\n            return i+1\n    return -1\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        return helper(nums,queries)\n        ","author":"Eaten_zombie","submissionId":"1575230522"},[]]},{"1440":[{"id":"1440","fileName":"1575230562.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        test = []\n        for n in nums: \n            if n !=0:\n                test.append({n})\n            else: test.append('g')\n        if all(n == 'g' for n in test): return 0\n        t = 0\n        for a,b,v in queries:\n            t+=1\n            for i in range(a,b+1):\n                if test[i] == 'g': continue\n                \n                if v in test[i]: \n                    test[i] = 'g'\n                    continue\n                new = set()\n                for s in test[i]:\n                    \n                    if s>v:\n                        new.add(s-v)\n                for n in new:\n                        test[i].add(n)\n            if all(n == 'g' for n in test): return t\n            \n        if all(n=='g' for n in test): return t\n        return -1\n            ","author":"marktr53","submissionId":"1575230562"},[]]},{"1442":[{"id":"1442","fileName":"1575230676.txt","sourceCode":"class Solution {\n     public int minIndexForSubsetSum(List<Integer> nums, int k) {\n        int n = nums.size();\n        int[][] dp = new int[n + 1][k + 1]; \n        for (int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE); \n        dp[0][0] = -1; // Base case: sum 0 at index -1\n        \n        for (int i = 0; i < n; i++) {\n            int num = nums.get(i);\n            for (int sum = 0; sum <= k; sum++) {\n                if (dp[i][sum] != Integer.MAX_VALUE) {\n                    dp[i + 1][sum] = Math.min(dp[i + 1][sum], dp[i][sum]); // Exclude current element\n                    if (sum + num <= k) {\n                        dp[i + 1][sum + num] = Math.min(dp[i + 1][sum + num], i); // Include current element\n                    }\n                }\n            }\n        }\n\n        return dp[n][k] == Integer.MAX_VALUE ? -1 : dp[n][k]; // Minimum index where subset sum == k\n    }\n    public int minZeroArray(int[] nums, int[][] qr) {\n        int n = nums.length;\n         List<Integer>[][] list = new ArrayList[n][2]; // Correct way to declare\n        for (int i = 0; i < n; i++) {\n            list[i][0] = new ArrayList<>();\n            list[i][1] = new ArrayList<>();\n        }\n        int k = 1;\n        for( int[] q : qr){\n            int l =q[0];\n            int r= q[1];\n            int val = q[2];\n            for( int i = l ; i<= r ; i++){\n                list[i][0].add(val);\n                list[i][1].add(k);\n            }\n            k++;\n        }\n        int ans = 0;\n        for( int i =0; i<n;i++){\n            if(nums[i] ==0){\n                continue;\n            }\n            int ele = minIndexForSubsetSum(list[i][0], nums[i]);\n            if(ele==-1) return -1;\n            ans = Math.max(ans,list[i][1].get(ele));\n        }\n        return ans;\n    }\n}","author":"Aghori","submissionId":"1575230676"},[]]},{"1443":[{"id":"1443","fileName":"1575230585.txt","sourceCode":"#include<vector> \n#include<cmath>  \n\nclass Solution {\npublic: \n    const int RANGE = 1000 ;  \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int height = nums.size() ; \n        int greater= 0  ;  \n        bool choice = true ; \n        for(int fc=0;fc<height;fc++){\n            std::vector<bool> dynamics(RANGE+1) ; \n            dynamics[0] = true ;  \n            if(dynamics[nums[fc]]==true){\n                greater = fmax(0,greater) ; \n                continue ; \n                }  \n            for(int fd=0;fd<queries.size();fd++){\n                std::vector<int>& phase = queries[fd] ; \n                if(fc<=phase[1]&&fc>=phase[0]){\n                    for(int fe=RANGE;fe>=0;fe--){\n                        if(dynamics[fe]==true){\n                            if(fe+phase[2]<=RANGE){\n                                dynamics[fe+phase[2]] = true ;  \n                            }\n                        }\n                    }\n                }  \n                if(dynamics[nums[fc]]==true){\n                    greater = fmax(fd+1,greater) ; \n                    break ; \n                }\n            }  \n            if(dynamics[nums[fc]]==false){\n                choice = false ; \n                break  ;  \n            }\n        }  \n        if(choice==false){return -1 ; }\n        return  greater ;  \n    }\n};","author":"Paul Owei","submissionId":"1575230585"},[]]},{"1444":[{"id":"1444","fileName":"1575230630.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], qu: List[List[int]]) -> int:\n        nm=len(qu)\n        k=0\n        n=len(nums)\n        arr=[]\n        for i in range(n):\n            arr.append([])\n        for i in range(nm):\n            l,r,val=qu[i]\n            for j in range(l,r+1):\n                arr[j].append([val,i+1])\n         \n        for i in range(n):\n            tar=nums[i]\n            ss=arr[i]\n            if tar==0:\n                continue  \n            dig=[]\n            for we in range(tar+1):\n                dig.append([])\n            for we in range(len(ss)):\n                vval,cnt=ss[we]\n                nn=[]\n                for j in range(tar+1):\n                    nn.append(dig[j].copy())\n                for j in range(tar+1):\n                    if len(dig[j])>0 and j+vval<=tar:\n                        nn[j+vval].append(cnt)\n                        \n                if vval<=tar:\n                    nn[vval].append(cnt)\n                dig=nn.copy()\n    \n            if (len(dig[tar])>0):\n                k=max(k,dig[tar][0])\n            else:\n                return -1\n        return k\n\n\n\n\n            \n        return k\n                \n                    \n        \n            \n            \n            \n            \n        \n        ","author":"Naveents1915","submissionId":"1575230630"},[]]},{"1445":[{"id":"1445","fileName":"1575230801.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        int res = 0;\n        for(int i = 0; i < n; i++) {\n            int v = nums[i];\n            if(!v) continue;\n            vector<bool> dp(v+1, 0);\n            dp[0] = 1;\n            int j = 0;\n            for(; j < m; j++) {\n                if(i < queries[j][0] || queries[j][1] < i) continue;\n                for(int k = v; k >= queries[j][2]; k--) {\n                    if(dp[k-queries[j][2]]) dp[k] = 1;\n                }\n                if(dp[v]) break;\n            }\n            if(!dp[v]) return -1;\n            // for(bool b: dp) cout << b << ' ';\n            // cout << endl;\n            // cout << j << endl;\n            res = max(res, j+1);\n        }\n        return res;\n    }\n};","author":"h_bugw7","submissionId":"1575230801"},[]]},{"1446":[{"id":"1446","fileName":"1575230786.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n        vector<vector<bool>> dp(n, vector<bool>(1001, false));\n        for(int j = 0; j < n; j++) dp[j][0] = true;\n        bool x = true;\n        for(int j = 0; j < n; j++){\n            if(nums[j] != 0) x = false;\n        }\n        if(x) return 0;\n        for(int k = 0; k < q.size(); k++){\n            int l = q[k][0];\n            int r = q[k][1];\n            int val = q[k][2];\n            for(int j = l; j <= r; j++){\n                vector<bool> curr(1001, false);\n                for(int s = 0; s <= nums[j]; s++){\n                    if(dp[j][s]){\n                        if(s + val <= 1000){\n                            curr[s + val] = true;\n                        }\n                    }\n                }\n                for(int s = 0; s <= 1000; s++){\n                    dp[j][s] = dp[j][s] || curr[s];\n                }\n            }\n            bool poss = true;\n            for(int j = 0; j < n; j++){\n                if(!dp[j][nums[j]]){\n                    poss = false;\n                    break;\n                }\n            }\n            if(poss) return k + 1;\n        }\n\n        return -1;\n    }\n};","author":"Ishit_7788","submissionId":"1575230786"},[]]},{"1448":[{"id":"1448","fileName":"1575230790.txt","sourceCode":"class Bag:\n    num: int\n    flag: bool = False\n    memo: set\n    queries: int = 0\n    \n    def __init__(self, num):\n        if num == 0:\n            self.flag = True\n            Bag.queries -= 1\n            return\n        self.num = num\n        self.memo = {num}\n    \n    def add(self, num):\n        if self.flag:\n            return\n        new_memo = set()\n        for x in self.memo:\n            if x == num:\n                self.flag = True\n                Bag.queries -= 1\n                return\n            elif x - num > 0:\n                new_memo.add(x - num)\n        self.memo |= new_memo\n\n\nclass Solution:\n    def minZeroArray(self, nums: list[int], queries: list[list[int]]) -> int:\n        m = len(nums)\n        n = len(queries)\n        Bag.queries = m\n        table = [Bag(nums[i]) for i in range(m)]\n        if Bag.queries == 0:\n            return 0\n        for i in range(n):\n            l, r, val = queries[i]\n            for j in range(l, r + 1):\n                table[j].add(val)\n                if Bag.queries == 0:\n                    return i + 1\n        return -1\n\n","author":"hemerocalle","submissionId":"1575230790"},[]]},{"1449":[{"id":"1449","fileName":"1575230942.txt","sourceCode":"class Solution {\npublic:\n\n\n\n    int f(int sum, int idx, vector<int> &op, map<pair<int,int>, int>& dp){\n        if(sum == 0){\n            return min(idx, (int)op.size());\n        }\n        if(idx >= op.size()){\n            return -1;\n        }\n        pair<int,int> p = make_pair(sum,idx);\n        if(dp.find(p) != dp.end()){\n            return dp[p];\n        }\n\n        int take = -1, dont = f(sum, idx+1, op,dp);\n        if(sum >= op[idx]){\n            take = f(sum-op[idx], idx+1, op,dp);\n        }\n\n        int here = dont;\n        if(take != -1){\n            if(here == -1){\n                here =take;\n            }\n            here = min(here, take);\n        }\n\n        dp[p] = here;\n        return here;\n    }\n\n    int solveFor(vector<int> & op,vector<int> & step, int sum){\n        if(sum == 0){return 0;}\n        map<pair<int,int>, int> dp;\n        \n        int here = f(sum, 0, op,dp);\n        \n        \n        if(here == -1){\n            return here;\n        }\n        if(here == 0){\n            return 0;\n        }\n        \n        return step[here-1];\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& qs) {\n        int n = nums.size(), q = qs.size();\n        vector<int> ops[n];\n        int s =1;\n        vector<int> step[n];\n        for(vector<int> &q : qs){\n            int l = q[0] , r = q[1], v = q[2];\n\n            for(int i = l;i<=r;i++){\n                ops[i].push_back(v);\n                step[i].push_back(s);\n            }\n            \n            s++;\n            \n        }\n\n        int ans = -1, notfound = 0;\n        for(int i =0;i<n;i++){\n           int here = solveFor(ops[i],step[i], nums[i]);\n            if(here == -1){\n                return -1;\n            }\n            ans = max(ans, here);\n        }\n\n        return ans;\n        \n\n        \n        \n    }\n};","author":"khalil shaik","submissionId":"1575230942"},[]]},{"1450":[{"id":"1450","fileName":"1575230867.txt","sourceCode":"#define inf 100000000\nclass Solution {\npublic:\n    int fun(vector<pair<int,int>>&vec, int val, int ind, vector<vector<int>>&dp){\n        if(ind == vec.size()) return inf;\n        if(dp[ind][val] != -1) return dp[ind][val];\n        \n        \n        if(val > vec[ind].first){\n            dp[ind][val] = min(fun(vec, val-vec[ind].first, ind+1, dp), fun(vec, val, ind+1, dp));\n        } else if(val < vec[ind].first){\n            dp[ind][val] = fun(vec, val, ind+1, dp);\n        } else{\n            dp[ind][val] = vec[ind].second;\n        }\n        return dp[ind][val];\n        \n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int ans = -1;\n        for(int i=0;i<nums.size();i++){\n            int val = nums[i];\n            if(!val){\n                continue;\n            }\n            vector<pair<int,int>>vec;\n            vector<vector<int>>dp;\n            for(int j=0;j<q.size();j++){\n                if(q[j][0] <= i && q[j][1] >= i){\n                    vec.push_back({q[j][2], j});\n                }\n            }\n            dp.resize(vec.size(), vector<int>(val+1, -1));\n            int tmpans = fun(vec, val, 0, dp);\n            //cout << \"val: \" << val << \" \" << \"tmpans: \" << tmpans << endl;\n            if(tmpans == inf){\n                return -1;\n            }\n            ans = max(ans, tmpans);\n        }\n        return ans + 1;\n    }\n};","author":"Srini","submissionId":"1575230867"},[]]},{"1451":[{"id":"1451","fileName":"1575230941.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<bool>>dp(n, vector<bool>(1001, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        bool found = true;\n        for (auto x: nums) {\n            if (x != 0) {\n                found = false;\n                break;\n            }\n        }\n\n        if(found) return 0;\n\n\n        for (int q = 0; q < queries.size(); q++) {\n            int l = queries[q][0];\n            int r = queries[q][1];\n            int val = queries[q][2];\n\n            for (int i = l; i <= r; i++) {\n                for (int j = 1000; j >= val; j--) {\n                    if (dp[i][j - val]) {\n                        dp[i][j] = true;\n                    }\n                }\n\n                for (int j = nums[i] + 1; j < 1001; j++) {\n                    dp[i][j] = false;\n                }\n            }\n\n            bool saare0 = true;\n            for (int i = 0; i < n; i++) {\n                if (dp[i][nums[i]] == false) {\n                    saare0 = false;\n                    break;\n                }\n            }\n\n            if (saare0) return q + 1;\n        }\n\n        return -1;\n    }\n};\n","author":"Mayur Srivastav","submissionId":"1575230941"},[]]},{"1452":[{"id":"1452","fileName":"1575231028.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size();\n        \n        \n        int left = 0, right = q, result = -1;\n\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            \n            vector<bitset<10001>> bitsets(n); \n            for (int i = 0; i < n; i++) bitsets[i][0] = 1; \n            \n            for (int j = 0; j < mid; j++) {\n                int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                \n                for (int i = l; i <= r; i++) {\n                    bitsets[i] |= (bitsets[i] << val);\n                }\n            }\n            \n\n            bool valid = true;\n            for (int i = 0; i < n; i++) {\n                if (nums[i] > 0 && !bitsets[i][nums[i]]) {\n                    valid = false;\n                    break;\n                }\n            }\n\n            if (valid) {\n                result = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        \n        return result;\n    }\n};\n","author":"Jaideep_Madiraju","submissionId":"1575231028"},[]]},{"1453":[{"id":"1453","fileName":"1575231037.txt","sourceCode":"class Solution {\npublic:\n\n    bool subsetSum(vector<int>& arr, int target) {\n    int n = arr.size();\n    vector<vector<bool>> dp(n + 1, vector<bool>(target + 1, false));\n\n    \n    for (int i = 0; i <= n; i++) dp[i][0] = true;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= target; j++) {\n            dp[i][j] = dp[i - 1][j]; \n            if (j >= arr[i - 1]){\n                dp[i][j] = dp[i][j] || dp[i - 1][j - arr[i - 1]];\n            }  \n        }\n    }\n\n    return dp[n][target];\n}\n\n\n    bool check(vector<int>&nums , int k , vector<vector<int>>& queries){\n        int size = nums.size();\n        unordered_map<int,vector<int>> adj;\n        for(int i=0;i<k;i++){\n            int l = queries[i][0] , r = queries[i][1] , val = queries[i][2];\n            for(int p=l;p<=r;p++){\n                adj[p].push_back(val);\n            }\n        }\n\n        for(int i=0;i<size;i++){\n            int target = nums[i];\n            if(!subsetSum(adj[i],target)) return false;\n        }\n\n        return true;\n        \n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int size = nums.size();\n        int q_size = queries.size();\n        int start = 0 , end = q_size;\n        int res = -1;\n        while(start <= end){\n            int mid = (start + end) / 2;\n            if(check(nums,mid,queries)){\n                res = mid;\n                end = mid-1;\n            }\n            else{\n                start = mid+1;\n            }\n        }\n        return res;\n    }\n};","author":"rahul_6677","submissionId":"1575231037"},[]]},{"1454":[{"id":"1454","fileName":"1575231223.txt","sourceCode":"class Solution {\npublic:\n    bool isSubsetSum(vector<int>& nums, int target) {\n    vector<bool> dp(target + 1, false);\n    dp[0] = true; \n\n    for (int num : nums) {\n        for (int j = target; j >= num; j--) {\n            dp[j] = dp[j] || dp[j - num];\n        }\n    }\n    return dp[target];\n}\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n     \n         int n=nums.size(),m=q.size();\n        \n        map<int,vector<int>> mp;\n        \n        \n        bool f=true;\n        int cnt=0;\n        \n        for(auto it:nums){\n            if(it!=0){\n                f=false;\n                break;\n            }\n        }\n        if(f){\n            return 0;\n        }\n       \n        \n        for(int i=0;i<m;i++){\n            f=true;\n              int l=q[i][0],r=q[i][1],val=q[i][2];\n              for(int j=l;j<=r;j++){\n                 \n                  \n                  mp[j].push_back(val);\n                  \n                  if(nums[j]!=0){\n                 if(isSubsetSum(mp[j],nums[j])){\n                     nums[j]=0;\n                 }\n                      }\n                 \n              }\n            \n            for(auto it:nums){\n                if(it!=0){\n                    f=false;\n                    break;\n                }\n            }\n            \n            if(f){\n                cnt++;\n                break;\n            }\n            else{\n                cnt++;\n            }\n            \n             \n            \n        }\n        \n        if(f){\n            return cnt;\n        }\n        else return -1;\n        \n        \n        \n        \n    }\n};","author":"Shubham Chauhan","submissionId":"1575231223"},[]]},{"1455":[{"id":"1455","fileName":"1575231145.txt","sourceCode":"class Solution {\npublic:\n    bool check1(int val, vector<int>&vec)\n    {\n        vector<bool>vis(val+1, 0);\n        vis[0]=1;\n        for(auto num:vec)\n        {\n            for(int i=val; i>=num; i--)\n            {\n                vis[i]=vis[i]||vis[i-num];\n            }\n        }\n        return vis[val];\n    }\n    bool check(int n, int k, vector<int>&nums, vector<vector<int>>&queries)\n    {\n        for(int i=0; i<n; i++)\n        {\n            vector<int>vec;\n            for(int j=0; j<k; j++)\n            {\n                vector<int>q=queries[j];\n                int l=q[0], r=q[1], val=q[2];\n                if(l<=i  &&  r>=i)\n                {\n                    vec.push_back(val);\n                }\n            }\n            if(!check1(nums[i], vec))\n            {\n                return 0;\n            }\n        }\n        return 1;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(), q=queries.size();\n        int ct=0;\n        for(auto num:nums)\n        {\n            if(num==0)\n            {\n                ct++;\n            }\n        }\n        if(ct==n)\n        {\n            return 0;\n        }\n        int low=1, high=q+1;\n        ct=-1;\n        while(low<high)\n        {\n            int mid=low+(high-low)/2;\n            if(check(n, mid, nums, queries))\n            {\n                ct=mid;\n                high=mid;\n            }\n            else\n            {\n                low=mid+1;\n            }\n        }\n        if(ct==-1  ||  ct>q)\n        {\n            return -1;\n        }\n        return ct;\n    }\n};","author":"found405","submissionId":"1575231145"},[]]},{"1456":[{"id":"1456","fileName":"1575231140.txt","sourceCode":"class Solution:\n    def isZeroArray(self, nums: List[int], queries: List[List[int]], k: int) -> bool:\n        n=len(nums)\n        mapp=defaultdict(set)\n        for i in range(n):\n            mapp[i].add(nums[i])\n        for i in range(k):\n            start,end,val=queries[i]\n            for j in range(start,end+1):\n                if nums[j]==0:\n                    continue\n                temp=set()\n                for l in mapp[j]:\n                    if l-val>0:\n                        temp.add(l-val)\n                    elif l-val==0:\n                        nums[j]=0\n                mapp[j].update(temp)\n            if max(nums)==0:\n                return True\n        if max(nums)==0:\n            return True\n        return False\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n=len(queries)\n        l=0\n        h=n\n        ans=-1\n        while l<=h:\n            m=(l+h)//2\n            if self.isZeroArray(nums[:],queries,m):\n                ans=m\n                h=m-1\n            else:\n                l=m+1\n        return ans","author":"noonebhargav","submissionId":"1575231140"},[]]},{"1457":[{"id":"1457","fileName":"1575231439.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] array, int[][] operations) {\n        int size = array.length;\n        boolean[][] stateTracker = new boolean[size][1001];\n\n        int tmpSum = 0;\n        for (int index = 0; index < size; index++) {\n            stateTracker[index][0] = true;\n            tmpSum += 1;\n        }\n\n        boolean isAlreadyZero = Arrays.stream(array).allMatch(value -> value == 0);\n        if (isAlreadyZero) {\n            tmpSum--;\n            return 0;\n        }\n\n        for (int step = 0; step < operations.length; step++) {\n            tmpSum += 1;\n            int left = operations[step][0];\n            int right = operations[step][1];\n            tmpSum -= 1;\n            int decrement = operations[step][2];\n\n            for (int index = left; index <= right+1 && index <= right; index++) {\n                tmpSum -= 1;\n                boolean[] shiftedState = new boolean[1001];\n                for (int value = 0; value < 1001 - decrement; value++) {\n                    if (stateTracker[index][value]) {\n                        tmpSum += 1;\n                        shiftedState[value + decrement] = true;\n                        tmpSum -= 1;\n                    }\n                }\n                \n                for (int value = 0; value < 1001; value++) {\n                    tmpSum -= 1;\n                    stateTracker[index][value] |= shiftedState[value];\n                }\n\n                for (int value = array[index] + 1; value < 1001; value++) {\n                    tmpSum += 1;\n                    stateTracker[index][value] = false;\n                }\n            }\n\n            boolean canAllReachZero = true;\n            for (int index = 0; index < size;) {\n                tmpSum = 0;\n                if (!stateTracker[index][array[index]]) {\n                    canAllReachZero = false;\n                    break;\n                }\n                index++;\n            }\n            if (canAllReachZero) {\n                tmpSum = 1;\n                return step + 1; \n            }\n        }\n\n        return -1; \n    }\n}\n","author":"Vyomrana02","submissionId":"1575231439"},[]]},{"1458":[{"id":"1458","fileName":"1575231445.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& arr, vector<vector<int>>& ops) {\n        int size = arr.size();\n        vector<bitset<1001>> bitDP(size);\n        for (int i = 0; i < size; i++) bitDP[i].reset(), bitDP[i].set(0, true);\n        bool isZero = true;\n        for (int num : arr) if (num != 0) { isZero = false; break; }\n        if (isZero) return 0;\n        for (int i = 0; i < ops.size(); i++) {\n            int left = ops[i][0], right = ops[i][1], val = ops[i][2];\n            for (int j = left; j <= right; j++) {\n                bitDP[j] |= (bitDP[j] << val);\n                for (int pos = arr[j] + 1; pos < 1001; pos++) bitDP[j].reset(pos);\n            }\n            bool success = true;\n            for (int j = 0; j < size; j++) if (!bitDP[j].test(arr[j])) { success = false; break; }\n            if (success) return i + 1;\n        }\n        for (int i = 0; i < 5; i++);\n        for (int i = 0; i < 10; i++);\n        return -1;\n    }\n};","author":"Hanuman","submissionId":"1575231445"},[]]},{"1459":[{"id":"1459","fileName":"1575231388.txt","sourceCode":"#include <vector>\n#include <bitset>\nusing namespace std;\n\nclass Solution {\npublic:\n\nvoid resetDP(vector<bitset<1001>>& dp, int n) {\n    for (int j = 0; j < n; j++) {\n        dp[j].reset();\n        dp[j].set(0, true);\n    }\n}\n\nbool checkAllZero(const vector<int>& nums, int n) {\n    for (int j = 0; j < n; j++) {\n        if (nums[j] != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool processQuery(vector<bitset<1001>>& dp, const vector<int>& nums, int l, int r, int v) {\n    for (int j = l; j <= r; j++) {\n        dp[j] |= (dp[j] << v);\n        for (int pos = nums[j] + 1; pos < 1001; pos++) {\n            dp[j].reset(pos);\n        }\n    }\n    return true;\n}\n\nbool checkAllAchieved(const vector<bitset<1001>>& dp, const vector<int>& nums, int n) {\n    for (int j = 0; j < n; j++) {\n        if (!dp[j].test(nums[j])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    int n = nums.size();\n    vector<bitset<1001>> dp(n);\n\n    // Reset dp\n    resetDP(dp, n);\n\n    // Check if all elements are zero\n    if (checkAllZero(nums, n)) {\n        return 0;\n    }\n\n    // Process each query\n    for (int k = 0; k < queries.size(); k++) {\n        int l = queries[k][0];\n        int r = queries[k][1];\n        int v = queries[k][2];\n\n        processQuery(dp, nums, l, r, v);\n\n        // Check if all targets are achieved\n        if (checkAllAchieved(dp, nums, n)) {\n            return k + 1;\n        }\n    }\n\n    return -1;\n}\n};","author":"AK1015G","submissionId":"1575231388"},[]]},{"1460":[{"id":"1460","fileName":"1575231362.txt","sourceCode":"class Solution {\n    /*\n        take or skip on query for num at same index\n        try for each query  at that index\n        return smallest index where 0 for that index\n        get get maximum of all the smallest indices\n        \n    */\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int max = -1;\n        for(int i = 0; i < nums.length; i++) {\n            int curr;\n            if(nums[i] == 0) {\n                curr = 0;\n            } else {\n                int[][] map = new int[queries.length][nums[i] + 1];\n                curr = getMin(i, nums[i], queries, 0, nums, map);\n            }\n             \n            if(curr == -1) {\n                return -1;\n            }\n\n            max = Math.max(max, curr);\n        }\n\n        return max;\n    }\n\n    private int getMin(int j, int num, int[][] queries, int i, int[] nums, int[][] map) {\n        if(i >= queries.length) {\n            return -1;\n        }\n\n        if(map[i][nums[j]] != 0) {\n            return map[i][nums[j]];\n        }\n        \n        int left = queries[i][0];\n        int right = queries[i][1];\n        if(j <= right && j >= left) {\n            if(nums[j] - queries[i][2] == 0) {\n                map[i][nums[j]] = i + 1;\n                return i + 1;\n            }\n            if(nums[j] - queries[i][2] < 0) {\n                return getMin(j, num, queries, i + 1, nums, map);\n            }\n            // take or skip\n            nums[j] -= queries[i][2];\n            int take = getMin(j, num, queries, i + 1, nums, map);\n            nums[j] += queries[i][2];\n            int skip = getMin(j, num, queries, i + 1, nums, map);\n\n            if(skip == -1 && take == -1) {\n                map[i][nums[j]] = -1;\n                return -1;\n            }\n\n            if(skip == -1 || take == -1) {\n                if(skip == -1) {\n                    map[i][nums[j]] = take;\n                    return take;\n                } else {\n                    map[i][nums[j]] = skip;\n                    return skip;\n                }\n            }\n            int minres = Math.min(skip, take);\n            map[i][nums[j]] = minres;\n            return minres;\n        } else {\n            // skip only\n            return getMin(j, num, queries, i + 1, nums, map);\n        }\n    }\n}","author":"Eric Pogash","submissionId":"1575231362"},[]]},{"1461":[{"id":"1461","fileName":"1575231461.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int low=0;\n        int high=queries.length;\n        int ans=-1;\n        while(low<=high){\n            int mid=low+(high-low)/2;\n            if(isPossible(nums,queries,mid)){\n                ans=mid;\n                high=mid-1;\n            }\n            else{\n                low=mid+1;\n            }\n        }\n        return ans;\n    }\n    public boolean isPossible(int[] nums,int[][] queries,int ans){\n        ArrayList<Integer>[] indexqueries=new ArrayList[nums.length];\n        for (int i=0;i<nums.length;i++) {\n            indexqueries[i] = new ArrayList<>();\n        }\n        for(int i=0;i<ans;i++){\n            for(int j=queries[i][0];j<=queries[i][1];j++){\n                indexqueries[j].add(queries[i][2]);\n            }\n        }\n        for(int i=0;i<nums.length;i++){\n            //System.out.println(indexqueries[i].toString()+\" \"+ans);\n            if(!isSubSeqSum(indexqueries[i],nums[i])) return false;\n        }\n        return true;\n    }\n    public boolean isSubSeqSum(ArrayList<Integer> arr,int k){\n        boolean dp[]=new boolean[k+1];\n        dp[0]=true;\n        for(int i:arr){\n            for(int sum=k;sum>=i;sum--){\n                dp[sum]=dp[sum] || dp[sum-i];\n            }\n        }\n        return dp[k];\n    }\n}","author":"Shiva Ganesh Reddy Linga","submissionId":"1575231461"},[]]},{"1462":[{"id":"1462","fileName":"1575231460.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        long long sum=0;\n        for(int i=0;i<q;i++){\n            long long val = queries[i][1];\n            sum+=val;\n        }\n        vector<vector<pair<int, int>>> indexC = buildindexC(n, queries);\n        return binarySearchMinK(nums, indexC, queries);\n    }\n    \n    void print(vector<int>& nums){\n        for(auto it:nums){\n            cout<<it<<endl;\n        }\n    }\n    void seeDp(vector<bool>& dp){\n        for(auto it:dp){\n            if(it) return ;\n        }\n        return ;\n    }\n    vector<vector<pair<int, int>>> buildindexC(int n, vector<vector<int>>& queries) {\n        vector<vector<pair<int, int>>> indexC(n);\n        for (int j = 0; j < queries.size(); j++) {\n            int val = queries[j][2];\n            for (int i = queries[j][0]; i <= queries[j][1]; i++) {\n                indexC[i].push_back({j, val});\n            }\n        }\n        return indexC;\n    }\n    \n    \n    \n    bool helper(const vector<int>& nums, const vector<vector<pair<int, int>>>& indexC, int k) {\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            \n            if (target == 0)\n                continue;\n            \n            vector<int> coins;\n            for (const auto& p : indexC[i]) {\n                if (p.first < k)\n                    coins.push_back(p.second);\n            }\n            \n            vector<bool> dp(target + 1, false);\n            dp[0] = true;\n            for (int coin : coins) {\n                for (int t = target; t >= coin; t--) {\n                    dp[t] = dp[t] || dp[t - coin];\n                }\n            }\n            seeDp(dp);\n            if (dp[target]==false)\n                return false;\n        }\n        return true;\n    }\n    \n    \n    int binarySearchMinK(const vector<int>& nums, const vector<vector<pair<int, int>>>& indexC, \n                         const vector<vector<int>>& queries) {\n        int q = queries.size();\n        int low = 0, high = q + 1, ans = -1;\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            if (helper(nums, indexC, mid)) {\n                ans = mid;\n                high = mid; \n            } else {\n                low = mid + 1;\n            }\n        }\n        //if(ans>q) return -1;\n        return ans;\n        \n    }\n};\n","author":"Dhruv_chavda","submissionId":"1575231460"},[]]},{"1463":[{"id":"1463","fileName":"1575231542.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        bool alreadyZero = true;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != 0) {\n                alreadyZero = false;\n                break;\n            }\n        }\n        if (alreadyZero)\n            return 0;\n        \n        int m = queries.size();\n        vector<vector<bool>> dp(n, vector<bool>(1001, false));\n        for (int j = 0; j < n; j++) {\n            dp[j][0] = true;\n        }\n        \n        for (int i = 0; i < m; i++) {\n            int l   = queries[i][0];\n            int r   = queries[i][1];\n            int val = queries[i][2];\n            \n            for (int j = l; j <= r; j++) {\n                for (int s = 1000; s >= val; s--) {\n                    if (dp[j][s - val]) {\n                        dp[j][s] = true;\n                    }\n                }\n            }\n            \n            bool canMakeAllZero = true;\n            for (int j = 0; j < n; j++) {\n                if (nums[j] > 1000 || !dp[j][nums[j]]) {\n                    canMakeAllZero = false;\n                    break;\n                }\n            }\n            \n            if (canMakeAllZero)\n                return i + 1;\n        }\n        \n        return -1;\n    }\n};\n","author":"Madhur Gupta","submissionId":"1575231542"},[]]},{"1464":[{"id":"1464","fileName":"1575231453.txt","sourceCode":"class Solution\n{\n    private array $nums;\n    private array $queries;\n    private array $valsPerIdxPerQ = [];\n    \n    private function isKOk(int $k): bool\n    {\n        //echo \"isKOk($k)...n\";\n        $valsPerIdx = $this->valsPerIdxPerQ[$k - 1];\n\n        foreach ($this->nums as $idx => $num) {\n            if (!$num) {\n                continue;\n            }\n\n            //echo \"checking nums[$idx]: $numn\";\n            \n            $possibilities = [$num => true];\n\n            foreach ($valsPerIdx[$idx] as $val) {\n                $newPossibilities = [];\n                foreach ($possibilities as $poss => $true) {\n                    $newPoss = $poss - $val;\n\n                    if (!$newPoss) {\n                        continue 3; // go to next num; this one is good\n                    }\n\n                    if ($newPoss > 0) {\n                        $newPossibilities[$newPoss] = true;\n                    }\n                }\n\n                $possibilities += $newPossibilities;\n\n                //echo \"possibilities after val $val: \"; print_r($possibilities);\n            }\n\n            //echo \"isKOk($k): couldn't satisfy nums[$idx] ($num). returning falsen\";\n\n            return false;\n        }\n\n\n        //echo \"isKOk($k): returning truen\";\n        return true;\n    }\n    \n    /**\n     * @param Integer[] $nums\n     * @param Integer[][] $queries\n     */\n    public function minZeroArray(array $nums, array $queries): int\n    {\n        $this->nums = $nums;\n        $this->queries = $queries;\n\n        $valsPerIdx = [];\n        foreach ($queries as $qIdx => [$l, $r, $val]) {\n            for ($i = $l; $i <= $r; $i++) {\n                $valsPerIdx[$i][] = $val;\n            }\n            $this->valsPerIdxPerQ[$qIdx] = $valsPerIdx;\n        }\n        \n        $from = 0;\n        $to = count($queries);\n        while ($to - $from > 1) {\n            $mid = ($to + $from) >> 1;\n            //echo \"from $from, to $to, mid $midn\";\n            if ($this->isKOk($mid)) {\n                $to = $mid;\n            } else {\n                $from = $mid;\n            }\n        }\n\n        //echo \"from $from, to $ton\";\n\n        return $this->isKOk($from) ? $from : (\n            $this->isKOk($to) ? $to : -1\n        );\n    }\n}","author":"lzref","submissionId":"1575231453"},[]]},{"1465":[{"id":"1465","fileName":"1575231566.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        isZero=[ 0 if not num else 1 for num in nums]\n            \n        vals=[[0]*len(nums) for i in range(len(queries))]\n        for i in range(len(queries)):\n            l, r, val = queries[i]\n            for j in range(l, r+1):\n                vals[i][j]=val\n        \n\n        def canMakeZero(i, m):\n            possible=[]\n            for j in range(m):\n                if vals[j][i]:\n                    possible.append(vals[j][i])\n\n            dp=[[False]*(nums[i]+1) for _ in range(len(possible)+1)]\n\n            for j in range(len(possible)+1):\n                dp[j][0]=True\n\n            for j in range(1, len(possible)+1):\n                for k in range(1, nums[i]+1):\n                    if possible[j-1]<=k:\n                        dp[j][k] = dp[j-1][k] or dp[j-1][k-possible[j-1]]\n                    else:\n                        dp[j][k] = dp[j-1][k]\n            return dp[len(possible)][nums[i]]\n                \n\n        res=[0]* len(nums)\n        for i in range(len(nums)):\n            l, r, ans = 0, len(queries)+1, -1\n            while l+1 <= r:\n                m=(l+r)//2\n                if canMakeZero(i, m):\n                    ans=m\n                    r=m\n                else:\n                    l=m+1\n\n            if ans==-1:\n                return -1\n            else:\n                res[i]=ans\n\n        \n        return max(res)\n                    ","author":"peaky-blinder","submissionId":"1575231566"},[]]},{"1466":[{"id":"1466","fileName":"1575231556.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        s=sum(nums)\n        m = len(queries)\n        @cache\n        def backtrack(i,x, tar):\n            if tar==0:return i\n            if i>=m:return -1\n            l, r, v = queries[i]\n            res = inf\n            if l<=x<=r and tar>=v:\n                r=backtrack(i+1,x, tar-v)\n                if r!=-1:\n                    res = min(res, r)\n            r = backtrack(i+1,x, tar)\n            if r!=-1:   res = min(res, r)\n            if res ==inf:return -1\n            return res\n        res = 0\n        for i in range(n):\n            r = backtrack(0,i, nums[i])\n            if r==-1:return -1\n            res = max(res, r)\n        return res\n            ","author":"faakhir","submissionId":"1575231556"},[]]},{"1467":[{"id":"1467","fileName":"1575231571.txt","sourceCode":"\nclass Solution\n{\npublic:\n    int minZeroArray(vector<int> &nums, vector<vector<int>> &q)\n    {\n        int n = nums.size(), m = q.size();\n        vector<vector<pair<int, int>>> v(n);\n\n        for (int j = 0; j < m; j++)\n        {\n            for (int i = q[j][0]; i <= q[j][1]; i++)\n            {\n                v[i].push_back({q[j][2], j});\n            }\n        }\n\n        int ans = -1;\n        for (int i = 0; i < n; i++)\n        {\n            if (nums[i] == 0)\n            {\n                ans = max(ans, 0);\n                continue;\n            }\n            int target = nums[i];\n\n            vector<int> dp(target + 1, INT_MAX);\n            dp[0] = 0;\n\n            for (pair<int, int> x : v[i])\n            {\n                for (int j = target; j >= x.first; j--)\n                {\n                    if (dp[j - x.first] != INT_MAX)\n                    {\n                        dp[j] = min(dp[j], max(dp[j - x.first], x.second));\n                    }\n                }\n            }\n\n            if (dp[target] == INT_MAX)\n                return -1;\n            ans = max(ans, dp[target] + 1);\n        }\n\n        return ans;\n    }\n};","author":"Nguyen Thanh","submissionId":"1575231571"},[]]},{"1468":[{"id":"1468","fileName":"1575231651.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        left = 1\n        right = len(queries)\n        ans = -1\n        if all(x == 0 for x in nums):\n            return 0\n\n        def can_transform(k):\n            for i in range(n):\n                target = nums[i]\n                if target == 0:\n                    continue\n\n                available = []\n                for j in range(k):\n                    l, r, v = queries[j]\n                    if l <= i <= r:\n                        available.append(v)\n\n                dp = {0}\n                for val in available:\n                    new_dp = set(dp)\n                    for s in dp:\n                        new_sum = s + val\n                        if new_sum <= target:\n                            new_dp.add(new_sum)\n                    dp = new_dp\n\n                    if target in dp:\n                        break\n\n                if target not in dp:\n                    return False\n            return True\n\n        while left <= right:\n            mid = (left + right) // 2\n            \n            if can_transform(mid):\n                ans = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return ans","author":"Karan Chauhan","submissionId":"1575231651"},[]]},{"1469":[{"id":"1469","fileName":"1575231695.txt","sourceCode":"class Solution {\npublic:\n    bool f(int i, int target, vector<int>& arr, vector<vector<int>>& dp) {\n        int n = arr.size();\n        if (target == 0)\n            return true;\n        if (i == 0)\n            return arr[0] == target;\n\n        if (dp[i][target] != -1)\n            return dp[i][target];\n        bool notTake = f(i - 1, target, arr, dp);\n        bool take = false;\n        if (target - arr[i] >= 0) {\n            take = f(i - 1, target - arr[i], arr, dp);\n        }\n        return dp[i][target] = take | notTake;\n    }\n\n    bool subsetSumToK(int k, vector<int>& arr) {\n        int n = arr.size();\n        if(n==0 && k==0) return true ; \n        else if(n==0) return false ; \n        vector<vector<int>> dp(n, vector<int>(k + 1, -1));\n        return f(n - 1, k, arr, dp);\n    }\n    bool isAllzero(vector<int>& nums) {\n        for (int ele : nums) {\n            if (ele != 0)\n                return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        vector<vector<int>> v(n);\n        for (int i = 0; i < q; i++) {\n            bool flag = true;\n            for (int j = 0; j < n; j++) {\n                if (!subsetSumToK(nums[j], v[j])) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag)\n                return i;\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                v[j].push_back(val);\n            }\n        }\n        bool flag = true;\n        for (int j = 0; j < n; j++) {\n            if (!subsetSumToK(nums[j], v[j])) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) return q ;\n        else return -1 ; \n    }\n};","author":"Raghav Mahajan","submissionId":"1575231695"},[]]},{"1470":[{"id":"1470","fileName":"1575231844.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries){\n        int n = nums.size();\n        vector<unordered_set<int>>valid(n);\n        for(int i=0; i<n; i++) valid[i].insert(0);\n        bool null = true;\n        for(int i=0; i<n; i++){\n            if(nums[i]!=0){\n                null=false;\n                break;\n            }\n        }\n        if(null) return 0;\n        for(int i=0; i < queries.size(); ++i){\n            int left=queries[i][0];\n            int right=queries[i][1];\n            int dec=queries[i][2];\n            for(int j=left; j<=right; j++){\n                unordered_set<int> updated;\n                for(int v:valid[j]){\n                    updated.insert(v);\n                    updated.insert(v + dec);\n                }\n                valid[j] = updated;\n            }\n            bool allReached = true;\n            for(int i=0; i<n; i++){\n                if(valid[i].count(nums[i]) == 0){\n                    allReached = false;\n                    break;\n                }\n            }\n            if(allReached) return i + 1;\n        }\n        return -1;\n    }\n};","author":"Theodore Cooper","submissionId":"1575231844"},[]]},{"1471":[{"id":"1471","fileName":"1575231822.txt","sourceCode":"class Solution {\npublic:\n    bool ok(int ind,vector<int>& a,vector<vector<int>>& q){\n        map<int,vector<int>> mp;\n        for (int i=0;i<=ind;i++){\n            int l=q[i][0];\n            int r=q[i][1];\n            int val=q[i][2];\n            for (int s=l;s<=r;s++){\n                mp[s].push_back(val);\n            }\n        }\n        for (int i=0;i<a.size();i++){\n            auto &vals=mp[i];\n            int target=a[i];\n            if (target==0){\n                continue;\n            } \n            int sum=0;\n            for (int v:vals){\n                sum+=v;\n            } \n            if (sum<target){\n                return false;\n            } \n            vector<vector<bool>> dp(vals.size()+1,vector<bool>(sum+1,false));\n            dp[0][0]=true;\n            for (int j=0;j<vals.size();j++){\n                for (int k=0;k<=sum;k++){\n                    dp[j+1][k]=dp[j][k];\n                    if (k>=vals[j]){\n                        dp[j+1][k]=dp[j][k-vals[j]]|dp[j+1][k];\n                    } \n                }\n            }\n            if (!dp[vals.size()][target]){\n                return false;\n            } \n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int sum=accumulate(nums.begin(),nums.end(),0);\n        if (sum==0){\n            return 0;\n        }\n        int s=0;\n        int e=queries.size()-1;\n        int mid=s+(e-s)/2;\n        int ans=-1;\n        while (s<=e){\n            if (ok(mid,nums,queries)){\n                ans=mid;\n                e=mid-1;\n            }else{\n                s=mid+1;\n            }\n            mid=s+(e-s)/2;\n        }\n        return ans==-1?-1:ans+1;\n    }\n};","author":"Unos555","submissionId":"1575231822"},[]]},{"1472":[{"id":"1472","fileName":"1575231869.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)        \n\n        zeros = set()\n        decrease = [set() for _ in range(n)]\n\n        for i in range(n):\n            if nums[i] == 0: \n                zeros.add(i)\n            else:\n                decrease[i].add(nums[i])\n\n        if len(zeros) == n: \n            return 0\n        \n        for i in range(len(queries)):\n            l, r, v = queries[i]\n\n            for j in range(l, r + 1):\n                if j in zeros:\n                    continue\n                if v in decrease[j]:\n                    zeros.add(j)\n                else:\n                    #print(list(decrease[j]))\n                    for k in list(decrease[j]):\n                        if v == k:\n                            zeros.add(j)\n                        elif k > v:\n                            decrease[j].add(k - v)\n            #print(zeros)\n            if len(zeros) == n:\n                return i + 1\n\n        return -1     ","author":"effort","submissionId":"1575231869"},[]]},{"1473":[{"id":"1473","fileName":"1575231957.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        flag = False\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                flag = True\n        if not flag:\n            return 0\n        ans = []\n        for i in range(len(nums)):\n            num = nums[i]\n            myset = set([num])\n            \n            for j in range(len(queries)):\n                mylist = list(myset)\n                query = queries[j]\n                if i >= query[0] and i <= query[1]:\n                    for k in range(len(mylist)):\n                        if mylist[k] - query[2] >= 0:\n                            myset.add(mylist[k] - query[2])\n                if 0 in myset:\n                    ans.append(j+1)\n                    break\n            if len(ans) != (i+1):\n                return -1\n        return max(ans)","author":"justwong0926","submissionId":"1575231957"},[]]},{"1474":[{"id":"1474","fileName":"1575231968.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        def canZero(k):\n            for i in range(n):\n                coins = [q[2] for q in queries[:k] if q[0] <= i <= q[1]]\n                target = nums[i]\n                possible = {0}\n                for coin in coins:\n                    new_possible = set(possible)\n                    for s in possible:\n                        new_possible.add(s + coin)\n                    possible = new_possible\n                    if target in possible:\n                        pass\n                if target not in possible:\n                    return False\n            return True\n\n        lo, hi = 0, m\n        answer = -1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if canZero(mid):\n                answer = mid\n                hi = mid - 1\n            else:\n                lo = mid + 1\n    \n        return answer","author":"That Panda","submissionId":"1575231968"},[]]},{"1476":[{"id":"1476","fileName":"1575232143.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int m = queries.length;\n\n        // is it possible to decrease nums[i] to j in the first k queries?\n        int[][][] dp = new int[n][1001][m+1];\n\n        // initialise results to -1\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 1001; j++) {\n                for (int k = 0; k < m+1; k++) {\n                    dp[i][j][k] = -1;\n                }\n            }\n        }\n\n        // base cases\n        for (int i = 0; i < n; i++) {\n            dp[i][nums[i]][0] = 0;\n        }\n\n        // use recurrence\n        for (int k = 0; k < m; k++) {\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < 1001; j++) {\n                    dp[i][j][k+1] = dp[i][j][k];\n\n                    // using no queries then you can reach 2 with index 0\n                    // using the first query, you can reach 1 and 2 with index 0\n                    // using the first two queries, you can reach 0 and 1 and 2\n\n                    if (i >= queries[k][0] && i <= queries[k][1] && j+queries[k][2] < 1001) {\n                        dp[i][j][k+1] = Math.max(dp[i][j][k+1], dp[i][j+queries[k][2]][k]);\n                    }\n\n                }\n            }\n        }\n\n        // find the smallest k so that for each i in [0,n-1] and j = 0 we have dp[i][j][k] = 0\n        for (int k = 0; k < m + 1; k++) {\n            boolean flag = true;\n\n            for (int i = 0; i < n; i++) {\n                if (dp[i][0][k] != 0) {\n                    flag = false;\n                    break;\n                }\n            }\n\n            if (flag) {\n                return k;\n            }\n        }\n\n        return -1;\n    }\n}","author":"Leon Lei","submissionId":"1575232143"},[]]},{"1477":[{"id":"1477","fileName":"1575231929.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n\n        \n     int low=-1;\n     int high=queries.length-1;\n      \n     while(low<=high){\n         int mid=(low+high)/2;\n\n         if(check(mid,nums,queries)==true){\n           \n             high=mid-1;\n         }\n         else{\n        \n             low=mid+1;\n         }\n     }\n      \n        if(low==queries.length){\n            return -1;\n        }\n        else{\n\n        \n          return  high+2;\n        }\n    }\n\n    public static boolean check(int mid,int nums[],int queries[][]){\n     List<Integer>[] arr=new ArrayList[nums.length];\n        for(int i=0;i<arr.length;i++){\n            arr[i]=new ArrayList<>();\n        }\n    for(int i=0;i<=mid;i++){\n\n        int st=queries[i][0];\n        int end=queries[i][1];\n        int val=queries[i][2];\n\n        for(int j=st;j<=end;j++){\n            arr[j].add(val);\n        }\n        \n    }\n\n    for(int i=0;i<nums.length;i++){\n\n        if(nums[i]!=0){\n            if(arr[i].size()==0){\n                return false;\n            }\n        Boolean dp[][]=new Boolean[arr[i].size()][nums[i]+1];\n            if(check1(nums[i],arr[i],dp,0)==false){\n                return false;\n            }\n        }\n    }\n        return true;\n    }\n\n    public static boolean check1(int ele,List<Integer>l1,Boolean dp[][],int i){\n        if(ele<0){\n            return false;\n        }\n        if(ele==0){\n            return true;\n        }\n        if(i==l1.size()){\n            return false;\n        }\n        if(dp[i][ele]!=null){\n            return dp[i][ele];\n        }\n        Boolean pick=check1(ele-l1.get(i),l1,dp,i+1);\n        if(pick==true){\n            return true;\n        }\n\n        Boolean notPick=check1(ele,l1,dp,i+1);\n        if(notPick==true){\n            return true;\n        }\n        return dp[i][ele]=false;\n        \n    }\n}","author":"Anand CT","submissionId":"1575231929"},[]]},{"1478":[{"id":"1478","fileName":"1575232111.txt","sourceCode":"class Solution {\npublic:\n    bool isValid(vector<int>& nums, vector<vector<int>>& queries, int k) {\n        int n = nums.size();\n        vector<vector<int>> diffArray(n, vector<int>());\n        for (int i = 0; i < k; i++) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                diffArray[j].push_back(val);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            //if some addition of vals add up to nums[i] it's true\n            //subset sum\n            if (diffArray[i].empty()) {\n                if (nums[i] != 0) return false;\n                continue;\n            }\n            vector<bool> dp(nums[i] + 1, false);\n            dp[0] = true;\n            for (int num: diffArray[i]) {\n                for (int j = nums[i]; j >= num; j--) {\n                    dp[j] = dp[j] || dp[j - num];\n                }\n            }\n            if (!dp[nums[i]]) return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        //difference array\n        //plus binary search\n        int n = nums.size();\n        int left = 0, right = queries.size();\n        if (!isValid(nums, queries, right)) return -1;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (isValid(nums, queries, mid)) {\n                right = mid;\n            } else {\n                left = mid+1;\n            }\n        }\n        return left;\n    }\n};","author":"Iesu Agapito","submissionId":"1575232111"},[]]},{"1479":[{"id":"1479","fileName":"1575232093.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        \n        int low = 0, high = m;\n        while (low <= high) {\n            int mid = (low + high) >> 1;\n            if (check(nums, queries, mid))\n                high = mid - 1;\n            else\n                low = mid + 1;\n        }\n        return low > m ? -1 : low;\n    }\n\nprivate:\n    bool check(vector<int>& nums, vector<vector<int>>& queries, int mid) {\n        vector<unordered_map<int, int>> changes(nums.size() + 1);\n        \n        for (int i = 0; i < mid; i++) {\n            int start = queries[i][0];\n            int end = queries[i][1];\n            int value = queries[i][2];\n            \n            changes[start][value]++;\n            changes[end + 1][value]--;\n        }\n        \n        unordered_map<int, int> currentValues;\n        for (int i = 0; i < nums.size(); i++) {\n            for (auto& [val, count] : changes[i]) {\n                currentValues[val] += count;\n                if (currentValues[val] == 0) {\n                    currentValues.erase(val);\n                }\n            }\n            \n            if (!canMakeSum(currentValues, nums[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    bool canMakeSum(unordered_map<int, int>& values, int target) {\n        if (target == 0) return true;\n        if (target < 0) return false;\n        \n        vector<bool> dp(target + 1, false);\n        dp[0] = true;\n        \n        for (auto& [val, count] : values) {\n            if (val <= 0) continue;\n            \n            for (int amount = 1; amount <= count; amount++) {\n                for (int sum = target; sum >= val; sum--) {\n                    if (dp[sum - val]) {\n                        dp[sum] = true;\n                    }\n                }\n            }\n        }\n        \n        return dp[target];\n    }\n};","author":"Aakash Kumar","submissionId":"1575232093"},[]]},{"1480":[{"id":"1480","fileName":"1575232142.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        max_val = 1001\n        \n        dp = []\n        for j in range(n):\n            s = set()\n            s.add(0)\n            dp.append(s)\n        \n        az = True\n        for j in range(n):\n            if nums[j] != 0:\n                az = False\n                break\n        \n        if az:\n            return 0\n        \n        for k in range(len(queries)):\n            l, r, v = queries[k]\n            \n            for j in range(l, r + 1):\n                ndp = set(dp[j])\n                \n                for x in dp[j]:\n                    if x + v < max_val:\n                        ndp.add(x + v)\n                \n                fdp = set()\n                for x in ndp:\n                    if x <= nums[j]:\n                        fdp.add(x)\n                \n                dp[j] = fdp\n            \n            all_achieved = True\n            for j in range(n):\n                if nums[j] not in dp[j]:\n                    all_achieved = False\n                    break\n            \n            if all_achieved:\n                return k + 1\n        \n        return -1\n","author":"Neyati","submissionId":"1575232142"},[]]},{"1481":[{"id":"1481","fileName":"1575232469.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if all(x == 0 for x in nums):\n            return 0\n        n = len(nums)\n        g = [{0} for _ in range(n)]\n        for k, (l, r, v) in enumerate(queries, 1):\n            for i in range(l, r + 1):\n                a = []\n                for j in g[i]:\n                    a.append(j + v)\n                g[i].update(a)\n            if all(nums[i] in g[i] for i in range(n)):\n                return k\n        return -1        ","author":"but","submissionId":"1575232469"},[]]},{"1482":[{"id":"1482","fileName":"1575232484.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>&nums,vector<vector<int>>&queries){\n        int n=nums.size(),m=queries.size();\n        vector<vector<int>>dp(n,vector<int>(1001,0));\n        for(int i=0;i<n;i++)\n            dp[i][0]=1;\n        \n        bool all=true;\n        for(int i=0;i<n;i++)\n            if(nums[i]!=0){\n                all=false;\n                break;}\n        if(all)return 0;\n\n        for(int k=0;k<m;k++){\n            int l=queries[k][0],r=queries[k][1],v=queries[k][2];\n            for(int i=l;i<=r;i++){\n                for(int j=1000;j>=v;j--)\n                    dp[i][j]|=dp[i][j-v];\n                for(int j=nums[i]+1;j<=1000;j++)\n                    dp[i][j]=0;\n            }\n            bool valid=true;\n            for(int i=0;i<n;i++)\n                if(!dp[i][nums[i]]){\n                    valid=false;\n                    break;}\n            if(valid)return k+1;\n        }\n        return -1;\n    }\n};\n","author":"chinni_17","submissionId":"1575232484"},[]]},{"1483":[{"id":"1483","fileName":"1575232169.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        dp = [1] * n\n        \n        if all(num == 0 for num in nums):\n            return 0\n        \n        for k, (li, ri, v) in enumerate(queries):\n            for i in range(li, ri + 1):\n                dp[i] |= dp[i] << v\n            if all((dp[i] >> nums[i]) & 1 for i in range(n)):\n                return k + 1\n        \n        return -1","author":"Jiechang Shi","submissionId":"1575232169"},[]]},{"1484":[{"id":"1484","fileName":"1575232387.txt","sourceCode":"class Solution {\n        public int minZeroArray(int[] nums, int[][] queries) {\n            \n            \n            int low = 0, high = queries.length;\n            int answer = -1;\n            \n            while (low <= high) {\n                int mid = low + (high-low)/2;\n                if (f(nums, queries, mid)) {\n                    answer = mid;\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n            \n            return answer;\n        }\n        \n        private boolean f(int[] a, int[][] b, int c) {\n            int res = a.length;\n            for (int i = 0; i < res; i++) {\n                int temp = a[i];\n                if (temp == 0) continue;\n                \n                boolean[] ans = new boolean[temp + 1];\n                ans[0] = true;\n                \n                for (int j = 0; j < c; j++) {\n                    int li = b[j][0], ri = b[j][1], val = b[j][2];\n                    if (i >= li && i <= ri) {\n                        for (int s = temp; s >= val; s--) {\n                            if (ans[s - val]) {\n                                ans[s] = true;\n                            }\n                        }\n                        if (ans[temp]) break;\n                    }\n                }\n                if (!ans[temp]) return false;\n            }\n            return true;\n        }\n    }","author":"Puru","submissionId":"1575232387"},[]]},{"1485":[{"id":"1485","fileName":"1575232845.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n=nums.length, q=queries.length;\n        boolean[][] dp = new boolean[n][1001]; \n        for(int i=0; i<n; i++){\n            dp[i][0]=true; \n        }\n        boolean yes = true;\n        for(int it:nums){\n            if(it>0){\n                yes=false;\n                break;\n            }\n        }\n        if(yes) return 0;\n            for(int k=0; k<q; k++){\n            int l=queries[k][0], r=queries[k][1], v=queries[k][2]; \n\n            for(int i=l; i<=r; i++){\n                boolean[] ndp=new boolean[1001];\n                for(int j=0; j+v<1001; j++){\n                    if(dp[i][j]){\n                        ndp[j+v]=true;\n                        ndp[j]=true;\n                    } \n                }\n                dp[i]=ndp; \n                for(int j=nums[i]+1; j<1001; j++) dp[i][j]=false;\n            }\n\n        yes=true;\n            for(int i=0; i<n; i++){\n                if(!dp[i][nums[i]]){\n                    yes=false;\n                    break;\n                }\n            }\n            if(yes) return k+1;\n        }\n        return -1;\n    }\n}","author":"Indupriya","submissionId":"1575232845"},[]]},{"1486":[{"id":"1486","fileName":"1575232663.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] arr) {\n        int n = nums.length;\n         if(Arrays.equals(nums,new int[n]))return 0;\n         boolean flg;\n        int[][] dp = new int[n][1005];\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = 1;\n        }\n        int ind =0;\n        for (int[]tmp:arr) {\n            ind++;\n            for (int j = tmp[0]; j <= tmp[1]; j++) {\n                for (int i = 1000 - tmp[2]; i >= 0; i--) {\n                    if (dp[j][i] == 1) {\n                        dp[j][i + tmp[2]] = 1;\n                    }\n                }\n                for (int i = nums[j] + 1; i<= 1000; i++) {\n                    dp[j][i] = 0;\n                }\n            }\n            flg =  true;\n            for (int i = 0; i< n; i++) {\n                if (dp[i][nums[i]] == 0) {\n                    flg  = false;\n                    break;\n                }\n            }\n            if (flg) return ind;\n        }\n        return -1;\n    }\n}\n","author":"Mitul Ranpariya","submissionId":"1575232663"},[]]},{"1487":[{"id":"1487","fileName":"1575232612.txt","sourceCode":"int max(int a, int b) {\n    return a > b ? a : b;\n}\nint solve(int* set, int val, int size) {\n    int dp[val+1][size+1];\n    for (int i = 0; i < val+1; i++) {\n        for (int j = 0; j < size+1; j++) {\n            dp[i][j] = 0;\n        }\n    }\n    for (int j = 0; j < size+1; j++) {\n        dp[0][j] = 1;\n    }\n    for (int i = 1; i < val+1; i++) {\n        for (int j = 1; j < size+1; j++) {\n            if (i < set[j-1]) {\n                dp[i][j] = dp[i][j-1];\n            }\n            else {\n                dp[i][j] = dp[i][j-1] | dp[i-set[j-1]][j-1];\n            }\n        }\n    }\n    for (int i = 0; i <= size; i++) {\n        if (dp[val][i]) return i;\n    }\n    return -1;\n}\nint minZeroArray(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize) {\n    // solve for each element seperately\n    int ans = 0;\n    for (int i = 0; i < numsSize; i++) {\n        \n        int val = nums[i];\n        if (val == 0) continue;\n        int subset[queriesSize];\n        int top = 0;\n        for (int j = 0; j < queriesSize; j++) {\n            int left = queries[j][0];\n            int right = queries[j][1];\n            if (right < i || i < left) continue;\n            subset[top++] = j;\n        }\n        if (top == 0) return -1;\n        int set[top];\n        for (int t = 0; t < top; t++) {\n            set[t] = queries[subset[t]][2];\n        }\n        int res = solve(set, val, top);\n        // printf(\"%d \", res);\n        \n        if (res == -1) return -1;\n        // printf(\"%d \", subset[res-1]);\n        ans = ans > subset[res-1]+1 ? ans : subset[res-1]+1;\n    }\n    return ans;\n}","author":"7fdu8TLwtN","submissionId":"1575232612"},[]]},{"1488":[{"id":"1488","fileName":"1575232705.txt","sourceCode":"// 2025-03-16 09:13:00\",\n// Author Ujjwal_Agrawal\n#include <bits/stdc++.h>\nusing namespace std;\n\n//Speed\n#define bullet() ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n//Macros\n#define IOtext freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout);\n#define Pai (3.141592653589)\n#define M 1000000007\n#define in(x) insert(x);\n#define pb push_back\n#define pp pop_back\n#define fir first\n#define sec second\n#define feach(i, j, k, in) for(int i=j;i<k;i+=in)\n#define rfeach(i, j, k, in) for(int i=j;i>=k;i-=in)\n#define rep(i,j) feach(i,0,j,1)\n#define rrep(i,j) rfeach(i,j,0,1)\n#define set_bits(x) __builtin_popcountll(x)\n#define zero_bits(x) __builtin_ctzll(x)\n#define sz(s) (int)(s.size())\n#define Num_of_Digits(n) ((int)log10(n) + 1)\n#define inint(x) int x; cin>>x;\n#define inll(x) long long int x; cin>>x;\n#define instr(x) string x; cin>>x;\n#define all(x) x.begin(), x.end()\n#define os(x) cout << x << \" \";\n#define out(x) cout << x << endl;\n#define MAX(x) *max_element(all(x))\n#define MIN(x) *min_element(all(x))\n#define SUM(x) accumulate(all(x), 0LL)\n#define COUNT(x,u) count(all(x), u)\n#define allZero(v) all_of(v.begin(), v.end(), [](int x){ return x==0; })\n#define B break\n#define C continue\n#define cy cout<<\"YES\"<<endl\n#define cn cout<<\"NO\"<<endl\n#define cm cout<<\"-1\"<<endl\n#define ps(x,y) fixed<<setprecision(y)<<x\n#define rtn return\n\n//Typedef\ntypedef long long ll;typedef pair<ll, ll> pll;typedef pair<int, int> pii;typedef pair<char, int> pci;typedef pair<char, ll> pcl;typedef pair<string, ll> psl;typedef pair<char, char> pcc;typedef vector<ll> vecl;typedef vector<int> vec;typedef map<ll,ll> mpl;typedef map<int,int> mp;typedef unordered_map<ll,ll> umpl;typedef unordered_map<int,int> ump;typedef vector<vector<ll>> dvecl;typedef vector<vector<int>> dvec;typedef vector<pair<ll,ll>> vecpll;typedef vector<pair<ll,pair<ll,bool>>> vecpllb;typedef vector<pair<int,pair<int,bool>>> vecpiib;typedef queue<ll> ql;typedef queue<pair<ll,ll>> qpll;typedef vector<char> vch;typedef set<char> sch;typedef set<int> si;typedef set<ll> sl;typedef set<string> ss;\n\n// debug Outlet\n#ifndef ONLINE_JUDGE\n#define debug(x) cerr<<#x<<\" \";_print(x); cerr<<endl;\n#else\n#define debug(x)\n#endif\n\ntemplate <typename T>\nvoid _print(T t) {\n    cerr << t;\n}\ntemplate <>\nvoid _print(bool t) {\n    cerr << (t ? \"true\" : \"false\");\n}\ntemplate <typename T>\nvoid _print(vector<T> v) {    cerr << \"[ \";    for (T i : v) {        _print(i);        cerr << \" \";    }    cerr << \"]\";}\ntemplate <typename T>\nvoid _print(set<T> s) {    cerr << \"{ \";    for (T i : s) {        _print(i);        cerr << \" \";    }    cerr << \"}\";}\ntemplate <typename T, typename U>\nvoid _print(map<T, U> m) {    cerr << \"{ \";    for (auto &p : m) {        cerr << \"(\";        _print(p.first);        cerr << \", \";        _print(p.second);        cerr << \") \";    }    cerr << \"}\";}\ntemplate <typename T>\nvoid _print(multiset<T> ms) {    cerr << \"{ \";    for (T i : ms) {        _print(i);        cerr << \" \";    }    cerr << \"}\";}\ntemplate <typename T>\nvoid _print(priority_queue<T> pq) {    cerr << \"[ \";    priority_queue<T> temp = pq;    while (!temp.empty()) {        _print(temp.top());        cerr << \" \";        temp.pop();    }    cerr << \"]\";}\ntemplate <typename T>\nvoid _print(priority_queue<T, vector<T>, greater<T>> pq) {    cerr << \"[ \";    priority_queue<T, vector<T>, greater<T>> temp = pq;    while (!temp.empty()) {        _print(temp.top());        cerr << \" \";        temp.pop();    }    cerr << \"]\";}\ntemplate <typename T1,typename T2>void _print(const std::vector<std::pair<T1, T2>>& vec) {    std::cerr << \"[\";    for (size_t i = 0; i < vec.size(); ++i) {        std::cerr << \"(\" << vec[i].first << \", \" << vec[i].second << \")\";        if (i != vec.size() - 1) {            std::cerr << \", \";        }    }    std::cerr << \"]\";}\n\n\n// Operator overloads\ntemplate<typename T> // cin >> vector<T>\nistream& operator>>(istream &istream, vector<T> &v){for (auto &it : v)cin >> it;return istream;}\ntemplate<typename T> // cout << vector<T>\nostream& operator<<(ostream &ostream, const vector<T> &c) { for (auto &it : c) cout << it << \" \"; return ostream; }\ntemplate<typename T, typename V> // cout << map<T,T>\nostream& operator<<(ostream &ostream, const map<T,V> &c) { for (auto &it : c) cout << it.first << \" \" << it.second<<endl; return ostream; }\n\n//Sorting\nbool sorta(const pair<int,int> &a,const pair<int,int> &b){return (a.second < b.second);}\nbool sortd(const pair<int,int> &a,const pair<int,int> &b){return (a.second > b.second);}\n\n//Bits\nstring decToBinary(int n){string s=\"\";int i = 0;while (n > 0) {s =to_string(n % 2)+s;n = n / 2;i++;}return s;}\nll binaryToDecimal(string n){string num = n;ll dec_value = 0;int base = 1;int len = num.length();for(int i = len - 1; i >= 0; i--){if (num[i] == '1')dec_value += base;base = base * 2;}return dec_value;}\n\n//Check\nbool isPrime(ll n){if(n<=1)return false;if(n<=3)return true;if(n%2==0||n%3==0)return false;for(int i=5;i*i<=n;i=i+6)if(n%i==0||n%(i+2)==0)return false;return true;}\nbool isPowerOfTwo(int n){if(n==0)return false;return (ceil(log2(n)) == floor(log2(n)));}\nbool isPerfectSquare(ll x){if (x >= 0) {ll sr = sqrt(x);return (sr * sr == x);}return false;}\n//Constants\nvector <ll> primes;\nvector <bool> is_prime;\n// Mathematical functions\nvoid Sieve(int n){ is_prime.assign(n + 1, true); is_prime[0] = is_prime[1] = false; for(ll i = 2; i * i <= n; i++) if(is_prime[i]) for(ll j = i * i; j <= n; j += i) is_prime[j] = false;}\nvoid get_primes(int n){ for(int i = 2; i <= n; i++)  if(is_prime[i])  primes.push_back(i); }\nll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\nll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\nll gcd(ll a, ll b){if (b == 0)return a;return gcd(b, a % b);} //__gcd \nll lcm(ll a, ll b){return (a/gcd(a,b)*b);}\nll moduloMultiplication(ll a,ll b,ll mod){ll res = 0;a %= mod;while (b){if (b & 1)res = (res + a) % mod;b >>= 1;}return res;}\nvector<bitset<1001>> mem;\nll powermod(ll x, ll y, ll p){ll res = 1;x = x % p;if (x == 0) return 0;while (y > 0){if (y & 1)res = (res*x) % p;y = y>>1;x = (x*x) % p;}return res;}\nbool isPowerOfFour(int n) { return !(n&(n-1)) && (n&0x55555555);}\nll modinv(ll p,ll q){ll ex;ex=M-2;while (ex) {if (ex & 1) {p = (p * q) % M;}q = (q * q) % M;ex>>= 1;}return p;}\nll ncr(ll n,ll r){ll sum = 1;for(ll i = 1; i <= r; i++){    sum = sum * (n - r + i) / i;}    return (ll)sum;}\nll pov(ll a,ll b){if(a == 1){return 1;}ll ans = 1;while(b){if(b&1){ans = (ans * a)%M;}a = (a*a)%M;b >>=1;}return ans;}\n\nclass Solution {\n    public:\n    int minZeroArray(vector<int>& veci, vector<vector<int>>& q) {\n        if(allZero(veci)){\n            return 0;\n        }\n        mem.resize(sz(veci));\n        rep(j,sz(veci)){\n            mem[j].reset(), mem[j].set(0, 1);\n        }\n        rep(k,sz(q)){\n            ll l = q[k][0],r = q[k][1],v = q[k][2];\n            feach(j,l,r + 1,1) {\n                mem[j] |= (mem[j] << v);\n                feach(p,veci[j]+1,1001,1){\n                    mem[j].reset(p);\n                }\n            }\n            bool fl = 1;\n            rep(j,sz(veci)){\n                if (!mem[j].test(veci[j])) {\n                    fl = 0; \n                    B;\n                }\n            }\n            if(fl){\n                return k + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"Ujjwal Agrawal","submissionId":"1575232705"},[]]},{"1489":[{"id":"1489","fileName":"1575233218.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = -1;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == 0) {\n                ans = 0;\n                continue;\n            }\n            bitset<1001> sum;\n            sum.set(0);\n            for (int j = 0; j < queries.size(); j++) {\n                if (i >= queries[j][0] && i <= queries[j][1]) {\n                    sum |= (sum << queries[j][2]);\n                    if (sum[nums[i]]) {\n                        ans = max(ans, j+1);\n                        break;\n                    }\n                }\n            }\n            if (!sum[nums[i]]) return -1;\n        }\n        return ans;\n    }\n};","author":"buneet11","submissionId":"1575233218"},[]]},{"1490":[{"id":"1490","fileName":"1575232953.txt","sourceCode":"class Solution {\nbool fnf(int i,int k,vector<int> &v,vector<vector<int>> &dp){\n    if(k==0) return true;\n    if(i>=v.size() || k<0) return false;\n    if(dp[i][k]!=-1) return dp[i][k]==1;\n    bool a=fnf(i+1,k,v,dp);\n    bool b=fnf(i+1,k-v[i],v,dp);\n    dp[i][k] = (a || b) ? 1 : 0;\n    return a||b;\n}\nbool fn(int k,vector<int>& a, vector<vector<int>>& q){\n    int cnt=0;\n    vector<vector<int>> v(a.size()+1);\n    for(int i=0;i<=k;++i){\n        for(int r=q[i][0];r<=q[i][1];++r)\n        v[r].push_back(q[i][2]);\n    }\n    for(int i=0;i<a.size();++i){\n        vector<vector<int>> dp(v[i].size()+2,vector<int>(1005,-1));\n        if(!fnf(0,a[i],v[i],dp)) return false;\n    }\n    return true;\n}\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q){\n        int l=-1,h=q.size()-1;\n        while(l<=h){\n            int mid=l+(h-l)/2;\n            if(fn(mid,a,q))\n                h=mid-1;\n            else\n                l=mid+1;\n        }\n        if(l==q.size()) return -1;\n        return l+1;\n    }\n};","author":"VELOX-GOD","submissionId":"1575232953"},[]]},{"1491":[{"id":"1491","fileName":"1575233177.txt","sourceCode":"class Solution {\n    private boolean R1_All(int[] num) {\n        return Arrays.stream(num).allMatch(q -> q == 0);\n    }\n    private List<Set<Integer>> DP(int T) {\n        List<Set<Integer>> dp = new ArrayList<>();\n        for (int s = 0; s < T; s++) {\n            dp.add(new HashSet<>(Collections.singleton(0)));\n        }\n        return dp;\n    }\n    private void process(int Low, int High, int V, int[] num, List<Set<Integer>> dp) {\n        for (int j = Low; j <= High; j++) {\n            Set<Integer> R = new HashSet<>();\n            for (int R1 : dp.get(j)) {\n                if (R1 + V <= num[j]) {\n                    R.add(R1 + V);\n                }\n            }\n            dp.get(j).addAll(R);\n        }\n    }\n    public int minZeroArray(int[] num, int[][] X) {\n        int T = num.length;\n        if (R1_All(num)) return 0;\n\n        List<Set<Integer>> dp = DP(T);\n\n        for (int s = 0; s < X.length; s++) {\n            process(X[s][0], X[s][1], X[s][2], num, dp);\n            if (isValid(num, dp)) return s + 1;\n        }\n        return -1;\n    }\n    private boolean isValid(int[] num, List<Set<Integer>> dp) {\n        return IntStream.range(0, num.length).allMatch(j -> dp.get(j).contains(num[j]));\n    }\n}\n","author":"Ritu Raj Singh","submissionId":"1575233177"},[]]},{"1492":[{"id":"1492","fileName":"1575233251.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        MX = 10000\n        k = [MX if n > 0 else 0 for n in nums]\n\n        if max(k) == 0:\n            return 0\n        \n        for i, n in enumerate(nums):\n            dp1 = [False] * (n + 1)\n            dp2 = [False] * (n + 1)\n\n            #print('a', i, n)\n\n            for qi, q in enumerate(queries):\n                l, r, val = q\n                if l <= i and i <= r and val <= n:\n                    for j in range(len(dp2)):\n                        #print (j, dp1[j], dp2[j], val)\n                        if j < val:\n                            dp2[j] = dp1[j]\n                        elif j == val:\n                            dp2[j] = True\n                        else:\n                            #print (j, dp1[j], dp2[j], dp1[j-val])\n                            dp2[j] = dp1[j-val] or dp1[j]\n            \n                    if dp2[n]:\n                        #print ('c', qi)\n                        k[i] = qi\n                        break\n                \n                    #print('b', dp2)\n                    dp1 = dp2\n                    dp2 = [False] * (n + 1)\n\n        #print (k)\n        maxk = max(k)\n        return maxk + 1 if maxk != MX else -1\n        \n        ","author":"Ivan Macek","submissionId":"1575233251"},[]]},{"1493":[{"id":"1493","fileName":"1575233277.txt","sourceCode":"class Solution {\npublic:\n bool canConstruct(const vector<int>& a, int x) {\n   \n    vector<bool> dp(x + 1, false);\n    dp[0] = true;  \n\n  \n    for (int num : a) {\n    \n        for (int s = x; s >= num; --s) {\n            if (dp[s - num]) {\n                dp[s] = true;\n            }\n        }\n    }\n\n    return dp[x];\n}\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q){\n        int n = nums.size(),m = q.size(),res = -1;\n        for(int i=0;i<n;++i){\n            if(!nums[i]){\n                res = max(res,0);\n                continue;\n            }\n            vector<int> mp;\n            int cres = -1;\n            for(int j=0;j<m;++j){\n                if(q[j][0] <= i and i <= q[j][1]){\n                    if(q[j][2] > nums[i]) continue;\n                    mp.push_back(q[j][2]);\n                    if(canConstruct(mp,nums[i])){\n                        cres = max(cres,j+1);\n                        break;\n                    }\n                }\n            }\n            if(cres == -1) return cres;\n            res = max(res,cres);\n        }\n        return res;\n    }\n};","author":"Sakthi Narayanan R","submissionId":"1575233277"},[]]},{"1494":[{"id":"1494","fileName":"1575233307.txt","sourceCode":"class Solution {\npublic:\n    \n    int solve(vector<vector<int>> &psum,int n,int col,int index,int sum,vector<vector<int>> &dp)\n    {\n        if(index>=n)\n        {\n            if(sum==0)\n            {\n                return index;\n            }\n            return 1e9;\n        }\n    \n        if(sum==0)\n        {\n            return index;\n        }\n\n        if(sum<0)\n        {\n            return 1e9;\n        }\n        \n        if(dp[index][sum]>-1)\n        {\n            return dp[index][sum];\n        }\n        \n        int a = 1e9;\n        if(sum-psum[index][col]>=0)\n        {\n            a = solve(psum,n,col,index+1,sum-psum[index][col],dp);\n        }\n        \n        int b = solve(psum,n,col,index+1,sum,dp);\n        \n        dp[index][sum] = min(a,b);\n        return dp[index][sum];\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        \n        vector<vector<int>> psum(m,vector<int>(n+1,0));\n        \n        for(int i=0;i<m;i++)\n        {\n            int a = queries[i][0];\n            int b = queries[i][1];\n            int c = queries[i][2];\n            \n            psum[i][a]+=c;\n            psum[i][b+1]+=(-1*c);\n        }\n        \n        for(int i=0;i<m;i++)\n        {\n            for(int j=1;j<n+1;j++)\n            {\n                psum[i][j] = psum[i][j] + psum[i][j-1];\n            }\n        }\n        \n        int ans = INT_MIN;\n        for(int i=0;i<n;i++)\n        {\n            vector<vector<int>> dp(m+1,vector<int>(nums[i]+1,-1));\n            int a = solve(psum,m,i,0,nums[i],dp);\n            if(a==1e9)\n            {\n                return -1;\n            }\n            ans=max(ans,a);\n        }\n        \n\n        return ans;\n    }\n};","author":"onkarjondhale","submissionId":"1575233307"},[]]},{"1496":[{"id":"1496","fileName":"1575233322.txt","sourceCode":"/* ----------------------------------------------- */\n/*  Template by Bharadwaj ( The Authentic JS CodeBuff )  */\n/* ------------------------------------------------ */\n/*    Youtube: https://youtube.com/@code-with-Bharadwaj   */\n/*    Portfolio: https://manu-bharadwaj-portfolio.vercel.app/ */\n/* ----------------------------------------------- */\n\nvar minZeroArray = function (a, q) {\n        let n = a.length;\n        \n        let f = true;\n        for (let i = 0; i < n; i++) {\n                if (a[i] !== 0) {\n                        f = false;\n                        break;\n                }\n        }\n        if (f) return 0;\n        \n        let o = new Array(n);\n        for (let i = 0; i < n; i++) {\n                o[i] = [];\n        }\n        \n        for (let i = 0; i < q.length; i++) {\n                let s = q[i][0],\n                        e = q[i][1],\n                        d = q[i][2];\n                for (let j = s; j <= e; j++) {\n                        o[j].push([i, d]);\n                }\n        }\n        \n        let l = 1,\n                r = q.length,\n                res = -1;\n        \n        while (l <= r) {\n                let m = ~~((l + r) / 2);\n                if (c(a, o, m)) {\n                        res = m;\n                        r = m - 1;\n                } else {\n                        l = m + 1;\n                }\n        }\n        \n        return res;\n};\n\nfunction c(a, o, k) {\n        let n = a.length;\n        \n        for (let i = 0; i < n; i++) {\n                let t = a[i];\n                let d = new Array(t + 1).fill(false);\n                d[0] = true;\n                \n                for (let j = 0; j < o[i].length; j++) {\n                        let p = o[i][j];\n                        if (p[0] < k) {\n                                let v = p[1];\n                                for (let x = t; x >= v; x--) {\n                                        if (d[x - v]) {\n                                                d[x] = true;\n                                        }\n                                }\n                        }\n                }\n                if (!d[t]) return false;\n        }\n        \n        return true;\n}\n","author":"Manu Bharadwaj BN","submissionId":"1575233322"},[]]},{"1497":[{"id":"1497","fileName":"1575233507.txt","sourceCode":"class Solution\n{\npublic:\n    int minZeroArray(vector<int> &nums, vector<vector<int>> &queries)\n    {\n        vector<int> a = nums;\n        vector<vector<int>> q = queries;\n        int l = 0, r = q.size() - 1;\n        int ans=-1;\n        int cnt = 0;\n\n        for (int i = 0; i < a.size(); i++)\n        {\n            if (a[i] == 0)\n                cnt++;\n        }\n        if (cnt == a.size())\n            return 0;\n\n        while (l <= r)\n        {\n            int mid = (l + r) / 2;\n            vector<vector<int>> tmp(a.size());\n            vector<int> cur = a;\n            for (int i = 0; i <= mid; i++)\n            {\n                for (int j = q[i][0]; j <= q[i][1]; j++)\n                {\n                    tmp[j].push_back(q[i][2]);\n                }\n            }\n            for (int k = 0; k < a.size(); k++)\n            {\n                unordered_set<int> dp = {0};\n                for(int i=0; i<tmp[k].size(); i++)\n                {\n                    vector<int> sum;\n                    for (int it: dp) \n                    {\n                        sum.push_back(it + tmp[k][i]);\n                    }\n                    dp.insert(sum.begin(), sum.end());\n                    if (dp.count(nums[k])) {\n                        cur[k] = 0;\n                    } \n\n                }\n            }\n            bool flag = false;\n            for (int i = 0; i < a.size(); i++)\n            {\n                if (cur[i] != 0)\n                {\n                    flag = true;\n                    break;\n                }\n            }\n            if (!flag)\n            {\n                ans=mid+1;\n                r=mid-1;\n            }\n            else\n            {\n               l=mid+1;               \n            }\n        }\n        return ans;\n    }\n};\n","author":"vansh268p","submissionId":"1575233507"},[]]},{"1499":[{"id":"1499","fileName":"1575233530.txt","sourceCode":"class Solution {\npublic:\nusing ll= long long;\nusing sg=string;\ntypedef pair<int, int> pll;\ntypedef vector<int> vll;\ntypedef vector<pll> vpll; \ntypedef map<int,int> mll;\n#define ff first\n#define ss second\n#define pb push_back\n#define fl(i,n) for(int i=0;i<n;i++)\n#define vr(v) v.begin(),v.end()\n#define flp(i,a,b) for(int i = a; i <= b; i++)\n    int dp[1005][1005];\n    int cr=-1;\n\n    int f(int ind,int sm,vector<pair<int,int>>&vp){\n        if(sm==0){\n            cr=0;\n            if(ind==vp.size()){\n                // cr=vp[vp.size()-1].ss+1;\n                return vp[vp.size()-1].ss+1;\n            }\n            \n            // cr=min(cr,vp[ind-1].ss+1);\n            return vp[ind-1].ss+1;\n        }\n        if(ind==vp.size()){\n            return 1e8;\n        }\n        if(sm<0){\n            return 1e8;\n        }\n        int &mem=dp[ind][sm];\n        if(dp[ind][sm]!=-1){\n            return dp[ind][sm];\n        }\n        int a=f(ind+1,sm,vp);\n        int b=f(ind+1,sm-vp[ind].first,vp);\n        return dp[ind][sm]=min(a,b);\n    }\n    int minZeroArray(vector<int>& v, vector<vector<int>>& q) {\n        int n=v.size();\n        vector<int>pre(n+1,0);\n        vector<vector<pair<int,int>>>u(n);\n\n        int m=q.size();\n        for(int i=0;i<m;i++){\n            int a=q[i][0];\n            int b=q[i][1];\n            int c=q[i][2];\n            for(int j=a;j<=b;j++){\n                u[j].push_back({c,i});\n            }\n        }\n        int maxi=0;\n\n        // fl(i,n){\n        //     for(auto it:u[i]){\n        //         cout<<it.ff<<\" \"<<it.ss;\n        //     }cout<<endl;\n        // }\n\n        for(int i=0;i<n;i++){\n            if(v[i]==0){\n                continue;\n            }\n            cr=-1;\n            memset(dp,-1,sizeof(dp));\n            int b=f(0,v[i],u[i]);\n            // cout<<\"cr \"<<cr<<\" \"<<i<<endl;\n            if(cr!=-1){\n                maxi=max(maxi,b);\n            }else{\n                return -1;\n            }\n        }\n        return maxi;\n    }\n};","author":"utkarsh prakash","submissionId":"1575233530"},[]]},{"1500":[{"id":"1500","fileName":"1575233551.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length, m = queries.length;\n        boolean allZero = true;\n        for (int x : nums) {\n            if (x != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) return 0;\n        List<List<int[]>> coinsForIndex = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            coinsForIndex.add(new ArrayList<>());\n        }\n        for (int qi = 0; qi < m; qi++) {\n            int l = queries[qi][0], r = queries[qi][1], v = queries[qi][2];\n            for (int i = l; i <= r; i++) {\n                coinsForIndex.get(i).add(new int[]{qi, v});\n            }\n        }\n        int lo = 0, hi = m, ans = -1;\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            boolean ok = true;\n            for (int i = 0; i < n; i++) {\n                List<int[]> coinList = coinsForIndex.get(i);\n                int total = 0;\n                List<Integer> available = new ArrayList<>();\n                for (int[] pair : coinList) {\n                    if (pair[0] < mid) {\n                        available.add(pair[1]);\n                        total += pair[1];\n                    }\n                }\n                if (total < nums[i] || (nums[i] > 0 && !subsetSum(available, nums[i]))) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) {\n                ans = mid;\n                hi = mid - 1;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        return ans;\n    }\n    private boolean subsetSum(List<Integer> coins, int target) {\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n        for (int coin : coins) {\n            for (int j = target; j >= coin; j--) {\n                if (dp[j - coin]) dp[j] = true;\n            }\n            if (dp[target]) return true;\n        }\n        return dp[target];\n    }\n}","author":"HarshAggarwal1","submissionId":"1575233551"},[]]},{"1501":[{"id":"1501","fileName":"1575233545.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n=len(nums)\n        possible=[1<<x for x in nums]\n        c=sum(x&1 for x in possible)\n        if c==n:\n            return 0\n        for j,(l,r,val) in enumerate(queries):\n            for i in range(l,r+1):\n                if possible[i]&1:\n                    continue\n                possible[i]=possible[i]|(possible[i]>>val)\n                if possible[i]&1:\n                    c+=1\n            if c==n:\n                return j+1\n        return -1","author":"Sandeep P","submissionId":"1575233545"},[]]},{"1502":[{"id":"1502","fileName":"1575233576.txt","sourceCode":"void print(){\n    vector<int>arr;\n    int n=arr.size();\n    for(auto it:arr){\n        cout<<\"->\"<<it<<endl;\n    }\n}\nint binary_search(vector<int>& v, vector<vector<int>>& qs) {\n        int n = v.size(), q = qs.size();\n        int d = 0;\n        int low = 0, hi = q + 1, ans = -1;\n        while (low < hi) {\n            int mid = low + (hi - low) / 2;\n            if (ans<=mid) {\n                ans = mid;\n                hi = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n    print();\n        return (ans > q) ? -1 : ans;\n    }\nclass Solution {\nprivate:\n    vector<vector<pair<int, int>>> helper2(const vector<int>& v, const vector<vector<int>>& qs) {\n        int n = v.size(), q = qs.size();\n        vector<vector<pair<int, int>>> m(n);\n        for (int j = 0; j < q; j++) {\n            int l = qs[j][0], r = qs[j][1], a = qs[j][2];\n            for (int i = l; i <= r; i++) {\n                m[i].push_back({j, a});\n            }\n        }\n        return m;\n    }   \nbool helper(int k, const vector<int>& v, const vector<vector<pair<int, int>>>& m) {\n        int n = v.size();\n        for (int i = 0; i < n; i++) {\n            int curr = v[i];\n            if (curr == 0)\n                continue;\n            vector<int> coin;\n            for (auto &it : m[i]) {\n                if (it.first < k)\n                    coin.push_back(it.second);\n            }\n            vector<bool> dp(curr + 1, false);\n            dp[0] = true;\n            for (int it : coin) {\n                for (int j = curr; j >= it; j--) {\n                    dp[j] = dp[j] || dp[j - it];\n                }\n            }\n            if (!dp[curr])\n                return false;\n        }\n    print();\n        return true ;\n    }    \npublic:\n    int minZeroArray(vector<int>& v, vector<vector<int>>& qs) {\n        int n = v.size(), q = qs.size();\n        int d = 90;\n        vector<vector<pair<int, int>>> m = helper2(v, qs);\n        int low = 0, high = q + 1, ans = -1;\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            if (helper(mid, v, m)) {\n                ans = mid;\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        print();\n        return (ans > q) ? -1 : ans;\n    }\n};","author":"ujjwal2612","submissionId":"1575233576"},[]]},{"1503":[{"id":"1503","fileName":"1575233654.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<set<int>> res(n);\n        for (int i = 0; i < n; i++) res[i].insert(0);\n\n        bool isZ = true;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != 0) {\n                isZ = false;\n                break;\n            }\n        }\n        if (isZ) return 0;\n    \n        for (int k = 0; k < m; k++) {\n            int l = queries[k][0], r = queries[k][1], val = queries[k][2];\n            for (int i = l; i <= r; i++) {\n                set<int> curr = res[i];\n                for (int s : curr) res[i].insert(s + val);\n            }\n            bool isZero = true;\n            for (int i = 0; i < n; i++) {\n                if (res[i].find(nums[i]) == res[i].end()) {\n                    isZero = false;\n                    break;\n                }\n            }\n            if (isZero) return k + 1;\n    }\n    return -1;\n    }\n};","author":"Bindhu Jupally","submissionId":"1575233654"},[]]},{"1505":[{"id":"1505","fileName":"1575233699.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& A, vector<vector<int>>& Q) {\n        if (accumulate(A.begin(), A.end(), 0) == 0)\n            return 0;\n        \n        int n = A.size();\n        vector<bitset<1001>> dp(n);\n        for (int i = 0; i < n; ++i)\n            dp[i][0] = 1;\n        \n        for (int i = 0; i < Q.size(); ++i) {\n            int l = Q[i][0], r = Q[i][1], val = Q[i][2];\n            for (int j = l; j <= r; ++j) {\n                dp[j] = (dp[j] << val) | dp[j]; // decrement or not\n            }\n            bool ok = true;\n            for (int j = 0; j < n; ++j) {\n                if (!dp[j][A[j]]) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) return i + 1;\n        }\n        return -1;\n    }\n};","author":"oscp","submissionId":"1575233699"},[]]},{"1506":[{"id":"1506","fileName":"1575233702.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        int l = 0;\n        int r = m;\n        int ans = -1;\n        while(l <= r){\n            int mid = (l + r) / 2;\n            int c=1;\n            for(int j = 0; j < n; j++){\n                vector<int> dp(2000, false);\n                dp[0] = 1;\n                for(int i = 0; i < mid; i++){\n                    int d=(j >= queries[i][0] && j <= queries[i][1])?1:0;\n                    if(!d) continue;\n                    else{\n                        for(int s = 1000 - queries[i][2]; s >= 0; s--){\n                            if(dp[s]==0) continue;\n                            dp[s + queries[i][2]] = 1;\n                        }\n                    }\n                }\n                if(dp[nums[j]]){\n                    c=1;\n                }\n                else{\n                    c=0;\n                    break;\n                }\n            }\n            if(c){\n                ans = mid;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"Vaibhav311004","submissionId":"1575233702"},[]]},{"1507":[{"id":"1507","fileName":"1575233830.txt","sourceCode":"class Solution {\npublic:\n    bool check(vector<int> &a, vector<vector<int>> &queries, int idx, int dokle, vector<multiset<int>>& koji){\n        if(idx<dokle){\n            for(int i = idx+1;i<=dokle;i++){\n                int l = queries[i][0];\n                int r = queries[i][1];\n                int val = queries[i][2];\n                for(int x = l;x<=r;x++)koji[x].insert(val);\n            }\n        }\n        else{\n            for(int i = idx;i>dokle;i--){\n                int l = queries[i][0];\n                int r = queries[i][1];\n                int val = queries[i][2];\n                for(int x = l;x<=r;x++)koji[x].erase(koji[x].find(val));\n            }\n        }\n        //for(int i = 0;i<a.size();i++)cout<<delta[i]<<\" \"; cout<<endl;\n        int n = a.size();\n        for(int i = 0;i<n;i++){\n            vector<bool> moze(1001, false);\n            moze[0]=true;\n            for(int x : koji[i]){\n                vector<bool> moze2 = moze;\n                for(int c = x;c<=1000;c++){\n                    if(!moze2[c])moze2[c]=moze[c-x];\n                }\n                moze = moze2;\n            }\n            if(!moze[a[i]])return true;\n        }\n        return false;\n\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n         int n = nums.size();\n        int q = queries.size();\n        int cnt = 0;\n        for(int i = 0;i<n;i++)if(nums[i]==0)cnt++;\n        if(cnt==n)return 0;\n        vector<multiset<int>> a(n);\n        int l = 0;\n        int r = q-1;\n        int trindex = -1;\n        int res = -1;\n        while(l<=r){\n            int mid = (l+r)/2;\n            //cout<<mid<<endl;\n            if(!check(nums, queries, trindex, mid, a)){\n                r = mid - 1;\n                res = mid+1;\n                trindex = mid;\n            }\n            else{\n                l = mid+1;\n                trindex = mid;\n            }\n        }\n        return res;\n    }\n};","author":"asdasdasd","submissionId":"1575233830"},[]]},{"1508":[{"id":"1508","fileName":"1575233962.txt","sourceCode":"class Solution {\npublic:\n    bool canMakeSum(vector<int>& arr, int target) {\n        unordered_set<int> sums;\n        sums.insert(0);\n        for (int num : arr) {\n            unordered_set<int> newSums;\n            for (int s : sums) {\n                if (s + num == target)\n                    return true;\n                newSums.insert(s + num);\n            }\n            sums.insert(newSums.begin(), newSums.end());\n        }\n        return sums.find(target) != sums.end();\n    }\n    bool isPossible(int mid,vector<int>& nums,vector<vector<int>>& queries){\n        int n = nums.size();\n        vector<vector<int>> vec(n);\n        for(int i=0;i<mid;i++){\n            int L = queries[i][0], R = queries[i][1], V = queries[i][2];\n            for(int j=L;j<=R;j++){\n                vec[j].push_back(V);\n            }\n        }\n        for(int i=0;i<n;i++){\n            if(!canMakeSum(vec[i],nums[i]))\n                return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int low=0,high=queries.size(),ans=-1;\n        while(low<=high){\n            int mid=(low+high)/2;\n            if(isPossible(mid,nums,queries)){\n                ans=mid;\n                high=mid-1;\n            }else{\n                low=mid+1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"anaa1020244r","submissionId":"1575233962"},[]]},{"1509":[{"id":"1509","fileName":"1575233888.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<int> v1 = nums;\n        bool isPossible1 = true;\n        for (int i = 0; i < n; i++) {\n            if (v1[i] != 0) { \n                isPossible1 = false; \n                break; \n            }\n        }\n        if (isPossible1) return 0;\n        for (int k = 1; k <= m; k++) {\n            bool isPossible2 = true;\n            for (int i = 0; i < n; i++) {\n                int target = v1[i];\n                vector<bool> dp(target + 1, false);\n                dp[0] = true;\n                for (int j = 0; j < k; j++) {\n                    int L = queries[j][0], R = queries[j][1], d = queries[j][2];\n                    if (i >= L && i <= R) {\n                        for (int s = target - d; s >= 0; s--) {\n                            if (dp[s]==true)\n                                dp[s + d] = true;\n                        }\n                    }\n                }\n                if (!dp[target]) { \n                    isPossible2 = false;\n                    break;\n                }\n            }\n            if (isPossible2)\n                return k;\n        }\n        return -1;\n    }\n};\n","author":"Sundorom Das","submissionId":"1575233888"},[]]},{"1510":[{"id":"1510","fileName":"1575233961.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        # pos = {}\n        posSet = {}\n        for i in range(len(nums)):\n            # pos[i] = []\n            posSet[i] = set([0])\n        if max(nums) == 0 and min(nums) == 0:\n            return 0\n        for i in range(len(queries)):\n            q = queries[i]\n            start = q[0]\n            end = q[1]\n            val = q[2]\n            found = True\n            for numIndex in range(len(nums)):\n                if numIndex >= start and numIndex <= end:\n                    # pos[numIndex].append(val)\n                    newVal = set([])\n                    for existing in posSet[numIndex]:\n                        newVal.add(existing + val)\n                    for num in newVal:\n                        posSet[numIndex].add(num)\n                    posSet[numIndex].add(val)\n                if nums[numIndex] not in posSet[numIndex]:\n                    found = False\n            if found:\n                return i + 1\n        return -1","author":"kdtr","submissionId":"1575233961"},[]]},{"1511":[{"id":"1511","fileName":"1575233982.txt","sourceCode":"class Solution:\n    def getSubsetSum(self, values, target):\n        possible_sums = {0}\n        for val in values:\n            if target in possible_sums:\n                return True\n            new_sums = set(possible_sums)\n            for s in possible_sums:\n                new_sum = s + val\n                if new_sum == target:\n                    return True\n                if new_sum < target:\n                    new_sums.add(new_sum)\n            possible_sums = new_sums\n    \n        return (target in possible_sums)\n\n    def isPossible(self, nums, queries, k):\n        n = len(nums)\n        coverage = [[] for _ in range(n)]\n        for i in range(k):\n            l, r, val = queries[i]\n            for idx in range(l, r+1):\n                coverage[idx].append(val)\n        for i in range(n):\n            if nums[i] < 0:\n                return False\n            if sum(coverage[i]) < nums[i]:\n                return False\n            if not self.getSubsetSum(coverage[i], nums[i]):\n                return False\n        return True\n    \n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        left, right = 0, len(queries)\n        res = -1\n    \n        while left <= right:\n            mid = (left + right) // 2\n            if self.isPossible(nums, queries, mid):\n                res = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n    \n        return res if res != -1 else -1","author":"Revanth Balineni","submissionId":"1575233982"},[]]},{"1512":[{"id":"1512","fileName":"1575234115.txt","sourceCode":"class Solution {\npublic:\n    int solve(vector<int>&num, int i, int sum, vector<vector<int>>&memo){\n        if(sum==0) return 1;\n        if(i==num.size()) return 0;\n        int opt1 = 0;\n        if(sum-num[i]>=0){\n            opt1 = solve(num, i+1,sum-num[i],memo);\n        }\n        int opt2 = solve(num,i+1,sum,memo);\n        return memo[i][sum] =opt1||opt2;\n    }\nbool makeSum(vector<int>& num, int sum) {\n    int n = num.size();\n    vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));\n\n    // Initialize the dp array\n    for (int i = 0; i <= n; ++i) {\n        dp[i][0] = true; // Sum 0 can always be achieved with an empty subset\n    }\n\n    // Fill the dp table\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= sum; ++j) {\n            if (j < num[i - 1]) {\n                dp[i][j] = dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - num[i - 1]];\n            }\n        }\n    }\n\n    return dp[n][sum];\n}\n    bool isPossible(vector<int>&nums, vector<vector<int>>& queries,int mid){\n        int n = nums.size();\n        vector<vector<int>>vec(n);\n        for(int i = 0; i<mid; i++){\n            int l = queries[i][0], r = queries[i][1], val =queries[i][2];\n            for(int j = l; j<=r; j++) vec[j].push_back(val);\n        }\n        for(int i = 0; i<n;i++){\n            int sum = nums[i];\n            vector<int>num = vec[i];\n            if(!makeSum(num,sum)) return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = queries.size();\n        int low = 0, high = n, ans =-1;\n        while(low<=high){\n            int mid = low+(high-low)/2;\n            if(isPossible(nums,queries,mid)){\n                ans = mid;\n                high = mid-1;\n            }\n            else low = mid+1;\n        }\n        return ans;\n        \n        \n    }\n};","author":"shiv0411","submissionId":"1575234115"},[]]},{"1513":[{"id":"1513","fileName":"1575234000.txt","sourceCode":"from sortedcontainers import SortedList\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if max(nums) == 0:\n            return 0\n        left = 0\n        right = len(queries) - 1\n        n = len(nums)\n        while left <= right:\n            mid = (left + right) // 2\n            curr_queries = queries[:mid+1]\n            curr_queries.sort(key=lambda x: (x[0], x[1]))\n            pq = []\n            iq = 0\n            isGood = True\n            curr_options = SortedList()\n            for idx in range(n):\n                while pq and pq[0][0] < idx:\n                    curr_options.remove(pq[0][1])\n                    heapq.heappop(pq)\n                while iq <= mid and idx >= curr_queries[iq][0]:\n                    curr_options.add(curr_queries[iq][2])\n                    heapq.heappush(pq, [curr_queries[iq][1], curr_queries[iq][2]])\n                    iq += 1\n                n_options = len(curr_options)\n                n_num = nums[idx]\n                if n_num == 0:\n                    continue\n                dp = [[False for _ in range(n_num + 1)] for _ in range(n_options + 1)]\n                dp[0][0] = True\n                for i in range(1, n_options + 1):\n                    for j in range(n_num + 1):\n                        # Use the current option\n                        if j >= curr_options[i - 1]:\n                            dp[i][j] = dp[i-1][j-curr_options[i - 1]]\n                        # Don't use the current option\n                        dp[i][j] |= dp[i-1][j]\n                isGood = dp[-1][-1]\n                if not isGood:\n                    break\n            if not isGood:\n                if left == right:\n                    break\n                left = mid + 1\n            else:\n                if left == right:\n                    break\n                right = mid\n        return left + 1 if isGood else -1\n        ","author":"jayxps","submissionId":"1575234000"},[]]},{"1514":[{"id":"1514","fileName":"1575234422.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)        \n        zero_idx = set()\n        dec = [set() for _ in range(n)]\n\n        for i in range(n):\n            if nums[i] == 0:\n                zero_idx.add(i)\n            else:\n                dec[i].add(nums[i])\n\n        if len(zero_idx) == n: \n            return 0\n        \n        for i, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                if j in zero_idx:\n                    continue\n                if v in dec[j]:\n                    zero_idx.add(j)\n                else:\n                    for k in list(dec[j]):\n                        if v == k:\n                            zero_idx.add(j)\n                        elif k > v:\n                            dec[j].add(k - v)\n\n            if len(zero_idx) == n:\n                return i + 1\n\n        return -1","author":"bobbybloo","submissionId":"1575234422"},[]]},{"1515":[{"id":"1515","fileName":"1575234076.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        n = len(nums)\n        \n        def valid(x):\n            ops = [[] for i in range(n)]\n\n            for q in range(x):\n                a, b, v = queries[q]\n                for j in range(a, b+1):\n                    ops[j].append(v)\n                    \n            def recur(i, curr):\n                if dp[i][curr] != -1:\n                    return dp[i][curr]\n                if not curr:\n                    return True\n                if i == m:\n                    return False\n    \n                if l[i] > curr:\n                    dp[i][curr] = recur(i+1, curr)\n                    return dp[i][curr]\n                    \n                dp[i][curr] = recur(i+1, curr-l[i]) or recur(i+1, curr)\n                return dp[i][curr]\n                \n            l = [1, 1]\n            m = len(l)\n            for i in range(n):\n                l = ops[i]\n                m = len(l)\n\n                @cache\n                def recur(i, curr):\n                    # if dp[i][curr] != -1:\n                    #     return dp[i][curr]\n                    if not curr:\n                        return True\n                    if i == m:\n                        return False\n        \n                    if l[i] > curr:\n                        # dp[i][curr] = recur(i+1, curr)\n                        return recur(i+1, curr)\n                        \n                    # dp[i][curr] = recur(i+1, curr-l[i]) or recur(i+1, curr)\n                    return recur(i+1, curr-l[i]) or recur(i+1, curr)\n                \n                if not recur(0, nums[i]):\n                    return False\n            return True\n\n        lo = 0\n        hi = len(queries)\n        ans = -1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if valid(mid):\n                ans = mid\n                hi = mid - 1\n            else:\n                lo = mid + 1\n\n        return ans","author":"Ajay Prem","submissionId":"1575234076"},[]]},{"1516":[{"id":"1516","fileName":"1575234011.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        # def isValid(k):\n        #     events = [0]*n\n        #     for l, r, val in queries[:k+1]:\n        #         events[l] -= val\n        #         if r+1 < n:\n        #             events[r+1] += val\n        #     arr = [0]*n\n        #     curr = 0\n        #     for i in range(n):\n        #         curr += events[i]\n        #         arr[i] += curr\n        #     print(arr)\n        #     for i in range(n):\n        #         a = arr[i]+nums[i]\n        #         if a > 0:\n        #             return False\n        #     return True\n        def subset_sum_possible(coins, target):\n            dp = [False] * (target + 1)\n            dp[0] = True\n            for coin in coins:\n                for s in range(target, coin - 1, -1):\n                    if dp[s - coin]:\n                        dp[s] = True\n            return dp[target]\n        def isValid(k):\n            n = len(nums)\n            for i in range(n):\n                coins = [val for (l, r, val) in queries[:k] if l <= i <= r]\n                if not subset_sum_possible(coins, nums[i]):\n                    return False\n            return True\n                    \n        low, high = 0, len(queries)\n        res = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if isValid(mid):\n                res = mid\n                high = mid - 1 \n            else:\n                low = mid + 1\n\n        return res","author":"thumbpixels","submissionId":"1575234011"},[]]},{"1517":[{"id":"1517","fileName":"1575234215.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:    \n        res = 0\n        vals = [[] for _ in range(len(nums))]\n\n        for i in range(len(nums)):\n            while not self.make_num(nums[i], sorted(vals[i], reverse=True)):\n                # include a new query\n                while True:\n                    res += 1\n    \n                    if res > len(queries):\n                        return -1\n                    \n                    l, r, val = queries[res - 1]\n    \n                    for j in range(max(l, i), r + 1):\n                        vals[j].append(val)\n                    if i >= l and i <= r:\n                        break\n                    \n        return res\n\n    def make_num(self, num, values):\n\n        @cache\n        def backtrack(i, curr):\n            if i == len(values):\n                return curr == num\n\n            if curr == num:\n                return True\n\n            if curr + values[i] <= num:\n                if backtrack(i + 1, curr + values[i]):\n                    return True\n            if backtrack(i + 1, curr):\n                return True\n            return False\n\n        return backtrack(0, 0)\n\n        \n    #     l = 0\n    #     r = len(queries) - 1\n    #     res = len(queries)\n\n    #     if not self.check(r, nums, queries):\n    #         return -1\n\n    #     if sum(nums) == 0:\n    #         return 0\n\n    #     while l <= r:\n    #         m = l + (r - l) // 2\n    #         if self.check(m, nums, queries):\n    #             res = min(res, m)\n    #             r = m - 1\n    #         else:\n    #             l = m + 1\n\n    #     return res + 1\n\n    # def check(self, index, nums, queries):\n    #     values = [[] for _ in range(len(nums))]\n        \n    #     for i in range(index + 1):\n    #         l, r, val = queries[i]\n    #         for j in range(l, r + 1):\n    #             values[j].append(val)\n\n    #     for i in range(len(nums)):\n    #         if not self.make_num(nums[i], sorted(values[i], reverse=True)):\n    #             return False\n    #     return True\n\n","author":"kay118","submissionId":"1575234215"},[]]},{"1519":[{"id":"1519","fileName":"1575234357.txt","sourceCode":"class Solution {\npublic:\n    int Size=1001;\n    int add(int a, int b){\n        return a+b;\n    }\n    int mul(int a, int b){\n        return a*b;\n    }\n    bool minz(int k,vector<int>&nums, vector<vector<int>>&queries, int n, int m){\n        bool answer=true;\n        int hi=20;\n        for(int j=0;j<n;j++){\n            vector<bool>dp(Size,false);\n            dp[0]=true;\n            for(int i=0;i<k;i++){\n                if(j>=queries[i][0] && j<=queries[i][1]){\n                    int ind=(Size-11+10)-queries[i][2];\n                    for(int s=ind;s>=3-3;s--){\n                        if(dp[s]){\n                            int happy=add(s,queries[i][2]);\n                            dp[happy]=true;\n                        }\n                    }\n                }\n            }\n            \n            if(!dp[nums[j]]){\n                answer=false;\n            }\n        }\n        return answer;\n    }\n    int func(vector<int>&nums, vector<vector<int>>&queries, int n, int m){\n        vector<int>v=nums;\n        int l=0;\n        int h=m;\n        int happy=18;\n        int bday=10;\n        int res=-1;\n        while(l<=h){\n            int mi=(add(l,h))/2;\n            if(minz(mi,nums,queries,n,m)){\n                res=mi;\n                h=mi-1;\n            }\n            else{\n                l=add(mi,1);\n            }\n        }\n        return res;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        int m=queries.size();\n        int b=5;\n        int c=0;\n        return func(nums,queries,n,m);\n    }\n};","author":"nehalsarraf3","submissionId":"1575234357"},[]]},{"1520":[{"id":"1520","fileName":"1575234156.txt","sourceCode":"class Solution {\n    int cache[1001][1001];\n    int dfs(std::vector<int>& values, int idx, int target)\n    {\n        if (target == 0)\n        {\n            return idx;\n        }\n        \n        if (idx >= values.size() || target < 0)\n        {\n            return INT_MAX;\n        }\n\n        // std::cout << \"idx: \" << idx << \", target: \" << target << \"n\";\n        if (cache[idx][target] != -1)\n            return cache[idx][target];\n\n        int steps = INT_MAX;\n\n        // take\n        steps = std::min(steps, dfs(values, idx + 1, target - values[idx]));\n\n        // not take\n        steps = std::min(steps, dfs(values, idx + 1, target));\n\n        cache[idx][target] = steps;\n        return steps;\n    }\n\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\n        std::vector<std::vector<int>> digit_values(nums.size());\n\n        for (auto& q : queries)\n        {\n            for (int i = 0; i < digit_values.size(); i++)\n            {\n                if (i >= q[0] && i <= q[1])\n                {\n                    digit_values[i].push_back(q[2]);\n                }\n                else\n                {\n                    digit_values[i].push_back(0);\n                }\n            }\n        }\n\n        int ret = -1;\n\n        for (int i = 0; i < nums.size(); i++)\n        {\n            int target = nums[i];\n            auto& values = digit_values[i];\n\n            memset(cache, -1, sizeof(cache));\n            int min_step = dfs(values, 0, target);\n\n            if (min_step == INT_MAX)\n                return -1;\n\n            ret = std::max(ret, min_step);\n        }\n\n        return ret;\n    }\n};","author":"Fred Yu","submissionId":"1575234156"},[]]},{"1521":[{"id":"1521","fileName":"1575234554.txt","sourceCode":"class Solution {\npublic:\n    int solve(vector<pair<int,int>>&nums,vector<vector<int>>&dp,int idx,int amt)\n{\n    // cout<<amt<<endl;\n    if(amt==0){\n        return nums[idx-1].second+1;\n    }\n    if(amt<0){\n        return 1e8;\n    }\n    if(idx>=nums.size())return 1e8;\n    if(dp[idx][amt]!=-1)return dp[idx][amt];\n\n    int ans=1e8;\n    \n    ans=min(ans,solve(nums,dp,idx+1,amt));\n    ans=min(ans,solve(nums,dp,idx+1,amt-nums[idx].first));\n    return dp[idx][amt]=ans;\n}\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n=nums.size();\n        int ans=INT_MIN;\n        int c=0;\n        for(int i=0;i<nums.size();i++)\n            {\n                if(nums[i]==0){\n                    ans=max(ans,0);\n                    continue;\n                }\n                unordered_map<int,int>mp;\n                vector<pair<int,int>>t;\n                int tt=1e8;\n                for(int j=0;j<q.size();j++)\n                    {\n                        int l=q[j][0];\n                        int r=q[j][1];\n                        int v=q[j][2];\n                        if(l<=i && i<=r){\n                            if(v==nums[i] && tt==INT_MAX){\n                                tt=j;\n                            }\n                            else{\n                                t.push_back({v,j}); \n                            }\n                        }\n                            \n                    }\n                vector<vector<int>>dp(t.size(),vector<int>(nums[i]+1,-1));\n                // for(int i=0;i<t.size();i++){\n                //     cout<<t[i].first<<\" \"<<t[i].second<<endl;\n                // }\n                tt=min(tt,solve(t,dp,0,nums[i]));\n                if(tt>=1e8){\n                    return -1;\n                }else{\n                    ans=max(tt,ans);\n                }\n            }\n        return ans;\n    }\n};","author":"Shivesh Dixit","submissionId":"1575234554"},[]]},{"1522":[{"id":"1522","fileName":"1575234635.txt","sourceCode":"class Solution {\npublic:\n    \n    int tell(int index, int val, vector<pair<int, int>> &query, int prev, vector<vector<int>> &dp){\n        if(val == 0) return prev + 1;\n        if(index >= query.size()) return INT_MAX;\n        if(dp[index][val] != -1) return dp[index][val];\n        int ans = tell(index + 1, val, query, query[index].first, dp);\n        if(query[index].second <= val){\n            ans = min(ans, tell(index + 1, val - query[index].second, query, query[index].first, dp));\n        }\n        \n        return dp[index][val] = ans;\n    }\n    \n    \n    void print(vector<pair<int, int>> &arr){\n        for(auto &i: arr){\n            cout << i.first << \" \" << i.second << endl;\n        }\n        cout << endl;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int> eachElement(nums.size(), -1);\n        for(int i = 0; i<nums.size(); i++){\n            vector<pair<int, int>> query;\n            for(int j = 0; j<queries.size(); j++){\n                if(queries[j][0] <= i and i <= queries[j][1] and nums[i] >= queries[j][2]){\n                    query.push_back({j, queries[j][2]});\n                }\n            }\n            vector<vector<int>> dp(query.size() + 1, vector<int>(nums[i] + 1, -1)); \n            eachElement[i] = tell(0, nums[i], query, -1, dp);\n        }\n        int ans = 0;\n        for(int i = 0; i<nums.size(); i++){\n            if(eachElement[i] == INT_MAX) return -1;\n            else{\n                ans = max(ans, eachElement[i]);\n            }\n        }\n        return ans;   \n    }\n};","author":"Kamal Singh","submissionId":"1575234635"},[]]},{"1523":[{"id":"1523","fileName":"1575234573.txt","sourceCode":"public class Solution {\n    boolean dp[][];\n    boolean verify(boolean dp[][], int nums[]){\n        boolean check = true;\n        for (int j = 0; j < nums.length; j++) {\n            if (!dp[j][nums[j]]) {\n                return false;\n            }\n        }\n        return check;\n    }\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        dp = new boolean[n][1001];\n        for (int j = 0; j < n; j++) {\n            dp[j][0] = true;\n        }\n\n        boolean isZero = true;\n        for (int i : nums) {\n            if (i != 0) {\n                isZero = false;\n                break;\n            }\n        }\n        if (isZero) return 0;\n\n        for (int i = 0; i < queries.length; i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int v = queries[i][2];\n\n            for (int j = l; j<=r; j++) {\n                boolean[] res = new boolean[1001];\n                for (int m = 0; m<1001; m++) {\n                    if (dp[j][m] && m+v < 1001) {\n                        res[m+v] = true;\n                    }\n                }\n                for (int m = 0; m<1001; m++) {\n                    if (res[m]) {\n                        dp[j][m] = true;\n                    }\n                }\n                for (int m = nums[j]+1; m<1001; m++) {\n                    dp[j][m] = false;\n                }\n            }\n            if (verify(dp, nums)) return i+1;\n        }\n        \n        return -1;\n    }\n}\n","author":"Abhimanyu Pratap Singh","submissionId":"1575234573"},[]]},{"1524":[{"id":"1524","fileName":"1575234682.txt","sourceCode":"\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        int overall_max_j = -1;\n        const int INF = m + 1;\n\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            if (target == 0) continue;\n\n            vector<int> v;\n            for (int j = 0; j < m; j++) {\n                if (i >= queries[j][0] && i <= queries[j][1]) {\n                    v.push_back(j);\n                }\n            }\n            sort(v.begin(), v.end());\n\n            vector<int> dp(target + 1, INF);\n            dp[0] = -1;  \n\n            for (int idx : v) {\n                int val = queries[idx][2];\n                for (int s = target - val; s >= 0; s--) {\n                    if (dp[s] != INF && s + val <= target) {\n                        dp[s + val] = min(dp[s + val], idx);\n                    }\n                }\n            }\n\n            if (dp[target] == INF) return -1;\n\n            overall_max_j = max(overall_max_j, dp[target]);\n        }\n\n        return overall_max_j == -1 ? 0 : overall_max_j + 1;\n    }\n};","author":"VISHAL DANGI","submissionId":"1575234682"},[]]},{"1525":[{"id":"1525","fileName":"1575234750.txt","sourceCode":"class Solution {\npublic:\n    int isSubsetSum(vector<pair<int,int>> &arr, int sum) {\n        int n = arr.size();\n        vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));\n        for (int i = 0; i <= n; i++) dp[i][0] = true;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= sum; j++) {\n                if (j < arr[i - 1].first) {\n                    dp[i][j] = dp[i - 1][j]; \n                }\n                else {\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - arr[i - 1].first];\n                }\n            }\n        }\n        for(int i = 1; i<=n; i++){\n            if(dp[i][sum]){\n                return i-1;\n            }\n        }\n        return -1;\n    }\n    int f(int ind, vector<pair<int,int>> &arr, int tar, int last, vector<vector<int>>& dp){\n        if(tar == 0){\n            return last;\n        }\n        if(arr.size() == ind || tar < 0 ){\n            return -1;\n        }\n\n        int &may = dp[ind][tar];\n        if(may != -2){\n            return may;\n        }\n\n        int take = f(ind+1, arr, tar-arr[ind].first, ind, dp);\n        if(take != -1){\n            return may = take;\n        }\n        int notTake = f(ind+1, arr, tar, last, dp);\n        if(notTake != -1){\n            return may = notTake;\n        }\n        return may = -1;\n    }\n    int g(vector<pair<int, int>> &arr, int tar){\n        int N = arr.size();\n    \n        vector<vector<int>> dp(N, vector<int>(tar+1, -2));\n        return f(0, arr, tar, -1, dp);\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int N = nums.size(), Q  = queries.size();\n        vector<vector<pair<int,int>>> options(N);\n        \n        for(int i = 0; i<Q;  i++){\n            for(int j = queries[i][0]; j<=queries[i][1]; j++){\n                options[j].push_back({queries[i][2], i});\n            }\n        }\n\n        int ans = 0;\n        for(int i = 0; i<N; i++){\n            if(nums[i] == 0)\n                continue;\n            \n            int ret = isSubsetSum(options[i], nums[i]);\n            if(ret == -1){\n                return -1;\n            }\n            ans = max(ans, options[i][ret].second+1);\n        }\n        return ans;\n    }\n};","author":"Pravinkumar S","submissionId":"1575234750"},[]]},{"1526":[{"id":"1526","fileName":"1575234834.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n    \n        auto zero = [&](int k) -> bool {\n            for (int j = 0; j < n; j++) {\n                vector<bool> dp(1001, false);\n                dp[0] = true;\n                for (int i = 0; i < k; i++) {\n                    if (j >= queries[i][0] && j <= queries[i][1]) {\n                        for (int s = 1000 - queries[i][2]; s >= 0; s--) {\n                            if (dp[s]) dp[s + queries[i][2]] = true;\n                        }\n                    }\n                }\n                if (!dp[nums[j]]) return false;\n            }\n            return true;\n        };\n    \n        int low = 0, high = m, answer = -1;\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (zero(mid)) {\n                answer = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return answer;\n    }\n};","author":"SHANTANU RAI","submissionId":"1575234834"},[]]},{"1527":[{"id":"1527","fileName":"1575234727.txt","sourceCode":"class Solution(object):\n    def minZeroArray(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if sum(nums) == 0: return 0\n        dp = [set() for _ in range(n)]\n\n        for j in range(n):\n            dp[j].add(0)\n\n        for k, (l, r, val) in enumerate(queries):\n            for j in range(l, r+1):\n                new_dp = {x+val for x in dp[j]}\n                dp[j].update(new_dp)\n                dp[j] = {x for x in dp[j] if x <= nums[j]}\n                \n            allDone = all(nums[j] in dp[j] for j in range(n))\n\n            if allDone: return k + 1\n        return -1","author":"Sachin","submissionId":"1575234727"},[]]},{"1529":[{"id":"1529","fileName":"1575234968.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def can_make(cnt, target):\n            if not target:\n                return True\n\n            for k in cnt.keys():\n                if not cnt[k] or target < k:\n                    continue\n\n                cnt[k] -= 1\n                if can_make(cnt, target - k):\n                    return True\n                cnt[k] += 1\n\n            return False\n\n        n = len(nums)\n        c = sum(num == 0 for num in nums)\n        if n == c:\n            return 0\n\n        d = defaultdict(Counter)\n        t = defaultdict(int)\n        for res, [l, r, v] in enumerate(queries, 1):\n            for i in range(l, r + 1):\n                if not nums[i] or nums[i] < v:\n                    continue\n\n                d[i][v] += 1\n                t[i] += v\n\n                if t[i] == nums[i] or nums[i] == v or nums[i] < t[i] and can_make(d[i], t[i] - nums[i]):\n                    nums[i] = 0\n                    c += 1\n\n                if n == c:\n                    return res\n\n        return -1","author":"Maxim Vasilic","submissionId":"1575234968"},[]]},{"1530":[{"id":"1530","fileName":"1575234919.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        n = len(nums)\n        q_len = len(queries)\n\n        left, right = 0, q_len\n        answer = -1\n\n        def can_make_zero_array(k: int) -> bool:\n\n            for idx, original_val in enumerate(nums):\n                if original_val == 0:\n                    continue\n\n\n                vals = []\n                for q_idx, (l, r, v) in enumerate(queries):\n                    if q_idx + 1 > k:\n                        break\n                    if l <= idx <= r:\n                        vals.append(v)\n\n\n                dp = [[False] * (original_val + 1) for _ in range(len(vals) + 1)]\n                dp[0][0] = True  \n\n                for i in range(1, len(vals) + 1):\n                    val_i = vals[i - 1]  \n                    for s in range(original_val + 1):\n                        dp[i][s] = dp[i][s] or dp[i - 1][s]\n                        if s >= val_i:\n                            dp[i][s] = dp[i][s] or dp[i - 1][s - val_i]\n\n                if not dp[len(vals)][original_val]:\n                    return False\n\n            return True\n\n        while left <= right:\n            mid = (left + right) // 2\n            if can_make_zero_array(mid):\n                answer = mid \n                right = mid - 1\n            else:\n                left = mid + 1\n\n        if answer == -1:\n            return -1\n        if answer > q_len:\n            return -1\n        return answer","author":"iyht","submissionId":"1575234919"},[]]},{"1532":[{"id":"1532","fileName":"1575234976.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        maximum = max(nums)\n        if maximum == 0:\n            return 0\n            \n        n = len(nums)\n        m = len(queries)\n        dp = [[False] * (maximum + 1) for _ in range(n)]\n\n        for i in range(n):\n            dp[i][nums[i]] = True\n\n        for k in range(m):\n            success = True\n            l = queries[k][0]\n            r = queries[k][1]\n            val = queries[k][2]\n\n            for i in range(n):\n                if dp[i][0]:\n                    continue\n                    \n                if i >= l and i <= r and val <= nums[i]:\n                    if dp[i][val]:\n                        dp[i][0] = True\n                    else:\n                        for j in range(maximum + 1):\n                            if dp[i][j] and j - val >= 0:\n                                dp[i][j-val] = True\n\n                if not dp[i][0]:\n                    success = False\n\n            if success:\n                return k + 1\n\n        return -1\n            ","author":"Secluded","submissionId":"1575234976"},[]]},{"1534":[{"id":"1534","fileName":"1575234996.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<vector<pair<int, int>>> cover(n);\n\n        for (int j = 0; j < m; ++j) {\n            int l = queries[j][0];\n            int r = queries[j][1];\n            int val = queries[j][2];\n            for (int i = l; i <= r; ++i) {\n                if (i >= 0 && i < n) {\n                    cover[i].emplace_back(j, val);\n                }\n            }\n        }\n\n        int max_k = 0;\n        for (int i = 0; i < n; ++i) {\n            int k_i;\n            if (nums[i] == 0) {\n                k_i = 0;\n            } else {\n                if (cover[i].empty()) {\n                    return -1;\n                }\n                unordered_set<int> S;\n                S.insert(0);\n                k_i = -1;\n                for (auto& q : cover[i]) {\n                    int j = q.first;\n                    int val = q.second;\n                    unordered_set<int> new_S = S;\n                    bool found = false;\n                    for (int s : S) {\n                        int new_s = s + val;\n                        if (new_s == nums[i]) {\n                            k_i = j + 1;\n                            found = true;\n                            break;\n                        }\n                        if (new_s < nums[i]) {\n                            new_S.insert(new_s);\n                        }\n                    }\n                    if (found) {\n                        break;\n                    }\n                    S = move(new_S);\n                }\n                if (k_i == -1) {\n                    return -1;\n                }\n            }\n            if (k_i > max_k) {\n                max_k = k_i;\n            }\n        }\n\n        return max_k;\n    }\n};","author":"Mohamed Oraby","submissionId":"1575234996"},[]]},{"1535":[{"id":"1535","fileName":"1575235277.txt","sourceCode":"class Solution {\npublic:\n    bool isSubsetSum(vector<int> arr, int sum) {\n        int n = arr.size();\n        vector<bool> prev(sum + 1, false), curr(sum + 1);\n    \n        // Mark prev[0] = true as it is true\n          // to make sum = 0 using 0 elements\n        prev[0] = true;\n    \n        // Fill the subset table in\n          // bottom up manner\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= sum; j++) {\n                if (j < arr[i - 1])\n                    curr[j] = prev[j];\n                else\n                    curr[j] = (prev[j] || prev[j - arr[i - 1]]);\n            }\n            prev = curr;\n        }\n        return prev[sum];\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        \n        int l = 0, r = queries.size();\n        r++;\n        \n        int n = nums.size();\n        \n        while(l < r){\n            \n            int mid = (l + r) / 2;\n            vector <int> sum(n);\n            \n            vector <vector<int>> opt(n);\n            \n            for(int i = 0; i < mid; i++){\n                int val = queries[i][2];\n                for(int x = queries[i][0]; x <= queries[i][1]; x++){\n                    sum[x] += val;\n                    \n                    opt[x].push_back(val);\n                }\n            }\n            \n            bool pos = true;\n            \n            for(int i = 0; i < n; i++){\n                if(sum[i] < nums[i])pos = false;\n            }\n            \n            if(pos){\n                for(int i = 0; i < n; i++){\n                    pos &= isSubsetSum(opt[i], nums[i]);\n                }\n            }\n            \n            if(pos)r = mid;\n            else{\n                l = mid + 1;\n            }\n        }\n\n        if(l == queries.size() + 1)l = -1;\n        \n        return l;\n        \n        \n    }\n};","author":"Vishal Kumar","submissionId":"1575235277"},[]]},{"1536":[{"id":"1536","fileName":"1575235704.txt","sourceCode":"#define ll long long\nclass Solution {\npublic:\n\tvector<vector<int>>dp;\n\tll solve(int i, int sum, vector<int>&temp){\n\t\tint n = temp.size();\n\t\tif(!sum) return i;\n\t\tif(i == n && sum) return 1e9;\n\t\tif(dp[i][sum] != -1) return dp[i][sum];\n\t\tll ans = 1e9;\n\t\tif(sum >= temp[i]) ans = solve(i+1, sum-temp[i], temp);\n\t\tans = min(ans, solve(i+1, sum, temp));\n\t\treturn dp[i][sum] = ans;\n\t}\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        vector<vector<int>>g(n,vector<int>(q,0));\n        for(int i = 0; i < q; i++){\n        \tint l = queries[i][0];\n        \tint r = queries[i][1];\n        \tint x = queries[i][2];\n        \tfor(int j = l; j <= r; j++){\n        \t\tg[j][i] = x;\n        \t}\n        }\n        int ans = -1;\n        for(int i = 0; i < n; i++){\n            //dp.clear();\n        \tdp = vector<vector<int>>();\n        \tdp.resize(q+1, vector<int>(nums[i]+1, -1));\n        \tvector<int>&temp = g[i];\n           // cout << temp.size() << \" \";\n            int check = solve(0,nums[i],temp);\n           // cout << check << \" \";\n        \tif(check == 1e9) return -1;\n        \tans = max(ans,check);\n        }\n        if(ans == -1) return 1;\n        return ans;\n    }\n};","author":"tarunkumarbasera","submissionId":"1575235704"},[]]},{"1537":[{"id":"1537","fileName":"1575235290.txt","sourceCode":"class Solution {\npublic:\n    vector<vector<int>> dp;\n\n    bool solve(int target, int idx, vector<vector<int>> &que, int q, int k) {\n        if (target == 0) return true;\n        if (q >= que.size() || q > k) return false;\n\n        if (dp[target][q] != -1) return dp[target][q];\n\n        bool notPick = solve(target, idx, que, q + 1, k);\n        bool pick = false;\n        if (que[q][0] <= idx && que[q][1] >= idx && que[q][2] <= target) {\n            pick = solve(target - que[q][2], idx, que, q + 1, k);\n        }\n\n        return dp[target][q] = pick || notPick;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int maxNum = *max_element(nums.begin(), nums.end());\n        int n = nums.size(), m = queries.size();\n\n        int low = 0, high = m, ans = -1;\n\n        auto isPoss = [&](int k) {\n            for (int i = 0; i < n; ++i) {\n                if (nums[i] == 0) continue;\n                dp.assign(maxNum + 1, vector<int>(m + 1, -1));\n                if (!solve(nums[i], i, queries, 0, k)) return false;\n            }\n            return true;\n        };\n\n        if (all_of(nums.begin(), nums.end(), [](int num) { return num == 0; })) return 0;\n\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (isPoss(mid)) {\n                ans = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        if (ans == -1) return -1;\n        return ans + 1;\n    }\n};\n","author":"Abhinav Yaduvanshi","submissionId":"1575235290"},[]]},{"1539":[{"id":"1539","fileName":"1575235281.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        if(!isKPossible(nums, queries, queries.length))\n            return -1;\n        int left = 0, right = queries.length;\n        while(left<right){\n            int mid = (left+right)/2;\n            if(isKPossible(nums, queries, mid))\n                right = mid;\n            else\n                left = mid+1;\n        }\n        return left;\n    }\n    private boolean isKPossible(int[] nums,int[][] queries, int k){\n        ArrayList<Integer>[] list = (ArrayList<Integer>[]) new ArrayList[nums.length];\n        for(int i=0;i<nums.length;i++)\n            list[i] = new ArrayList<>();\n        for(int i=0;i<k;i++){\n            applyQuery(list, queries[i]);\n        }\n        boolean flag = true;\n        for(int i=0;i<nums.length;i++){\n            if(!sumPossibleDP(list[i],nums[i])){\n                flag = false;\n                break;\n            }\n        }\n        return flag;\n    }\n    private boolean sumPossibleDP(ArrayList<Integer> list, int target) {\n        if (target == 0) return true;\n        if (list.isEmpty()) return false;\n\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true; \n\n        for (int num : list) {\n            for (int j = target; j >= num; j--) {\n                dp[j] |= dp[j - num];\n            }\n        }\n        return dp[target];\n    }\n    private void applyQuery(ArrayList<Integer>[] list,int[] query){\n        for(int i=query[0];i<=query[1];i++){\n            list[i].add(query[2]);\n        }\n    }\n}","author":"mundadamarmik","submissionId":"1575235281"},[]]},{"1540":[{"id":"1540","fileName":"1575236030.txt","sourceCode":"class Solution {\nprivate:\n    bool checker(const vector<int>& nums, const vector<bitset<1001>>& dp) {\n        for (int i = 0; i < nums.size(); i++) {\n            if (!dp[i].test(nums[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\npublic:    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<bitset<1001>> dp(n, bitset<1001>().set(0));\n    \n        int nofz = count(nums.begin(), nums.end(), 0);\n        if (nofz == n) return 0;\n    \n        for (int i = 0; i < queries.size(); i++) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n    \n            for (int j = l; j <= r; j++) {\n                dp[j] |= (dp[j] << val);\n                for (int pos = nums[j] + 1; pos < 1001; pos++)\n                    dp[j].reset(pos);\n            }\n    \n            if (checker(nums, dp)) return i + 1;\n        }\n        return -1;\n    }\n};","author":"Soorya Kumar S","submissionId":"1575236030"},[]]},{"1541":[{"id":"1541","fileName":"1575235959.txt","sourceCode":"class Solution:\n  def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n    m = max(nums)\n    n = len(queries)\n    dp = [[j == 0 for j in range(nums[i] + 1)] for i in range(len(nums))]\n    cnt = 0\n    # print(dp)\n    for i, num in enumerate(nums):\n      while not dp[i][num] and cnt < n:\n        l, r, v = queries[cnt]\n        cnt += 1\n        for j in range(max(l, i), r + 1):\n          for k in reversed(range(nums[j] + 1 - v)):\n            dp[j][k + v] = dp[j][k + v] or dp[j][k]\n      if not dp[i][num]:\n        return -1\n      # print(i, num, j, dp)\n      # print(dp)\n    return cnt\n","author":"LeeetCode","submissionId":"1575235959"},[]]},{"1542":[{"id":"1542","fileName":"1575235894.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n\n        # bitmask\n        def is_feasible(k):\n            for i in range(n):\n                dp = 1 \n                for l, r, val in queries[:k]:\n                    if l <= i <= r:\n                        dp |= dp << val\n                        dp &= (1 << (nums[i] + 1)) - 1\n                if not (dp >> nums[i]) & 1:\n                    return False\n            return True\n    \n        s, e = 0, m\n        ans = -1\n        while s <= e:\n            mid = (s + e) // 2\n            if is_feasible(mid):\n                ans = mid\n                e = mid - 1\n            else:\n                s = mid + 1\n        return ans","author":"dreambig29","submissionId":"1575235894"},[]]},{"1543":[{"id":"1543","fileName":"1575236071.txt","sourceCode":"class Solution {\npublic:\n    int func(vector<pair<int,int>>& operations, int target) {\n        // Initialize dp array - each element represents min operations to reach that value\n        vector<int> dp(target + 1, INT_MAX);\n        dp[target] = 0;  // Base case: no operations needed if starting at target\n        \n        // Process each operation\n        for(int i = 0; i < operations.size(); i++) {\n            int val = operations[i].first;   // Value to subtract\n            int opIdx = operations[i].second; // Operation index\n            \n            // Update dp array from right to left to avoid reusing the same operation\n            for(int j = 0; j <= target; j++) {\n                if(dp[j] == INT_MAX) continue; // Skip unreachable states\n                \n                // After applying operation, we get j - val\n                int nextVal = j - val;\n                if(nextVal >= 0) {\n                    dp[nextVal] = min(dp[nextVal], max(dp[j], opIdx));\n                }\n            }\n        }\n        \n        return dp[0] == INT_MAX ? -1 : dp[0];\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int answer = 0;\n        \n        // Build operation maps for each index\n        unordered_map<int, vector<pair<int,int>>> indexToOperations;\n        for(int i = 0; i < queries.size(); i++) {\n            int left = queries[i][0];\n            int right = queries[i][1];\n            int value = queries[i][2];\n            \n            for(int j = left; j <= right; j++) {\n                indexToOperations[j].push_back({value, i + 1});\n            }\n        }\n        \n        // For each array element, find minimum set of operations to make it zero or negative\n        for(int i = 0; i < n; i++) {\n            // If value is already non-positive, no operations needed\n            if(nums[i] <= 0) continue;\n            \n            int result = func(indexToOperations[i], nums[i]);\n            if(result == -1) return -1; // If any element can't be made non-positive\n            answer = max(answer, result);\n        }\n        \n        return answer;\n    }\n};","author":"Naitik Raj","submissionId":"1575236071"},[]]},{"1544":[{"id":"1544","fileName":"1575236325.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        if all(x == 0 for x in nums):\n            return 0\n\n        dp = [set() for _ in range(n)]\n        for j in range(n):\n            dp[j].add(0)  \n\n        for k, (I, r, v) in enumerate(queries):\n            for j in range(I, r + 1): \n                dp[j] |= {x + v for x in dp[j]} \n\n            if all(nums[j] in dp[j] for j in range(n)):\n                return k + 1\n\n        return -1","author":"tajiyashaikh30","submissionId":"1575236325"},[]]},{"1545":[{"id":"1545","fileName":"1575236283.txt","sourceCode":"class Solution {\npublic:\n    bool canZeroArray(vector<int>& nums, vector<vector<int>>& queries, int k) {\n        int n = nums.size();\n\n        for (int i = 0; i < n; i++) {\n            \n            vector<int> available;\n            for (int j = 0; j < k; j++) {\n                int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                if (l <= i && i <= r) {\n                    available.push_back(val);\n                }\n            }\n            \n            int target = nums[i];\n            \n            vector<bool> dp(target + 1, false);\n            dp[0] = true;\n            for (int v : available) {\n                for (int s = target; s >= v; s--) {\n                    dp[s] = dp[s] || dp[s - v];\n                }\n            }\n            if (!dp[target]) {\n                return false; \n            }\n        }\n        return true; \n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int low = 0, high = queries.size();\n        int ans = -1;\n        // Binary search for the minimum k for which we can get a zero array.\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (canZeroArray(nums, queries, mid)) {\n                ans = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"Electode","submissionId":"1575236283"},[]]},{"1546":[{"id":"1546","fileName":"1575236212.txt","sourceCode":"from bisect import bisect_left\nfrom bisect import bisect_right\nfrom itertools import combinations\n\nclass Solution:\n    def binary_search(self, arr, target):\n        low = 0\n        high = len(arr) - 1\n\n        while low <= high:\n            mid = (low + high) // 2\n\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n\n        return -1\n\n    # def earliest_ending_subsequence(self, nums, target):\n    #     n = len(nums)\n    #     prefix_sums = {}\n\n    #     for size in range(1, n + 1):\n    #         for indices in combinations(range(n), size):\n    #             subseq_sum = sum(nums[i] for i in indices)\n    #             if subseq_sum == target:\n    #                 last_idx = indices[-1]\n    #                 if subseq_sum not in prefix_sums or last_idx < prefix_sums[subseq_sum]:\n    #                     prefix_sums[subseq_sum] = last_idx\n\n    #     return prefix_sums.get(target, -1)\n\n    def earliest_ending_subsequence(self, nums, target):\n        n = len(nums)\n        dp = {0: 0}\n        \n        for i in range(n):\n            current_dp = dp.copy()\n            \n            for prev_sum, prev_last_index in dp.items():\n                current_sum = prev_sum + nums[i]\n                \n                if current_sum not in current_dp or i < current_dp[current_sum]:\n                    current_dp[current_sum] = i\n                    \n            dp = current_dp\n        \n        if target in dp:\n            return dp[target]\n        else:\n            return -1\n\n    \n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        N = len(nums)\n        dick = {i: [0] for i in range(N)}\n\n        for l, r, val in queries:\n            q = set(i for i in range(l, r + 1))\n\n            for i in range(N):\n                if i in q:\n                    dick[i].append(val)\n                else:\n                    dick[i].append(0)\n\n        if any(self.earliest_ending_subsequence(dick[i], num) == -1 for i, num in enumerate(nums)):\n            return -1\n\n        return max(self.earliest_ending_subsequence(dick[i], num) for i, num in enumerate(nums))\n","author":"moodyartist28","submissionId":"1575236212"},[]]},{"1547":[{"id":"1547","fileName":"1575236269.txt","sourceCode":"class Solution {\n    int int_max = Integer.MAX_VALUE;\n    public int minZeroArray(int[] nums, int[][] q) {\n        // limit -> 0 to N\n        List<List<int[]>> list = new ArrayList<>();\n        for(int i=0;i<nums.length;i++) list.add(new ArrayList<>());\n\n        for(int i=0;i<q.length;i++){\n            int s = q[i][0], e = q[i][1], w = q[i][2];\n            for(int j=s;j<=e;j++) list.get(j).add(new int[]{w,i+1});\n        }\n        int result = -1;\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==0){\n                result = Math.max(result,0);\n                continue;\n            }\n            intialize(list.get(i).size(), nums[i]+1);\n            int minK = rec(0,nums[i],list.get(i));\n            //System.out.printf(\"mink=%d i=%dn\",minK,i);\n            if(minK == int_max) return -1;\n            result = Math.max(result,minK);\n        }\n        return result;\n        \n        \n    }\n    int[][] mem;\n    void intialize(int len,int num){\n        mem = new int[len][num];\n        for(int i=0;i<len;i++)\n            Arrays.fill(mem[i],-1);\n    }\n    int rec(int i,int num,List<int[]> list){\n        if(i==list.size()){\n            return int_max;\n        }\n        if(mem[i][num]!=-1){\n            return mem[i][num];\n        }\n        //pick\n        int pick = int_max;\n        if(num >= list.get(i)[0]){\n            if(num == list.get(i)[0]){\n                pick = list.get(i)[1];\n            }\n            else{\n                pick = rec(i+1, num-list.get(i)[0],list);\n            }\n        }\n        // not pick\n        int notPick = rec(i+1,num,list);\n        int result = Math.min(pick,notPick);\n        //System.out.printf(\"i=%d nuum=%d list=%s res=%dn\",i,num,list,result);\n        return mem[i][num] = result;\n    }\n    \n    \n}","author":"BALAMURUGAN_K","submissionId":"1575236269"},[]]},{"1548":[{"id":"1548","fileName":"1575236439.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int mn = *min_element(nums.begin(), nums.end());\n        int mx = *max_element(nums.begin(), nums.end());\n        if(mn == mx && mn == 0) return 0;\n        int q = queries.size();\n        function<int(int)> solve = [&](int i) {\n            vector<bool> dp(nums[i] + 1);\n            dp[0] = true;\n            for(int j = 0; j < q; j++) {\n                if(queries[j][0] <= i && i <= queries[j][1]) {\n                    for(int v = nums[i]; v >= queries[j][2]; v--) {\n                        dp[v] = dp[v] || dp[v - queries[j][2]];\n                    }\n                    if(dp[nums[i]]) return j + 1;\n                }\n            }\n            return 0x3f3f3f3f;\n        };\n        int ans = 0;\n        for(int i = 0; i < n; i++) {\n            ans = max(solve(i), ans);\n        }\n        return ans > q? -1: ans;\n    }\n};","author":"pein531","submissionId":"1575236439"},[]]},{"1549":[{"id":"1549","fileName":"1575236514.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int m = nums.size();\n        bool ok = true;\n        for (int i = 0; i < m; i++) {\n            if (nums[i] != 0) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) {\n            return 0;\n        }\n\n        int n = queries.size();\n        int mx = -1;\n        for (int i = 0; i < m; i++) {\n            int num = nums[i];\n            if (num == 0) continue;\n            \n            vector<bool>L(1001, false);\n            int cur = -1;\n            L[num] = true;\n            for (int j = 0; j < n; j++) {\n                if (i < queries[j][0] || i > queries[j][1]) continue;\n                if (L[queries[j][2]]) {\n                    cur = max(cur, j + 1);\n                    break;\n                }\n                for (int k = queries[j][2] + 1; k <= 1000; k++) {\n                    if (L[k]) {\n                        L[k - queries[j][2]] = true;\n                    }\n                }\n            }\n            if (cur == -1) {\n                return -1;\n            } \n            mx = max(mx, cur);\n        }\n        \n        return mx != -1 ? mx : -1;\n    }\n};","author":"Trần Văn Thành","submissionId":"1575236514"},[]]},{"1550":[{"id":"1550","fileName":"1575236329.txt","sourceCode":"class Solution {\npublic:\n    int help(vector<int>&nums,int id,vector<vector<int>>& queries){\n        int n = nums[id];\n        int q = queries.size();\n        // vector<vector<int>>dp(q,vector<int>(n+1,-1));\n        vector<int>val;\n        for(int i = 0 ; i < q ; i++){\n            int l = queries[i][0];\n            int h = queries[i][1];\n            int v = queries[i][2];\n            if(id>=l && id<=h){\n                val.push_back(v);\n            }\n            else{\n                val.push_back(0);\n            }\n        }\n        // for(int i : val){\n        //     cout<<i<<\" \";\n        // }\n        // cout<<endl;\n        unordered_set<int>dp;\n        dp.insert(0);\n        for(int i = 0 ; i < val.size() ; i++){\n            unordered_set<int>newDp(dp);\n            for(int j : dp){\n                newDp.insert(j+val[i]);\n            }\n            dp = newDp;\n            if(dp.find(nums[id])!=dp.end()){\n                // cout<<i<<endl;\n                return i;\n            }\n        }\n        // cout<<(-1)<<endl;\n        return -1;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int>res(n);\n        for(int i = 0 ; i < n ; i++){\n            if(nums[i]==0){\n                res[i] = 0;\n                continue;\n            }\n            int x = help(nums,i,queries);\n            \n            if(x==-1){\n                return -1;\n            }\n\n            res[i] = x+1;\n        }\n        return *max_element(res.begin(),res.end());\n    }\n};","author":"Narasimha","submissionId":"1575236329"},[]]},{"1551":[{"id":"1551","fileName":"1575236404.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& targets, vector<vector<int>>& ops) {\n        int len = targets.size(), totalOps = ops.size();\n        vector<vector<bool>> dp(len);\n        for (int i = 0; i < len; ++i) {\n            dp[i].resize(targets[i] + 1, false);\n            dp[i][0] = true;\n        }\n        \n        bool alreadyZero = true;\n        for (int i = 0; i < len; ++i)\n            if (!dp[i][targets[i]])\n                alreadyZero = false;\n        if (alreadyZero)\n            return 0;\n        \n        for (int op = 0; op < totalOps; op++) {\n            int L = ops[op][0], R = ops[op][1], dec = ops[op][2];\n            for (int idx = L; idx <= R; idx++)\n                for (int s = targets[idx]; s >= dec; s--)\n                    if (dp[idx][s - dec])\n                        dp[idx][s] = true;\n            bool allReached = true;\n            for (int i = 0; i < len; i++)\n                if (!dp[i][targets[i]])\n                    allReached = false;\n            if (allReached)\n                return op + 1;\n        }\n        return -1;\n    }\n};\n","author":"wckiipi","submissionId":"1575236404"},[]]},{"1552":[{"id":"1552","fileName":"1575236650.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size();\n        vector<bitset<1001>> dp(n, bitset<1001>().set(0));\n\n        if (all_of(a.begin(), a.end(), [](int x) { return x == 0; })) return 0;\n\n        for (int k = 0; k < q.size(); k++) {\n            applyOp(dp, a, q[k][0], q[k][1], q[k][2]);\n            if (checkAll(dp, a)) return k + 1;\n        }\n        return -1;\n    }\n\nprivate:\n    void applyOp(vector<bitset<1001>>& dp, vector<int>& a, int l, int r, int v) {\n        for (int j = l; j <= r; j++) {\n            bitset<1001> s;\n            for (int i = 0; i < 1001 - v; i++) if (dp[j][i]) s.set(i + v);\n            dp[j] |= s;\n            for (int p = a[j] + 1; p < 1001; p++) dp[j].reset(p);\n        }\n    }\n\n    bool checkAll(vector<bitset<1001>>& dp, vector<int>& a) {\n        for (int j = 0; j < a.size(); j++) if (!dp[j][a[j]]) return false;\n        return true;\n    }\n};\n","author":"navneetpathak35","submissionId":"1575236650"},[]]},{"1553":[{"id":"1553","fileName":"1575236759.txt","sourceCode":"class Solution {\npublic:\nint dp[1001][1001];\nint pos(int i, int n ,vector<int>&num,map<pair<int,int>,int>&dp){\n    \n    if(n==0)return 1;\n    if(i==num.size())return 0;\n    if(n<0)return 0;\n    if(dp.find({i,n})!=dp.end())return dp[{i,n}];\n    return dp[{i,n}]= pos(i+1,n-num[i],num,dp)||pos(i+1,n,num,dp);\n    \n}\nbool check(int idx,vector<int> nums, vector<vector<int>>& q ){\n    int n=nums.size();\n    vector<vector<int>>v(n);\n    for(int i=0;i<=idx;i++){\n        for(int j=q[i][0];j<=q[i][1];j++)\n            v[j].push_back(q[i][2]);\n    }\n    for(int i=0;i<n;i++){\nmap<pair<int,int>,int>dp;\n        if(!pos(0,nums[i],v[i],dp))return 0;\n        \n    }\nreturn 1;\n    \n\n\n}\nbool allzero(vector<int>&nums){\n    for(auto i:nums)if(i)return 0;\n    return 1;\n}\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        if(allzero(nums))return 0;\n        int q=queries.size();\n        int lo=0,hi=q-1;\n        int ans=-1;\n        while(lo<=hi){\n            int mid=(lo+hi)/2;\n            int res=check(mid,nums,queries);\n            // cout<<mid<<\" \"<<res<<endl;\n            if(res){\n                ans=mid+1;\n                hi=mid-1;\n\n            }\n            else {\n                lo=mid+1;\n            }\n        }\n       return ans;\n      \n    }\n};","author":"Ayush","submissionId":"1575236759"},[]]},{"1554":[{"id":"1554","fileName":"1575236618.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int m=queries.size(),n=nums.size();\n        int l=0,h=m+1,ans=-1;\n        \n        while(l<h){\n            int mid=l+(h-l)/2;\n            bool ok=true;\n            \n            for(int j=0;j<n;j++){\n                if(nums[j]==0) continue;\n                vector<int> v;\n                for(int i=0;i<mid;i++){\n                    int l=queries[i][0],r=queries[i][1],k=queries[i][2];\n                    if(l<=j and j<=r) v.push_back(k);\n                }\n                if(v.empty()){ \n                    ok=false;\n                    break; \n                }\n                \n                sort(v.begin(),v.end());\n                unordered_map<long long,bool> dp;\n                \n                function<bool(int, int)> rec = [&](int idx,int target)->bool{\n                    if(target==0) return true;\n                    if(idx>=v.size()) return false;\n                    long long key=((long long)idx<<32)|(target);\n                    if (dp.find(key)!=dp.end()) return dp[key];\n                    bool res=rec(idx+1,target);\n                    if(!res and v[idx]<=target)\n                        res=rec(idx+1,target-v[idx]);\n                    dp[key]=res;\n                    return res;\n                };\n                \n                if(!rec(0,nums[j])){\n                    ok=false;\n                    break;\n                }\n            }\n            if(ok){\n                ans=mid;\n                h=mid;\n            }else{\n                l=mid+1;\n            }\n        }\n        if(ans>m)  return -1;\n        return ans;\n    }\n};","author":"mayankmanik_32","submissionId":"1575236618"},[]]},{"1555":[{"id":"1555","fileName":"1575236644.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<unordered_set<int>> oldSum(size(nums));\n        for(auto&oS:oldSum) oS.insert(0);\n        int cntZ=0;\n        for(int&n:nums) if(n==0) cntZ++;\n        if(cntZ==size(nums)) return 0;\n        for(int cur=0; cur<size(queries); cur++){\n            auto q=queries[cur];\n            for(int i=q[0]; i<=q[1]; i++){\n                auto temp=oldSum[i];\n                for(const int&old:temp) oldSum[i].insert(old+q[2]);\n            }\n            int i=0;\n            for(; i<size(nums); i++){\n                if(!oldSum[i].contains(nums[i])) break;\n            }\n            if(i==size(nums)) return cur+1;\n        }\n        return -1;\n    }\n};","author":"dktoan03","submissionId":"1575236644"},[]]},{"1556":[{"id":"1556","fileName":"1575236865.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int l = -1, r = queries.length + 1;\n        while (r - l > 1) {\n            int mid = l + (r - l) / 2;\n            if (check(nums, queries, mid)) {\n                r = mid;\n            } else {\n                l = mid;\n            }\n        }\n        return r == queries.length + 1 ? -1 : r;\n    }\n\n    private boolean check(int[] nums, int[][] queries, int k) {\n        int n = nums.length;\n        List<Integer>[] ids = new List[n];\n        Arrays.setAll(ids, o -> new ArrayList<>());\n        for (int i = 0; i < k; i++) {\n            int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                ids[j].add(v);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            List<Integer> vs = ids[i];\n            int num = nums[i];\n            boolean[] dp = new boolean[num + 1];\n            dp[0] = true;\n            for (int v : vs) {\n                for (int j = num; j >= v; j--) {\n                    dp[j] |= dp[j - v];\n                }\n                if (dp[num]) break;\n            }\n            if (!dp[num]) return false;\n        }\n        return true;\n    }\n}","author":"iris1230xs","submissionId":"1575236865"},[]]},{"1557":[{"id":"1557","fileName":"1575236894.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        boolean alreadyZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                alreadyZero = false;\n                break;\n            }\n        }\n        if (alreadyZero)\n            return 0;\n\n        int m = queries.length;\n        int low = 1, high = m + 1;\n        int answer = -1;\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            if (canZero(nums, queries, mid)) {\n                answer = mid;\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return answer;\n    }\n\n    private boolean canZero(int[] nums, int[][] queries, int k) {\n        int n = nums.length;\n        for (int j = 0; j < n; j++) {\n            int target = nums[j];\n            List<Integer> available = new ArrayList<>();\n            for (int i = 0; i < k; i++) {\n                int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n                if (j >= l && j <= r) {\n                    available.add(val);\n                }\n            }\n            if (!canSum(available, target)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean canSum(List<Integer> vals, int target) {\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n        for (int v : vals) {\n            for (int s = target; s >= 0; s--) {\n                if (dp[s] && s + v <= target) {\n                    dp[s + v] = true;\n                }\n            }\n        }\n        return dp[target];\n    }\n}","author":"Rifqi Fatchurrahman","submissionId":"1575236894"},[]]},{"1558":[{"id":"1558","fileName":"1575236764.txt","sourceCode":"   \nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        done = True\n        for i in nums:\n            if i != 0:\n                done = False\n        if done:\n            return 0\n        \n        n = len(nums)\n        reachable = [[False]*i for i in nums]\n        for i in range(len(reachable)):\n            reachable[i].append(True)\n        \n        for index, x in enumerate(queries):\n            l,r,v = x\n            for i in range(l,r+1):\n                if reachable[i][0] == True:\n                    continue\n                for j in range(v, len(reachable[i])):\n                    if reachable[i][j]:\n                        reachable[i][j-v]=True\n\n            done=True\n            for i in reachable:\n                if i[0] == False:\n                    done=False\n                    break\n            if done:\n                return index+1\n                \n        return -1","author":"deasoliser","submissionId":"1575236764"},[]]},{"1559":[{"id":"1559","fileName":"1575236810.txt","sourceCode":"class Solution {\n    bool chk(int sum, vector<vector<int>>& toPut, int index, vector<vector<int>>& dp, int val){\n        if(sum == 0)return true;\n        if(sum < 0)return false;\n        if(index >= toPut[val].size())return false;\n        // cout << sum << \" \" << index << toPut[val].size() << dp.size() << \" \" << dp[index].size() << endl;\n        if(dp[index][sum] != -1) return dp[index][sum];\n        bool vk = chk(sum-toPut[val][index], toPut, index+1, dp, val);\n        if(vk)return dp[index][sum] = true;\n        bool val2 = chk(sum, toPut, index+1, dp, val);\n        return dp[index][sum] = val2;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int low = 0, high = queries.size(), ans = -1;\n        int size = nums.size();\n        while(low <= high){\n            int mid = low + (high - low) / 2;\n            \n            vector<vector<int>> toPut(size);\n            for(int i = 0; i < mid; i++){\n                for(int j = queries[i][0]; j <= queries[i][1]; j++){\n                    toPut[j].push_back(queries[i][2]);\n                }\n            }\n            bool val = true;\n            for(int i = 0; i < size; i++){\n                vector<vector<int>> dp(toPut[i].size(), vector<int>(nums[i]+10, -1));\n                bool cv = chk(nums[i], toPut, 0, dp, i);\n                if(!cv){\n                    val = false;\n                    break;\n                }\n            }\n            if(val){\n                ans = mid, high = mid-1;\n            }\n            \n            else low = mid+1;\n        }\n        return ans;\n    }\n};","author":"Renuka sinha","submissionId":"1575236810"},[]]},{"1560":[{"id":"1560","fileName":"1575236934.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        int ans = 0;\n        for(int ind = 0 ; ind < n ; ind++ ) {\n            vector<int> q(m, 0);\n            for(int j = 0 ; j < m ; j++ ) {\n                if(ind>=queries[j][0] && ind<=queries[j][1])\n                    q[j] = queries[j][2];\n            }\n            if(nums[ind] == 0) continue;\n            vector<vector<bool>> dp(nums[ind]+1, vector<bool>(m, false));\n            if(q[0]<=nums[ind]) dp[q[0]][0] = true;\n            for(int i = 0 ; i < m ; i++ ) dp[0][i] = true;\n            for(int i = 1 ; i < m ; i++ ) {\n                for(int j = 1 ; j <= nums[ind] ; j ++ ) {\n                    dp[j][i] = dp[j][i-1];\n                    if(j-q[i] >= 0) dp[j][i] = dp[j][i] || dp[j-q[i]][i-1];\n                }\n            }\n            int minInd = -1;\n            for(int i = 0 ; i < m ; i++ ) {\n                if(dp[nums[ind]][i]){\n                    minInd = i+1;\n                    break;\n                }\n            }\n            if(minInd >= 0)\n                ans = max(ans, minInd);\n            else return -1;\n        }\n        \n        return ans;\n    }\n};","author":"uj007","submissionId":"1575236934"},[]]},{"1562":[{"id":"1562","fileName":"1575236990.txt","sourceCode":"class Solution {\npublic:\n    bool canMakeZero(vector<int>& nums, vector<vector<int>>& queries, int k) {\n        int n = nums.size();\n        vector<vector<int>> validVals(n);\n\n        // Collect valid decrements for each index in nums\n        for (int q = 0; q < k; q++) {\n            int l = queries[q][0], r = queries[q][1], val = queries[q][2];\n            for (int i = l; i <= r; i++) {\n                validVals[i].push_back(val);\n            }\n        }\n\n        // Check if each nums[i] can be reduced to zero using subset sum\n        for (int i = 0; i < n; i++) {\n            if (nums[i] > 0 && !subsetSum(validVals[i], nums[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool subsetSum(vector<int>& values, int target) {\n        if (target == 0) return true;\n        if (values.empty()) return false;\n\n        int m = values.size();\n        vector<bool> dp(target + 1, false);\n        dp[0] = true; // Base case: sum of 0 is always achievable\n\n        for (int val : values) {\n            for (int j = target; j >= val; j--) {\n                dp[j] = dp[j] || dp[j - val];\n            }\n        }\n        return dp[target];\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        // Edge case: If nums is already zero\n        if (all_of(nums.begin(), nums.end(), [](int x) { return x == 0; })) {\n            return 0;\n        }\n\n        int left = 1, right = queries.size(), ans = -1;\n\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (canMakeZero(nums, queries, mid)) {\n                ans = mid;\n                right = mid - 1; // Try for a smaller k\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"nishant6789","submissionId":"1575236990"},[]]},{"1563":[{"id":"1563","fileName":"1575237162.txt","sourceCode":"class Solution { \n    public int minZeroArray(int[] nums, int[][] queries) {\n        // -2 -3 3 2 -> -2 -5 -2 0\n        // -1 -2 0 1 -2 -> -1 -3 -3 -2 -4\n        int left = 0, right = queries.length;\n        while (left + 1 < right) {\n            int mid = left + (right - left) / 2;\n            if (canMakeAllZero(nums, queries, mid)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        // System.out.println(\"left is \" + left + \", right is \" + right);\n        if (canMakeAllZero(nums, queries, left)) {\n            return left;\n        }\n        if (canMakeAllZero(nums, queries, right)) {\n            return right;\n        }\n        return -1;\n    }\n\n    // private boolean canMakeAllZero(int[] nums, int[][] queries, int k) {\n    //     int[] diff = new int[nums.length + 1];\n    //     for (int i = 0; i < k; i++) {\n    //         int[] query = queries[i];\n    //         diff[query[0]] -= query[2];\n    //         diff[query[1] + 1] += query[2];\n    //     }\n\n    //     for (int i = 0; i < nums.length; i++) {\n    //         if (i > 0) {\n    //             diff[i] += diff[i - 1];\n    //         }\n    //         if (nums[i] + diff[i] > 0) {\n    //             return false;\n    //         }\n    //     }\n    //     return true;\n    // }\n    \n    private boolean canMakeAllZero(int[] nums, int[][] queries, int k) {\n        int n = nums.length;\n        List<List<Integer>> diffs = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            diffs.add(new ArrayList<>());\n        }\n        for (int i = 0; i < k; i++) {\n            int[] query = queries[i];\n            int leftIdx = query[0], rightIdx = query[1], d = query[2];\n            for (int j = leftIdx; j <= rightIdx; j++) {\n                diffs.get(j).add(d);\n            }\n        }\n\n        for (int i = 0; i < nums.length; i++) {\n            int num = nums[i];\n            if (num == 0) {\n                continue;\n            }\n            List<Integer> diff = diffs.get(i);\n            // System.out.println(diff);\n            // check if the sum of subsequence in diff arr can make up to num\n            Boolean[][] memo = new Boolean[diff.size()][num + 1];\n            if (!helper(diff, num, 0, 0, memo)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean helper(List<Integer> arr, int sum, int idx, int curSum, Boolean[][] memo) {\n        if (curSum == sum) {\n            return true;\n        }\n        if (curSum > sum) {\n            return false;\n        }\n        if (idx == arr.size()) {\n            return curSum == sum;\n        }\n        if (memo[idx][curSum] != null) {\n            return memo[idx][curSum];\n        }\n        boolean res = false;\n        // skip the current idx\n        res |= helper(arr, sum, idx + 1, curSum, memo);\n        // use the current idx\n        res |= helper(arr, sum, idx + 1, curSum + arr.get(idx), memo);\n        return memo[idx][curSum] = res;\n    }\n}","author":"puffycheeks","submissionId":"1575237162"},[]]},{"1564":[{"id":"1564","fileName":"1575237205.txt","sourceCode":"class Solution {\nprivate:\n    bool f(int idx, int target, vector<vector<int>>& dp, vector<int>& arr) {\n        // BASE CASE\n        if (target == 0)\n            return true;\n        if (idx == 0) {\n            if (target == arr[idx])\n                return true;\n            else\n                return false;\n        }\n        if (dp[idx][target] != -1)\n            return dp[idx][target];\n        bool not_pick = f(idx - 1, target, dp, arr);\n        bool pick = false;\n        if (arr[idx] <= target) {\n            pick = f(idx - 1, target - arr[idx], dp,arr);\n        }\n        return dp[idx][target] = pick || not_pick;\n    }\n\n    bool check(vector<int>& nums, vector<vector<int>>& queries, int k) {\n        int n = nums.size(), q = queries.size();\n        for (int i = 0; i < n; i++) {\n            if(nums[i]==0) continue;\n            int ele = nums[i];\n            vector<int> arr;\n            for (int j = 0; j < k; j++) {\n                int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                if (i >= l && i <= r) {\n                    arr.push_back(queries[j][2]);\n                }\n            }\n            if(arr.size()==0 && nums[i]!=0) return false;\n            vector<vector<int>> dp(arr.size(), vector<int>(1001, -1));\n            if (!(f(arr.size() - 1, ele, dp, arr))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int low = 0, high = queries.size(), k = -1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (check(nums, queries, mid)) {\n                k = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return k;\n    }\n};","author":"Divye Maloo","submissionId":"1575237205"},[]]},{"1565":[{"id":"1565","fileName":"1575237194.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        boolean flag = true;\n        for(int i=0;i<nums.length;i++){\n            if(nums[i] != 0){\n                flag = false;\n                break;\n            }\n        }\n        \n        if(flag == true){\n            return 0;\n        }\n        \n        Map<Integer, List<Integer>> hash = new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            hash.put(i, new ArrayList<>());\n        }\n        \n        int count = 0;\n        for(int[] query : queries){\n            int l = query[0];\n            int r = query[1];\n            int val = query[2];\n            \n            for(int i=l;i<=r;i++){\n                List<Integer> list = hash.get(i);\n                list.add(val);\n                \n                hash.put(i, list);\n            }\n            \n            if(isPossible(nums, hash)){\n                return count + 1;\n            }\n            \n            count++;\n        }\n        \n        return -1;\n    }\n    \n    public boolean isPossible(int[] nums, Map<Integer, List<Integer>> hash){\n        for(int i=0;i<nums.length;i++){\n            int[][] dp = new int[hash.get(i).size() + 1][nums[i] + 1];\n            for(int j=0;j<hash.get(i).size()+1;j++){\n                Arrays.fill(dp[j], -1);\n            }\n            \n            if(targetSum(hash.get(i), nums[i], 0, dp) == false){\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    public boolean targetSum(List<Integer> list, int target, int idx, int[][] dp){\n        if(target == 0){\n            return true;\n        }\n        \n        if(idx == list.size()){\n            return false;\n        }\n        \n        if(dp[idx][target] != -1){\n            return dp[idx][target] == 1 ? true : false;\n        }\n        \n        if(list.get(idx) <= target){\n            boolean ans = targetSum(list, target - list.get(idx), idx+1, dp);\n            dp[idx][target] = ans ? 1 : 0;\n            if(ans == true){\n                return true;\n            }\n        }\n        \n        boolean ans = targetSum(list, target, idx+1, dp);\n        dp[idx][target] = ans ? 1 : 0;\n        if(ans == true){\n            return true;\n        }\n        \n        return false;\n    }\n    \n    \n}","author":"Yatnesh Gyani","submissionId":"1575237194"},[]]},{"1566":[{"id":"1566","fileName":"1575237238.txt","sourceCode":"class Solution {\npublic:\n    int isPossible(int target, int idx, vector<pair<int, int>>& vals, vector<unordered_map<int, int>>& ht) {\n        // base\n        if (idx >= vals.size())\n            return -1;\n        // cout << \"At \" << target << \", \" << idx << \": \" << endl;\n\n        // choose idx or not;\n        if (vals[idx].first == target) {\n             // cout << \"target \" << target << \" met at \" << idx << endl;\n            return idx;   \n        }\n        if (ht[target].find(idx) != ht[target].end())\n            return ht[target][idx];\n        int ans = -1;\n        if (vals[idx].first < target) {\n            // choose\n            // cout << \"choosing \" << idx << endl;\n            int v1 = isPossible(target - vals[idx].first, idx + 1, vals, ht);\n            // cout << \"At \" << target << \", \" << idx << \": v1 as \" << v1 << endl;\n            ans = v1;\n        }\n        // not choose\n        int v2 = isPossible(target, idx + 1, vals, ht);\n        // cout << \"At \" << target << \", \" << idx << \": v2 as \" << v2 << endl;\n        if (ans == -1) ans = INT_MAX;\n        if (v2 == -1) v2 = INT_MAX;\n        ans = min(ans, v2);\n        if (ans == INT_MAX) ans = -1;\n        // cout << \"target = \" << target << \", at = \" << idx << \" => \" << ans << endl;\n        return ht[target][idx] = ans;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        bool alreadyZero = true;\n        for (int i=0; i<nums.size(); ++i) {\n            if (nums[i] != 0) {\n                alreadyZero = false;\n                break;\n            }\n        }\n        if (alreadyZero) return 0;\n        bool ok = true;\n        int k = -1;\n        for (int i=0; i<nums.size(); ++i) {\n            int num = nums[i];\n            if (num == 0) continue;\n            vector<pair<int, int>> data;\n            for (int j=0; j<queries.size(); ++j) {\n                auto& query = queries[j];\n                if (query[0] <= i && query[1] >= i)\n                    data.push_back({query[2], j});\n            }\n            vector<unordered_map<int, int>> ht(num+1, unordered_map<int, int>());\n            int val = isPossible(num, 0, data, ht);\n            if (val == -1) {\n                ok = false;\n                break;\n            }\n            int maxQ = data[val].second + 1;  // idx + 1\n            // cout << i << \" -> \" << maxQ << endl;\n            k = max(k, maxQ);\n        }\n        if (!ok) return -1;\n        return k;\n    }\n};","author":"thatdns","submissionId":"1575237238"},[]]},{"1567":[{"id":"1567","fileName":"1575237258.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        cache = [[] for _ in range(n)]        \n        for i in range(len(queries)):\n            l, r, val = queries[i]\n            upper = min(n-1, r)\n            for idx in range(l, upper + 1):\n                cache[idx].append(i)\n        \n        max_q_idx = -1\n        \n        for i, num in enumerate(nums):\n            if num == 0:\n                continue\n            temp = cache[i]\n            if not temp:\n                return -1\n            \n            total_sum = 0\n            max_idx = -1\n            dp = {total_sum: max_idx}\n            for j in temp:\n                val = queries[j][2]\n                new_entries = {}\n                for s in dp:\n                    curr_max = dp[s]\n                    new_val = s + val\n                    new_max = max(curr_max, j)\n                    if not new_val in dp:\n                        new_entries[new_val] = new_max\n                    elif new_max < dp[new_val]:\n                        new_entries[new_val] = min(new_max, dp[new_val])\n\n                for s, new_max in new_entries.items():\n                    if not s in dp or new_max < dp[s]:\n                        dp[s] = new_max\n            \n            if not num in dp:\n                return -1\n                \n            current_m = dp[num]\n            max_q_idx = max(max_q_idx, current_m)\n        \n        if max_q_idx == -1:\n            return 0\n        else:\n            return max_q_idx + 1","author":"BingX","submissionId":"1575237258"},[]]},{"1568":[{"id":"1568","fileName":"1575237368.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(),m=queries.size();\n        vector<vector<bool>>vec(n,vector<bool>(1001,false));\n\n        for(int i=0;i<n;i++){\n            vec[i][nums[i]]=true;\n        }\n        for(int i=0;i<n;i++){\n            if(nums[i]!=0)break;\n            if(i==n-1)return 0;\n        }\n        for(int k=0;k<m;k++){\n            bool b=true;\n            for(int j=queries[k][0];j<=queries[k][1];j++){\n                vector<bool>tmp=vec[j];\n                for(int t=nums[j];t>=queries[k][2];t--){\n                    if(tmp[t]){\n                        vec[j][t-queries[k][2]]=true;\n                    }\n                }\n            }\n            for(int j=0;j<n;j++){\n                if(!vec[j][0]){ \n                    b=false;\n                    break;\n                }\n            }\n            if(b)return k+1;\n        }\n        return -1;\n    }\n};","author":"Franky_Hsiao","submissionId":"1575237368"},[]]},{"1569":[{"id":"1569","fileName":"1575237270.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n\n        int n = nums.length;\n        BitSet[] bt = new BitSet[n];\n\n        boolean flag = false;\n\n        for(int x: nums){\n            if(x!=0){\n                flag = true;\n                break;\n            }\n        }\n\n        if(!flag)return 0;\n\n        for(int i=0;i<n;i++){\n\n            bt[i] = new BitSet(1001);\n            bt[i].set(0);\n        }\n\n        int idx =1;\n\n        for(int[] q: queries){\n\n            int a = q[0];\n            int b = q[1];\n            int v = q[2];\n            boolean flaag = false;\n\n            for(int i=a;i<=b;i++){\n\n                BitSet temp = new BitSet(1001);\n\n                sfunc(bt ,i, v, temp);\n\n                bt[i].or(temp);\n                bt[i].clear( nums[i]+1, 1001 );\n            }\n\n            for(int i=0;i<n;i++){\n\n                if(!bt[i].get(nums[i])){\n                    flaag = true;\n                    break;\n                }\n            }\n\n            if(!flaag)return idx;\n            idx++;\n            \n        }\n\n        return -1;\n    }\n\n    void sfunc(BitSet[] bt, int a, int v, BitSet temp){\n        for(int i=bt[a].nextSetBit(0); i>=0; i = bt[a].nextSetBit(i+1)){\n\n            if(i + v < 1001){\n                temp.set(i + v);\n            }\n        }\n    }\n}","author":"perfection98","submissionId":"1575237270"},[]]},{"1570":[{"id":"1570","fileName":"1575237341.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number}\n */\nconst minZeroArray = function (nums, queries) {\n\tconst q = queries.length;\n\tconst n = nums.length;\n\tconst dp = Array.from({ length: n }, () => new Array(1001).fill(false));\n\n\tfor (let i = 0; i < n; i++) {\n\t\tdp[i][0] = true;\n\t}\n\n\tif (nums.every((x) => x == 0)) return 0;\n\n\tfor (let i = 0; i < q; i++) {\n\t\tconst [l, r, val] = queries[i];\n\n\t\tfor (let j = l; j <= r; j++) {\n\t\t\tconst x = new Array(1001).fill(false);\n\n\t\t\tfor (let k = 0; k < 1001 - val; k++) {\n\t\t\t\tif (dp[j][k]) {\n\t\t\t\t\tx[k + val] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let k = 0; k < 1001; k++) {\n\t\t\t\tdp[j][k] ||= x[k];\n\t\t\t}\n\n\t\t\tfor (let k = nums[j] + 1; k < 1001; k++) {\n\t\t\t\tdp[j][k] = false;\n\t\t\t}\n\t\t}\n\n\t\tlet ok = true;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tif (!dp[i][nums[i]]) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ok) return i + 1;\n\t}\n\n\treturn -1;\n};\n","author":"Fayozbek","submissionId":"1575237341"},[]]},{"1571":[{"id":"1571","fileName":"1575237553.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        int maxi = *max_element(nums.begin(), nums.end());\n        vector<vector<int>> dp(n, vector<int>(maxi + 1, -1));\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = 0;\n            for (int t = 1; t <= maxi; t++) dp[i][t] = -1;\n        }\n        for (int i = 0; i < m; i++) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for (int index = l; index <= r; index++) {\n                for (int t = maxi; t >= val; t--) {\n                    if (dp[index][t - val] != -1) {\n                        if (dp[index][t] == -1)\n                            dp[index][t] = i + 1;\n                        else\n                            dp[index][t] = min(dp[index][t], i + 1);\n                    }\n                }\n            }\n        }\n\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            int mini_k = dp[i][nums[i]];\n            if (mini_k == -1) return -1;\n            ans = max(ans, mini_k);\n        }\n        return ans;\n    }\n};\n","author":"Medhansh","submissionId":"1575237553"},[]]},{"1572":[{"id":"1572","fileName":"1575237479.txt","sourceCode":"class Solution {\npublic:\n    int dp[1005][1005];\n\n    int solve(vector<pair<int,int>> &sumArray,int index,int n,int num){\n        \n        if(num==0){\n            return sumArray[index-1].second;\n        }\n        if(num<0){\n            return 1e4;\n        }\n        if(index>=n){\n            return 1e4;\n        }\n\n        if(dp[index][num]!=-1){\n            return dp[index][num];\n        }\n\n        int ans=min(solve(sumArray,index+1, n,num-sumArray[index].first), solve(sumArray, index+1, n, num));\n\n        return dp[index][num]= ans;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans=-1;\n        int cnt=0;\n        \n        for(int i=0;i<nums.size();i++){\n            int num=nums[i];\n\n            if(num==0){\n                cnt++;\n                continue;\n            }\n\n            // this has to be made zero\n\n            // check if there is a subsequence of query val that can get me the. particular sum\n            vector<pair<int,int>> sumArray;\n\n            int index=0;\n            \n            for(auto query:queries){\n                int l=query[0];\n                int r=query[1];\n                \n                if(l<=i && r>=i){\n                    sumArray.push_back({query[2],index});\n                }\n                index++;\n            }\n\n\n            // find the possiblity of subsequence sum of num, with the least queryIndex possible\n\n            memset(dp,-1,sizeof(dp));\n            \n            int indexx=solve(sumArray,0,sumArray.size(), nums[i]);\n            \n            \n            if(indexx<1e4){\n                ans=max(ans, indexx+1);\n            }\n            else{\n                ans=-1;\n                break;\n            }\n\n            // check which is the biggest array that encompasses thsi query\n        }\n\n        if(cnt==nums.size()){\n            return 0;\n        }\n\n        return ans;\n    }\n};","author":"Nandan T S","submissionId":"1575237479"},[]]},{"1573":[{"id":"1573","fileName":"1575237492.txt","sourceCode":"class Solution {\npublic:\n    int rec(int sum, vector<pair<int, int>>& val, int ind, vector<unordered_map<int, int>>& dp) {\n        if (sum == 0)\n            return (ind > 0) ? val[ind - 1].second : 0;\n        if (sum < 0 || ind >= val.size())\n            return INT_MAX;\n        if (dp[ind].find(sum) != dp[ind].end())\n            return dp[ind][sum];\n        // take or not take\n        return dp[ind][sum] = min(rec(sum - val[ind].first, val, ind + 1, dp), rec(sum, val, ind + 1, dp));\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<pair<int, int>>> vals(n);\n        int s = queries.size();\n        for (int k = 0; k < s; k++) {\n            auto q = queries[k];\n            int l = q[0];\n            int r = q[1];\n            int val = q[2];\n            for (int i = 0; i < n; i++) {\n                if (i >= l && i <= r) {\n                    vals[i].push_back({val, k + 1});\n                }\n            }\n        }\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0)\n                continue;\n            vector<unordered_map<int, int>> dp(vals[i].size());\n            int ans = rec(nums[i], vals[i], 0, dp);\n            if (ans == INT_MAX)\n                return -1;\n            res = max(res, ans);\n        }\n        return res;\n    }\n};","author":"Om Sahu","submissionId":"1575237492"},[]]},{"1574":[{"id":"1574","fileName":"1575237557.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size(), k = 0, cnt = 0;\n\n        unordered_set<int> s, t;\n\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) {\n                cnt++;\n                continue;\n            }\n\n            s.clear();\n            \n            for (int j = 0; j < m; j++) {\n                auto query = queries[j];\n                if (query[0] <= i && i <= query[1]) {\n                    t = s;\n                    for (auto ele : s) {\n                        // printf(\"%d, \", ele + query[2]);\n                        t.insert(ele + query[2]);\n                    }\n                    t.insert(query[2]);\n                    s = t;\n                }\n\n                // for (auto&& ele : s) {\n                //     printf(\"%d, \", ele);\n                // }\n                // printf(\"n\");\n\n                if (s.find(nums[i]) != s.end()) {\n                    k = max(k, j + 1);\n                    cnt++;\n                    break;\n                }\n            }\n        }\n\n        return cnt == n ? k : -1;\n    }\n};","author":"shaoziqi","submissionId":"1575237557"},[]]},{"1575":[{"id":"1575","fileName":"1575237598.txt","sourceCode":"class Solution {\npublic:\nint dp[1001][1001];\nint fn(int i, vector<int> &values,int sum){\n    if(sum==0) return i-1;  \n    if(sum<0 || i>=values.size()) return INT_MAX;\n    if(dp[i][sum]!=-1) return dp[i][sum];\n    return dp[i][sum] = min(fn(i+1,values,sum-values[i]),fn(i+1,values,sum));\n}\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> apply(n); \n        int ind=0;\n        for(auto &i:queries){\n            int l=i[0],r=i[1];\n            for(int j=l; j<=r; j++){\n                apply[j].push_back(ind);\n            }\n            ind++;\n        }\n        for(auto &j:apply){\n            sort(j.begin(),j.end());\n        }\n        int ans=INT_MIN;\n        ind=0;\n        for(auto &i:apply){\n            vector<int> values;\n            for(auto &j:i){\n                values.push_back(queries[j][2]);\n            }\n            memset(dp,-1,sizeof(dp));\n            int p=fn(0,values,nums[ind]);\n            if(p==INT_MAX) return -1;\n            if(p>=0) ans=max(ans,i[p]+1);           \n            ind++;\n        }\n        return ans==INT_MIN?0:ans;\n    }\n};","author":"I-tachi","submissionId":"1575237598"},[]]},{"1576":[{"id":"1576","fileName":"1575237672.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        //time O(nlogn), space O(n)\n        int n = nums.size(), qn = q.size();\n        vector<vector<pair<int, int>>> v(n);\n        for(int i = 0; i < qn; i++) {\n            int left = q[i][0], right = q[i][1], val = q[i][2];\n            for(int j = left; j <= right; j++) {\n                v[j].push_back({i, val});\n            }\n        }        \n        int res = 0;\n        for(int i = 0; i < n; i++) {\n            int ret = helper(nums[i], v[i]);\n            if(ret == -1) return -1;\n            res = max(res, ret);\n        }\n        return res;\n    }\n    \n    int helper(int target, vector<pair<int, int>>& q) {\n        if(target == 0) return 0;\n        vector<bool> dp(target + 1, false);\n        dp[0] = true;\n        for(auto& p : q) {\n            int idx = p.first, val = p.second;\n            for(int i = target - val; i >= 0; i--) {\n                if(dp[i]) dp[i + val] = true;\n            }\n            if(dp[target]) return idx + 1;\n        }\n        return -1;\n    }\n};","author":"Chao Yu","submissionId":"1575237672"},[]]},{"1577":[{"id":"1577","fileName":"1575238050.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        auto can = [&](int k) -> bool {\n            for (int y = 0; y < n; y++) {\n                vector<int> x;\n                for (int i = 0; i < k; i++) {\n                    if (queries[i][0] <= y && y <= queries[i][1])\n                        x.push_back(queries[i][2]);\n                }\n                unordered_set<int> dp;\n                dp.insert(0);\n                for (int z : x) {\n                    unordered_set<int> ndp = dp;\n                    for (int v : dp)\n                        if (v + z <= nums[y])\n                            ndp.insert(v + z);\n                    dp = move(ndp);\n                }\n                if (!dp.count(nums[y]))\n                    return false;\n            }\n            return true;\n        };\n        int lo = 0, hi = m + 1, ans = -1;\n        while (lo < hi) {\n            int mid = (lo + hi) / 2;\n            if (can(mid)) {\n                ans = mid;\n                hi = mid;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"somandhir","submissionId":"1575238050"},[]]},{"1578":[{"id":"1578","fileName":"1575237633.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n#define vii vector<vector<int>>\n#define vpp vector<vector<pair<int, int>>>\n#define vi vector<int>\n#define pb push_back\n#define fi first\n#define se second\n#define s(v) sort(v.begin(), v.end())\n#define r(v) reverse(v.begin(), v.end())\nclass Solution\n{\npublic:\n    bool fun(int num, const multiset<int> &subset)\n    {\n        if (num == 0)\n        {\n            return true;\n        }\n        if (subset.size() == 0)\n        {\n            return false;\n        }\n        vi st1(subset.begin(), subset.end());\n        int sum = accumulate(st1.begin(), st1.end(), 0);\n        if (sum < num)\n        {\n            return false;\n        }\n        if (sum == num)\n        {\n            return true;\n        }\n        vector<bool> dp(num + 1, false);\n        dp[0] = true;\n        for (int val : st1)\n        {\n            for (int j = num; j >= val; j--)\n            {\n                dp[j] = dp[j] | dp[j - val];\n            }\n        }\n        return dp[num];\n    }\n    int minZeroArray(vi &nums, vector<vi> &queries)\n    {\n        int n = nums.size(), m = queries.size();\n        bool flag = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (nums[i] != 0)\n            {\n                flag = 1;\n                break;\n            }\n        }\n        if (flag == 0)\n        {\n            return 0;\n        }\n        int lo = 0, hi = m - 1, ans = -1;\n        while (lo <= hi)\n        {\n            int mid = (lo + hi) / 2;\n            map<int, multiset<int>> mp;\n            for (int j = 0; j <= mid; j++)\n            {\n                for (int i = queries[j][0]; i <= queries[j][1]; i++)\n                {\n                    mp[i].insert(queries[j][2]);\n                }\n            }\n        //     for (auto it : mp)\n        // {\n        //     cout << it.first << \" \";\n        //     for (auto it1 : it.se)\n        //     {\n        //         cout << it1 << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        // cout<<endl;\n            int ip = 1;\n            for (int i = 0; i < n; i++)\n            {\n                if (fun(nums[i], mp[i]))\n                {\n                    ip &= 1;\n                }\n                else\n                {\n                    ip &= 0;\n                }\n            }\n            if (ip == 0)\n            {\n                lo = mid + 1;\n            }\n            else\n            {\n                ans = mid;\n                hi = mid - 1;\n            }\n        }\n        // cout<<endl;\n        // cout<<endl;\n        // cout<<endl;\n        if (ans == -1)\n        {\n            return ans;\n        }\n        return ans + 1;\n    }\n};\n","author":"manideep2004","submissionId":"1575237633"},[]]},{"1579":[{"id":"1579","fileName":"1575238116.txt","sourceCode":"  /* bool exist(int target, vector<int> arr){\n       if(target == 0) return true;\n        if(arr.size()==0 ) return false;\n        int n = arr.size(),i,j;\n        bool dp[1015][1015];\n        for(i=0;i<(n+10);i++){\n            for(j=0;j<(target+10);j++){\n                dp[i][j] = false;\n            }    \n            \n        }\n        dp[0][arr[0]] = true;\n        for(i=0;i<(n+10);i++) dp[i][0] = true;\n        for(i=1;i<n;i++){\n            for(j=1;j<=target;j++){\n                bool curr = dp[i-1][j];\n                if(j>=arr[i]){\n                    curr = (curr || (dp[i-1][j-arr[i]]));\n                }\n                dp[i][j] = curr;\n            }\n        }\n        return dp[n-1][target];\n    } */\nbool exist(int sum , vector<int> &arr) {\n    int n = arr.size();\n\n    // Create a 2D vector for storing results\n      // of subproblems\n    vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));\n\n    // If sum is 0, then answer is true (empty subset)\n    for (int i = 0; i <= n; i++)\n        dp[i][0] = true;\n\n    // Fill the dp table in bottom-up manner\n    for (int i = 1; i <= n; i++) {\n      \n        for (int j = 1; j <= sum; j++) {\n            if (j < arr[i - 1]) {\n              \n               // Exclude the current element\n                dp[i][j] = dp[i - 1][j]; \n            }\n            else {\n              \n               // Include or exclude\n                dp[i][j] = dp[i - 1][j] \n                || dp[i - 1][j - arr[i - 1]];\n            }\n        }\n    }\n\n    return dp[n][sum];\n}\nclass Solution {\npublic:\n  \n   \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = queries.size(),i,j;\n        int low =  0,high  = n-1 , gans = -2;\n        bool zer = true;\n        for(auto ele : nums){\n            if(ele!=0) zer = false;\n        }\n        if(zer) return 0;\n        while(low<=high){\n            int mid = low +  ((high-low)/2);\n            bool ans  = true;\n            for(i=0;i<nums.size();i++){\n                vector<int> temp;\n                for(j=0;j<=mid;j++){\n                    if(i>=queries[j][0] && i<=queries[j][1]){\n                        temp.push_back(queries[j][2]);\n                    }\n                }\n                /*cout<<nums[i]<<\"n\";\n                for(auto ele : temp) cout<<ele<<\" \";\n                cout<<\"n\";*/\n                ans = ans & (exist(nums[i],temp));\n                // cout<<ans<<\"n\";\n            }\n            if(ans){\n                gans = mid ; high = mid - 1;\n            }\n            else{\n                low = mid + 1;\n            }\n        }\n        return gans+1;\n    }\n};","author":"nimish","submissionId":"1575238116"},[]]},{"1582":[{"id":"1582","fileName":"1575238187.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        # vali: pick any val in querys, until it is 0. record i\n        # if a number can be a sum by a subset of numbers\n        if all(num ==0 for num in nums):\n            return 0\n        def check(candidates:List[int], target:int) -> bool:\n            if target == 0:\n                return True\n            p = {0}\n            for c in candidates:\n                p_new = set()\n                for n1 in p:\n                    if n1+c <target:\n                        p_new.add(n1+c)\n                    elif n1+c == target:\n                        return True\n                    \n                p = p|p_new\n            return False\n\n        require= [math.inf for _ in range(len(nums))]\n        numCandidates = [[] for _ in range(len(nums))]\n        for i, (l, r, val) in enumerate(queries):\n            for _idx in range(l, r+1):\n                numCandidates[_idx].append(val)\n            for j, num in enumerate(nums):\n                if require[j] != math.inf:\n                    continue\n                # find if num can meet the need to get the sum of num\n                if check(numCandidates[j], num):\n                    require[j]=i+1\n            if max(require) != math.inf:\n                return i+1\n        return -1\n                \n            ","author":"codemonkey66","submissionId":"1575238187"},[]]},{"1583":[{"id":"1583","fileName":"1575238173.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int ans = 0;\n        Map<Integer, List<Integer>> decrement = new HashMap<>();\n        if (isZero(nums, decrement)) {\n            return ans;\n        }\n        for (int[] query : queries) {\n            ans++;\n//            System.out.println(\"query:\"+ans);\n            for (int i = query[0]; i <= query[1]; i++) {\n                decrement.computeIfAbsent(i, key -> new ArrayList<>()).add(query[2]);\n            }\n            if (isZero(nums, decrement)) {\n                return ans;\n            }\n        }\n        return -1;\n    }\n\n    private boolean isZero(int[] nums, Map<Integer, List<Integer>> decrement) {\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 0) {\n                continue;\n            }\n            List<Integer> array = decrement.get(i);\n            if (array == null) {\n//                System.out.println(\"array null\");\n                return false;\n            }\n            int target = nums[i];\n            int m = array.size();\n            int[][] dp = new int[m][target + 1];\n            for(int[] row: dp){\n                Arrays.fill(row,-1);\n            }\n            if (!subsetSum(m - 1, target, array, dp)) {\n//                System.out.println(target + \" \" + array);\n\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean subsetSum(int i, int target, List<Integer> array, int[][] dp) {\n        if (target == 0) {\n            return true;\n        }\n        if (i == 0) {\n            return array.get(i) == target;\n        }\n        if (dp[i][target] != -1) {\n            return dp[i][target] == 1;\n        }\n        boolean first = subsetSum(i - 1, target, array, dp);\n        boolean second = false;\n        if (array.get(i) <= target) {\n            second = subsetSum(i - 1, target - array.get(i), array, dp);\n        }\n        dp[i][target] = first || second ? 1 : 0;\n        return first || second;\n    }\n}","author":"deep-gajjar","submissionId":"1575238173"},[]]},{"1584":[{"id":"1584","fileName":"1575238235.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, q = len(nums), len(queries)\n\n        if all(num == 0 for num in nums):\n            return 0\n\n        dp = [1 << 0] * n\n\n        # print(bin(dp[0]))\n        for i, query in enumerate(queries):\n            left, right, val = query\n\n            for j in range(left, right + 1):\n                dp[j] |= dp[j] << val\n\n            res = True\n            for k, num in enumerate(nums):\n                if not (dp[k] & (1 << num)):\n                    res = False\n                    break\n\n            if res:\n                return i + 1\n\n        return -1","author":"RAY2L","submissionId":"1575238235"},[]]},{"1585":[{"id":"1585","fileName":"1575238196.txt","sourceCode":"class Solution {\npublic:\n    bool isSubsetSumRec(vector<int>& arr, int n, int sum, vector<vector<int>> &memo) {\n\n        if (sum == 0)\n            return 1;\n        if (n <= 0)\n            return 0;\n        if (memo[n][sum] != -1)\n            return memo[n][sum];\n        if (arr[n - 1] > sum)\n            return memo[n][sum] = isSubsetSumRec(arr, n - 1, sum, memo);\n        else {\n            return memo[n][sum] = isSubsetSumRec(arr, n - 1, sum, memo) ||\n                                  isSubsetSumRec(arr, n - 1, sum - arr[n - 1], memo);\n        }\n    }\n\n    bool isSubsetSum(vector<int>&arr, int sum, int n) {\n\n        vector<vector<int>> memo(n + 1, vector<int>(sum + 1, -1));\n        return isSubsetSumRec(arr, n, sum, memo);\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), i,j, q = queries.size();\n        vector<int> temp;\n        int found = 0;\n        int res = 0;\n        vector<int> v(q);\n        for(i=0;i<n;i++){\n            int hi = q, lo = 0, mid;\n            for(j=0;j<q;j++){\n                if(i>=queries[j][0]&&i<=queries[j][1]){\n                    v[j] = queries[j][2];\n                }\n                else{\n                    v[j] = 0;\n                }\n            }\n            int ans=-1;\n            while(lo<=hi){\n                mid = lo+(hi-lo)/2;\n                if(isSubsetSum(v,nums[i],mid)){\n                    found = 1;\n                    ans = mid;\n                    hi = mid-1;\n                }\n                else{\n                    lo = mid+1;\n                }\n            }\n            if(ans==-1){\n                return -1;\n            }\n            res = max(res,ans);\n        }\n        return res;\n    }\n};","author":"Bharat Adhikari","submissionId":"1575238196"},[]]},{"1586":[{"id":"1586","fileName":"1575238369.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        boolean[][] dp = new boolean[n][1001];\n\n        for (int j = 0; j < n; j++) {\n            dp[j][0] = true;\n        }\n\n        boolean allZeroes = Arrays.stream(nums).allMatch(num -> num == 0);\n        if (allZeroes) return 0;\n\n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int v = queries[k][2];\n\n            for (int i = l; i <= r; i++) {\n                boolean[] newDp = new boolean[1001];\n\n                for (int pos = 0; pos + v < 1001; pos++) {\n                    if (dp[i][pos]) {\n                        newDp[pos] = true;\n                        newDp[pos + v] = true;\n                    }\n                }\n\n                dp[i] = newDp;\n                Arrays.fill(dp[i], nums[i] + 1, 1001, false);\n            }\n\n            boolean allDone = true;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i][nums[i]]) {\n                    allDone = false;\n                    break;\n                }\n            }\n\n            if (allDone) return k + 1;\n        }\n        return -1;\n    }\n}\n","author":"trisha_tomy","submissionId":"1575238369"},[]]},{"1587":[{"id":"1587","fileName":"1575238384.txt","sourceCode":"class Solution {\npublic:\nbool fun(vector<int>& nums, int sum) {\n    vector<bool> dp(sum + 1, false);\n    dp[0] = true;\n\n    for (int num : nums) {\n        for (int j = sum; j >= num; --j) {\n            if (dp[j - num]) {\n                dp[j] = true;\n            }\n        }\n    }\n    return dp[sum];\n}\n    bool valid(vector<int>&nums,int k,vector<vector<int>>&queries){\n\n        int n=nums.size(),q=queries.size();\n\n        vector<vector<int>>f(n);\n\n        for(int i=0;i<k;i++){\n\n            int l=queries[i][0],r=queries[i][1],val=queries[i][2];\n\n            for(int j=l;j<=r;j++){\n\n                f[j].push_back(val);\n                \n            }\n        }\n\n        for(int i=0;i<n;i++){\n\n            if(nums[i]==0)continue;\n\n            if(!fun(f[i],nums[i]))return false;\n            \n        }\n\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\n        int n=nums.size();\n\n        int q=queries.size();\n\n        int low=0,high=q;\n\n        int ans=-1;\n\n        while(low<=high){\n\n            int mid=low+(high-low)/2;\n\n            if(valid(nums,mid,queries)){\n\n                ans=mid;\n\n                high=mid-1;\n                \n            }\n\n            else{\n\n                low=mid+1;\n                \n            }\n            \n        }\n\n        return ans;\n        \n    }\n};","author":"Aditya Baranwal","submissionId":"1575238384"},[]]},{"1588":[{"id":"1588","fileName":"1575238200.txt","sourceCode":"class Solution {\npublic:\n    bool check(int mid,vector<int>&nums,vector<vector<int>>& queries){\n        int n=nums.size();\n        vector<bitset<1001>>dp(n);\n        for(int i=0;i<n;i++){\n            dp[i].set(nums[i]);\n        }\n        for(int i=0;i<mid;i++){\n            int l=queries[i][0];\n            int r=queries[i][1];\n            int val=queries[i][2];\n\n            for(int j=l;j<=r;j++){\n                bitset<1001>ndp=dp[j];\n                for(int k=1000;k>=val;k--){\n                    if(dp[j][k]){\n                        ndp.set(k-val);\n                    }\n                }\n                dp[j]=move(ndp);\n            }\n            \n        }\n\n        for(int i=0;i<n;i++){\n            if(!dp[i][0]){\n                return false;\n            }\n        }\n        return true;\n\n        \n        \n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l=0;\n        int r=queries.size();\n        int ans=-1;\n        while(l<=r){\n            int mid=(r-l)/2+l;\n            if(check(mid,nums,queries)){\n                ans=mid;\n                r=mid-1;\n            }\n            else{\n                l=mid+1;\n            }\n        }\n        return ans;\n    }\n};","author":"Heer Shah","submissionId":"1575238200"},[]]},{"1589":[{"id":"1589","fileName":"1575238374.txt","sourceCode":"class Solution {\npublic:\n    int solve(vector<int>&nums,int t,int i,vector<vector<int>>&dp){\n        if(t==0)\n            return 1;\n        if(i==nums.size())\n                return 0;\n        if(dp[i][t]!=-1)\n                return dp[i][t];\n        int in=0,ex=0;\n        if(t>=nums[i])\n            in=solve(nums,t-nums[i],i+1,dp);\n        ex=solve(nums,t,i+1,dp);\n        return dp[i][t]=in or ex;\n        \n    }\n    bool ispossible(vector<int>&nums,vector<vector<int>>&q,int k){\n        vector<vector<int>>tar(nums.size());\n        for(int i=0;i<k;i++){\n            auto &v=q[i];\n            for(int j=v[0];j<=v[1];j++){\n                tar[j].push_back(v[2]);\n            }\n        }\n        //vector<vector<int>>dp(1001,vector<int>(1001,-1));\n        for(int i=0;i<nums.size();i++){\n            \n                \n            auto &v=tar[i];\n            int target=nums[i];\n            vector<vector<int>>dp(v.size(),vector<int>(target+1,-1));\n            //for(auto i:v) cout<<i<<\" \";\n            //cout<<\",\"<<target;\n            bool ans=solve(v,target,0,dp);\n            //cout<<\",\"<<ans<<endl;\n            if(! ans)\n                return 0;\n        }\n        return 1;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        bool  tmp=1;\n        for(auto i:nums)\n            if(i!=0) tmp=0;\n        if(tmp) return 0;\n        int s=1,e=queries.size();\n        int ans=-1;\n        while(s<=e){\n            int mid=s+(e-s)/2;\n            if(ispossible(nums,queries,mid))\n                ans=mid,e=mid-1;\n            else s=mid+1;\n        }\n        return ans;\n        \n    }\n};","author":"akshanshjain","submissionId":"1575238374"},[]]},{"1590":[{"id":"1590","fileName":"1575238676.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int sum = 0;\n        for(int i = 0; i < nums.size(); i++){\n            sum += nums[i];\n        }\n        if(sum == 0){\n            return 0;\n        }\n        // For each one of the nums, find a subsequence of queries that sums to num\n        map<int,vector<pair<int,int>>> mp;\n        int i = 1;\n        for(vector<int> q : queries){\n            int L = q[0];\n            int R = q[1];\n            int decr = q[2];\n            for(int j = L; j <= R; j++){\n                mp[j].push_back({decr,i});\n            }\n            i++;\n        }\n        int ans = -1;\n        for(int i = 0; i < nums.size(); i++){\n            if(nums[i] > 0 && !mp.count(i)){\n                return -1;\n            }\n        }\n        for(auto info : mp){\n            //cout << \"Now dealing with index \" << info.first << \"n\";\n            int initNum = nums[info.first];\n            vector<pair<int,int>> v = info.second;\n            int N = v.size();\n            int dp[N][initNum+1];\n            for(int j = 0; j < N; j++){\n                for(int num = 0; num < initNum+1; num++){\n                    dp[j][num] = 0;\n                }\n            }\n            // dp[j][num] is number of subsequences of v up to index j with sum num\n            int sol = -1;\n            for(int j = 0; j < N; j++){\n                dp[j][0] = 1;\n                if(v[j].first <= initNum) dp[j][v[j].first] = 1;\n                for(int num = 0; num <= initNum; num++){\n                    if(j > 0){\n                        dp[j][num] = (((((num >= v[j].first) ? dp[j-1][num - v[j].first] : 0) + dp[j-1][num])) > 0) ? 1 : 0;\n                        //cout << \"Number of ways to reach \" << num << \" by query # \" << j << \"is \" << dp[j][num] << \"n\";\n                    }\n                    if(num == initNum && dp[j][num] > 0){\n                        sol = (sol == -1) ? v[j].second : sol;\n                        \n                    }\n                }\n            }\n            //cout << \"Found sol \" << sol << \"n\";\n            if(sol == -1 && initNum > 0){\n                return -1;\n            }\n            if(sol != -1) ans = max(sol,ans);\n            \n        }\n        return ans;\n    }\n};","author":"xorfftdp","submissionId":"1575238676"},[]]},{"1591":[{"id":"1591","fileName":"1575238537.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& v, vector<vector<int>>& q) {\n        int n = v.size();\n        \n        vector<bitset<1001>> ans(n, bitset<1001>());\n        for (int j = 0; j < n; j++) {\n            ans[j][0] = 1;\n        }\n\n        bool fun=false;\n        bool bullu = true;\n        for (int j = 0; j < n; j++) {\n            if (v[j] != 0) {\n                bullu = false;\n                break;\n            }\n        }\n\n        int count1=0;\nint mount1=-1;\nbool bulu=true;\nfor(int i=0;i<10;i++){\n    count1+=2;\n}\n\nif(count1>10){\n    bulu=false;\n}else{\n    bulu=true;\n}\n\nfor(int i=0;i<10;i++){\n    mount1+=count1;\n    count1++;\n}\n\nstack<int>stt;\nfor(int i=0;i<18;i++){\n    stt.push(i+2);\n}\nwhile(!stt.empty()){\n    stt.pop();\n}\nif(mount1>32){\n    bulu=false;\n}else{\n    bulu=true;\n}\n        \n        if (bullu)\n        return 0;\n        \n        for (int k = 0; k < q.size(); k++) {\n            int z = q[k][2];\n            int l = q[k][0];\n            int r = q[k][1];\n            \n            \n            for (int j = l; j <= r; j++) {\n                ans[j] = ans[j] | (ans[j] << z); \n                for (int pos = v[j] + 1; pos < 1001; pos++) {\n                    ans[j][pos] = 0;\n                }\n            }\n            bool fbullu = true;\n        \n            for (int j = 0; j < n; j++) {\n                if (ans[j][v[j]] == 0){\n                    fbullu = false;\n                    break;\n                }\n            }\n            if(fun){\n                if (z == -1){\n                    fbullu = true;\n                    break;\n                }else{\n                    continue;\n                }\n            }\n            \n            if (fbullu!=false)\n                return 1+k;\n        }\n        return -1;\n    }\n};","author":"Pudzianowski","submissionId":"1575238537"},[]]},{"1592":[{"id":"1592","fileName":"1575238445.txt","sourceCode":"class Solution {\n    public boolean helper(List<Integer> ls,int sum,int i,int[][] dp){\n        if(sum==0)return true;\n        if(i>=ls.size())return false;\n        if(dp[i][sum]!=-1){\n            if(dp[i][sum]==1)return true;\n            return false;\n        }\n        boolean x=helper(ls,sum,i+1,dp);\n        if(x){\n            dp[i][sum]=1;\n            return true;\n        }\n        if(ls.get(i)>sum){\n            dp[i][sum]=0;\n            return false;\n        }\n        x=helper(ls,sum-ls.get(i),i+1,dp);\n        if(x){\n            dp[i][sum]=1;\n        }else{\n            dp[i][sum]=0;\n        }\n        return x;\n    }\n    public boolean check(HashMap<Integer,Integer> hm,int sum){\n        List<Integer> ls=new ArrayList<>();\n        for(Map.Entry<Integer,Integer> h:hm.entrySet()){\n            for(int i=0;i<h.getValue();i++)ls.add(h.getKey());\n        }\n        //if(ls.size()>0)System.out.println(ls.get(0)+\" \"+ls.get(1));\n        int[][] dp=new int[ls.size()][sum+1];\n        for(int[] d:dp)Arrays.fill(d,-1);\n        return helper(ls,sum,0,dp);\n    }\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int sum=0,k=0,i=0;\n        ArrayList<Integer>[] adi=new ArrayList[nums.length+1];  \n        for( i=0;i<nums.length+1;i++)adi[i]=new ArrayList<>();\n        ArrayList<Integer>[] del=new ArrayList[nums.length+1];\n        for( i=0;i<nums.length+1;i++)del[i]=new ArrayList<>();\n        HashMap<Integer,Integer> hm=new HashMap<>();\n        i=0;\n        for(;i<nums.length;i++){\n            for(Integer d:del[i]){\n                if(hm.get(d)==1){\n                    hm.remove(d);\n                }else{\n                    hm.put(d,hm.get(d)-1);\n                }\n            }\n            for(Integer d:adi[i]){\n                hm.put(d,hm.getOrDefault(d,0)+1);\n            }\n            while(!check(hm,nums[i]) && k <queries.length){\n                if(queries[k][1]<i){\n                    k++;\n                    continue;\n                }\n               // System.out.println(i+\" gh\"+k +\" \"+hm.size());\n                if(queries[k][0]<=i){\n                    hm.put(queries[k][2],hm.getOrDefault(queries[k][2],0)+1);\n                   // adi[i].add(queries[k][2]);\n                }else{\n                    adi[queries[k][0]].add(queries[k][2]);\n                }\n                del[queries[k][1]+1].add(queries[k][2]);\n                k++;\n               // System.out.println(i+\" gh\"+k +\" \"+hm.size());\n                \n            }\n            if(!check(hm,nums[i])){\n                return -1;\n            }\n        }\n        return k;\n    }\n}","author":"chinnamsaireddy1369","submissionId":"1575238445"},[]]},{"1593":[{"id":"1593","fileName":"1575238639.txt","sourceCode":"class Solution {\npublic:\n    int dp[1002][1002];\n    int ks(int val, int ind, vector<int>& vals, int n){\n        if(val<0) return 0;\n        if(val==0) return 1;\n        if(ind==n){\n            if(val==0) return 1;\n            else return 0;\n        }\n        if(dp[ind][val]!=-1) return dp[ind][val];\n        return dp[ind][val]= ks(val,ind+1,vals,n) || ks(val-vals[ind],ind+1,vals,n);\n    }\n    bool solve2(vector<int>& nums, int mid, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> ind(n);\n        for (int k = 0; k <= mid; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int val = queries[k][2];\n            for (int i = l; i <= r; i++)\n                ind[i].push_back(val);\n        }\n        int cnt=0;\n        for(int i=0;i<nums.size();i++){\n            memset(dp,-1,sizeof(dp));\n            if(ks(nums[i],0,ind[i],ind[i].size())) cnt++;\n        }\n        return cnt==n;\n    }\n    int solve(vector<int>& nums, int mid, vector<vector<int>>& queries) {\n        int n = nums.size();\n        // cout<<\"mid \"<<mid<<endl;\n        vector<int> fct(n, 0);\n        for (int i = 0; i <= mid; i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            fct[l] -= queries[i][2];\n            if (r < n - 1)\n                fct[r + 1] += queries[i][2];\n        }\n        int cnt = 0, fact = 0, cntneg = 0;\n        for (int i = 0; i < n; i++) {\n            // cout<<fct[i]<<endl;\n            fact += fct[i];\n            // nums[i]+=fact;\n            if (nums[i] + fact == 0)\n                cnt++;\n            else if (nums[i] + fact < 0)\n                cntneg++;\n            else {\n            }\n        }\n        if (cnt == n)\n            return 1;\n        else if (cntneg > 0)\n            return -1;\n        else\n            return 0;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = queries.size();\n        int m = nums.size();\n        bool fl = true;\n        for (auto& x : nums)\n            if (x > 0)\n                fl = false;\n        if (fl)\n            return 0;\n        int s = 0, e = n - 1;\n        int ans = -2;\n        while (s <= e) {\n            // cout<<\"s \"<<s<<\" e\"<<e<<endl;\n            int mid = s + (e - s) / 2;\n            if (solve2(nums, mid, queries)) {\n                ans = mid;\n                e=mid-1;\n            } else {\n                s=mid+1;\n            }\n        }\n        if(ans<0) return -1;\n        return ans+1;\n    }\n};","author":"Random Coder","submissionId":"1575238639"},[]]},{"1594":[{"id":"1594","fileName":"1575238678.txt","sourceCode":"class Solution {\npublic:\n    bool bagProblem(vector<int>& choice, int target) {\n        // cout << \"Resolving 0/1: target - \" << target;\n        // cout << \" The choice: \";\n        // for(auto& c: choice) {\n        //     cout << c << \" \";\n        // }\n        // cout << endl;\n    \n        vector<int> dp(target+1, 0);\n        dp[0] = 1;\n        for(int& num: choice) {\n            for(int i = target; i >= num; i -= 1) {\n                dp[i] = dp[i] || dp[i - num];\n            }\n        }\n        // if(dp[target] == 1)\n        //     cout << \" SUCCESS! \" <<endl;\n        return dp[target];\n    }\n\n    bool validate(vector<int>& nums,  vector<vector<int>>& queries, vector<vector<int>>& choose, int qlimit) {\n        // 0/1 bag problem\n        vector<vector<int>> choices(nums.size());\n        for(int i = 0; i < choose.size(); i += 1) {\n            for(int j = 0; j < choose[i].size(); j += 1) {\n                int q_idx = choose[i][j];\n                if(q_idx <= qlimit)\n                    choices[i].push_back(queries[q_idx][2]);\n            }\n        }\n\n        // now choices means, for each idx of nums, which numbers I could choose to combine from it?\n        for(int i = 0; i < nums.size(); i += 1) {\n            int target = nums[i];\n            if(target == 0)\n                continue;\n            if(!bagProblem(choices[i], target)){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int allZero = 1;\n        for(int& num: nums) {\n            if(num != 0) {\n                allZero = 0;\n            }\n        }\n        if(allZero)\n            return 0;\n\n        \n        // for each i of nums, find out the idx of the queries which includes i;\n        vector<vector<int>> choose(nums.size());\n        for(int j = 0; j < queries.size(); j += 1) {\n            auto q = queries[j];\n            int s = q[0];\n            int e = q[1];\n            for(int i = s; i <= e; i += 1) {\n                choose[i].push_back(j);\n            }\n        }\n\n        // binary search the result.\n        // the result should be the ans + 1 since it is nth not the idx\n        int beg = 0;\n        int end = queries.size() - 1;\n        while(beg <= end) {\n            int mid = (beg + end) / 2;\n            // mid means the last queries should be considered\n            if(validate(nums, queries, choose, mid)) {\n                // works, we should find smaller!\n                end = mid - 1;\n            } else {\n                // not works, then we should find bigger \n                beg = mid + 1;\n            }\n        }\n\n        // the beg is the first idx of queries limit which make it work!\n        // so the answer should be beg + 1\n        if(beg < queries.size()) {\n            return beg + 1;\n        } else {\n            // invalid idx\n            return -1;\n        }\n    }\n};","author":"kirska","submissionId":"1575238678"},[]]},{"1595":[{"id":"1595","fileName":"1575238629.txt","sourceCode":"using namespace std;\n\nclass Solution {\npublic:\n    bool good(int mid, vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        for (int i = 0; i < n; i++){\n            if(nums[i] == 0)\n                continue;\n            \n            vector<int> curr;\n            for(int j = 0; j <= mid; j++){\n                if (queries[j][0] <= i && i <= queries[j][1])\n                    curr.push_back(queries[j][2]);\n            }\n            \n            bitset<1100> dp;\n            dp.reset();\n            dp[0] = 1;\n            for(int v : curr){\n                dp |= (dp << v);\n            }\n            if(!dp[nums[i]])\n                return false;\n        }\n        return true;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        \n        bool zero = true;\n        for(int x : nums){\n            if(x != 0){ zero = false; break; }\n        }\n        if(zero)\n            return 0;\n        \n        int s = -1, e = queries.size();\n        while(e > s + 1){\n            int mid = (s + e) / 2;\n            if (good(mid, nums, queries))\n                e = mid;\n            else\n                s = mid;\n        }\n        return (e == queries.size() ? -1 : e + 1);\n    }\n};\n","author":"Lakshay Tewtiya","submissionId":"1575238629"},[]]},{"1596":[{"id":"1596","fileName":"1575238727.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int N=nums.length;\n        int k=0;\n        int Q=queries.length;\n        int[][]dp=new int[1001][1001];\n        for(int i=0;i<N;i++){\n            if(nums[i]==0)continue;\n            for(int[]row:dp)Arrays.fill(row,-1);\n            k=Math.max(k, rec(nums[i], 0, queries, i, dp));\n        }\n        return k==Q+1?-1:k;\n    }\n    int rec(int X,int I,int[][]A,int p,int[][]dp){\n        int Q=A.length;\n        if(X==0)return I;\n        if(I==Q)return Q+1;\n        if(dp[X][I]!=-1)return dp[X][I];\n        int[]q=A[I];\n        int l=q[0],r=q[1],v=q[2];\n        int o1=rec(X,I+1,A,p,dp);\n        int o2=Q+1;\n        if(p>=l && p<=r && X>=v){\n            o2=rec(X-v,I+1,A,p,dp);\n        }\n        return dp[X][I]=Math.min(o1,o2);\n    }\n}","author":"Ritwik Bhattacharya","submissionId":"1575238727"},[]]},{"1597":[{"id":"1597","fileName":"1575238860.txt","sourceCode":"class Solution {\npublic:\n    vector<vector<int>> dp;\n    int solve(int num,int idx,vector<vector<int>> &queries,int myidx)\n    {\n        int sz=queries.size();\n        if(idx==sz)\n        {\n            if(num!=0)\n            {\n                return 1e9;\n            }\n            return 0;\n        }\n        if(num==0)\n        {\n            return 0;\n        }\n        if(num<0)\n        {\n            return 1e9;\n        }\n        if(dp[num][idx]!=-1)\n        {\n            return dp[num][idx];\n        }\n        if(myidx>=queries[idx][0] && queries[idx][1]>=myidx && queries[idx][2]<=num)\n        {\n            return dp[num][idx]=min(1+solve(num-queries[idx][2],idx+1,queries,myidx),1+solve(num,idx+1,queries,myidx));\n        }\n        return dp[num][idx]=1+solve(num,idx+1,queries,myidx);\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int> arr;\n        for(auto it:queries)\n        {\n            arr.push_back(it[2]);\n        }\n        int mx=0;\n        int n=nums.size();\n        int sz=queries.size();\n        for(int i=0;i<n;i++)\n        {\n            vector<vector<int>> dp(nums[i]+1,vector<int>(sz+1,-1));\n            this->dp=dp;\n            int val=solve(nums[i],0,queries,i);\n            mx=max(mx,val);\n        }\n        if(mx>1000)\n        {\n            return -1;\n        }\n        return mx;\n    }\n};","author":"Slim Shady","submissionId":"1575238860"},[]]},{"1598":[{"id":"1598","fileName":"1575238775.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int len=nums.length;\n        int l=queries.length;\n        int zCount=0;\n        int[] sumArr=new int[len];\n        HashMap<Integer,HashSet<Integer>> hMap = new HashMap();\n        for(int i=0;i<len;i++){\n            if(nums[i]==0){\n                zCount++;\n            }\n            else{\n            hMap.put(i,new HashSet<Integer>());\n            }\n            \n        }\n        if(hMap.size()==0) return 0;\n        for(int i=0;i<l;i++){\n            int st=queries[i][0],end=queries[i][1],val=queries[i][2];\n            for(int j=st;j<=end;j++){\n                if(hMap.containsKey(j)){\n                    HashSet<Integer> hset= hMap.get(j);\n                    HashSet<Integer> newHset= new HashSet(hMap.get(j));\n                    for(int v: hset){\n                       newHset.add(v+val); \n                    }\n                    newHset.add(val);\n                    hMap.put(j,newHset);\n                     if(newHset.contains(nums[j])){\n                        zCount++;\n                        hMap.remove(j);\n                    }\n                    if(zCount==len) return i+1;\n                }\n               \n                \n            }\n            \n        }\n        return -1;\n    }\n\n}","author":"Deeveish","submissionId":"1575238775"},[]]},{"1599":[{"id":"1599","fileName":"1575238888.txt","sourceCode":"class Solution {\npublic:\n    int find(vector<vector<int>>& q, int val,int i) {\n        vector<bool> dp(1001, false);\n        dp[0] = true;\n        if (val == 0) return 0;\n        for (int k = 0;k<q.size(); k++) {\n            int l =q[k][0],r=q[k][1],v=q[k][2];\n            if (i >= l && i <= r) {\n                vector<bool> curr(1001, false);\n                for (int s = 0; s <= val; s++) {\n                    if (s + v <= 1000 && dp[s]) {\n                        curr[s + v] = true;\n                    }\n                }\n                for (int s = 0; s <= 1000; s++) {\n                    dp[s] = dp[s]||curr[s];\n                }\n            }\n            if (dp[val]) return k + 1;\n        }\n        return -1;\n    }\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size();\n        int m = q.size();\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            int temp = find(q, a[i],i);\n            if (temp == -1)\n                return temp;\n            ans = max(ans, temp);\n        }\n        return ans;\n    }\n};","author":"ketan_k_j","submissionId":"1575238888"},[]]},{"1600":[{"id":"1600","fileName":"1575239020.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n\n        int zeroCount = 0;\n        boolean[] isZero = new boolean[nums.length]; // indicates whether nums[i] is 0 or not\n        // combs[i] stores the all possible combinations that we could have for nums[i] after a given query is applied on it\n        HashSet<Integer>[] combs = new HashSet[nums.length]; \n        for(int i=0;i<nums.length;i++){\n            HashSet<Integer> hs = new HashSet<>();\n            hs.add(nums[i]);\n            combs[i] = hs;\n            if(nums[i] == 0){\n                zeroCount += 1;\n                isZero[i] = true;\n            }\n        }\n\n        int k = 0;\n        if(zeroCount == nums.length)\n            return k;\n\n        while(k < queries.length){\n            int[] query = queries[k];\n            for(int i=query[0];i<=query[1];i++){\n                if(!isZero[i]){\n                    HashSet<Integer> values = combs[i];\n                    HashSet<Integer> newValues = new HashSet<>(values);\n                    // Iterator<Integer> iterator = values.iterator();\n                    for(int val: values){\n                        // int val = iterator.next();\n                        int newValue = val - query[2];\n                        if(newValue == 0){\n                            isZero[i] = true;\n                            zeroCount += 1;\n                            break;\n                        }\n                        else if(newValue > 0)\n                            newValues.add(val - query[2]);\n                    }\n                    combs[i] = newValues;\n                }\n            }\n            k++;\n            if(zeroCount == nums.length)\n                return k;\n        }\n\n        return -1;\n    }\n}","author":"Atishay Jain","submissionId":"1575239020"},[]]},{"1601":[{"id":"1601","fileName":"1575238933.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        ptr_q = 0\n        m = len(queries)\n        n = len(nums)\n        mem = [set([0]) for _ in range(n)]\n        for ind, num in enumerate(nums):\n            while ptr_q < m and num not in mem[ind]:\n                l, r, val = queries[ptr_q]\n                ptr_q += 1\n                if r < ind:\n                    continue\n                for ptr in range(max(ind, l), r+1):\n                    temp = set()\n                    for pre in mem[ptr]:\n                        temp.add(pre+val)\n                    mem[ptr] |= temp\n            if ptr_q == m and num not in mem[ind]:\n                return -1\n        return ptr_q\n","author":"yuchanhsiao","submissionId":"1575238933"},[]]},{"1602":[{"id":"1602","fileName":"1575238990.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int m = queries.length, n = nums.length;\n        int logic[][] = new int[m][n];\n\n        for (int i = 0; i < m; ++i) {\n            int start = queries[i][0], end = queries[i][1];\n            for (int j = start; j <= end; ++j)\n                logic[i][j] = queries[i][2];\n        }\n\n        List<Set<Integer>> possibleNums = new ArrayList<Set<Integer>>();\n\n        int count = 0, k = 0;\n        for (int i = 0; i < n; ++i) {\n            Set<Integer> set = new HashSet<Integer>();\n            set.add(nums[i]);\n            possibleNums.add(set);\n            if (nums[i] == 0) count++;\n        }\n        if (count == n) return 0;\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                int num = nums[j];\n                if (logic[i][j] == 0) continue;\n                if (logic[i][j] > num) continue;\n                Set<Integer> set = possibleNums.get(j);\n                if (set.contains(0)) continue;\n                if (set.contains(logic[i][j])) {\n                    count++;\n                    set.add(0);\n                } else {\n                    Set<Integer> newSet = new HashSet<>(set);\n                    for (int x : newSet) {\n                        if (x > logic[i][j])\n                            set.add(x-logic[i][j]);\n                    }\n                }\n            }\n            k++;\n            if (count == n) {\n                return k;\n            }\n        }\n\n        return -1;\n    }\n}","author":"sanmayaj","submissionId":"1575238990"},[]]},{"1603":[{"id":"1603","fileName":"1575239101.txt","sourceCode":"class Solution {\n    bool solve(int sum, vector<int> &arr) {\n        int n = arr.size();\n        \n        vector<vector<bool>> dp(n+1, vector<bool> (sum+1, false));\n        \n        for(int i = 0; i <= n; i++) dp[i][0] = true;\n        \n        for(int i = n-1; i >= 0; i--) {\n            for(int s = 1; s <= sum; s++) {\n                dp[i][s] = dp[i+1][s]; // If we don't take arr[i]\n                if(s >= arr[i]) {\n                    dp[i][s] = dp[i][s] || dp[i+1][s-arr[i]]; // If we take arr[i]\n                }\n                \n                // cout << dp[i][s] << \" \";\n            }\n            // cout << endl;\n        }\n        \n        \n        \n        return dp[0][sum];\n    }\n    bool checker(int Q, vector<vector<int>>& queries, vector<int>& nums) {\n        int n = nums.size();\n        vector<vector<int>> valueMap(n);\n        \n        for(int q = 0; q < Q; q++) {\n            int l = queries[q][0];\n            int r = queries[q][1];\n            int val = queries[q][2];\n            \n            for(int i = l; i <= r; i++) valueMap[i].push_back(val);\n        }\n        \n        // now for all indices try to achive the sum nums[i] using valueMap[i] array\n        \n        for(int i = 0; i < n; i++) {\n            // cout << nums[i] << \" : \";\n            // for(auto &val: valueMap[i]) cout << val << \" \";\n            // cout << endl;\n            if(!solve(nums[i], valueMap[i])) return false;\n        }\n        \n        return true;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        \n        int mx = *max_element(nums.begin(), nums.end());\n        if(mx == 0) return 0;\n        \n        int low = 1, high = queries.size(), ans = -1;\n        \n        // cout << checker(4, queries, nums) << endl;\n        while(low <= high) {\n            int mid = (low + high) >> 1;\n            \n            if(checker(mid, queries, nums)) {\n                ans = mid;\n                high = mid-1;\n            }\n            else {\n                low = mid+1;\n            }\n        }\n        \n        return ans;\n    }\n};","author":"AGAM GUPTA","submissionId":"1575239101"},[]]},{"1604":[{"id":"1604","fileName":"1575239037.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        // Check if all elements are zero\n        boolean allZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) {\n            return 0;\n        }\n\n        int maxM = -1;\n\n        for (int i = 0; i < nums.length; i++) {\n            int target = nums[i];\n            if (target == 0) {\n                continue;\n            }\n\n            // Collect all queries that include i in their range\n            List<int[]> qs = new ArrayList<>();\n            for (int j = 0; j < queries.length; j++) {\n                int[] q = queries[j];\n                int l = q[0], r = q[1];\n                if (i >= l && i <= r) {\n                    qs.add(new int[]{q[2], j}); // store val and original index\n                }\n            }\n\n            if (qs.isEmpty()) {\n                return -1;\n            }\n\n            // Subset sum DP to find the minimal latest original index\n            Map<Integer, Integer> dp = new HashMap<>();\n            dp.put(0, -1);\n\n            for (int[] q : qs) {\n                int val = q[0];\n                int origPos = q[1];\n                Map<Integer, Integer> newDp = new HashMap<>(dp);\n\n                for (Map.Entry<Integer, Integer> entry : dp.entrySet()) {\n                    int s = entry.getKey();\n                    int latest = entry.getValue();\n                    int newSum = s + val;\n                    int newLatest = Math.max(latest, origPos);\n\n                    if (!newDp.containsKey(newSum) || newLatest < newDp.getOrDefault(newSum, Integer.MAX_VALUE)) {\n                        newDp.put(newSum, newLatest);\n                    }\n                }\n\n                dp = newDp;\n            }\n\n            if (dp.containsKey(target)) {\n                int mi = dp.get(target);\n                maxM = Math.max(maxM, mi);\n            } else {\n                return -1;\n            }\n        }\n        return maxM + 1;\n    }\n}","author":"CoreI9","submissionId":"1575239037"},[]]},{"1605":[{"id":"1605","fileName":"1575239060.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        \n        int[] r = new int[nums.length];\n        \n        for(int i = 0; i < nums.length; i ++) {\n            \n            r[i] = -1;\n            \n            boolean[][] A = new boolean[queries.length + 1][nums[i] + 1];\n            A[0][0] = true;\n            if (nums[i] == 0)   \n                r[i] = 0;\n            else {\n                for(int j = 1; j <= queries.length; j ++) {\n\n                    for(int k = 0; k <= nums[i]; k ++) {\n                        if ((i >= queries[j - 1][0]) && (i <= queries[j - 1][1]) && (k >= queries[j - 1][2])) {\n                            A[j][k] = A[j - 1][k] || A[j - 1][k - queries[j - 1][2]];\n                        } else {\n                            A[j][k] = A[j - 1][k];\n                        }\n                    }\n\n                    if (A[j][nums[i]]) {\n                        r[i] = j;\n                        break;\n                    }\n\n                }\n            }\n            \n        }\n        \n        int m = r[0];\n        for(int rr : r) {\n            if (rr == -1)\n                return -1;\n            m = Math.max(rr, m);\n        }\n        return m;\n        \n    }\n}","author":"happyfeetpi","submissionId":"1575239060"},[]]},{"1606":[{"id":"1606","fileName":"1575239197.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        res, n, m = -1, len(nums), len(queries)\n        qs = [[] for _ in range(n)]\n        for q in range(m):\n            l, r, val = queries[q]\n            for i in range(l, r + 1):\n                qs[i].append((q, val))\n        \n        def can_zero(k):\n            for i in range(n):\n                if nums[i] == 0:\n                    continue\n                vals = [val for q, val in qs[i] if q < k]\n                if not vals and nums[i] > 0:\n                    return False\n                target = nums[i]\n                dp = [False] * (target + 1)\n                dp[0] = True\n                for val in vals:\n                    for s in range(target, val - 1, -1):\n                        dp[s] = dp[s] or dp[s - val]\n                if not dp[target]:\n                    return False\n            return True\n        l, r = 0, len(queries)\n        while l <= r:\n            mid = (l + r) // 2\n            if can_zero(mid):\n                res = mid\n                r = mid - 1\n            else:\n                l = mid + 1\n        return res\n                    ","author":"Minghao Li","submissionId":"1575239197"},[]]},{"1607":[{"id":"1607","fileName":"1575239080.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<vector<pair<int, int>>> queries_for_index(n);\n        for (int j = 0; j < m; ++j) {\n            int l = queries[j][0];\n            int r = queries[j][1];\n            int val = queries[j][2];\n            for (int i = l; i <= r; ++i) {\n                queries_for_index[i].emplace_back(val, j);\n            }\n        }\n        int ans = -1;\n        for (int i = 0; i < n; i ++) {\n            if (nums[i] == 0) continue;\n            int target = nums[i];\n            auto& q = queries_for_index[i];\n            if (q.empty()) return -1;\n\n            unordered_set<int> cur = {0};\n            bool found = false;\n            int last_j = -1;\n            \n            for (auto& [val, j] : q) {\n                unordered_set<int> new_sums;\n                for (int s : cur) {\n                    int new_s = s + val;\n                    if (new_s == target) {\n                        found = true;\n                        last_j = j;\n                        break;\n                    }\n                    if (new_s < target) {\n                        new_sums.insert(new_s);\n                    }\n                }\n                if (found) break;\n                for (int s : new_sums) {\n                    cur.insert(s);\n                }\n            }\n            if (!found) return -1;\n            ans = max(ans, last_j);\n        }\n        if (ans == -1) return 0;\n        return ans + 1;\n    }\n};","author":"Prathamesh","submissionId":"1575239080"},[]]},{"1608":[{"id":"1608","fileName":"1575239239.txt","sourceCode":"class Solution {\n    \n    public int minZeroArray(int[] nums, int[][] queries) {\n        int m = nums.length;\n        int qLen = queries.length;\n        // 建立每個 index 對應的 query 列表 (每筆記錄: [queryIndex, vali])\n        List<List<int[]>> posQueries = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            posQueries.add(new ArrayList<>());\n        }\n        // 每個 query 的索引即為其在 queries 陣列中的位置\n        for (int qi = 0; qi < qLen; qi++) {\n            int l = queries[qi][0];\n            int r = queries[qi][1];\n            int val = queries[qi][2];\n            for (int i = l; i <= r; i++) {\n                // 對 index i，加入該 query（其索引與扣除值）\n                posQueries.get(i).add(new int[]{qi, val});\n            }\n        }\n        \n        int overallK = 0;\n        // 對每個 index 做 DP，求從其覆蓋的 query 中能否選出子集合，使扣除值總和恰好等於 nums[i]\n        // 並計算出這個子集合中最大的 query 索引（因為 query 順序不能被打亂）\n        for (int i = 0; i < m; i++) {\n            int target = nums[i];\n            List<int[]> qList = posQueries.get(i);\n            // 依 query 索引排序（雖然原本順序就是 query 順序，但保險起見排序一下）\n            qList.sort((a, b) -> Integer.compare(a[0], b[0]));\n            \n            // dp[s] 表示達成 sum = s 時所使用的 query 中最大的索引，若無法達成則設為 INF\n            int INF = Integer.MAX_VALUE / 2;\n            int[] dp = new int[target + 1];\n            Arrays.fill(dp, INF);\n            dp[0] = -1; // 不使用任何 query時，最大的 query 索引為 -1\n            \n            // 對每一個 query 做更新\n            for (int[] curQuery : qList) {\n                int qi = curQuery[0];\n                int val = curQuery[1];\n                // 為避免重複使用同一個 query，本輪從大到小更新\n                for (int s = target - val; s >= 0; s--) {\n                    if (dp[s] != INF) {\n                        int ns = s + val;\n                        // 使用該 query後，最大的 query 索引為 max(dp[s], qi)\n                        dp[ns] = Math.min(dp[ns], Math.max(dp[s], qi));\n                    }\n                }\n            }\n            \n            // 如果無法剛好扣完該位置的數值，就無法將整個 nums 變為零陣列\n            if (dp[target] == INF) return -1;\n            // 由於 query 是從 0 開始編號，結果應加 1\n            overallK = Math.max(overallK, dp[target] + 1);\n        }\n        \n        return overallK;\n    }\n    \n}","author":"Sorano Lan","submissionId":"1575239239"},[]]},{"1609":[{"id":"1609","fileName":"1575239354.txt","sourceCode":"class Solution {\npublic:\n\nint dp[10][1001][1000];\nint f(int idx,int val,int q,vector<int>& v, vector<vector<int>>& query){\nif(val==v[idx]){\n    return q;}\nif(q==query.size()){return -1;}\nif(dp[idx][val][q]!=0){return dp[idx][val][q];}\nif(val>v[idx]){return -1;}\nint k=f(idx,val,1+q,v,query);\nint l=query[q][0],r=query[q][1];\nif(l<=idx&&r>=idx){\n    int k2=f(idx,val+query[q][2],1+q,v,query);\n    if(k==-1||(k2!=-1&&k2<k)){k=k2;}\n}\n\n\nreturn dp[idx][val][q]=k;\n\n}\nint minZeroArray(vector<int>& v, vector<vector<int>>& q) {\n    map<int,vector<int>>mp;\n    for(int i=0;i<q.size();i++){\nint l=q[i][0],r=q[i][1];\nfor(int j=l;j<=r;j++){mp[j].push_back(i);}\n\n    }\n    memset(dp,0,sizeof(dp));\nint ans=-1;\nfor(int i=0;i<v.size();i++){\nint k=f(i,0,0,v,q);\nif(k==-1){return -1;}\nans=max(ans,k);\n}\n    return ans;\n        }\n      \n};","author":"Nilangshu Ghosh","submissionId":"1575239354"},[]]},{"1610":[{"id":"1610","fileName":"1575239465.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int ans = -1;\n        int[][] memoArr = new int[nums.length][1003];\n        int zeros = 0;\n        for(int i=0;i<nums.length;i++) {\n            if(nums[i]==0) {\n                ++zeros;\n            }\n        }\n        if(zeros==nums.length) {\n            return 0;\n        }\n        for(int i=0;i<queries.length;i++) {\n            int[] query = queries[i];\n            for(int j=query[0];j<=query[1];j++) {\n                if(nums[j]==0) {\n                    continue;\n                }\n                int[] memo = memoArr[j];\n                //0->false\n                //1->intermediateTrue\n                //2->true\n                int inc = query[2];\n                memo[nums[j]] = 2;\n                for(int k=nums[j]-1;k>=0;k--) {\n                    if(memo[k]==0 && (k+inc)<=nums[j] && memo[k+inc]==2) {\n                        memo[k] = 1;\n                    }\n                }\n                for(int k=nums[j];k>=0;--k) {\n                    if(memo[k]==1) {\n                        memo[k]=2;\n                    }\n                }\n                if(memo[0]==2) {\n                    nums[j] = 0;\n                }\n            }\n\n            int numOfZeroes = 0;\n            for(int t=0;t<nums.length;t++) {\n                if(nums[t]==0) {\n                    ++numOfZeroes;\n                }\n            }\n            if(numOfZeroes == nums.length) {\n                return i+1;\n            }\n        }\n        return ans;\n    }\n}","author":"bals","submissionId":"1575239465"},[]]},{"1611":[{"id":"1611","fileName":"1575239525.txt","sourceCode":"class Solution {\npublic:\n    bool canAchieve(int k, const vector<vector<int>>& queries, const vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            vector<bool> dp(target + 1, false);\n            dp[0] = true;\n            for (int j = 0; j < k; j++) {\n                if (queries[j][0] <= i && i <= queries[j][1]) {\n                    int v = queries[j][2];\n                    for (int s = target - v; s >= 0; s--) {\n                        if (dp[s]) {\n                            dp[s + v] = true;\n                        }\n                    }\n                }\n            }\n            if (!dp[target]) return false;\n        }\n        return true;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int m = queries.size();\n        \n        vector<int> numsCopy = nums;\n        \n        int left = 0, right = m, answer = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (canAchieve(mid, queries, numsCopy)) {\n                answer = mid;\n                right = mid - 1; \n            } else {\n                left = mid + 1;\n            }\n        }\n        return answer;\n    }\n};\n","author":"Rodier","submissionId":"1575239525"},[]]},{"1612":[{"id":"1612","fileName":"1575239331.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        k = [-1]*len(nums)\n        for j in range(len(nums)):\n            if nums[j] == 0:\n                k[j] = 0\n        \n        for j in range(len(nums)):\n            n = nums[j]\n            m = {n}\n            tempM = set()\n            found = False\n            for i in range(len(queries)):\n                #print(\"i\",n,i)\n                #print(m)\n                start, end, val = queries[i]\n                if start <= j <= end:\n                    for v in m:\n                        if v-val == 0:\n                            k[j] = i+1\n                            found = True\n                        elif v-val > 0:\n                            tempM.add(v-val)\n                #print(\"t\",tempM)\n                if found:\n                    #print(\"found\", m, tempM)\n                    break\n                m.update(tempM)\n                #print(\"m\",m)\n        for n in k:\n            if n == -1:\n                return -1\n        return max(k)\n                    ","author":"slowoldman","submissionId":"1575239331"},[]]},{"1613":[{"id":"1613","fileName":"1575239450.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        set<int> arr[n];\n        bool done[n];\n        int rem=0;\n        for(int i=0;i<n;i++){\n            if(nums[i]==0){\n                done[i]=1;\n            }\n            else {\n                done[i]=0;\n                rem++;\n            }\n        }\n        cout<<rem<<endl;\n        if(rem==0){\n            return 0;\n        }\n        for(int i=0;i<n;i++){\n            arr[i].insert(0);\n        }\n        int qs=queries.size();\n        for(int i=0;i<qs;i++){\n            int l=queries[i][0];\n            int r=queries[i][1];\n            int v=queries[i][2];\n            while(l<=r){\n                if(!done[l]){\n                    auto it=--arr[l].end();\n                    while(it!=arr[l].begin()){\n                        int num=(*it)+v;\n                        if(num==nums[l]){\n                            done[l]=1;\n                            rem--;\n                            break;\n                        }\n                        arr[l].insert(num);\n                        it--;\n                    }\n                    if(!done[l]){\n                        int num=(*it)+v;\n                        if(num==nums[l]){\n                            done[l]=1;\n                            rem--;\n                        }\n                        arr[l].insert(num);\n                    }\n                }\n                if(rem==0){\n                    return 1+i;\n                }\n                // for(int temp:arr[l]){\n                //     cout<<temp<<\" \";\n                // }\n                // cout<<rem<<\" \"<<l<<\" \"<<i<<endl;\n                l++;\n            }\n        }\n        return -1;\n    }\n};","author":"rkrohit123","submissionId":"1575239450"},[]]},{"1614":[{"id":"1614","fileName":"1575239586.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int f=0;\n        int maxval=Integer.MAX_VALUE;\n        int nlength = nums.length;\n        Node<List<Integer>, List<int[]>> lstp = new Node<>(helper5(nums), helper6(queries));\n        BitSet[] arr = new BitSet[nlength];\n        for (int i = 0; i < nlength; i++) {\n            arr[i] = new BitSet(1010);\n            arr[i].set(0);\n        }\n        if (helper2(nums)) return 0;\n        int mlen = queries.length;\n        for (int i = 0; i < mlen; i++) \n        {\n            int val1 = queries[i][1];\n            int val2 = queries[i][0];\n            int val3 = queries[i][2];\n            for (int j =val2;j<= val1;j++) {\n                arr[j].or(helper3(arr[j], val3));\n                arr[j].clear(nums[j] + 1, 1010);\n            }\n            if (helper4(nums, arr) && maxval==Integer.MAX_VALUE) return i + 1;\n        }\n       if(f==0) return -1;\n        else return 0;\n    }\n    public List<Integer> helper5(int[] varr) \n    {\n        List<Integer> list = new ArrayList<>();\n        for (int i=0;i<varr.length;i++)\n        {\n            list.add(varr[i]);\n        }\n        return list;\n    }\n    public List<int[]> helper6(int[][] varr) \n    {\n        return Arrays.asList(varr);\n    }\n    public boolean helper2(int[] varr) \n    {\n        for (int i=0;i<varr.length;i++)\n            {\n            if (varr[i] != 0) return false;\n        }\n        return true;\n    }\n    public BitSet helper3(BitSet bs, int shiftval3) {\n        BitSet sft = new BitSet(1010);\n        for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) \n        {\n            if (i + shiftval3 <= 1000) {\n                sft.set(i + shiftval3);\n            }\n        }\n        return sft;\n    }\n    public boolean helper4(int[] nums, BitSet[] arr)\n    {\n        int n=nums.length;\n        for (int i =0; i<n; i++) \n        {\n            if (!arr[i].get(nums[i])) return false;\n        }\n        return true;\n    }\n    class Node<A,B>\n    {\n    public final A one;\n    public final B two;\n    public Node(A one, B two) \n    {\n        this.one = one;\n        this.two = two;\n    }\n  }\n}","author":"Ashik","submissionId":"1575239586"},[]]},{"1615":[{"id":"1615","fileName":"1575239461.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if nums.count(0) == len(nums):\n            return 0\n        left, right = 0, len(queries) - 1\n        ans = -1\n        def posSum(index, target, lst, dp)-> bool:\n            if target == 0:\n                return True\n            if index == len(lst):\n                return False\n            if dp[index][target] != -1:\n                return dp[index][target]\n            sub = lst[index][0]\n            ans = False\n            for j in range(lst[index][1]):\n                if sub > target:\n                    break\n                ans = ans or posSum(index + 1, target - sub, lst, dp)\n                sub += lst[index][0]\n                if ans:\n                    break \n            if not ans:\n                ans = posSum(index + 1, target, lst, dp)\n            dp[index][target] = ans\n            return ans\n        \n        def check(add, remove)-> bool:\n            lst = defaultdict(int)\n            for i in range(len(nums)):\n                for key in add[i]:\n                    lst[key] += add[i][key]\n                for key in remove[i]:\n                    lst[key] -= remove[i][key]\n                dp = [[-1 for target in range(nums[i] + 1)] for index in range(len(lst))]\n                if not posSum(0, nums[i], list(lst.items()), dp):\n                    return False\n            return True\n        \n        def zeroArray(mid):\n            add = [defaultdict(int) for i in range(len(nums))]\n            remove = [defaultdict(int) for i in range(len(nums) + 1)]\n            for i in range(mid + 1): \n                l, r, val = queries[i]\n                add[l][val] += 1\n                remove[r + 1][val] += 1\n            return check(add, remove)\n            \n        while left <= right:\n            mid = left + (right - left) // 2\n            if zeroArray(mid): \n                ans = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        if ans == -1:\n            return ans\n        return ans + 1","author":"Vrinda Singhal","submissionId":"1575239461"},[]]},{"1616":[{"id":"1616","fileName":"1575239541.txt","sourceCode":"class Solution {\n    int isSubsetSum(vector<int>& arr, int target) {\n        // cout<<\"Call\"<<endl;\n        int n= arr.size();\n        if(n == 0)\n            return target == 0;\n        \n        vector<vector<bool>> dp(n,vector<bool>(target+1,0));\n        // cout<<\"Np\";\n        for(int i=0;i<n;i++){\n            dp[i][0]=true;\n        }\n        // cout<<\"Npn\";\n        // for(auto i : arr)\n        //     cout<<i<<\" \";\n        // cout<<endl;\n        dp[0][arr[0]]=true;\n        if(dp[0][target])\n            return 0;\n        // cout<<\"Np\";\n  \n        for(int i=1;i<n;i++){\n            for(int t =1 ;t<target+1;t++){\n                bool nottake= dp[i-1][t];\n                bool take = false;\n                if(t>=arr[i]) take = dp[i-1][t -arr[i]];\n                dp[i][t]= take || nottake;\n            }\n            if(dp[i][target])\n                return i; \n        }\n        \n        return -1;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> op(n), values(n);\n        int zeroes = count(begin(nums), end(nums), 0);\n        if(zeroes == n)\n            return 0;\n        \n        for(int i = 0; i < queries.size(); i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n\n            for(int j = l; j <= r; j++) {\n                op[j].push_back(val);\n                values[j].push_back(i+1);\n            }\n        }\n        int maxOp = 0;\n        for(int i = 0; i < n; i++) {\n            if(op[i].empty()) {\n                if(nums[i] != 0)\n                    return -1;\n                continue;\n            }\n            int ans = isSubsetSum(op[i], nums[i]);\n            // cout<<\"Call end\"<<endl;\n            if(ans == -1)\n                return -1;\n            maxOp = max(maxOp, values[i][ans]);\n        }\n\n        return maxOp;\n    }\n};","author":"Yaswanth Reddy","submissionId":"1575239541"},[]]},{"1617":[{"id":"1617","fileName":"1575239556.txt","sourceCode":"class Solution {\nprivate:\n    bool isSubsetSum(vector<int> &arr, int sum) {\n        int n = arr.size();\n        vector<bool> prev(sum + 1, false), curr(sum + 1);\n\n        prev[0] = true;\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= sum; j++) {\n                if (j < arr[i - 1])\n                    curr[j] = prev[j];\n                else\n                    curr[j] = (prev[j] || prev[j - arr[i - 1]]);\n            }\n            prev = curr;\n        }\n        return prev[sum];\n    }\n\n    bool predicate(vector<int>& nums, vector<vector<int>>& queries, int k) {\n        vector<pair<int, int>> addQ;\n        vector<pair<int, int>> removeQ;\n\n        for (int i=0 ; i<k ; i++) {\n            vector<int> query = queries[i];\n            addQ.push_back({query[0], query[2]});\n            removeQ.push_back({query[1]+1, query[2]});\n        }\n\n        sort(addQ.begin(), addQ.end());\n        sort(removeQ.begin(), removeQ.end());\n\n        auto aitr = addQ.begin();\n        auto ritr = removeQ.begin();\n        vector<int> cur;\n        for (int i=0 ; i<nums.size() ; i++) {\n            while(aitr != addQ.end() && aitr->first <= i) {\n                cur.push_back(aitr->second);\n                aitr++;\n            }\n            while(ritr != removeQ.end() && ritr->first <= i) {\n                auto it = find(cur.begin(), cur.end(), ritr->second);\n                cur.erase(it);\n                ritr++;\n            }\n\n            // for (int c : cur) {\n            //     cout << c << \" \";\n            // }cout << endl;\n\n            if (!isSubsetSum(cur, nums[i]))\n                return false;\n        }\n        return true;\n    }\n\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l = 0;\n        int r = queries.size() + 1;\n\n        // predicate(nums, queries, queries.size());\n        \n        while (l < r) {\n            int m = l + ((r - l) >> 1);\n            if (!predicate(nums, queries, m))\n                l = m + 1;\n            else\n                r = m;\n        }\n\n        return l >= queries.size() + 1 ? -1 : l;\n    }\n};","author":"eugenechouy","submissionId":"1575239556"},[]]},{"1618":[{"id":"1618","fileName":"1575239697.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& queries) {\n        int m = a.size();\n        int dp[11][1010];\n        memset(dp, -1, sizeof(dp));\n        int cnt = 0;\n        for (int i=0; i<m; i++)\n            if (a[i] == 0)\n                cnt++;\n        if (cnt == m) return 0;\n        for (int i=0; i<m; i++)\n            dp[i][0] = 1;\n        for (int i=0; i<queries.size(); i++) {\n            int start = queries[i][0];\n            int end = queries[i][1];\n            int v = queries[i][2];\n            for (int j=start; j<=end; j++) {\n                for (int k=1000; k>=0; k--) {\n                    if (v+k<1005 && dp[j][k] != -1)\n                        dp[j][v+k] = 1;\n                }\n            }\n            bool is_ok = true;\n            for (int j=0; j<m; j++)\n                if (dp[j][a[j]] == -1)\n                    is_ok = false;\n            if (is_ok) return i+1;\n        }\n        return -1;\n    }\n};","author":"ydnl","submissionId":"1575239697"},[]]},{"1619":[{"id":"1619","fileName":"1575239549.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        prefix = [[] for i in range(len(nums))]\n        mem = defaultdict(list)\n        for i in range(len(queries)+1):\n            if i != 0:\n                left, right, val = queries[i-1]\n                prefix[left].append(val)\n                if right + 1 < len(prefix):\n                    prefix[right + 1].append(-val)\n            if self.validate(queries, i, prefix, nums, mem):\n                return i\n\n        return -1\n\n    def validate(self, queries, k, prefix, nums, mem):\n        num_counts = defaultdict(int)\n        #print(prefix)\n        \n        for i in range(len(nums)):\n            poss = set([0])\n            for p in prefix[i]:\n                if p > 0:\n                    num_counts[p] += 1\n                else:\n                    num_counts[-p] -= 1\n            arr = []\n            for n in num_counts:\n                for j in range(num_counts[n]):\n                    arr.append(n)\n            #print(arr)\n            \n            for n in num_counts:\n                adds = set()\n                for x in range(num_counts[n]):\n                    if (x + 1) * n <= nums[i]:\n                        adds.add((x + 1) * n)\n                b = set(adds)\n                for z in poss:\n                    for a in adds:\n                        if z + a <=  nums[i]:\n                            b.add(z + a)\n                poss |= b\n                # if nums[i] in poss:\n                #     return True\n            #print(poss)\n            if nums[i] not in poss:\n                return False\n        return True\n                \n        #     if not self.valid_sum(nums[i], num_counts, mem, defaultdict(int), nums[i]):\n        #         return False\n        # return True\n\n    def valid_sum(self, target, nums, mem, cur, orig_targ):\n        if target < 0:\n            return False\n        if target == 0:\n            mem[orig_targ].append(cur)\n            return True\n        \n        if target in mem:\n            combs = mem[target]\n            for comb in combs:\n                found = True\n                for n in comb:\n                    if nums[n] < comb[n]:\n                        found = False\n                        break\n                if found:\n                    return True\n\n        for num in nums:\n            if nums[num] > 0:\n                nums[num] -= 1\n                cur[num] += 1\n                res = self.valid_sum(target - num, nums, mem, cur, orig_targ)\n                nums[num] += 1\n                if res:\n                    return res\n                cur[num] -= 1\n                \n\n        return False\n                    \n                    \n\n    \n        ","author":"Jason Wang","submissionId":"1575239549"},[]]},{"1620":[{"id":"1620","fileName":"1575239808.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        bool allZero = true;\n        for(auto &i:nums){\n            if(i != 0){\n                allZero = false;\n                break;\n            }\n        }\n        if(allZero) return 0;\n        int start = 1;\n        int end = queries.size();\n        int ans = -1;\n        while(start<=end){\n            int mid = start + ((end-start)/2);\n            bool res = doSomething(mid,nums,queries);\n            if(res){\n                if(ans==-1){\n                    ans = mid;\n                }else{\n                    ans = min(mid,ans);\n                }\n                end = mid-1;\n            }else{\n                start = mid+1;\n            }\n        }\n        return ans;\n    }\n\n    bool doSomething(int mid,vector<int>& nums, vector<vector<int>>& queries){\n        vector<vector<int>> v(nums.size());\n        for(int i=0;i<mid;i++){\n            for(int j=queries[i][0];j<=queries[i][1];j++){\n                v[j].push_back(queries[i][2]);\n            }\n        }\n        for(int i=0;i<nums.size();i++){\n            // unordered_map<string, bool> memo;\n            // if(!combinationEqualsSum(v[i].size()-1,nums[i],v[i],memo)){\n            //     return false;\n            // }\n            if(!subsetSum(v[i],nums[i])){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool subsetSum(vector<int>& vals, int target) {\n        vector<bool> dp(target + 1, false);\n        dp[0] = true; // Base case: sum of 0 is always possible\n    \n        for (int val : vals) {\n            for (int j = target; j >= val; --j) {  // Fill DP array in reverse\n                dp[j] = dp[j] || dp[j - val];\n            }\n        }\n        return dp[target];\n    }\n\n    bool combinationEqualsSum(int index, int sum, vector<int>& val, unordered_map<string, bool>& memo) {\n        if (sum == 0) return true;\n        if (index < 0) return false;\n        if (index == 0) return val[0] == sum;\n        string key = to_string(index) + \"_\" + to_string(sum);\n        if (memo.find(key) != memo.end()) return memo[key];\n    \n        bool exclude = combinationEqualsSum(index - 1, sum, val, memo);\n    \n        bool include = false;\n        if (val[index] <= sum) {\n            include = combinationEqualsSum(index - 1, sum - val[index], val, memo);\n        }\n    \n        return memo[key] = (include || exclude);\n    }\n\n};","author":"Ankit_Strange","submissionId":"1575239808"},[]]},{"1621":[{"id":"1621","fileName":"1575239614.txt","sourceCode":"class Solution:\n    def sss(self, target, arr):\n        n = len(arr)\n        if n == 0:\n            return False\n        dp = [[False] * (target + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = True\n    \n        for i in range(1, n + 1):\n            for j in range(1, target + 1):\n                if j < arr[i - 1]:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n    \n        return dp[n][target]\n        \n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        l = len(nums)\n        ql = []\n        qi = 0\n        for i in range(l):\n            n = nums[i]\n            if n == 0:\n                continue\n            while True:\n                sql = []\n                for l, r, val in ql:\n                    if l <= i <= r:\n                        sql.append(val)\n                if self.sss(n, sql):\n                    break\n                if qi >= len(queries): return -1   \n                ql.append(queries[qi])\n                qi += 1\n        return len(ql)\n\n                \n                \n","author":"dkavinsky96","submissionId":"1575239614"},[]]},{"1622":[{"id":"1622","fileName":"1575239899.txt","sourceCode":"\nclass Solution(object):\n    def minZeroArray(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        m = len(queries)\n        \n        self.d = dict()\n        def backtracking(curr, idx, cq, queries, m):\n            key = (curr, idx, cq)\n            \n            # print(curr, idx, cq)\n            if curr == 0:\n                return cq - 1\n            if cq == m:\n                return m + 1\n            if key in self.d:\n                return self.d[key]\n            \n            l = queries[cq][0]\n            r = queries[cq][1]\n            v = queries[cq][2]\n            ans = m + 1\n\n            \n            \n            ans = min(ans, backtracking(curr, idx, cq + 1, queries, m))\n            if (l <= idx <= r) and curr - v >= 0 :\n                ans = min(ans, backtracking(curr - v, idx, cq + 1, queries, m))\n\n            self.d[key] = ans\n            return ans\n\n\n        ans = -1\n\n        for i in range(n):\n            if nums[i] != 0:\n                k = backtracking(nums[i], i, 0, queries, m)\n            else:\n                k = -1\n            # print(\"o\",k)\n            if k == m + 1 and nums[i] != 0:\n                return -1\n            \n            ans = max(ans, k)\n\n\n        return -1 if ans == m + 1 else ans + 1\n            \n                \n                \n                    \n                ","author":"Sagnik Sen Sarma","submissionId":"1575239899"},[]]},{"1624":[{"id":"1624","fileName":"1575239751.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number}\n */\nvar minZeroArray = function (nums, queries) {\n    const set = new Set();\n    const possibleValues = Array(nums.length);\n    for (let i = 0; i < nums.length; i++) {\n        possibleValues[i] = new Set();\n    }\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] === 0) {\n            set.add(i);\n            continue;\n        }\n        possibleValues[i].add(nums[i]);\n    }\n    if (set.size === nums.length) return 0;\n\n    for (let i = 0; i < queries.length; i++) {\n        const [l, r, val] = queries[i];\n        for (let j = l; j <= r; j++) {\n            if (set.has(j)) {\n                continue;\n            }\n\n            const iterator = possibleValues[j].values();\n            const size = possibleValues[j].size;\n            let k = 0;\n            while (k < size) {\n                k++\n                const { value } = iterator.next();\n                if (value === val) {\n                    set.add(j);\n                    if (set.size === nums.length) return i + 1;\n                    break;\n                }\n\n                if (value > val) {\n                    possibleValues[j].add(value - val);\n                }\n            }\n        }\n    }\n\n    return -1;\n};\n","author":"Duandz","submissionId":"1575239751"},[]]},{"1625":[{"id":"1625","fileName":"1575240098.txt","sourceCode":"class Solution {\npublic:\n    bool isPossible2(vector<int>&counter,int val,int i,vector<vector<int>>&dp){\n        //is it possible to make val out of counter\n        if(i>=counter.size()) return false;\n        if(dp[val][i]!=-1) return dp[val][i];\n        for(int cnt=0;cnt<=counter[i];cnt++){\n            if(cnt*i<val){\n                bool temp=isPossible2(counter,val-cnt*i,i+1,dp);\n                if(temp) return dp[val][i]=true;\n            }\n            else if(cnt*i==val){\n                return dp[val][i]=true;\n            }\n        }\n        return dp[val][i]=false;\n    }\n    bool isPossible(vector<int>&nums,vector<vector<int>>& queries,int mid){\n        \n        vector<vector<int>>counter(nums.size(),vector<int>(11,0));\n        for(int i=0;i<mid;i++){\n            int l=queries[i][0];int r=queries[i][1];int val=queries[i][2];\n            for(int st=l;st<=r;st++){\n                counter[st][val]++;\n            }\n        }\n        for(int i=0;i<nums.size();i++){\n            vector<vector<int>>dp(nums[i]+1,vector<int>(11,-1));\n            if(isPossible2(counter[i],nums[i],0,dp)){\n                \n            }\n            else return false;\n        }\n        return true;\n        \n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int s=0,e=queries.size();\n        int mid= s+(e-s)/2;\n        int store=-1;\n        while(s<=e){\n            // cout<<s<<\" \"<<e<<\" \"<<mid<<endl;\n            if(isPossible(nums,queries,mid)){\n                store=mid;\n                e=mid-1;\n            }\n            else{\n                s=mid+1;\n            }\n            mid=s+(e-s)/2;\n        }\n        return store;\n    }\n};","author":"Aayush Singh","submissionId":"1575240098"},[]]},{"1626":[{"id":"1626","fileName":"1575240838.txt","sourceCode":"class Solution {\npublic:\n    // bool helper(int curIdx, vector<int>& nums, int target) {\n    //     if (target == 0) {\n    //         return true;\n    //     } else if (curIdx == nums.size() || target < 0) {\n    //         return false;\n    //     }\n\n    //     return helper(curIdx + 1, nums, target - nums[curIdx]) || helper(curIdx + 1, nums, target);\n    // }\n\n    bool canSumToTarget(multiset<int>& numSet, int target) {\n        unordered_set<int> possibleSumSet;\n        possibleSumSet.insert(target);\n        \n        multiset<int>::iterator it;\n        for (it = numSet.begin(); it != numSet.end(); ++it) {\n            if (possibleSumSet.count(*it) > 0) {\n                return true;\n            }\n\n            unordered_set<int> tmp = possibleSumSet;\n            unordered_set<int>::iterator it1;\n            for (it1 = possibleSumSet.begin(); it1 != possibleSumSet.end(); ++it1) {\n                tmp.insert(*it1 - *it);\n            }\n\n            possibleSumSet = tmp;\n        }\n        \n        return false;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        multiset<int> opeSet;\n        unordered_map<int, multiset<int>> addMap, deleteMap;\n        int queryIdx = 0;\n\n        for (int i = 0; i < nums.size(); i++) {\n            if (!addMap[i].empty()) {\n                opeSet.insert(addMap[i].begin(), addMap[i].end());\n            }\n            \n            if (!deleteMap[i].empty()) {\n                multiset<int>::iterator it;\n                for (it = deleteMap[i].begin(); it != deleteMap[i].end(); ++it) {\n                    opeSet.erase(opeSet.find(*it));\n                }\n            }\n            \n            if (nums[i] > 0) {\n                while (!canSumToTarget(opeSet, nums[i])) {\n                    if (queryIdx == queries.size()) {\n                        return -1;\n                    }\n                    \n                    int left = queries[queryIdx][0];\n                    int right = queries[queryIdx][1];\n                    int value = queries[queryIdx][2];\n\n                    if (left > i) {\n                        addMap[left].insert(value);\n                        deleteMap[right + 1].insert(value);\n                    } else if (i <= right) {\n                        opeSet.insert(value);\n                        deleteMap[right + 1].insert(value);\n                    }\n\n                    queryIdx++;\n                }\n            }\n        }\n        \n        return queryIdx;\n    }\n};","author":"NTU_Anonymous","submissionId":"1575240838"},[]]},{"1627":[{"id":"1627","fileName":"1575240205.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n\n        int zeros = 0;\n        var vs = new boolean[n];\n        Set<Integer>[] dp = new Set[n];\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) {\n                vs[i] = true;\n                zeros++;\n            } else {\n                dp[i] = new HashSet<>();\n                dp[i].add(nums[i]);\n            }\n        }\n\n        if (zeros == n) return 0;\n\n        int answ = 0;\n        for (var q : queries) {\n            for (int i = q[0]; i <= q[1]; i++) {\n                if (vs[i]) continue;\n                var arr = dp[i].toArray(new Integer[0]);\n                for (var num : arr) {\n                    int res = num - q[2];\n                    if (res == 0) {\n                        vs[i] = true;\n                        zeros++;\n                        break;\n                    } else if (res > 0) {\n                        dp[i].add(res);\n                    }\n                }\n            }\n            answ++;\n            if (zeros == n) break;\n        }\n\n        return zeros == n ? answ : -1;\n    }\n}","author":"abdullojony","submissionId":"1575240205"},[]]},{"1628":[{"id":"1628","fileName":"1575240645.txt","sourceCode":"class Solution {\npublic:\n\n    long long func(long long i,long long sum,vector<long long> &wow,vector<vector<long long>> &dp){\n        if(i==wow.size()){\n            return sum==0;\n        }\n        if(dp[i][sum]!=-1) return dp[i][sum];\n        long long x1=0,x2=0;\n        if(sum>=wow[i]){\n            x1=func(i+1,sum-wow[i],wow,dp);\n        }\n        x2=func(i+1,sum,wow,dp);\n        return dp[i][sum]=max(x1,x2);\n    }\n\n    int minZeroArray(vector<int>& v, vector<vector<int>>& q) {\n        long long i,j,sum=0,ans=-1;\n        long long n=v.size();\n        long long m=q.size();\n\n        long long low=0;\n        long long high=m-1;\n        long long mid;\n\n        for(i=0;i<n;i++){\n            if(v[i]==0) sum++;\n        }\n        if(sum==n) return 0;\n        sum=0;\n        while(low<=high){\n            sum=0;\n            mid=(low+high)/2;\n                \n            for(i=0;i<n;i++){\n                if(v[i]==0){\n                    sum++;\n                    continue;\n                }\n                vector<long long> wow;\n                for(j=0;j<=mid;j++){\n                    if(i>=q[j][0] && i<=q[j][1]) wow.push_back(q[j][2]);\n                }\n                if(wow.size()==0) continue;\n                sort(wow.begin(),wow.end());\n                if(wow[0]>v[i]) continue;\n                vector<vector<long long>> dp(wow.size(),vector<long long> (v[i]+1,-1));\n                sum+=func(0,v[i],wow,dp);\n            }\n\n            if(sum==n){\n                ans=mid+1;\n                high=mid-1;\n            }\n            else{\n                low=mid+1;\n            }\n        }\n        \n        // if(ans==0) ans--;\n        return ans;\n    }\n};","author":"PDXTITAN","submissionId":"1575240645"},[]]},{"1629":[{"id":"1629","fileName":"1575240788.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        nq = len(queries)\n        if self.checkZero(nums, queries, nq) == False:\n            return -1\n        left = 0\n        right = nq\n        while left < right:\n            mid = left + (right - left)//2\n            if self.checkZero(nums, queries, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n    \n    def checkZero(self, nums: List[int], queries: List[List[int]], k) -> bool:\n        d = []\n        for i in range(len(nums)):\n            d.append([0]*11)\n        for i in range(k):\n            q = queries[i]\n            for j in range(q[0], q[1]+1):\n                d[j][q[2]] += 1\n        for i in range(len(nums)):\n            tar = nums[i]\n            if tar == 0:\n                continue\n            val = d[i]\n            if max(val) == 0:\n                return False\n            if self.check_combine(tar, val):\n                continue\n            else:\n                return False\n        return True\n    \n    def check_combine(self, tar: int, val: List[int]) -> bool:\n        if tar <= 10:\n            if val[tar] > 0:\n                return True\n        max_sum = sum(val[i]*i for i in range(len(val)))\n        if max_sum < tar:\n            return False\n        for i in range(10, 0, -1):\n            if tar < i:\n                continue\n            if val[i] > 0:\n                tar -= i\n                val[i] -= 1\n                if self.check_combine(tar, val):\n                    return True\n                tar += i\n                val[i] += 1\n        return False","author":"jinnlu","submissionId":"1575240788"},[]]},{"1630":[{"id":"1630","fileName":"1575240882.txt","sourceCode":"#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    unordered_map<int, int> memo;\n\n    int helper(int sum, vector<int>& a, int ind) {\n        if (sum == 0) return 0;\n        if (ind >= a.size()) return 1e7;\n\n        int key = sum * 1000 + ind; \n        if (memo.count(key)) return memo[key];\n\n        int cnt = 1e7;\n        if (sum >= a[ind]) {\n            cnt = min(cnt, 1 + helper(sum - a[ind], a, ind + 1));\n        }\n        cnt = min(cnt, 1+helper(sum, a, ind + 1));\n\n        return memo[key] = cnt;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size();\n        vector<vector<int>> v(n,vector<int>(q));\n\n        for (int j = 0; j < q; j++) {\n            int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n            for (int i = 0; i <n; i++) {\n                if(i>=l && i<=r)v[i][j]=val;\n                else v[i][j]=0;\n            }\n        }\n\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            memo.clear();\n            ans = max(ans, helper(nums[i], v[i], 0));\n        }\n\n        return (ans > q) ? -1 : ans;\n    }\n};\n","author":"hehehe1111","submissionId":"1575240882"},[]]},{"1631":[{"id":"1631","fileName":"1575240906.txt","sourceCode":"class Solution {\npublic:\n    vector<vector<int>> denomination;\n    int dp[11][1001][1001];\n    bool isPossible(int i, int target, int n) {\n        if (target == 0) return true;\n        if (n == 0) return false;\n        if(dp[i][target][n]!=-1)\n            return dp[i][target][n];\n        if (denomination[i][n - 1] > target) {\n            return dp[i][target][n] = isPossible(i,target, n - 1);\n        }\n        return dp[i][target][n] = isPossible(i,target, n - 1) || isPossible(i,target - denomination[i][n - 1], n - 1);\n    }\n    bool check(int mid,vector<int>& nums){\n        int n = nums.size();\n        for(int i=0;i<n;i++)\n            if(isPossible(i,nums[i],mid+1)==false)\n                return false;\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        if(accumulate(nums.begin(),nums.end(),0)==0)\n            return 0;\n        int q = queries.size(), n = nums.size();\n        denomination.resize(n);\n        memset(dp,-1,sizeof(dp));\n        for(int i=0;i<q;i++){\n            for(int j=0;j<n;j++)\n                if(j>=queries[i][0] and j<=queries[i][1])\n                    denomination[j].push_back(queries[i].back());\n                else\n                    denomination[j].push_back(0);\n        }\n        int l = 0, h = q-1;\n        while(l<=h){\n            int mid = (l+h)/2;\n            if(check(mid,nums))\n                h = mid - 1;\n            else\n                l = mid + 1;\n        }\n        if(l==q)\n            l=-2;\n        return l+1;\n    }\n};","author":"Saurav","submissionId":"1575240906"},[]]},{"1632":[{"id":"1632","fileName":"1575240839.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        \n        def target_sum(target,arr,dp):\n\n            \n            \n            def f(i,amount,dp):\n                if amount<0: return float(\"inf\")\n                \n                if i == len(arr) and amount!=0: return float(\"inf\")\n                if amount == 0: return i\n                if (i,amount) in dp: return dp[(i,amount)]\n                \n                # take/not take logic\n                dp[(i,amount)] = min(f(i+1,amount-arr[i],dp),f(i+1,amount,dp))\n                return dp[(i,amount)]\n            return f(0,target,dp)\n\n        ans = float(\"-inf\")\n        n = len(nums)\n        for i in range(n):\n            target = nums[i]\n            arr = []\n            for query in queries:\n                l,r,v = query\n                if i>=l and i<=r:\n                    arr.append(v)\n                else:\n                    arr.append(0)\n            dp = {}\n            queries_needed = target_sum(target,arr,dp)\n            ans = max(ans,queries_needed)\n        return ans if ans!=float(\"inf\") else -1\n            \n                    \n                \n                ","author":"Utsav Jha","submissionId":"1575240839"},[]]},{"1633":[{"id":"1633","fileName":"1575240978.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if all(x == 0 for x in nums):\n            return 0\n    \n        n = len(nums)\n        m = len(queries)\n        \n        # check if we can make nums zero with first k query\n        def can_zero(k):\n            for j in range(n):\n                target = nums[j]\n                dp = [False] * (target + 1)\n                dp[0] = True\n                for i in range(k):\n                    l, r, val = queries[i]\n                    if l <= j <= r:\n                        for s in range(target, val - 1, -1):\n                            if dp[s - val]:\n                                dp[s] = True\n                if not dp[target]:\n                    return False\n            return True\n    \n        left, right = 1, m + 1\n        ans = -1\n        while left < right:\n            mid = (left + right) // 2\n            if can_zero(mid):\n                ans = mid\n                right = mid\n            else:\n                left = mid + 1\n    \n        return ans if ans != -1 else -1","author":"Haikyo","submissionId":"1575240978"},[]]},{"1634":[{"id":"1634","fileName":"1575241071.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> first(n, -1);\n        vector<vector<bool>> dp(n);\n        for (int i = 0; i < n; i++) {\n            dp[i].resize(nums[i] + 1, false);\n            dp[i][0] = true;\n             if (nums[i] == 0)\n                first[i] = 0;\n        }\n        int q = queries.size();\n        for (int i = 0; i < q; i++) {\n            int n1 = queries[i][0], n2 = queries[i][1], value = queries[i][2];\n            for (int j = n1; j <= n2; j++) {\n                if (first[j] != -1)\n                    continue;\n                int t = nums[j];\n\n                for (int k = t - value; k >= 0; k--) {\n                    if (dp[j][k] && !dp[j][k + value]) {\n                        dp[j][k + value] = true;\n                    }\n                }\n                if (dp[j][t] && first[j] == -1)\n                    first[j] = i + 1;\n            }\n        }\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (first[i] == -1)\n                return -1;\n            result = max(result, first[i]);\n        }\n        return result;\n    }\n};\n","author":"Tilak Neema","submissionId":"1575241071"},[]]},{"1635":[{"id":"1635","fileName":"1575241091.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int k = -1;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (nums[i] == 0) {\n                k = 0;\n                continue;\n            }\n            \n            int ki = -1;\n            // set to store all possibilities of the current index value after every query\n            set<int> s;\n            s.insert(nums[i]);\n            // loop through each query\n            for (int j = 0; j < queries.size(); ++j) {\n                int l = queries[j][0], r = queries[j][1], v = queries[j][2];\n                if (i >= l && i <= r) {\n                    for (auto r: s) {\n                        if (r - v > 0)\n                            s.insert(r - v);\n                        // first time the index value reaches zero\n                        else if (r - v == 0) {\n                            ki = j + 1;\n                            break;\n                        }\n                    }\n                }\n                if (ki > 0)\n                    break;\n            }\n\n            // an index can't become zero after all queries\n            if (ki == -1)\n                return -1;\n            \n            // otherwise, update the maximum steps\n            else\n                k = max(k, ki);\n        }\n        return k;\n    }\n};","author":"Kannan312","submissionId":"1575241091"},[]]},{"1636":[{"id":"1636","fileName":"1575241076.txt","sourceCode":"class Solution {\nprivate:\n    int dp(vector<int>& nums, int index, vector<vector<int>>& queries, int num, int queryIndex, vector<vector<int>>& map) {\n        if(!num)\n            return queryIndex;\n        \n        if(queryIndex == queries.size())\n            return num == 0 ? queryIndex : INT_MAX;\n        \n        if(num < 0)\n            return INT_MAX;\n        \n        if(map[queryIndex][num] != INT_MIN)\n            return map[queryIndex][num];\n        \n        int result{INT_MAX};\n        \n        // case 1 - ignore \n        result = min(result, dp(nums, index, queries, num, queryIndex + 1, map));\n        \n        // case 2 - use query\n        if(index >= queries[queryIndex][0] && index <= queries[queryIndex][1]) {\n            result = min(result, dp(nums, index, queries, num - queries[queryIndex][2], queryIndex + 1, map));\n        }\n        \n        return map[queryIndex][num] = result;\n    }\n    \npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int result{INT_MIN};\n        \n        for(int i = 0; i < nums.size(); i++) {\n            vector<vector<int>> map(queries.size(), vector<int>(1001, INT_MIN));\n            result = max(result, dp(nums, i, queries, nums[i], 0, map));\n        }\n        \n        if(result == INT_MAX)\n            return -1;\n        \n        return result;\n    }\n};","author":"Amol Jindal","submissionId":"1575241076"},[]]},{"1637":[{"id":"1637","fileName":"1575241103.txt","sourceCode":"class Solution {\npublic:\n    \n    bool isV(int i , int n , vector<int>& list , int tar, vector<vector<int>>& dp ) {\n        if(tar == 0) return true;\n        if(tar < 0) return false;\n        if(i >= n) return false;\n        auto& ret = dp[i][tar];\n        if(ret != -1) return ret;\n        \n        bool left = isV(i + 1 , n , list , tar , dp);\n        bool notleft = isV(i + 1 , n , list , tar - list[i] ,dp);\n        \n        return ret = (left || notleft);\n        \n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        map<int , vector<int>> mp;\n        map<int , vector<int>> pm;\n        \n    \n        \n        int n = nums.size() , m = queries.size();\n        \n        for(int i = 0 ; i < n ; i++) {\n            mp[i] ={};\n            pm[i] ={};\n        }\n        \n        for(int i = 0 ; i  < n ; i++) {\n            for(int j = 0 ; j < m ; j++) {\n                if(queries[j][0] <= i && queries[j][1] >= i) {\n                    mp[i].push_back(queries[j][2]);\n                    pm[i].push_back(j);\n                }\n            }\n        }\n        \n        int k =0 ;\n        \n        \n            \n        for(auto& it : mp) {\n            int tar = nums[it.first];\n            vector<int> list = it.second;\n            if(list.size() == 0 && tar > 0) return -1;\n            if(tar == 0) continue;\n            bool ck = false;\n            \n            for(int i = 0  ; i < list.size() ; i++) {\n                vector<vector<int>> dp(i + 2 , vector<int>(tar + 1 , -1));\n                if(isV(0 , i + 1 , list , tar , dp)) {\n                    \n                    k = max(k , pm[it.first][i] + 1);\n                    ck = true;\n                    break;\n                 }\n                \n            }\n            if(!ck) return -1;\n        }\n        \n        return k;\n    }\n};","author":"Mohammed Nayeem","submissionId":"1575241103"},[]]},{"1638":[{"id":"1638","fileName":"1575241294.txt","sourceCode":"class Solution {\npublic:\n    int n, q;\n    vector<int>nums;\n    vector<vector<int>>queries;\n\n    bool canSum(const vector<int>&covered, int tar){\n        bitset<10001>dp;\n        dp[0]=1;\n        for(int x:covered){\n            dp|=(dp<<x);\n            if(dp[tar]){\n                return true;\n            }\n        }\n        return dp[tar];\n    }\n\n    bool ok(int num){\n        vector<vector<int>>covered(n+1);\n        for(int i = 0; i<num; i++){\n            for(int j=queries[i][0]; j<=queries[i][1]; j++){\n                covered[j].push_back(queries[i][2]);\n            }\n        }\n        for(int i = 0; i<n; i++){\n            int tar=nums[i];\n            if(tar==0){\n                continue;\n            }\n            if(!canSum(covered[i], tar)){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    int minZeroArray(vector<int>& numsArr, vector<vector<int>>& queriesArr) {\n        nums=numsArr, queries=queriesArr;\n        n=nums.size(), q=queries.size();\n        for(int i = 0; i<=q; i++){\n            if(ok(i)){\n                return i;\n            }\n        }\n        return -1;\n    }\n};","author":"user2146zS","submissionId":"1575241294"},[]]},{"1639":[{"id":"1639","fileName":"1575241227.txt","sourceCode":"class Solution {\nprivate:\n    bool isZeroState(const vector<int>& a) {\n        \n        for (auto x : a) {\n            if (x != 0) return false;\n        }\n            return true;\n    }\n    \n    bool canAchieve(const vector<bitset<1001>>& b, const vector<int>& a) {\n        \n        \n        int sz = a.size();\n        \n        for (int i = 0; i < sz; ++i) {\n            \n            if (!b[i][a[i]]) \n            {\n                return false;\n            }\n        }\n         return true;\n    }\n    \n    void applyOp(vector<bitset<1001>>& b, int s, int e, int d, const vector<int>& a) {\n        \n        \n        for (int i = s; i <= e; ++i) {\n            \n               bitset<1001> t;\n            \n            for (int j = 0; j < 1001 - d; ++j) {\n                \n                if (b[i][j]) \n                {\n                    t.set(j + d);\n                }\n            }\n            \n            b[i] |= t;\n            \n              int m = a[i];\n            \n            for (int j = m + 1; j < 1001; ++j) {\n                \n                    b[i].reset(j);\n                }\n         }\n        }\n    \npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        \n        int sz = a.size();\n        \n        if (isZeroState(a)) return 0;\n        \n        \n        vector<bitset<1001>> b(sz);\n        \n        for (int i = 0; i < sz; ++i) \n            \n        {\n            b[i].set(0);\n        }\n        \n        for (int i = 0; i < q.size(); ++i) {\n            \n            \n            applyOp(b, q[i][0], q[i][1], q[i][2], a);\n            \n            \n                if (canAchieve(b, a)) \n                {\n                    return i + 1;\n                }\n        }\n        \n        return -1;\n    }\n};","author":"SAURABH PANDEY","submissionId":"1575241227"},[]]},{"1640":[{"id":"1640","fileName":"1575241137.txt","sourceCode":"class Solution {\npublic:\n    bool ok(vector<int>& arr, int t)\n    {\n        if (t == 0)\n        {\n            return true;\n        }\n        vector<int> dp(t + 1);\n        dp[0] = 1;\n        \n        for (int i = 0; i < arr.size(); i++)\n        {\n            for (int j = t; j >= 0; j--)\n            {\n                if (dp[j] == 0)\n                {\n                    continue;\n                }\n                int nv = arr[i] + j;\n                if (nv <= t)\n                {\n                    dp[nv] = 1;\n                }\n            }\n            if (dp[t] == 1)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    bool solve(vector<int>& nums, vector<vector<int>>& queries, int t)\n    {\n        for (int i = 0; i < nums.size(); i++)\n        {\n            vector<int> arr;\n            for (int j = 0; j <= t; j++)\n            {\n                int l = queries[j][0];\n                int r = queries[j][1];\n                int v = queries[j][2];\n                if (i >= l && i <= r)\n                {\n                    arr.push_back(v);\n                }\n            }\n            if (!ok(arr, nums[i]))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    bool allzero(vector<int>& nums)\n    {\n        for (auto& num : nums)\n        {\n            if (num != 0)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        \n        int l = 0;\n        int r = m - 1;\n        \n        if (allzero(nums))\n        {\n            return 0;\n        }\n        \n        while (l < r)\n        {\n            int mid = (l + r) / 2;\n            \n            if (solve(nums, queries, mid))\n            {\n                r = mid;\n            }\n            else\n            {\n                l = mid + 1;\n            }\n        }\n        \n        if (solve(nums, queries, l))\n        {\n            return l + 1;\n        }\n        return -1;\n    }\n};","author":"agix","submissionId":"1575241137"},[]]},{"1641":[{"id":"1641","fileName":"1575241239.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length, q = queries.length;\n        boolean alreadyZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                alreadyZero = false;\n                break;\n            }\n        }\n        if (alreadyZero) return 0;\n        \n        BitSet[] dp = new BitSet[n];\n        for (int i = 0; i < n; i++) {\n            dp[i] = new BitSet(nums[i] + 1);\n            dp[i].set(0);\n        }\n        \n        for (int k = 0; k < q; k++) {\n            int l = queries[k][0], r = queries[k][1], val = queries[k][2];\n            for (int i = l; i <= r; i++) {\n                BitSet shifted = shiftLeft(dp[i], val, nums[i]);\n                dp[i].or(shifted);\n            }\n            boolean allZero = true;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i].get(nums[i])) {\n                    allZero = false;\n                    break;\n                }\n            }\n            if (allZero) return k + 1;\n        }\n        return -1;\n    }\n    \n    private BitSet shiftLeft(BitSet bs, int shift, int target) {\n        BitSet res = new BitSet(target + 1);\n        for (int i = bs.nextSetBit(0); i >= 0 && i <= target; i = bs.nextSetBit(i + 1)) {\n            if (i + shift <= target) {\n                res.set(i + shift);\n            }\n        }\n        return res;\n    }\n}\n","author":"Nalla Sanjay Reddy","submissionId":"1575241239"},[]]},{"1642":[{"id":"1642","fileName":"1575241354.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int left = 0, right = queries.size();\n        int k = INT_MAX;\n\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            if(isZeroArray(nums, queries, mid)){\n                k = mid;\n                right = mid - 1;\n            }\n            else{\n                left = mid + 1;\n            }\n        }\n        \n        return k == INT_MAX ? -1 : k;\n    }\nprivate:\n    bool subsetSumHelper(int num, vector<int>& vals){\n        if(num == 0) return true;\n        if(vals.empty()) return false;\n        \n        vector<bool> dp(num + 1, false);\n        dp[0] = true;\n        for(auto& val : vals){\n            for(int i = num; i >= val; i--){\n                dp[i] = dp[i] || dp[i - val];\n            }\n        }\n        return dp[num];\n    }\n\n    bool isZeroArray(vector<int>& nums, vector<vector<int>>& queries, int k){\n        int n = nums.size();\n        vector<int> diff_arr(n + 1, 0);\n        vector<vector<int>> vals_arr(n);\n\n        for(int i_k = 0; i_k < k; i_k++){\n            for(int i = queries[i_k][0]; i <= queries[i_k][1]; i++){\n                vals_arr[i].push_back(queries[i_k][2]);\n            }\n        }\n        \n        for(int i = 0; i < n; i++){\n            if(subsetSumHelper(nums[i], vals_arr[i]) == false) return false;\n        }\n\n        return true;\n    }\n};","author":"SZone","submissionId":"1575241354"},[]]},{"1643":[{"id":"1643","fileName":"1575241461.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if not nums: return -1\n        \n        if all(e == 0 for e in nums): return 0\n        n = len(nums)\n        # dp[i] is a bitmask, its value is 2 ^ (nums[i] + 1) (totally we need nums[i] bits) based on values in queries\n        dp = [1] * n  # .......1 (value = 0 (index 0)) is achievable\n        \n        masks = [(1 << (num + 1)) - 1 for num in nums]\n        \n        for idx, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                # how can we deal with a subset of indices?\n                dp[i] |= (dp[i] << val)  # magic, it will shift existing indices to val positions 2, 5, ...\n                dp[i] &= masks[i]\n                \n        \n            if all((dp[i] >> nums[i]) & 1 for i in range(n)):\n                return idx + 1\n        \n        return -1","author":"park29","submissionId":"1575241461"},[]]},{"1644":[{"id":"1644","fileName":"1575241530.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length, q = queries.length;\n        \n        int minReq = -1;\n        for (int i = 0; i < n; i++) {\n            int[][] dp = new int[nums[i] + 1][q];\n            for (int[] row : dp) Arrays.fill(row, -1);\n            \n            int currReq = minQueries(nums[i], 0, i, queries, dp);\n            if (currReq == Integer.MAX_VALUE) {\n                return -1;\n            }\n\n            minReq = Math.max(minReq, currReq);\n        }\n\n        return minReq;\n        \n    }\n\n    private int minQueries(int num, int i, int idx, int[][] queries, int[][] dp) {\n        if (num == 0) {\n            return i;\n        }\n        \n        if (i == queries.length) {\n            return Integer.MAX_VALUE;\n        }\n\n        if (dp[num][i] != -1) return dp[num][i];\n        \n        int[] query = queries[i];\n        int l = query[0], r = query[1], val = query[2];\n\n        int notUse = minQueries(num, i + 1, idx, queries, dp);\n\n        int use = Integer.MAX_VALUE;\n        if (idx >= l && idx <= r && num - val >= 0) {\n            use = minQueries(num - val, i + 1, idx, queries, dp);\n        }\n\n        return dp[num][i] = Math.min(use, notUse);\n    }\n}","author":"PecManO2","submissionId":"1575241530"},[]]},{"448":[{"id":"448","fileName":"1575164816.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        boolean[][] dp = new boolean[n][1001];\n        for(int j = 0 ; j < n ; j++){\n            Arrays.fill(dp[j],false);\n            dp[j][0] = true;\n        }\n        boolean allZero = true;\n        for(int num : nums){\n            if(num!= 0){\n                allZero = false;\n                break;\n            }\n        }\n        if(allZero) return 0;\n        for(int k = 0 ; k < queries.length ; k++){\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int x = queries[k][2];\n\n            for(int j = l ; j <= r; j++){\n                for(int pos = 1000; pos>=x ; pos--){\n                    dp[j][pos] |= dp[j][pos-x];\n                }\n                for(int pos = nums[j]+1;pos<=1000; pos++){\n                    dp[j][pos] = false;\n                }\n            }\n            boolean allDone = true;\n            for(int j = 0 ; j < n ; j++){\n                if(!dp[j][nums[j]]){\n                    allDone = false;\n                    break;\n                }\n            }\n            if(allDone) return k+1;\n        }\n        return -1;\n    }\n}","author":"Michael Muthuraj","submissionId":"1575164816"},[{"id":"1222","similarity":0.9752475247524752,"totOverlap":197,"longestOverlap":77},{"id":"870","similarity":0.9509803921568627,"totOverlap":194,"longestOverlap":68},{"id":"870","similarity":0.8862559241706162,"totOverlap":187,"longestOverlap":39}]],"870":[{"id":"870","fileName":"1575198319.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n         int n = nums.length;\n        boolean[][] dp = new boolean[n][1001];\n        \n        for (int j = 0; j < n; j++) {\n            Arrays.fill(dp[j], false);\n            dp[j][0] = true;\n        }\n        \n        boolean allZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        \n        if (allZero) return 0;\n        \n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int v = queries[k][2];\n            \n            for (int j = l; j <= r; j++) {\n                for (int pos = 1000; pos >= v; pos--) {\n                    if (dp[j][pos - v]) {\n                        dp[j][pos] = true;\n                    }\n                }\n                for (int pos = nums[j] + 1; pos <= 1000; pos++) {\n                    dp[j][pos] = false;\n                }\n            }\n            \n            boolean allAchieved = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j][nums[j]]) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n            \n            if (allAchieved) return k + 1;\n        }\n        \n        return -1;\n    }\n}","author":"Devansh_0109","submissionId":"1575198319"},[{"id":"448","similarity":0.9509803921568627,"totOverlap":194,"longestOverlap":68}]],"1132":[{"id":"1132","fileName":"1575215199.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int length = nums.length;\n        boolean[][] dp = new boolean[length][1001];\n        for (int i = 0; i < length; i++) {\n            dp[i][0] = true;\n        }\n\n        boolean allZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) return 0;\n\n        for (int queryIndex = 0; queryIndex < queries.length; queryIndex++) {\n            int left = queries[queryIndex][0];\n            int right = queries[queryIndex][1];\n            int value = queries[queryIndex][2];\n\n            for (int index = left; index <= right; index++) {\n                boolean[] updated = new boolean[1001];\n\n                for (int sum = 0; sum < 1001 - value; sum++) {\n                    if (dp[index][sum]) {\n                        updated[sum + value] = true;\n                    }\n                }\n\n                for (int sum = 0; sum < 1001; sum++) {\n                    dp[index][sum] |= updated[sum];\n                }\n\n                for (int sum = nums[index] + 1; sum < 1001; sum++) {\n                    dp[index][sum] = false;\n                }\n            }\n\n            boolean allAchievable = true;\n            for (int i = 0; i < length; i++) {\n                if (!dp[i][nums[i]]) {\n                    allAchievable = false;\n                    break;\n                }\n            }\n\n            if (allAchievable) return queryIndex + 1;\n        }\n\n        return -1;\n    }\n}","author":"Tirtharaj Jana","submissionId":"1575215199"},[{"id":"1132","similarity":0.8789237668161435,"totOverlap":196,"longestOverlap":47}]],"1222":[{"id":"1222","fileName":"1575219844.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        boolean[][] dp = new boolean[n][1001];\n\n        for (int j = 0; j < n; j++) {\n            dp[j][0] = true;\n        }\n\n        // if arr has already all zero\n        boolean zeroArray = true;\n        for (int num : nums) {\n            if (num != 0) {\n                zeroArray = false;\n                break;\n            }\n        }\n        if (zeroArray) return 0;\n\n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int v = queries[k][2];\n\n            // Apply the transformation\n            for (int j = l; j <= r; j++) {\n                for (int pos = 1000; pos >= v; pos--) {\n                    dp[j][pos] |= dp[j][pos - v];\n                }\n                // Reset values greater than nums[j]\n                for (int pos = nums[j] + 1; pos <= 1000; pos++) {\n                    dp[j][pos] = false;\n                }\n            }\n\n            // converted to zero?\n            boolean converted = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j][nums[j]]) {\n                    converted = false;\n                    break;\n                }\n            }\n\n            if (converted) return k + 1;\n        }\n\n        return -1;\n    }\n}\n","author":"vishakha_210","submissionId":"1575219844"},[{"id":"448","similarity":0.9752475247524752,"totOverlap":197,"longestOverlap":77}]],"1266":[{"id":"1266","fileName":"1575222150.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        boolean[][] dp = new boolean[n][1001];\n\n        for (int j = 0; j < n; j++) {\n            dp[j][0] = true;\n        }\n\n        boolean allZero = Arrays.stream(nums).allMatch(x -> x == 0);\n        if (allZero) return 0;\n\n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0], r = queries[k][1], v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n                boolean[] shifted = new boolean[1001];\n\n                for (int i = 0; i < 1001 - v; i++) {\n                    if (dp[j][i]) {\n                        shifted[i + v] = true;\n                    }\n                }\n                for (int i = 0; i < 1001; i++) {\n                    dp[j][i] |= shifted[i];\n                }\n\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp[j][pos] = false;\n                }\n            }\n\n            boolean allAchieved = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j][nums[j]]) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n\n            if (allAchieved) return k + 1;\n        }\n        return -1;\n    }\n}","author":"Karan Upadhyay","submissionId":"1575222150"},[{"id":"1132","similarity":0.9112149532710281,"totOverlap":195,"longestOverlap":55}]],"1498":[{"id":"1498","fileName":"1575233522.txt","sourceCode":"\nclass Solution {\n    public int minZeroArray(int[] arr, int[][] updates) {\n        int len = arr.length;\n        boolean[][] dpState = new boolean[len][1001];\n\n        for (int i = 0; i < len; i++) {\n            Arrays.fill(dpState[i], false);\n            dpState[i][0] = true;\n        }\n\n        boolean isAllZero = true;\n        for (int num : arr) {\n            if (num != 0) {\n                isAllZero = false;\n                break;\n            }\n        }\n        if (isAllZero) return 0;\n\n        for (int step = 0; step < updates.length; step++) {\n            int left = updates[step][0];\n            int right = updates[step][1];\n            int value = updates[step][2];\n\n            for (int i = left; i <= right; i++) {\n                boolean[] newState = new boolean[1001];\n\n                for (int pos = 0; pos < 1001; pos++) {\n                    if (dpState[i][pos]) {\n                        newState[pos] = true;\n                        if (pos + value < 1001) {\n                            newState[pos + value] = true;\n                        }\n                    }\n                }\n\n                dpState[i] = newState;\n\n                for (int pos = arr[i] + 1; pos < 1001; pos++) {\n                    dpState[i][pos] = false;\n                }\n            }\n\n            boolean isValid = true;\n            for (int i = 0; i < len; i++) {\n                if (!dpState[i][arr[i]]) {\n                    isValid = false;\n                    break;\n                }\n            }\n\n            if (isValid) return step + 1;\n        }\n        return -1;\n    }\n}\n","author":"anandchowhan_05","submissionId":"1575233522"},[{"id":"1498","similarity":0.9424778761061947,"totOverlap":213,"longestOverlap":71}]],"1504":[{"id":"1504","fileName":"1575233835.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        boolean[][] arr = new boolean[n][1001];\n        for (int a = 0; a < n; a++) {\n            // Arrays.fill(dp[a], false);\n            arr[a][0] = true; \n        }\n        boolean flag = true;\n        for (int k : nums) {\n            if(k!=0){flag=false;break;}\n        }\n        if (flag) return 0;\n        for (int q = 0; q < queries.length; q++) {\n            int l=queries[q][0];\n            int r= queries[q][1];\n            int val =queries[q][2];\n            for (int idx = l; idx <= r; idx++) {\n                boolean[] brr = new boolean[1001];\n                for (int sum = 0; sum < 1001; sum++) {\n                    if (arr[idx][sum]) {\n                        if(sum+val<1001)brr[sum + val] = true;\n                        brr[sum] = true;\n                    }\n                }\n                arr[idx]=brr;\n                for (int z=nums[idx]+ 1;z<= 1000;z++) {\n                    arr[idx][z] = false;\n                }\n            }\n             flag= true;\n            for (int i= 0;i< n;i++) {\n                if (!arr[i][nums[i]]) {flag= false;break;}\n            }\n\n            if(flag) return q+1;\n        }\n        return -1;\n    }\n}\n","author":"channamsetty sriram","submissionId":"1575233835"},[{"id":"1504","similarity":0.8545454545454545,"totOverlap":188,"longestOverlap":39}]],"1645":[{"id":"1645","fileName":"1575241350.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        boolean[][] dp = new boolean[n][1001];\n\n        // Initialize dp array\n        for (int j = 0; j < n; j++) {\n            Arrays.fill(dp[j], false);\n            dp[j][0] = true;  // Base case: 0 can always be achieved\n        }\n\n        // Check if all elements are already zero\n        boolean allZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) return 0;\n\n        // Process each query\n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int v = queries[k][2];\n\n            // Update DP for range [l, r]\n            for (int j = l; j <= r; j++) {\n                boolean[] newDp = new boolean[1001];\n\n                for (int pos = 0; pos <= 1000; pos++) {\n                    if (dp[j][pos]) {\n                        newDp[pos] = true; // Keep previous values\n                        if (pos + v <= 1000) {\n                            newDp[pos + v] = true; // Add `v` to existing values\n                        }\n                    }\n                }\n\n                // Reset values beyond nums[j]\n                for (int pos = nums[j] + 1; pos <= 1000; pos++) {\n                    newDp[pos] = false;\n                }\n\n                dp[j] = newDp; // Update dp state\n            }\n\n            // Check if all numbers in nums can be achieved\n            boolean allAchieved = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j][nums[j]]) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n\n            if (allAchieved) return k + 1;  // Return query index (1-based)\n        }\n\n        return -1; // If no query makes all numbers reachable\n    }\n\n}\n","author":"22211a05v9","submissionId":"1575241350"},[{"id":"1651","similarity":0.9781659388646288,"totOverlap":224,"longestOverlap":112},{"id":"1651","similarity":0.9424778761061947,"totOverlap":213,"longestOverlap":71},{"id":"1651","similarity":0.8789237668161435,"totOverlap":196,"longestOverlap":47},{"id":"1266","similarity":0.9112149532710281,"totOverlap":195,"longestOverlap":55},{"id":"1651","similarity":0.8545454545454545,"totOverlap":188,"longestOverlap":39},{"id":"1132","similarity":0.8862559241706162,"totOverlap":187,"longestOverlap":39},{"id":"1660","similarity":0.9020618556701031,"totOverlap":175,"longestOverlap":24}]],"1651":[{"id":"1651","fileName":"1575242039.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        boolean[][] dp = new boolean[n][1001];\n\n        for (int j = 0; j < n; j++) {\n            Arrays.fill(dp[j], false);\n            dp[j][0] = true;\n        }\n\n        boolean allZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) return 0;\n\n        for (int k = 0; k < queries.length; k++) {\n            int si = queries[k][0];\n            int ei = queries[k][1];\n            int val = queries[k][2];\n\n            for (int j = si; j <= ei; j++) {\n                boolean[] newDp = new boolean[1001];\n                for (int pos = 0; pos < 1001; pos++) {\n                    if (dp[j][pos]) {\n                        newDp[pos] = true;\n                        if (pos + val < 1001) {\n                            newDp[pos + val] = true;\n                        }\n                    }\n                }\n                \n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    newDp[pos] = false;\n                }\n                dp[j] = newDp;\n            }\n\n            boolean allAchieved = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j][nums[j]]) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n\n            if (allAchieved) return k + 1;\n        }\n\n        return -1;\n    }\n}\n","author":"Priya Ranjan Kumar","submissionId":"1575242039"},[{"id":"1645","similarity":0.9781659388646288,"totOverlap":224,"longestOverlap":112}]],"1660":[{"id":"1660","fileName":"1575242500.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        boolean[][] dp = new boolean[n][1001];\n\n        for (int j = 0; j < n; j++) {\n            dp[j][0] = true;\n        }\n\n        boolean allZero = true;\n        for (int num : nums) {\n            if (num != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) return 0;\n\n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0], r = queries[k][1], v = queries[k][2];\n            for (int j = l; j <= r; j++) {\n                for (int pos = 1000; pos >= v; pos--) {\n                    if (dp[j][pos - v]) dp[j][pos] = true;\n                }\n                for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                    dp[j][pos] = false;\n                }\n            }\n            boolean allAchieved = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j][nums[j]]) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n            if (allAchieved) return k + 1;\n        }\n        return -1;\n    }\n}\n","author":"Code_Phoenix","submissionId":"1575242500"},[{"id":"448","similarity":0.9020618556701031,"totOverlap":175,"longestOverlap":24}]]},{"1646":[{"id":"1646","fileName":"1575241615.txt","sourceCode":"class Solution {\npublic:\n    bool subsetSumToK(int n, int k, vector<int>& arr) {\n        vector<bool> prev(k + 1, false), curr(k + 1, false);\n        prev[0] = true;\n        curr[0] = true;\n        if(n > 0 && arr[0] <= k)\n            prev[arr[0]] = true;\n        for (int i = 1; i < n; i++) {\n            curr[0] = true;\n            for (int j = 1; j <= k; j++) {\n                if (j >= arr[i])\n                    curr[j] = (prev[j] || prev[j - arr[i]]);\n                else\n                    curr[j] = prev[j];\n            }\n            prev = curr;\n        }\n        return prev[k];\n    }\n\n    bool f(int k, vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> contributions(n);\n        for (int i = 0; i < k; i++) {\n            int L = queries[i][0], R = queries[i][1], val = queries[i][2];\n            for (int j = L; j <= R; j++) {\n                contributions[j].push_back(val);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != 0) {\n                if (contributions[i].empty()) return false;\n                if (!subsetSumToK(contributions[i].size(), nums[i], contributions[i]))\n                    return false;\n            }\n        }\n        return true;\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        bool allZero = true;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) return 0;\n        \n        int Q = queries.size();\n        if (!f(Q, nums, queries))\n            return -1;\n        int low = 0, high = Q;\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            if (f(mid, nums, queries))\n                high = mid;\n            else\n                low = mid + 1;\n        }\n        return low;\n    }\n};\n","author":"EntireRevival105","submissionId":"1575241615"},[]]},{"1647":[{"id":"1647","fileName":"1575241726.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(); // n is only of size 10\n        vector<vector<bool>> arr(n);\n        for (int i = 0; i < n; i++) {\n            vector<bool> curr(nums[i] + 1, false);\n            curr[0] = true;\n            arr[i] = curr;\n        }\n        \n        int count = 0; // how many 0 elems\n        int countQueries = 1;\n        int k;\n        for (auto it : nums) {\n            if (it == 0) {\n                count++;\n            }\n        }\n        if (count == n) {\n            return 0;\n        }\n        for (auto it : queries) {\n            for (int i = it[0]; i <= it[1]; i++) {\n                if (arr[i][nums[i]]) continue;\n                \n                // now we do the array stuff\n                k = it[2];\n                int l = nums[i];\n                for (int j = l; j >= 0; j--) {\n                    if (k + j <= nums[i] && arr[i][j]) {\n                        arr[i][j + k] = true;\n                    }\n                }\n                if (arr[i][nums[i]]) {\n                    count++;\n                }\n            }\n            if (count == n) {\n                return countQueries;\n            }\n            countQueries++;\n        }\n\n        return -1;\n    }\n};","author":"louieoconnell4","submissionId":"1575241726"},[]]},{"1648":[{"id":"1648","fileName":"1575241678.txt","sourceCode":"class Solution {\npublic:\n\n    bool isSubsetSum(vector<int> &arr, int sum) {\n    int n = arr.size();\n\n    // Create a 2D vector for storing results\n      // of subproblems\n    vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));\n\n    // If sum is 0, then answer is true (empty subset)\n    for (int i = 0; i <= n; i++)\n        dp[i][0] = true;\n\n    // Fill the dp table in bottom-up manner\n    for (int i = 1; i <= n; i++) {\n      \n        for (int j = 1; j <= sum; j++) {\n            if (j < arr[i - 1]) {\n              \n               // Exclude the current element\n                dp[i][j] = dp[i - 1][j]; \n            }\n            else {\n              \n               // Include or exclude\n                dp[i][j] = dp[i - 1][j] \n                || dp[i - 1][j - arr[i - 1]];\n            }\n        }\n    }\n\n    return dp[n][sum];\n}\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int s=0,e=queries.size();\n        int n=nums.size();\n        int ans=-1;\n        while(s<=e){\n            int m=(e+s)/2;\n\n            vector<vector<int>>v(n);\n\n            for(int i=0;i<n;i++){\n               for(int j = 0; j < m; j++){\n                   auto it = queries[j];\n                   if(i >= it[0] && i <= it[1])   v[i].push_back(it[2]);\n               }\n              \n            }\n\n             for(int i=0;i<n;i++){\n                if(!isSubsetSum(v[i],nums[i]) ){\n                    s=m+1;\n                    break;\n                }\n\n                 if(i==n-1){\n                     ans=m;\n                     e=m-1;\n                 }\n             }\n\n            \n        }\n\n\n        return ans;\n        \n    }\n};","author":"debaprasad_70","submissionId":"1575241678"},[]]},{"1649":[{"id":"1649","fileName":"1575241651.txt","sourceCode":"class Solution {\n    int f(int num, int i, int idx, vector<vector<int>>& q, vector<vector<int>>& dp){\n        if(num == 0){\n            return i;\n        }\n        if(i >= q.size()){\n            return q.size() + 1;\n        }\n        if(dp[num][i] >= 0){\n            return dp[num][i];\n        }\n        int firstKQuery = q.size() + 1;\n        int l = q[i][0], r = q[i][1], val = q[i][2];\n        if(l <= idx && idx <= r && val <= num){\n            firstKQuery = min(firstKQuery, f(num - val, i + 1, idx, q, dp));\n        }\n        firstKQuery = min(firstKQuery, f(num, i + 1, idx, q, dp));\n        dp[num][i] = firstKQuery;\n        return firstKQuery;\n    }\n    int minFirstKQuery(int idx, int num, vector<vector<int>>& queries){\n        int q = queries.size();\n        //f(val, i, idx, q) = min(f(val - q[i][2], i + 1, idx, q), f(val, i + 1, idx, q))\n        vector<vector<int>> dp(num + 1, vector<int>(q, -1));\n        return f(num, 0, idx, queries, dp);\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size();\n        int k = 0;\n        for(int i = 0, firstKQuery = 0; i < n; i++){\n            firstKQuery = minFirstKQuery(i, nums[i], queries);\n            if(firstKQuery > queries.size())\n                return -1;\n            k = max(k, firstKQuery);\n        }\n        return k;\n    }\n};","author":"Bhagabati Prasad Rout","submissionId":"1575241651"},[]]},{"1650":[{"id":"1650","fileName":"1575241908.txt","sourceCode":"class Solution {\n    private static boolean isAllZeroes(int[] nums) {\n        for(int num : nums) {\n            if (num != 0) return false;\n        }\n        return true;\n    }\n    \n    public int minZeroArray(int[] nums, int[][] queries) {\n        if(isAllZeroes(nums)) return 0;\n        \n        int n = nums.length;\n        int maxValue = 1000;\n        boolean[][] dp = new boolean[n][maxValue + 1];\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (Arrays.stream(nums).allMatch(num -> num == 0)) {\n            return 0;\n        }\n\n        for (int k = 0; k < queries.length; k++) {\n            int l = queries[k][0], r = queries[k][1], v = queries[k][2];\n\n            for (int i = l; i <= r; i++) {\n                for (int sum = maxValue - v; sum >= 0; sum--) {\n                    if (dp[i][sum]) {\n                        dp[i][sum + v] = true;\n                    }\n                }\n\n                Arrays.fill(dp[i], nums[i] + 1, maxValue + 1, false);\n            }\n\n            boolean allAchieved = true;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i][nums[i]]) {\n                    allAchieved = false;\n                    break;\n                }\n            }\n\n            if (allAchieved) return k + 1;\n        }\n\n        return -1;\n    }\n}\n","author":"pianomyn","submissionId":"1575241908"},[]]},{"1652":[{"id":"1652","fileName":"1575241959.txt","sourceCode":"class Solution {\nprivate:\n    // bool checkZero(vector<int> &nums){\n    //     for(int v : nums){\n    //         if(v!=0) return false;\n    //     }\n    //     return true;\n    // }\n\n    int findk(int idx, vector<int> &nums, vector<vector<int>>& queries){\n        int ts = nums[idx];\n        if(ts ==0) return 0;\n        int n = queries.size();\n        vector<vector<bool>> table(n+1, vector<bool>(ts+1, false));\n        for(int i=0; i<=n; i++){\n            table[i][0] = true;\n        }\n        for(int i=1; i<=n; i++){\n            int l = queries[i-1][0], r = queries[i-1][1], val = queries[i-1][2];\n            // if(idx>r || idx < l) continue;\n            for(int j=1; j<=ts; j++){\n                if((idx>r || idx < l) || (j - val <0)){\n                    table[i][j] = table[i-1][j];\n                }else{\n                    table[i][j] = table[i-1][j-val] || table[i-1][j];\n                }\n            }\n            if(table[i][ts]) return i;\n        }\n        \n        return INT_MAX;\n    }\n    \npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        // if(checkZero(nums)) return 0;\n        // for(int k=0; k< queries.size(); k++){\n        //     int l = queries[k][0], r = queries[k][1], val = queries[k][2];\n        //     for(int i=l; i<=r; i++){\n        //         if(nums[i] - val <0) continue;\n        //         nums[i] -= val;\n        //     }\n        //     if(checkZero(nums)) return k+1;\n        // }\n        // return  -1;\n        int ans = 0;\n        for(int i=0; i < nums.size(); i++){\n            int k = findk(i, nums, queries);\n            ans = max(ans, k);\n        }\n        if(ans == INT_MAX) return -1;\n        return ans;\n    }\n};","author":"gkishan","submissionId":"1575241959"},[]]},{"1653":[{"id":"1653","fileName":"1575241789.txt","sourceCode":"// Source: https://usaco.guide/general/io\n#include <algorithm>\n#include <bits/stdc++.h>\nusing namespace std;\n#define pm cout << -1 << \"n\"\n#define min_pq priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>>\n#define vishal_mishra ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define print(x) { cout << x << \"n\"; }\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define read(arr) for(auto& it : arr) {cin >> it;}\n#define printit(arr) for(auto& it : arr) cout << it << \" \"\n#define fl(i, a, b) for (ll i = a; i < b; i++)\n#define f0(i, a, b) for (ll i = a; i <= b; i++)\n#define rfl(i, a, b) for (ll i = a; i >= b; i--)\n#define c4(x, y, z, w) cin >> x >> y >> z >> w\n#define c3(x, y, z) cin >> x >> y >> z \n#define c5(x,y,z,w,s) cin >> x >> y >> z >> w >> s\n#define c6(x,y,z,w,s,t) cin >> x >> y >> z >> w >> s >> t\ntypedef long long ll;\ntypedef vector<ll> vi;\n#define vl vector<int>\ntypedef pair<ll, ll> pi;\nconst ll inf = 1e17;\nconst ll INF = LLONG_MIN;\n#define ff first\n#define ss second\n#define nl 'n'\n#define comp(x) sort(x.begin(), x.end())\n#define compr(x) sort(x.rbegin(), x.rend())\n#define pb push_back\nconst ll maxn = 1000004;\nvector<int> prime_one(maxn + 1, 0);\n#define sz(a) (ll)a.size()\nvector<int> con;\n const ll mod = 1e9+7;\nconst ll MOD = 998244353;\nusing pii = pair<ll, ll>;\nusing vvi = vector<vi>;\nusing vii = vector<pii>;\nusing vvii = vector<vii>;\n#define pno cout << \"NO\" << nl\n#define pyes cout << \"YES\" << nl\n#define gap \" \"\n#define each(seq) for(auto e: seq)\nconst ll M=998244353;\n//  one day , I WILL !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//  PROVE MYSELF!!!!!\n//const ll N = 5002;\nconst ll MAXN = 4e5;\nconst int MAX = 1e9+7;\n#define lld long double\ndouble sq (double x) {\n  return x*x*1ll;\n}\n// USE stoll for string to integer //DIVIDE MOD dekhlena\n// v.erase(unique(v.begin(),v.end()),v.end()); //for unique\n// MAP,SET-i->first (For lb and ub, use [name.lb/ub(val)]; \n// (n & ~n) returns rightmost 1 bit in n  || s.find==-1 meval absent\n// n<<i == n*(2^i)   while n>>i== n/(2^i)  closing side is used\n// if((it&(1ll<<i))) for checking ith bit is 1 or 0\n// When n%n==n, use (n-1)%n +1 == n (1487B)\n// 279C (calc False. from back of array,q=0; q+=(p*arr[i]); p*=10; )\n// Max GCD is (a-b) and max when a,a/2 --> a/2 is max \n// Copy vector by '=' //MAP,SET-  auto(add is Falset int)\n// INTERACTIVE: use flush between cout and cin: cout--flush--cin\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& qq) {\n        int n = nums.size();\n        int m = qq.size();\n        // for (int j = 0; j < n; j++) {\n        //     dp[j] = bitset<1001>(1); \n        // }\n\n        vector<bitset<1003>> dp(n);\n       // cout << n << m << nl;\n        \n        fl(i,0,n) {\n            dp[i] = 0;\n            dp[i].set(0, 1);\n           // cout < dp[i] << nl;\n        }\n\n        \n        bool f = 1;\n        fl(i,0,n) {\n            if (nums[i] != 0) {\n                f = 0;\n                break;\n            }\n        }\n\n        if (f == 1) return 0;\n\n        fl(i,0,m) {\n            int st = qq[i][0];\n            int en = qq[i][1];\n            int po = qq[i][2];\n\n           // cout << st << \" \" << en << \" \" << po << nl;\n            \n            fl(j,st,en+1) {\n               // cout << dp[j] << \" \";\n                dp[j] |= (dp[j] << po);\n                ll x = nums[j]+1;\n                fl(pos , x , 1001) {\n                    dp[j].reset(pos);\n                }\n            }\n            \n           // printit(dp);\n            \n\n            bool f = 1;\n            fl(i,0,n) {\n                if ((dp[i][nums[i]] == 0)) {\n                    f = 0;\n                    break;\n                }\n            }\n\n            // cout << ans << nl;\n            \n            ll ans = 1+i;\n            if (f == 1) return ans;\n        }\n\n        return -1;\n    }\n};","author":"vmknight","submissionId":"1575241789"},[]]},{"1654":[{"id":"1654","fileName":"1575242073.txt","sourceCode":"class Solution {\n    public int compute(int i, int amount, ArrayList<Integer> list, int[][] dp){\n        if(amount == 0) return i;\n        \n        if(i == list.size() || amount<0) return list.size()+1;\n        if(dp[i][amount] != -1) return dp[i][amount];\n\n        int with = compute(i+1, amount-list.get(i), list, dp);\n        int without = compute(i+1, amount, list, dp);\n\n        return dp[i][amount] = Math.min(with, without);\n    }\n    public int minZeroArray(int[] nums, int[][] queries) {\n        ArrayList<ArrayList<Integer>> list = new ArrayList<>();\n        for(int i = 0; i<nums.length; i++){\n            list.add(new ArrayList<Integer>());\n        }\n\n        for(int[] query : queries){\n            int s = query[0];\n            int e = query[1];\n            for(int i = 0; i<nums.length; i++){\n                if(i>=s && i<=e){\n                    list.get(i).add(query[2]);\n                }\n                else{\n                    list.get(i).add(0);\n                }\n            }\n        }\n\n        int max = -1;\n        for(int i = 0; i<nums.length; i++){\n            int amount = nums[i];\n            ArrayList<Integer> temp = list.get(i);\n\n            int[][] dp = new int[temp.size()][amount+1];\n\n            for(int[] arr : dp){\n                Arrays.fill(arr, -1);\n            }\n            int val = compute(0, amount, temp, dp);\n            // System.out.println(amount + \" \" + val);\n            if(val > temp.size()) return -1;\n            \n            max = Math.max(max, val);\n        }\n\n        return max;\n    }\n}","author":"PalakRajput","submissionId":"1575242073"},[]]},{"1655":[{"id":"1655","fileName":"1575242132.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& qrs) {\n        map<int, vector<int>> q_map;\n        \n        int n = nums.size(), q = qrs.size();\n       \n        int l = 0, r = q, res = -1;\n        while (l <= r) {\n            int m = l + (r - l) / 2;\n            q_map.clear();\n            \n            for (int i = 0; i < m; ++i) {\n                int li = qrs[i][0], ri = qrs[i][1], v = qrs[i][2];\n                for (int j = li; j <= ri; ++j) {\n                    q_map[j].push_back(v);\n                }\n            }\n            \n            if (canMakeZero(nums, q_map, n)) {\n                res = m;\n                r = m - 1;\n            } else {\n                l = m + 1;\n            }\n        }\n        return res;\n    }\n\nprivate:\n    bool canMakeZero(vector<int>& nums, map<int, vector<int>>& q_map, int n) {\n        for (int i = 0; i < n; ++i) {\n            if (!isSubsetSumPossible(q_map[i], nums[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool isSubsetSumPossible(vector<int>& vals, int tgt) {\n        int m = vals.size();\n        vector<bool> dp(tgt + 1, false);\n        dp[0] = true;\n        \n        for (int v : vals) {\n            for (int j = tgt; j >= v; --j) {\n                dp[j] = dp[j] || dp[j - v];\n            }\n        }\n        return dp[tgt];\n    }\n};","author":"Harsh Vyas","submissionId":"1575242132"},[]]},{"1656":[{"id":"1656","fileName":"1575242188.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> min_time(n, INT_MAX);\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) {\n                min_time[i] = 0;\n                continue;\n            }\n            \n            unordered_set<int> showed;\n            showed.insert(nums[i]);\n            for (int j = 0; j < queries.size(); j++) {\n                auto& q = queries[j];\n                int l = q[0];\n                int r = q[1];\n                int v = q[2];\n                unordered_set<int> next_showed = showed;\n                if (i >= l && i <= r) {\n                    for (int prev_show : showed) {\n                        next_showed.insert(prev_show-v);\n                    }\n                }\n                \n                \n                if (next_showed.count(0)) {\n                    min_time[i] = j+1;\n                    break;\n                }\n                swap(showed, next_showed);\n            }\n        }\n        int k = -1;\n        for (int t : min_time) {\n            k = max(k, t);\n        }\n        if (k == INT_MAX)\n            return -1;\n        return k;\n    }\n};","author":"BRM","submissionId":"1575242188"},[]]},{"1657":[{"id":"1657","fileName":"1575242059.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int ans=0;\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==0){\n                continue;\n            }\n            Integer[][] dp=new Integer[queries.length][10001];\n            int curr=helper(nums[i],queries,0,i,dp);\n            if(curr==Integer.MAX_VALUE){\n                return -1;\n            }\n            else{\n                ans=Math.max(ans,curr);\n            }\n        }\n        return ans;\n    }\n    public int helper(int sum,int[][] queries,int pos,int index,Integer[][] dp){\n        if(sum==0){\n            return pos;\n        }\n        if(pos>=queries.length){\n            return Integer.MAX_VALUE;\n        }\n        if(dp[pos][sum]!=null){\n            return dp[pos][sum];\n        }\n        int take=Integer.MAX_VALUE;;\n        if(queries[pos][0]<=index&&queries[pos][1]>=index&&sum>=queries[pos][2]){\n            take=helper(sum-queries[pos][2],queries,pos+1,index,dp);\n        }\n        int noTake=helper(sum,queries,pos+1,index,dp);\n        return dp[pos][sum]=Math.min(take,noTake);\n    }\n}","author":"DEV YADAV","submissionId":"1575242059"},[]]},{"1658":[{"id":"1658","fileName":"1575242357.txt","sourceCode":"func minZeroArray(nums []int, qs [][]int) int {\n\tres := 0\n\tfor i := range nums {\n\t\tif nums[i] <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\tcur := len(qs) + 1\n\t\thm := make(map[int]bool)\n\t\thm[0] = true\n\t\tfor j, q := range qs {\n\t\t\tif q[2] > nums[i] || q[0] > i || q[1] < i {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif hm[nums[i]-q[2]] {\n\t\t\t\tcur = j + 1\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcur := make(map[int]bool)\n            cur[0] = true\n\t\t\tfor sum := range hm {\n\t\t\t\tif q[2]+sum < nums[i] {\n\t\t\t\t\tcur[q[2]+sum] = true\n\t\t\t\t}\n\t\t\t}\n            for sum := range cur {\n                hm[sum] = true\n            }\n\t\t}\n\n\t\tif cur == len(qs)+1 {\n\t\t\treturn -1\n\t\t}\n\t\tres = max(res, cur)\n\t}\n\n\treturn res\n}\n\n","author":"Wei-Li Lai","submissionId":"1575242357"},[]]},{"1659":[{"id":"1659","fileName":"1575242234.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        dp = [set([0]) for _ in range(n)]\n\n        if all(x == 0 for x in nums):\n            return 0\n\n        for k, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                shifted = set(x + v for x in dp[j] if x + v <= nums[j])\n                dp[j].update(shifted)\n                dp[j] = set(x for x in dp[j] if x <= nums[j])\n            allAchieved = True\n            for j in range(n):\n                if nums[j] not in dp[j]:\n                    allAchieved = False\n                    break\n\n            if allAchieved:\n                return k + 1\n        \n        return -1","author":"Pranay Raj Rathod","submissionId":"1575242234"},[]]},{"1661":[{"id":"1661","fileName":"1575242468.txt","sourceCode":"\nclass Solution {\n\npublic:\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\n        int n = nums.size();\n\n        vector<unordered_set<int>> dp(n);\n\n        for (int j = 0; j < n; j++) {\n\n            dp[j].insert(0);\n\n        }\n\n        bool allzero = true;\n\n        for (int num : nums) {\n\n            if (num != 0) {\n\n                allzero = false;\n\n                break;\n\n            }\n\n        }\n\n        if (allzero) return 0;\n\n        for (int k = 0; k < queries.size(); k++) {\n\n            int l = queries[k][0];\n\n            int r = queries[k][1];\n\n            int v = queries[k][2];\n\n            for (int j = l; j <= r; j++) {\n\n                unordered_set<int> newDp = dp[j];\n\n                for (int sum : dp[j]) {\n\n                    newDp.insert(sum + v);\n\n                }\n\n                dp[j] = move(newDp);\n\n                for (auto it = dp[j].begin(); it != dp[j].end();) {\n\n                    if (*it > nums[j]) {\n\n                        it = dp[j].erase(it);\n\n                    } else {\n\n                        ++it;\n\n                    }\n\n                }\n\n            }\n\n            bool allAchieved = true;\n\n            for (int j = 0; j < n; j++) {\n\n                if (dp[j].find(nums[j]) == dp[j].end()) {\n\n                    allAchieved = false;\n\n                    break;\n\n                }\n\n            }\n\n            if (allAchieved) return k + 1;\n\n        }\n\n        return -1;\n\n    }\n\n};","author":"dikshit123","submissionId":"1575242468"},[]]},{"1662":[{"id":"1662","fileName":"1575242527.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        using ll = long long;\n        auto isPos = [&](vector<ll> &A, ll val)->bool {\n            vector<vector<ll>> dp((ll)A.size()+1, vector<ll>(val+1,-1));\n            auto rec = [&](const auto &self, ll i, ll rem)->ll {\n                  if(i == (ll)A.size()) {\n                      return rem == 0;\n                  }  \n                if(dp[i][rem] != -1)\n                    return dp[i][rem];\n                \n                ll notTake = self(self,i+1,rem);\n                ll take = 0;\n                if(rem-A[i] >= 0) {\n                    take = self(self,i+1,rem-A[i]);\n                }\n                \n                return dp[i][rem] = (notTake or take);\n            };\n\n            return rec(rec,0,val);\n        };\n        \n        auto isOk = [&](ll k)->bool {\n            ll n = (ll)nums.size();\n            vector<vector<ll>> bag(n);\n\n            for(ll i = 0; i < k; i++) {\n                ll l = queries[i][0];\n                ll r = queries[i][1];\n                ll val = queries[i][2];\n\n                for(ll j = l; j <= r; j++) {\n                    bag[j].push_back(val);\n                }\n            }\n\n            // Obtain nums[i] using elements from bag[i]\n            bool flag = true;\n            for(int i = 0; i < n; i++){\n                flag &= isPos(bag[i],nums[i]);\n            }\n\n            return flag;\n        };\n        \n        ll l = -1, r = queries.size()+1;\n        while(r-l>1) {\n            ll mid = l + (r-l) / 2;\n            if(isOk(mid))\n                r = mid;\n            else \n                l = mid;\n        }\n\n        if(r == (ll)queries.size()+1)\n            r = -1;\n\n        return r;\n    }\n};","author":"_Dragneel","submissionId":"1575242527"},[]]},{"1663":[{"id":"1663","fileName":"1575242593.txt","sourceCode":"class Solution {\n    public function minZeroArray($nums, $queries) {\n        $n = count($nums);\n        $dp = array_fill(0, $n, array_fill(0, 1001, 0));\n\n        for ($i = 0; $i < $n; $i++) {\n            $dp[$i][0] = 1;\n        }\n\n        $allZero = true;\n        for ($i = 0; $i < $n; $i++) {\n            if ($nums[$i] != 0) {\n                $allZero = false;\n                break;\n            }\n        }\n\n        if ($allZero) {\n            return 0;\n        }\n\n        foreach ($queries as $index => $query) {\n            list($l, $r, $shift) = $query;\n\n            for ($i = $l; $i <= $r; $i++) {\n                for ($j = 1000; $j >= 0; $j--) {\n                    if ($dp[$i][$j] == 1) {\n                        if ($j + $shift <= 1000) {\n                            $dp[$i][$j + $shift] = 1;\n                        }\n                    }\n                }\n\n                for ($pos = $nums[$i] + 1; $pos < 1001; $pos++) {\n                    $dp[$i][$pos] = 0;\n                }\n            }\n\n            $achieved = true;\n            for ($i = 0; $i < $n; $i++) {\n                if ($dp[$i][$nums[$i]] != 1) {\n                    $achieved = false;\n                    break;\n                }\n            }\n\n            if ($achieved) {\n                return $index + 1;\n            }\n        }\n\n        return -1;\n    }\n}\n","author":"ShirotoMahiru","submissionId":"1575242593"},[]]},{"1664":[{"id":"1664","fileName":"1575242524.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n=len(nums)\n        d=[0]*n\n        for i in range(n):\n            d[i]=1<<0\n        if all(x == 0 for x in nums):\n            return 0\n        for k, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                sh = 0\n                for i in range(1001 - v):\n                    if d[j] & (1 << i):\n                        sh |= (1 << (i + v))\n\n                d[j]=d[j]|sh\n                for p in range(nums[j]+1,1001):\n                    o=~(1<<p)\n                    d[j]&=o\n            flag = True\n\n            for j in range(n):\n                if not (d[j] & (1 << nums[j])):\n                    flag = False\n                    break\n            if flag:\n                return k + 1\n\n        return -1\n\n        ","author":"Junolin","submissionId":"1575242524"},[]]},{"1665":[{"id":"1665","fileName":"1575242581.txt","sourceCode":"class Solution {\npublic:\n\n/*\n    1000 * 10\n\n    [5]     [0,0,2] [0,0,1] [0,0,3]\n\n        [[0,2,1],[0,2,1],[1,1,3]]\n\n\n        [2,2,2]\n\n        [[1,3,2],[0,2,1]]\n\n        [1,3,3,2]  [4,3,2,1]\n\n\n        [[0,1,1],[1,2,1],[2,3,2],[3,4,1],[4,4,1]]\n\n        [1,2,3,0,0]\n    \n    could be either take or not for any query[i]\n\n*/\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<vector<bool>> temp(10, vector<bool>(1001, false));\n\n        for(int i = 0; i < nums.size(); i++){\n            temp[i][0] = true;\n        }\n\n        function<bool(void)> check = [&](){\n            for(int i = 0; i <nums.size(); i++){\n                if(temp[i][nums[i]] == false){\n                    return false;\n                }\n            }\n            return true;\n        };\n        int k = -1;\n\n      \n\n        if(check()) return 0;\n        for(vector<int>& query: queries){\n            int val = query[2];\n            cout <<\" quwey \" << val << endl;\n            for(int i = query[0]; i <= query[1]; i++){\n                vector<bool> tempFix = temp[i];\n                for(int j = 0; j <=nums[i]; j++ ){\n\n                \n                    if(temp[i][j] == true && (j + val) <= nums[i]){\n                        tempFix[j+val] = true;\n                    }\n                }\n                temp[i] = tempFix;\n            }\n            k++;\n            if(check()){\n\n                for(int i = 0; i <nums.size(); i++){\n                    cout << \"val \" << nums[i];\n                    for(int j = 0; j <= nums[i]; j++){\n                        cout << \" \" << temp[i][j] << \" \";\n                    }\n                    cout << endl;;\n                    \n                }\n                return k+1;\n            }\n        }\n        \n\n        \n\n\n        return -1;\n\n        \n    }\n};","author":"Ian Arsenault","submissionId":"1575242581"},[]]},{"1666":[{"id":"1666","fileName":"1575242686.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        \n        boolean alreadyZero = true;\n        for (int val : nums) {\n            if (val != 0) {\n                alreadyZero = false;\n                break;\n            }\n        }\n        if (alreadyZero) {\n            return 0;\n        }\n        \n        int maxSum = 1000;\n        boolean[][] dp = new boolean[n][maxSum + 1];\n        \n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        for (int q = 0; q < queries.length; q++) {\n            int left  = queries[q][0];\n            int right = queries[q][1];\n            int val   = queries[q][2];\n            \n            for (int i = left; i <= right; i++) {\n                for (int sum = maxSum; sum >= val; sum--) {\n                    if (dp[i][sum - val]) {\n                        dp[i][sum] = true;\n                    }\n                }\n            }\n            \n            boolean allZeroPossible = true;\n            for (int i = 0; i < n; i++) {\n                int needed = nums[i];\n                if (needed > maxSum || !dp[i][needed]) {\n                    allZeroPossible = false;\n                    break;\n                }\n            }\n            if (allZeroPossible) {\n                return q + 1;\n            }\n        }\n\n        return -1;\n    }\n}","author":"DynamicSarvan","submissionId":"1575242686"},[]]},{"1667":[{"id":"1667","fileName":"1575242645.txt","sourceCode":"class Solution {\npublic:\n    vector<vector<int>> dp;\n    \n    bool rec(vector<int>& v, int t, int idx) {\n        if(t == 0) return true;\n        if(idx == v.size()) return false;\n        if(dp[idx][t] != -1) return dp[idx][t] == 1;\n        bool notTake = rec(v, t, idx + 1);\n        bool take = false;\n        if(v[idx] <= t)\n            take = rec(v, t - v[idx], idx + 1);\n        dp[idx][t] = (take || notTake) ? 1 : 0;\n        return (take || notTake);\n    }\n    \n    bool solve(vector<int>& v, int t) {\n        int n = v.size();\n        dp.assign(n + 1, vector<int>(t + 1, -1));\n        return rec(v, t, 0);\n    }\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n        int m = q.size();\n        bool alreadyZero = true;\n        for (int x : nums)\n            if (x != 0) { alreadyZero = false; break; }\n        if (alreadyZero)\n            return 0;\n        for (int k = 0; k < m; k++) {\n            bool flag = true;\n            for (int i = 0; i < n; i++) {\n                if (nums[i] == 0)\n                    continue;\n                vector<int> vals;\n                for (int j = 0; j <= k; j++) {\n                    if (q[j][0] <= i && i <= q[j][1])\n                        vals.push_back(q[j][2]);\n                }\n                if (!solve(vals, nums[i])) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag)\n                return k + 1;\n        }\n        return -1;\n    }\n};\n","author":"Shlok Srivastava","submissionId":"1575242645"},[]]},{"1668":[{"id":"1668","fileName":"1575242647.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        List<Set<Integer>> numList = new ArrayList<>();\n        Set<Integer> isZero = new HashSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            numList.add(new HashSet<>());\n            numList.get(i).add(nums[i]);\n            if (nums[i] == 0) {\n                isZero.add(i);\n            }\n        }\n        if (isZero.size() == nums.length) return 0;\n        for (int i = 0; i < queries.length; i++) {\n            for (int j = queries[i][0]; j <= queries[i][1]; j++) {\n                if (isZero.contains(j)) continue;\n                Set<Integer> currentSet = numList.get(j);\n                Set<Integer> nextSet = new HashSet<>(currentSet);\n                for (Integer s: currentSet) {\n                    if (s > queries[i][2]) {\n                        nextSet.add(s - queries[i][2]);\n                    } else if (s == queries[i][2]) {\n                        nextSet.add(0);\n                        isZero.add(j);\n                        break;\n                    }\n                }\n                numList.set(j, nextSet);\n            }\n            if (isZero.size() == nums.length) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n}","author":"xuZxnAWFes","submissionId":"1575242647"},[]]},{"1669":[{"id":"1669","fileName":"1575242660.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int qn = queries.size();\n        int curr;\n        int k = 0;\n        bool flag;\n        flag = true;\n        for(int i = 0; i < n; i++)\n            {\n                if(nums[i] != 0)\n                {\n                    flag = false;\n                }\n            }\n        if(flag)\n        {\n            return 0;\n        }\n        unordered_set<int> vals;\n        unordered_set<int> val2;\n        //we find the number of queries needed to bring each num to 0\n        for(int i = 0; i < n; i++)\n            {\n                if(nums[i] == 0)\n                {\n                    continue;\n                }\n                vals.clear();\n                vals.insert(nums[i]); \n                flag = false;\n                curr = -1;\n                for(int j = 0; j < qn; j++)\n                    {\n                        if(queries[j][1] < i || queries[j][0] > i)\n                        {\n                            continue;\n                        }\n                        val2.clear();\n                        for(auto x = vals.begin(); x != vals.end(); x++)\n                            {\n                                if(queries[j][2] - *x == 0)\n                                {\n                                    curr = j;\n                                    flag = true;\n                                    break;\n                                }\n                                if(*x - queries[j][2] > 0)\n                                {\n                                    val2.insert(*x - queries[j][2]);\n                                }\n                            }\n                        if(flag)\n                        {\n                            break;\n                        }\n                        for(auto it = val2.begin(); it != val2.end(); it++)\n                            {\n                                vals.insert(*it);\n                            }\n                    }\n                if(curr == -1)\n                {\n                    return -1;\n                }\n                if(curr > k)\n                {\n                    k = curr;\n                }\n                \n            }\n        return k + 1;\n        \n        \n    }\n};","author":"zoranabc201","submissionId":"1575242660"},[]]},{"1670":[{"id":"1670","fileName":"1575242797.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] a, int[][] queries) {\n        int n = a.length, k = -1;\n        for (int i = 0; i < n; i++) {\n            Integer dp[][] = new Integer[a[i] + 1][queries.length + 1];\n            int t = f(queries, a[i], i, 0, dp);\n            if (t > queries.length) return -1;\n            k = Math.max(k, t);\n        }\n        return k;\n    }\n    private int f(int[][] q, int a, int ind, int i, Integer dp[][]) {\n        int n = q.length;\n        if (a == 0) return i;\n        if (a < 0) return n + 1;\n        if (i >= n) return n + 1;\n        if (dp[a][i] != null) return dp[a][i];\n        int take = n + 1;\n        if (q[i][0] <= ind && q[i][1] >= ind) {\n            take = f(q, a - q[i][2], ind, i + 1, dp);\n        }\n        int not = f(q, a, ind, i + 1, dp);\n        return dp[a][i] = Math.min(take, not);\n    }\n}","author":"Krishnam Agarwal","submissionId":"1575242797"},[]]},{"1671":[{"id":"1671","fileName":"1575242705.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        d = defaultdict(list)\n        for i, (l, r, v) in enumerate(queries):\n            for j in range(l, r+1):\n                d[j].append((i, v))\n\n        def go(arr, target):\n            n = len(arr)\n            dp = [False] * (target + 1)\n            dp[0] = True \n            for k in range(n):\n                for i in range(target, arr[k][1] - 1, -1):\n                    if dp[i - arr[k][1]]:\n                        dp[i] = True\n                        if dp[target]:\n                            return arr[k][0] + 1        \n            return -1\n        \n        res = 0\n        # for k,v in d.items():\n        #     print(k,v)\n        for i in range(len(nums)):\n            if not nums[i]:\n                continue\n            if i not in d and nums[i]:\n                return -1\n            if i not in d:\n                return -1\n            tmp = go(d[i], nums[i])\n            if tmp == -1:\n                return -1\n            res = max(res, tmp)\n        return res\n    \n","author":"Iskender Berdiev","submissionId":"1575242705"},[]]},{"1672":[{"id":"1672","fileName":"1575242726.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        vector<vector<bool>>dp(n,vector<bool>(1001,false)); \n        for(int i=0;i<n;i++)dp[i][0]=true;\n        if(count(nums.begin(),nums.end(),0)==n)return 0;\n        for(int q=0;q<queries.size();q++){\n            int left=queries[q][0],right=queries[q][1],value=queries[q][2];\n            for(int i=left;i<=right;i++){\n                for(int sum=1000;sum>=value;sum--)if(dp[i][sum-value])dp[i][sum]=true;\n                for(int pos=nums[i]+1;pos<=1000;pos++)dp[i][pos]=false;\n            }\n            bool allAchieved=true;\n            for(int i=0;i<n;i++)if(!dp[i][nums[i]]){allAchieved=false;break;}\n            if(allAchieved)return q+1;\n        }\n        return -1;\n\n    }\n};","author":"Abhishek Wani","submissionId":"1575242726"},[]]},{"1673":[{"id":"1673","fileName":"1575242804.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<vector<bool>> dp(nums.size(),vector<bool>(1001,false));\n        for(int i=0;i<nums.size();i++) {\n            dp[i][0] = true;\n        }\n\n        int count = 0;\n            for(int i=0;i<nums.size();i++) {\n                if(dp[i][nums[i]]) {\n                    count++;\n                }\n            }\n        if(count==nums.size()) return 0;\n\n        for(int i=0;i<queries.size();i++) {\n            int count = 0;\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            for(int j=l;j<=r;j++) {\n                for(int k=nums[j];k>=val;k--) {\n                    dp[j][k] = dp[j][k] || dp[j][k-val];\n                }\n            }\n            for(int i=0;i<nums.size();i++) {\n                if(dp[i][nums[i]]) {\n                    count++;\n                }\n            }\n            if(count==nums.size()) {\n                return i+1;\n            }\n            //cout<<count<<endl;\n        }\n        return -1;\n    }\n};","author":"plusline","submissionId":"1575242804"},[]]},{"1674":[{"id":"1674","fileName":"1575242826.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(); \n        int m = queries.size(); \n        int lo = 0, hi = m;  \n        int ans = m + 1;\n        \n        while (hi >= lo) {  \n            int mid = lo + (hi - lo) / 2;  \n            vector<int> pref(n, 0); \n            bool ok = true;\n            for (int i = 0; i < mid; ++i) {  \n                int a = queries[i][0]; \n                int b = queries[i][1]; \n                pref[a] += queries[i][2]; \n                if (b + 1 < n)\n                    pref[b + 1] -= queries[i][2];\n            } \n            \n            for (int i = 1; i < n; ++i)\n                pref[i] += pref[i - 1];\n            \n            for (int i = 0; i < n; ++i) { \n                pref[i] -= nums[i];  \n                if (pref[i] < 0) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) {\n                for (int i = 0; i < n; ++i) {\n                    if (pref[i] == 0) \n                        continue;\n                    \n                    vector<int> allowed;\n                    for (int j = 0; j < mid; ++j) {  \n                        if (queries[j][0] <= i && queries[j][1] >= i) {\n                            allowed.push_back(queries[j][2]);\n                        }\n                    }\n                    \n                    if (allowed.empty()) {\n                        ok = false; \n                        break; \n                    }\n                    \n                    int target = abs(pref[i]);\n                    vector<bool> dp(target + 1, false);\n                    dp[0] = true; \n            \n                    for (int num : allowed) {\n                        for (int s = target; s >= num; --s) {\n                            if (dp[s - num]) {\n                                dp[s] = true;\n                            }\n                        }\n                    } \n                    \n                    if (!dp[target]) {\n                        ok = false;\n                        break;\n                    }\n                }\n            }\n            \n            if (ok) {  \n                ans = min(ans, mid); \n                hi = mid - 1;\n            } else {  \n                lo = mid + 1;\n            }\n        } \n        \n        return (ans == m + 1 ? -1 : ans);\n    }\n};\n","author":"_maniac","submissionId":"1575242826"},[]]},{"1675":[{"id":"1675","fileName":"1575242960.txt","sourceCode":"class Solution {\npublic:\n    unordered_map<string, int> dp_map;\n\n    string hashKey(vector<int>& nums, int it) {\n        string key = to_string(it) + \"#\";\n        for (int num : nums) key += to_string(num) + \",\";\n        return key;\n    }\n\n    int rec(vector<int> nums, vector<vector<int>>& queries, int it, vector<bitset<1001>>& bit_mask) {\n        if (it >= queries.size()) return INT_MAX;\n\n        string key = hashKey(nums, it);\n        if (dp_map.find(key) != dp_map.end()) return dp_map[key];\n\n        int l = queries[it][0], r = queries[it][1], v = queries[it][2];\n\n        vector<int> temp = nums;\n        for (int j = l; j <= r; j++) {\n            bit_mask[j] |= (bit_mask[j] << v);\n            for (int pos = nums[j] + 1; pos < 1001; pos++) {\n                bit_mask[j].reset(pos);\n            }\n        }\n\n        bool allAchieved = true;\n        for (int j = 0; j < nums.size(); j++) {\n            if (!bit_mask[j].test(nums[j])) {\n                allAchieved = false;\n                break;\n            }\n        }\n\n        if (allAchieved) return dp_map[key] = it;\n\n        int x = rec(temp, queries, it + 1, bit_mask);\n        int y = rec(nums, queries, it + 1, bit_mask);\n\n        return dp_map[key] = min(x, y);\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<bitset<1001>> bit_mask(n);  \n        for (int j = 0; j < n; j++) bit_mask[j].set(0, true);\n\n        bool allZero = true;\n        for (int num : nums) if (num > 0) allZero = false;\n        if (allZero) return 0;\n\n        int ans = rec(nums, queries, 0, bit_mask);\n        return (ans == INT_MAX) ? -1 : ans + 1;\n    }\n};\n","author":"Akshit_Nagar2","submissionId":"1575242960"},[]]},{"1676":[{"id":"1676","fileName":"1575242895.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        unordered_map<int, map<int, int>> mp;\n        int m = nums.size();\n        int n = queries.size();\n        int ans = 0;\n        for(int i=0; i<n; i++){\n            auto arr = queries[i];\n            int l = arr[0];\n            int r = arr[1];\n            int v = arr[2];\n            for(int j=l; j<=r; j++){\n                mp[j][i+1] = v;   // first is index, then second is uqnieue, then v is value.\n            }\n        }\n      //  bool okay = true;\n        for(int i=0; i<m; i++){\n            int v = nums[i];\n            if(v==0)continue;\n            if(!mp.count(i))return -1;\n            auto mpp = mp[i];\n            unordered_set<int> st;  \n            st.insert(v);    // it holds all the value we need.\n            bool okay = false;\n            for(auto it : mpp){  // loop all the values avaiable.\n               // cout<<it.second<<endl;\n                auto cp = st;                \n                if(st.count(it.second)){ans = max(ans, it.first);okay = true;break;}                \n                for(auto vv :st){   //what we need\n                    //cout<<vv<<endl;\n                    if(vv>it.second)cp.insert(-it.second+vv);\n                }\n                st = cp;\n            }\n           // if(!okay)cout<<i<<\"   \"<<v<<endl;\n            if(!okay)return -1;\n        }\n        \n\n        return ans;\n    }\n};","author":"taitaiumich","submissionId":"1575242895"},[]]},{"1677":[{"id":"1677","fileName":"1575242992.txt","sourceCode":"func minZeroArray(nums []int, queries [][]int) int {\n    n := len(nums)\n    m := len(queries)\n    options := make([][]int, n)\n    // the options that available for num from 0 - 9\n    for i:=0; i < n; i++ {\n        options[i] = make([]int, m)\n        for j, q := range(queries) {\n            if i >= q[0] && i <= q[1] {\n                options[i][j] = q[2]\n            } else {\n                options[i][j] = 0\n            }\n        }\n    }\n\n    fmt.Println(options)\n    // Now for each option, find the min j that could make it 0\n    maxOps := -1\n    for i :=0; i<n; i++ {\n        minOps := findMin(options[i], nums[i])\n        fmt.Printf(\"MinOps %d, = %dn\", i, minOps)\n\n        if minOps == -1 {\n            return -1\n        }\n\n        if minOps > maxOps {\n            maxOps = minOps\n        }\n    }\n\n    return maxOps\n    \n}\n\n//return -1 if not found\nfunc findMin(option []int, value int) int {\n    ValM := make(map[int] bool)\n    ValM[value] = true\n    if value == 0 {\n        return 0\n    }\n\n    for i :=0; i< len(option); i++ {\n        op := option[i]\n        fmt.Println(ValM)\n        keys := make([]int, len(ValM))\n        j := 0\n        for k := range ValM {\n            keys[j] = k\n            j++\n        }\n        for _, k := range keys {\n            if k - op == 0 {\n                return i+1\n            }\n            ValM[k-op] = true\n        }\n\n    }\n\n    return -1\n    \n    \n}","author":"Kyle Nguyen","submissionId":"1575242992"},[]]},{"1678":[{"id":"1678","fileName":"1575243275.txt","sourceCode":"class Solution {\npublic:\n    bool check(vector<int>& nums, vector<vector<int>>& queries, int m){\n        for(int j=0; j<nums.size(); j++){\n            vector<bool> dp(1001, 0);\n            dp[0]=1;\n            for(int i=0; i<m; i++){\n                if(j>=queries[i][0] && j<=queries[i][1]){\n                    for(int s=1000-queries[i][2]; s>=0; s--){\n                        if(dp[s]) dp[s+queries[i][2]]=true;\n                    }\n                }\n            }\n            if(!dp[nums[j]]) return 0;\n        }\n        return 1;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int> arr=nums;\n        int l=0, r=queries.size(), ans=-1;\n        while(l<=r){\n            int m=l+(r-l)/2;\n            if(check(nums, queries, m)){\n                ans=m;\n                r=m-1;\n            }\n            else l=m+1;\n        }\n        return ans;\n    }\n};","author":"Riyaz Siddiqui","submissionId":"1575243275"},[]]},{"1679":[{"id":"1679","fileName":"1575243005.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] elements, int[][] modifications) {\n        int length = elements.length;\n     List<BitSet> countes = new ArrayList<>(length);\n        List<int[]> diff = Arrays.asList(modifications);\n\n        int l = 0;\n        while (l < length) {\n            BitSet bitSet = new BitSet(1001);\n            bitSet.set(0);\n            countes.add(bitSet);\n            l++;\n        }\n\n        boolean isHasZero = true;\n        int curr = 0;\n        while (curr < length) {\n            if (elements[curr] != 0) {\n                isHasZero = false;\n                break;\n            }\n            curr++;\n        }\n\n        if (isHasZero)\n            return 0;\n\n        int mods = 0;\n        while (mods < diff.size()) {\n            int[] change = diff.get(mods);\n            int start = change[0];\n            int end = change[1];\n            int decrement = change[2];\n\n            int pos = start;\n            while (pos <= end) {\n                countes.get(pos).or(moveBits(countes.get(pos), decrement));\n                int reset = elements[pos] + 1;\n                while (reset < 1001) {\n                    countes.get(pos).clear(reset);\n                    reset++;\n                }\n                pos++;\n            }\n\n            boolean isChanged = true;\n            int counted = 0;\n            while (counted < length) {\n                if (!countes.get(counted).get(elements[counted])) {\n                    isChanged = false;\n                    break;\n                }\n                counted++;\n            }\n\n            if (isChanged)\n                return mods + 1;\n            mods++;\n        }\n\n        return -1;\n    }\n\n    private BitSet moveBits(BitSet bitSet, int shiftAmount) {\n        BitSet shiftedSet = new BitSet(1001);\n        for (int pos = bitSet.nextSetBit(0); pos >= 0; pos = bitSet.nextSetBit(pos + 1)) {\n            if (pos + shiftAmount < 1001) {\n                shiftedSet.set(pos + shiftAmount);\n            }\n        }\n        return shiftedSet;\n    }\n}","author":"Dhruv","submissionId":"1575243005"},[]]},{"1680":[{"id":"1680","fileName":"1575243092.txt","sourceCode":"class Solution {\npublic:\n\n    static int check2(const vector<int>& actives, int num) {\n        set<int> before;\n        before.insert(0);\n        for (int i = 0; i < size(actives); i++) {\n            set<int> current(before);\n            const auto val = actives[i];\n            for (auto&& v : before) {\n                if (v  + val== num) { return i + 1; }\n                if (v + val < num) {\n                    current.insert(val + v);\n                }\n            }\n            swap(before, current);\n        }\n        return -1;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        map<int, map<int, int>> actives_index_map;\n        map<int, vector<int>> actives_map;\n        for (int i = 0; i < size(queries); i++) {\n            const auto l = queries[i][0];\n            const auto r = queries[i][1];\n            const auto val = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                actives_index_map[j].insert({ static_cast<int>(size(actives_map[j])), i + 1});\n                actives_map[j].emplace_back(val);\n            }\n        }\n        int k = 0;\n\n        for (int i = 0; i < size(nums); i++) {\n            const auto num = nums[i];\n            if (num == 0) {\n            }\n            else {\n                const auto& actives = actives_map[i];\n                const int ans = check2(actives, num);\n                if (ans < 0) {\n                    return -1;\n                }\n                k = max(k, actives_index_map[i][ans - 1]);\n            }\n        }\n        return k;\n    }\n};","author":"sakaoka","submissionId":"1575243092"},[]]},{"1681":[{"id":"1681","fileName":"1575243016.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int q = queries.length;\n        int[][] dp = new int[n][q+5];\n\n        for(int i =0; i<q; i++){\n            int[] query = queries[i];\n            int l = query[0], r = query[1], val = query[2];\n            for(int j = l; j<=r; j++){\n                dp[j][i] = val; // storing 0 based index for querying.\n            }\n        }\n\n        // now for each index, we want the min time in which we can turn it to 0;\n        int[] ans = new int[n];\n        int[][] temp = new int[q+5][1010];\n        for(int i=0; i<n; i++){\n            // we want to turn nums[i] into zero\n            ans[i] = findMinQueryForIdx(i, nums, dp, temp);\n        }\n        int res = -1;\n        for(int i=0; i<n; i++){\n            if(ans[i] == -1){\n                return -1;\n            }else{\n                res = Math.max(res, ans[i]);\n            }\n        }\n        return res;\n    }\n\n    private int findMinQueryForIdx(int i, int[] nums, int[][] dp, int[][] temp){\n        // this returns the min no of steps into which nums[i] can be turned into zero.\n        int target = nums[i];\n        if(target == 0){\n            return 0;\n        }\n        for(int[] r: temp){\n            Arrays.fill(r, -1);\n        }\n        int[] row= dp[i];\n        int steps = solve(0, target, row, row.length, temp);\n        \n        if(steps >= (int)1e9){\n            return -1;\n        }\n        return steps;\n    }\n\n    int solve(int i, int target, int[] row, int n, int[][] temp){\n        // this can be optimized using a dp\n        if(target == 0){\n            return 0;\n        }\n        if(i == n){\n            return (int)1e9;\n        }\n        if(temp[i][target] != -1){\n            return temp[i][target];\n        }\n\n        int notPick = 1+solve(i+1, target, row, n, temp);\n        int pick = (int)1e9;\n        if(row[i] <= target){\n            pick = 1+solve(i+1, target-row[i], row, n, temp);\n        }\n        return temp[i][target] = Math.min(pick, notPick);\n    }\n\n    \n    \n}","author":"devrraj","submissionId":"1575243016"},[]]},{"1682":[{"id":"1682","fileName":"1575243577.txt","sourceCode":"class Solution {\npublic:\n    unordered_map<string, bool> memo;\n\n    bool solve(vector<int>& nums, vector<vector<vector<int>>>& idx, int k) {\n        int n = nums.size();\n        string key = to_string(k) + \"|\" + addKey(nums, n);\n        if (memo.count(key)) return memo[key];\n\n        for (int i = 0; i < nums.size(); i++) {\n            int target = nums[i];\n            vector<bool> dp(target + 1, false);\n            dp[0] = true;\n            for (const auto& op : idx[i]) {\n                if (op[0] < k) {\n                    int val = op[1];\n                    for (int j = target; j >= val; j--) {\n                        if (dp[j - val]) {\n                            dp[j] = true;\n                        }\n                    }\n                }\n            }\n            if (!dp[target]) return memo[key] = false;\n        }\n        return memo[key] = true;\n    }\n\n    string addKey(vector<int>& nums, int n) {\n        string res;\n        for (int i = 0; i < n; i++) res += to_string(nums[i]) + \",\";\n        return res;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        bool flag = true;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) return 0;\n\n        vector<vector<vector<int>>> idx(n);\n        for (int i = 0; i < queries.size(); i++) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                idx[j].push_back({i, val});\n            }\n        }\n\n        int s = 1, e = queries.size(), ans = -1;\n        while (s <= e) {\n            int mid = s + (e - s) / 2;\n            if (solve(nums, idx, mid)) {\n                ans = mid;\n                e = mid - 1;\n            } else {\n                s = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"XEROX","submissionId":"1575243577"},[]]},{"1683":[{"id":"1683","fileName":"1575243421.txt","sourceCode":"class Solution {\npublic:\n\n    bool f(int i, int k, vector<int>& candidates, vector<vector<int>>& dp) {\n        if (k == 0)\n            return true;\n        if (i >= candidates.size() || k < 0)\n            return false;\n        if (dp[i][k] != -1)\n            return dp[i][k];\n        \n        bool include = f(i + 1, k - candidates[i], candidates, dp);\n        bool exclude = f(i + 1, k, candidates, dp);\n        return dp[i][k] = include || exclude;\n    }\n\n    bool check(int mid, vector<int>& arr, vector<vector<int>>& queries) {\n        int n = arr.size();\n        // e[i] will store all query values that affect index i.\n        vector<vector<int>> e(n);\n        for (int i = 0; i < mid; i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                e[j].push_back(val);\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            int target = arr[i];\n\n            if (target == 0)\n                continue;\n\n            if (e[i].empty())\n                return false;\n\n            vector<vector<int>> dp(e[i].size() + 1, vector<int>(target + 1, -1));\n            if (!f(0, target, e[i], dp))\n                return false;\n        }\n        return true;\n    }\n    \n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l = 0, r = queries.size();\n        int ans = -1;\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if (check(mid, nums, queries)) {\n                ans = mid;\n                r = mid - 1;  // try to find a smaller mid\n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"kir4n_2234","submissionId":"1575243421"},[]]},{"1684":[{"id":"1684","fileName":"1575243302.txt","sourceCode":"class Solution {\npublic:\n    bool allElementsZero(const vector<int>& arr) {\n        for (int num : arr) {\n            if (num != 0) return false;\n        }\n        return true;\n    }\n    \n    void initializeDP(vector<bitset<1001>>& dp, int size) {\n        for (int i = 0; i < size; i++) {\n            dp[i].reset();\n            dp[i].set(0);\n        }\n    }\n    \n    bool allTargetsAchieved(const vector<bitset<1001>>& dp, const vector<int>& nums) {\n        for (int i = 0; i < nums.size(); i++) {\n            if (!dp[i].test(nums[i])) return false;\n        }\n        return true;\n    }\n    \n    int minZeroArray(vector<int>& arr, vector<vector<int>>& operations) {\n        int n = arr.size();\n        vector<bitset<1001>> dp(n);\n    \n        initializeDP(dp, n);\n    \n        if (allElementsZero(arr)) return 0;\n    \n        for (int opIdx = 0; opIdx < operations.size(); opIdx++) {\n            int left = operations[opIdx][0];\n            int right = operations[opIdx][1];\n            int value = operations[opIdx][2];\n    \n            for (int i = left; i <= right; i++) {\n                dp[i] |= (dp[i] << value);\n                for (int pos = arr[i] + 1; pos < 1001; pos++) {\n                    dp[i].reset(pos);\n                }\n            }\n    \n            if (allTargetsAchieved(dp, arr)) {\n                return opIdx + 1;\n            }\n        }\n    \n        return -1;\n    }\n    // int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        \n    // }\n};","author":"Manish Malik","submissionId":"1575243302"},[]]},{"1685":[{"id":"1685","fileName":"611231499.txt","sourceCode":"from typing import *\n\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        ans = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                continue\n            b = 1 << nums[i]\n            res = -1\n            for j in range(len(queries)):\n                if queries[j][0] <= i and i <= queries[j][1]:\n                    b = b | (b >> queries[j][2])\n                if b & 1:\n                    res = j\n                    break\n            if res == -1:\n                return res\n            ans = max(ans, res + 1)\n        return ans\n","author":"PyIsBestLang","submissionId":"611231499"},[]]},{"1686":[{"id":"1686","fileName":"611232412.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& num, vector<vector<int>>& q) {\n        int res = 0, n = num.size(), m = q.size();\n        for (int p = 0; p < n; p++) {\n            int i = num[p];\n            if (!i) continue;\n            vector<int> dp(i + 1);\n            dp[0] = 1;\n            for (int j = 0; j < m; j++) {\n                int l = q[j][0], r = q[j][1], w = q[j][2];\n                if (p < l or p > r) continue;\n                for (int k = i - w; k >= 0; k--)\n                    dp[k + w] |= dp[k];\n                if (dp[i]) {\n                    res = max(res, j + 1);\n                    break;\n                }\n            }\n            if (!dp[i]) return -1;\n        }\n        return res;\n    }\n};","author":"tobo","submissionId":"611232412"},[]]},{"1687":[{"id":"1687","fileName":"611232541.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if all([t==0 for t in nums]) :\n            return 0\n        snums = [set([t]) for t in nums] \n        \n        for it, (li, ri, val) in enumerate(queries) :\n            for i in range(li, ri+1) :\n                if 0 in snums[i] :\n                    continue\n                new_set = set()\n                for t in snums[i] :\n                    if t - val >= 0 :\n                        new_set.add(t-val)\n                snums[i] |= new_set\n            \n            if all([0 in t for t in snums]) :\n                return it+1\n        return -1\n                    ","author":"pku_erutan","submissionId":"611232541"},[]]},{"1688":[{"id":"1688","fileName":"611232323.txt","sourceCode":"#include<bits/stdc++.h>\n// #pragma GCC optimize(\"Ofast,no-stack-protector,fast-math\",3)\n#define cln cerr<<\"Line:   \"<<__LINE__<<\"    \"\n#define pct __builtin_popcountll\n#define ctz __builtin_ctzll\n#define mkp make_pair\n#define MST(x) memset(x,0,sizeof(x))\n#define all(x) x.begin(),x.end()\nusing namespace std;\nconstexpr int N=(1<<21)+100,_g=3,M1=1e9+7,M2=1e9+9,M=M1;\nusing ll=long long;\nnamespace fast_io{\n    char buf[N+10],*p1,*p2,c;\n#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2))?EOF:*p1++\ntemplate<typename _Tp>\n    void read(_Tp &x){\n        int f=0;for(c=gc;c<48;c=gc)f^=c=='-';\n        for(x=0;c>47;x=(x<<1)+(x<<3)+(48^c),c=gc);\n        if(f)x=-x;\n    }\ntemplate<typename _Tp,typename..._tps>\n    void read(_Tp &x,_tps&...y){read(x),read(y...);}\n    char ob[N+100],stk[505];int tp,ot;\n    void fls(){fwrite(ob,1,ot,stdout),ot=0;}\n    int cntt;\ntemplate<typename _Tp>\n    static inline void write(_Tp x,char c){\n        if(!cntt)atexit(fls),cntt=1;\n        while(x>9)stk[++tp]=48^(x%10),x/=10;\n        for(ob[ot++]=48^x;tp;ob[ot++]=stk[tp--]);\n        ob[ot++]=c;if(ot>N)fls();\n    }\n}using fast_io::read;\nusing fast_io::write;\n#define pli pair<ll,int>\n#define pii pair<int,int>\nusing ul=unsigned long long;\ntemplate<typename tp1,typename tp2>\n    void ckmx(tp1 &x,const tp2 &y){if(x<y)x=y;}\ntemplate<typename tp1,typename tp2>\n    void ckmn(tp1 &x,const tp2 &y){x>y?x=y:0;}\nvoid add(int &x,int y){(x+=y)>=M?x-=M:0;}\nvoid del(int &x,int y){(x-=y)<0?x+=M:0;}\nvoid add(int &x,ul y,int z){x=(y*z+x)%M;}\nvoid del(int &x,ul y,int z){(x-=y*z%M)<0&&(x+=M);}\nconstexpr int qp(ll a,ll x=M-2){\n    int res=1;for(;x;x>>=1,a=a*a%M)\n        (x&1)&&(res=a*res%M);return res;\n}\nconstexpr int qp(ll a,ll x,int M){\n    int res=1;for(;x;x>>=1,a=a*a%M)\n        (x&1)&&(res=a*res%M);return res;\n}\nstruct NTP{};\ntemplate<typename tp1,typename tp2,int N>\nstruct Htb{\n    static constexpr int M=1e7+19;\n    int hd[M+3],to[N],ct;\n    tp1 ed[N];tp2 w[N];\n    static int hc(ul v){\n        v^=v<<13,v^=v>>7;\n        return (v^(v<<17))%M;\n    }\n    void ins(tp1 x,tp2 y){\n        int &p=hd[hc(x)];\n        ed[++ct]=x,to[ct]=p;\n        w[p=ct]=y;\n    }\n    int count(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return 1;\n        return 0;\n    }\n    pair<tp2,bool>find(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return mkp(w[i],true);\n        return mkp(tp2(),false);\n    }\n    int operator[](tp1 x){\n        int &p=hd[hc(x)];\n        for(int i=p;i;i=to[i])\n            if(ed[i]==x)return i;\n        ed[++ct]=x,to[ct]=p;\n        return p=ct;\n    }\n    void clear(){while(ct)hd[hc(ed[ct--])]=0;}\n};\nnamespace MATH{\n    vector<int>jc,nv,_nv;\n    int dv2(int x){return x&1?x+M>>1:x>>1;}\n    int C(int n,int m){\n        assert(m<=n);\n        return 1ll*jc[n]*nv[m]%M*nv[n-m]%M;\n    }\n    int P(int n,int m){\n        return 1ll*jc[n]*nv[n-m]%M;\n    }\n    int D(int n,int m){\n        if(n<0||m<0)return 0;\n        if(!n)return 1;\n        if(!m)return 0;\n        return C(n+m-1,m-1);\n    }\n    void init(int n){\n        int x;\n        jc.resize(n+2);\n        jc[0]=jc[1]=1;\n        nv=_nv=jc;\n        for(x=2;x<=n;++x){\n            jc[x]=1ll*x*jc[x-1]%M;\n            _nv[x]=ll(M-M/x)*_nv[M%x]%M;\n            nv[x]=1ll*nv[x-1]*_nv[x]%M;\n        }\n    }\n}\nstruct DET{\n    int a[3005][3005],n;\n    int run(){\n        if(!n)return 1;\n        int x,y,z,k,res=1;\n        for(x=1;x<=n;++x){\n            for(y=x;y<=n&&!a[y][x];++y);\n            if(y>n)return 0;\n            if(y>x){\n                for(k=1;k<=n;++k)swap(a[x][k],a[y][k]);\n                res&&(res=M-res); \n            }\n            k=qp(a[x][x]);\n            res=1ll*res*a[x][x]%M;\n            for(z=1;z<=n;++z)\n                a[x][z]=1ll*a[x][z]*k%M;\n            for(y=1;y<=n;++y)\n                if(x!=y){\n                    k=a[y][x];\n                    for(z=1;z<=n;++z)\n                        del(a[y][z],a[x][z],k);\n                }\n        }\n        for(x=1;x<=n;++x)\n            res=1ll*res*a[x][x]%M;\n        return res;\n    }\n}det;\nll Gcd(ll x,ll y){\n    if(!x||!y)return x|y;\n    int k=min(ctz(x),ctz(y));\n    ll d;y>>=ctz(y);\n    while(x){\n        x>>=ctz(x),d=x-y;\n        if(x<y)y=x;\n        if(d<0)x=-d;\n        else x=d;\n    }return y<<k;\n}\nusing ll=long long;\nusing ul=unsigned long long;\nconstexpr int bceil(int n){return 1<<(std::__lg(n-1)+1);}\ntemplate<int mod>struct NTT{\n    constexpr int dil(int x){return x>>31?x+mod:x;}\n    constexpr int mul(ul x,int y){return x*y%mod;}\n    constexpr int qpow(int a,int b,int r=1){for(;b;a=mul(a,a),b>>=1){r=b&1?mul(r,a):r;}return r;}\n    int w[N>>1],wI[N>>1];\n    void init(int n){\n        int l=bceil(n)>>1;w[0]=wI[0]=1;\n        for(int i=1;i<l;i<<=1){w[i]=qpow(_g,((mod-1)>>2)/i),wI[i]=qpow(_g,mod-1-((mod-1)>>2)/i);}\n        for(int i=1;i<l;++i){w[i]=mul(w[i&(i-1)],w[i&-i]),wI[i]=mul(wI[i&(i-1)],wI[i&-i]);}\n    }\n    void dif(int *f,int lim){\n        for(int l=lim>>1,r=lim;l;l>>=1,r>>=1)\n            for(int*j=f,*o=w;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    (x=*k)>=mod&&(x-=mod),y=mul(k[l],*o),*k=x+y,k[l]=x-y+mod;\n    }\n    void dit(int *f,int lim){\n        for(int l=1,r=2;l<lim;l<<=1,r<<=1)\n            for(int*j=f,*o=wI;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    x=*k,y=mod-k[l],(*k=x-y)<0&&(*k+=mod),k[l]=mul(x+y,*o);\n        for(int i=0,p=mod-(mod-1)/lim;i<lim;++i)f[i]=1ll*f[i]*p%mod;\n    }\n    void mul(int *f,int *g,int n){\n        dif(f,n),dif(g,n);\n        for(int i=0;i<n;++i)f[i]=1ll*f[i]*g[i]%M;\n        dit(f,n);\n    }\n    void mul(int *f,int n){\n        dif(f,n);int i;\n        for(i=0;i<n;++i)f[i]=1ll*f[i]*f[i]%M;\n        dit(f,n);\n    }\n};\nNTT<M>ntt;\nusing namespace MATH;\nmt19937_64 rg(random_device{}());\nusing LL=__int128_t;\nusing vt=vector<int>;\nusing vl=vector<ll>;\nusing ld=double;\nconst ll INF=1e18;\nint T,n,m,a[N],b[N],to[N];\n// int main(){\n//     ios::sync_with_stdio(false),cin.tie(0);\n//     int i,j,k,l,r,x,y,z;\n//     return 0;\n// }\nvoid rmn(){\n    int i,j,k,l,r,x,y,z;\n    return;\n}\nbitset<1005>h[16];\nclass Solution {\n    public:\n        int minZeroArray(vector<int>& a, vector<vector<int>>& qq) {\n            int v=0,i,r;n=a.size();\n            for(i=0;i<n;++i)h[i].reset(),h[i][a[i]]=1;\n            r=0;\n            for(i=0;i<n;++i)r+=h[i][0];\n            if(r==n)return v;\n            for(auto at:qq){\n                for(int i=at[0];i<=at[1];++i)h[i]|=h[i]>>at[2];\n                ++v,r=0;\n                for(i=0;i<n;++i)r+=h[i][0];\n                if(r==n)return v;\n            }return -1;\n        }\n    };","author":"EnofTaiPeople","submissionId":"611232323"},[]]},{"1689":[{"id":"1689","fileName":"611230902.txt","sourceCode":"const int inf = 0x3f3f3f3f;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size(), ans = 0;\n        for(int i = 0; i < n; ++i) {\n            vector<int> f(nums[i] + 1, +inf);\n            f[0] = 0;\n            for(int j = 0; j < m; ++j) {\n                int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                if(l <= i && i <= r) {\n                    for(int k = nums[i]; k >= val; --k) {\n                        if(f[k - val] < +inf) {\n                            f[k] = min(f[k], j + 1);\n                        }\n                    }\n                }\n            }\n            ans = max(ans, f[nums[i]]);\n        }\n        return ans == +inf ? -1 : ans;\n    }\n};","author":"rui_er","submissionId":"611230902"},[]]},{"1690":[{"id":"1690","fileName":"611232774.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& queries) {\n        int n = a.size(), m = queries.size();\n        int ret = 0;\n        const int N = 1e3 + 1;\n        auto solve = [&](int id) {\n            if (a[id] == 0) return 0;\n            bitset<N> dp;\n            dp[0] = 1;\n            for (int i = 0; i < m; ++i) {\n                int L = queries[i][0], R = queries[i][1], val = queries[i][2];\n                if (id < L || id > R) continue;\n                dp = dp | (dp << val);\n                if (dp[a[id]]) return i + 1;\n            }\n            return m + 1;\n        };\n        for (int i = 0; i < n; ++i) {\n            int cur = solve(i);\n            ret = max(ret, cur);\n        }\n        if (ret > m) return -1;\n        return ret;\n    }\n};","author":"cuiaoxiang","submissionId":"611232774"},[]]},{"1691":[{"id":"1691","fileName":"611232796.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        if(*max_element(nums.begin(),nums.end())==0){\n            return 0;\n        }\n        int n=nums.size();\n        int res=0;\n        vector<vector<int>> a(n,vector<int>(1200));\n        for(auto& q:a){\n            q[0]=1;\n        }\n        for(auto& q:queries){\n            ++res;\n            int v=q[2];\n            for(int i=q[0];i<=q[1];++i){\n                for(int j=nums[i];j>=v;--j){\n                    if(a[i][j-v]){\n                        a[i][j]=1;\n                    }\n                }    \n            }\n\n            \n            bool ok=1;\n            for(int i=0;ok&&i<n;++i){\n                if(!a[i][nums[i]]){\n                    ok=0;\n                }\n            }\n            if(ok){\n                return res;\n            }\n        }\n\n        return -1;\n    }\n};","author":"w285714","submissionId":"611232796"},[]]},{"1692":[{"id":"1692","fileName":"611232450.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def check(pos, val):\n            if val == 0:\n                return 0\n            \n            can = [False] * (val + 1)\n            can[0] = True\n            for i, (l, r, k) in enumerate(queries):\n                if l <= pos <= r:\n                    for z in range(val, -1, -1):\n                        if can[z] and z + k <= val:\n                            can[z + k] = True\n                if can[val]:\n                    return i + 1\n            return -1\n        \n        reqs = [check(i, num) for i, num in enumerate(nums)]\n        if any(req == -1 for req in reqs):\n            return -1\n        return max(reqs)\n","author":"牧瀬 紅莉栖","submissionId":"611232450"},[]]},{"1693":[{"id":"1693","fileName":"611233041.txt","sourceCode":"import string\nfrom sortedcontainers import SortedList\nfrom collections import defaultdict, deque, Counter\nfrom bisect import bisect_left, bisect_right\nfrom typing import List, Set, Tuple, Optional\nfrom itertools import pairwise, permutations, combinations, groupby\nfrom heapq import heappush, heappop\nfrom random import shuffle\nfrom functools import cmp_to_key, lru_cache\nfrom fractions import Fraction\nfrom math import gcd, lcm\n\n\nclass Solution:\n    def minZeroArray(self, a: List[int], queries: List[List[int]]) -> int:\n        if max(a) == 0:\n            return 0\n        n = len(a)\n        f = [[0 for _ in range(a[i] + 1)] for i in range(n)]\n        for i in range(n):\n            f[i][0] = 1\n        for i, (l, r, v) in enumerate(queries, 1):\n            for k in range(l, r + 1):\n                for j in range(a[k], v - 1, -1):\n                    f[k][j] |= f[k][j - v]\n            if all(f[k][a[k]] for k in range(n)):\n                return i\n        return -1\n","author":"Ujimatsu_Chiya","submissionId":"611233041"},[]]},{"1694":[{"id":"1694","fileName":"611234144.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        ans = 0\n        m = len(queries)\n        for i, x in enumerate(nums):\n            dp = [0] * x + [1]\n            if x == 0:\n                continue\n            for j in range(m):\n                l, r, val = queries[j]\n                if l <= i <= r:\n                    for idx in range(x - val + 1):\n                        jdx = idx + val\n                        if dp[jdx] == 1:\n                            dp[idx] = 1\n                if dp[0] == 1:\n                    ans = max(ans, j + 1)\n                    break\n            if dp[0] == 0:\n                return -1\n        return ans","author":"萨姆","submissionId":"611234144"},[]]},{"1695":[{"id":"1695","fileName":"611233461.txt","sourceCode":"const int N = 1024;\nbitset<N> bs;\nint solve(int v, int p, vector<vector<int>>& queries){\n    if(v == 0)  return 0;\n    bs.reset();\n    bs.set(0);\n    int n = queries.size();\n    for(int i=0; i<n; ++i){\n        int l = queries[i][0];\n        int r = queries[i][1];\n        int w = queries[i][2];\n        if(p < l || p > r)  continue;\n        bs |= (bs << w);\n        if(bs.test(v)){\n            return i + 1;\n        }\n    }\n    return -1;\n}\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& queries) {\n        int ret = 0;\n        int n = a.size();\n        for(int i=0; i<n; ++i){\n            int cur = solve(a[i], i, queries);\n            if(cur == -1){\n                return -1;\n            }\n            ret = max(ret, cur);\n        }\n        return ret;\n    }\n};","author":"Hongrock","submissionId":"611233461"},[]]},{"1696":[{"id":"1696","fileName":"611232985.txt","sourceCode":"class Solution {\n    int minZero(int id, int t, vector<vector<int>>& queries) {\n        if (t == 0) {\n            return 0;\n        }\n        bitset<1001> dp = 1;\n        for (int i = 0; i < queries.size(); i++) {\n            if (queries[i][0] <= id && id <= queries[i][1]) {\n                dp |= dp << queries[i][2];\n                if (dp[t]) {\n                    return i + 1;\n                }\n            }\n        }\n        return -1;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            int cur = minZero(i, nums[i], queries);\n            if (cur == -1) {\n                return -1;\n            }\n            res = max(res, cur);\n        }\n        return res;\n    }\n};","author":"Hack_Others","submissionId":"611232985"},[]]},{"1697":[{"id":"1697","fileName":"611234342.txt","sourceCode":"import os,sys,random,threading\n#sys.exit() 退出程序\n#sys.setrecursionlimit(10**6) #调整栈空间\nfrom random import randint,choice,shuffle\n#randint(a,b)从[a,b]范围随机选择一个数\n#choice(seq)seq可以是一个列表,元组或字符串,从seq中随机选取一个元素\n#shuffle(x)将一个可变的序列x中的元素打乱\nfrom copy import deepcopy\nfrom io import BytesIO,IOBase\nfrom types import GeneratorType\nfrom functools import lru_cache,reduce\n#reduce(op,迭代对象)\nfrom bisect import bisect_left,bisect_right\n#bisect_left(x) 大于等于x的第一个下标\n#bisect_right(x) 大于x的第一个下标\nfrom collections import Counter,defaultdict,deque\nfrom itertools import accumulate,combinations,permutations\n#accumulate(a)用a序列生成一个累积迭代器，一般list化前面放个[0]做前缀和用\n#combinations(a,k)a序列选k个 组合迭代器\n#permutations(a,k)a序列选k个 排列迭代器\nfrom heapq import  heapify,heappop,heappush\n#heapify将列表转为堆\nfrom typing import Generic,Iterable,Iterator,TypeVar,Union,List\nfrom string import ascii_lowercase,ascii_uppercase,digits\n#小写字母，大写字母，十进制数字\nfrom math import ceil,floor,sqrt,pi,factorial,gcd,log,log10,log2,inf\n#ceil向上取整，floor向下取整 ，sqrt开方 ，factorial阶乘\nfrom decimal import Decimal,getcontext\n#Decimal(s) 实例化Decimal对象,一般使用字符串\n#getcontext().prec=100 修改精度\nfrom sys import stdin, stdout, setrecursionlimit\ninput = lambda: sys.stdin.readline().rstrip(\"rn\")\nMI = lambda :map(int,input().split())\nli = lambda :list(MI())\nii = lambda :int(input())\nmod = int(1e9 + 7) #998244353\ninf = 1<<60\npy = lambda :print(\"YES\")\npn = lambda :print(\"NO\")\nDIRS = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # 右下左上\nDIRS8 = [(0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0),(-1, 1)]  # →↘↓↙←↖↑↗\n\n\n\nclass Solution:\n    def minZeroArray(self, a: List[int], queries: List[List[int]]) -> int:\n        n=len(a)\n        m=len(queries)\n        f=[m+1]*n #f[i]表示a[i]经过前f[j]个q后能变0\n        for i in range(n):\n            if a[i]==0:\n                f[i]=0\n            else:\n                x=a[i]\n                dp=[False]*(x+1)\n                dp[0]=True\n                for j in range(m):\n                    l,r,val=queries[j]\n                    if l<=i<=r:\n                        for k in range(x,val-1,-1):\n                            if dp[k-val]:\n                                dp[k]=1\n                    if dp[x]:\n                        f[i]=j+1\n                        break\n                #print(i,dp)\n        if max(f)==m+1:\n            return -1\n        return max(f)","author":"poiujhgdsd","submissionId":"611234342"},[]]},{"1698":[{"id":"1698","fileName":"611234719.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def do(x):\n            v = nums[x]\n            lis = [1] + [0] * v\n            for i in has[x]:\n                for j in range(v,i-1,-1):\n                    lis[j] = lis[j]|lis[j-i]\n            if lis[-1] == 1:\n                nhas[x] = False\n        n = len(nums)\n        res = 0\n        has = [[] for _ in range(n)]\n        nhas = [(i>0) for i in nums]\n        if max(nums) == 0: return 0\n        for i,j,k in queries:\n            for a in range(i,j+1):\n                if nhas[a] and k <= nums[a]:\n                    has[a].append(k)\n                    do(a)\n            res += 1\n            if not any(nhas): return res\n        return -1","author":"丁飞","submissionId":"611234719"},[]]},{"1699":[{"id":"1699","fileName":"611234471.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size();\n        int ans = 0;\n\n        for (int idx = 0; idx < n; idx++) {\n            int x = nums[idx];\n            if (x == 0) continue;\n\n            bool f[x + 1];\n            memset(f, 0, sizeof(f));\n            f[0] = true;\n            for (int i = 0; i < q; i++) {\n                if (queries[i][0] <= idx && idx <= queries[i][1]) {\n                    int y = queries[i][2];\n                    for (int j = x; j >= y; j--) if (f[j - y]) f[j] = true;\n                }\n                if (f[x]) { ans = max(ans, i + 1); break; }\n            }\n            if (!f[x]) return -1;\n        }\n        return ans;\n    }\n};","author":"TsReaper","submissionId":"611234471"},[]]},{"1700":[{"id":"1700","fileName":"611235183.txt","sourceCode":"func getMin(i, num int, queries [][]int) int {\n    if num == 0 { return 0 }\n    f := make([]bool, num+1)\n    f[0] = true\n    for j, q := range queries {\n        l, r, v := q[0], q[1], q[2]\n        if i >= l && i <= r {\n            for l := num-v; l >= 0; l-- {\n                if f[l] { f[l+v] = true }\n            }\n        }\n        if f[num] { return j+1 }\n    }\n    return len(queries) + 1\n}\n\nfunc minZeroArray(nums []int, queries [][]int) int {\n    m := len(queries)\n    rs := 0  \n    for i, num := range nums {\n        rs = max(rs, getMin(i, num, queries)) \n    }\n    if rs == m + 1 { rs = -1 }\n    return rs\n}","author":"我啊","submissionId":"611235183"},[]]},{"1701":[{"id":"1701","fileName":"611233630.txt","sourceCode":"using i64 = long long;\nusing i128 = __int128;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f32 = double;\nusing f64 = long double;\n\n#define uset unordered_set\n#define umap unordered_map\n#define vi vector<int>\n#define vvi vector<vi>\n#define vll vector<i64>\n#define vvll vector<vll>\n#define pb push_back\n#define pq priority_queue\n#define ALL(x) (x).begin(), (x).end()\n#define rep(i, x, y) for (int (i) = (x); (i) < (y); (i)++)\n#define repr(i, x, y) for (int (i) = (x); (i) > (y); (i)--)\n#define YES \"YESn\"\n#define NO \"NOn\"\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param m `1 <= m`\n// @return x mod m\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\n\n// Fast modular multiplication by barrett reduction\n// Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n// NOTE: reconsider after Ice Lake\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n\n    // @param m `1 <= m`\n    explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n\n    // @return m\n    unsigned int umod() const { return _m; }\n\n    // @param a `0 <= a < m`\n    // @param b `0 <= b < m`\n    // @return `a * b % m`\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        // [1] m = 1\n        // a = b = im = 0, so okay\n\n        // [2] m >= 2\n        // im = ceil(2^64 / m)\n        // -> im * m = 2^64 + r (0 <= r < m)\n        // let z = a*b = c*m + d (0 <= c, d < m)\n        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n        // ((ab * im) >> 64) == c or c + 1\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned long long y = x * _m;\n        return (unsigned int)(z - y + (z < y ? _m : 0));\n    }\n};\n\n// @param n `0 <= n`\n// @param m `1 <= m`\n// @return `(x ** n) % m`\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\n\n// Reference:\n// M. Forisek and J. Jancina,\n// Fast Primality Testing for Integers That Fit into a Machine Word\n// @param n `0 <= n`\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    constexpr long long bases[3] = {2, 7, 61};\n    for (long long a : bases) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n\n// @param b `1 <= b`\n// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n\n    // Contracts:\n    // [1] s - m0 * a = 0 (mod b)\n    // [2] t - m1 * a = 0 (mod b)\n    // [3] s * |m1| + t * |m0| <= b\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n\n        // [3]:\n        // (s - t * u) * |m1| + t * |m0 - m1 * u|\n        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n        // = s * |m1| + t * |m0| <= b\n\n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n    // by [3]: |m0| <= b/g\n    // by g != b: |m0| < b/g\n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n\n// Compile time primitive root\n// @param m must be prime\n// @return primitive root (and minimum in now)\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n\n// @param n `n < 2^32`\n// @param m `1 <= m < 2^32`\n// @return sum_{i=0}^{n-1} floor((ai + b) / m) (mod 2^64)\nunsigned long long floor_sum_unsigned(unsigned long long n,\n                                      unsigned long long m,\n                                      unsigned long long a,\n                                      unsigned long long b) {\n    unsigned long long ans = 0;\n    while (true) {\n        if (a >= m) {\n            ans += n * (n - 1) / 2 * (a / m);\n            a %= m;\n        }\n        if (b >= m) {\n            ans += n * (b / m);\n            b %= m;\n        }\n\n        unsigned long long y_max = a * n + b;\n        if (y_max < m) break;\n        // y_max < m * (n + 1)\n        // floor(y_max / m) <= n\n        n = (unsigned long long)(y_max / m);\n        b = (unsigned long long)(y_max % m);\n        std::swap(m, a);\n    }\n    return ans;\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n#if __cplusplus >= 202002L\n#include <bit>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\n#if __cplusplus >= 202002L\n\nusing std::bit_ceil;\n\n#else\n\n// @return same with std::bit::bit_ceil\nunsigned int bit_ceil(unsigned int n) {\n    unsigned int x = 1;\n    while (x < (unsigned int)(n)) x *= 2;\n    return x;\n}\n\n#endif\n\n// @param n `1 <= n`\n// @return same with std::bit::countr_zero\nint countr_zero(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n\n// @param n `1 <= n`\n// @return same with std::bit::countr_zero\nconstexpr int countr_zero_constexpr(unsigned int n) {\n    int x = 0;\n    while (!(n & (1 << x))) x++;\n    return x;\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    explicit csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\nnamespace atcoder {\n\nnamespace internal {\n\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n                              __uint128_t,\n                              unsigned __int128>;\n\ntemplate <class T>\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n                                              std::true_type,\n                                              std::false_type>::type;\n\ntemplate <class T>\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                 std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n                                                std::true_type,\n                                                std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value,\n    make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value,\n                              std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n\n#else\n\ntemplate <class T> using is_integral = typename std::is_integral<T>;\n\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n\n#endif\n\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\nnamespace atcoder {\n\nnamespace internal {\n\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\n\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n\n}  // namespace internal\n\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\n\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt(998244353);\n\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\n\nnamespace internal {\n\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\nnamespace atcoder {\nnamespace internal {\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    explicit scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\nmt19937_64 rng((unsigned) chrono::high_resolution_clock::now().time_since_epoch().count());\n\nint ri() {\n    int n;\n    cin >> n;\n    return n;\n}\n\nvi rai(int n) {\n    vi a(n);\n    rep(i, 0, n) cin >> a[i];\n    return a;\n}\n\nstring rs() {\n    string s;\n    cin >> s;\n    return s;\n}\n\nusing B = bitset<1001>;\n    \nclass Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& queries) {\n        if (accumulate(ALL(a), 0) == 0) return 0;\n        int n = a.size();\n        vector<B> b(n);\n        rep(i, 0, n) b[i].set(0);\n        rep(i, 0, queries.size()) {\n            int l = queries[i][0], r = queries[i][1], x = queries[i][2];\n            rep(j, l, r + 1) b[j] |= b[j] << x;\n            int f = 1;\n            rep(j, 0, n) {\n                if (!b[j].test(a[j])) f = 0;\n            }\n            if (f == 1) return i + 1;\n        }\n        return -1;\n    }\n};\n","author":"一只包zi","submissionId":"611233630"},[]]},{"1702":[{"id":"1702","fileName":"611235314.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<bitset<1001>> v(n);\n        for (int i = 0; i < n; ++i)\n            v[i].set(nums[i]);\n\n        auto check = [&]() {\n            for (auto& b : v)\n                if (!b[0])\n                    return false;\n            return true;\n        };\n\n        if (check())\n            return 0;\n\n        int ans = 0;\n        for (auto& q : queries) {\n            ++ans;\n            for (int i = q[0]; i <= q[1]; ++i)\n                v[i] = v[i] | (v[i] >> q[2]);\n            if (check())\n                return ans;\n        }\n        return -1;\n    }\n};","author":"Sariabell","submissionId":"611235314"},[]]},{"1703":[{"id":"1703","fileName":"611234341.txt","sourceCode":"constexpr long long inf = INT_MAX >> 1;\nconstexpr double eps = 1e-9;\n\nconstexpr int N = 2e5 + 10;\nconstexpr int M = 1000000007; // 998244343;\n\nint lc_init = ([]() {\n}(), 0);\n#define eput(...) 218\n\n#line 10\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& b) {\n        using B = bitset<1 << 10>;\n        B f;\n        int n = a.size();\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (a[i] == 0) continue;\n            B f{};\n            f.set(a[i]);\n            int t = 0;\n            for (auto &x: b) {\n                if (x[0] <= i && i <= x[1]) {\n                    f |= f >> x[2];\n                    if (f[0]) break;\n                }\n                ++t;\n                // eput(i, a[i], f, x);\n            }\n            t += 1;\n            eput(i, t);\n            ans = max(ans, t);\n        }\n        return ans > b.size() ? -1 : ans;\n    }\n};","author":"sfiction","submissionId":"611234341"},[]]},{"1704":[{"id":"1704","fileName":"611235361.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if set(nums) == {0}:\n            return 0\n\n        n = len(nums)\n        mx = max(nums)\n        dp = [1] * n\n        for k, (l, r, v) in enumerate(queries, 1):\n            for i in range(l, r + 1):\n                dp[i] |= dp[i] << v\n                dp[i] &= (1 << (mx + 1)) - 1\n            if all((d >> x) & 1 for d, x in zip(dp, nums)):\n                return k\n        return -1","author":"不造轮子","submissionId":"611235361"},[]]},{"1705":[{"id":"1705","fileName":"611234020.txt","sourceCode":"using namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vll> vvll;\ntypedef vector<vvll> vvvll;\ntypedef vector<pii> vpii;\ntypedef vector<vpii> vvpii;\ntypedef vector<pll> vpll;\ntypedef vector<vpll> vvpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<vd> vvd;\n#define yn(ans) printf(\"%sn\", (ans)?\"Yes\":\"No\");\n#define YN(ans) printf(\"%sn\", (ans)?\"YES\":\"NO\");\ntemplate<class T> bool chmax(T &a, T b) {\n\tif (a >= b) return false;\n\ta = b; return true;\n}\ntemplate<class T> bool chmin(T &a, T b) {\n\tif (a <= b) return false;\n\ta = b; return true;\n}\n#define FOR(i, s, e, t) for ((i) = (s); (i) < (e); (i) += (t)) \n#define REP(i, e) for (int i = 0; i < (e); ++i) \n#define REP1(i, s, e) for (int i = (s); i < (e); ++i)\n#define RREP(i, e) for (int i = (e); i >= 0; --i)\n#define RREP1(i, e, s) for (int i = (e); i >= (s); --i)\n#define all(v) v.begin(), v.end()\n#define pb push_back\n#define qb pop_back\n#define pf push_front\n#define qf pop_front\n#define maxe max_element\n#define mine min_element\nll inf = 1e18;\n#define DEBUG printf(\"%dn\", __LINE__); fflush(stdout);\ntemplate<class T> void print(vector<T> &v, bool withSize = false) {\n\tif (withSize) cout << v.size() << endl;\n\tREP(i, v.size()) cout << v[i] << \" \"; \n\tcout << endl;\n}\nmt19937_64 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int N = nums.size(), Q = queries.size();\n\n        int L = -1, R = Q + 1;\n        while (L + 1 < R) {\n            int mid = (L + R) >> 1;\n\n            bool ok = true;\n            REP(i, N) {\n                bitset<1001> dp;\n                dp[0] = 1;\n                REP(j, mid) {\n                    int l = queries[j][0], r = queries[j][1], w = queries[j][2];\n                    if (i >= l && i <= r) {\n                        dp |= dp << w;\n                    }\n                }\n                if (!dp[nums[i]]) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) R = mid; else L = mid;\n        }\n\n        return R == Q + 1 ? -1 : R;\n    }\n};","author":"Relaxed Visvesvaraya","submissionId":"611234020"},[]]},{"1706":[{"id":"1706","fileName":"611235688.txt","sourceCode":"impl Solution {\n    pub fn min_zero_array(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> i32 {\n        if nums.iter().all(|&x| x == 0) {\n            return 0;\n        }\n        let n = nums.len();\n        let mut dp = Vec::new();\n        for i in 0..n {\n            dp.push(vec![false; nums[i] as usize + 1]);\n            dp[i][nums[i] as usize] = true;\n        }\n        for (i, query) in queries.iter().enumerate() {\n            let (l, r, val) = (query[0] as usize, query[1] as usize, query[2] as usize);\n            for j in l..=r {\n                for k in val..=nums[j] as usize {\n                    dp[j][k - val] |= dp[j][k];\n                }\n            }\n            if dp.iter().all(|x| x[0]) {\n                return i as i32 + 1;\n            }\n        }\n        -1\n    }\n}","author":"weiqizheng","submissionId":"611235688"},[]]},{"1707":[{"id":"1707","fileName":"611235854.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        if(check(nums)){\n            return 0;\n        }\n        \n        int n = nums.length;\n        HashSet<Integer>[] sets = new HashSet[n];\n        int m = queries.length;\n\n        for(int i = 0; i < n; i++){\n            sets[i] = new HashSet<>();\n            sets[i].add(nums[i]);\n        }\n\n\n        OUTER:\n        for(int i = 0; i < m; i++){\n            int[] query = queries[i];\n\n            for(int j = query[0]; j <= query[1]; j++){\n                List<Integer> possible = new ArrayList<>();\n                for(int k : sets[j]){\n                    if(k >= query[2]){\n                        possible.add(k - query[2]);\n                    }\n                }\n\n                sets[j].addAll(possible);\n            }\n\n            // check\n            for(HashSet<Integer> set : sets){\n                if(!set.contains(0)){\n                    continue OUTER;\n                }\n            }\n\n            return i + 1;\n        }\n\n        return -1;\n    }\n\n\n    private boolean check(int[] arr){\n        for(int i : arr){\n            if(i > 0){\n                return false;\n            }\n        }\n\n        return true;\n    }\n}","author":"KAI FENG XUE","submissionId":"611235854"},[]]},{"1708":[{"id":"1708","fileName":"611236426.txt","sourceCode":"class Solution {\npublic:\n  int minZeroArray(vector<int> &nums, vector<vector<int>> &queries) {\n\n    vector<bitset<1001>> dp(nums.size());\n    for (int i = 0; i < dp.size(); ++i)\n      dp[i][0] = 1;\n\n    auto check = [&]() {\n      for (int i = 0; i < nums.size(); ++i)\n        if (!dp[i][nums[i]])\n          return false;\n      return true;\n    };\n    if (check()) {\n      return 0;\n    }\n    for (int i = 0; i < queries.size(); ++i) {\n      int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n      for (int j = l; j <= r; ++j)\n        dp[j] |= dp[j] << val;\n      if (check()) {\n        return i + 1;\n      }\n    }\n    return -1;\n  }\n};","author":"TangJing","submissionId":"611236426"},[]]},{"1709":[{"id":"1709","fileName":"611235276.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& A, vector<vector<int>>& Q) {\n        int n = A.size(), qs = Q.size();\n\n        auto ok = [&](int m) -> bool {\n            for (int i = 0; i < n; ++i) {\n                int a = A[i];\n                vector<bool> dp(a + 1, false);\n                dp[0] = true;\n                for (int j = 0; j < m; ++j) {\n                    if (Q[j][0] <= i && i <= Q[j][1]) {\n                        int val = Q[j][2];\n                        for (int s = a; s >= val; --s) {\n                            dp[s] = dp[s] || dp[s - val];\n                        }\n                    }\n                }\n                if (!dp[a])\n                    return false;\n            }\n            return true;\n        };\n        \n        int l = 0, r = qs + 1;\n        while (l < r) {\n            int m = l + (r - l) / 2;\n            if (ok(m)) {\n                r = m;\n            } else {\n                l = m + 1;\n            }\n        }\n        return l <= qs && ok(l) ? l : -1;\n    }\n};","author":"farmer","submissionId":"611235276"},[]]},{"1710":[{"id":"1710","fileName":"611236519.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        ans = [float(\"inf\")]*n\n        for i in range(n):\n            if nums[i] == 0:\n                ans[i] = 0\n                continue\n            p = 1\n            for j in range(len(queries)):\n                if queries[j][0] <= i <= queries[j][1]:\n                    p |= (p << queries[j][2])\n                if ((p >> nums[i]) & 1):\n                    ans[i] = j+1\n                    break\n        mx = max(ans)\n        return mx if mx != float(\"inf\") else -1","author":"孙慢慢","submissionId":"611236519"},[]]},{"1711":[{"id":"1711","fileName":"611235792.txt","sourceCode":"bool visited[1020];\nint sta[1020];\nint f[12];\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int m = queries.size();\n        int n = nums.size();\n        int ans = 0;\n        for(int i=0;i<n;++i){\n            if(nums[i] == 0)continue;\n            memset(visited,0,sizeof(visited));\n            int top = 0;\n            sta[top++] = nums[i];\n            f[i] = -1;\n            visited[nums[i]] = true;\n            for(int j=0;j<m;++j){\n                if(queries[j][0] > i || queries[j][1] < i)continue;\n                int topn = top;\n                for(int k=0;k<topn;++k){\n                    if(sta[k] >= queries[j][2]){\n                        int x = sta[k] - queries[j][2];\n                        if(!visited[x]){\n                            visited[x] = true;\n                            sta[top++] = x;\n                        }\n                    }\n                }\n                if(visited[0]){\n                    f[i] = j+1;\n                    break;\n                }\n            }\n            if(f[i] == -1){\n                ans = -1;\n                break;\n            }else ans = max(ans, f[i]);\n        }\n        return ans;\n    }\n};","author":"Milesian","submissionId":"611235792"},[]]},{"1712":[{"id":"1712","fileName":"611237047.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if set(nums) == {0}:\n            return 0\n        \n        n = len(nums)\n        dp = [[1] + [0] * num for num in nums]\n        \n        for ans, query in enumerate(queries, 1):\n            l, r, v = query\n            for i in range(l, r + 1):\n                for j in range(nums[i], v - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i][j - v])\n            \n            if all(dp[i][nums[i]] == 1 for i in range(n)):\n                return ans\n        return -1","author":"sishenzhimu","submissionId":"611237047"},[]]},{"1713":[{"id":"1713","fileName":"611236089.txt","sourceCode":"#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#define ALL(v) v.begin(),v.end()\n#define For(i,_) for(int i=0,i##end=_;i<i##end;++i) // [0,_)\n#define FOR(i,_,__) for(int i=_,i##end=__;i<i##end;++i) // [_,__)\n#define Rep(i,_) for(int i=(_)-1;i>=0;--i) // [0,_)\n#define REP(i,_,__) for(int i=(__)-1,i##end=_;i>=i##end;--i) // [_,__)\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define V vector\n#define pb push_back\n#define pf push_front\n#define qb pop_back\n#define qf pop_front\n#define eb emplace_back\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\n#define fi first\n#define se second\nconst int dir[4][2]={{-1,0},{0,1},{1,0},{0,-1}},inf=0x3f3f3f3f,mod=1e9+7;\nconst ll infl=0x3f3f3f3f3f3f3f3fll;\ntemplate<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,1:0;}\nint init=[](){return cin.tie(nullptr)->sync_with_stdio(false),0;}();\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n=nums.size();\n        V<bitset<1001>>a(n);\n        For(i,n)a[i].set(0);\n        auto check=[&](){\n            For(i,n)if(!a[i].test(nums[i]))return false;\n            return true;\n        };\n        if(check())return 0;\n        For(i,q.size()){\n            FOR(j,q[i][0],q[i][1]+1)a[j]|=a[j]<<q[i][2];\n            if(check())return i+1;\n        }\n        return -1;\n    }\n};","author":"drizzlo","submissionId":"611236089"},[]]},{"1714":[{"id":"1714","fileName":"611236978.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    int n=nums.size();\n    int ans = -1;\n    for(int k=0;k<=queries.size();k++){\n        bool f = true;\n        for(int i=0;i<n;i++){\n            vector<bool> dp(nums[i]+1, false);\n            dp[0]=true;\n            for(int j=0;j<k;j++){\n                if(i>=queries[j][0] && i<=queries[j][1]){\n                    for(int s = nums[i]; s>=queries[j][2]; s--){\n                        if(dp[s-queries[j][2]]) dp[s]=true;\n                    }\n                }\n            }\n            if(!dp[nums[i]]) {f = false; break;}\n        }\n        if(f){ans = k; break;}\n    }\n    return ans;\n    }\n};","author":"Hungry Ishizaka4ZT","submissionId":"611236978"},[{"id":"1854","similarity":0.8518518518518519,"totOverlap":138,"longestOverlap":51}]],"1854":[{"id":"1854","fileName":"611248980.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size(), m = q.size();\n        int l = 0, r = m, ans = -1;\n        \n        while (l <= r) {\n            int k = (l + r) / 2;\n            bool ok = true;\n            \n            for (int i = 0; i < n; i++) {\n                vector<bool> dp(a[i] + 1, false);\n                dp[0] = true;\n                for (int j = 0; j < k; j++) {\n                    if (i >= q[j][0] && i <= q[j][1]) {\n                        for (int s = a[i]; s >= q[j][2]; s--) {\n                            if (dp[s - q[j][2]]) dp[s] = true;\n                        }\n                    }\n                }\n                if (!dp[a[i]]) { ok = false; break; }\n            }\n\n            if (ok) {\n                ans = k;\n                r = k - 1;\n            } else {\n                l = k + 1;\n            }\n        }\n        return ans;\n    }\n};\n","author":"程序猴","submissionId":"611248980"},[{"id":"1714","similarity":0.8518518518518519,"totOverlap":138,"longestOverlap":51}]]},{"1715":[{"id":"1715","fileName":"611237291.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        dp = [[False] * (nums[i] + 1) for i in range(n)]\n        for i in range(n):\n            dp[i][0] = True\n        if all(x == 0 for x in nums):\n            return 0\n        for k, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                target = nums[i]\n                for s in range(target - val, -1, -1):\n                    if dp[i][s]:\n                        dp[i][s + val] = True\n            if all(dp[i][nums[i]] for i in range(n)):\n                return k + 1\n        return -1","author":"mywaythere","submissionId":"611237291"},[]]},{"1716":[{"id":"1716","fileName":"611237298.txt","sourceCode":"from typing import List\n\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        ans = 0\n        memo = [[] for _ in range(n)]\n        for start, end, val in queries:\n            for i in range(n):\n                memo[i].append(val if start <= i <= end else 0)\n        for idx, me in enumerate(memo):\n            num = nums[idx]\n            if num == 0:\n                continue\n            target = 1 << num\n            mask = target * 2 - 1\n            tmp = 1\n            for i, val in enumerate(me):\n                tmp = ((tmp << val) | tmp) & mask\n                if tmp & target != 0:\n                    ans = max(ans, i + 1)\n                    break\n            else:\n                return -1\n        return ans","author":"细菌小子","submissionId":"611237298"},[]]},{"1717":[{"id":"1717","fileName":"611236941.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        n = nums.length;\n        a = nums;\n        g = queries;\n        int l = -1, r = queries.length + 1;\n        while (l + 1 < r) {\n            int m = l + (r - l) / 2;\n            if (f(m)) {\n                r = m;\n            } else {\n                l = m;\n            }\n        }\n        return r <= queries.length ? r : -1;\n    }\n\n    int n, a[], g[][];\n\n    boolean f(int m) {\n        for (int i = 0; i < n; i++) {\n            int s = a[i];\n            boolean[] dp = new boolean[s + 1];\n            dp[0] = true;\n            for (int j = 0; j < m; j++) {\n                if (in(i, g[j])) {\n                    int v= g[j][2];\n                    for (int k = s; k >= v; k--  ) {\n                        dp[k] |= dp[k - v];\n                    }\n                }\n            }\n            if (!dp[s]) {\n                return false;\n            }\n\n        }\n        return true;\n    }\n\n    boolean in(int x, int[] e) {\n        return x >= e[0] && x <= e[1];\n    }\n}","author":"Itsuki","submissionId":"611236941"},[]]},{"1718":[{"id":"1718","fileName":"611237380.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries)\n    {\n        int dp[1001];\n        int res = 0;\n        int n = queries.size();\n        for (int t = 0; t < nums.size(); ++t) {\n            if (nums[t] == 0) {\n                continue;\n            }\n            int k = nums[t];\n            int temp_res = INT_MAX;\n            memset(dp, 0, sizeof dp);\n            dp[0] = 1; \n            for (int i = 0; i < n; ++i) {\n                int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n                if (l > t || r < t)\n                    continue;\n                // cout << t << \": \" << l << \" \" << r << \" \" << v << endl;\n                for (int j = k; j >= v; --j)\n                    dp[j] |= dp[j - v];\n                if (dp[k]) {\n                    res = max(res, i + 1);\n                    break;\n                }\n            }\n            if (!dp[k])\n                return -1;\n        }\n        return res;\n    }\n};","author":"Qiye","submissionId":"611237380"},[]]},{"1719":[{"id":"1719","fileName":"611237788.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def is_ok(k):\n            for i in range(n):\n                target = nums[i]\n                flag = 1\n                for j in range(k):\n                    l, r, v = queries[j]\n                    if l <= i <= r:\n                        flag |= flag << v\n                if not (flag >> target) & 1:\n                    return False\n            return True\n\n        n, m = len(nums), len(queries)\n        l, r = 0, m + 1\n        while l < r:\n            mid = (l + r) // 2\n            if is_ok(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l if l <= m else -1\n\n                \n        \n        ","author":"iofu728","submissionId":"611237788"},[]]},{"1720":[{"id":"1720","fileName":"611237147.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n    \n        n = len(nums)\n        q = len(queries)\n        element_queries = [[] for _ in range(n)]\n        \n        for j in range(q):\n            l, r, val = queries[j]\n            for i in range(l, r + 1):\n                element_queries[i].append((j, val))  \n        \n        k_list = []\n        for i in range(n):\n            if nums[i] == 0:\n                k_list.append(0)\n                continue\n            eq = element_queries[i]\n            if not eq:\n                return -1\n            dp = {0: 0} \n            target = nums[i]\n            min_k = float('inf')\n            for (j, val) in eq:\n                tmp = {}\n                for s in dp:\n                    tmp[s] = min(tmp.get(s, float('inf')), dp[s])\n                for s in list(dp.keys()):\n                    new_sum = s + val\n                    new_k = max(dp[s], j + 1)\n                    if new_sum > target:\n                        continue\n                    if new_sum in tmp:\n                        if new_k < tmp[new_sum]:\n                            tmp[new_sum] = new_k\n                    else:\n                        tmp[new_sum] = new_k\n                dp = tmp\n                if target in dp:\n                    if dp[target] < min_k:\n                        min_k = dp[target]\n            if target not in dp:\n                return -1\n            k_list.append(min_k)\n        \n        max_k = max(k_list)\n        return max_k if max_k <= q else -1    ","author":"Lucky7","submissionId":"611237147"},[]]},{"1721":[{"id":"1721","fileName":"611237835.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        {\n            int mx = 0;\n            for (auto x : nums) {\n                mx = max(mx, x);\n            }\n            if (mx == 0) {\n                return 0;\n            }\n        }\n        int n = (int) nums.size();\n        int m = (int) queries.size();\n        \n        using BIT = bitset<1024>;\n        \n        \n        vector<int> A(n, m + 1);\n        \n        auto calc = [&](int idx) {\n            BIT dp;\n            dp.set(0);\n            \n            int T = nums[idx];\n            \n            for (int i = 0; i < m; ++i) {\n                auto& Q = queries[i];\n                int l = Q[0], r = Q[1], v = Q[2];\n                if (l <= idx && idx <= r) {\n                    dp |= dp << v;\n                }\n                if (dp.test(T)) {\n                    return i + 1;\n                }\n            }\n            \n            \n            return m + 1;\n        };\n        \n        for (int i = 0; i < n; ++i) {\n            A[i] = calc(i);\n        }\n        \n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            ans = max(ans, A[i]);\n        }\n        if (ans > m) {\n            return -1;\n        }\n        return ans;\n    }\n};","author":"gooday","submissionId":"611237835"},[]]},{"1722":[{"id":"1722","fileName":"611237633.txt","sourceCode":"#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#include \"algo/debug_lc.h\"\n#else\n#define debug(...) 42\n#endif\n\nusing namespace std;\n\nint __fast_io__ = []() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    return 0;\n}();\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int> &nums, vector<vector<int>> &qs) {\n        int ans = 0, n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            int m = nums[i];\n            if (!m)\n                continue;\n            bitset<1001> bs;\n            bs.set(0);\n            for (int j = 0; j < qs.size(); ++j) {\n                int l = qs[j][0], r = qs[j][1], y = qs[j][2];\n                if (l <= i && r >= i) {\n                    bs |= bs << y;\n                }\n                if (bs[m]) {\n                    ans = max(ans, j + 1);\n                    break;\n                }\n            }\n            if (!bs[m])\n                return -1;\n        }\n        return ans;\n    }\n};\n\n#ifdef LOCAL\n\nint main() {\n    int T;\n    string s;\n    getline(cin, s);\n    T = stoi(s);\n    while (T--) {\n        Solution sol;\n        test<vector<int>, vector<vector<int>>>(sol, &Solution::minZeroArray);\n    }\n    return 0;\n}\n\n#endif\n","author":"5cm/s 🌸","submissionId":"611237633"},[]]},{"1723":[{"id":"1723","fileName":"611238053.txt","sourceCode":"class Solution {\npublic:\n    // vector<int> e[11];\n    // bool dfs(int pos,int cur,vector<int>& nums){\n    //     if(!cur) return true;\n    //     if(cur<0) return false;\n    //     for(int nex:e[pos])\n    // }\n    int dp[21][2005];\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(),m=queries.size();\n        bool flag=true;\n        for(int i=0;i<n;i++){\n            if(nums[i]) flag=false;\n        }\n        if(flag) return 0;\n        memset(dp,0,sizeof(dp));\n        for(int i=0;i<n;i++){\n            dp[i][0]=1;\n        }\n        for(int i=0;i<m;i++){\n            int l=queries[i][0],r=queries[i][1],val=queries[i][2];\n            for(int j=l;j<=r;j++){\n                // e[j].push_back(val);\n                for(int k=nums[j];k-val>=0;k--){\n                    dp[j][k]|=dp[j][k-val];\n                }\n            }\n            bool flag=true;\n            for(int j=0;j<n;j++){\n                // cout<<j<<\" \"<<dp[j][nums[j]]<<endl;\n                if(!dp[j][nums[j]]){\n                    flag=false;\n                }\n            }\n            if(flag) return i+1;\n        }\n        return -1;\n    }\n};","author":"Boring NapierhcR","submissionId":"611238053"},[]]},{"1724":[{"id":"1724","fileName":"611238229.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if max(nums) == 0:\n            return 0\n        n = len(nums)\n        d = [[] for _ in range(n)]\n        for k, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                d[i].append([val, k])\n        res = 0\n        for i in range(n):\n            ar = d[i]\n            tot = sum(val for val,idx in ar)\n            if tot < nums[i]:\n                return -1\n            m = nums[i]\n            f = [False] * (m + 1)\n            f[0] = True\n            for val,idx in ar:\n                for x in range(m, val - 1, -1):\n                    if f[x - val]:\n                        f[x] = True\n                if f[m]:\n                    res = max(res, idx)\n                    break\n            if not f[m]:\n                return -1\n        return res + 1","author":"lee0560","submissionId":"611238229"},[]]},{"1725":[{"id":"1725","fileName":"611237821.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<vector<int>> coverage(n);\n        \n        for (int j = 0; j < m; ++j) {\n            int l = queries[j][0];\n            int r = queries[j][1];\n            for (int i = l; i <= r; ++i) {\n                coverage[i].push_back(j);\n            }\n        }\n        \n        int minK = 0;\n        bool possible = true;\n        \n        for (int i = 0; i < n; ++i) {\n            int target = nums[i];\n            if (target == 0) {\n                continue;\n            }\n            \n            unordered_map<int, int> dp;\n            dp[0] = -1;\n            vector<int>& cov = coverage[i];\n            bool found = false;\n            \n            for (int j : cov) {\n                if (dp.find(target) != dp.end()) {\n                    found = true;\n                    break;\n                }\n                \n                int val = queries[j][2];\n                unordered_map<int, int> tmp;\n                \n                for (auto& entry : dp) {\n                    int s = entry.first;\n                    int current_max_j = entry.second;\n                    int new_s = s + val;\n                    \n                    if (new_s > target) {\n                        continue;\n                    }\n                    \n                    int new_max_j = max(current_max_j, j);\n                    auto it = tmp.find(new_s);\n                    if (it == tmp.end() || new_max_j < it->second) {\n                        tmp[new_s] = new_max_j;\n                    }\n                }\n                \n                for (auto& entry : tmp) {\n                    int s = entry.first;\n                    int new_max_j = entry.second;\n                    auto it = dp.find(s);\n                    if (it == dp.end() || new_max_j < it->second) {\n                        dp[s] = new_max_j;\n                    }\n                }\n            }\n            \n            if (dp.find(target) == dp.end()) {\n                possible = false;\n                break;\n            }\n            \n            int k_i = dp[target] + 1;\n            if (k_i > minK) {\n                minK = k_i;\n            }\n        }\n        \n        if (!possible) {\n            return {-1};\n        }\n        \n        for (int i = 0; i < n; ++i) {\n            if (nums[i] != 0) {\n                continue;\n            }\n        }\n        \n        return {minK};\n    }\n};","author":"code_sunflowers","submissionId":"611237821"},[]]},{"1726":[{"id":"1726","fileName":"611238294.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), qnum = queries.size();\n        vector<bitset<1001>> f(n);\n        for (int i = 0; i < n; ++i)\n            f[i].set(0);\n\n        if (accumulate(nums.begin(), nums.end(), 0) == 0)\n            return 0;\n\n        int ans = -1;\n        for (int i = 0; i < qnum; ++i) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            for (int j = l; j <= r; ++j)\n                f[j] |= f[j] << val;\n\n            bool fg = true;\n            for (int j = 0; j < n; ++j) {\n                if (!f[j].test(nums[j])) {\n                    fg = false;\n                    break;\n                }\n            }\n            if (fg) {\n                ans = i + 1;\n                break;\n            }\n        }\n\n        return ans;\n    }\n};","author":"Cactus","submissionId":"611238294"},[]]},{"1727":[{"id":"1727","fileName":"611237933.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n                int n=nums.length;\n        int[][]dp=new int[n][];\n        for(int i=0;i<n;i++){\n            dp[i]=new int[nums[i]+1];\n            Arrays.fill(dp[i],Integer.MAX_VALUE);\n            dp[i][0]=-1;\n        }\n        for(int i=0;i<queries.length;i++){\n            int val=queries[i][2];\n            for(int j=queries[i][0];j<=queries[i][1];j++){\n                int[]cur=dp[j];\n                for(int k=cur.length-1;k>=val;k--){\n                    if(cur[k-val]!=Integer.MAX_VALUE){\n                        cur[k]=Math.min(cur[k],i);\n                    }\n                }\n            }\n        }\n        int need=-1;\n        for(int i=0;i<n;i++){\n            need=Math.max(need,dp[i][dp[i].length-1]);\n        }\n        return need==Integer.MAX_VALUE?-1:(need+1);\n    }\n}","author":"ReZero","submissionId":"611237933"},[]]},{"1728":[{"id":"1728","fileName":"611238753.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if not any(nums):\n            return 0\n        dp = [[False] * (x+1) for x in nums]\n        for i in range(len(nums)):\n            dp[i][0] = True\n        for k, (l, r, val) in enumerate(queries, 1):\n            for i in range(l, r+1):\n                for j in range(nums[i], val-1, -1):\n                    dp[i][j] |= dp[i][j-val]\n            if all(dp[i][x] for i, x in enumerate(nums)):\n                return k\n        return -1","author":"FatalError","submissionId":"611238753"},[]]},{"1729":[{"id":"1729","fileName":"611238793.txt","sourceCode":"#define repi(i, a, b) for (int i = (a), i##len = (b); i <= i##len; ++i)\n#define peri(i, a, b) for (int i = (a), i##len = (b); i >= i##len; --i)\n#define ll long long\n#define pii pair<int, int>\n#define x first\n#define y second\n#define vi vector<int>\n#define gi greater<int>\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define lowbit(t) ((t) & (-(t)))\nconstexpr const int MAXN = 1e5 + 5;\nconstexpr const int MOD = 1e9 + 7;\nconstexpr const int BASE = 233;\nconstexpr const int MOD2 = 998244353;\nconstexpr const int INF = 0x3f3f3f3f;\nint dx[] = {0, 0, -1, 1, -1, 1, 1, -1};\nint dy[] = {-1, 1, 0, 0, -1, -1, 1, 1};\ntemplate <class U, class T> void Max(U &x, T y) {\n  if (x < y)\n    x = y;\n}\ntemplate <class U, class T> void Min(U &x, T y) {\n  if (x > y)\n    x = y;\n}\ninline ll qpow(ll b, ll k, int MOD) {\n  ll ans = 1;\n  while (k) {\n    if (k & 1) {\n      (ans *= b) %= MOD;\n    }\n    (b *= b) %= MOD;\n    k >>= 1;\n  }\n  return ans;\n}\n\nstruct UF {\n  int fa[MAXN];\n  int sz[MAXN];\n  void init(int n) {\n    repi(i, 0, n - 1) {\n      fa[i] = i;\n      sz[i] = 1;\n    }\n  }\n  int qry(int x) {\n    if (fa[x] != x) {\n      fa[x] = qry(fa[x]);\n    }\n    return fa[x];\n  }\n  bool uni(int x, int y) {\n    int xx = qry(x), yy = qry(y);\n    if (xx != yy) {\n      fa[xx] = yy;\n      sz[yy] += sz[xx];\n      return false;\n    }\n\n    return true;\n  }\n} uf;\n\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        int l = 0,r = m+1;\n        auto cal = [&](int md) {\n          vi pos[15];\n          repi(i,1,md) {\n            int l = queries[i-1][0], r = queries[i-1][1], x = queries[i-1][2];\n            repi(j,l,r) {\n              pos[j].pb(x);\n            }\n          }\n          repi(p,0,n-1) {\n            bool dp[1005] = {1};\n            for(auto x:pos[p]) {\n              peri(j,nums[p],x) {\n                dp[j] |=dp[j-x];\n              }\n            }\n            if (!dp[nums[p]]) {\n              return false;\n            }\n          }\n          return true;\n        };\n        while(l<r){\n            int md = (l+r)>>1;\n            if (cal(md)) {\n              r = md;\n            } else {\n              l = md + 1;\n            }\n        }\n        return r == m + 1 ? -1 : r;\n    }\n};","author":"carrot","submissionId":"611238793"},[]]},{"1730":[{"id":"1730","fileName":"611238860.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), res = 0;\n            std::vector<bool> f(1001, false);\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) { continue; }\n            for (int j = 0; j <= nums[i]; j++) {\n                f[j] = false;\n            }\n            f[nums[i]] = true;\n            bool is_acc = false;\n            int v = 0;\n            for (int j = 0; j < queries.size(); j++) {\n                if (queries[j][0] > i || queries[j][1] < i) { continue; }\n                for (int k = 0; k <= nums[i] - queries[j][2]; k++) {\n                    if (f[k + queries[j][2]]) {\n                        f[k] = true;\n                    }\n                }\n                if (f[0]) {\n                    is_acc = true;\n                    v = j + 1;\n                    break;\n                }\n            }\n            if (is_acc) {\n                res = max(res, v);\n            } else {\n                return -1;\n            }\n        }\n        return res;\n    }\n};","author":"cjy","submissionId":"611238860"},[]]},{"1731":[{"id":"1731","fileName":"611238535.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        ans = 0\n        for i, x in enumerate(nums):\n            dp = [math.inf] * (x + 1)\n            dp[x] = 0\n            for j, (l, r, v) in enumerate(queries):\n                if l > i or r < i:\n                    continue\n                for k in range(v, x + 1):\n                    if dp[k] == math.inf:\n                        continue\n                    dp[k - v] = min(dp[k - v], j + 1)\n            if dp[0] == math.inf:\n                return -1\n            ans = max(ans, dp[0])\n        return ans\n        ","author":"醉里挑灯看剑","submissionId":"611238535"},[]]},{"1732":[{"id":"1732","fileName":"611237643.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries)\n    {\n        int n = nums.size(), q = queries.size();\n        int ans = 0;\n        bool zero = true;\n        for (auto x : nums)\n            if (x)\n            {\n                zero = false;\n                break;\n            }\n        if (zero)\n            return 0;\n        for (int t = 0; t < n; t++)\n        {\n            vector<int> f(nums[t] + 1, 0);\n            f[0] = 1;\n            int cnt = 0;\n            for (auto x : queries)\n            {\n                if (x[0] <= t && x[1] >= t)\n                    for (int j = nums[t]; j >= x[2]; j--)\n                        f[j] |= f[j - x[2]];\n                cnt++;\n                if (f[nums[t]])\n                {\n                    ans = max(ans, cnt);\n                    break;\n                }\n            }\n            if (!f[nums[t]])\n                return -1;\n        }\n        return ans;\n    }\n};","author":"walk-alone","submissionId":"611237643"},[]]},{"1733":[{"id":"1733","fileName":"611238900.txt","sourceCode":"func minZeroArray(nums []int, queries [][]int) int {\n\tans := -1\n\tfor i, x := range nums {\n\n\t\tif x == 0 {\n\t\t\tans = max(ans, 0)\n\t\t\tcontinue\n\t\t}\n\n\t\tdp := make([]bool, 1015)\n\t\tdp[0] = true\n\t\tfor j, q := range queries {\n\t\t\tif i < q[0] || i > q[1] {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor k := x; k >= 0; k-- {\n\t\t\t\tdp[k+q[2]] = dp[k+q[2]] || dp[k]\n\t\t\t}\n\t\t\tif dp[x] {\n\t\t\t\tans = max(ans, j+1)\n\t\t\t\t// fmt.Println(i, j+1)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !dp[x] {\n\t\t\treturn -1\n\t\t}\n\t}\n\treturn ans\n}","author":"逍遥生","submissionId":"611238900"},[]]},{"1734":[{"id":"1734","fileName":"611238505.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        int ans = 0, can = 0;\n        for(int i = 0; i < n; i++) {\n            bitset<1001> dp;\n            dp[0] = 1;\n            if(dp[nums[i]]) {\n                ans = max(ans, 0);\n                can++;\n                continue;\n            }\n            for(int j = 0; j < q; j++) {\n                int l, r, val;\n                l = queries[j][0];\n                r = queries[j][1];\n                val = queries[j][2];\n                if(i >= l && i <= r) {\n                    dp |= dp << val;\n                }\n                if(dp[nums[i]]) {\n                    ans = max(ans, j + 1);\n                    can++;\n                    break;\n                }\n            }\n        }\n        return can == n ? ans : -1;\n    }\n};","author":"Khoray","submissionId":"611238505"},[]]},{"1735":[{"id":"1735","fileName":"611238870.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number}\n */\nvar minZeroArray = function(nums, queries) {\n    if(nums.every(u=>u==0))\n        return 0;\n    let a=nums.map(()=>new Set([0]));\n    for(let i=0;i<queries.length;i++){\n        for(let j=queries[i][0];j<=queries[i][1];j++){\n            let s=a[j];\n            for(let u of [...s]){\n                s.add(u+queries[i][2]);\n            }\n        }\n        if(a.every((u,i)=>u.has(nums[i])))\n            return i+1;\n    }\n    return -1;\n};","author":"wangzi","submissionId":"611238870"},[]]},{"1736":[{"id":"1736","fileName":"611238853.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n#define all(a) a.begin(), a.end()\nvoid print() { cout << 'n'; }\ntemplate <typename T, typename...Args>\nvoid print(T t, Args...args) { cout << t << ' '; print(args...); }\nusing ll = long long;\nconst int N = 1e5 + 5;\n\nint dir[4][2] = {\n    {1, 0}, {0, 1}, {-1, 0}, {0, -1}\n};\n\ntemplate <typename T> bool chmax(T &x, T y) { if (y > x) { x = y; return true; } return false; }\ntemplate <typename T> bool chmin(T &x, T y) { if (y < x) { x = y; return true; } return false; }\n\ntemplate <typename T = int>\nvector<T> readVector(int n) {\n    vector<T> a(n);\n    for(T &x: a) cin >> x;\n    return a;\n} \n\nclass Solution {\npublic:\n\tint minZeroArray(vector<int>& a, vector<vector<int>>& queries) {\n\t\tint n = a.size();\n\t\tint m = queries.size();\n\t\t\n\t\tif (ranges::count(a, 0) == n) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tauto check = [&](int lim) -> bool {\n\t\t\tvector<vector<int>> nums(n);\n\t\t\tfor (int j = 0; j <= lim; j ++) {\n\t\t\t\tauto& q = queries[j];\n\t\t\t\tint l = q[0];\n\t\t\t\tint r = q[1];\n\t\t\t\tint v = q[2];\n\t\t\t\tfor (int i = l; i <= r; i ++) {\n\t\t\t\t\tnums[i].push_back(v);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i ++) {\n\t\t\t\tbitset<1001> dp;\n\t\t\t\tdp[0] = 1;\n\t\t\t\tfor (int x : nums[i]) {\n\t\t\t\t\tdp |= dp << x;\n\t\t\t\t}\n\t\t\t\tif (dp[a[i]] == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t};\n\n\t\tint l = 0, r = m - 1, ans = -1;\n\t\twhile (l <= r) {\n\t\t\tint mid = l + r >> 1;\n\t\t\tcheck(mid) ? r = mid - 1, ans = mid : l = mid + 1;\n\t\t}\n\t\tif (ans != -1) {\n\t\t\tans ++;\n\t\t}\n\t\treturn ans;\n\t}\n};","author":"hhhhyf","submissionId":"611238853"},[]]},{"1737":[{"id":"1737","fileName":"611239187.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], qs: List[List[int]]) -> int:\n        n = len(nums)\n        if max(nums) == 0:\n            return 0\n        arr = [set([0]) for _ in range(n)]\n        for ii, (l, r, v) in enumerate(qs):\n            for j in range(l, r + 1):\n                for k in list(arr[j]):\n                    if k + v <= nums[j]:\n                        arr[j].add(k + v)\n            for i in range(n):\n                if nums[i] not in arr[i]:\n                    break\n            else:\n                return ii + 1\n        return -1\n                \n                \n        ","author":"Misaka Mikoto","submissionId":"611239187"},[]]},{"1738":[{"id":"1738","fileName":"611239368.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n=len(nums)\n        m=len(queries)\n        if sum(nums)==0:\n            return 0\n        res=[]\n        for k in range(n):\n            x=nums[k]\n            if nums[k]==0:\n                res.append(0)\n                continue\n            t=[]\n            for j,(l,r,v) in enumerate(queries):\n                if l<=k<=r:\n                    t.append((v,j))\n            if not t:\n                return -1\n            m=len(t)\n            # print(k,x,t)\n            @cache\n            def dfs(i,val):\n                if i==m:\n                    return inf\n                if val-t[i][0] == 0:\n                    return i\n                if val<0:\n                    return inf\n                return min(dfs(i+1,val-t[i][0]),dfs(i+1,val))\n            ans = dfs(0,x)\n\n            if ans==inf:\n                return -1\n            res.append(t[ans][1])\n            dfs.cache_clear()\n        # print(res)\n        return max(res)+1\n            \n            \n        \n        \n        ","author":"krism","submissionId":"611239368"},[]]},{"1739":[{"id":"1739","fileName":"611239118.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        tmp = [[] for _ in range(len(nums))]\n        for i, (left, right, val) in enumerate(queries):\n            for j in range(left, right+1):\n                tmp[j].append((i, val)) #idx, diff\n\n        @cache\n        def dfs(num, cur, i):\n            nonlocal this\n            if num <= 0: return\n            if cur >= len(tmp[i]): return\n\n            if num-tmp[i][cur][1] == 0:\n                this = min(this, tmp[i][cur][0])\n                return\n            dfs(num, cur+1, i)\n            dfs(num-tmp[i][cur][1], cur+1, i)\n\n        res = -inf\n        for i in range(len(tmp)):\n            this = inf\n            if nums[i] != 0:\n                dfs(nums[i], 0, i)\n            else:\n                this = -1\n\n            if this == inf: return -1\n            this += 1\n            res = max(res, this)\n        return res","author":"君影草","submissionId":"611239118"},[]]},{"1740":[{"id":"1740","fileName":"611238957.txt","sourceCode":"int dp[1005] ;\nint ans[15] ;\n\nint minZeroArray(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize) {\n    for(int i = 0; i < numsSize; ++ i)\n    {\n        ans[i] = -1 ;\n        int x = nums[i] ;\n        for(int j = 1; j <= x; ++ j) dp[j] = 0 ;\n        dp[0] = 1 ;\n        if(x > 0)\n        {\n            for(int j = 0; j < queriesSize; ++ j)\n            {\n                int l = queries[j][0], r = queries[j][1], val = queries[j][2] ;\n                if(l <= i && i <= r)\n                {\n                    for(int k = x; k >= val; -- k)\n                        dp[k] |= dp[k - val] ;\n                    if(dp[x])\n                    {\n                        ans[i] = j + 1 ;\n                        break ;\n                    }\n                }\n            }\n        }\n        else ans[i] = 0 ;\n        // printf(\"%d %dn\", i, ans[i]) ;\n        if(ans[i] == -1) return -1 ;\n    }\n\n    int ret = 0 ;\n    for(int i = 0; i < numsSize; ++ i)\n        if(ret < ans[i]) ret = ans[i] ;\n    return ret ;\n}","author":"半城烟沙","submissionId":"611238957"},[]]},{"1741":[{"id":"1741","fileName":"611240034.txt","sourceCode":"import java.util.*;\nimport java.math.BigInteger;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        \n        boolean allZero = true;\n        for (int num : nums) {\n            if (num > 0) {\n                allZero = false;\n                break;\n            }\n        }\n        if (allZero) return 0;\n\n        List<Integer> nonZeroIndices = new ArrayList<>();\n        for (int j = 0; j < n; j++) {\n            if (nums[j] > 0) {\n                nonZeroIndices.add(j);\n            }\n        }\n\n        int maxv = 1000;\n        BigInteger mask = BigInteger.ONE.shiftLeft(maxv + 1).subtract(BigInteger.ONE);  \n        BigInteger[] aux = new BigInteger[n]; \n        Arrays.fill(aux, BigInteger.ONE);  \n\n        for (int i = 0; i < queries.length; i++) {\n            int left = queries[i][0];\n            int right = queries[i][1];\n            int val = queries[i][2];\n\n            for (int j = left; j <= right; j++) {\n                if (nums[j] > 0) {  \n                    aux[j] = aux[j].or(aux[j].shiftLeft(val));\n                    aux[j] = aux[j].and(mask);\n                }\n            }\n\n            boolean flag = true;\n            for (int j : nonZeroIndices) {\n                if (!aux[j].testBit(nums[j])) {  \n                    flag = false;\n                    break;\n                }\n            }\n\n            if (flag) {\n                return i + 1;  \n            }\n        }\n        return -1;\n    }\n}\n","author":"耀民Allen","submissionId":"611240034"},[]]},{"1742":[{"id":"1742","fileName":"611239519.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        available = [[] for _ in range(n)]\n        for idx, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                if 0 <= i < n:\n                    available[i].append((idx, val))\n        \n        # 对每个元素的查询列表按查询的索引排序\n        for i in range(n):\n            available[i].sort()\n        \n        max_k = -1\n        for i in range(n):\n            target = nums[i]\n            if target == 0:\n                current_k = 0\n            else:\n                dp = {0: -1}\n                for (j, val) in available[i]:\n                    new_dp = {}\n                    for s in dp:\n                        current_max_j = dp[s]\n                        if s not in new_dp or current_max_j < new_dp[s]:\n                            new_dp[s] = current_max_j\n                    for s in list(dp.keys()):\n                        current_max_j = dp[s]\n                        new_s = s + val\n                        new_j = max(current_max_j, j)\n                        if new_s in new_dp:\n                            if new_j < new_dp[new_s]:\n                                new_dp[new_s] = new_j\n                        else:\n                            new_dp[new_s] = new_j\n                    dp = new_dp\n                if target in dp:\n                    current_k = dp[target] + 1 if dp[target] != -1 else 0\n                else:\n                    return -1\n            if current_k == -1:\n                return -1\n            max_k = max(max_k, current_k)\n        return max_k if max_k != -1 else -1","author":"SwissRoll","submissionId":"611239519"},[]]},{"1743":[{"id":"1743","fileName":"611240052.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int res = -1, n = nums.size(), m = queries.size(), cnt = 0;\n        for (int i = 0; i < n; i++) {\n            vector<int> dp(nums[i] + 1, 0);\n            dp[0] = 1;\n            if (nums[i] == 0) {\n                res = max(res, 0);\n                cnt++;\n                continue;\n            }\n            for (int j = 0; j < m; j++) {\n                int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                if (i >= l && i <= r) {\n                    for (int k = nums[i]; k >= val; k--)\n                        dp[k] |= dp[k - val];\n                }\n                if (dp[nums[i]] == 1) {\n                    res = max(res, j + 1);\n                    cnt++;\n                    break;\n                }\n            }\n        }\n        if (cnt < n) res = -1;\n        return res;\n    }\n};","author":"北棂","submissionId":"611240052"},[]]},{"1744":[{"id":"1744","fileName":"611239960.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        \n        int ans = -1;\n        for (int i = 0; i < n; i++) {\n            ans = max(ans, getCost(i, nums[i], queries));\n        }\n        \n        if (ans == INT_MAX) return -1;\n        else return ans;\n    }\n    int getCost(int index, int target, const vector<vector<int>> &queries) {\n        if (target == 0) return 0;\n        bitset<1001> bs;\n        bs.set(0);\n        for (int qi = 0; qi < queries.size(); qi++) {\n            int l = queries[qi][0];\n            int r = queries[qi][1];\n            int v = queries[qi][2];\n            if (l > index || r < index) continue;\n            bs |= (bs << v);\n            if (bs.test(target)) return qi + 1;\n        }\n        return INT_MAX;\n    }\n};","author":"seedjyh","submissionId":"611239960"},[]]},{"1745":[{"id":"1745","fileName":"611239308.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        elements_queries = [[] for _ in range(n)]\n        for idx, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                elements_queries[i].append((val, idx))\n\n        max_k = 0\n        for i in range(n):\n            target = nums[i]\n            if target == 0:\n                continue\n            q_list = elements_queries[i]\n            if not q_list:\n                return -1\n            dp = {0: -1}\n            for val, idx in q_list:\n                tmp_dp = {}\n                for s in list(dp.keys()):\n                    m = dp[s]\n                    if s in tmp_dp:\n                        if m < tmp_dp[s]:\n                            tmp_dp[s] = m\n                    else:\n                        tmp_dp[s] = m\n                    new_s = s + val\n                    new_m = max(m, idx)\n                    if new_s in tmp_dp:\n                        if new_m < tmp_dp[new_s]:\n                            tmp_dp[new_s] = new_m\n                    else:\n                        tmp_dp[new_s] = new_m\n                dp = tmp_dp\n            if target not in dp:\n                return -1\n            current_max_index = dp[target]\n            current_k = current_max_index + 1\n            if current_k > max_k:\n                max_k = current_k\n        return max_k if max_k != 0 else 0","author":"ning1ing","submissionId":"611239308"},[]]},{"1746":[{"id":"1746","fileName":"611240314.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        cnt_zero = nums.count(0)\n        if cnt_zero == n:\n            return 0\n\n        def helper(idx):\n            bit = 1 << nums[idx]\n            cur = 1\n            for i, (l, r, val) in enumerate(queries, 1):\n                if not (l <= idx <= r):\n                    continue\n                cur |= cur << val\n                if cur & bit:\n                    return i\n            return 10 ** 9\n\n        res = [helper(i) for i in range(n)]\n        k = max(res)\n        return k if k != 10 ** 9 else -1\n","author":"Fzldq","submissionId":"611240314"},[]]},{"1747":[{"id":"1747","fileName":"611240084.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        auto check = [&](int k) -> bool {\n            for (int j = 0; j < n; j++) {\n                bitset<1100> dp;\n                dp[0] = 1;\n                for (int i = 0; i < k; i++) {\n                    int li = queries[i][0], ri = queries[i][1], val = queries[i][2];\n                    if (li <= j && j <= ri) {\n                        dp |= (dp << val);\n                    }\n                }\n                if (!dp[nums[j]])\n                    return false;\n            }\n            return true;\n        };\n        \n        int l = 0, r = m;\n        while (l < r) {\n            int mid = (l + r) / 2;\n            if (check(mid)) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        if (check(l)) return l;\n        return -1;\n    }\n};\n","author":"discipline","submissionId":"611240084"},[]]},{"1748":[{"id":"1748","fileName":"611240067.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == 0) continue;\n            set<int> s;\n            s.insert(0);\n            for (int j = 0; j < queries.size(); j++) {\n                if (i >= queries[j][0] && i <= queries[j][1]) {\n                    set<int> ss;\n                    for (auto f : s) {\n                        if (f + queries[j][2] <= nums[i]) {\n                            ss.insert(f + queries[j][2]);\n                        }\n                    }\n                    for (auto f : ss) s.insert(f);\n                }\n                if (s.find(nums[i]) != s.end()) {\n                    ans = max(ans, j + 1);\n                    break;\n                }\n            }\n            if (s.find(nums[i]) == s.end()) return -1;\n        }\n        return ans;\n    }\n};","author":"若讷","submissionId":"611240067"},[]]},{"1749":[{"id":"1749","fileName":"611240426.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        int ans=0;\n        for(int i=0;i<n;i++){\n            bitset<1001> b;\n            b[0]=1;\n            int s=0;\n            if(nums[i]==0)\n                continue;\n            bool f=false;\n            for(auto &j:queries){\n                if(i>=j[0]&&i<=j[1])\n                    b=b|b<<j[2];\n                ++s;\n                if(b[nums[i]]){\n                    ans=max(ans,s);\n                    f=true;\n                    break;\n                }\n            }\n            if(!f)\n                return -1;\n        }\n        return ans;\n    }\n};","author":"Max.D.","submissionId":"611240426"},[]]},{"1750":[{"id":"1750","fileName":"611240301.txt","sourceCode":"bool dp[1005];\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans=0, N=nums.size(), Q=queries.size();\n        for(int Ti=0; Ti<N; ++Ti){\n            // make T\n            int T = nums[Ti];\n            if(T!=0){\n                memset(dp, false, sizeof(bool)*(T+1));\n                dp[0] = true;\n                for(int q=0; q<Q; ++q){\n                    int li=queries[q][0], ri=queries[q][1], vi=queries[q][2];\n                    if(Ti>=li and Ti<=ri){\n                        for(int v=T-vi; v>=0; --v){\n                            if(dp[v]){\n                                dp[v+vi] = true;\n                            }\n                        }\n                        if(dp[T]){\n                            ans = max(ans, q+1);\n                            break;\n                        }\n                    }\n                }\n                if(!dp[T]){\n                    return -1;\n                }\n            }\n        }\n        return ans;\n    }\n};\n","author":"伽利略","submissionId":"611240301"},[]]},{"1751":[{"id":"1751","fileName":"611240399.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        vector<vector<int>> dp(n);\n        for(int i=0;i<n;i++)\n            dp[i].resize(nums[i]+1,0);\n        int len=queries.size();\n        int sum=0;\n        for(int i=0;i<n;i++){\n            dp[i][0]=1;\n            sum+=dp[i][nums[i]];\n        }\n        if(sum>=n)\n            return 0;\n        for(int i=0;i<queries.size();i++){\n            int l=queries[i][0],r=queries[i][1],val=queries[i][2];\n            while(l<=r){\n                for(int j=nums[l]-val;j>=0;j--){\n                    dp[l][j+val]=max(dp[l][j+val],dp[l][j]);\n                }\n                l++;\n            }\n            sum=0;\n            for(int j=0;j<n;j++)\n                sum+=dp[j][nums[j]];\n            if(sum>=n)\n                return i+1;\n        }\n        return -1;\n    }\n};","author":"Bold NoyceaZ0","submissionId":"611240399"},[]]},{"1752":[{"id":"1752","fileName":"611240113.txt","sourceCode":"const int N=1e3+10;\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(),m=queries.size();vector<bitset<N>> dp(n);\n        for(int i{0};i<n;i++){\n        \tdp[i].reset();dp[i].set(0,true);\n        }bool f=true;\n        for(int i{0};i<n;i++){\n        \tif(!dp[i].test(nums[i])){\n        \t\tf=false;break;\n        \t}\n        }if(f)return 0;\n        for(int i{0};i<m;i++){\n        \tint l=queries[i][0],r=queries[i][1],v=queries[i][2];\n        \tfor(int j{l};j<=r;j++)dp[j]|=(dp[j]<<v);\n        \tbool c=true;\n        \tfor(int j{0};j<n;j++){\n        \t\tif(!dp[j].test(nums[j])){\n        \t\t\tc=false;break;\n        \t\t}\n        \t}if(c)return i+1;\n        }return -1;\n    }\n};","author":"forgo","submissionId":"611240113"},[]]},{"1753":[{"id":"1753","fileName":"611240617.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size(), res = 0;\n        vector<int> dp(1001);\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == 0) continue;\n            fill(dp.begin(), dp.end(), 0);\n            dp[nums[i]] = 1;\n            for (int j = 0; j < m; ++j) {\n                int l = queries[j][0], r = queries[j][1], v = queries[j][2];\n                if (l <= i && i <= r) {\n                    for (int x = v; x <= nums[i]; ++x) \n                        dp[x - v] |= dp[x];\n                }\n                if (dp[0]) {\n                    res = max(res, j + 1);\n                    break;\n                }\n            }\n            if (!dp[0]) return -1;\n        }\n        return res;\n    }\n};","author":"abyss","submissionId":"611240617"},[]]},{"1754":[{"id":"1754","fileName":"611240540.txt","sourceCode":"class Solution {\n    int dp[1005][1005] = {0};\n    int cur[1005][1005] = {0};\n    int cnt[1005] = {0};\n    bool dfs(int t,int id,int target){\n        if(target == 0){\n            return true;\n        }\n        //cout<<t<<\" \"<<id<<endl;\n        int val = cur[t][id];\n        if(id == 0){\n            return val == target;\n        }\n        \n        if(dp[id][target] != -1){\n            return dp[id][target] == 1;\n        }\n        bool ans = dfs(t,id-1,target);\n        if(target >= val)\n            ans |= dfs(t,id-1,target-val);\n        if(ans){\n            dp[id][target] = 1;\n        }else{\n            dp[id][target] = 0;\n        }\n        return ans;\n    }\n    bool f(int id,int target){\n        int n = cnt[id];\n        for(int i = 0;i<n;i++){\n            for(int j = 0;j<=target;j++){\n                dp[i][j] = -1;\n            }\n        }\n        if(n == 0){\n            return target == 0;\n        }\n        return dfs(id,n-1,target);\n    }\n    bool func(int t,vector<int>& nums, vector<vector<int>>& q){\n        int n = nums.size();\n        for(int i = 0;i<n;i++){\n            cnt[i] = 0;\n        }\n        for(int i = 0;i<t;i++){\n            for(int j = q[i][0];j<=q[i][1];j++){\n                int id = cnt[j];\n                cur[j][id] = q[i][2];\n                cnt[j]++;\n            }\n        }\n        for(int i = 0;i<n;i++){\n            if(!f(i,nums[i])){\n                return false;\n            }\n        }\n        return true;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n        int m = q.size();\n        if(!func(m,nums,q)){\n            return -1;\n        }\n        int l = 0,r = m;\n        while(l<r){\n            int mid = (l+r)>>1;\n            if(func(mid,nums,q)){\n                r = mid;\n            }else{\n                l = mid+1;\n            }\n        }\n        return l;\n    }\n};","author":"sheldon","submissionId":"611240540"},[]]},{"1755":[{"id":"1755","fileName":"611241024.txt","sourceCode":"package main\n\n// https://space.bilibili.com/206214\nfunc minZeroArray(a []int, qs [][]int) (ans int) {\n\tc0 := 0\n\tfor _, v := range a {\n\t\tif v == 0 {\n\t\t\tc0++\n\t\t}\n\t}\n\tif c0 == len(a) {\n\t\treturn 0\n\t}\n\n\tn := len(a)\n\tf := make([][]bool, n)\n\tfor i, v := range a {\n\t\tf[i] = make([]bool, v+1)\n\t\tf[i][0] = true\n\t}\no:\n\tfor qid, q := range qs {\n\t\tl, r, v := q[0], q[1], q[2]\n\t\tfor i := l; i <= r; i++ {\n\t\t\tfor j := a[i]; j >= v; j-- {\n\t\t\t\tf[i][j] = f[i][j] || f[i][j-v]\n\t\t\t}\n\t\t}\n\t\tfor i, row := range f {\n\t\t\tif !row[a[i]] {\n\t\t\t\tcontinue o\n\t\t\t}\n\t\t}\n\t\treturn qid + 1\n\t}\n\treturn -1\n}\n","author":"灵茶山艾府","submissionId":"611241024"},[]]},{"1756":[{"id":"1756","fileName":"611241047.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if all(x == 0 for x in nums): return 0\n        a = [1 << x for x in nums]\n        for k, (l, r, v) in enumerate(queries, 1):\n            for i in range(l, r + 1):\n                a[i] |= a[i] >> v\n            if all(x & 1 for x in a): return k\n        return -1","author":"cheng-liang-yu","submissionId":"611241047"},[]]},{"1757":[{"id":"1757","fileName":"611241399.txt","sourceCode":"class Solution {\npublic:\n  int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    int ans = 0;\n    int n = nums.size();\n    vector<bitset<1001>> A(n);\n    for (int i = 0; i < n; i++) A[i][nums[i]]=true;\n    bool ok = true;\n    for (auto &x: A) if (!x[0]) ok = false;\n    if (ok) return ans;\n    \n    for (auto q: queries) {\n      ans++;\n      int l = q[0], r = q[1], x = q[2];\n      for (int i = l; i <= r; i++) A[i]|=A[i]>>x;\n      bool ok = true;\n      for (auto &x: A) if (!x[0]) ok = false;\n      if (ok) return ans;\n    }\n    return -1;\n  }\n};","author":"Darren Hp","submissionId":"611241399"},[]]},{"1758":[{"id":"1758","fileName":"611239159.txt","sourceCode":"def bs(a, x):\n    l, r = 0, len(a) - 1\n    while l <= r:\n        m = (l + r) // 2\n        if a[m] == x:\n            return m\n        if a[m] < x:\n            l = m + 1\n        else:\n            r = m - 1\n    return -1\n\ndef st(a):\n    n = len(a)\n    s = 1\n    while s < n:\n        s *= 2\n    t = [0] * (2 * s)\n    for i in range(n):\n        t[s + i] = a[i]\n    for i in range(s - 1, 0, -1):\n        t[i] = t[2 * i] + t[2 * i + 1]\n    def q(l, r):\n        l += s; r += s; tot = 0\n        while l <= r:\n            if l & 1:\n                tot += t[l]\n                l += 1\n            if not (r & 1):\n                tot += t[r]\n                r -= 1\n            l //= 2; r //= 2\n        return tot\n    return t, q\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        \n        dp = [1] * len(nums)\n        c = [(1 << (num + 1)) - 1 for num in nums]\n        \n        if all(x == 0 for x in nums):\n            return 0\n                \n        for k, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                dp[i] |= (dp[i] << val)\n                dp[i] &= c[i]\n            if all(dp[i] & (1 << nums[i]) for i in range(len(nums))):\n                return k + 1\n        return -1\n","author":"Cranky 6agarinizJ","submissionId":"611239159"},[]]},{"1759":[{"id":"1759","fileName":"611241499.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        covered = [[] for _ in range(n)]\n        for j in range(m):\n            l, r, val = queries[j]\n            for i in range(n):\n                if l <= i <= r:\n                    covered[i].append((j, val))\n        \n        max_k = 0\n        for i in range(n):\n            num = nums[i]\n            if num == 0:\n                continue \n            \n            queries_i = covered[i]\n            if not queries_i:\n                return -1\n            \n            dp = {0: -1}\n            for (j_index, val) in queries_i:\n                new_dp = {}\n                for s in dp:\n                    current_max = dp[s]\n                    if s in new_dp:\n                        if current_max < new_dp[s]:\n                            new_dp[s] = current_max\n                    else:\n                        new_dp[s] = current_max\n                    new_s = s + val\n                    if new_s > num:\n                        continue\n                    new_max = max(current_max, j_index)\n                    if new_s in new_dp:\n                        if new_max < new_dp[new_s]:\n                            new_dp[new_s] = new_max\n                    else:\n                        new_dp[new_s] = new_max\n                dp = new_dp\n            \n            if num not in dp:\n                return -1\n            k_i = dp[num] + 1 \n            if k_i > max_k:\n                max_k = k_i\n        zero_count = sum(1 for x in nums if x == 0)\n        if zero_count == n:\n            return 0\n        if max_k > m:\n            return -1\n        return max_k if max_k != 0 else -1","author":"终不负少年游","submissionId":"611241499"},[]]},{"1760":[{"id":"1760","fileName":"611241566.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        bitset<1010> f[10];\n        int n=nums.size();\n        for(int i=0;i<n;++i) f[i][0]=1;\n        int ans=0;\n        \n        // for(auto &q:queries){\n        for(int k=0;k<queries.size();++k){\n            auto &q=queries[k];\n            for(int i=q[0];i<=q[1];++i)if(f[i][nums[i]]==0){\n                f[i] |= (f[i]<<q[2]);\n                if(f[i][nums[i]]){\n                    ans=max(ans,k+1);\n                }\n            }\n        }\n        for(int i=0;i<n;++i)\n            if(f[i][nums[i]]==0) return -1;\n        return ans;\n    }\n};","author":"jillscat","submissionId":"611241566"},[]]},{"1761":[{"id":"1761","fileName":"611241019.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        r = -1\n        dp = [0]*1001\n        for i in range(n):\n            v = nums[i]\n            if v==0:\n                r = max(r, 0)\n                continue\n            xx = []\n            for j in range(m):\n                a, b, c = queries[j]\n                if i<a or i>b: continue\n                xx.append((c, j))\n            x = len(xx)\n            for z in range(v+1): dp[z]=m+10\n            dp[0]=0\n            for c, k in xx:\n                vv=v\n                while vv>=c:\n                    dp[vv]=min(dp[vv], max(dp[vv-c], k+1))\n                    vv-=1\n                if dp[v]!=m+10:\n                    break\n            # print(v, dp[:v+1], xx)\n            r = max(r, dp[v])\n        if r>m: r=-1\n        return r\n                \n            \n            \n        ","author":"82年的muggle","submissionId":"611241019"},[]]},{"1762":[{"id":"1762","fileName":"611241527.txt","sourceCode":"bool f[11][2111];\nint n, m;\nvector<int> a;\nclass Solution {\npublic:\n    bool check() {\n        for (int i = 0; i < n; ++i) {\n            if (!f[i][a[i]]) return false;\n        }\n        return true;\n    }\n\n    void update(int l, int r, int x) {\n        for (int i = l; i <= r; ++i) {\n            for (int j = 1000; j >= x; --j) {\n                f[i][j] |= f[i][j-x];\n            }\n        }\n    }\n\n    int minZeroArray(vector<int>& _a, vector<vector<int>>& q) {\n        a = _a;\n        n = a.size();\n        m = q.size();\n        memset(f, 0, sizeof(f));\n        for (int i = 0; i < n; ++i) {\n            f[i][0] = 1;\n        }\n        if (check()) return 0;\n        for (int i = 0; i < m; ++i) {\n            update(q[i][0], q[i][1], q[i][2]);\n            if (check()) return i+1;\n        }\n        return -1;\n    }\n};","author":"summerdaway","submissionId":"611241527"},[]]},{"1763":[{"id":"1763","fileName":"611241701.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size(), m = q.size();\n        if(accumulate(a.begin(), a.end(), 0) == 0) return 0;\n        auto check = [&](int m) {\n            vector<vector<int>> op(n);\n            for(int i = 0; i < m; i ++) {\n                int l = q[i][0], r = q[i][1], val = q[i][2];\n                for(int k = l; k <= r; k ++) op[k].push_back(val);\n            }\n            for(int i = 0; i < n; i ++) {\n                vector<int> f(a[i] + 1, 0);\n                f[0] = 1;\n                for(int j = 0; j < op[i].size(); j ++) {\n                    if(op[i][j] > a[i]) continue;\n                    for(int k = a[i]; k >= op[i][j]; k --)\n                        f[k] |= f[k - op[i][j]];\n                }\n                // cout << m << endl;\n                // for(int j = 0; j <= a[i]; j ++) cout << f[j] << \" \"; cout << endl;\n                if(f[a[i]] == 0) return false;\n            }\n            return true;\n        };\n        if(check(m) == 0) return -1;\n        int l = 1, r = m;\n        while(l < r) {\n            int mid = (l + r) / 2;\n            if(check(mid)) r = mid;\n            else l = mid + 1;\n        }\n        return l;\n    }\n};","author":"Stupefied Pare6Le","submissionId":"611241701"},[]]},{"1764":[{"id":"1764","fileName":"611241498.txt","sourceCode":"import java.util.*;\n\nclass Solution extends U {\n\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length, q = queries.length;\n        boolean zero = true;\n        for (int i : nums) {\n            if (i != 0) {\n                zero = false;\n                break;\n            }\n        }\n        if (zero) {\n            return 0;\n        }\n        int[][] cnt = new int[n][11];\n        int l = 0, r = q - 1, x;\n        while (l <= r) {\n            x = (l + r) >> 1;\n            for (int i = 0; i < n; i++) {\n                Arrays.fill(cnt[i], 0);\n            }\n            for (int i = 0; i <= x; i++) {\n                int v = queries[i][2];\n                for (int j = queries[i][0]; j <= queries[i][1]; j++) {\n                    cnt[j][v]++;\n                }\n            }\n            boolean ok = true;\n            for (int z = 0; z < n; z++) {\n                int s = nums[z];\n                List<Integer> list = new ArrayList<>();\n                for (int i = 1; i <= 10; i++) {\n                    if (cnt[z][i] > 0) {\n                        int v = cnt[z][i];\n                        for (int t = 1; t <= v; t <<= 1) {\n                            list.add(t * i);\n                            v -= t;\n                        }\n                        if (v > 0) {\n                            list.add(v * i);\n                        }\n                    }\n                }\n                int m = list.size();\n                boolean[][] dp = new boolean[m + 1][s + 1];\n                dp[m][0] = true;\n                for (int i = m - 1; i >= 0; i--) {\n                    int v = list.get(i);\n                    for (int j = 0; j <= s; j++) {\n                        dp[i][j] = dp[i + 1][j] || (j >= v && dp[i + 1][j - v]);\n                    }\n                }\n                if (!dp[0][s]) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) {\n                r = x - 1;\n            } else {\n                l = x + 1;\n            }\n        }\n        r += 2;\n        return r > q ? -1 : r;\n    }\n}\n\nclass U {                                                                                                                                                                                                                WU out=new WU();class WU{private java.io.OutputStream out=System.out;WU print(byte b){try{out.write(b);}catch(Exception e){}return this;}WU print(char c){return print((byte)c);}WU print(int x){return print(String.valueOf(x));}WU print(long x){return print(String.valueOf(x));}WU print(double x){return print(String.valueOf(x));}WU print(String s){for(int i=0;i<s.length();i++)print((byte)s.codePointAt(i));return this;}void writeln(){print((byte)'n');}void println(byte b){print(b).writeln();}void println(char c){print(c).writeln();}void println(int x){print(x).writeln();}void println(long x){print(x).writeln();}void println(double x){print(x).writeln();}void println(String s){print(s).writeln();}void println(Object o){deepPrint(o,true);}private void deepPrint(Object o,boolean f){if(o==null){print(f?\"nulln\":\"null\");return;}Class<?>c=o.getClass();if(c.isArray()){if(o instanceof Object[]){Object[]t=(Object[])o;int n=t.length;boolean b=f&&n>0&&t[0]!=null;print(b?\"[n\":\"[\");for(int i=0;i<n;i++){deepPrint(t[i],false);if(i<n-1)print(b?\", n\":\", \");else if(b)writeln();}print(\"]\");}else{print(o instanceof byte[]?Arrays.toString((byte[])o):o instanceof short[]?Arrays.toString((short[])o):o instanceof int[]?Arrays.toString((int[])o):o instanceof long[]?Arrays.toString((long[])o):o instanceof char[]?Arrays.toString((char[])o):o instanceof float[]?Arrays.toString((float[])o):o instanceof double[]?Arrays.toString((double[])o):Arrays.toString((boolean[])o));}}else if(o instanceof Collection){Collection<?>t=(Collection<?>)o;print(\"[\");int i=0;for(Object v:t){deepPrint(v,false);if(i<t.size()-1)print(\", \");i++;}print(\"]\");}else if(o instanceof Map){Map<?,?>t=(Map<?,?>)o;print(!t.isEmpty()&&f?\"{n\":\"{\");int i=0;for(Map.Entry<?,?>v:t.entrySet()){deepPrint(v.getKey(),false);print(\" = \");deepPrint(v.getValue(),false);if(++i<t.size())print(f?\", n\":\", \");else if(f)writeln();}print(\"}\");}else{print(o.toString());}if(f)writeln();}}int min(int a,int b){return a>b?b:a;}int min(int...args){int ans=Integer.MAX_VALUE;for(int v:args)if(ans>v)ans=v;return ans;}long min(long a,long b){return a>b?b:a;}long min(long...args){long ans=Long.MAX_VALUE;for(long v:args)if(ans>v)ans=v;return ans;}double min(double a,double b){return a>b?b:a;}double min(double...args){double ans=Double.MAX_VALUE;for(double v:args)if(ans>v)ans=v;return ans;}int max(int a,int b){return a<b?b:a;}int max(int...args){int ans=Integer.MIN_VALUE;for(int v:args)if(ans<v)ans=v;return ans;}long max(long a,long b){return a<b?b:a;}long max(long...args){long ans=Long.MIN_VALUE;for(long v:args)if(ans<v)ans=v;return ans;}double max(double a,double b){return a<b?b:a;}double max(double...args){double ans=Double.MIN_VALUE;for(double v:args)if(ans<v)ans=v;return ans;}int abs(int a){return a<0?-a:a;}long abs(long a){return a<0?-a:a;}double abs(double a){return a<0?-a:a;}\n}","author":"lyongwolf","submissionId":"611241498"},[]]},{"1765":[{"id":"1765","fileName":"611241819.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        lo, hi = 0, m + 1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            res = [1] * n\n            for j in range(mid):\n                l, r, v = queries[j]\n                for i in range(l, r + 1):\n                    res[i] |= res[i] << v\n            ok = True\n            for i in range(n):\n                if (res[i] >> nums[i]) & 1 == 0:\n                    ok = False\n                    break\n            if ok:\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo if lo <= m else -1","author":"Alex-Yan","submissionId":"611241819"},[]]},{"1766":[{"id":"1766","fileName":"611241885.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n\n        vector<vector<pair<int,int>>>v(n);\n        for(int i=0;i<m;++i){\n            int l =queries[i][0],r=queries[i][1],val=queries[i][2];\n            for(int j=l;j<=r;++j){\n                v[j].emplace_back(i,val);\n            }\n        }\n\n        int mk=-1;\n        for(int i=0;i<n;++i){\n            int cur =nums[i];\n            if(cur==0)continue;\n            vector<pair<int,int>> tv=v[i];\n\n            if(tv.empty())return -1;\n            int tgt=cur;\n            unordered_map<int,int>dp;\n            dp[0]=0;\n\n            for(int j=0;j<tv.size();++j){\n                int val =tv[j].second;\n                unordered_map<int,int>tdp(dp);\n\n                for(auto p :dp){\n                    int ns  =p.first+val;\n                    if(ns>tgt)continue;\n                    int nt = max(p.second,j+1);\n                    if(tdp.find(ns)==tdp.end()||nt<tdp[ns])tdp[ns]=nt;\n                }\n\n                dp=move(tdp);\n            }\n\n            if(dp.find(tgt)==dp.end())return -1;\n            int tj=dp[tgt];\n            if(tj>tv.size())return -1;\n            int li=tv[tj-1].first;\n            mk=max(mk,li);\n        }\n\n        return mk==-1?0:mk+1;\n    }\n};","author":"蛋弟","submissionId":"611241885"},[]]},{"1767":[{"id":"1767","fileName":"611241651.txt","sourceCode":"from sortedcontainers import SortedList\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        \n        count = n\n        dp_mat = []\n        for num in nums:\n            dp = [0] * (num + 1)\n            dp[num] = 1\n            if num == 0:\n                count -= 1\n            dp_mat.append(dp)\n        \n        if count == 0:\n            return 0\n        \n        for i in range(m):\n            left, right, val = queries[i]\n            for j in range(left, right + 1):\n                num = nums[j]\n                if dp_mat[j][0] == 0 and val <= num:\n                    for k in range(num - val + 1):\n                        if dp_mat[j][k + val] == 1:\n                            dp_mat[j][k] = 1\n                    if dp_mat[j][0] == 1:\n                        count -= 1\n            # print(dp_mat)\n            if count == 0:\n                return i + 1\n        return -1\n        \n            \n        ","author":"Admiring ShockleyZns","submissionId":"611241651"},[]]},{"1768":[{"id":"1768","fileName":"611242057.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int queriesCount = queries.length;\n        int length = nums.length;\n        int maxNum = Arrays.stream(nums).max().getAsInt();\n        boolean[][][] dp = new boolean[queriesCount + 1][length][maxNum + 1];\n        for (int j = 0; j < length; j++) {\n            dp[0][j][nums[j]] = true;\n        }\n        if (allZeroPossible(dp[0])) {\n            return 0;\n        }\n        for (int i = 1; i <= queriesCount; i++) {\n            for (int j = 0; j < length; j++) {\n                System.arraycopy(dp[i - 1][j], 0, dp[i][j], 0, maxNum + 1);\n            }\n            int left = queries[i - 1][0], right = queries[i - 1][1], val = queries[i - 1][2];\n            for (int j = left; j <= right; j++) {\n                for (int k = maxNum - val; k >= 0; k--) {\n                    dp[i][j][k] = dp[i][j][k] || dp[i - 1][j][k + val];\n                }\n            }\n            if (allZeroPossible(dp[i])) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    public boolean allZeroPossible(boolean[][] dpCurr) {\n        int length = dpCurr.length;\n        for (int j = 0; j < length; j++) {\n            if (!dpCurr[j][0]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}","author":"冰淇淋","submissionId":"611242057"},[]]},{"1769":[{"id":"1769","fileName":"611241569.txt","sourceCode":"\nclass Solution {\n  public:\n    int minZeroArray(vector<int> &nums, vector<vector<int>> &queries) {\n        int n = (int)nums.size(), m = (int)queries.size();\n\n        int zeros = 0;\n        vector<unordered_set<int>> rests(n);\n        for (int i = 0; i < n; i++) {\n            rests[i].insert(nums[i]);\n            if (nums[i] == 0) {\n                ++zeros;\n            }\n        }\n\n        if (zeros == n) {\n            return 0;\n        }\n        for (int j = 0; j < m; j++) {\n            auto &query = queries[j];\n            auto l = query[0], r = query[1], val = query[2];\n\n            for (int i = l; i <= r; i++) {\n                if (rests[i].contains(0)) {\n                    continue;\n                }\n                if (rests[i].contains(val)) {\n                    ++zeros;\n                    rests[i].insert(0);\n                    continue;\n                }\n\n                vector<int> temp;\n                for (auto x : rests[i]) {\n                    if (x > val) {\n                        temp.push_back(x - val);\n                    }\n                }\n                for (auto x : temp) {\n                    rests[i].insert(x);\n                }\n            }\n\n            if (zeros == n) {\n                return j + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"丁真今天写什么","submissionId":"611241569"},[]]},{"1770":[{"id":"1770","fileName":"611242546.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def work(k, t):\n            if t == 0:\n                return 0\n            q = {0}\n            for i in range(len(queries)):\n                l, r, v = queries[i]\n                if l <= k <= r:\n                    w = set([x + v for x in q  if x + v <= t])\n                    q = w | q\n                if t in q:\n                    return i + 1\n            return -1\n\n        ret = -1\n        for i in range(len(nums)):\n            z = work(i, nums[i])\n            # print(i, nums[i], z)\n            if z != -1:\n                ret = max(ret, z)\n            else:\n                return -1\n        return ret","author":"thuczh","submissionId":"611242546"},[]]},{"1771":[{"id":"1771","fileName":"611242562.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int[] times = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            int time = deal(i, nums[i], queries);\n            \n            if (time == -1) {\n                return -1;\n            }\n            times[i] = time;\n        }\n        \n        int result = times[0];\n        for (int i = 1; i < n; i++) {\n            result = Math.max(result, times[i]);\n        }\n        \n        return result;\n    }\n    \n    private int deal(int pos, int value, int[][] queries) {\n        if (value == 0) {\n            return 0;\n        }\n        HashSet<Integer> set = new HashSet<>();\n        set.add(value);\n        \n        for (int i = 0; i < queries.length; i++) {\n            int[] query = queries[i];\n            \n            int l = query[0];\n            int r = query[1];\n            int v = query[2];\n            \n            if (l <= pos && pos <= r) {\n                if (set.contains(v)) {\n                    return i + 1;\n                }\n\n                HashSet<Integer> temp = new HashSet<>();\n                for (int x: set) {\n                    temp.add(x);\n                    if (x - v > 0) {\n                        temp.add(x - v);\n                    }\n                }\n                set = temp;\n            }\n            \n        }\n        return -1;\n    }\n}","author":"Astric","submissionId":"611242562"},[]]},{"1772":[{"id":"1772","fileName":"611242765.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int max = 0;\n        int n = nums.length;\n        int m = queries.length;\n        int L = 1000;\n        for(int i=0;i<n;i++) {\n            if(nums[i] == 0) continue;\n            boolean[] v = new boolean[L+1];\n            v[0] = true;\n            for(int j=0;j<m;j++) {\n                if(queries[j][0]>i || queries[j][1]<i) continue;\n                for(int k=L;k>=queries[j][2];k--) {\n                    if(v[k-queries[j][2]]) v[k] = true;\n                }\n                // System.out.println(String.format(\"%d %d %s\",i,j,Arrays.toString(v)));\n                if(v[nums[i]]) {\n                    max = Math.max(j+1,max);\n                    break;\n                }\n            }\n            if(!v[nums[i]]) return -1;\n        }\n        return max;\n    }\n}","author":"Knarf","submissionId":"611242765"},[]]},{"1773":[{"id":"1773","fileName":"611241860.txt","sourceCode":"class Solution {\npublic:\n    struct Query {\n    int index;\n    int val;\n    bool operator<(const Query& other) const {\n        return index < other.index;\n    }\n};\n\nint minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    int n = nums.size();\n    int m = queries.size();\n    \n    vector<vector<pair<char, Query>>> events(n + 1);\n    for (int k = 0; k < m; ++k) {\n        int li = queries[k][0];\n        int ri = queries[k][1];\n        int val = queries[k][2];\n        if (li < 0) li = 0;\n        if (ri >= n) ri = n - 1;\n        if (li > ri) continue;\n        Query q = {k, val};\n        events[li].emplace_back('s', q);\n        if (ri + 1 < n) {\n            events[ri + 1].emplace_back('e', q);\n        } else if (ri + 1 == n) {\n            events[n].emplace_back('e', q);\n        }\n    }\n    \n    vector<vector<Query>> cover(n);\n    set<Query> active;\n    for (int i = 0; i < n; ++i) {\n        for (auto& ev : events[i]) {\n            if (ev.first == 's') {\n                active.insert(ev.second);\n            } else {\n                active.erase(ev.second);\n            }\n        }\n        cover[i].assign(active.begin(), active.end());\n    }\n    \n    int max_k = 0;\n    for (int i = 0; i < n; ++i) {\n        if (nums[i] == 0) continue;\n        const vector<Query>& cq = cover[i];\n        if (cq.empty()) return -1;\n        unordered_map<int, int> dp;\n        dp[0] = -1;\n        bool found = false;\n        int current_k = -1;\n        for (const Query& q : cq) {\n            int v = q.val;\n            int idx = q.index;\n            unordered_map<int, int> tmp;\n            for (const auto& entry : dp) {\n                int s = entry.first;\n                int max_idx = entry.second;\n                int new_sum = s + v;\n                int new_max = max(max_idx, idx);\n                if (tmp.find(new_sum) == tmp.end() || new_max < tmp[new_sum]) {\n                    tmp[new_sum] = new_max;\n                }\n            }\n            for (const auto& entry : tmp) {\n                int s = entry.first;\n                int new_max = entry.second;\n                if (dp.find(s) == dp.end() || new_max < dp[s]) {\n                    dp[s] = new_max;\n                }\n            }\n            if (dp.find(nums[i]) != dp.end()) {\n                current_k = dp[nums[i]] + 1;\n                found = true;\n                break;\n            }\n        }\n        if (!found) return -1;\n        max_k = max(max_k, current_k);\n    }\n    return max_k;\n}\n};","author":"MaloFleur","submissionId":"611241860"},[]]},{"1774":[{"id":"1774","fileName":"611242662.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int count0 = 0, maxNum = 0;\n        for (int i = 0; i < nums.length; i++) {\n        \tif (nums[i] == 0) {\n        \t\tcount0++;\n        \t}\n        \tmaxNum = Math.max(maxNum, nums[i]);\n        }\n        if (count0 == nums.length) {\n        \treturn 0;\n        }\n        \n        int[][] status = new int[nums.length][maxNum + 1];\n        for (int i = 0; i < queries.length; i++) {\n        \tint l = queries[i][0], r = queries[i][1], val = queries[i][2];\n        \tfor (int j = l; j <= r; j++) {\n        \t\tif (nums[j] == 0) {\n        \t\t\tcontinue;\n        \t\t}\n        \t\tfor (int k = maxNum; k >= 0; k--) {\n        \t\t\tif (status[j][k] != 0 || k == 0) {\n        \t\t\t\tint next = k + val;\n        \t\t\t\tif (next <= maxNum) {\n        \t\t\t\t\tstatus[j][next] = 1;\n        \t\t\t\t\tif (next == nums[j]) {\n        \t\t\t\t\t\tnums[j] = 0;\n        \t\t\t\t\t\tcount0++;\n        \t\t\t\t\t\tif (count0 == nums.length) {\n        \t\t\t\t\t\t\treturn i + 1;\n        \t\t\t\t\t\t}\n        \t\t\t\t\t}\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n        \n        return -1;\n    }\n}","author":"成长- 追梦","submissionId":"611242662"},[]]},{"1775":[{"id":"1775","fileName":"611242808.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        cover = [[] for _ in range(n)]\n        for j, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                cover[i].append((j, val))\n        \n        for i in range(n):\n            cover[i].sort(key=lambda x: x[0])\n        \n        max_indices = []\n        for i in range(n):\n            target = nums[i]\n            if target == 0:\n                max_indices.append(-1)\n                continue\n            dp = {0: -1}\n            for (j, val) in cover[i]:\n                new_dp = {}\n                for x in list(dp.keys()):\n                    new_x = x + val\n                    new_max = max(dp[x], j)\n                    if new_x in dp:\n                        if new_max < dp[new_x]:\n                            new_dp[new_x] = new_max\n                    else:\n                        new_dp[new_x] = new_max\n                for x in new_dp:\n                    if x not in dp or new_dp[x] < dp[x]:\n                        dp[x] = new_dp[x]\n            if target in dp:\n                max_indices.append(dp[target])\n            else:\n                return -1\n        \n        max_k = max(max_indices)\n        if max_k == -1:\n            return 0\n        else:\n            return max_k + 1","author":"目目","submissionId":"611242808"},[]]},{"1776":[{"id":"1776","fileName":"611243022.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(queries)\n        lo, hi = 0, len(queries)\n        def validate(k):\n            for idx, num in enumerate(nums):\n                if num == 0:\n                    continue\n                dp = [False] * (num + 1)\n                dp[0] = True\n                for i in range(k):\n                    l, r, v = queries[i]\n                    if l <= idx <= r and v <= num:\n                        for j in range(num, v - 1, -1):\n                            if dp[j - v]:\n                                dp[j] = True\n                        # if dp[num]:\n                        #     break\n                if not dp[num]:\n                    return False\n            return True\n        while lo <= hi:\n            mi = (lo + hi) >> 1\n            if validate(mi):\n                hi = mi - 1\n            else:\n                lo = mi + 1\n    \n        if lo == n + 1:\n            lo = -1\n        return lo","author":"ikun","submissionId":"611243022"},[]]},{"1777":[{"id":"1777","fileName":"611243451.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], qs: List[List[int]]) -> int:\n        n = len(nums)\n        nq = len(qs)\n        maxone = 0\n        debug = 0\n        for ti,tar in enumerate(nums):\n            if debug:\n                print(\"=\",[ti,tar])\n            if not tar:\n                maxone = max(maxone,0)\n                continue\n            temp = [0] * (tar+1)\n            temp[0] = 1\n            res = -1\n            for i,q in enumerate(qs):\n                x,y,v = q\n                if ti<x or y<ti:\n                    continue\n                for j in range(tar,v-1,-1):\n                    temp[j] |= temp[j-v]\n                if debug:\n                    print([i,q],temp)\n                if temp[tar]:\n                    res = i+1\n                    break\n            if res == -1:\n                return -1\n            maxone = max(maxone,res)\n        return maxone\n            \n'''\n[2,0,2]\n[[0,2,1],[0,2,1],[1,1,3]]\n[4,3,2,1]\n[[1,3,2],[0,2,1]]\n[1,2,3,2,1]\n[[0,1,1],[1,2,1],[2,3,2],[3,4,1],[4,4,1]]\n[1,2,3,2,6]\n[[0,1,1],[0,2,1],[1,4,2],[4,4,4],[3,4,1],[4,4,5]]\n[2]\n[[0,0,6],[0,0,2],[0,0,9],[0,0,5],[0,0,10]]\n[6]\n[[0,0,10],[0,0,5],[0,0,2],[0,0,2],[0,0,1],[0,0,2],[0,0,2]]\n'''","author":"大英权相吉姆哈克","submissionId":"611243451"},[]]},{"1778":[{"id":"1778","fileName":"611242374.txt","sourceCode":"//Timestamp: 2025-03-16 10:55:50\n#define DROP\n#ifdef ONLINE\n#undef LOCAL\n#endif\n#ifndef LOCAL\n#undef _GLIBCXX_DEBUG\n#undef _DEBUG\n#endif\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <deque>\n#include <fstream>\n//#include <ext/pb_ds/assoc_container.hpp>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <type_traits>\n#include <chrono>\n#include <random>\n#include <complex>\n#include <bitset>\n#include <set>\n#include <list>\n#include <array>\n//#include \"compiler_hint.cpp\"\ntemplate <class T, int S>\nstruct MDVecDef {\n  using Type = std::vector<typename MDVecDef<T, S - 1>::Type>;\n  template <typename... Args>\n  static Type Make(int n, Args... args) {\n    return Type(n, MDVecDef<T, S - 1>::Make(args...));\n  }\n};\ntemplate <class T>\nstruct MDVecDef<T, 0> {\n  using Type = T;\n  static Type Make(T val = T()) { return val; }\n};\ntemplate <class T, int S = 1>\nusing MDVec = typename MDVecDef<T, S>::Type;\n#ifndef M_PI\n#define M_PI 3.14159265358979323851280895940618620443274267017841L\n#endif\n#ifndef M_E\n#define M_E 2.718281828459045235428168107993940338928950950503355L\n#endif\n#ifdef LOCAL\n#define Assert(x) assert(x)\n#define DebugRun(X) X\n#define DebugPoint int _x_ = 0; _x_++;\n#else\n#define Debug(...) 42\n#define DebugFmtln(...) 42\n#define Assert(x) 42\n#define DebugRun(X)\n#define DebugPoint\n#endif\n#define Trace(x) DebugFmtln(\"Line %d: %s\", __LINE__, #x)\ntemplate<class T>\ninline T DebugRet(T x) {\n    Debug(x);\n    return x;\n}\n#define const_ref(T) const T &\n#define mut_ref(T) T &\n#define let auto\n#define var auto\n#define varr var&\n#define MEMSET0(X) std::memset(&X, 0, sizeof(X)) \n#define Size(T) int((T).size())\n#define All(data) data.begin(), data.end()\n#define MakeUnique(data) data.resize(std::unique(All(data)) - data.begin())\n#define MakeUniqueAndSort(data) Sort(All(data)); MakeUnique(data) \n#define MakeAttribute(struct_name, Type, attr_name)               \n  struct struct_name {                                            \n    using attr_name ## _type = Type;                              \n    Type attr_name;                                               \n    mut_ref(Type) get_##attr_name() { return attr_name; }         \n    const_ref(Type) get_##attr_name() const { return attr_name; } \n  };\n#define MakeTemplateAttribute(struct_name, attr_name)          \n  template <class T>                                           \n  struct struct_name {                                         \n    using attr_name##_type = T;                             \n    T attr_name;                                               \n    mut_ref(T) get_##attr_name() { return attr_name; }         \n    const_ref(T) get_##attr_name() const { return attr_name; } \n  };\n#define ImplDefaultEq(name)                        \n  bool operator==(const name &a, const name &b) {  \n    return std::memcmp(&a, &b, sizeof(name)) == 0; \n  }                                                \n  bool operator!=(const name &a, const name &b) { return !(a == b); }\n#define ImplDefaultComparision(name)                                \n  bool operator>(const name &rhs) const { return rhs < *this; }     \n  bool operator<=(const name &rhs) const { return !(*this > rhs); } \n  bool operator>=(const name &rhs) const { return !(*this < rhs); }\n#define ImplArithmeticAssignOperation(name)                                 \n  name &operator+=(const name &rhs) { return *this = (*this) + rhs; } \n  name &operator-=(const name &rhs) { return *this = (*this) - rhs; } \n  name &operator*=(const name &rhs) { return *this = (*this) * rhs; } \n  name &operator/=(const name &rhs) { return *this = (*this) / rhs; }\n#define IsType(Type, param, ret_type)                                        \n  template <typename OnlyWhenArg = param>                                    \n  enable_if_t<is_same_v<OnlyWhenArg, param> && is_same_v<OnlyWhenArg, Type>, \n              ret_type>\n#define IsBool(param, ret_type)       \n  template <bool OnlyWhenArg = param> \n  enable_if_t<OnlyWhenArg == (param) && OnlyWhenArg, ret_type>\n#define IsBoolStatic(param, ret_type) \n  template <bool OnlyWhenArg = param> \n  static enable_if_t<OnlyWhenArg == (param) && OnlyWhenArg, ret_type>\n#define MakeAnnotation(name)         \n  template <class T>                 \n  struct is_##name {                 \n    static const bool value = false; \n  };                                 \n  template <class T>                 \n  inline constexpr bool is_##name##_v = is_##name<T>::value;\n#define AssignAnnotation(cls, annotation) \n  template <>                             \n  struct is_##annotation<cls> {           \n    static const bool value = true;       \n  };\n#define AssignAnnotationTemplate(cls, annotation, type) \n  template <type T>                                     \n  struct is_##annotation<cls<T>> {                      \n    static const bool value = true;                     \n  };\n#define FunctionAlias(from, to)                       \n  template <typename... Args>                         \n  inline auto to(Args &&...args)                      \n      ->decltype(from(std::forward<Args>(args)...)) { \n    return from(std::forward<Args>(args)...);         \n  }\n#define CastToScalar(field, type) \n  operator type() const { return type(field); }\n#define CastToAllScalar(field) \n  CastToScalar(field, i8);     \n  CastToScalar(field, u8);     \n  CastToScalar(field, i16);    \n  CastToScalar(field, u16);    \n  CastToScalar(field, i32);    \n  CastToScalar(field, u32);    \n  CastToScalar(field, i64);    \n  CastToScalar(field, u64);    \n  CastToScalar(field, f32);    \n  CastToScalar(field, f64);    \n  CastToScalar(field, f80);\n#define COMMA ,\n#ifndef LOCAL\nstd::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());\n#else\nstd::mt19937 rng(0);\n#endif\ntemplate <class T> T random_choice(T l, T r, std::mt19937 &gen = rng) {\n  std::uniform_int_distribution<T> random(l, r);\n  return random(gen);\n}\nnamespace dalt {\n#ifndef LOCAL\nstruct Timer {explicit Timer(const char* m) {}void stop() const {}};\n#else\n#endif\n}\nusing i8 = char;\nusing i16 = short;\nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u16 = unsigned short;\nusing u32 = unsigned int;\nusing u64 = unsigned long long;\nusing usize = size_t;\nusing f32 = float;\nusing f64 = double;\n// 16 exp, 64 precision\nusing f80 = long double;\nFunctionAlias(std::lower_bound, LowerBound);\nFunctionAlias(std::upper_bound, UpperBound);\nFunctionAlias(std::unique, Unique);\nFunctionAlias(std::swap, Swap);\nFunctionAlias(std::min, Min);\nFunctionAlias(std::max, Max);\nFunctionAlias(std::abs, Abs);\nFunctionAlias(std::sin, Sin);\nFunctionAlias(std::asin, Asin);\nFunctionAlias(std::cos, Cos);\nFunctionAlias(std::acos, Acos);\nFunctionAlias(std::tan, Tan);\nFunctionAlias(std::atan, Atan);\nFunctionAlias(std::sort, Sort);\nFunctionAlias(std::fill, Fill);\nFunctionAlias(std::move, Move);\nFunctionAlias(std::reverse, Reverse);\nFunctionAlias(std::max_element, MaxElement);\nFunctionAlias(std::min_element, MinElement);\nFunctionAlias(std::make_tuple, MakeTuple);\nFunctionAlias(std::make_pair, MakePair);\nFunctionAlias(std::clamp, Clamp);\nFunctionAlias(std::shuffle, Shuffle);\nFunctionAlias(std::to_string, ToString);\nFunctionAlias(std::tie, Tie);\nFunctionAlias(std::get<0>, Get0);\nFunctionAlias(std::get<1>, Get1);\nFunctionAlias(std::get<2>, Get2);\nFunctionAlias(std::get<3>, Get3);\nFunctionAlias(std::get<4>, Get4);\ntemplate <typename _Signature>\nusing Function = std::function<_Signature>;\ntemplate <typename _Signature>\nusing Func = Function<_Signature>;\nusing Str = std::string;\nusing String = Str;\nusing StringStream = std::stringstream;\nusing IStream = std::istream;\nusing OStream = std::ostream;\nusing std::enable_if;\nusing std::enable_if_t;\nusing std::is_base_of;\nusing std::is_base_of_v;\nusing std::is_floating_point;\nusing std::is_floating_point_v;\nusing std::is_integral;\nusing std::is_integral_v;\nusing std::is_arithmetic;\nusing std::is_arithmetic_v;\nusing std::is_same;\nusing std::is_same_v;\nusing std::tie;\nauto &Stderr = std::cerr;\nauto &Stdin = std::cin;\nauto &Stdout = std::cout;\ntemplate <class T>\nusing Less = std::less<T>;\ntemplate <class T>\nusing Greater = std::greater<T>;\ntemplate <typename _Key, typename _Tp, typename _Compare = Less<_Key>>\nusing TreeMap = std::map<_Key, _Tp, _Compare>;\ntemplate <typename _Key, typename _Compare = Less<_Key>>\nusing TreeSet = std::set<_Key, _Compare>;\ntemplate <typename _Key, typename _Compare = std::less<_Key>,\n          typename _Alloc = std::allocator<_Key>>\nusing MultiTreeSet = std::multiset<_Key, _Compare, _Alloc>;\ntemplate <class T>\nusing Deque = std::deque<T>;\ntemplate <class T>\nusing Queue = std::queue<T>;\ntemplate <class T>\nusing Vec = std::vector<T>;\ntemplate <class T>\nusing Reducer = Func<T(const T &, const T &)>;\ntemplate <class T>\nusing Comparator = Func<bool(const T &, const T &)>;\ntemplate <class T>\nusing Indexer = Func<T(i32)>;\ntemplate <class T>\nusing Indexer2 = Func<T(i32, i32)>;\ntemplate <class A, class B = A, class C = A>\nusing Adder = Func<C(const A &, const B &)>;\ntemplate <class I>\nusing Checker = Func<bool(const I &)>;\ntemplate <class A, class B>\nusing BiChecker = Func<bool(const A &, const B &)>;\ntemplate <class T>\nusing Consumer = Func<void(const T &)>;\nusing Action = Func<void()>;\ntemplate<class T>\nusing Supplier = Func<T()>;\ntemplate <class FIRST, class SECOND>\nusing BiConsumer = Func<void(const FIRST &, const SECOND &)>;\ntemplate <class F, class T = F>\nusing Mapper = Func<T(const F &)>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, Vec<T>, Greater<T>>;\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T, Vec<T>, Less<T>>;\ntemplate <class T, usize S>\nusing Array = std::array<T, S>;\ntemplate <typename... _Elements>\nusing Tuple = std::tuple<_Elements...>;\ntemplate <class T, class = enable_if_t<is_floating_point_v<T>>>\nusing Complex = std::complex<T>;\ntemplate <class A, class B>\nusing Pair = std::pair<A, B>;\nnamespace dalt {\ntemplate <class T>\nIStream& operator>>(IStream& is, Vec<T>& val) {\n  for (auto& v : val) {\n    is >> v;\n  }\n  return is;\n}\n#define VEC_OP(op)                         \n  template <class T>                       \n  Vec<T>& operator op(Vec<T>& data, T x) { \n    for (auto& v : data) {                 \n      v op x;                              \n    }                                      \n    return data;                           \n  }\nVEC_OP(+=)\nVEC_OP(-=)\nVEC_OP(*=)\nVEC_OP(/=)\nVEC_OP(%=)\nVEC_OP(^=)\nVEC_OP(&=)\nVEC_OP(|=)\nVEC_OP(==)\nVEC_OP(!=)\ntemplate <class T>\nint Compare(const Vec<T>& lhs, const Vec<T>& rhs) {\n  for(int i = 0; i < Size(lhs) && i < Size(rhs); i++) {\n    if(lhs[i] != rhs[i]) {\n      return lhs[i] < rhs[i] ? -1 : 1;\n    }\n  }\n  return Size(lhs) < Size(rhs) ? -1 : Size(lhs) > Size(rhs) ? 1 : 0;\n}\ntemplate <class T>\nbool operator<(const Vec<T>& lhs, const Vec<T>& rhs) {\n  return Compare(lhs, rhs) < 0;\n}\ntemplate <class T>\nbool operator>(const Vec<T>& lhs, const Vec<T>& rhs) {\n  return Compare(lhs, rhs) > 0;\n}\ntemplate <class T>\nbool operator<=(const Vec<T>& lhs, const Vec<T>& rhs) {\n  return Compare(lhs, rhs) <= 0;\n}\ntemplate <class T>\nbool operator>=(const Vec<T>& lhs, const Vec<T>& rhs) {\n  return Compare(lhs, rhs) >= 0;\n}\n}  // namespace dalt\n//#include \"array_adder.cpp\"\n#ifndef _builtin_clz\ninline i32 _builtin_clz(u32 i) {\n  // HD, Count leading 0's\n  if (i <= 0) return i == 0 ? 32 : 0;\n  int n = 31;\n  if (i >= 1 << 16) {\n    n -= 16;\n    i >>= 16;\n  }\n  if (i >= 1 << 8) {\n    n -= 8;\n    i >>= 8;\n  }\n  if (i >= 1 << 4) {\n    n -= 4;\n    i >>= 4;\n  }\n  if (i >= 1 << 2) {\n    n -= 2;\n    i >>= 2;\n  }\n  return n - (i >> 1);\n}\n#endif\n#ifndef _builtin_clzll\ninline i32 _builtin_clzll(u64 i) {\n  u32 x = u32(i >> 32);\n  return x == 0 ? 32 + _builtin_clz((int)i) : _builtin_clz(x);\n}\n#endif\n#ifndef _builtin_ctz\ninline i32 _builtin_ctz(u32 i) {\n  // HD, Figure 5-14\n  int y;\n  if (i == 0) return 32;\n  int n = 31;\n  y = i << 16;\n  if (y != 0) {\n    n = n - 16;\n    i = y;\n  }\n  y = i << 8;\n  if (y != 0) {\n    n = n - 8;\n    i = y;\n  }\n  y = i << 4;\n  if (y != 0) {\n    n = n - 4;\n    i = y;\n  }\n  y = i << 2;\n  if (y != 0) {\n    n = n - 2;\n    i = y;\n  }\n  return n - ((i << 1) >> 31);\n}\n#endif\n#ifndef _builtin_ctzll\ninline i32 _builtin_ctzll(u64 i) {\n  // HD, Figure 5-14\n  int x, y;\n  if (i == 0) return 64;\n  int n = 63;\n  y = (int)i;\n  if (y != 0) {\n    n = n - 32;\n    x = y;\n  } else\n    x = (int)(i >> 32);\n  y = x << 16;\n  if (y != 0) {\n    n = n - 16;\n    x = y;\n  }\n  y = x << 8;\n  if (y != 0) {\n    n = n - 8;\n    x = y;\n  }\n  y = x << 4;\n  if (y != 0) {\n    n = n - 4;\n    x = y;\n  }\n  y = x << 2;\n  if (y != 0) {\n    n = n - 2;\n    x = y;\n  }\n  return n - ((x << 1) >> 31);\n}\n#endif\n#ifndef _builtin_popcount\ninline i32 _builtin_popcount(u32 i) {\n  // HD, Figure 5-2\n  i = i - ((i >> 1) & 0x55555555);\n  i = (i & 0x33333333) + ((i >> 2) & 0x33333333);\n  i = (i + (i >> 4)) & 0x0f0f0f0f;\n  i = i + (i >> 8);\n  i = i + (i >> 16);\n  return i & 0x3f;\n}\n#endif\n#ifndef _builtin_popcountll\ninline i32 _builtin_popcountll(u64 i) {\n  // HD, Figure 5-2\n  i = i - ((i >> 1) & 0x5555555555555555ll);\n  i = (i & 0x3333333333333333ll) + ((i >> 2) & 0x3333333333333333ll);\n  i = (i + (i >> 4)) & 0x0f0f0f0f0f0f0f0fll;\n  i = i + (i >> 8);\n  i = i + (i >> 16);\n  i = i + (i >> 32);\n  return (int)i & 0x7f;\n}\n#endif\nnamespace dalt {\ninline i32 LeadingZeroNumber(u32 x) {\n  if (x == 0) return 32;\n  return _builtin_clz(x);\n}\ninline i32 LeadingZeroNumber(i32 x) { return LeadingZeroNumber(u32(x)); }\ninline i32 LeadingZeroNumber(u64 x) {\n  if (x == 0) return 64;\n  return _builtin_clzll(x);\n}\ninline i32 LeadingZeroNumber(i64 x) { return LeadingZeroNumber(u64(x)); }\ninline i32 TrailingZeroNumber(u32 x) {\n  if (x == 0) return 32;\n  return _builtin_ctz(x);\n}\ninline i32 TrailingZeroNumber(i32 x) { return TrailingZeroNumber(u32(x)); }\ninline i32 TrailingZeroNumber(u64 x) {\n  if (x == 0) return 64;\n  return _builtin_ctzll(x);\n}\ninline i32 TrailingZeroNumber(i64 x) { return TrailingZeroNumber(u64(x)); }\ninline i32 Log2Ceil(u32 x) {\n  if (x == 0) {\n    return 0;\n  }\n  return 32 - LeadingZeroNumber(x - 1);\n}\ninline i32 Log2Ceil(u64 x) {\n  if (x == 0) {\n    return 0;\n  }\n  return 64 - LeadingZeroNumber(x - 1);\n}\ninline i32 Log2Floor(u32 x) {\n  if (x == 0) {\n    return -1;\n  }\n  return 31 - LeadingZeroNumber(x);\n}\ninline i32 Log2Floor(u64 x) {\n  if (x == 0) {\n    return -1;\n  }\n  return 63 - LeadingZeroNumber(x);\n}\ninline i32 Log2Ceil(i32 x) { return Log2Ceil(u32(x)); }\ninline i32 Log2Ceil(i64 x) { return Log2Ceil(u64(x)); }\ninline i32 Log2Floor(i32 x) { return Log2Floor(u32(x)); }\ninline i32 Log2Floor(i64 x) { return Log2Floor(u64(x)); }\ninline i32 CountBit(u32 x) { return _builtin_popcount(x); }\ninline i32 CountBit(i32 x) { return CountBit(u32(x)); }\ninline i32 CountBit(u64 x) { return _builtin_popcountll(x); }\ninline i32 CountBit(i64 x) { return CountBit(u64(x)); }\ninline i32 HighestOneBitOffset(u32 x) { return Log2Floor(x); }\ninline i32 HighestOneBitOffset(i32 x) { return HighestOneBitOffset(u32(x)); }\ninline i32 HighestOneBitOffset(u64 x) { return Log2Floor(x); }\ninline i32 HighestOneBitOffset(i64 x) { return HighestOneBitOffset(u64(x)); }\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, T> LowestOneBit(T x) {\n  return x & -x;\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, T> HighestOneBit(T x) {\n  if (x == 0) {\n    return x;\n  }\n  return T(1) << HighestOneBitOffset(x);\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, i32> LowestOneBitOffset(T x) {\n  if (x == 0) {\n    return -1;\n  }\n  return HighestOneBitOffset(LowestOneBit(x));\n}\ninline u32 HighestKOnes32(i32 k) {\n  if (k == 0) {\n    return 0;\n  }\n  return (~u32()) << (32 - k);\n}\ninline u64 HighestKOnes64(i32 k) {\n  if (k == 0) {\n    return 0;\n  }\n  return (~u64()) << (64 - k);\n}\ninline u32 LowestKOnes32(i32 k) {\n  if (k == 0) {\n    return 0;\n  }\n  return (~u32()) >> (32 - k);\n}\ninline u64 LowestKOnes64(i32 k) {\n  if (k == 0) {\n    return 0;\n  }\n  return (~u64()) >> (64 - k);\n}\ninline u64 IntervalOnes64(i32 l, i32 r) {\n  if (l > r) {\n    return 0;\n  }\n  u64 high = r < 63 ? (u64(-1) << r + 1) : 0;\n  u64 low = u64(-1) << l;\n  return high ^ low;\n}\ninline u32 IntervalOnes32(i32 l, i32 r) {\n  if (l > r) {\n    return 0;\n  }\n  u32 high = r < 31 ? (u32(-1) << r + 1) : 0;\n  u32 low = u32(-1) << l;\n  return high ^ low;\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, i32> KthBit(T x, i32 k) {\n  return (x >> k) & 1;\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, T> SetBit(T x, i32 k) {\n  return x | (T(1) << k);\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, T> ClearBit(T x, i32 k) {\n  return x & ~(T(1) << k);\n}\n}  // namespace dalt\n// #include \"binary_search.cpp\"\nusing namespace dalt;\n// #include \"collection.cpp\"\n// #include \"combination.cpp\"\n// #include \"function.cpp\"\n//#include \"graph.cpp\"\n//#include \"shortest_path.cpp\"\n// #include \"math.cpp\"\n// #include \"radix.cpp\"\n//#include \"modint.cpp\"\n//using Mi = ModInt1000000007;\n//#include \"prefixsum.cpp\"\nusing namespace std;\n//using namespace graph;\nnamespace dalt {\ntemplate <class T>\nstruct Optional {\n  using Self = Optional<T>;\n private:\n  T val;\n  bool show_up;\n public:\n  Optional(const T &arg_val) : val(arg_val), show_up(true) {}\n  Optional(const T &&arg_val) : val(arg_val), show_up(true) {}\n  Optional() : show_up(false) {}\n  const T &value() const {\n    Assert(show_up);\n    return val;\n  }\n  T &value() {\n    Assert(show_up);\n    return val;\n  }\n  T &operator*() { return value(); }\n  const T &operator*() const { return value(); }\n  bool is_some() const { return show_up; }\n  bool is_none() const { return !show_up; }\n  const T *operator->() const {\n    return &value();\n  }\n  T *operator->() { return &value(); }\n  inline operator T() const { return value(); }\n  T or_else(T def) const {\n    if (is_some()) {\n      return val;\n    } else {\n      return def;\n    }\n  }\n  template <class E>\n  Optional<E> map(const Mapper<T, E> &mapper) const {\n    if (is_some()) {\n      return mapper(value());\n    } else {\n      return Optional<E>();\n    }\n  }\n  bool operator==(const Self &b) const {\n    return show_up == b.show_up && (!show_up || val == b.val);\n  }\n};\ntemplate <class E>\nbool operator!=(const Optional<E> &a, const Optional<E> &b) {\n  return !(a == b);\n}\ntemplate <class E>\nOStream &operator<<(OStream &os, const Optional<E> &v) {\n  if (v.is_none()) {\n    os << \"{}\";\n  } else {\n    os << '{' << v.value() << '}';\n  }\n  return os;\n}\n}  // namespace dalt\nnamespace dalt {\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, T> Gcd(T a, T b) {\n  while (b != 0) {\n    a %= b;\n    Swap(a, b);\n  }\n  return a;\n}\n// ret_value = [x, y, gcd(a,b)] that x * a + y * b = gcd(a, b)\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, Array<T, 3>> ExtGcd(T a, T b) {\n  if (b == 0) {\n    return Array<T, 3>{1, 0, a};\n  }\n  auto div = a / b;\n  auto ans = ExtGcd(b, a - b * div);\n  auto x = ans[0];\n  auto y = ans[1];\n  return Array<T, 3>{y, x - a / b * y, ans[2]};\n}\ntemplate <class T>\ninline enable_if_t<is_integral_v<T>, Optional<T>> PossibleModInverse(\n    T a, T modulus) {\n  auto res = ExtGcd(a, modulus);\n  if (res[2] == 1) {\n    auto ans = res[0] % modulus;\n    if (ans < 0) {\n      ans += modulus;\n    }\n    return ans;\n  }\n  return {};\n}\n}  // namespace dalt\n// #include \"dsu.cpp\"\n//   #include \"segtree.cpp\"\nusing namespace dalt;\nnamespace dalt {\ntemplate <class T, class C>\nIndexer<T> MakeIndexer(const C &data) {\n  return [&](auto i) -> T { return data[i]; };\n}\ntemplate <class T, class C>\nIndexer<T> MakeReverseIndexer(const C &data) {\n  return [&](auto i) -> T { return data[Size(data) - 1 - i]; };\n}\ntemplate <class T>\nVec<T> ExpandIndexer(int n, const Indexer<T> &indexer) {\n  Vec<T> ans;\n  ans.reserve(n);\n  for (int i = 0; i < n; i++) {\n    ans.push_back(indexer(i));\n  }\n  return ans;\n}\nIndexer<i32> SelfIndexer() {\n  return [](auto i) { return i; };\n}\ntemplate <class T>\nIndexer<T> ConstantIndexer(const T &val) {\n  return [=](auto i) { return val; };\n}\ntemplate <class A, class B>\nMapper<A, B> ConstructorMapper() {\n  return [&](auto a) { return B(a); };\n}\ntemplate <class T>\nAdder<T> NaturalAdder() {\n  return [](auto a, auto b) { return a + b; };\n}\ntemplate <class A, class B, class C>\nconstexpr Adder<A, B, C> EmptyAdder() {\n  return [](auto a, auto b) { return C(); };\n}\ntemplate <class A, class B = A>\nconstexpr Adder<A, B, A> ReturnLeftAdder() {\n  return [](auto a, auto b) { return a; };\n}\ntemplate <class A, class B = A>\nconstexpr Adder<A, B, B> ReturnRightAdder() {\n  return [](auto a, auto b) { return b; };\n}\ntemplate <class T>\nIndexer<int> BinaryIndexer(const T& val) {\n  return [=](int i) {return int((val >> i) & 1);};\n}\ntemplate <class T>\nIndexer<int> ReverseIndexer(int n, Indexer<T> indexer) {\n  return [=](int i) {return indexer(n - 1 - i);};\n}\nVec<int> MakeIndexVec(int n) {\n  Vec<int> ans(n);\n  for(int i = 0; i < n; i++) ans[i] = i;\n  return ans;\n}\n}  // namespace dalt\n//#include \"kmp.cpp\"\n// #include \"interval_map.cpp\"\n//#include \"matrix.cpp\"\n// #include \"hash_range.cpp\"\n// #include \"hashmap.cpp\"\n//#include \"binary_tree.cpp\"\n#ifdef LOCAL\nstruct TreeNode\n{\n  int val;\n  TreeNode *left;\n  TreeNode *right;\n  TreeNode()\n      : val(0),\n        left(nullptr), right(nullptr) {}\n  TreeNode(int x)\n      : val(x),\n        left(nullptr),\n        right(nullptr) {}\n  TreeNode(int x, TreeNode *left, TreeNode *right)\n      : val(x),\n        left(left), right(right) {}\n};\n#endif\n// #include \"interval_map.cpp\"\n// #include \"hash_range.cpp\"\n//#include \"segtree_beat.cpp\"\n//#include \"sparse_table.cpp\"\n//#include \"binary.cpp\"\n//#include \"fenwick_tree.cpp\"\n//#include \"segtree.cpp\"\n//#include \"operand.cpp\"\n//#include \"limit_value.cpp\"\n//using Lv = LimitValue<i64>;\n//#include \"min_cost_flow.cpp\"\n//#include \"binary_tree.cpp\"\n//#include \"treap.cpp\"\n//#include \"hashmap.cpp\"\n// #include \"segtree_beat.cpp\"\n// #include \"prefixsum.cpp\"\nclass Solution\n{\npublic:\n  int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    using bs = bitset<1001>;\n    int m = Size(queries);\n    int ans = 0;\n    int n = Size(nums);\n    for(int i = 0; i < n; i++) {\n      bs dp;\n      dp[0] = true;\n      int minReq = m + 1;\n      if(nums[i] == 0) {\n        minReq = 0;\n      } else {\n        for(int j = 0; j < m; j++) {\n          var &q = queries[j];\n          if(q[0] <= i && i <= q[1]) {\n            dp = dp | (dp << q[2]);\n          }\n          if(dp[nums[i]]) {\n            minReq = j + 1;\n            break;\n          }\n        }\n        ans = max(ans, minReq);\n      }\n    }\n    return ans > m ? -1 : ans;\n  }\n};\n#ifdef LOCAL\nint main()\n{\n  return 0;\n}\n#endif","author":"天塘","submissionId":"611242374"},[]]},{"1779":[{"id":"1779","fileName":"611243561.txt","sourceCode":"from typing import *\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nfrom queue import PriorityQueue\nfrom itertools import combinations\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        nq = len(queries)\n        n = len(nums)\n        if sum(nums) == 0: return 0\n        # dp，让 nums[i] 中变为 0 的最少操作次数\n        max_times = 0\n        for i in range(n):\n            times = self.check_times(i, nums[i], queries)\n            # print(nums[i], times)\n            if times == -1:\n                return -1\n            max_times = max(max_times, times)\n        return max_times\n\n\n    \n    def check_times(self, idx: int, num: int, queries: List[List[int]]) -> int:\n        if num == 0:\n            return 0\n        nq = len(queries)\n        dp = [0 for _ in range(num+1)]\n        dp[num] = 1\n        for i in range(nq):\n            l, r, val = queries[i]\n            if l <= idx and r >= idx:\n                for j in range(val, num+1):\n                    if dp[j] == 1:\n                        dp[j-val] = 1\n            if dp[0] == 1:\n                # print(dp)\n                return i+1\n        # print(dp)\n        return -1\n        ","author":"wangsc","submissionId":"611243561"},[]]},{"1780":[{"id":"1780","fileName":"611243685.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        if(*max_element(nums.begin(), nums.end()) == 0) return 0;\n        int n = nums.size(), ans = 1e9; vector<int> ret;\n        for(int i=0; i<n; i++) {\n            int x = nums[i];\n            bitset<1001> dp; dp[0] = 1;\n            for(int k = 0; k < queries.size(); k++) {\n                const auto& q = queries[k];\n                if(q[0] <= i && i <= q[1]) {\n                    dp |= dp << q[2];\n                }\n                if(dp[x]) { ret.push_back(k+1); break; }\n            }\n        }\n        if(ret.size() != n) return -1;\n        return *max_element(ret.begin(), ret.end());\n    }\n};","author":"nnKoala","submissionId":"611243685"},[]]},{"1781":[{"id":"1781","fileName":"611243512.txt","sourceCode":"type query struct {\n\tindex int\n\tval   int\n}\n\nfunc minZeroArray(nums []int, queries [][]int) int {\n\tn := len(nums)\n\tmaxK := 0\n\n\tfor i := 0; i < n; i++ {\n\t\ttarget := nums[i]\n\t\tif target == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tvar qs []query\n\t\tfor j, q := range queries {\n\t\t\tl, r := q[0], q[1]\n\t\t\tif l <= i && i <= r {\n\t\t\t\tqs = append(qs, query{index: j, val: q[2]})\n\t\t\t}\n\t\t}\n\n\t\tdp := make(map[int]int)\n\t\tdp[0] = -1\n\t\tminMaxJ := math.MaxInt32\n\n\t\tfor _, q := range qs {\n\t\t\tj := q.index\n\t\t\tval := q.val\n\n\t\t\tnewDp := make(map[int]int)\n\t\t\tfor s, currentJ := range dp {\n\t\t\t\tif existingJ, ok := newDp[s]; !ok || currentJ < existingJ {\n\t\t\t\t\tnewDp[s] = currentJ\n\t\t\t\t}\n\n\t\t\t\tnewS := s + val\n\t\t\t\tnewJ := max(currentJ, j)\n\t\t\t\tif existingJ, ok := newDp[newS]; !ok || newJ < existingJ {\n\t\t\t\t\tnewDp[newS] = newJ\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp = newDp\n\n\t\t\tif currentJ, ok := dp[target]; ok {\n\t\t\t\tif currentJ < minMaxJ {\n\t\t\t\t\tminMaxJ = currentJ\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif minMaxJ == math.MaxInt32 {\n\t\t\treturn -1\n\t\t}\n\n\t\tkI := minMaxJ + 1\n\t\tif kI > maxK {\n\t\t\tmaxK = kI\n\t\t}\n\t}\n\n\treturn maxK\n}\n","author":"Elated HugleydP","submissionId":"611243512"},[]]},{"1782":[{"id":"1782","fileName":"611243620.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& Q) {\n\n        const int m = Q.size();\n        auto check = [&](int v, int x)->int{\n            \n            if(v == 0) {\n                return 0;\n            }\n\n            bitset<1001>bs;\n            bs[0] = 1;\n\n            for(int i = 0;i < m;i++) {\n                int l = Q[i][0], r = Q[i][1], val = Q[i][2];\n                if(l <= x && x <= r) {\n                    bs |= (bs << val);\n                    if(bs[v] == 1) {\n                        return i + 1;\n                    }\n                }    \n            }\n\n            return -1;\n        };\n\n        int ans = 0;\n        for(int i = 0;i < a.size();i++) {\n            auto t = check(a[i], i);\n            if(t == -1) {\n                return t;\n            }\n            ans = std::max(ans, t);\n        }\n\n        return ans;\n    }\n};","author":"spj","submissionId":"611243620"},[]]},{"1783":[{"id":"1783","fileName":"611243841.txt","sourceCode":"//by 72\n#include<bits/stdc++.h>\n#define pii pair<int, int>\n#define F(i, a, b) for(int i = (a); i <= (b); i ++)\n#define Fd(i, a, b) for(int i = (a); i >= (b); i --)\nusing namespace std;\n\ntemplate <typename T1, typename T2>\nostream& operator <<(ostream& out, pair<T1, T2> p) {\n    out << '(' << p.first << \", \" << p.second << ')';\n    return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, vector<T> v) {\n    cout << '[';\n    if (!v.empty()) cout << v[0];\n    for (int i = 1; i < (int)v.size(); i++) cout << \",\" << v[i];\n    cout << ']';\n    return out;\n}\n\ntypedef long long ll;\nconst int mod = 998244353;\nconst int inf = 1e9;\nconst bool test = true;\nconst int mx = 1000;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        vector<int> res(a.size() + 1, -1);\n        for(int i = 0; i < a.size(); i ++) {\n            vector<int> f(mx + 1, 0);\n            f[0] = 1;\n            if(f[a[i]]) res[i] = 0;\n            for(int j = 0; j < q.size(); j ++) {\n                if(res[i] != -1) break;\n                auto x = q[j];\n                if(x[0] > i || x[1] < i) continue;\n                Fd(k, mx, x[2]) if(f[k - x[2]]) f[k] = 1; \n                if(f[a[i]]) {\n                    res[i] = j + 1;\n                    break;\n                }\n            }\n        }\n        // cout << res << endl;\n        int mx = 0;\n        int n = a.size();\n        F(i, 0, n - 1) {\n            if(res[i] == -1) return -1;\n            else mx = max(mx, res[i]);\n        }\n        return mx;\n    }\n};","author":"Nanani","submissionId":"611243841"},[]]},{"1784":[{"id":"1784","fileName":"611243767.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        vector<vector<int>> v(10, vector<int>(1001, 0));\n        vector<int> log(nums.size(), INT_MAX);\n        for (int i = 0; i < nums.size(); ++i) {\n            v[i][nums[i]] = 1;\n            if (nums[i] == 0) log[i] = 0;\n        }\n        \n        for (int i = 0; i < q.size(); ++i) {\n            for (int j = 0; j < nums.size(); ++j) {\n                if (q[i][0] > j || q[i][1] < j) continue;\n                for (int k = 0; k <= 1000; ++k) {\n                    if (k - q[i][2] < 0) continue;\n                    if (v[j][k] != 1) continue;\n                    v[j][k - q[i][2]] = 1;\n                    if (k - q[i][2] == 0) {\n                        log[j] = min(log[j], i + 1);\n                    }\n                }\n            }\n        }\n        int ans = 0;\n        for (int a : log) {\n            ans = max(ans, a);\n        }\n        return ans == INT_MAX ? -1 : ans;\n    }\n};","author":"jushuai_lfx","submissionId":"611243767"},[]]},{"1785":[{"id":"1785","fileName":"611243966.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(),m=queries.size();\n        auto check=[&](int k){\n            vector<vector<int>> v(n);\n            for(int i=0;i<k;i++){\n                vector<int>&q=queries[i];\n                int l=q[0],r=q[1],val=q[2];\n                for(int i=l;i<=r;i++){\n                    v[i].push_back(val);\n                }\n            }\n            int s=0;\n            for(int i=0;i<n;i++){\n                if(!nums[i])continue;\n                bitset<1001> dp;\n                dp[0]=1;\n                for(int& num:v[i]){\n                    dp|=dp<<num;\n                }\n                if(!dp[nums[i]])return false;\n            }\n            return true;\n        };\n        int left=0,right=m;\n        while(left<=right){\n            int mid=(left+right)>>1;\n            if(check(mid)){\n                right=mid-1;\n            }else{\n                left=mid+1;\n            }\n        }\n        if(left==m+1){\n            return -1;\n        }\n        return left;\n    }\n};","author":"nihonge","submissionId":"611243966"},[]]},{"1786":[{"id":"1786","fileName":"611244033.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        // 每个横坐标都看一下最小k\n        int ans = Integer.MIN_VALUE;\n        for (int i = 0; i < nums.length; i++) {\n            int max = getMax(i, nums[i], queries);\n            if (max != -1) {\n                ans = Math.max(ans, max);\n            } else {\n                return -1;\n            }\n        }\n        return ans;\n    }\n\n    private int getMax(int idx, int n, int[][] queries) {\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < queries.length; i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            if (l <= idx && r >= idx) {\n                list.add(val);\n            } else {\n                list.add(-1);\n            }\n        }\n        int[] nums = new int[list.size()];\n        for (int i = 0; i < list.size(); i++) {\n            nums[i] = list.get(i);\n        }\n        int minN = findMinN(nums, n);\n        return minN;\n    }\n\n    public int findMinN(int[] nums, int target) {\n        if (target == 0) {\n            return 0;\n        }\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == -1) {\n                continue;\n            }\n            int num = nums[i];\n            if (num > target) {\n                continue;\n            }\n            for (int j = target; j >= num; j--) {\n                if (dp[j - num]) {\n                    dp[j] = true;\n                }\n            }\n            if (dp[target]) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n}","author":"欧海","submissionId":"611244033"},[]]},{"1787":[{"id":"1787","fileName":"611243190.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n\n        def canComplete(k):\n            for i in range(n):\n                target = nums[i]\n                if target == 0:\n                    continue\n                dp = 1\n                for j in range(k):\n                    l, r, v = queries[j]\n                    if l <= i <= r:\n                        dp |= (dp << v)\n                        dp &= (1 << (target + 1)) - 1\n                        if (dp >> target) & 1:\n                            break\n                if not ((dp >> target) & 1):\n                    return False\n            return True\n\n        l, h = 0, m+1\n        res = -1\n        while l<h:\n            mid = (l+h)//2\n            if canComplete(mid):\n                res = mid\n                h = mid\n            else:\n                l = mid + 1\n        if res == -1 or res > m:\n            return -1\n        return res\n        \n            ","author":"Matisse","submissionId":"611243190"},[]]},{"1788":[{"id":"1788","fileName":"611243713.txt","sourceCode":"#pragma region template\n\n#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <cmath>\n#include <queue>\n#include <algorithm>\n#include <array>\n#include <functional>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; --i)\n#define forab(i, a, b) for(int i=(a);i<(b);++i)\n#define fore(v, a) for(auto &v: a)\n#define sqr(x) ((x)*(x))\n#define clr(a, b) memset(a, b, sizeof(a))\n#define sz(a) ((int)a.size())\n#define all(a) (a).begin(),(a).end()\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef map<int,int> mii;\ntypedef map<int,string> mis;\ntypedef map<string,int> msi;\ntemplate <class T> using max_heap = priority_queue<T>;\ntemplate <class T> using min_heap = priority_queue<T, vector<T>, greater<>>;\nconst double eps = 1e-8;\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / 2;\nint dcmp(double x) { if (x < -eps) return -1; else return x > eps;}\ntemplate <typename T> bool chmax(T &m, const T q) { return m < q ? (m = q, true) : false; }\ntemplate <typename T> bool chmin(T &m, const T q) { return m > q ? (m = q, true) : false; }\nconstexpr pii dx4[4] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\nconstexpr pii dx8[8] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};\ntemplate <class T> using vc = vector<T>;\ntemplate <class T> using vvc = vector<vc<T>>;\ntemplate <class T> using vvvc = vector<vvc<T>>;\n#define minall(v) *min_element(all(v))\n#define maxall(v) *max_element(all(v))\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\n#define unq(x) sort(all(x)), x.erase(unique(all(x)), x.end())\nint popcnt(unsigned int x) { return __builtin_popcount(x); }\nint popcntll(unsigned long long x) { return __builtin_popcountll(x); }\ntemplate <class T, class U> ostream& operator<<(ostream& os, const pair<T, U>& p){ return os<<\"(\"<<p.fi<<\",\"<<p.se<<\")\"; }\nvoid see0(){ cout<<endl; }\ntemplate<class H, class ...T> void see0(H && h, T && ...t) { cout<<h<<\",\"; see0(t...); }\n\n#pragma endregion template\n\n#ifdef CHEN_PC\n#include \"lc-struct.h\"\n#define see(...) {cout<<__LINE__<<\": \"<<#__VA_ARGS__<<\" = \";see0(__VA_ARGS__);}\n#define seev(a) {cout<<__LINE__<<\": \"<<#a<<\" = [\"; fore(v, a)cout<<(v)<<\",\"; cout<<\"]\"<<endl;}\n#else\n#define see(...)\n#define seev(...)\n#endif\n\nconst int N = 30010;\nconst int mod = 1000000007; // 10^9+7\n\nusing B = bitset<1005>;\n\nclass Solution {\npublic:\n\tint minZeroArray(vector<int>& a, vector<vector<int>>& qr) {\n\t\tseev(a);\n\t\tint n = sz(a);\n\t\tint m = sz(qr);\n\t\tvc<B> bt(n);\n\t\tforn (i, n) bt[i][0] = 1;\n\t\tauto check = [&] () {\n\t\t\tforn (i, n) {\n\t\t\t\tif (bt[i][a[i]] == 0) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\tif (check()) return 0;\n\t\tforn (i, m) {\n\t\t\tint l = qr[i][0];\n\t\t\tint r = qr[i][1];\n\t\t\tint v = qr[i][2];\n\t\t\tforab (j, l, r+1) {\n\t\t\t\tauto &b = bt[j];\n\t\t\t\tb |= (b << v);\n\t\t\t\tif (check()) {\n\t\t\t\t\treturn i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};","author":"ch365","submissionId":"611243713"},[]]},{"1789":[{"id":"1789","fileName":"611244083.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<int> a(1);\n        for(int i = 0; i < n; i++) {\n            a.push_back(nums[i]);\n        }\n        int l = 0, r = m;\n\n        auto check = [&](int mid) -> int {\n            vector<vector<int>> s(n + 1);\n            for(int i = 0; i < mid; i++) {\n                int l = 1 + queries[i][0], r = 1 + queries[i][1], val = queries[i][2];\n                for(int j = l; j <= r; j++) {\n                    s[j].push_back(val);\n                }\n            }  \n            for(int i = 1; i <= n; i++) {\n                vector<int> dp(1e3 + 1);\n                dp[0] = 1;\n                for(int val : s[i]) {\n                    for(int j = a[i]; j >= val; j--) {\n                        dp[j] |= dp[j - val];\n                    }\n                }\n                if(dp[a[i]] == 0) return 0;\n            }\n            return 1;\n        };\n        \n        while(l <= r) {\n            int mid = (l + r) >> 1;\n            if(check(mid)) r = mid - 1;\n            else l = mid + 1;\n        }\n\n        \n        if(l == m + 1) return -1;\n        return l;\n    }\n};","author":"snowy2002","submissionId":"611244083"},[]]},{"1790":[{"id":"1790","fileName":"611244039.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = queries.length;\n        int left = 0, right = n, ans = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (canMakeZero(nums, queries, mid)) {\n                ans = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n    \n    private boolean canMakeZero(int[] nums, int[][] queries, int k) {\n        int n = nums.length;\n        for (int j = 0; j < n; j++) {\n            int target = nums[j];\n            if (target == 0) continue;\n            ArrayList<Integer> values = new ArrayList<>();\n            int sumAll = 0;\n            for (int i = 0; i < k; i++) {\n                if (queries[i][0] <= j && j <= queries[i][1]) {\n                    int val = queries[i][2];\n                    values.add(val);\n                    sumAll += val;\n                }\n            }\n\n            if (sumAll < target) return false;\n            if (!subsetSum(values, target)) return false;\n        }\n        return true;\n    }\n\n    private boolean subsetSum(List<Integer> values, int target) {\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n        for (int val : values) {\n            for (int s = target - val; s >= 0; s--) {\n                if (dp[s]) {\n                    dp[s + val] = true;\n                }\n            }\n            if (dp[target]) return true;\n        }\n        return dp[target];\n    }\n}","author":"Eliauk","submissionId":"611244039"},[]]},{"1791":[{"id":"1791","fileName":"611244135.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        res = 0\n        for i in range(len(nums)):\n            num = nums[i]\n            if num == 0:\n                continue\n            values = []\n            for j in range(len(queries)):\n                l, r, val = queries[j]\n                if l <= i <= r:\n                    values.append((j, val))\n            s = {0}\n            flag = False\n            ans = 0\n            for j in range(len(values)):\n                tmp = []\n                for x in s:\n                    tmp.append(x + values[j][1])\n                for x in tmp:\n                    if x <= 1000:\n                        s.add(x)\n                \n                if num in s:\n                    flag = True\n                    ans = values[j][0] + 1\n                    break\n            if not flag:\n                return -1\n            res = max(res, ans)\n        return res\n                \n                    \n                \n            \n                \n            ","author":"Practical Edisony6X","submissionId":"611244135"},[]]},{"1792":[{"id":"1792","fileName":"611244190.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<vector<int>> dp(n);\n        for(int i = 0; i < n; i++){\n            dp[i] = vector<int> (nums[i] + 1, 0);\n            dp[i][0] = 1;\n        }\n        for(int i = 0; i <= m; i++){\n            int t = 1;\n            for(int j = 0; j < n; j++){\n                if(dp[j][nums[j]] == 0){\n                    t = 0;\n                }\n            }\n            if(t){\n                return i;\n            }\n            if(i == m) break;\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for(int j = l; j <= r; j++){\n                if(dp[j][nums[j]]) continue;\n                for(int k = nums[j]; k >= val; k--){\n                    dp[j][k] = dp[j][k] | dp[j][k - val];\n                }\n            }\n        }\n        return -1;\n    }\n};","author":"ベ断桥烟雨ミ","submissionId":"611244190"},[]]},{"1793":[{"id":"1793","fileName":"611244529.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], qs: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(qs)\n        \n        \n        dp = [[10**15]*(max(nums)+1) for _ in range(m+1)]\n        \n        def cal(idx):\n            for i in range(m+1):\n                dp[i][0] = 0\n                for j in range(1, nums[idx]+1):\n                    dp[i][j] = 10**15\n                    \n            for i in range(m-1,-1,-1):\n                for j in range(1, nums[idx]+1):\n                    tmp = dp[i+1][j]\n                    if qs[i][0]<=idx<=qs[i][1] and j>=qs[i][2]:\n                        tmp = min(tmp, dp[i+1][j-qs[i][2]])\n                    dp[i][j]=tmp+1\n            \n            return dp[0][nums[idx]]\n        \n        \n        res = max([cal(i) for i in range(n)])\n        if res<10**15:\n            return res\n        return -1\n                    \n                \n        ","author":"Perlman","submissionId":"611244529"},[]]},{"1794":[{"id":"1794","fileName":"611244269.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        \n        def check(m):\n            \n            mem = defaultdict(list)\n            \n            for i in range(m):\n                l,r,q = queries[i]\n                for j in range(l, r + 1):\n                    if q <= nums[j]:\n                        mem[j].append(q)\n                        \n                        \n            for i,v in enumerate(nums):\n                if v == 0:\n                    continue\n                    \n                dic = Counter(mem[i])\n                dp = {}\n                dp[0] = 1\n                items = []\n                \n                for key, val in dic.items():\n                    cnt = 1\n                    \n                    while val >= cnt:\n                        val -= cnt\n                        items.append((cnt * key))\n                        cnt *= 2\n                        \n                    if val:\n                        items.append((val * key))\n                        \n                for k in items:\n                    tmp = deepcopy(dp)\n                    for key in dp:\n                        if key + k > v:\n                            continue\n                        if key + k == v:\n                            tmp[v] = 1\n                            break\n                        tmp[key + k] = 1\n                        \n                    dp = tmp\n                    \n                if v not in dp:\n                    # print(i, v, dic, dp, items)\n                    return False\n                \n                \n            return True\n                    \n                    \n                \n                \n                    \n            \n                    \n            \n            \n        \n        leng = len(nums)\n        if nums == [0] * leng:\n            return 0\n        \n        l = 1\n        r = len(queries)\n        \n        while l <= r:\n            m = (l + r) // 2\n            if check(m):\n                r = m - 1\n            else:\n                l = m + 1\n                \n        return r + 1 if r + 1 <= len(queries) else -1","author":"rookie","submissionId":"611244269"},[]]},{"1795":[{"id":"1795","fileName":"611244242.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define maxn (int)(1e6 + 10)\n#define IOS ios::sync_with_stdio(0);\n#define FFF freopen(\"out\", \"w\", stdout);\n\n\n\nclass Solution {\nprivate:\n    struct Node {\n        vector<pair<int,int>> a;\n    }nodes[15];\n    int dp[1005][1005];\npublic:\n    int minZeroArray(vector<int> &nums, vector<vector<int>> &queries) {\n        for (int i = 0; i < queries.size(); i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                nodes[j].a.push_back({i,val});\n            }\n        }\n        int n = nums.size();\n        int ans = 0;\n        bool flag = true;\n        for (int i = 0; i < n; i++) {\n            memset(dp, 0, sizeof(dp));\n            int x = nums[i];\n            if (x == 0) {\n                continue;\n            }\n            dp[0][x] = 1;\n            auto as = nodes[i].a;\n            int asiz = as.size();\n            int res = -1;\n            for (int j = 1; j <= asiz; j++) {\n                int pos = as[j-1].first;\n                int val = as[j-1].second;\n                for (int k = x; k >= 0; k--) {\n                    dp[j][k] |= dp[j-1][k];\n                    if (k - val >= 0) {\n                        dp[j][k-val] |= dp[j-1][k];\n                    }\n                }\n                if (dp[j][0] == 1) {\n                    res = pos+1;\n                    break;\n                }\n            }\n            if (res == -1) {\n                flag = false;\n                break;\n            } else {\n                ans = max(ans, res);\n            }\n        }\n        if (flag) {\n            return ans;\n        } else {\n            return -1;\n        }\n    }\n};","author":"dydy","submissionId":"611244242"},[]]},{"1796":[{"id":"1796","fileName":"611244593.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(queries)\n        @cache\n        def dfs(tmp, i):\n            nonlocal idx\n            if tmp == 0:\n                return i\n            if i == n:\n                return inf\n            \n\n            res = dfs(tmp, i+1)\n            if queries[i][0] <= idx <= queries[i][1] and tmp >= queries[i][2]:\n                res = min(res, dfs(tmp - queries[i][2], i+1))\n            return res\n\n        ans = 0\n        for idx, x in enumerate(nums):\n            need = dfs(x, 0)\n            dfs.cache_clear()\n            if need == inf:\n                return -1\n            ans = max(ans, need)\n\n        return ans\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n        ","author":"Beautiful Shawsfr","submissionId":"611244593"},[]]},{"1797":[{"id":"1797","fileName":"611244665.txt","sourceCode":"function minZeroArray(nums: number[], queries: number[][]): number {\n  const n = nums.length;\n  const p = new Array(n).fill(0).map(() => new Array(1001).fill(false));\n\n  for (let i = 0; i < n; ++i) {\n    p[i][nums[i]] = true;\n  }\n\n  if (p.every((v) => v[0])) {\n    return 0;\n  }\n\n  for (let i = 0, l = queries.length; i < l; ++i) {\n    const [a, b, v] = queries[i];\n\n    for (let j = a; j <= b; ++j) {\n      const pj = p[j];\n\n      if (!pj[0]) {\n        for (let k = 0; k <= 1000; ++k) {\n          if (pj[k] && k >= v) {\n            pj[k - v] = true;\n          }\n        }\n      }\n    }\n\n    if (p.every((v) => v[0])) {\n      return i + 1;\n    }\n  }\n\n  return -1;\n}\n","author":"Noah","submissionId":"611244665"},[]]},{"1798":[{"id":"1798","fileName":"611244817.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        const int MAXN1=11, MAXN2=1001;\n        int i,k,t,x,y,z;\n        bool a[MAXN1][MAXN2];\n        for(i=0;i<nums.size();i++)\n            {\n                a[i][0]=1;\n                for(k=1;k<MAXN2;k++)\n                a[i][k]=0;\n            }\n        for(i=0;i<nums.size();i++)\n        if(a[i][nums[i]]==0)break;\n        if(i==nums.size())return 0;\n        else\n        {\n            for(i=0;i<queries.size();i++)\n                {\n                    x=queries[i][0]; y=queries[i][1]; z=queries[i][2];\n                    for(k=x;k<=y;k++)\n                        {\n                            for(t=MAXN2-1;t>=z;t--)\n                            if(a[k][t-z]==1)a[k][t]=1;\n                        }\n                    for(k=0;k<nums.size();k++)\n                    if(a[k][nums[k]]==0)break;\n                    if(k==nums.size())break;\n                }\n            if(i<queries.size())return i+1;\n            else return -1;\n        }\n    }\n};","author":"er🌪","submissionId":"611244817"},[]]},{"1799":[{"id":"1799","fileName":"611245080.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        \n        def compute(pos, total):\n            if total == 0:\n                return 0\n            curr_S = 0\n            lookup = set([])\n            # tmp = set([])\n            for i, (l, r, val) in enumerate(queries):\n                if l <= pos <= r:\n                    tmp = lookup.copy()\n                    for elem in tmp:\n                        if elem + val <= total:\n                            lookup.add(elem + val)\n                    if val <= total:\n                        lookup.add(val)\n                if total in lookup:\n                    return i + 1\n            return float('inf')\n                    \n        # @lru_cache(None)\n        # def dfs(pos, rem, i):\n        #     if rem == 0:\n        #         return i\n        #     if i >= m:\n        #         return float('inf')\n        #     ans = dfs(pos, rem, i + 1)\n        #     if queries[i][0] <= pos <= queries[i][1] and rem >= queries[i][2]:\n        #         ans = min(ans, dfs(pos, rem - queries[i][2], i + 1))\n        #     return ans\n        res = 0\n        for i in range(n):\n            res = max(res, compute(i, nums[i]))\n        return res if res < float('inf') else -1\n                \n                \n            \n            ","author":"🍪🍪🍪","submissionId":"611245080"},[]]},{"1800":[{"id":"1800","fileName":"611245143.txt","sourceCode":"\nfunc minZeroArray(nums []int, queries [][]int) int {\n\tif slices.Max(nums) == 0 {\n\t\treturn 0\n\t}\n\tn := len(nums)\n\tans := sort.Search(len(queries), func(i int) bool {\n\t\tcnt := make([][]int, n)\n\t\tfor _, q := range queries[:i+1] {\n\t\t\tl, r, v := q[0], q[1], q[2]\n\t\t\tfor j := l; j <= r; j++ {\n\t\t\t\tcnt[j] = append(cnt[j], v)\n\t\t\t}\n\t\t}\n\t\ttNums := make([]int, n)\n\t\tcopy(tNums, nums)\n\t\tfor j, tmp := range cnt {\n\t\t\tdp := make([]bool, nums[j]+1)\n\t\t\tdp[0] = true\n\t\t\tfor _, v := range tmp {\n\t\t\t\tfor w := nums[j]; w >= v; w-- {\n\t\t\t\t\tdp[w] = dp[w] || dp[w-v]\n\t\t\t\t}\n\t\t\t}\n\t\t\tif dp[nums[j]] {\n\t\t\t\ttNums[j] = 0\n\t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t})\n    \n\tif ans >= len(queries) {\n\t\treturn -1\n\t}\n\treturn ans + 1\n}\n","author":"djzzwx","submissionId":"611245143"},[]]},{"1801":[{"id":"1801","fileName":"611244345.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        # if all zero, still need to return 1\n        \n        if all(x == 0 for x in nums):\n            return 0\n        vals = [set([x]) for x in nums]\n        \n        for qidx,(l,r,decr) in enumerate(queries, start=1):\n            new_vals = [{y for y in x} for x in vals]\n            for i,val in enumerate(vals[l:r+1], start=l):\n                for y in val:\n                    if y - decr >= 0:\n                        new_vals[i].add(y - decr)\n            vals = new_vals\n            # print(vals)\n            if all(0 in val for val in vals):\n                # print()\n                return qidx\n        # print()\n        return -1","author":"涂汇康","submissionId":"611244345"},[]]},{"1802":[{"id":"1802","fileName":"611244779.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> dp(n,vector<int>(1001,1e9));\n        for(int i = 0;i < n;++i)dp[i][0] = 0;\n        for(int k = 0;k < queries.size();++k)\n            {\n                int l = queries[k][0],r = queries[k][1],val = queries[k][2];\n                for(int p = 0;p + val <= 1000;++p)\n                {\n                    for(int i = l;i <= r;++i)\n                        if(dp[i][p] < k + 1)\n                            dp[i][p + val] = min(dp[i][p + val],k + 1);\n                }\n            }\n        int ans = 0;\n        for(int i = 0;i < n;++i)\n            ans = max(ans,dp[i][nums[i]]);\n        return ans >= 1e9 ? -1 : ans;\n    } \n};","author":"Camellia_y","submissionId":"611244779"},[]]},{"1803":[{"id":"1803","fileName":"611245285.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& qu) {\n        int n = a.size();\n\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (a[i] == 0) continue;\n            vector<int> f(a[i] + 1);\n            f[0] = 1;\n            int aans = -1;\n            for (int j = 0; j < qu.size(); ++j) {\n                if (i < qu[j][0] || qu[j][1] < i || qu[j][2] > a[i])\n                    continue;\n                for (int k = a[i]; k >= qu[j][2]; --k)\n                    f[k] |= f[k - qu[j][2]];\n                if (f[a[i]]) {\n                    aans = j;\n                    break;\n                }\n            }\n            if (aans == -1) return -1;\n            ans = max(ans, aans + 1);\n        }\n        return ans;\n    }\n};","author":"维虵命","submissionId":"611245285"},[]]},{"1804":[{"id":"1804","fileName":"611245138.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(),m=queries.size(),ans=-1;\n        set<int> now;\n        vector<vector<int>> q(n+1);\n        for(int i=0;i<m;++i){\n            q[queries[i][0]].emplace_back(i);\n            q[queries[i][1]+1].emplace_back(-i-1);\n        }\n        for(int i=0;i<n;++i){\n            vector<int> dp(nums[i]+1, m);\n            dp[0]=-1;\n            for(auto &j:q[i]){\n                if(j<0) now.erase(-j-1);\n                else now.insert(j);\n            }\n            for(auto &j:now){\n                for(int k=nums[i];k>=queries[j][2];--k){\n                    if(dp[k-queries[j][2]]!=m) dp[k]=j;\n                }\n                if(dp[nums[i]]!=m) break;\n            }\n            if(dp[nums[i]]==m) return -1;\n            ans=max(ans, dp[nums[i]]);\n        }\n        return ans+1;\n    }\n};","author":"大愚若智","submissionId":"611245138"},[]]},{"1805":[{"id":"1805","fileName":"611245163.txt","sourceCode":"class Solution {\n    fun minZeroArray(nums: IntArray, queries: Array<IntArray>): Int {\n        if (nums.all { it == 0 }) return 0\n\n        val q = queries.size\n\n        fun canZero(k: Int): Boolean {\n            for (i in nums.indices) {\n                val target = nums[i]\n                val values = mutableListOf<Int>()\n                for (j in 0 until k) {\n                    val (l, r, v) = queries[j]\n                    if (i in l..r) {\n                        values.add(v)\n                    }\n                }\n                val dp = BooleanArray(target + 1)\n                dp[0] = true\n                for (v in values) {\n                    for (s in target downTo v) {\n                        if (dp[s - v]) dp[s] = true\n                    }\n                }\n                if (!dp[target]) return false\n            }\n            return true\n        }\n\n        var lo = 1\n        var hi = q + 1\n        var ans = -1\n        while (lo < hi) {\n            val mid = lo + (hi - lo) / 2\n            if (canZero(mid)) {\n                ans = mid\n                hi = mid\n            } else {\n                lo = mid + 1\n            }\n        }\n        return if (ans == -1) -1 else ans\n    }\n}","author":"HaKu","submissionId":"611245163"},[]]},{"1806":[{"id":"1806","fileName":"611244390.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(),m=queries.size(),ma=*max_element(nums.begin(),nums.end());\n\n        auto check=[&](int x){\n            vector f(n,vector(ma+1,0));\n            for(int i=0;i<n;++i){\n                f[i][nums[i]]=1;\n            }\n            for(int i=0;i<x;++i){\n                int l=queries[i][0],r=queries[i][1],val=queries[i][2];\n                for(int j=l;j<=r;++j){\n                    for(int k=val;k<=nums[j];++k){\n                        f[j][k-val]|=f[j][k];\n                    }\n                }\n            }\n            int ans=0;\n            for(int i=0;i<n;++i) ans+=f[i][0];\n            return ans==n;\n        };\n        \n        int l=0,r=m;\n        while(l<r){\n            int mid=l+r>>1;\n            if(check(mid)) r=mid;\n            else l=mid+1;\n        }\n        if(check(l)) return l;\n        else return -1;\n    }\n};","author":"Glow.","submissionId":"611244390"},[]]},{"1807":[{"id":"1807","fileName":"611245434.txt","sourceCode":"\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int ans = 0;\n        for (int i = 0; i < nums.length; i++) {\n            List<int[]> list = new ArrayList<>();\n            for (int j = 0; j < queries.length; j++) {\n                int[] q = queries[j];\n                if (q[0] <= i && q[1] >= i) {\n                    list.add(new int[]{q[2], j + 1});\n                }\n            }\n            ans = Math.max(ans, getNs(list, nums[i]));\n        }\n        return ans == Integer.MAX_VALUE ? -1 : ans;\n    }\n\n    private int getNs(List<int[]> list, int num) {\n        if(num==0) return 0;\n        int sz = list.size();\n        boolean[][] nn = new boolean[sz + 1][num + 1];\n        nn[0][0] = true;\n        for (int i = 0; i < sz; i++) {\n            for (int j = 0; j <= num; j++) {\n                if (!nn[i][j]) continue;\n                if (j + list.get(i)[0] <= num) {\n                    nn[i + 1][j + list.get(i)[0]] = true;\n                }\n                nn[i + 1][j] = true;\n            }\n        }\n        for (int i = 1; i <= sz; i++) {\n            if (nn[i][num]) return list.get(i - 1)[1];\n        }\n        return Integer.MAX_VALUE;\n    }\n}\n","author":"一只小蜗牛呀","submissionId":"611245434"},[]]},{"1808":[{"id":"1808","fileName":"611245577.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        subs = [set() for _ in range(n)]\n        chk = [False for _ in range(n)]\n        rm = n\n        for i in range(n):\n            subs[i].add(nums[i])\n            if nums[i] == 0:\n                chk[i] = True\n                rm -= 1\n        if rm == 0:\n            return 0\n        for i, q in enumerate(queries):\n            for j in range(q[0], q[1] + 1):\n                if chk[j]:\n                    continue\n                ns = set()\n                for x in subs[j]:\n                    ns.add(x)\n                    if x >= q[2]:\n                        ns.add(x - q[2])\n                subs[j] = ns\n                if 0 in ns:\n                    chk[j] = True\n                    rm -= 1\n            if rm == 0:\n                return i + 1\n        return -1\n            \n            \n        ","author":"Shaaou","submissionId":"611245577"},[]]},{"1809":[{"id":"1809","fileName":"611245646.txt","sourceCode":"\nconst g = (idx, v, queries) => {\n    const dp = new Array(v + 1).fill(Infinity)\n    dp[v] = 0\n    for (let i = 0; i < queries.length; i += 1) {\n        const [l, r, d] = queries[i]\n        if (l > idx || r < idx) continue\n        for (let j = 0; j <= v - d; j += 1) {\n            dp[j] = Math.min(dp[j], dp[j + d] === Infinity ? Infinity : i + 1)\n        }\n    }\n    return dp[0]\n}\n/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number}\n */\nvar minZeroArray = function(nums, queries) {\n    const arr = nums.map((v, i) => g(i, v, queries))\n    const ans = Math.max(...arr)\n    return ans === Infinity ? -1 : ans\n};\n","author":"capybara","submissionId":"611245646"},[]]},{"1810":[{"id":"1810","fileName":"611245456.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        m = len(queries)\n        l,r= 1,m \n        if all(a==0 for a in nums ):\n            return 0\n        def search(nums,tar):\n\n            vis = [0]*(tar+1)\n            vis[0] =1\n            for a in nums:\n                for j in range(tar,0,-1):\n                    if j-a >=0 and vis[j-a] ==1:\n                        vis[j] =1\n            return vis[-1]==1\n\n\n        def verify(mid):\n            n = len(nums)\n            lss= [[] for _ in range(n)]\n            for a,b,c in queries[:mid]:\n                for j in range(a,b+1):\n                    lss[j].append(c)\n            \n            return all(search(lss[i],nums[i]) for i in range(n))\n\n        while l<r:\n            mid = (l+r)>>1\n            if verify(mid):\n                r = mid \n            else:\n                l= mid +1\n        return l if verify(l) else -1","author":"Tao Zhou","submissionId":"611245456"},[]]},{"1811":[{"id":"1811","fileName":"611245918.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        int res = 0;\n\n        int [][]dp = new int[n+1][1001];\n        for(int i=0;i<n;++i){\n            dp[i][0] = 1;\n            if(nums[i]==0){\n                continue;\n            }\n            for(int j=0;j<m;++j){\n                if(!(queries[j][0]<=i && queries[j][1]>=i)){\n                    continue;\n                }\n                int val = queries[j][2];\n                for(int k=nums[i];k>=val;--k){\n                    if(dp[i][k-val]==1){\n                        dp[i][k] = 1;\n                    }\n                }\n                if(dp[i][nums[i]]!=0){\n                    res = Math.max(res, j+1);\n                    break;\n                }\n            }\n            if(dp[i][nums[i]] == 0){\n                return -1;\n            }\n        }\n        return res;\n    }\n}","author":"youyouyou","submissionId":"611245918"},[]]},{"1812":[{"id":"1812","fileName":"611245609.txt","sourceCode":"class Solution:\n    def minZeroArray(self, A: List[int], Q: List[List[int]]) -> int:\n        res = -1\n        for i, a in enumerate(A):\n            if a == 0:\n                res = max(res, 0)\n                continue\n            B = [False] * (a + 1)\n            B[0] = True\n            mx = 0\n            nxtMx = 0\n            for q, (x, y, z) in enumerate(Q):\n                if x <= i <= y:\n                    for j in range(mx, -1, -1):\n                        if B[j] and j + z < len(B):\n                            B[j+z] = True\n                            nxtMx = max(nxtMx, j+z)\n                        if B[-1]:\n                            break\n                        mx = nxtMx\n                if B[-1]:\n                    res = max(res, q+1)\n                    break\n            else:\n                return -1\n        return res\n            \n                        \n                    ","author":"Doudle","submissionId":"611245609"},[]]},{"1813":[{"id":"1813","fileName":"611245477.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector <pair <int, int> > vec[15];\n        for(int i = 0; i < queries.size(); i++){\n            for(int j = queries[i][0]; j <= queries[i][1]; j++){\n                vec[j].push_back({queries[i][2], i + 1});\n            }\n        }\n        int ans = -1;\n        for(int i = 0; i < nums.size(); i++){\n            vector <bool> f(nums[i] + 1, 0);\n            f[0] = true;\n            if(f[nums[i]]) ans = max(ans, 0);\n            else\n            for(int j = 0; j < vec[i].size(); j++){\n                auto [x, p] = vec[i][j];\n                for(int k = nums[i]; k - x >= 0; k--){\n                    f[k] = f[k] || f[k - x];\n                }\n                if(f[nums[i]]){\n                    ans = max(ans, p);\n                    break;\n                }\n            }\n            if(!f[nums[i]]) return -1;\n        }\n        return ans;\n    }\n};","author":"dhxh","submissionId":"611245477"},[]]},{"1814":[{"id":"1814","fileName":"611246154.txt","sourceCode":"class Solution {\npublic:\n    bool dp[20][3025] = {0};\n    bool mp[20] = {0};\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), cnt = 0;\n        for(int i = 0; i < n; ++i) {\n            if(!nums[i])++cnt;\n            dp[i][0] = true;\n        }\n        if(cnt == n)return 0;\n        int k = 1;\n        for(auto q : queries) {\n            int ll = q[0], rr = q[1], val = q[2];\n            for(int i = ll; i <= rr; ++i) {\n                int num = nums[i];\n                if(dp[i][num])continue;\n                for(int j = 1500; j >= val; --j) {\n                    dp[i][j] = (dp[i][j] || dp[i][j - val]);\n                }\n                if(dp[i][num])++cnt;\n                if(cnt == n) {\n                    return k;\n                }\n            }\n            ++k;\n        }\n        return -1;\n    }\n};","author":"张二狗","submissionId":"611246154"},[]]},{"1815":[{"id":"1815","fileName":"611246081.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        L = len(nums)\n        can_zero = [num==0 for num in nums]\n        if all(can_zero):return 0\n        pos_values = [{num} for num in nums]\n        for i, (l,r,v) in enumerate(queries):\n            for j in range(l, r+1):\n                if can_zero[j]:continue\n                tmp_values = set()\n                for pv in pos_values[j]:\n                    if pv - v == 0:\n                        can_zero[j]=True\n                        break\n                    elif pv-v>0:\n                        tmp_values.add(pv-v)\n                    pos_values[j] = pos_values[j].union(tmp_values)\n            if all(can_zero):\n                return i +1\n        return -1\n        ","author":"海澄","submissionId":"611246081"},[]]},{"1816":[{"id":"1816","fileName":"611246550.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<vector<int>> vis(n, vector<int>(1001, 0));\n        int rest = n;\n        for (int i = 0; i < n; ++i) {\n            vis[i][nums[i]] = 1;\n            if (nums[i] == 0) --rest;\n        }\n        if (rest == 0) return 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = queries[i][0]; j <= queries[i][1]; ++j) {\n                if (vis[j][0] == 0) {\n                    for (int k = queries[i][2]; k < 1001; ++k) {\n                        if (vis[j][k] == 1) {\n                            vis[j][k - queries[i][2]] = 1;\n                        }\n                    }\n                    if (vis[j][0] == 1) {\n                        --rest;\n                    }\n                }\n            }\n            if (rest == 0) return i + 1;\n        }\n        return -1;\n    }\n};","author":"ddmike","submissionId":"611246550"},[]]},{"1817":[{"id":"1817","fileName":"611245899.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<vector<int>> dp(nums.size());\n        for(int i=0;i<nums.size();++i){\n            dp[i].resize(nums[i]+1);\n            dp[i][0]=1;\n        }\n        auto ok=[&](){\n            for(int j=0;j<nums.size();++j){\n                if(dp[j].back()==0){\n                    return 0;\n                }\n            }\n            return 1;\n        };\n        if(ok()){\n            return 0;\n        }\n        for(int i=0;i<queries.size();++i){\n            int l=queries[i][0], r=queries[i][1], v=queries[i][2];\n            for(int j=l;j<=r;++j){\n                if(dp[j].back()){\n                    continue;\n                }\n                for(int k=dp[j].size()-1;k>=v;--k){\n                    dp[j][k]|=dp[j][k-v];\n                }\n            }\n            if(ok()){\n                return i+1;\n            }\n        }\n        return -1;\n    }\n};","author":"无名棋脚","submissionId":"611245899"},[]]},{"1818":[{"id":"1818","fileName":"611246724.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        dic = defaultdict(list)\n        for j, (l, r, v) in enumerate(queries):\n            for i in range(l, r + 1):\n                dic[i].append((v, j))\n        ans = 0\n        for i in range(n):\n            target = nums[i]\n            if not target: continue\n            if not dic[i]: return -1\n            v = dic[i]\n            seen = set([0])\n            for a, j in v:\n                if target - a in seen:\n                    tmp = j\n                    break\n                ss = set()\n                for b in seen:\n                    if b + a < target:\n                        ss.add(b + a)\n                seen |= ss\n            else:\n                return -1\n            ans = max(ans, tmp + 1)\n        return ans","author":"silvertint10","submissionId":"611246724"},[]]},{"1819":[{"id":"1819","fileName":"611246635.txt","sourceCode":"import java.util.*;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        int maxK = -1;\n\n        for (int j = 0; j < n; j++) {\n            int target = nums[j];\n            if (target == 0) {\n                continue;\n            }\n\n            List<Integer> covers = new ArrayList<>();\n            for (int i = 0; i < m; i++) {\n                int l = queries[i][0];\n                int r = queries[i][1];\n                if (l <= j && j <= r) {\n                    covers.add(i);\n                }\n            }\n\n            Map<Integer, Integer> dp = new HashMap<>();\n            dp.put(0, -1);\n            for (int i : covers) {\n                int val = queries[i][2];\n                Map<Integer, Integer> newDp = new HashMap<>(dp);\n                for (Map.Entry<Integer, Integer> entry : dp.entrySet()) {\n                    int sum = entry.getKey();\n                    int currentMax = entry.getValue();\n                    int newSum = sum + val;\n                    if (newSum > target) {\n                        continue;\n                    }\n                    int newMax = Math.max(currentMax, i);\n                    if (!newDp.containsKey(newSum) || newMax < newDp.get(newSum)) {\n                        newDp.put(newSum, newMax);\n                    }\n                }\n                dp = newDp;\n            }\n\n            if (!dp.containsKey(target)) {\n                return -1;\n            }\n            int currentMax = dp.get(target);\n            maxK = Math.max(maxK, currentMax);\n        }\n\n        if (maxK == -1) {\n            for (int num : nums) {\n                if (num != 0) {\n                    return -1;\n                }\n            }\n            return 0;\n        }\n\n        return maxK + 1;\n    }\n}","author":"北海有你","submissionId":"611246635"},[]]},{"1820":[{"id":"1820","fileName":"611246403.txt","sourceCode":"class Solution {\n   public:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int> ans(nums.size(), -1);\n        for (int i = 0; i < nums.size(); i++) {\n            int x = nums[i];\n            vector<bool> f(x + 1), g(x + 1);\n            f[0] = true;\n            for (int q = 0; q < queries.size(); q++) {\n                int l = queries[q][0], r = queries[q][1], v = queries[q][2];\n                if (l <= i && i <= r) {\n                    for (int j = 0; j <= x; j++) {\n                        g[j] = f[j];\n                        if (j - v >= 0) {\n                            g[j] = g[j] | f[j - v];\n                        }\n                    }\n                    swap(f, g);\n                    if (f.back()) {\n                        ans[i] = q + 1;\n                        break;\n                    }\n                }\n            }\n            if (x == 0) ans[i] = 0;\n        }\n        int mx = 0;\n        for (int i: ans) {\n            if (i == -1) return -1;\n            mx = max(mx, i);\n        }\n        return mx;\n    }\n};","author":"sdcgvhgj","submissionId":"611246403"},[]]},{"1821":[{"id":"1821","fileName":"611246427.txt","sourceCode":"import java.util.Arrays;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int cnt = 0;\n        int max = Arrays.stream(nums).max().getAsInt();\n        int n = nums.length;\n\n        boolean[][] dp = new boolean[n][max + 10];\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n        for (int j = 0; j < n; j++) {\n            if (dp[j][nums[j]]) {\n                cnt++;\n            }\n        }\n        if (cnt == n) {\n            return 0;\n        }\n        for (int i = 0; i < queries.length; i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int v = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                for (int target = nums[j]; target >= v; target--) {\n                    dp[j][target] |= dp[j][target - v];\n                }\n            }\n            cnt = 0;\n            for (int j = 0; j < n; j++) {\n                if (dp[j][nums[j]]) {\n                    cnt++;\n                }\n            }\n            if (cnt == n) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n}","author":"acvv_Nickdd","submissionId":"611246427"},[]]},{"1822":[{"id":"1822","fileName":"611246952.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n        \n        vector<pair<int,int>> v[n];\n        for(int i = 0; i < q.size(); ++i) {\n            int l = q[i][0], r = q[i][1];\n            for(int j = l; j <= r; ++j) {\n                v[j].push_back({q[i][2], i});\n            }\n        }\n        \n        int ret = 0;\n        \n        for(int i = 0; i < n; ++i) {\n            if(nums[i] == 0) continue;\n            int f[2][nums[i] + 1];\n            memset(f, 0, sizeof(f));\n            f[0][0] = 1;\n            int res = -1;\n            for(int j = 0, cur = 0, ne = 1; j < v[i].size(); ++j) {\n                for(int k = 0; k < nums[i]; ++k) {\n                    if(f[cur][k]) {\n                        f[ne][k] = 1;\n                        if(k + v[i][j].first <= nums[i]) {\n                            f[ne][k + v[i][j].first] = 1;\n                        }\n                    }\n                }\n                if(f[ne][nums[i]]) {\n                    res = v[i][j].second;\n                    break;\n                }\n                cur ^= 1;\n                ne ^= 1;\n            }\n            if(res == -1) return -1;\n            ret = max(ret, res + 1);\n        }\n        \n        return ret;\n    }\n};","author":"newhar","submissionId":"611246952"},[]]},{"1823":[{"id":"1823","fileName":"611246777.txt","sourceCode":"#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long int\n#define db double\n#define ldb long double\n#define int128 __int128_t\n#define fr(x) freopen(x,\"r\",stdin);\n#define fw(x) freopen(x,\"w\",stdout);\n#define mst(x,a) memset(x,a,sizeof(x));\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define fi first\n#define se second\n#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define yes std::cout << \"Yesn\"\n#define no std::cout << \"Non\"\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#ifdef LOCAL\n#include \"leetcode.h\"\n#endif // LOCAL\ntemplate <typename T> int si(const T &x) { return x.size(); }\ntemplate <typename T, typename S> inline bool chmax(T &a, const S &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <typename T, typename S> inline bool chmin(T &a, const S &b) { if (b < a) { a = b; return true; } return false; }\nconst int mod = 1000000007;\nconst int inf = 0x3f3f3f3f;\nconst int M = 1005;\nint can[11][M];\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n      int n = si(nums);\n      int q = si(queries);\n      int ans = inf;\n      memset(can, 0, sizeof(can));\n      rep(i, n) can[i][nums[i]] = 1;\n      rep(i, q) {\n        bool ok = true;\n        int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n        for (int j = l; j <= r; j++) {\n          for (int k = v; k < M; k++) {\n            can[j][k-v] |= can[j][k];\n          }\n        }\n        rep(j, n) {\n          if (!can[j][0]) ok = false;\n        }\n        if (ok) {\n          ans = i + 1; break;\n        }\n      }\n      if (count(all(nums), 0) == n) {\n        return 0;\n      }\n      if (ans == inf) ans = -1;\n      return ans;\n    }\n};","author":"gcasd001","submissionId":"611246777"},[]]},{"1824":[{"id":"1824","fileName":"611247258.txt","sourceCode":"#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint minZeroArray(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize) {\n    int n = numsSize;\n    int q = queriesSize;\n    int cnt = n;\n    int ** dp = (int**) malloc(n * sizeof(int*));\n    for (int i = 0;i < n;i++) {\n        dp[i] = (int*) malloc((nums[i] + 5) * sizeof(int));\n        for (int j = 0;j < nums[i] + 5;j++) dp[i][j] = 0;\n        dp[i][0] = 1;\n        if (nums[i] == 0) cnt--;\n    }\n    if (cnt == 0) return 0;\n    int ans = 0;\n    for (int k = 0;k < q;k++) {\n        ans = k + 1;\n        int w = queries[k][2];\n        for (int i = queries[k][0]; i <= queries[k][1];i++) {\n            if (dp[i][nums[i]] == 1) continue;\n            for (int j = nums[i]; j - w >= 0;j--) {\n                if (dp[i][j - w] == 1) dp[i][j] = 1;\n            }\n            if (dp[i][nums[i]] == 1) cnt--;\n        }\n        if (cnt == 0) break;\n    }\n    if (cnt > 0) return -1;\n    return ans;\n}","author":"河城白露","submissionId":"611247258"},[]]},{"1825":[{"id":"1825","fileName":"611246415.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        List<Integer>[] vals = new ArrayList[n];\n        int[] valsSum = new int[n];\n        Arrays.setAll(vals, i -> new ArrayList<>());\n\n        int k = 0;\n        boolean[] valid = new boolean[n];\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += nums[i];\n            if (nums[i] == 0) valid[i] = true;\n        }\n\n        if (sum == 0) return 0;\n        \n        for (; k < queries.length; k++) {\n            int l = queries[k][0], r = queries[k][1];\n            for (int i = l; i <= r; i++) {\n                if (!valid[i]) {\n                    vals[i].add(queries[k][2]);\n                    valsSum[i] += queries[k][2];\n                    if (valsSum[i] < nums[i]) continue;\n                    if (valsSum[i] == nums[i] || check(nums[i], vals[i])) {\n                        valid[i] = true;\n                        sum -= nums[i];\n                    }\n                }\n            }\n\n            if (sum == 0) return k + 1;\n        }\n\n        return -1;\n    }\n\n    boolean check(int x, List<Integer> vals) {\n        return dfs(x, vals, 0);\n    }\n\n    boolean dfs(int x, List<Integer> vals, int i) {\n        if (x == 0) return true;\n        if (i == vals.size() || x < 0) return false;\n\n        boolean ans = false;\n        for (int j = i; j < vals.size() && !ans; j++) {\n            ans |= dfs(x - vals.get(j), vals, j+1);\n        }\n\n        return ans;\n    }\n}","author":"Nanmor","submissionId":"611246415"},[]]},{"1826":[{"id":"1826","fileName":"611247609.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, inf = len(nums), 1 << 30\n        t = [inf] * n\n\n        for i in range(n):\n            dp = [False] * (nums[i] + 1)\n            dp[nums[i]] = True\n            if dp[0]:\n                t[i] = 0\n                continue\n            for j in range(len(queries)):\n                l, r, val = queries[j]\n                if i < l or r < i: continue\n                for k in range(nums[i] - val + 1):\n                    dp[k] |= dp[k + val]\n                if dp[0]:\n                    t[i] = j + 1\n                    break\n            \n        ans = max(t)\n        if ans == inf: ans = -1\n        return ans","author":"Jos","submissionId":"611247609"},[]]},{"1827":[{"id":"1827","fileName":"611247574.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        res = -1\n        for i in range(n):\n            if nums[i] == 0:\n                continue\n            vis = []\n            for idx, (l, r, val) in enumerate(queries):\n                if l <= i <= r:\n                    vis.append((idx, val))\n            vis.sort()\n            dp = {0: -1}\n            for (idx, val) in vis:\n                for s, cur_max in list(dp.items()):\n                    new_s = s + val\n                    new_max = max(cur_max, idx)\n                    if new_s > nums[i]:\n                        continue\n                    if new_s not in dp or new_max < dp[new_s]:\n                        dp[new_s] = new_max\n            if nums[i] not in dp:\n                return -1\n            res = max(res, dp[nums[i]])\n        return res + 1","author":"Li Yixin","submissionId":"611247574"},[]]},{"1828":[{"id":"1828","fileName":"611247655.txt","sourceCode":"int minZeroArray(int* nums, int n, int** q, int m, int* queriesColSize){\n    int** dp = (int**)malloc(sizeof(int*) * n) ;\n    int* st = (int*) malloc(sizeof(int) * n) ; \n    for(int i = 0 ; i < n ; i ++) {\n        st[i] = 0 ; \n        dp[i] = (int*)malloc(sizeof(int) * (nums[i] + 1)) ;\n        for(int j = 0 ; j <= nums[i] ; j ++) dp[i][j] = 0 ;\n    }\n    for(int i = 0 ; i < n ; i ++) {\n        dp[i][nums[i]] = 1 ; \n    }\n    bool flag = true ;\n    for(int i = 0 ; i < n ; i ++)\n        if(nums[i]) flag = false ;\n    if(flag) return 0 ; \n    int res = 0 ; \n    for(int i = 0 ; i < m ; i ++){\n        int l = q[i][0] ;\n        int r = q[i][1] ;\n        int v = q[i][2] ;\n        for(int j = l ; j <= r ; j ++){\n            for(int k = 0 ; k <= nums[j] - v ; k ++){\n                dp[j][k] |= dp[j][k + v] ; \n            }\n            // for(int k = 0 ; k <= nums[j] ; k ++)\n                // printf(\"%d \" , dp[j][k]) ;\n            // puts(\"\") ; \n            if(dp[j][0] && st[j] == 0){\n                st[j] = 1 ;\n                // printf(\"%dn\" , i + 1) ; \n                ++ res ; \n                \n            }\n        }\n        if(res == n) return i + 1 ; \n\n    }\n    return -1 ; \n}","author":"罚时大师月色","submissionId":"611247655"},[]]},{"1829":[{"id":"1829","fileName":"611247715.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        if (!*max_element(nums.begin(), nums.end())) return 0;\n        vector<int> g(n);\n        vector<vector<bool>> f(n, vector<bool>(1001));\n        for (int i = 0; i < n; i++) {\n            f[i][0] = true;\n        }\n        for (int i = 0; i < m; i++) {\n            g.assign(n, 0);\n            for (int j = queries[i][0]; j <= queries[i][1]; j++) {\n                g[j] = queries[i][2];\n            }\n            for (int j = 0; j < n; j++) {\n                if (!g[j]) continue;\n                for (int k = 1000; k >= g[j]; k--) {\n                    if (f[j][k - g[j]]) f[j][k] = true;\n                }\n            }\n            bool flag = true;\n            for (int j = 0; j < n; j++) {\n                if (!f[j][nums[j]]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) return i + 1;\n        }\n        return -1;\n    }\n};","author":"onlyblues","submissionId":"611247715"},[]]},{"1830":[{"id":"1830","fileName":"611247826.txt","sourceCode":"func minZeroArray(nums []int, queries [][]int) int {\n\tinf := int(1e18)\n\tans := 0\n\n\tcalc := func(i, x int) int {\n\t\tf := make([]bool, x+1)\n\t\tf[0] = true\n\t\tfor j, q := range queries {\n\t\t\tl, r, val := q[0], q[1], q[2]\n\t\t\tif i > r || i < l || x-val < 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif f[x-val] {\n\t\t\t\treturn j + 1\n\t\t\t}\n\t\t\tfor k := x; k >= val; k-- {\n\t\t\t\tif f[k-val] {\n\t\t\t\t\tf[k] = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn inf\n\t}\n\n\tfor i, x := range nums {\n\t\tif x == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tans = max(ans, calc(i, x))\n\t}\n\n\tif ans == inf {\n\t\treturn -1\n\t}\n\treturn ans\n}","author":"FallenLeaves","submissionId":"611247826"},[]]},{"1831":[{"id":"1831","fileName":"611246980.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        # diff\n        n = len(nums)\n        def www(arr,y):\n            @cache\n            def dfs(i,y):\n                if y==0:\n                    return True\n                if i>=len(arr) or y<0:\n                    return False if y!=0 else True\n                return dfs(i+1,y) or dfs(i+1,y-arr[i])\n            return dfs(0,y)\n        def check(x):\n            ans = nums.copy()\n            dic = {}\n            for i,j,d in queries[:x]:\n                for x in range(i,j+1):\n                    if x in dic:\n                        dic[x].append(d)\n                    else:\n                        dic[x] = [d]\n            for i,y in enumerate(ans):\n                # x->0\n                if y>0:\n                    t = dic.get(i,[])\n                    if t==None:\n                        return False\n                    if not www(t,y):\n                        return False\n            return True\n        l = 0\n        r = len(queries)\n        res = -1\n        while l<=r:\n            mid = (l+r)//2\n            if check(mid):\n                res = mid\n                r = mid-1\n            else:\n                l = mid+1\n        return res\n                \n            \n                \n        ","author":"又不会写了","submissionId":"611246980"},[{"id":"1840","similarity":1.0,"totOverlap":156,"longestOverlap":78}]],"1840":[{"id":"1840","fileName":"611247818.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        # diff\n        n = len(nums)\n        def www(arr,y):\n            @cache\n            def dfs(i,y):\n                if y==0:\n                    return True\n                if i>=len(arr) or y<0:\n                    return False if y!=0 else True\n                return dfs(i+1,y) or dfs(i+1,y-arr[i])\n            return dfs(0,y)\n        def check(x):\n            ans = nums.copy()\n            dic = {}\n            for i,j,d in queries[:x]:\n                for x in range(i,j+1):\n                    if x in dic:\n                        dic[x].append(d)\n                    else:\n                        dic[x] = [d]\n            for i,y in enumerate(ans):\n                # x->0\n                if y>0:\n                    t = dic.get(i,[])\n                    if t==None:\n                        return False\n                    if not www(t,y):\n                        return False\n            return True\n        l = 0\n        r = len(queries)\n        res = -1\n        while l<=r:\n            mid = (l+r)//2\n            if check(mid):\n                res = mid\n                r = mid-1\n            else:\n                l = mid+1\n        return res\n                \n            \n                \n        ","author":"只会暴力","submissionId":"611247818"},[{"id":"1831","similarity":1.0,"totOverlap":156,"longestOverlap":78}]]},{"1832":[{"id":"1832","fileName":"611247836.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n=len(nums)\n        mp={}\n        cnt=0\n        a=[False]*n\n        for i in range(n):\n            mp[i]={nums[i]:True}\n            if nums[i]==0:\n                a[i]=True\n                cnt+=1\n        if cnt==n:return 0\n        for i in range(len(queries)):\n            l,r,val=queries[i][0],queries[i][1],queries[i][2]\n            for j in range(l,r+1):\n                if a[j]:continue\n                if val in mp[j]:\n                    a[j]=True\n                    cnt+=1\n                else:\n                    temp=set()\n                    for key in mp[j].keys():\n                        if key-val<0:continue\n                        temp.add(key-val)\n                    for s in temp:\n                        mp[j][s]=True\n            if cnt==n:return i+1\n        return -1","author":"郑涵予","submissionId":"611247836"},[]]},{"1833":[{"id":"1833","fileName":"611247558.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int len = queries.size();\n        unordered_set<int> vis;\n        int dp[len+1][n][1001];\n        memset(dp, 0, sizeof(dp));\n        for(int i=0;i<n;i++) {\n            dp[0][i][nums[i]] = 1;\n            if(nums[i] == 0) vis.insert(i);\n        }\n\n        if(vis.size() == n) return 0;\n\n        \n        for(int i=1;i<=len;i++) {\n            int l = queries[i-1][0], r = queries[i-1][1], v = queries[i-1][2];\n            for(int j=0;j<n;j++) {\n                for(int k=0;k<=1000;k++) {\n                    dp[i][j][k] = dp[i-1][j][k];\n                }\n            }\n            for(int j=l;j<=r;j++) {\n                for(int k=v;k<=1000;k++) {\n                    if(dp[i-1][j][k]) {\n                        dp[i][j][k-v] = 1;\n                        if(k-v == 0) vis.insert(j);\n                        if(vis.size() == n) return i;\n                    }\n                }\n            }\n        }\n\n        return -1;\n    }\n};","author":"陈小斌","submissionId":"611247558"},[]]},{"1834":[{"id":"1834","fileName":"611248040.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if all(n == 0 for n in nums):\n            return 0\n        num_set = [{n} for n in nums]\n        for q_i, (l, r, v) in enumerate(queries):\n            for n_i in range(l, r + 1):\n                new_set = set()\n                for p in num_set[n_i]:\n                    new_set.add(p)\n                    if p - v >= 0:\n                        new_set.add(p - v)\n                num_set[n_i] = new_set\n            if all(0 in n_set for n_set in num_set):\n                return q_i + 1\n        return -1","author":"kcrimson","submissionId":"611248040"},[]]},{"1835":[{"id":"1835","fileName":"611247937.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, m = len(nums), len(queries)\n        mx = [maxsize] * n  # 让每个数变成0所需经过的最小查询数量\n        for i, a in enumerate(nums):\n            if a == 0:\n                mx[i] = 0\n                continue\n            \n            s = {0}  # 不超过a的子集和\n            for j, (l, r, val) in enumerate(queries):\n                if not (l <= i <= r):\n                    continue\n                s |= {x + val for x in s if x + val <= a}\n                if a in s:\n                    mx[i] = j + 1\n                    break\n        ans = max(mx)\n        return ans if ans < maxsize else -1","author":"JeremyZhang96","submissionId":"611247937"},[]]},{"1836":[{"id":"1836","fileName":"611247914.txt","sourceCode":"class Solution {\nint n, m;\nint dp[1005][1005];\npublic:\n\n    int dfs(int pos, int x, int index, vector<vector<int>>& q)\n{\n    if(x == 0) return pos;\n    if(pos == m || x < 0) return 0x3f3f3f3f;\n    if(dp[pos][x] != -1) return dp[pos][x];\n    int ans = dfs(pos + 1, x, index, q);\n    if(q[pos][0] <= index && q[pos][1] >= index)\n        ans = min(dfs(pos + 1, x - q[pos][2], index, q), ans);\n    dp[pos][x] = ans;\n    return ans;\n}\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        n = nums.size(), m = q.size();\n        int ans = 0;\n        for(int i = 0; i < n; i++)\n            {\n                if(nums[i] == 0) continue;\n                for(int j = 0; j < m; j++)\n                    for(int k = 0; k <= 1000; k++)\n                        dp[j][k] = -1;\n                int t = dfs(0, nums[i], i, q);\n                // cout << t << \" \";\n                ans = max(ans, t);\n            }\n        if(ans == 0x3f3f3f3f) return -1;\n        return ans;\n    }\n};","author":"White","submissionId":"611247914"},[]]},{"1837":[{"id":"1837","fileName":"611248189.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int res = 0;\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] == 0) continue;\n            boolean[] dp = new boolean[nums[i] + 1];\n            dp[nums[i]] = true;\n            int p = 0;\n            for (int[] q : queries) {\n                ++p;\n                if (q[0] <= i && i <= q[1]) {\n                    for (int j = 0; j + q[2] <= nums[i]; ++j) {\n                        dp[j] |= dp[j + q[2]];\n                    }\n                }\n                if (dp[0]) break;\n            }\n            if (!dp[0]) return -1;\n            res = Math.max(res, p);\n        }\n        return res;\n    }\n}","author":"NeoStart","submissionId":"611248189"},[]]},{"1838":[{"id":"1838","fileName":"611247939.txt","sourceCode":"func minZeroArray(nums []int, queries [][]int) int {\n\tn := len(nums)\n\tsum := 0\n\tfor _, num := range nums {\n\t\tsum += num\n\t}\n\tif sum == 0 {\n\t\treturn 0\n\t}\n\tmpList := []map[int]bool{}\n\tfor i := 0; i < n; i++ {\n\t\tmpList = append(mpList, map[int]bool{nums[i]: true})\n\t}\n\tfor i, q := range queries {\n\t\tl, r, v := q[0], q[1], q[2]\n\t\tfor j := l; j <= r; j++ {\n\t\t\tmp := mpList[j]\n\t\t\ttmp := map[int]bool{}\n\t\t\tfor num := range mp {\n\t\t\t\ttmp[num] = true\n\t\t\t\tif num >= v {\n\t\t\t\t\ttmp[num-v] = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tmpList[j] = tmp\n\t\t}\n\t\tif AllZero(mpList) {\n\t\t\treturn i + 1\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc AllZero(mpList []map[int]bool) bool {\n\tfor _, mp := range mpList {\n\t\tif !mp[0] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","author":"慎微","submissionId":"611247939"},[]]},{"1839":[{"id":"1839","fileName":"611248515.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if sum(nums) == 0:\n            return 0\n        candidate = [[] for _ in range(len(nums))]\n        for cidx in range(len(queries)):\n            [l, r, x] = queries[cidx]\n            for i in range(l, r+1):\n                candidate[i].append([cidx, x])\n        print(candidate)\n        ans = [0]*len(nums)\n        for i in range(len(candidate)):\n            if nums[i] == 0:\n                continue\n            clist = candidate[i]\n            dp = [0]*(nums[i]+1)\n            dp[0] = 1\n            for [cidx, val] in clist: \n                for k in range(len(dp)-1, -1, -1):\n                    if k-val < 0:\n                        continue\n                    if dp[k-val] == 1:\n                        dp[k] = 1\n                if dp[-1] == 1:\n                    ans[i] = cidx+1\n                    break\n            if dp[-1] != 1:\n                return -1\n        return max(ans)","author":"速冻小鹿包","submissionId":"611248515"},[]]},{"1841":[{"id":"1841","fileName":"611248550.txt","sourceCode":"class Solution {\npublic:\n    int f[11][1010];\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        bool fg = true;\n        for(int i = 0; i < nums.size(); i++) if(nums[i] != 0) fg = false;\n        if(fg) return 0;\n        for(int i = 0; i < queries.size(); i++){\n            int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n            if(i == 0){\n                for(int j = 0; j < nums.size(); j++){\n                    f[j][0] = 1;\n                    if(j >= l && j <= r && nums[j] >= v) f[j][v] = 1;\n                }\n            }else{\n                for(int j = 0; j < nums.size(); j++){\n                    for(int k = nums[j]; k >= 0; k--){\n                        if(j >= l && j <= r && k >= v)f[j][k] |= f[j][k - v];\n                    }\n                }\n            }\n            bool flag = true;\n            for(int j = 0; j < nums.size(); j++) \n                if(f[j][nums[j]] == 0) {\n                    flag = false;\n                }\n            if(flag) return i + 1;\n        }\n        return -1;\n    }\n};","author":"ppaker","submissionId":"611248550"},[]]},{"1842":[{"id":"1842","fileName":"611248562.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int qs = queries.size(), ans = 0;\n        int f[1005], n = nums.size();\n        for (int i=0; i< n; i++) {\n            if (nums[i]==0) continue;\n            memset(f, 0, sizeof(f)); f[0] = 1;\n            int ok = 0;\n            for (int j=0; j< qs; j++) if (i>=queries[j][0] && i<=queries[j][1]) {\n                int k = queries[j][2];\n                for (int o=nums[i]; o>=k; o--) f[o] |= f[o-k];\n                if (f[nums[i]]) {\n                    ans = max(ans, j+1);\n                    ok = 1;\n                    break;\n                }\n            }\n            if (!ok) return -1;\n        }\n        return ans;\n    }\n};","author":"啊啊啊啊","submissionId":"611248562"},[]]},{"1843":[{"id":"1843","fileName":"611248807.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        // 其实就是看每个数，可以被queries中的最少前几个val减到0，val可选可不选\n        int n = nums.size(), m = queries.size();\n        int mx = *max_element(nums.begin(), nums.end());\n        if(mx == 0) return 0;\n        vector<vector<bool>> dp(n, vector<bool>(mx + 1, false));\n        for(int i = 0; i < n; i++) dp[i][0] = true;\n        for(int k = 0; k < m; k++){\n            int l = queries[k][0], r = queries[k][1], val = queries[k][2];\n            for (int j = l; j <= r; j++) {\n                for (int s = nums[j]; s >= val; s--) {\n                    if (!dp[j][s] && dp[j][s - val]) {\n                        dp[j][s] = true;\n                    }\n                }\n            }\n            bool flag = true;\n            for (int j = 0; j < n; j++) {\n                if (!dp[j][nums[j]]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) return k + 1;\n        }\n        return -1;\n    }\n};","author":"a碟","submissionId":"611248807"},[]]},{"1844":[{"id":"1844","fileName":"611248183.txt","sourceCode":"class Solution {\npublic:\n    int sum(vector<int>& arr) {\n        int n = 0;\n        for (auto& i : arr) {\n            n += i;\n        }\n        return n;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        if (sum(nums) == 0) {\n            return 0;\n        }\n        vector<int> arr(nums.size());\n        vector<vector<int>> arr2(nums.size());\n        for (int i = 0; i < arr2.size(); i++) {\n            arr2[i] = vector<int>(nums[i] + 1);\n            arr2[i][0] = 1;\n            if (arr2[i].back())\n                arr[i] = true;\n        }\n        int ans = 0;\n        while (ans != queries.size()) {\n            int left = queries[ans][0];\n            int right = queries[ans][1];\n            for (int i = left; i <= right; i++) {\n                if (arr[i])\n                    continue;\n                for (int j = arr2[i].size() - 1; j >= 0; j--) {\n                    if (arr2[i][j] && j + queries[ans][2] < arr2[i].size()) {\n                        arr2[i][j + queries[ans][2]] = 1;\n                        if (arr2[i].back()) {\n                            arr[i] = 1;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (sum(arr) == nums.size())\n                break;\n            ans++;\n        }\n        if (ans == queries.size()) {\n            return -1;\n        }\n        return ans + 1;\n    }\n};","author":"Elaina","submissionId":"611248183"},[]]},{"1845":[{"id":"1845","fileName":"611248626.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size(), m = q.size();\n        int ans = 0;\n        int N = 1e3;\n        for (int i = 0; i < n; i++) {\n            if (a[i] == 0) {\n                continue;\n            }\n            std::vector<int> f(a[i] + 1);\n            f[0] = 1;\n            int j = 0;\n            while (j < m) {\n                if (q[j][0] > i || q[j][1] < i) {\n                    j++;\n                    continue;\n                }\n                for (int k = a[i]; k >= q[j][2]; k--) {\n                    f[k] |= f[k - q[j][2]];\n                }\n                if (f[a[i]]) {\n                    break;\n                }\n                // std::cout << j << \"n\";\n                j++;\n            }\n            if (j == m) {\n                return -1;\n            }\n            ans = std::max(ans, j + 1);\n        }\n        return ans;\n    }\n};","author":"纯金是单质","submissionId":"611248626"},[]]},{"1846":[{"id":"1846","fileName":"611248786.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        # # 大水漫灌，先做一件事情，每个位置能被\n        # k=0\n        # n=len(nums)\n        # n_sum=[0]*n\n        # n_dict={}\n        # for q in queries:\n        #     k+=1\n        #     l,r,v=q\n        #     i=l\n        #     while i<r+1:\n        #         n_sum[i]+=v\n        #         if \n        n = len(nums)\n        m = len(queries)\n        \n        # 预处理每个元素i，收集覆盖它的查询并按索引排序\n        element_queries = [[] for _ in range(n)]\n        for idx, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                element_queries[i].append((idx, val))\n        \n        # 对每个元素i的查询按索引排序\n        for i in range(n):\n            element_queries[i].sort()  # 按索引升序排列\n        \n        element_max_idx = []\n        for i in range(n):\n            target = nums[i]\n            # 初始化动态规划字典，记录和对应的最大索引的最小值\n            dp = {0: -1}  # sum: min_max_index\n            for (q_idx, val) in element_queries[i]:\n                current_entries = list(dp.items())\n                for s, current_max in current_entries:\n                    new_s = s + val\n                    new_max = max(current_max, q_idx)\n                    # 如果新和不存在，或者存在但新的max更小，则更新\n                    if new_s not in dp or new_max < dp[new_s]:\n                        dp[new_s] = new_max\n            # 检查是否存在和为target的情况\n            if target not in dp:\n                return -1\n            element_max_idx.append(dp[target])\n        \n        # 处理特殊情况：元素初始值为0的情况\n        for i in range(n):\n            if nums[i] != 0 and element_max_idx[i] == -1:\n                return -1\n        \n        # 计算最大的max_idx\n        max_k_candidate = max(element_max_idx)\n        if max_k_candidate == -1:\n            # 所有元素初始值为0，不需要任何查询\n            return 0\n        else:\n            return max_k_candidate + 1","author":"kimoji","submissionId":"611248786"},[]]},{"1847":[{"id":"1847","fileName":"611248911.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& Qu) {\n        int n = a.size();\n        std::vector<std::vector<int> > f(a.size(), std::vector<int>(1010));\n        if(*max_element(a.begin(), a.end()) == 0) return 0;\n        for(int i = 0; i < n; i ++) f[i][0] = 1;\n        for(int i = 0; i < Qu.size(); i ++){\n            auto l = Qu[i][0], r = Qu[i][1], val = Qu[i][2];\n            for(int j = l; j <= r; j ++){\n                for(int k = a[j]; k >= val; k --){\n                    f[j][k] |= f[j][k - val];\n                }\n            }\n            int suc = 1;\n            for(int i = 0; i < n; i ++){\n                if(!f[i][a[i]]){\n                    suc = 0;\n                    break;\n                }\n            }\n            if(suc){ \n                return i + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"WUHUQIFEI123","submissionId":"611248911"},[]]},{"1848":[{"id":"1848","fileName":"611248931.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries)\n    {\n    \tint  n = nums.size();\n    \tint  m = queries.size();\n    \tint  N = *max_element(nums.begin(), nums.end());\n    \tauto check = [&](int mid) -> bool {\n    \t\tvector<vector<int>> f(n, vector<int>(N + 1, 0));\n    \t\tfor (int i = 0; i < n; i++) f[i][0] = 1;\n    \t\tfor (int k = 0; k < mid; k++)\n    \t\t{\n    \t\t\tfor (int i = queries[k][0]; i <= queries[k][1]; i++)\n    \t\t\t{\n    \t\t\t\tfor (int j = nums[i]; j >= queries[k][2]; j--)\n    \t\t\t\t{\n    \t\t\t\t\tf[i][j] |= f[i][j - queries[k][2]];\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tfor (int i = 0; i < n; i++)\n    \t\t\tif (!f[i][nums[i]]) return false;\n    \t\treturn true;\n    \t};\n    \n    \tint l = 1, r = m;\n    \twhile (l <= r)\n    \t{\n    \t\tint mid = (l + r) >> 1;\n    \t\tif (check(mid))\n    \t\t\tr = mid - 1;\n    \t\telse\n    \t\t\tl = mid + 1;\n    \t}\n        if(check(0))return 0;\n    \treturn l == m + 1 ? -1 : l;\n    }\n};","author":"OVOAutoMaton","submissionId":"611248931"},[]]},{"1849":[{"id":"1849","fileName":"611248988.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        bool tag=true;\n        for(int i=0;i<n;i++){\n            if(nums[i]!=0){\n                tag=false;\n                break;\n            }\n        }\n        if(tag){\n            return 0;\n        }\n        vector<bitset<1001>>vc(n,1);\n        int k=1;\n        int r=queries.size();\n        for(auto& q:queries){\n            for(int i=q[0];i<=q[1];i++){\n                vc[i]=(vc[i]|(vc[i]<<q[2]));\n            }\n            bool flag=true;\n            bitset<1001>b(1);\n            for(int i=0;i<n;i++){\n                if(((vc[i]>>nums[i])&b)==0){\n                    flag=false;\n                    break;\n                }\n            }\n            if(flag){\n               break; \n            }\n            k++;\n        }\n        return k>r?-1:k;\n    }\n};","author":"yuanhao","submissionId":"611248988"},[]]},{"1850":[{"id":"1850","fileName":"611248846.txt","sourceCode":"class Solution {\npublic:\n    bool solve(vector<int>& summand, int target)\n    {\n        vector<int> dp(target+1);\n        dp[0] = 1;\n        for(int x: summand)\n        {\n            for(int y = target; y >= x; --y)\n            {\n                if(dp[y - x])\n                {\n                    dp[y] = 1;\n                }\n            }\n        }\n        return dp[target];\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        int l = 0;\n        int r = q;\n        int ans = -1;\n        while(l <= r)\n        {\n            int md = (l+r)/2;\n            vector<vector<int>> add(n);\n            for(int i = 0; i < md; ++i)\n            {\n                for(int j = queries[i][0]; j <= queries[i][1]; ++j)\n                {\n                    add[j].push_back(queries[i][2]);        \n                }\n            }\n            bool ok = true;\n            for(int i = 0; i < n; ++i)\n            {\n                if(!solve(add[i], nums[i]))\n                {\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok) \n            {\n                ans = md;\n                r = md - 1;\n            }\n            else\n            {\n                l = md + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"Boring Kepler7FY","submissionId":"611248846"},[]]},{"1851":[{"id":"1851","fileName":"611249013.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size(), res = 0;\n        int l, r, x, y;\n        vector<int> d(n, -1);\n        for(int k = 0; k < n; ++k){\n            y = nums[k];\n            vector<bool> dp(1001);\n            dp[0] = true;\n            if(y == 0){\n                d[k] = 0;\n                continue;\n            }\n            for(int i = 0; i < m; ++i){\n                l = queries[i][0];\n                r = queries[i][1];\n                x = queries[i][2];\n                if(k < l || k > r){\n                    continue;\n                }\n                for(int j = y; j >= x; --j){\n                    if(dp[j - x]){\n                        dp[j] = true;\n                    }\n                }\n                if(dp[y]){\n                    // cout<<k<<\" \"<<y<<\" \"<<i<<endl;\n                    d[k] = i + 1;\n                    break;\n                }\n            }\n            if(d[k] == -1){\n                res = -1; break;\n            }\n            res = max(res, d[k]);\n        }\n        return res;\n    }\n};","author":"13579","submissionId":"611249013"},[]]},{"1852":[{"id":"1852","fileName":"611248940.txt","sourceCode":"class Solution {\npublic:\n     int coinChange(vector<int> &nums, int target) {\n        if (target == 0) return true;\n        if (nums.size() == 0 && target != 0) return false;\n\n        vector<bool> dp(target + 1, false);\n        dp[0] = true;\n        \n        for (int num : nums) {\n            if (num <= target) {\n                for (int j = target; j >= num; --j) {\n                    if (dp[j - num]) {\n                        dp[j] = true;\n                    }\n                }\n            }\n        }\n        return dp[target];\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n        vector<vector<int>> c;\n        c.resize(n);\n        bool f = true;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != 0) break;\n            if (i == n - 1) return 0;\n        }\n        auto check = [&] () -> bool {\n            for (int i = 0; i < n; i++) {\n                if (!coinChange(c[i], nums[i])) return false;\n            }\n            return true;\n        };\n        for (int i = 0; i < q.size(); i++) {\n           int l = q[i][0], r = q[i][1], v = q[i][2];\n            for (int j = l; j <= r; j++) {\n                c[j].push_back(v);\n            }\n            if (check()) return i +1;\n        }\n        return -1;\n    }\n};","author":"Relaxed","submissionId":"611248940"},[]]},{"1853":[{"id":"1853","fileName":"611249598.txt","sourceCode":"int minZeroArray(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize) {\n    int min=-1;\n    bool if_h=true;\n    for(int i=0;i<numsSize;i++)\n    {\n        if(nums[i]>0) if_h=false;\n    }\n    if(if_h) return 0;\n    for(int i=0;i<numsSize;i++)\n    {\n        int *re=malloc(sizeof(int *)*(nums[i]+1));\n        for(int j=0;j<nums[i];j++)\n        {\n            re[j]=0;\n        }\n        re[nums[i]]=1;\n        for(int j=0;j<queriesSize;j++)\n        {\n            if(queries[j][0]<=i&&queries[j][1]>=i)\n            {\n                for(int l=0;l<=nums[i]-queries[j][2];l++)\n                {\n                    if(re[l+queries[j][2]]==1) re[l]=1;\n                }\n            }\n            if(re[0]==1)\n            {\n                if(j+1>min) min=j+1;\n                break;\n            }\n        }\n        if(re[0]==0) return -1;\n    }\n    return min;\n}","author":"Caihw","submissionId":"611249598"},[]]},{"1855":[{"id":"1855","fileName":"611249372.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = 0, n = nums.size(), mx = ranges::max(nums);\n        if(mx == 0) return 0;\n        vector<vector<int>> f(n, vector<int>(mx+1));\n        for(int i=0; i<n; i++) f[i][0] = 1;\n        for(auto & q : queries) {\n            ans++;\n            int l = q[0], r = q[1], v = q[2];\n            for(int i=l; i<=r; i++) {\n                for(int k=nums[i]; k>=v; k--) {\n                    f[i][k] |= f[i][k-v];\n                }\n            }\n            bool zero = true;\n            for(int i=0; i<n; i++) {\n                if(!f[i][nums[i]]) {\n                    zero = false;\n                    break;\n                }\n            }\n            if(zero) return ans;\n        }\n        return -1;\n    }\n};","author":"OHNO","submissionId":"611249372"},[]]},{"1856":[{"id":"1856","fileName":"611249240.txt","sourceCode":"class Solution {\npublic:\n    int n;\n    int len;\n    vector<int> canchoose[15];\n    bool dp(int val,vector<int>& have)\n    {\n        int tmplen=have.size();\n        vector<vector<bool>> f(tmplen+5,vector<bool>(val+8,0));\n        f[0][0]=true;\n        int i,j,k;\n        int V;\n        for(i=1;i<=tmplen;i++)\n            f[i][0]=true;\n        for(V=1;V<=val;V++)\n        {\n            for(i=1;i<=tmplen;i++)\n            {\n                if(V>=have[i-1])\n                {\n                    f[i][V]=f[i][V] | f[i-1][V-have[i-1]];\n                }\n                f[i][V]=f[i][V] | f[i-1][V];\n            }\n        }\n        for(i=0;i<=tmplen;i++)\n        if(f[i][val]) \n        return true;\n        \n        return false;\n    }\n    bool check(int need,vector<int>& nums, vector<vector<int>>& queries)\n    {\n        int i,j,k;\n        for(i=0;i<n;i++) canchoose[i].clear();\n        for(i=0;i<=need;i++)\n        {\n            for(j=queries[i][0];j<=queries[i][1];j++)\n            {\n                canchoose[j].push_back(queries[i][2]);//每个地方的待选\n            }\n        }\n        for(i=0;i<n;i++)\n        {\n            if(!dp(nums[i],canchoose[i]))\n            return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        n=nums.size();\n        len=queries.size();\n        int i,j,k;\n        bool flag=true;\n        for(i=0;i<n;i++)\n        {\n            if(nums[i]!=0)\n            {\n                flag=false;\n                break;\n            }\n        }\n        if(flag) return 0;\n        int ans=-1;\n        int l=0,r=len-1,mid;\n        while(l<=r)\n        {\n            mid=(l+r)>>1;\n            if(check(mid,nums,queries))\n            {\n                ans=mid+1;\n                r=mid-1;\n            }\n            else\n            l=mid+1;\n        }\n        return ans;\n    }\n};","author":"野望","submissionId":"611249240"},[]]},{"1857":[{"id":"1857","fileName":"611249680.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(),nq=queries.size(),iq=0;\n        int mask=(1<<n)-1;\n        int maxv=*max_element(nums.begin(),nums.end());\n        if(maxv==0) return 0;\n        vector<bool> vt(maxv+1,false);\n        vt[0]=true;\n        vector<vector<bool>> m(n,vt);\n        for(;iq<nq && mask!=0;++iq)\n        {\n            for(int i=queries[iq][0];i<=queries[iq][1];++i)\n            {\n                if((mask&(1<<i))==0) continue;\n                vector<bool> &last=m[i];\n                for(int val=queries[iq][2],j=nums[i]-val;j>=0;--j)\n                {\n                    if(last[j]) last[j+val]=true;\n                }\n                if(last[nums[i]]) mask^=(1<<i);\n            }\n        }\n        if(mask!=0) iq=-1;\n        return iq;\n    }\n};","author":"周周","submissionId":"611249680"},[]]},{"1858":[{"id":"1858","fileName":"611249633.txt","sourceCode":"class Solution:\n\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        if all(i == 0 for i in nums):\n            return 0\n\n        n = len(nums)\n        d = defaultdict(list)\n        for qi, (l, r, v) in enumerate(queries):\n            t = [v, qi]\n            for i in range(l, r + 1):\n                d[i].append(t)\n\n        def check(ns, tar):\n\n            if tar == 0:\n                return -1\n\n            cur_vs = set()\n            cur_vs.add(0)\n            for v, qi in ns:\n                to_add = set()\n                for cur in cur_vs:\n                    t = cur + v\n                    if t == tar:\n                        return qi\n                    to_add.add(t)\n                cur_vs |= to_add\n                # print(\"after check v: {}, qi: {}, the cur_vs is {}\".format(v, qi, cur_vs))\n\n            return None\n\n        ans = list()\n        for i in range(n):\n            # print(\"d[i]: {}, nums[i]: {}\".format(d[i], nums[i]))\n            qi = check(d[i], nums[i])\n            if qi is None:\n                return -1\n            ans.append(qi)\n\n        return max(ans) + 1\n","author":"喜乐","submissionId":"611249633"},[]]},{"1859":[{"id":"1859","fileName":"611249254.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        bool f[10][1005];\n        memset(f,false,sizeof(f));\n        int m=queries.size(),n=nums.size(),cnt=n,res=0;\n        for(int i=0;i<n;i++){f[i][0]=true;if(!nums[i])cnt--;}\n        for(int a=0;a<m;a++){\n            auto& q=queries[a];\n            int &l=q[0],&r=q[1],&val=q[2];\n            for(int i=l;i<=r;i++){\n                if(f[i][nums[i]])continue;\n                for(int j=nums[i];j>=val;j--){\n                    f[i][j]|=f[i][j-val];\n                }\n                if(val<=nums[i])f[i][val]=true;\n                if(f[i][nums[i]]){\n                    cnt--;\n                    res=a+1;\n                }\n            }\n        }\n        return cnt?-1:res;\n    }\n};","author":"贺茂建角身神","submissionId":"611249254"},[]]},{"1860":[{"id":"1860","fileName":"611249231.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length, res = 0;\n        Set<Integer> s = new HashSet<>();\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != 0) {\n                s.add(i);\n            }\n        }\n        if (s.size() == 0) return 0;\n        Map<Integer, Set<Integer>> m = new HashMap<>();\n        for (int i = 0; i < queries.length; i++) {\n            int[] q = queries[i];\n            for (int j = q[0]; j <= q[1]; j++) {\n                if (!s.contains(j)) continue;\n                m.putIfAbsent(j, new HashSet<>());\n                Set<Integer> se = m.get(j);\n                HashSet<Integer> te = new HashSet<>();\n                if (!se.isEmpty()) {\n                    for (Integer it : se) {\n                        if (q[2] + it == nums[j]) s.remove(j);\n                        te.add(q[2] + it);\n                    }\n                }\n                te.add(q[2]);\n                se.addAll(te);\n                \n                if (q[2] == nums[j]) {\n                    s.remove(j);\n                }\n            }\n            // System.out.println(m);\n            if (s.size() == 0) return i + 1;\n        }\n        return -1;\n    }\n}","author":"waters_man","submissionId":"611249231"},[]]},{"1861":[{"id":"1861","fileName":"611249754.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        boolean isOk = true;\n        for (int num : nums) {\n            if (num != 0) {\n                isOk = false;\n                break;\n            }\n        }\n        if (isOk) return 0;\n        for (int k = 1; k <= m ; k++) {\n            boolean ok = true;\n            for (int i = 0 ; i < n ; i++){\n                int t = nums[i];\n                List<Integer> list = new ArrayList<>();\n                for (int j = 0; j < k; j++) {\n                    int l = queries[j][0];\n                    int r = queries[j][1];\n                    int val = queries[j][2];\n                    if (l <= i && i <= r){\n                        list.add(val);\n                    }\n                }\n                if (!check(list,t)){\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) return k;\n        }\n        return -1;\n    }\n    \n    private boolean check(List<Integer> list,int capacity){\n        boolean[] f = new boolean[capacity + 1];\n        f[0] = true;\n        for (Integer x : list) {\n            for (int i = capacity; i >= x ; i--) {\n                f[i] = f[i] || f[i - x];\n            }\n        }\n        return f[capacity];\n    }\n}","author":"酷到没脾气","submissionId":"611249754"},[]]},{"1862":[{"id":"1862","fileName":"611249821.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def check (j, x):\n            t = 1 << x\n            for i, (l, r, v) in enumerate(queries):\n                if l <= j <= r:\n                    t |= t >> v\n                if t & 1 == 1:\n                    return i + 1\n            return -1\n\n        ans = 0\n        for i, x in enumerate(nums):\n            if x == 0:continue\n            v = check(i, x)\n            if v == -1:\n                return -1\n            ans = max(ans, v)\n        return ans\n","author":"stargazy","submissionId":"611249821"},[]]},{"1864":[{"id":"1864","fileName":"611250075.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        const int N = nums.size();\n        const int Q = queries.size();\n        int ret = 0;\n        for (int i = 0; i < N; i++) {\n            if (nums[i] == 0) {\n                continue;\n            }\n            set<int> cur;\n            cur.insert(nums[i]);\n            int k = -1;\n            for (int j = 0; j < Q; j++) {\n                auto l = queries[j][0];\n                auto r = queries[j][1];\n                auto val = queries[j][2];\n\n                if (l > i || r < i) {\n                    continue;\n                }\n\n                if (cur.find(val) != cur.end()) {\n                    k = j;\n                    break;\n                }\n\n                set<int> next;\n                for (auto x : cur) {\n                    if (x > val) {\n                        next.insert(x - val);\n                    }\n                }\n                for (auto x : next) {\n                    cur.insert(x);\n                }\n            }\n            if (k == -1) {\n                return -1;\n            } else {\n                ret = max(ret, k + 1);\n            }\n        }\n        return ret == INT_MAX ? -1 : ret;\n    }\n};","author":"HamsiK","submissionId":"611250075"},[]]},{"1865":[{"id":"1865","fileName":"611250055.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        auto getMinK = [&](int i)->int {\n            if (nums[i] == 0) return 0;\n            bitset<1001> can;\n            can.reset();\n            can[nums[i]] = 1;\n            for (int k = 1; k <= queries.size(); k++) {\n                int iL = queries[k - 1][0], iR = queries[k - 1][1], val = queries[k - 1][2];\n                if ((iL <= i && i <= iR)) can |= (can >> val);\n                if (can[0]) return k;\n            }\n            return queries.size() + 1;\n        };\n        int ans = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            ans = max(ans, getMinK(i));\n        }\n        return ans == (queries.size() + 1) ? -1 : ans;\n    }\n\n};","author":"Cranky Hermann8Yl","submissionId":"611250055"},[]]},{"1866":[{"id":"1866","fileName":"611249777.txt","sourceCode":"class Solution:  \n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:  \n        if all(v == 0 for v in nums):  \n            return 0  \n        n = len(nums)  \n        l, r = 0, len(queries)  \n        ans = -1  \n\n        def check(k: int) -> bool:  \n            for i in range(n):  \n                v = [q[2] for q in queries[:k] if q[0] <= i <= q[1]]  \n                target = nums[i]  \n                dp = [False] * (target + 1)  \n                dp[0] = True  \n\n                for val in v:   \n                    for j in range(target, -1, -1):  \n                        if dp[j] and j + val <= target:  \n                            dp[j + val] = True  \n                    if dp[target]:  \n                        break  \n                if not dp[target]:  \n                    return False  \n            return True  \n\n        while l <= r:  \n            mid = (l + r) >> 1  \n            if check(mid):  \n                ans = mid  \n                r = mid - 1  \n            else:  \n                l = mid + 1  \n\n        return ans\n","author":"OverclockedIvan","submissionId":"611249777"},[]]},{"1867":[{"id":"1867","fileName":"611249890.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number}\n */\nvar minZeroArray = function(nums, queries) {\n        function helper(index, q_i, t_c, map) {\n        if (q_i >= queries.length) return Infinity;\n        const s = q_i + ',' + t_c;\n        if (map.has(s)) return map.get(s);\n        const [l, r, val] = queries[q_i];\n        let rt = Infinity;\n        if (l <= index && r >= index && t_c >= val) {\n            const next_c = t_c - val;\n            if (next_c === 0) {\n                rt = q_i;\n            } else {\n                const next = helper(index, q_i + 1, next_c, map);\n                rt = next;\n            }\n        }\n        const next_2 = helper(index, q_i + 1, t_c, map);\n        rt = Math.min(rt, next_2);\n        map.set(s, rt);\n        return rt;\n    }\n    const c = nums.reduce((sum, v) => sum + v, 0);\n    if (c === 0) return 0;\n    let rt = -1;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] === 0) continue;\n        const map = new Map();\n        let t_i = helper(i, 0, nums[i], map);\n        if (t_i === Infinity) {\n            return -1;\n        } else {\n            t_i += 1;\n        }\n        rt = Math.max(t_i, rt);\n    }\n    return rt;\n};","author":"peepeepoopoo","submissionId":"611249890"},[]]},{"1868":[{"id":"1868","fileName":"611250166.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n,m = len(nums),len(queries)\n        ma = max(nums)+1\n        \n        left = -1\n        right = m+1\n        \n        while left+1!=right:\n            dp = [[False]*ma for _ in range(n)]\n            for i in range(n):\n                dp[i][0] = True                       #可以加减得到的值\n            mp = defaultdict(int)\n            mid = (left+right)>>1\n            for l,r,val in queries[:mid]:\n                for t in range(l,r+1):\n                    for i in range(ma-1,val-1,-1):\n                        dp[t][i] = dp[t][i] or dp[t][i-val]\n\n            '''print(\"mid=\",mid)\n            for t in range(n):\n                for i in range(ma):\n                    print(dp[t][i],end=' ')\n                print()'''\n                    \n                    \n            flg = True\n            for i in range(n):\n                if not dp[i][nums[i]]:\n                    flg = False\n                    break\n            if flg:\n                right = mid\n            else:\n                left = mid\n        if right==m+1:\n            return -1\n        return right","author":"Elasxible","submissionId":"611250166"},[]]},{"1869":[{"id":"1869","fileName":"611250116.txt","sourceCode":"class Solution {\npublic:\nint dp[1100];\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int minn=0;\n        for(int i=0;i<nums.size();i++){\n            if(nums[i]!=0)break;\n            if(nums[i]==0&&i==nums.size()-1){\n                return 0;\n            }\n        }\n        for(int i=0;i<nums.size();i++){\n            for(int j=0;j<=nums[i];j++){\n                dp[j]=0;\n            }\n            dp[nums[i]]=1;\n            for(int j=0;j<queries.size();j++){\n                int l=queries[j][0];\n                int r=queries[j][1];\n                int jian=queries[j][2];\n                if(l<=i&&i<=r){\n                    for(int k=0;k<=nums[i];k++){\n                        if(dp[k]==1&&k>=jian){\n                            dp[k-jian]=1;\n                        }\n                    }\n\n                    \n                }\n                if(dp[0]==1){\n                    minn=max(minn,j+1);\n                    break;\n                }\n            }\n            if(dp[0]==0){\n                return -1;\n            }\n        }\n        return minn;\n    }\n};","author":"该进厂打螺丝了","submissionId":"611250116"},[]]},{"1870":[{"id":"1870","fileName":"611250347.txt","sourceCode":"int dp[1001][1001]{};\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n=nums.size();\n        auto dfs=[&](auto &dfs,int i,int x,int y)->int {\n            if(x==0) {\n                return i;\n            }\n            if(i>=q.size()) return INT32_MAX;\n            if(dp[i][x]!=-1) return dp[i][x];\n            int res=dfs(dfs,i+1,x,y);\n            if(q[i][0]<=y&&q[i][1]>=y) {\n                if(x>=q[i][2]) res=min(res,dfs(dfs,i+1,x-q[i][2],y));\n            }\n            dp[i][x]=res;\n            return res;\n        };\n        int res=0;\n        for(int y=0;y<n;y++) {\n            int x=nums[y];\n            for(int i=0;i<q.size();i++) {\n                for(int j=0;j<=x;j++) {\n                    dp[i][j]=-1;\n                }\n            }\n            res=max(res,dfs(dfs,0,x,y));\n        }\n        if(res==INT32_MAX) return -1;\n        return res;\n    }\n};","author":"DestinyGod","submissionId":"611250347"},[]]},{"1871":[{"id":"1871","fileName":"611250248.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        mx = max(nums)\n        if mx == 0:\n            return 0\n\n        n = len(nums)\n        arr = [[False]*(mx+1) for v in nums]\n        for i in range(n):\n            arr[i][nums[i]] = True\n        \n        left = sum([1 if v > 0 else 0 for v in nums])\n\n        for idx,(l,r,v) in enumerate(queries):\n            for i in range(l,r+1):\n                if arr[i][0]:\n                    continue\n                for e in range(1,mx+1):\n                    if not arr[i][e]:\n                        continue\n                    if e == v:\n                        arr[i][0] = True\n                        left -= 1\n                        break\n                    if e > v:\n                        arr[i][e-v] = True\n            #print(idx,(l,r,v),'left',left,'arr',arr)\n            if not left:\n                return idx+1\n        return -1","author":"cpp20","submissionId":"611250248"},[]]},{"1872":[{"id":"1872","fileName":"611250392.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        List<Integer>[] a = new List[n];\n        Arrays.setAll(a, k -> new ArrayList<>());\n        if (check(nums, a)) {\n            return 0;\n        }\n        int ans = 0;\n        for (int[] q : queries) {\n            for (int i = q[0]; i <= q[1]; ++i) {\n                a[i].add(q[2]);\n            }\n            ans++;\n            if (check(nums, a)) {\n                return ans;\n            }\n        }\n        return -1;\n    }\n    boolean check(int[] a, List<Integer>[] li) {\n        int n = a.length;\n        for (int i = 0; i < n; ++i) {\n            boolean[] f = new boolean[a[i] + 1];\n            f[0] = true;\n            for (int x : li[i]) {\n                for (int j = a[i]; j >= x; --j) {\n                    f[j] |= f[j - x];\n                }\n            }\n            if (!f[a[i]]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}","author":"zzl","submissionId":"611250392"},[]]},{"1873":[{"id":"1873","fileName":"611250360.txt","sourceCode":"class Solution {\npublic:\n    const int INF=1003;\n    int f(vector<int>& a,int t){\n        if(t==0)return 0;\n        int n=a.size();\n        vector<vector<bool>> dp(n,vector<bool>(t+1,0));\n        dp[0][0]=true;\n        dp[0][a[0]]=true;\n        for(int i=1;i<n;i++){\n            for(int j=0;j<=t;j++){\n                if(dp[i-1][j])dp[i][j]=true;\n                else if(j>=a[i]){\n                    dp[i][j]=dp[i-1][j-a[i]];\n                }\n            }\n        }\n        for(int i=0;i<n;i++){\n            if(dp[i][t]){\n                return i+1;\n            }\n        }\n        return INF;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n=q.size(),m=nums.size();\n        vector<vector<int>> a(m,vector<int>(n,0));\n        for(int i=0;i<n;i++){\n            for(int j=q[i][0];j<=q[i][1];j++){\n                a[j][i]=q[i][2];\n            }\n        }\n        vector<int> ans;\n        for(int i=0;i<m;i++){\n            ans.push_back(f(a[i],nums[i]));\n        }\n        int ans0=*max_element(ans.begin(),ans.end());\n        return ans0==INF?-1:ans0;\n    }\n};","author":"Romantic I3assiw5k","submissionId":"611250360"},[]]},{"1874":[{"id":"1874","fileName":"611250176.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n=len(nums)\n        m=len(queries)\n        q=[[] for _ in range(n)]\n        for j,(l,r,val) in enumerate(queries):\n            for i in range(l,r+1):\n                if 0<=i<n:\n                    q[i].append((j,val))\n        d=[inf]*n\n        for i in range(n):\n            x=nums[i]\n            if x==0:\n                d[i]=-1\n                continue\n            h=q[i]\n            if not h:\n                return -1\n            dp={0:-1}\n            for j,val in h:\n                cur=dict(dp)\n                for s,mx in cur.items():\n                    nsum=s+val\n                    if nsum>x:\n                        continue\n                    nmx=max(mx,j)\n                    if nsum not in dp or dp[nsum]>nmx:\n                        dp[nsum]=nmx\n            if x in dp:\n                d[i]=dp[x]\n        return max(d)+1 if max(d)<inf else -1","author":"Alx","submissionId":"611250176"},[]]},{"1875":[{"id":"1875","fileName":"611250401.txt","sourceCode":"int const N=1e3+7;\nint f[11][N];\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n=nums.size();\n        int s=0;\n        for(int x:nums) s+=x;\n        if(s==0)    return 0;\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<=nums[i];j++) f[i][j]=0;\n        }\n        for(int i=0;i<n;i++) f[i][0]=1;\n        \n        \n        for(int k=0;k<q.size();k++){\n            int l=q[k][0],r=q[k][1],val=q[k][2];\n            for(int i=l;i<=r;i++){\n                for(int j=nums[i];j>=val;j--){\n                    f[i][j]|=f[i][j-val];\n                }\n            }\n            \n            int ok=1;\n            for(int i=0;i<n;i++){\n                if(f[i][nums[i]]==0) ok=0;\n            }\n            if(ok){\n                return k+1;\n            }\n        }\n        \n        return -1;\n    }\n};","author":"hover","submissionId":"611250401"},[]]},{"1876":[{"id":"1876","fileName":"611250544.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        \n        int res = 0;\n        int l = nums.size();\n        vector<int>cnts(l);\n        int flag = 0;\n        for(int it:nums){\n            if(it != 0) flag = 1;\n        }\n        if(flag == 0) return 0;\n        \n        for(int i=0;i<l;i++){\n            int cnt = getcnt(queries, nums[i] , i);\n            if(cnt== -1) return -1;\n            res = max(res, cnt);\n        }\n        return res;\n    }\n    int getcnt(vector<vector<int>>&queries, int target, int site){\n        vector<int>dp(target + 1);\n        dp[0] = 1;\n        int cnt = 0;\n        for(auto query : queries){\n            cnt++;\n            if(site >= query[0] && site <= query[1]){//\n                for(int i=target; i>=0;i--){\n                    if(i - query[2] >= 0 && dp[i - query[2]] == 1){\n                        dp[i] = 1;\n                    }\n                }\n            }\n            if(dp[target] == 1) return cnt;\n        }\n        return -1;\n    }\n};","author":"如果","submissionId":"611250544"},[]]},{"1877":[{"id":"1877","fileName":"611250535.txt","sourceCode":"func minZeroArray(nums []int, queries [][]int) int {\n    n := len(queries)\n    k := 0\n    for i, c := range nums {\n        if c == 0 {\n            continue\n        }\n        tmp := make(map[int]int)\n        tmp[0] = 1\n        cached := false\n        for idx := 0; idx < n; idx++ {\n            if i < queries[idx][0] || i > queries[idx][1] {\n                continue\n            }\n            if _, ok := tmp[c-queries[idx][2]]; ok {\n                cached = true\n                k = max(k, idx+1)\n                break\n            }\n            cc := make(map[int]int)\n            for v, _ := range tmp {\n                cc[v] = 1\n                if v+queries[idx][2] <= c {\n                    cc[v+queries[idx][2]] = 1\n                }\n            }\n            tmp = cc\n        }\n        if !cached {\n            return -1\n        }\n    }\n\n    return k\n}","author":"IPRintf","submissionId":"611250535"},[]]},{"1878":[{"id":"1878","fileName":"611250396.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if sum(nums) == 0:\n            return 0\n        n = len(nums)\n        ans = -1\n        for i,s in enumerate(nums):\n            if s == 0:\n                ans = max(ans, 0)\n                continue\n            f = [1]+[0]*s\n            for k,(l,r,v) in enumerate(queries,start=1):\n                if l<=i<=r:\n                    for j in range(s,v-1,-1):\n                        f[j] |= f[j-v]\n                    if f[s]:\n                        ans = max(ans, k)\n                        break\n            if not f[s]:\n                return -1\n        return ans","author":"陆鸢","submissionId":"611250396"},[]]},{"1879":[{"id":"1879","fileName":"611250550.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<pair<int,int>>>v(n);\n        for(int qi = 0;qi<queries.size();++qi)\n            {\n                auto q = queries[qi];\n                int l = q[0] , r = q[1] , val = q[2];\n                for(int i=l;i<=r;++i)\n                    {\n                        v[i].emplace_back(val,qi);\n                    }\n            }\n        int res = 0;\n\n        for(int i = 0;i<n;++i)\n            {\n                if(nums[i]==0) continue;\n                set<int>s;\n                s.emplace(0);\n                bool flag = false;\n                unordered_set<int>tmp;\n                for(auto &p:v[i])\n                    {\n                        for(const int &n:s)\n                            {\n                                if(n+p.first==nums[i])\n                                {\n                                    res = max(res,p.second+1);\n                                    flag = true;\n                                    break;\n                                }\n                                else if(n+p.first<nums[i])\n                                {\n                                    tmp.emplace(n+p.first);\n                                }\n                            }\n                        for(const int &n:tmp)\n                            {\n                                s.emplace(n);\n                            }\n                        if(flag)break;\n                    }\n                if(!flag)\n                {\n                    return -1;\n                }\n            }\n        return res;\n    }\n};","author":"Mafa","submissionId":"611250550"},[]]},{"1880":[{"id":"1880","fileName":"611250754.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n=nums.length,count_zero=0;\n        HashSet<Integer>[] sarray = new HashSet[n];\n        for(int i=0;i<n;++i){\n            sarray[i] = new HashSet<>();\n            sarray[i].add(nums[i]);\n            if(nums[i]==0)++count_zero;\n        }\n        if(count_zero==n)return 0;\n        for(int q=0;q<queries.length;++q){\n            for(int i=queries[q][0];i<=queries[q][1];++i){\n                if(!sarray[i].contains(0)){\n                    if(sarray[i].contains(queries[q][2])){\n                        sarray[i].add(0);\n                        ++count_zero;\n                        if(count_zero==n)return q+1;\n                    }else{\n                        List<Integer> l = new ArrayList<>(sarray[i]);\n                        for(Integer j:l){\n                            if(j-queries[q][2]>0)sarray[i].add(j-queries[q][2]);\n                        }\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}","author":"delideliBird","submissionId":"611250754"},[]]},{"1881":[{"id":"1881","fileName":"611250732.txt","sourceCode":"func minZeroArray(nums []int, queries [][]int) int {\n    n,m := len(nums),len(queries)\n\n    ans := 0\n    \n    need := make([]int,n)\n    for i:=0; i<n; i++ {\n        need[i] = m+1\n        num := nums[i]\n\n        f := make([][]bool,m+1)\n        for j:=0; j<=m; j++ {\n            f[j] = make([]bool,num+1)\n        }\n        f[0][0] = true\n\n        if num != 0 {\n            for j:=1; j<=m; j++ {\n                l,r,val := queries[j-1][0],queries[j-1][1],queries[j-1][2]\n                for k:=0; k<=num; k++ {\n                    f[j][k] = f[j][k] || f[j-1][k]\n                    if l<=i && i<=r && k>=val {\n                        f[j][k] = f[j][k] || f[j-1][k-val]\n                    }\n                }\n                if f[j][num] {\n                    need[i] = j\n                    break\n                }\n            }   \n        } else {\n            need[i] = 0\n        }\n\n        // fmt.Println(num,need[i])\n        \n        if need[i] > m {\n            return -1\n        } else {\n            ans = max(ans,need[i])\n        }\n    }\n\n    return ans\n}","author":"归来还当保安","submissionId":"611250732"},[]]},{"1882":[{"id":"1882","fileName":"611250839.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = queries.length;\n        int left = 0, right = n + 1;\n        while (left < right) {\n            int mid = (right - left) / 2 + left;\n            if (check(nums, queries, mid)) right = mid;\n            else left = mid + 1;\n        }\n        return right > n ? -1 : right;\n    }\n\n    public boolean check(int[] nums, int[][] queries, int k) {\n        int n = nums.length;\n        List<Integer>[] add = new ArrayList[n];\n        List<Integer>[] sub = new ArrayList[n];\n        Arrays.setAll(add, i -> new ArrayList<>());\n        Arrays.setAll(sub, i -> new ArrayList<>());\n        for (int i = 0; i < k; i++) {\n            int l = queries[i][0], r = queries[i][1];\n            add[l].add(queries[i][2]);\n            if (r + 1 < n) sub[r + 1].add(queries[i][2]);\n        }\n        Map<Integer, Integer> cnt = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            for (Integer x : add[i]) {\n                cnt.merge(x, 1, Integer::sum);\n            }\n            for (Integer x : sub[i]) {\n                cnt.merge(x, -1, Integer::sum);\n            }\n            boolean[] dp = new boolean[1001];\n            dp[0] = true;\n            for (Map.Entry<Integer, Integer> e : cnt.entrySet()) {\n                int x = e.getKey(), c = e.getValue();\n                for (int j = 0; j < c; j++) {\n                    for (int v = 1000; v >= 0; v--) {\n                        if (v + x <= 1000) dp[v + x] |= dp[v];\n                    }\n                }\n            }\n            if (!dp[nums[i]]) return false;\n        }\n        return true;\n    }\n}","author":"Mojo","submissionId":"611250839"},[]]},{"1883":[{"id":"1883","fileName":"611251084.txt","sourceCode":"class Solution {\npublic:\n    int tmp[1010],dp[1001];\n    bool check(vector<int>& a, vector<vector<int>>&q, int k) {\n        // O(10 * 10 * )\n        for(int ii = 0; ii < a.size(); ii++) {\n            int x = a[ii];\n            int cnt = 0;\n            for(int j = 0; j < k; j++) {\n                if(q[j][0] <= ii && q[j][1] >= ii) {\n                    tmp[++cnt] = q[j][2];\n                }\n            }\n            // cout << \"x = \" << x << endl;\n            memset(dp, -1, sizeof dp);\n            dp[0] = 0;\n            for(int i = 1; i <= cnt; i++) {\n                // cout<<\"from\";\n                // for(int o = 0; o <= x; o++) {\n                //     printf(\"(%d,%d) \",o,dp[o]);\n                // }cout<<endl;\n                for(int j = x; j >= tmp[i]; j--) {\n                    if(dp[j - tmp[i]] == 0) {\n                        dp[j] = 0;\n                    }\n                }\n                // cout<<\"to\";for(int o = 0; o <= x; o++) {\n                //     printf(\"(%d,%d) \",o,dp[o]);\n                // }cout<<endl;\n            }\n            // for(int i = 1; i <= cnt; i++) {\n            //     cout << tmp[i] << \" \";\n            // }cout<<endl;\n            \n            // cout << endl;\n            if(dp[x] == -1) return false;\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int l = 0, r = queries.size(), ans = -1;\n        // l = r;\n        while(l <= r) {\n            int mid = l + r >> 1;\n            if(check(nums, queries, mid)) {\n                r = mid - 1;\n                ans = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"acception","submissionId":"611251084"},[]]},{"1884":[{"id":"1884","fileName":"611250621.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size();\n        int f = 1;\n        for (int x : a) {\n            if (x != 0) {\n                f = 0;\n            }\n        }\n        if (f) return 0;\n\n        vector<bitset<1010>> dp(n);\n        for (int i = 0; i < n; i ++) {\n            dp[i].reset();\n            dp[i][0] = true;\n        }\n        \n        int m = q.size();\n        for (int i = 0; i < m; i ++) {\n            int l = q[i][0], r = q[i][1], val = q[i][2];\n            for (int j = l; j <= r; j ++) {\n                dp[j] |= (dp[j] << val);\n            }\n            int f = 1;\n            for (int j = 0; j < n; j ++) {\n                // cout << dp[j].test(a[j]) << ' ';\n                if (!dp[j].test(a[j])) {\n                    f = 0;\n                    break;\n                }\n            }\n            if (f) return i + 1;\n        }\n        \n        return -1;\n    }\n};\n","author":"surpass-w","submissionId":"611250621"},[]]},{"1885":[{"id":"1885","fileName":"611251136.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<bool> > dp(n, vector<bool>(1050));\n        for(int i=0; i<n; i++)\n            dp[i][0]=true;\n\n        bool allZero = true;\n        for(int ele: nums)\n            allZero = allZero &&(ele==0);\n        if(allZero)\n            return 0;\n\n        for(int i=0;i<queries.size(); i++){\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n\n            for(int j=l; j<=r; j++)\n                for(int k = 1000; k>=val; k--)\n                    dp[j][k] = dp[j][k] || dp[j][k-val];\n\n            bool flag = true;\n            for(int j=0; j<n; j++)\n                flag = flag && dp[j][nums[j]];\n\n            if(flag)\n                return i+1;\n        }\n\n        return -1;\n    }\n};","author":"pointedpoints","submissionId":"611251136"},[]]},{"1886":[{"id":"1886","fileName":"611251294.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& n, vector<vector<int>>& q) {\n        vector<unordered_map<int,bool>>v(n.size());\n        int sum=0;\n        for(auto x:n) {\n            sum+=x;\n        }\n        if(sum==0) return 0;\n        for(int i=0;i<n.size();i++) v[i][0]=true;\n        int ans=0;\n        for(auto& x:q) {\n            for(int i=x[0];i<=x[1];i++) {\n                for(int j=1000;j>=x[2];j--) {\n                    if(v[i][j-x[2]]) v[i][j]=true;\n                }\n            }\n            ans++;\n            bool f=true;\n            for(int i=0;i<n.size();i++) {\n                if(!v[i][n[i]]) f=false;\n            }\n            if(f) return ans;\n        }\n        return -1;\n    }\n};","author":"Kwords","submissionId":"611251294"},[]]},{"1887":[{"id":"1887","fileName":"611251405.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if max(nums)==0:\n            return 0\n        dp = [[True]+[False]*(i) for i in nums]\n        ans = 1\n        for l,r,v in queries:\n            cnt = 0\n            for i,k in enumerate(nums):\n                if l<=i<=r:\n                    for j in range(k,v-1,-1):\n                        dp[i][j] = dp[i][j] or dp[i][j-v]\n                if dp[i][k] :\n                    cnt += 1\n            if cnt == len(nums):\n                return ans\n            ans +=1\n        return -1\n                        ","author":"NCU_jack","submissionId":"611251405"},[]]},{"1888":[{"id":"1888","fileName":"611251389.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        q = len(queries)\n        m = max(nums) + 1\n        dp = [[-1] * m for _ in range(n)]\n        ans = 0\n        for i in range(n):\n            dp[i][nums[i]] = 0\n            for j in range(q):\n                l, r, val = queries[j]\n                if l <= i <= r:\n                    for k in range(nums[i]):\n                        if k + val <= nums[i] and dp[i][k + val] != -1:\n                            dp[i][k] = j + 1\n                if dp[i][0] != -1:\n                    break\n            if dp[i][0] == -1:\n                ans = -1\n                break\n            else:\n                ans = max(ans, dp[i][0])\n\n        return ans","author":"skdky","submissionId":"611251389"},[]]},{"1889":[{"id":"1889","fileName":"611251576.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        res = []\n        for i in range(n):\n            if nums[i] == 0:\n                res.append(0)\n                continue\n                \n            cover_q = []\n            for ind,(l,r,val) in enumerate(queries):\n                if l<= i <= r:\n                    cover_q.append((ind,val))\n\n            dp = {0:-1}\n            for ind,val in cover_q:\n                dp_new = {}\n                for s in dp.keys():\n                    current = dp[s]\n                    s_new = s+ val\n                    if s_new > nums[i]:\n                        continue\n                    new_c = max(current,ind)\n                    if (s_new not in dp_new) or new_c < dp_new[s_new]:\n                        dp_new[s_new] = new_c\n\n                for s in dp_new.keys():\n                    if (s not in dp) or dp_new[s] < dp.get(s,float('inf')):\n                        dp[s] = dp_new[s]\n\n            if nums[i] not in dp:\n                return -1\n            res.append(dp[nums[i]] + 1)\n        return max(res)\n\n                ","author":"|_・)","submissionId":"611251576"},[]]},{"1890":[{"id":"1890","fileName":"611250691.txt","sourceCode":"impl Solution {\n    pub fn min_zero_array(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> i32 {\n        if nums.iter().any(|&x| x < 0) {\n            return -1;\n        }\n\n        let n = nums.len();\n\n        let mut elem_ops = vec![vec![]; n];\n\n        for (j, q) in queries.iter().enumerate() {\n            let l = q[0] as usize;\n            let r = q[1] as usize;\n            let val = q[2];\n            for i in l..=r {\n                elem_ops[i].push((j, val));\n            }\n        }\n\n        let mut max_k = -1;\n\n        for (i, &target) in nums.iter().enumerate() {\n            if target == 0 {\n                continue;\n            }\n\n            let mut dp = std::collections::HashMap::new();\n            dp.insert(0, -1);\n            let mut min_k = i32::MAX;\n\n            for &(j, val) in &elem_ops[i] {\n                let current_j = j as i32;\n                let current_val = val;\n\n                // 克隆当前状态以避免迭代中修改\n                let keys: Vec<_> = dp.keys().cloned().collect();\n\n                for sum in keys {\n                    let new_sum = sum + current_val;\n                    let new_max = dp[&sum].max(current_j);\n\n                    // 更新最小值\n                    if new_sum == target {\n                        min_k = min_k.min(new_max);\n                    }\n\n                    dp.entry(new_sum).and_modify(|e| *e = (*e).min(new_max)).or_insert(new_max);\n                }\n            }\n\n            if !dp.contains_key(&target) {\n                return -1;\n            }\n\n            max_k = max_k.max(min_k);\n        }\n\n        if max_k == -1 {\n            0\n        } else {\n            max_k + 1\n        }\n    }\n}","author":"夏侯","submissionId":"611250691"},[]]},{"1891":[{"id":"1891","fileName":"611251670.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n        int mx = 0;\n        for(auto i: nums) {\n            mx = max(mx, i);\n        }\n        if(mx == 0) return 0;\n        vector<vector<int>> g(n+5);\n        vector<int> sum(n+5, 0);\n        auto check = [&](int x) -> bool{\n            for(int i = 0; i < n; i++) {\n                if(sum[i] < nums[i]) return 0;\n                vector<bool> v(nums[i]+5, 0);\n                v[0] = 1;\n                for(auto j: g[i]) {\n                    for(int k = nums[i]; k >= 0; k--) {\n                        if(k >= j) v[k] = v[k - j] | v[k];\n                    }\n                }\n                if(!v[nums[i]]) return 0;\n            }\n            return 1;\n        };\n        for(int i = 0; i < q.size(); i++) {\n            int l = q[i][0], r = q[i][1], val = q[i][2];\n            for(int j = l; j <= r; j++) {\n                g[j].push_back(val);\n                sum[j] += val;\n            }\n            if(check(i)) {\n                return i + 1;\n            } \n        }\n        return -1;\n    }\n};","author":"lin1314_fan","submissionId":"611251670"},[]]},{"1892":[{"id":"1892","fileName":"611251684.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int tmp=-1;\n        for(int i=0;i<nums.size();i++){\n            auto s=visit(queries,i,nums[i]);\n            if(s<0){\n                return -1;\n            }else{\n                tmp=max(tmp,s);\n            }\n        }\n        return tmp;\n    }\n\n    int visit(vector<vector<int>>& queries,int p,int v){\n        if(v==0){\n            return 0;\n        }\n        unordered_set<int> st;\n        st.insert(0);\n        for(int i=0;i<queries.size();i++){\n            auto &q=queries[i];\n            if(q[0]<=p&&p<=q[1]){\n                vector<int> tmp;\n                auto it=st.begin();\n                while(it!=st.end()){\n                    int a=*it+q[2];\n                    if(a==v){\n                        return i+1;\n                    }else{\n                        tmp.push_back(a);\n                    }\n                    it++;\n                }\n                for(auto num:tmp){\n                    st.insert(num);\n                }\n            }\n            \n        }\n        return -1;\n    }\n};","author":"apocalypse","submissionId":"611251684"},[]]},{"1893":[{"id":"1893","fileName":"611251376.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size(), m = q.size();\n        bool flag = true;\n        for (int i = 0; i < n; i++) \n            if (nums[i]) {\n                flag = false;\n                break;\n            }\n        if (flag) return 0;\n        vector<int> ans(n, -1);\n        for (int i = 0; i < n; i++) {\n            vector<int> dp(1005, 0); // dp[j]表示当前能不能拼成j\n            dp[0] = 1;\n            for (int j = 0; j < m; j++) {\n                if (q[j][0] <= i && q[j][1] >= i) {\n                    int val = q[j][2];\n                    for (int k = 1000; k >= val; k--) {\n                        dp[k] |= dp[k - val];\n                    }\n                }\n                if (dp[nums[i]]) {\n                    ans[i] = j + 1;\n                    break;\n                } \n            }\n        }\n        int res = 0;\n        for (auto v : ans) {\n            if (v == -1) {\n                res = -1;\n                break;\n            }\n            res = max(res, v);\n        }\n        return res;\n    }\n};","author":"猎捕一切优质河狸","submissionId":"611251376"},[]]},{"1894":[{"id":"1894","fileName":"611251108.txt","sourceCode":"#include <vector>\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = -1;\n        for (int i = 0; i < nums.size(); i++) {\n            vector<bool> dp(1001, 0);\n            int x = nums[i];\n            dp[x] = 1;\n\n            if (x == 0) {\n                ans = max(ans, 0);\n                continue;\n            }\n            for (int j = 0; j < queries.size(); j++) {\n                int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                if (i < l || i > r) continue;\n                for (int k = val; k <= x; k++) {\n                    if (dp[k]) {\n                        dp[k - val] = 1;\n                    }\n                }\n                if (dp[0]) {\n                    ans = max(ans, j + 1);\n                    break;\n                }\n            }\n\n            if (!dp[0]) {\n                return -1;\n            }\n        } return ans;\n    }\n};\n\n// int main() {\n//     Solution s;\n//     vector<int> nums = {2, 0, 2};\n//     vector<vector<int>> queries = {{0, 2, 1}, {0, 2, 1}};\n//     cout << s.minZeroArray(nums, queries) << endl;\n//     return 0;\n// }","author":"译言丁真","submissionId":"611251108"},[]]},{"1895":[{"id":"1895","fileName":"611252261.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int[][] dp = new int[n][2001];\n\n        for (int[] ints : dp) {\n            Arrays.fill(ints, -1);\n        }\n\n        int cnt = 0;\n        for (int i = 0; i < n; ++ i) {\n            dp[i][0] = 1;\n            if (nums[i] == 0) {\n                cnt ++;\n            }\n        }\n\n        if (cnt == n) {\n            return 0;\n        }\n        for (int i = 0; i < queries.length; ++ i) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n\n            for (int j = l; j <= r; ++ j) {\n                int top = nums[j];\n                if (dp[j][top] == 1) {\n                    continue;\n                }\n\n                for (int k = top; k >= val; -- k) {\n                    if (dp[j][k - val] > 0) {\n                        dp[j][k] = dp[j][k - val];\n                    }\n                }\n\n                if (dp[j][top] == 1) {\n                    cnt ++;\n                }\n                if (cnt == n) {\n                    return i + 1;\n                }\n            }\n        }\n\n        return -1;\n    }\n}","author":"造假不好","submissionId":"611252261"},[]]},{"1896":[{"id":"1896","fileName":"611251765.txt","sourceCode":"class Solution {\n     public int minZeroArray(int[] nums, int[][] queries) {\n        int ans = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int computer = computer(queries, nums, i);\n            if (computer == -1) return -1;\n            ans = Math.max(ans, computer);\n        }\n        return ans ;\n    }\n\n    public int computer(int[][] queries, int[] nums, int j) {\n        int n = queries.length;\n        boolean[] dp = new boolean[nums[j] + 1];\n        dp[0] = true;\n        if (dp[nums[j]]) return 0;\n        for (int i = 0; i < n; i++) {\n            if (queries[i][0] <= j && j <= queries[i][1]) {\n                for (int k = nums[j]; k >= queries[i][2]; k--) {\n                    dp[k] |= dp[k - queries[i][2]];\n                }\n            }\n            if (dp[nums[j]]) return i+1;\n        }\n        return -1;\n    }\n}","author":"风铃","submissionId":"611251765"},[]]},{"1897":[{"id":"1897","fileName":"611251802.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size(), m = q.size(), ans = -1;\n        for (int i = 0; i < n; i++) {\n            if (a[i] == 0) {\n                ans = max(ans, 0);\n                continue;\n            }\n            vector<int> b;\n            for (int j = 0; j < m; j++) {\n                int l = q[j][0], r = q[j][1], v = q[j][2];\n                if (l <= i && i <= r) b.push_back(j); \n            }\n            int sz = b.size();\n            // cout << \"i= \" << i << \", sz= \" << sz << 'n';\n            vector<int> f(a[i] + 1, 0);\n            f[0] = 1;\n            for (int j = 0; j < sz; j++) {\n                for (int k = a[i]; k >= q[b[j]][2]; k--) f[k] |= f[k - q[b[j]][2]]; \n                if (f[a[i]]) {\n                    ans = max(ans, b[j] + 1);\n                    break;\n                }\n            }\n            if (!f[a[i]]) {\n                ans = -1;\n                break;\n            }\n            // for (int j = 0; j <= a[i]; j++) cout << f[j] << \" n\"[j == a[i]];\n            // cout << \"i= \" << i << \", ans= \" << ans << 'n';\n        }\n        // cout << \"ans= \" << ans << 'n';\n        return ans;\n    }\n};","author":"liang sheng","submissionId":"611251802"},[]]},{"1898":[{"id":"1898","fileName":"611251905.txt","sourceCode":"class Solution\n{\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries)\n    {\n        if (all_of(nums.begin(), nums.end(), [](int num)\n        {\n            return num == 0;\n        }))\n        {\n            return 0;\n        }\n        int n = nums.size();\n        int ans = -1;\n\n        for (int i = 0; i < n; i++)\n        {\n            int target = nums[i];\n            if (target == 0)\n            {\n                continue;\n            }\n\n            vector<int> covers;\n            for (int j = 0; j < queries.size(); j++)\n            {\n                int li = queries[j][0];\n                int ri = queries[j][1];\n                if (li <= i && i <= ri)\n                {\n                    covers.push_back(j);\n                }\n            }\n\n            vector<int> dp(target + 1, INT_MAX);\n            dp[0] = -1;\n\n            for (int j: covers)\n            {\n                int val = queries[j][2];\n                for (int s = target; s >= 0; --s)\n                {\n                    if (dp[s] != INT_MAX)\n                    {\n                        int new_s = s + val;\n                        if (new_s > target) continue;\n                        int new_max = max(dp[s], j);\n                        if (new_max < dp[new_s])\n                        {\n                            dp[new_s] = new_max;\n                        }\n                    }\n                }\n            }\n\n            if (dp[target] == INT_MAX)\n            {\n                return -1;\n            }\n            ans = max(ans, dp[target]);\n        }\n        return ans == -1 ? 0 : ans + 1;\n    }\n};","author":"maruser","submissionId":"611251905"},[]]},{"1899":[{"id":"1899","fileName":"611252355.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = 0;\n        for (int i = 0;i<nums.size();i++){\n            if (nums[i] == 0) continue;\n            vector<int> dp(nums[i] + 1,2000);\n            dp[nums[i]] = 0;\n            for (int j = 0;j<queries.size();j++){\n                if (queries[j][0] <= i && i <= queries[j][1]){\n                    for (int k = queries[j][2];k<=nums[i];k++){\n                        dp[k - queries[j][2]] = min(dp[k - queries[j][2]],dp[k] + 1);\n                    }\n                }\n\n                if (dp[0] < 2000){\n                    ans = max(ans,j + 1);\n                    break;\n                }\n            }\n\n            if (dp[0] >= 2000){\n                return -1;\n            }\n        }\n\n\n        return ans;\n    }\n};","author":"羧基碱","submissionId":"611252355"},[]]},{"1900":[{"id":"1900","fileName":"611252357.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& qs) {\n        int n = nums.size();\n\n        int ma = 0;\n        for (int i = 0; i < n; ++ i){\n            int m = nums[i];\n            if (m == 0) continue;\n            \n            vector<array<int,2>> U;\n            for (int j = 0; j < qs.size(); ++ j){\n                if (i >= qs[j][0] && i <= qs[j][1]){\n                    U.push_back({qs[j][2], j+1});\n                }\n            }\n            vector <int> f(m+1);\n            f[0] = 1;\n            int cur = 0;\n            for (auto &[val, j] : U){\n                for (int j = m; j >= val; -- j){\n                    if (f[j-val]){\n                        f[j] = 1;\n                    }\n                }\n                cur = j;\n                if (f[m]) break;\n            }\n            if (!f[m]) return -1;\n\n            ma = max(ma, cur);\n        }\n\n        return ma;\n    }\n};","author":"lambour","submissionId":"611252357"},[]]},{"1901":[{"id":"1901","fileName":"611252364.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int mx = 0;\n        for (int x : nums) {\n            mx = Math.max(mx, x);\n        }\n        if (mx == 0) return 0;\n        boolean[][] f = new boolean[n][mx + 1];\n        for (boolean[] arr : f) {\n            arr[0] = true;\n        }\n        int last = 0;\n        int k = 0;\n        for (int[] query : queries) {\n            k++;\n            int l = query[0], r = query[1], v = query[2];\n            for (int i = l; i <= r; i++) {\n                if (f[i][nums[i]]) continue;\n                for (int j = nums[i]; j >= v; j--) {\n                    f[i][j] = f[i][j] || f[i][j - v];\n                }\n            }\n            while (last < n && f[last][nums[last]]) {\n                last++;\n            }\n            if (last == n) {\n                return k;\n            }\n        }\n        return -1;\n    }\n}","author":"Funny Ben2Gom","submissionId":"611252364"},[]]},{"1902":[{"id":"1902","fileName":"611252776.txt","sourceCode":"class Solution {\npublic:\n    int f[1003];\n    int F(int p, int v, vector<vector<int>>& qr) {\n        if(!v) return 0;\n        memset(f, 0, sizeof f);\n        f[0] = 1;\n        for(int i = 0; i < qr.size(); ++i) {\n            int l = qr[i][0], r = qr[i][1], t = qr[i][2];\n            if(l <= p && p <= r) {\n                for(int j = v; j >= t; --j)\n                    f[j] |= f[j - t];\n            }\n            if(f[v]) return i + 1;\n        } return INT_MAX;\n    }\n    int minZeroArray(vector<int>& a, vector<vector<int>>& qr) {\n        int res = 0;\n        for(int i = 0; i < a.size(); ++i) res = max(res, F(i, a[i], qr));\n        return res == INT_MAX ? -1 : res;\n    }\n};","author":"0xffffffff","submissionId":"611252776"},[]]},{"1903":[{"id":"1903","fileName":"611252393.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n,m = len(nums),len(queries)\n        g = [[] for _ in range(n)]\n        for i,(l,r,v) in enumerate(queries):\n            for j in range(l,r+1):\n                g[j].append((v,i))\n        ans = 0\n        for i,val in enumerate(nums):\n            if val == 0:\n                continue\n            f = [False]*(val+1)\n            f[0] = True\n            for j,(v,idx) in enumerate(g[i]):\n                for k in range(val,0,-1):\n                    if k < v:break\n                    f[k] = f[k-v] | f[k]\n                if f[val]:\n                    ans = max(ans,idx+1)\n                    break\n            else:\n                return -1\n        return ans","author":"我想要看你笑","submissionId":"611252393"},[]]},{"1904":[{"id":"1904","fileName":"611252530.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        ask = [0] * n\n        dp = [[False] * (nums[i]+1) for i in range(n)]\n        for i in range(n):\n            if nums[i] == 0:\n                ask[i] = 1\n            dp[i][0] = True\n        if sum(ask) == n:\n            return 0\n        \n        for ind, (l, r, val) in enumerate(queries):\n            for i in range(l, r+1):\n                mx = nums[i]\n                if ask[i]:\n                    continue\n                for j in range(mx, val-1, -1):\n                    if dp[i][j-val]:\n                        dp[i][j] = True\n                if dp[i][mx]:\n                    ask[i] = 1\n            if sum(ask) == n:\n                return ind+1\n        return -1","author":"shimmery_firefly","submissionId":"611252530"},[]]},{"1905":[{"id":"1905","fileName":"611252646.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if all(num == 0 for num in nums):\n            return 0\n\n        n = len(nums)\n        cover = [[] for _ in range(n)]\n\n        # 预处理每个元素被哪些查询覆盖，按查询顺序存储\n        for j in range(n):\n            for i, (l, r, val) in enumerate(queries):\n                if l <= j <= r:\n                    cover[j].append((i, val))\n\n        max_k = -1\n\n        for j in range(n):\n            target = nums[j]\n            if target == 0:\n                continue\n\n            dp = {0: -1}\n            for (i, val) in cover[j]:\n                tmp = {}\n                for s in list(dp.keys()):\n                    current_max = dp[s]\n                    new_s = s + val\n                    new_max = max(current_max, i)\n                    if new_s in tmp:\n                        if new_max < tmp[new_s]:\n                            tmp[new_s] = new_max\n                    else:\n                        tmp[new_s] = new_max\n\n                # 合并tmp到dp中\n                for s in tmp:\n                    if s in dp:\n                        if tmp[s] < dp[s]:\n                            dp[s] = tmp[s]\n                    else:\n                        dp[s] = tmp[s]\n\n            if target not in dp:\n                return -1\n            required_max = dp[target]\n            if required_max > max_k:\n                max_k = required_max\n\n        return max_k + 1 if max_k != -1 else -1","author":"黄XC","submissionId":"611252646"},[]]},{"1906":[{"id":"1906","fileName":"611253149.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<vector<int>> v(n);\n        for (int j = 0; j < m; ++j) {\n            int l = queries[j][0];\n            int r = queries[j][1];\n            for (int i = l; i <= r; ++i) {\n                v[i].push_back(j);\n            }\n        } \n        int max_k = 0;\n        for (int i = 0; i < n; ++i) {\n            int target = nums[i];\n            if (target == 0) continue;\n            vector<int> dp(target + 1, INT_MAX);\n            dp[0] = -1;   \n            for (int j : v[i]) {\n                int val = queries[j][2];\n                for (int s = target; s >= 0; --s) {\n                    if (dp[s] != INT_MAX) {\n                        int new_s = s + val;\n                        if (new_s > target) continue;\n                        int new_max = max(dp[s], j);\n                        if (new_max < dp[new_s]) {\n                            dp[new_s] = new_max;\n                        }\n                    }\n                }\n            }           \n            if (dp[target] == INT_MAX) {\n                return -1;\n            }\n            int k_i = dp[target] + 1; \n            max_k = max(max_k, k_i);\n        }        \n        return max_k;\n    }\n};","author":"Edward","submissionId":"611253149"},[]]},{"1907":[{"id":"1907","fileName":"611253116.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, m = len(nums), len(queries)\n    \n        klist = [0] * n\n        \n        for j in range(n):\n            if nums[j] == 0:\n                klist[j] = 0\n                continue\n            \n            target = nums[j]\n            dp = [False] * (target + 1)\n            dp[0] = True\n            klist[j] = -1\n    \n            for i in range(m):\n                l, r, val = queries[i]\n                if l <= j <= r:\n                    for s in range(target, val - 1, -1):\n                        if dp[s - val]:\n                            dp[s] = True\n                if dp[target]:\n                    klist[j] = i + 1\n                    break\n        \n        if any(val == -1 for val in klist):\n            return -1\n        return max(klist)","author":"fanxing","submissionId":"611253116"},[]]},{"1908":[{"id":"1908","fileName":"611253150.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        @cache\n        def dfs(idx, num, idy):\n            if num == 0:\n                return idy\n            if idy == n:\n                return n+1\n                \n            l, r, v = queries[idy]\n            res = n+1\n            if l <= idx <= r and num >= v:\n                res = dfs(idx, num-v, idy+1)\n                \n            res = min(res, dfs(idx, num, idy+1))\n            return res\n        \n        k = 0\n        n = len(queries)\n        for idx, num in enumerate(nums):\n            ans = dfs(idx, num, 0)\n            # print(idx, ans)\n            if ans == n+1:\n                return -1\n            k = max(k, ans)\n        return k","author":"Charming Jones0uZ","submissionId":"611253150"},[]]},{"1909":[{"id":"1909","fileName":"611252595.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        # 01\n        added = defaultdict(list)\n        for k_idx, query in enumerate(queries):\n            l, r, v = query\n            for i in range(l, r + 1):\n                added[i].append((v, k_idx + 1))\n        # print(added)\n        min_k = 0\n        for i, x in enumerate(nums):\n            if x == 0:\n                continue\n\n            arr = added[i]\n            n = len(arr)\n\n            @cache\n            def dfs(j, target):\n                if j > n - 1:\n                    return arr[j - 1][1] if target == 0 else inf\n                    \n                if target == 0:\n                    return arr[j - 1][1]\n\n                res = inf\n                if target >= arr[j][0]:\n                    res = min(res, dfs(j + 1, target - arr[j][0]))\n                res = min(res, dfs(j + 1, target))\n                \n                return res\n\n            mini = dfs(0, x)\n            # print(mini)\n            \n            dfs.cache_clear()\n            if mini == inf:\n                return -1\n            min_k = max(mini, min_k)\n            \n        return min_k","author":"硕风点点","submissionId":"611252595"},[]]},{"1910":[{"id":"1910","fileName":"611253218.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        if all(x == 0 for x in nums):\n            return 0\n        \n        q = [[] for _ in range(n)]\n        for i, (l, r, val) in enumerate(queries):\n            for j in range(l, r + 1):\n                if 0 <= j < n:\n                    q[j].append((i, val))\n        \n        \n        k = -1\n        for i in range(n):\n            target = nums[i]\n            if target == 0:\n                continue\n            ql = q[i]\n            if not ql:\n                return -1  \n            dp = {0: -1}\n            flag = False\n            cur = float('inf')\n            for (j, val) in ql:\n                tmp = {}\n                for s in list(dp.keys()):\n                    cur_mx = dp[s]\n                    n_s = s + val\n                    if n_s > target:\n                        continue\n                    n_mx = max(cur_mx, j)\n                    if n_s in tmp:\n                        if n_mx < tmp[n_s]:\n                            tmp[n_s] = n_mx\n                    else:\n                        tmp[n_s] = n_mx\n                for s in tmp:\n                    if s in dp:\n                        if tmp[s] < dp[s]:\n                            dp[s] = tmp[s]\n                    else:\n                        dp[s] = tmp[s]\n                if target in dp:\n                    cur = dp[target]\n                    flag = True\n                    break\n            if not flag and target in dp:\n                cur = dp[target]\n                flag = True\n            if not flag:\n                return -1\n            if cur > k:\n                k = cur\n        \n        return k + 1 if k != -1 else -1","author":"心，月","submissionId":"611253218"},[]]},{"1911":[{"id":"1911","fileName":"611253062.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int mx=0;\n        int flag=0;\n        for(int i=0;i<nums.size();i++){\n            bitset<1000005>bs;\n            bs.set(0);\n            if(nums[i]==0)continue;\n            for(int j=0;j<queries.size();j++){\n                if(queries[j][0]<=i&&queries[j][1]>=i){\n                    bs=bs|(bs<<queries[j][2]);\n                    if(bs.test(nums[i])){mx=max(j+1,mx);break;}\n                    }\n                if((!bs.test(nums[i]))&&j==(int)queries.size()-1){\n                        flag=1;\n                    break;\n                }\n            }\n            if(flag)mx=-1;\n        }\n        return mx;\n    }\n};","author":"Nostalgic I3oothXUN","submissionId":"611253062"},[]]},{"1912":[{"id":"1912","fileName":"611253286.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int ans = -1, n = q.size();\n        for (int i = 0; i < nums.size(); i++) {\n            set<int> set;\n            set.insert(0);\n            int step = 0;\n            if (nums[i] == 0) {\n                ans = max(ans, 0);\n                continue;\n            }\n            // cout << i << \" yes \" << endl;\n            for (int k = 0; k < n; k++) {\n                if (q[k][0] <= i && q[k][1] >= i) {\n                    vector<int> v;\n                    for (int x : set) {\n                        if (!set.count(x + q[k][2])) v.emplace_back(x + q[k][2]);\n                    }\n                    \n                    for (int x : v) {\n                        // cout << x << ' ';\n                        set.insert(x);\n                    }\n                    if (set.count(nums[i])) {\n                        step = k + 1;\n                        // cout << i << \" find \" << step << endl;\n                        break;\n                    }\n                }\n            }\n            if (step == 0) return -1;\n            ans = max(ans, step);\n        }\n        return ans;\n    }\n};","author":"tkw","submissionId":"611253286"},[]]},{"1913":[{"id":"1913","fileName":"611253220.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size(), m = q.size();\n        vector<map<int, int>> ma(n);\n        int cnt = 0;\n        vector<int> vis(n);\n        for (int i = 0; i < n; i++) {\n            ma[i][nums[i]] = 1;\n            if (nums[i] == 0) {\n                cnt++;\n                vis[i] = 1;\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            if (cnt == n) {\n                return i;\n            }\n            int l = q[i][0], r = q[i][1], val = q[i][2];\n            for (int j = l; j <= r; j++) {\n                if (vis[j])\n                    continue;\n                for (auto [x, y] : ma[j]) {\n                    if (x - val < 0)\n                        continue;\n                    //cout << x - val << 'n';\n                    ma[j][x - val] = 1;\n                    if (x - val == 0) {\n                        cnt++;\n                        vis[j] = 1;\n                        break;\n                    }\n                }\n            }\n        }\n        if (cnt == n) {\n            return m;\n        }\n        return -1;\n    }\n};","author":"Violet","submissionId":"611253220"},[]]},{"1914":[{"id":"1914","fileName":"611253329.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n       \n        \n        auto dfs = [&](this auto &&dfs, int index, int i, int num, vector<vector<int>> &f)->int{\n            if(num == 0){\n                return i;\n            }\n            if(num < 0  || i >= queries.size()){\n                return INT_MAX / 2;\n            }\n            int &x = f[i][num-1];\n            if(x != -1){\n                return x;\n            }\n            if(index < queries[i][0] || index > queries[i][1]){\n                return x = dfs(index, i+1, num, f);\n            }else{\n                return x = min(dfs(index,i+1,num, f), dfs(index,i+1,num-queries[i][2],f));    \n            }\n         \n        };\n        int ans = 0;\n        for(int i=0;i<nums.size();i++){\n            vector cache(1000, vector<int>(1000, -1));\n            ans = max(dfs(i, 0, nums[i],cache), ans);\n            if(ans > 1000){\n                return -1;\n            }\n        }\n        return ans >1000?-1:ans;    \n    }\n};","author":"阿白","submissionId":"611253329"},[]]},{"1915":[{"id":"1915","fileName":"611253552.txt","sourceCode":"class Solution {\npublic:\n  int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    int ret = -1, l = 0, r = queries.size();\n    while (l <= r) {\n      int mid = (l + r) >> 1;\n      if (check(nums, queries, mid)) {\n        ret = mid;\n        r = mid - 1;\n      }\n      else {\n        l = mid + 1;\n      }\n    }\n    return ret;\n  }\n\n  bool canFormSum(int target, vector<int>& nums) {\n    vector<bool> dp(target + 1, false);\n    dp[0] = true;\n    for (int num : nums) {\n      for (int j = target; j >= num; j--) {\n        if (dp[j - num]) {\n          dp[j] = true;\n        }\n      }\n    }\n    return dp[target];\n  }\n  bool check(vector<int>& nums, vector<vector<int>>& queries, int k) {\n    vector<vector<int>> hou(nums.size() + 1, vector<int>());\n    for (int i = 0; i < k; i++) {\n      auto q = queries[i];\n      for (int i = q[0]; i <= q[1]; i++) {\n        hou[i].push_back(q[2]);\n      }\n    }\n    for (int i = 0; i < nums.size(); i++) {\n      if (!canFormSum(nums[i], hou[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n};","author":"9caiji","submissionId":"611253552"},[]]},{"1916":[{"id":"1916","fileName":"611253713.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n,res,m=len(nums),0,len(queries)\n        def check(idx: int)->int:\n            i=0\n            se=set()\n            se.add(nums[idx])\n            while i<m:\n                if 0 in se:\n                    return i\n                if idx>=queries[i][0] and idx<=queries[i][1]:\n                    for val in se.copy():\n                        x=val-queries[i][2]\n                        if x>=0:\n                            se.add(x)\n                i+=1\n            if 0 in se:\n                return i\n            return -1\n        for i in range(n):\n            tar=check(i)\n            if tar<0:\n                return -1\n            res=max(tar,res)\n        return res","author":"Demon3","submissionId":"611253713"},[]]},{"1917":[{"id":"1917","fileName":"611253654.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length, m = queries.length;\n        int res = 0;\n        for (int k = 0; k < n; k++) {\n            int x = nums[k];\n            if (x == 0) {\n                continue;\n            }\n            boolean[] dp = new boolean[x + 1];\n            dp[x] = true;\n            for (int i = 0; i < m; i++) {\n                int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n                if (l > k || r < k || v > x) {\n                    continue;\n                }\n                for (int j = 0; j <= x; j++) {\n                    if (j + v <= x) {\n                        dp[j] = dp[j] || dp[j + v];\n                    }\n                }\n                if (dp[0]) {\n                    res = Math.max(res, i + 1);\n                    break;\n                }\n            }\n            if (!dp[0]) {\n                return -1;\n            }\n            // System.out.println(res);\n        }\n        return res;\n    }\n}","author":"秋心","submissionId":"611253654"},[]]},{"1918":[{"id":"1918","fileName":"611253376.txt","sourceCode":"class Solution {\npublic:\n  int minZeroArray(vector<int> &a, vector<vector<int>> &q) {\n    int n = a.size();\n    bool fl = true;\n    for (int i = 0; i < n; ++i) {\n      if (a[i] != 0) {\n        fl = false;\n        break;\n      }\n    }\n    if (fl) {\n      return 0;\n    }\n    vector<vector<int>> dp(n);\n    for (int i = 0; i < n; ++i) {\n      dp[i].resize(a[i] + 1);\n    }\n    for (int i = 0; i < q.size(); ++i) {\n      int l = q[i][0], r = q[i][1], x = q[i][2];\n      for (int j = l; j <= r; ++j) {\n        for (int k = a[j]; k >= x; --k) {\n          dp[j][k] = max(dp[j][k], dp[j][k - x] + x);\n        }\n      }\n      int fl = true;\n      for (int j = 0; j < n; ++j) {\n        cout << dp[j][a[j]] << ' ';\n        if (dp[j][a[j]] != a[j]) {\n          fl = false;\n          break;\n        }\n      }\n      cout << endl;\n      if (fl) {\n        return i + 1;\n      }\n    }\n    return -1;\n  }\n};\n","author":"lnkkerst","submissionId":"611253376"},[]]},{"1919":[{"id":"1919","fileName":"611253735.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int dp[11][1024] = {0};\n        for (int i = 0; i < n; i++) dp[i][0] = 1;\n\n        int matchNum = 0;\n        int matchFlag[11] = {0};\n        for (int i = 0; i < n; i++) if (nums[i] == 0) matchFlag[i] = 1, matchNum++;\n        if (matchNum == n) return 0;\n        for (int qid = 0; qid < queries.size(); qid++) {\n            auto &q = queries[qid];\n            int v = q[2];\n            for (int p = q[0]; p <= q[1]; p++) {\n                int nv = nums[p];\n                if (v > nv) continue;\n                if (matchFlag[p]) continue;\n                for (int i = nv; i >= v; i--) dp[p][i] |= dp[p][i - v];\n                if (dp[p][nv]) matchFlag[p] = 1, matchNum++;\n            }\n            if (matchNum == n) return qid + 1;\n        }\n        return -1;\n    }\n};","author":"ssayzx","submissionId":"611253735"},[]]},{"1920":[{"id":"1920","fileName":"611253948.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        const int n = nums.size();\n        const int m = queries.size();\n        vector<int> ans(n, m + 1);\n        int res = m + 1;\n        for(int i = 0; i < n; i ++ ) {\n            const int& num = nums[i];\n            bitset<1000 + 1> dp;\n            dp.set(num);\n            if(dp.test(0)) {\n                ans[i] = 0;\n                continue;\n            }\n            for(int j = 0; j < m; j ++ ) {\n                const int& l = queries[j][0];\n                const int& r = queries[j][1];\n                const int& val  = queries[j][2];\n                if(i < l || i > r) {\n                    continue;\n                }\n                dp = dp | (dp >> val);\n                if(dp.test(0)) {\n                    ans[i] = j + 1;\n                    break;\n                }\n            }\n        }\n        res = *max_element(ans.begin(), ans.end());\n        return res == m + 1 ? -1 : res;\n    }\n};","author":"latstars","submissionId":"611253948"},[]]},{"1921":[{"id":"1921","fileName":"611253915.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        a = nums.copy()\n        b = [[] for _ in nums]\n        for l, r, v in queries:\n            for i in range(l, r + 1):\n                a[i] -= v\n                b[i].append(v)\n            for i in chain(range(l), range(r + 1, n)):\n                b[i].append(0)\n        if any(x > 0 for x in a):\n            return -1\n\n        def f(a, v):\n            if v == 0:\n                return 0\n            s = {0}\n            for i, x in enumerate(a, 1):\n                if x == 0:\n                    continue\n                b = []\n                for y in s:\n                    y += x\n                    if y == v:\n                        return i\n                    if y < v:\n                        b.append(y)\n                s.update(b)\n            return len(queries) + 1\n        \n        t = max(f(a, v) for a, v in zip(b, nums))\n        return t if t <= len(queries) else -1","author":"lsf","submissionId":"611253915"},[]]},{"1922":[{"id":"1922","fileName":"611253292.txt","sourceCode":"import java.util.Arrays;\n\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        boolean[][]dp = new boolean[n][1001];\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        int c = 0;\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == 0) {\n                ++c;\n            }\n        }\n        if(c==n)return 0;\n        for (int i = 0; i < queries.length; i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int v = queries[i][2];\n\n            for(int j=l;j<=r;j++){\n                if(dp[j][nums[j]])continue;\n                for(int num=dp[j].length-1;num>=v;num--){\n                    if(dp[j][num-v]){\n                        dp[j][num] = true;\n                    }\n                }\n                if(dp[j][nums[j]])++c;\n            }\n\n            if(c==n)return i+1;\n\n        }\n\n        return -1;\n    }\n}","author":"nickname","submissionId":"611253292"},[]]},{"1923":[{"id":"1923","fileName":"611254006.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if not sum(nums):return 0\n        n=len(nums)\n        m=len(queries)\n        ans=0\n        for i,num in enumerate(nums):\n            dp=[True]+[False]*num\n            j=0\n            while j<m:\n                l,r,v=queries[j][0],queries[j][1],queries[j][2]\n                if l<=i<=r:\n                    for k in range(num,v-1,-1):\n                        dp[k]|=dp[k-v]\n                if dp[num]:break\n                j+=1\n            if j==m:return -1\n            ans=max(ans,j+1)\n        return ans\n                ","author":"Hyperalgebra","submissionId":"611254006"},[]]},{"1924":[{"id":"1924","fileName":"611253742.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& qu) {\n        int n = nums.size(),q = qu.size();\n        vector<vector<int>> idx(10);\n        vector<vector<int>> val(10);\n        for(int i=0;i<q;++i){\n            auto &t = qu[i];\n            for(int j=t[0];j<=t[1];++j){\n                idx[j].push_back(i);\n                val[j].push_back(t[2]);\n            }\n        }\n        int ans = -1;\n        for(int i=0;i<n;++i){\n            int target = nums[i];\n            bool dp[1010]{};\n            dp[0] = 1;\n            auto &arr = val[i];\n            int m = arr.size();\n            for(int j=0;j<m;++j){\n                if(arr[j]>target) continue;\n                if(dp[target-arr[j]]){\n                    dp[target] = 1;\n                    ans = max(ans,idx[i][j]);break;\n                }\n                for(int k=target-1;k>=arr[j];--k){\n                    if(dp[k-arr[j]]) dp[k] = 1;\n                }\n            }\n            if(!dp[target]) return -1;\n        }\n        return ans+1;\n    }\n};","author":"eleven-mile","submissionId":"611253742"},[]]},{"1925":[{"id":"1925","fileName":"611254079.txt","sourceCode":"class Solution {\npublic:\n    vector<int> G[12];\nint dp[2003];\n    bool check_(int s, int i){\n       for(int i = 0; i <= s; ++i){\n           dp[i] = 0;\n       }\n        dp[s] = 1;\n        for(auto x : G[i]){\n            for(int j = 0; j + x<= s; j++){\n                if(dp[j + x]){\n                    dp[j] = 1;\n                }\n            }\n        }\n        //cout << dp[0] <<\" \" << s << \" \" << i << \"n\";\n        return dp[0] == 1;\n    }\n    bool check(int mid, const vector<int>& nums, const vector<vector<int>>& queries){\n        for(int i = 0; i < nums.size(); ++i){\n            G[i].clear();\n        }\n        for(auto i = 0; i < mid; ++i){\n            const auto& v = queries[i];\n            for(auto j = v[0]; j <= v[1]; ++j){\n                G[j].emplace_back(v[2]);\n            }\n            \n        }\n        for(int i = 0; i < nums.size(); ++i){\n            \n                \n            if(!check_(nums[i], i)){\n                \n                //cout << i << \" \" << mid << \"n\";\n                return false;\n            }\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        bool flag = true;\n        for(auto x: nums){\n            if(x != 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            return 0;\n        }\n        int l = 1, r = queries.size();\n        while(l + 1 < r){\n            int mid = (l + r) >> 1;\n            if(check(mid, nums, queries)){\n                r = mid;\n            }else{\n                l = mid + 1;\n            }\n        }\n        //std::cout << l << \" \" << r << \"n\";\n        if(!check(r, nums, queries)){\n            \n            return -1;\n        }\n        if(check(l, nums, queries)){\n            return l;\n        }else{\n            return r;\n        }\n        \n    }\n};","author":"Monad","submissionId":"611254079"},[]]},{"1926":[{"id":"1926","fileName":"611254264.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ret = -1;\n        for(int i = 0; i < nums.size(); i++){\n            if(nums[i] == 0){\n                ret = max(ret, 0);\n                continue;\n            }\n            int j = 0;\n            unordered_map<int, int> hash;\n            hash[nums[i]] = 1;\n            for( ; j < queries.size(); j++){\n                int left = queries[j][0],\n                    right = queries[j][1],\n                    val = queries[j][2];\n                if(i < left || i > right) continue;\n                auto hash_tmp = hash;\n                for(auto& [e, v] : hash){\n                    if(e - val == 0){\n                        nums[i] = 0;\n                        j++;\n                        // cout << \"out \" << e << endl;\n                        break;\n                    }\n                    hash_tmp[e - val]++;\n                }\n                hash = hash_tmp;\n                // cout << \"j = \" << j << endl;\n                // for(auto [e, v] : hash) cout << e << ' ' << v << endl;\n                if(nums[i] == 0) break;\n            }\n            // cout << \"out j = \" << j << endl;\n            if(nums[i]) return -1;\n            ret = max(ret, j);\n        }\n        return ret;\n    }\n};","author":"夜泉","submissionId":"611254264"},[]]},{"1927":[{"id":"1927","fileName":"611254158.txt","sourceCode":"class Solution {\n\n    private int judge(int[] nums, int total) {\n        if (total == 0) {\n            return 0;\n        }\n        boolean[] dp = new boolean[total + 1];\n        dp[0] = true;\n        for (int i = 0;i < nums.length;i++) {\n            int x = nums[i];\n            if (x == -1) {\n                continue;\n            }\n            for (int j = dp.length - 1;j >= 0;j--) {\n                if (!dp[j]) {\n                    continue;\n                }\n                if (j + x >= dp.length) {\n                    continue;\n                }\n                dp[j + x] = true;\n            }\n            if (dp[dp.length - 1]) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int ret = 0;\n        for (int i = 0;i < nums.length;i++) {\n            int x = nums[i];\n            int[] data = new int[queries.length];\n            for (int j = 0;j < queries.length;j++) {\n                int[] query = queries[j];\n                if (query[0] <= i && i <= query[1]) {\n                    data[j] = query[2];\n                } else {\n                    data[j] = -1;\n                }\n            }\n            int temp = judge(data, x);\n            if (temp == -1) {\n                return -1;\n            }\n            ret = Math.max(ret, temp);\n        }\n        return ret;\n    }\n\n}","author":"小白二号","submissionId":"611254158"},[]]},{"1928":[{"id":"1928","fileName":"611254275.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def check(cnt2: int) -> bool:\n            cnt = [[] for _ in range(10)]\n            for i in range(cnt2):\n                l, r, val = queries[i]\n                for j in range(l, r + 1):\n                    cnt[j].append(val)\n            for row in cnt:\n                row.sort()\n                # f[i][j] represent first i-th val with j remain\n            for length in range(len(nums)):\n                cap = nums[length]\n                f = [[False] * (cap + 1) for _ in range(len(cnt[length]) + 1)]\n                for a in range(len(cnt[length]) + 1):\n                    f[a][0] = True\n                for a in range(len(cnt[length])):\n                    for b in range(cap + 1):\n                        f[a + 1][b] = f[a][b]\n                        if b >= cnt[length][a]:\n                            f[a + 1][b] |= f[a][b - cnt[length][a]]\n                if not f[-1][-1]: return False\n            return True\n        q = len(queries)\n        left, right = 0, q\n        ans = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if check(mid):\n                ans = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        return ans","author":"sdl","submissionId":"611254275"},[]]},{"1929":[{"id":"1929","fileName":"611254343.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& que) {\n        int n = nums.size(),m = que.size();\n        \n        auto check = [&](int i)->int{\n            int l=0,r=m;\n            while(l<=r){\n                int mid = (l+r)/2;\n                vector<vector<int>> f(mid+1,vector<int>(nums[i]+1));\n                f[0][0] = 1;\n                for(int j=1;j<=mid;++j){\n                    int jl = que[j-1][0],jr = que[j-1][1], jval = que[j-1][2];\n                    for(int v=0;v<=nums[i];++v){\n                        f[j][v] = f[j-1][v];\n                        if(i>=jl && i<=jr && v>=jval){\n                            f[j][v] = max(f[j][v],f[j-1][v-jval]);\n                        }\n                    }\n                }\n                if(f[mid][nums[i]]) r = mid - 1;\n                else l = mid + 1;\n            }\n            return l;\n        };\n\n        int ans = 0;\n        for(int i=0;i<n;++i){\n           ans = max(ans,check(i));\n        }\n        return ans == m+1 ? -1 : ans;\n    }\n};","author":"JoyHuan","submissionId":"611254343"},[]]},{"1930":[{"id":"1930","fileName":"611254635.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n    int q = queries.size();\n    vector<vector<pair<int, int>>> cover_queries(n); // 每个元素对应的查询列表，存储(查询索引，val)\n\n    // 预处理每个元素的覆盖查询\n    for (int j = 0; j < q; ++j) {\n        int l = queries[j][0];\n        int r = queries[j][1];\n        int val = queries[j][2];\n        // 遍历区间内的所有元素，添加查询\n        for (int i = l; i <= r; ++i) {\n            if (i >= 0 && i < n) {\n                cover_queries[i].emplace_back(j, val);\n            }\n        }\n    }\n\n    int max_x = -1;\n    for (int i = 0; i < n; ++i) {\n        int target = nums[i];\n        if (target == 0) {\n            continue; // 该元素不需要任何操作，不影响max_x\n        }\n\n        auto& cq = cover_queries[i];\n        long long sum_val = 0;\n        for (auto& p : cq) {\n            sum_val += p.second;\n        }\n        if (sum_val < target) {\n            return -1;\n        }\n\n        unordered_map<int, int> dp;\n        dp[0] = -1;\n        int x_i = INT_MAX;\n        bool found = false;\n\n        for (auto& p : cq) {\n            int j = p.first;\n            int val = p.second;\n\n            unordered_map<int, int> tmp;\n            // 先处理不选当前查询的情况\n            for (auto& entry : dp) {\n                int s = entry.first;\n                int current_max = entry.second;\n                if (tmp.find(s) == tmp.end() || current_max < tmp[s]) {\n                    tmp[s] = current_max;\n                }\n            }\n\n            // 处理选择当前查询的情况\n            for (auto& entry : dp) {\n                int s = entry.first;\n                int current_max = entry.second;\n                int new_s = s + val;\n                if (new_s > target) continue;\n                int new_max = max(current_max, j);\n                if (tmp.find(new_s) == tmp.end() || new_max < tmp[new_s]) {\n                    tmp[new_s] = new_max;\n                }\n            }\n\n            dp.swap(tmp);\n\n            if (dp.count(target)) {\n                if (dp[target] < x_i) {\n                    x_i = dp[target];\n                    found = true;\n                    break; // 后面的查询索引更大，无法得到更小的x_i\n                }\n            }\n        }\n\n        if (!found) {\n            if (dp.count(target)) {\n                x_i = dp[target];\n            } else {\n                return -1;\n            }\n        }\n\n        max_x = max(max_x, x_i);\n    }\n\n    // 处理所有元素都是0的情况\n    if (max_x == -1) {\n        for (int num : nums) {\n            if (num != 0) {\n                return -1;\n            }\n        }\n        return 0;\n    }\n\n    return max_x + 1;\n    }\n};","author":"Sheen","submissionId":"611254635"},[]]},{"1931":[{"id":"1931","fileName":"611254371.txt","sourceCode":"int minZeroArray(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize) {\n    int n = numsSize, m = queriesSize;\n    int k = 0;\n    int sum = 0;\n    int* v = malloc(sizeof(int) * (numsSize+1));\n    int dp[15][1010];\n\n    bool quan0 = true;\n    for(int i = 0; i < numsSize; i++) \n        if(nums[i]) {\n            quan0 = false;\n            break;\n        }\n    if(quan0) return 0;\n    \n    memset(dp, 0x3f, 15*1010*sizeof(int));\n    for(int i = 0; i < 15; i++) dp[i][0] = 0;\n    for(int i = 0; i < n; i++) v[i] = nums[i];\n    for(int i = 0; i < m; i++) {\n        int l = queries[i][0], r = queries[i][1], wei = queries[i][2];\n        for(int j = l; j <= r; j++) {\n            for(int k = v[j]; k >= wei; k--)\n                dp[j][k] = fmin(dp[j][k], dp[j][k-wei] + 1);\n        }\n        k++;\n        bool isf = true;\n        for(int i = 0; i < numsSize; i++) \n            if(dp[i][v[i]] == 0x3f3f3f3f) {\n                isf = false;\n                break;\n            }\n        if(isf) break;\n    }\n\n    bool isf = true;\n    for(int i = 0; i < numsSize; i++) \n        if(dp[i][v[i]] == 0x3f3f3f3f) {\n                isf = false;\n                break;\n            }\n    if(isf) return k;\n    else return -1;\n}","author":"lviy","submissionId":"611254371"},[]]},{"1932":[{"id":"1932","fileName":"611254426.txt","sourceCode":"bool canAchieveTarget(int target, int *coins, int coinsCount) {\n    bool *dp = (bool*)calloc(target + 1, sizeof(bool));\n    dp[0] = true;\n    for (int i = 0; i < coinsCount; i++) {\n        int coin = coins[i];\n        for (int s = target; s >= coin; s--) {\n            if (dp[s - coin])\n                dp[s] = true;\n        }\n    }\n    bool res = dp[target];\n    free(dp);\n    return res;\n}\n\nbool isFeasible(int k, int *nums, int n, int **queries) {\n    for (int i = 0; i < n; i++) {\n        int cnt = 0;\n        for (int j = 0; j < k; j++) {\n            int l = queries[j][0], r = queries[j][1];\n            if (i >= l && i <= r)\n                cnt++;\n        }\n        int *coins = (int*)malloc(cnt * sizeof(int));\n        int index = 0;\n        for (int j = 0; j < k; j++) {\n            int l = queries[j][0], r = queries[j][1];\n            if (i >= l && i <= r) {\n                coins[index++] = queries[j][2];\n            }\n        }\n        if (nums[i] != 0) {\n            if (!canAchieveTarget(nums[i], coins, cnt)) {\n                free(coins);\n                return false;\n            }\n        }\n        free(coins);\n    }\n    return true;\n}\n\nint minZeroArray(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize) {\n    if (numsSize == 0)\n        return 0;\n    if (isFeasible(0, nums, numsSize, queries))\n        return 0;\n    for (int k = 1; k <= queriesSize; k++) {\n        if (isFeasible(k, nums, numsSize, queries))\n            return k;\n    }\n    return -1;\n}","author":"sinkDink","submissionId":"611254426"},[]]},{"1933":[{"id":"1933","fileName":"611254073.txt","sourceCode":"class Solution {\npublic:\n    int minDo(int num, vector<vector<int>>& ddo) {\n        if (num == 0) return 0;\n        set<int> s;\n        s.insert(num);\n        for (int i = 0; i < ddo.size(); i++) {\n            set<int> ns;\n            for (int t : s) {\n                if (t == ddo[i][0]) return ddo[i][1] + 1;\n                if (t - ddo[i][0] > 0) ns.insert(t - ddo[i][0]);\n            }\n            for (int t : ns) s.insert(t);\n        }\n        return -1;\n        \n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<vector<vector<int>>> vv;\n        for (int i = 0; i < nums.size(); i++) vv.push_back(vector<vector<int>>());\n        for (int i = 0; i < queries.size(); i++) {\n            auto &q = queries[i];\n            for (int j = q[0]; j <= q[1]; j++) {\n                vv[j].push_back({q[2], i});\n            }\n        }\n        int maxDo = -1;\n        for (int i = 0; i < nums.size(); i++) {\n            int md = minDo(nums[i], vv[i]);\n            if (md == -1) return -1;\n            maxDo = max(maxDo, md);\n        }\n        return maxDo;\n    }\n};","author":"漆黑之牙约修亚","submissionId":"611254073"},[]]},{"1934":[{"id":"1934","fileName":"611254762.txt","sourceCode":"class Solution:\n\n    def minZeroArray(self, A: List[int], queries: List[List[int]]) -> int:\n        if all(a == 0 for a in A): return 0\n        n = len(A)\n        A = [{a} for a in A]\n        for k, (l, r, val) in enumerate(queries, 1):\n            for i in range(l, r + 1):\n                if 0 not in A[i]:\n                    A[i] |= {a - val for a in A[i] if a - val >= 0}\n            if all(0 in B for B in A):\n                return k\n        return -1","author":"Han3000","submissionId":"611254762"},[]]},{"1935":[{"id":"1935","fileName":"611254009.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<unordered_set<int>> vals(n);\n        vector<int> oks(n, 0);\n        for (int i = 0; i < n; i++)\n            if (nums[i] == 0)\n                oks[i] = 1;\n        bool check = true;\n        for (int i = 0; i < n; i++) {\n            if (oks[i] == 0) {\n                check = false;\n                break;\n            }\n        }\n        if (check)\n            return 0;\n        for (int i = 0; i < m; i++) {\n            int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                if (oks[j] || v > nums[j])\n                    continue;\n                if (v == nums[j]) {\n                    oks[j] = 1;\n                    continue;\n                }\n                int nv = vals[j].size();\n                vector<int> tmp = {v};\n                for (auto x: vals[j]) {\n                    if (v + x < nums[j]) {\n                        tmp.push_back(v + x);   \n                    } else if (v + x == nums[j]) {\n                        oks[j] = 1;\n                        break;\n                    }\n                }\n                vals[j].insert(tmp.begin(), tmp.end());\n            }\n            bool found = true;\n            for (int j = 0; j < n; j++) {\n                if (!oks[j]) {\n                    found = false;\n                    break;\n                }\n            }\n            if (found)\n                return i + 1;\n        }\n        return -1;\n    }\n};","author":"umiGen","submissionId":"611254009"},[]]},{"1936":[{"id":"1936","fileName":"611254867.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<pair<int,int>>ys[10];\n        int cnt = 0;\n        for(auto q : queries){\n            int l = q[0],r = q[1],val = q[2];\n            cnt++;\n            for(int i = l;i <= r;i++){\n                ys[i].push_back({val,cnt});\n            }\n        }\n        int ans = 0;\n        for(int i = 0;i < nums.size();i++){\n            int yn = ys[i].size();\n            vector<int>dp(nums[i] + 1);\n            dp[0] = 1;\n            if(nums[i] == 0)continue;\n            for(int k = 0;k < ys[i].size();k++){\n                for(int j = nums[i];j >= ys[i][k].first;j--){\n                        dp[j] |= dp[j - ys[i][k].first];\n                }\n                if(dp[nums[i]] == 1){\n                    ans = max(ans,ys[i][k].second);\n                    break;\n                }\n            }\n            if(dp[nums[i]] == 0){\n                return -1;\n            }\n        }\n        return ans; \n    }\n};","author":"千数","submissionId":"611254867"},[]]},{"1937":[{"id":"1937","fileName":"611254905.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        // sort(queries.begin(), queries.end());\n        int ln = nums.size();\n        int lq = queries.size();\n        int min_q = 0;\n        for (int i = 0; i < ln; ++i) {\n            // cout << nums[i] << \":\" << endl;\n            if (nums[i] == 0) {\n                continue;\n            }\n            vector<int> hash(nums[i] + 1, 0);\n            hash[0] = 1;\n            for (int q = 0; q < lq; ++q) {\n                if (queries[q][1] < i || queries[q][0] > i) {\n                    continue;\n                }\n                // ----------------------------------\n                int v = queries[q][2];\n                // cout << q << \":\" << v << \":\" << endl;\n                if (v > nums[i]) {\n                    continue;\n                }\n                for (int idx = nums[i] - v; idx >= 0; --idx) {\n                    if (hash[idx] == 1) {\n                        hash[idx + v] = 1;\n                    }\n                }\n                // for (int idx = 0; idx <= nums[i]; ++idx) {\n                //     cout << hash[idx] << \" \";\n                // }\n                // cout << endl;\n                min_q = max(min_q, q + 1);\n                if (hash[nums[i]] == 1) {\n                    break;\n                }\n            }\n            if (hash[nums[i]] != 1) {\n                return -1;\n            }\n        }\n        return min_q;\n    }\n};","author":"签到题高手_mmm","submissionId":"611254905"},[]]},{"1938":[{"id":"1938","fileName":"611254968.txt","sourceCode":"func minZeroArray(nums []int, queries [][]int) (ans int) {\n    n := len(nums)\n\n    for i := 0; i < n; i++ {\n        if nums[i] == 0 {\n            continue\n        }\n\n        a := []int{}\n        for q := 0; q < len(queries); q++ {\n            li, ri := queries[q][0], queries[q][1]\n            if li <= i && i <= ri {\n                a = append(a, q)\n            }\n        }\n\n        if len(a) == 0 {\n            return -1\n        }\n\n        vals := make([]int, len(a))\n        for j, q := range a {\n            vals[j] = queries[q][2]\n        }\n\n        target := nums[i]\n        f := make([]bool, target+1)\n        f[0] = true\n        minT := -1\n\n        for t := 0; t < len(vals); t++ {\n            val := vals[t]\n            for j := target; j >= val; j-- {\n                if f[j-val] {\n                    f[j] = true\n                    if j == target && minT == -1 {\n                        minT = t\n                    }\n                }\n            }\n        }\n\n        if !f[target] {\n            return -1\n        }\n\n        ans = max(ans, a[minT] + 1)\n    }\n\n    return ans\n}","author":"tyrantzhao","submissionId":"611254968"},[]]},{"1939":[{"id":"1939","fileName":"611255198.txt","sourceCode":"class Solution {\n  public int minZeroArray(int[] nums, int[][] queries) {\n    boolean allZero = true;\n    for (int v : nums) {\n      if (v != 0) {\n        allZero = false;\n        break;\n      }\n    }\n    if (allZero) {\n      return 0;\n    }\n    int len = nums.length, qLen = queries.length, limit = 1 << 10;\n    boolean[][] bits = new boolean[len][limit];\n    for (int i = 0; i < qLen; i++) {\n      int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n      for (int t = l; t <= r; t++) {\n        int nv = nums[t];\n        if (bits[t][nv]) {\n          continue;\n        }\n        for (int x = limit - 1; x >= v; x--) {\n          int bx = x - v;\n          if (bits[t][bx]) {\n            bits[t][x] = true;\n          }\n        }\n        bits[t][v] = true;\n      }\n      boolean valid = true;\n      for (int t = 0; t < len; t++) {\n        if (nums[t] > 0 && !bits[t][nums[t]]) {\n          valid = false;\n          break;\n        }\n      }\n      if (valid) {\n        return i + 1;\n      }\n    }\n    return -1;\n  }\n}","author":"lifam","submissionId":"611255198"},[]]},{"1940":[{"id":"1940","fileName":"611255194.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> arr(n, vector<int>(1001, 0));\n        for(int i = 0; i < n; i++) arr[i][0] = 1;\n        int flag = 1;\n        for(int i = 0; i < n; i++) if(nums[i]) {\n            flag = 0;\n            break;\n        }\n        if(flag == 1) return 0; \n        for(int i = 0; i < queries.size(); i++) {\n            int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n            for(int j = l; j <= r; j++) {\n                // 处理nums[j]\n                if(arr[j][nums[j]] == 1) continue;\n                for(int k = 1000 - v; k >= 0; k--) {\n                    if(arr[j][k]) arr[j][k + v] = 1;\n                }\n            }\n            int flag = 1;\n            for(int j = 0; j < n; j++) if(arr[j][nums[j]] != 1) {\n                flag = 0;\n                break;\n            }\n            if(flag == 1) return i + 1;\n            \n        }\n        return -1;\n    }\n};","author":"原味鸡","submissionId":"611255194"},[]]},{"1941":[{"id":"1941","fileName":"611254788.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        List<int[]>[] g = new List[n];\n        for (int i = 0; i < n; i++) {\n            g[i] = new ArrayList<>();\n        }\n        for (int k = 0; k < queries.length; k++) {\n            int[] q = queries[k];\n            int l = q[0], r = q[1], val = q[2];\n            for (int i = l; i <= r; i++) {\n                g[i].add(new int[]{val, k});\n            }\n        }\n        int res = -1;\n        for (int i = 0; i < n; i++) {\n            int cur = solve(g[i], nums[i]);\n            if (cur == -1) {\n                return -1;\n            }\n            res = Math.max(res, cur);\n        }\n        return res;\n    }\n\n    private int solve(List<int[]> list, int x) {\n        if (x == 0) {\n            return 0;\n        }\n        boolean[] dp = new boolean[x + 1];\n        dp[0] = true;\n        for (int[] item : list) {\n            int y = item[0];\n            for (int i = x; i >= y; i--) {\n                dp[i] |= dp[i - y];\n                if (dp[x]) {\n                    return item[1] + 1;\n                }\n            }\n        }\n        return -1;\n    }\n}","author":"橘右京","submissionId":"611254788"},[]]},{"1942":[{"id":"1942","fileName":"611255275.txt","sourceCode":"class Solution {\npublic:\nint minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    int n = nums.size();\n    int m = queries.size();\n    auto check = [&](int mid) -> bool {\n        // cerr << \"mid = \" << mid << endl;\n        if (mid == m + 1)\n            return true;\n        vector<vector<int>> add(n);\n        for (int i = 0; i < mid; i++) {\n            auto& q = queries[i];\n            for (int i = q[0]; i <= q[1]; i++) {\n                add[i].push_back(q[2]);\n            }\n        }\n        // for (auto& v : add) {\n        //     for (int i : v) {\n        //         cerr << i << \" \";\n        //     }\n        //     cerr << endl;\n        // }\n        for (int k = 0; k < n; k++) {\n            vector dp(nums[k] + 1, 0);\n            dp[0] = 1;\n            for (int i : add[k]) {\n                for (int j = nums[k]; j >= i; j--) {\n                    dp[j] |= dp[j - i];\n                }\n            }\n            // for (int i = 0; i <= nums[k]; i++) {\n            //     cerr << dp[i] << \" \";\n            // }\n            // cerr << endl;\n            if (!dp[nums[k]])\n                return false;\n        }\n        return true;\n    };\n    int L = 0, R = m + 1;\n    while (L < R) {\n        int mid = (L + R) >> 1;\n        if (check(mid))\n            R = mid;\n        else\n            L = mid + 1;\n    }\n    if (L == m + 1)\n        return -1;\n    return L;\n}\n};","author":"XYukari","submissionId":"611255275"},[]]},{"1943":[{"id":"1943","fileName":"611255010.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        static bitset <1010> dp[15];\n        int n=nums.size();int m=queries.size();\n        for(int i=0;i<n;i++)dp[i].reset();\n        for(int i=0;i<n;i++)dp[i][0]=1;\n        int zcnt=0;\n        for(int i=0;i<n;i++)\n            {\n                if(dp[i][nums[i]]==1)zcnt++;\n            }\n        if(zcnt==n)return 0;\n        for(int k=0;k<m;k++)\n        {\n            int l=queries[k][0];\n            int r=queries[k][1];\n            int val=queries[k][2];\n           // printf(\"q [%d,%d] %dn\",l,r,val);\n            for(int z=l;z<=r;z++)\n            {\n                dp[z]=dp[z]|(dp[z]<<val);        \n            }\n            int cnt=0;\n            for(int i=0;i<n;i++)\n            {\n                //for(int j=0;j<=10;j++)\n                 //   if(dp[i][j]==1)printf(\"1\");\n                  //  else printf(\"0\");\n                //printf(\"n\");\n                if(dp[i][nums[i]]==1)cnt++;\n            }\n            if(cnt==n)return k+1;\n        }\n        return -1;\n    }\n};","author":"Shadowice1984","submissionId":"611255010"},[]]},{"1944":[{"id":"1944","fileName":"611255479.txt","sourceCode":"int m[1005][1005];\n\nclass Solution {\npublic:\n    \n    int dfs(int v, int i, int j) {\n        if(j >= q.size() || j > res) {\n            return j;\n        }\n        // if(i == 2) cout << v << \" \" << i << \" \" << j << endl;\n        if(m[v][j] < 1e4) {\n            return m[v][j];\n        }\n        if(i < q[j][0] || i > q[j][1]) {\n            m[v][j] = dfs(v, i, j + 1);\n            return m[v][j];\n        }\n        if(v == q[j][2]) {\n            res = min(res, j);\n            m[v][j] = j;\n            return j;\n        }\n        // cout << v << \" \" << i << \" \" << j << endl;\n        int c = dfs(v, i, j + 1);\n        if(v > q[j][2]) {\n            c = min(c, dfs(v - q[j][2], i, j + 1));\n        }\n        m[v][j] = c;\n        return c;\n    }\n    \n    int res;\n    // unordered_map<int, unordered_map<int, int>> m;\n    vector<vector<int>> q;\n    \n    int minZeroArray(vector<int>& a, vector<vector<int>>& q_) {\n        if(*max_element(a.begin(), a.end()) == 0) {\n            return 0;\n        }\n        q = q_;\n        int n = a.size();\n        vector<int> k(n);\n        for(int i = 0; i < n; i++) {\n            if(a[i] == 0) {\n                continue;\n            }\n            memset(m, 127, (a[i] + 1) * 1005 * 4);\n            // m.clear();\n            res = q.size() + 1;\n            int c = dfs(a[i], i, 0);\n            // cout << i << \" \" << res << endl;\n            if(c >= q.size()) {\n                return -1;\n            }\n            k[i] = c;\n        }\n        res = 0;\n        for(auto &i : k) {\n            res = max(res, i);\n        }\n        return res + 1;\n    }\n};","author":"后青春期的YXY","submissionId":"611255479"},[]]},{"1945":[{"id":"1945","fileName":"611255502.txt","sourceCode":"#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> PII;\ntypedef unsigned long long ull;\n\n    \nclass Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& Q) {\n        int n = a.size(), q = Q.size();\n        int k = -1;\n        bool ck = true;\n        for(int i = 0; i < n; i++) {\n            if(a[i]) ck = false;\n        }\n        if(ck) {\n            return 0;\n        }\n        vector<set<ll>> mp(n + 1);\n        for(int i = 0; i < n; i++) {\n            mp[i].insert(0);\n        }\n        queue<ll> qq;\n        for(int i = 0; i < q; i++) {\n            int l = Q[i][0], r = Q[i][1], x = Q[i][2];\n            for(int j = l; j <= r; j++) {\n                for(auto c : mp[j]) {\n                    qq.push(c);\n                }             \n                while(!qq.empty()) {\n                    mp[j].insert(qq.front() + x);\n                    qq.pop();\n                }   \n            }\n            bool ok = true;\n            for(int j = 0; j < n; j++) {\n                if(!mp[j].count(a[j])) {\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok) {\n                k = i + 1;\n                break;\n            }\n        }\n        return k;\n    }\n};","author":"Dr_Zhang","submissionId":"611255502"},[]]},{"1946":[{"id":"1946","fileName":"611255366.txt","sourceCode":"/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number}\n */\nvar minZeroArray = function (nums, queries) {\n  const n = nums.length\n  const check = (m) => {\n    for (let i = 0; i < n; i++) {\n      const sum = nums[i]\n      const f = new Array(sum + 1).fill(false)\n      f[0] = true\n      for (let j = 0; j <= m; j++) {\n        const [l, r, v] = queries[j]\n        // 在区间内才可以操作\n        for (let s = sum; s >= 0; s--) {\n          if (i >= l && i <= r && s >= v) {\n            f[s] = f[s] || f[s - v]\n          }\n        }\n      }\n      if (!f[sum]) return false\n    }\n    return true\n  }\n\n  if (_.sum(nums) === 0) {\n    return 0\n  }\n\n  let l = 0, r = queries.length;\n  // \n  while (l < r) {\n    const mid = Math.floor((l + r) / 2)\n    if (check(mid)) {\n      r = mid\n    } else {\n      l = mid + 1\n    }\n  }\n  return l === queries.length ? -1 : l + 1\n};\n","author":"lihaoze","submissionId":"611255366"},[]]},{"1947":[{"id":"1947","fileName":"611255577.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        int retVal = 0;\n        for (int i = 0; i < n; ++i) {\n            if (!nums[i]) continue;\n            bool valid[nums[i] + 1];\n            bool flag = false;\n            int j;\n            memset(valid, 0, sizeof(valid));\n            valid[0] = true;\n            for (j = 0; j < m; ++j) {\n                auto q = queries[j];\n                if (q[0] <= i && q[1] >= i) {\n                    for (int k = nums[i] - q[2]; k >= 0; --k) valid[k + q[2]] = valid[k + q[2]] || valid[k];\n                }\n                if (valid[nums[i]]) {\n                    flag = true;\n                    break;\n                }\n            }\n            if (flag) retVal = max(retVal, j + 1);\n            else return -1;\n        }\n        return retVal;\n    }\n};","author":"ming","submissionId":"611255577"},[]]},{"1948":[{"id":"1948","fileName":"611255943.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    int n = nums.size();\n    int m = queries.size();\n    vector<vector<pair<int, int>>> cover(n);\n    for (int i = 0; i < m; i++) \n    {\n        int l = queries[i][0];\n        int r = queries[i][1];\n        int val = queries[i][2];\n        for (int x = l; x <= r; x++) \n            if (x >= 0 && x < n) cover[x].emplace_back(i, val);\n    }\n    \n    vector<int> allmax;\n    for (int i = 0; i < n; i++) \n    {\n        int num = nums[i];\n        if (num == 0) \n        {\n            allmax.emplace_back(-1);\n            continue;\n        }\n        \n        auto& que = cover[i];\n        unordered_set<int> p = {0};\n        bool found = false;\n        int jmax = -1;\n        for (auto& [idx, val] : que) {\n            unordered_set<int> newp(p);\n            for (auto s : p) newp.insert(s + val);\n            p.swap(newp);\n            if (p.count(num)) \n            {\n                jmax = idx;\n                found = true;\n                break;\n            }\n        }\n        if (!found) return -1;\n        allmax.emplace_back(jmax);\n    }\n    int maxj = -1;\n    bool flag = false;\n    for (auto j : allmax) \n    {\n        if (j != -1) \n        {\n            flag=true;\n            if(j>maxj) maxj=j;\n        }\n    }\n    \n    if (!flag) return 0;\n    return maxj + 1;\n    }\n};","author":"unak","submissionId":"611255943"},[]]},{"1949":[{"id":"1949","fileName":"611255533.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size(), m = q.size();\n        int ans = 0;\n        for(int j = 0; j < n; j++) {\n            vector<vector<int> > dp(m, vector<int>(a[j]+1, -1));\n            auto dfs = [&](auto& dfs, int i, int y) -> int {\n                if(i == m) {\n                    if(y == 0) return 0;\n                    else return m + 1;\n                }\n                if(y == 0) return 0;\n                if(dp[i][y] != -1) return dp[i][y];\n                int res = dfs(dfs, i + 1, y) + 1;\n                if(q[i][0] <= j and j <= q[i][1] and y >= q[i][2]) \n                    res = min(res, dfs(dfs, i + 1, y - q[i][2]) + 1);\n                return dp[i][y] = res;\n            };\n            int t = dfs(dfs, 0, a[j]);\n            if(t >= m + 1) return -1;\n            ans = max(ans, t);\n        }\n        if(ans == m + 1) ans = -1;\n        return ans;\n    }\n};","author":"shi_logic","submissionId":"611255533"},[]]},{"1950":[{"id":"1950","fileName":"611255642.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        const int n = nums.size(), m = queries.size();\n        vector<set<int>> arr(n, set<int>{0});\n        vector<int> ret(n, INT_MAX);\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == 0) {\n                ret[i] = 0;\n            }\n        }\n        vector<int> v;\n        for (int i = 0; i < m; ++i) {\n            const int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for (int j = l; j <= r; ++j) {\n                if (ret[j] != INT_MAX) {\n                    continue;\n                }\n                auto& s = arr[j];\n                v.clear();\n                for (auto t : s) {\n                    if (t + val == nums[j]) {\n                        ret[j] = i + 1;\n                        break;\n                    }\n                    if (t + val > nums[j]) {\n                        break;\n                    }\n                    v.push_back(t + val);\n                }\n                s.insert(v.begin(), v.end());\n            }\n        }\n        int r = *max_element(ret.begin(), ret.end());\n        return r == INT_MAX ? -1 : r;\n    }\n};\n/*\n[2]\n[[0,0,6],[0,0,2],[0,0,9],[0,0,5],[0,0,10]]\n2\n*/","author":"梁震甲","submissionId":"611255642"},[]]},{"1951":[{"id":"1951","fileName":"611255819.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<pair<int, int>>> cover(n); // 覆盖每个元素的查询列表，按索引排序\n        // 预处理每个元素被哪些查询覆盖\n        for (int j = 0; j < queries.size(); ++j) {\n            auto& q = queries[j];\n            int l = q[0], r = q[1], val = q[2];\n            for (int i = l; i <= r; ++i) {\n                cover[i].emplace_back(j, val);\n            }\n        }\n        // 对每个元素的覆盖查询按索引排序\n        for (auto& v : cover) {\n            sort(v.begin(), v.end());\n        }\n        int max_j = -1;\n        for (int i = 0; i < n; ++i) {\n            int target = nums[i];\n            if (target == 0) {\n                continue; // 该元素无需操作，不影响max_j\n            }\n            unordered_map<int, int> dp;\n            dp[0] = -1; // 初始状态，和为0时没有使用任何查询\n            for (auto& p : cover[i]) {\n                int j = p.first;\n                int val = p.second;\n                unordered_map<int, int> new_dp(dp); // 不选当前查询的情况\n                // 处理选择当前查询的情况\n                for (auto& [s, current_max] : dp) {\n                    int new_s = s + val;\n                    if (new_s > target) continue;\n                    int new_max = max(current_max, j); // 当前查询的索引必然更大\n                    // 更新new_dp中的状态\n                    if (new_dp.find(new_s) == new_dp.end()) {\n                        new_dp[new_s] = new_max;\n                    } else {\n                        if (new_max < new_dp[new_s]) {\n                            new_dp[new_s] = new_max;\n                        }\n                    }\n                }\n                dp.swap(new_dp);\n            }\n            // 检查是否存在解\n            if (dp.find(target) == dp.end()) {\n                return -1;\n            }\n            max_j = max(max_j, dp[target]);\n        }\n        // 处理所有元素都为0的情况\n        if (max_j == -1) {\n            for (int num : nums) {\n                if (num != 0) return -1;\n            }\n            return 0;\n        }\n        return max_j + 1;\n\n    }\n};","author":"Antares","submissionId":"611255819"},[]]},{"1952":[{"id":"1952","fileName":"611256073.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n=nums.length;\n        int m=queries.length;\n        int k=0;\n        for(int i=0;i<n;i++){\n            int tar=nums[i];\n            if(tar==0)continue;\n            List<Integer> subs=new ArrayList<>();\n            int sum=0;\n            boolean zero=false;\n            for(int j=0;j<m;j++){\n                if(queries[j][0]<=i&&queries[j][1]>=i&&queries[j][2]<=tar){\n                    subs.add(queries[j][2]);\n                    sum+=queries[j][2];\n                    if(sum>=tar&&canSum(subs,tar)){\n                        k=Math.max(k,j+1);\n                        zero=true;\n                        break;\n                    }\n                }\n            }\n            if(!zero)return -1;\n        }\n        return k;\n    }\n    private boolean canSum(List<Integer> subs,int target){\n        boolean[] f=new boolean[target+1];\n        f[0]=true;\n        for(int num:subs){\n            for(int i=target;i>=num;i--){\n                f[i]|=f[i-num];\n            }\n        }\n        return f[target];\n    }\n}","author":"111","submissionId":"611256073"},[]]},{"1953":[{"id":"1953","fileName":"611255971.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if max(nums) == 0:\n            return 0\n        qn = len(queries)\n        def check(k):\n            # print('check', k)\n            if k == qn + 1:\n                return True\n            n = len(nums)\n            lists = [[0] * 11 for _ in nums]\n            for l, r, val in queries[:k]:\n                for i in range(l, r + 1):\n                    lists[i][val] += 1\n            # print(lists)\n            for i in range(n):\n                num = nums[i]\n                s = [0] * (num + 1)\n                s[0] = 1\n                for j in range(1, 11):\n                    c = lists[i][j]\n                    if c == 0:\n                        continue\n                    for t in range(num, -1, -1):\n                        if s[t]:\n                            # print('t', t, ' t + c * j + 1', t + c * j + 1, ' s[t:(t + c * j + 1):c]', s[t:(t + c * j + 1):c])\n                            s[t:(t + c * j + 1):j] = [1] * len(s[t:(t + c * j + 1):j])\n                    # print(i, j, s)\n                    if s[-1]:\n                        break\n                    \n                if s[-1] == 0:\n                    return False\n            return True\n        p = 0\n        q = qn + 1\n        while p < q:\n            mid = (p + q) // 2\n            # print(p, q, mid)\n            # print(mid, check(mid))\n            if check(mid):\n                q = mid\n            else:\n                p = mid + 1\n        if q <= qn:\n            return q\n        return -1","author":"好想喝羊肉汤啊","submissionId":"611255971"},[]]},{"1954":[{"id":"1954","fileName":"611256090.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int res = -1;\n        for(int i = 0; i < nums.length;i++){\n            if(nums[i] == 0){\n                if(res <0){\n                    res = 0;\n                }\n                continue;\n            }\n            \n            int[] m = new int[1001];\n            m[0]= 1;\n            boolean f = false;\n            for(int j = 0; j < queries.length;j++){\n                if(queries[j][0]>i||queries[j][1]<i){\n                    continue;\n                }\n\n                if(nums[i]-queries[j][2]>=0 && m[nums[i]-queries[j][2]] != 0){\n                    if(res < j+1){\n                        res = j+1;\n                    }\n                    f = true;\n                    break;\n                }\n\n                int[] m2 = new int[1001];\n                m2[queries[j][2]]=1;\n                for(int k =0;k<1001;k++){\n                    if(m[k]!=0){\n                        if(k+queries[j][2]<1001) {\n                            m2[k + queries[j][2]] = 1;\n                        }\n                        m2[k] = 1;\n                    }\n                }\n                m = m2;\n            }\n            if(!f){\n                return -1;\n            }\n        }\n        return res;\n    }\n    \n}","author":"秋雨田风","submissionId":"611256090"},[]]},{"1955":[{"id":"1955","fileName":"611256152.txt","sourceCode":"const int N = 1e3 + 5;\nint dp[N];\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        int a = 0;\n        for (int i = 0; i < n; i++) {\n            int x = nums[i];\n            if (x == 0) {\n                continue ;\n            }\n            memset(dp, 0, sizeof(dp));\n            dp[0] = 1;\n            \n            for (int k = 0; k < m; k++) {\n                int l = queries[k][0], r = queries[k][1], y = queries[k][2];\n                if (i < l || i > r) {\n                    continue ;\n                }\n                for (int j = x; j - y >= 0; j--) {\n                    if (dp[j - y]) {\n                        dp[j] = 1;\n                    }\n                }\n                if (dp[x] == 1) {\n                    a = max(a, k + 1);\n                    break ;\n                }\n            }\n            if (dp[x] != 1) {\n                return -1;\n            }\n        }\n        return a;\n    }\n};","author":"山风土豆","submissionId":"611256152"},[]]},{"1956":[{"id":"1956","fileName":"611256107.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int ans = 1;\n        vector<map<int, int>> g(n);\n\n        for (int i = 0; i < n; i++) {\n            g[i][nums[i]]++;\n        }\n\n        bool ff = true;\n        for (int i = 0; i < n; i++) {\n            if (g[i].find(0) == g[i].end()) {\n                ff = false;\n                break;\n            }\n        }\n\n        if (ff == true) return 0;\n\n        for (auto &q : queries) {\n            int l = q[0], r = q[1], val = q[2];\n            for (int i = l; i <= r; i++) {\n                for (auto &[u, v] : g[i]) {\n                    g[i][u - val]++;\n                }\n            }\n\n            bool f = true;\n            for (int i = 0; i < n; i++) {\n                if (g[i].find(0) == g[i].end()) {\n                    f = false;\n                    break;\n                }\n            }\n\n            if (f == true) return ans;\n            ans++;\n        }\n\n        return -1;\n    }\n};","author":"๑古月ღ","submissionId":"611256107"},[]]},{"1957":[{"id":"1957","fileName":"611256162.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        nums_len = len(nums)\n        \n        poss_nums = [set([num]) for num in nums]\n        # print(poss_nums)\n\n        if all([num == 0 for num in nums]):\n            return 0\n        \n        for k, query in enumerate(queries):\n            l, r, val = query\n            r = min(r, nums_len - 1)\n\n            for i in range(l, r + 1):\n                new_poss_num = set()\n                for poss_num in poss_nums[i]:\n                    new_poss_num.add(poss_num)\n                    if poss_num - val >= 0:\n                        new_poss_num.add(poss_num - val)\n                poss_nums[i] = new_poss_num\n\n            # print(poss_nums)\n            \n            # check\n            if all([0 in poss_num for poss_num in poss_nums]):\n                return k + 1\n\n        return -1\n","author":"g00dm0rning","submissionId":"611256162"},[]]},{"1958":[{"id":"1958","fileName":"611256212.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int sum = 0;\n        for(auto c:nums){\n            if(c != 0){\n                sum = 1;\n                break;\n            }\n        }\n        if(sum == 0) return 0;\n        int res = 0;\n        for(int i=0;i<nums.size();i++){\n            int len = nums[i];\n            vector<int> dp(len+1,0);\n            int cnt = 0;\n            for(auto &c:queries){\n                cnt++;\n                if(i>=c[0] && i<=c[1]){\n                    for(int k=len;k>=0;k--){\n                        if(k >= c[2])\n                            dp[k] = max(dp[k], dp[k-c[2]] + c[2]);\n                    }\n                    if(dp[len] == len){\n                        res = max(res,cnt);\n                        break;\n                    }\n                }\n            }\n            if(dp[len] < len) return -1;\n        }\n        return res;\n    }\n};","author":"我也不想c+v呀","submissionId":"611256212"},[]]},{"1959":[{"id":"1959","fileName":"611256486.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> p(n, vector<int>());\n        vector<vector<int>> dp(n, vector<int>());\n        for (int i = 0; i < n; ++i) {\n            int m = nums[i];\n            dp[i].resize(m + 1, 0);\n            dp[i][0] = 1;\n        }\n        for (auto& q : queries) {\n            int l = q[0], r = q[1], v = q[2];\n            for (int i = 0; i < n; ++i) {\n                if(i>=l&&i<=r)\n                    p[i].push_back(v);\n                else\n                    p[i].push_back(0);\n            }\n        }\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            int m = nums[i];\n            int cnt = 1;\n            if(m==0) {\n                ans = max(ans,0);\n                continue;\n            }\n            for (auto& x : p[i]) {\n                if(x==0||x>m) {\n                    ++cnt;\n                    continue;\n                }\n                for (int j = m; j >= x; --j) {\n                    dp[i][j] = dp[i][j] | dp[i][j - x];\n                }\n                if(dp[i][m]==1){\n                    ans = max(ans,cnt);\n                    // cout<<ans<<endl;\n                    break;\n                }\n                ++cnt;\n            }\n            if(!dp[i][m]) return -1;\n        }\n        return ans;\n    }\n};","author":"ascend","submissionId":"611256486"},[]]},{"1960":[{"id":"1960","fileName":"611256248.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        if all(x == 0 for x in nums):\n            return 0\n        dp = [1] * n\n\n        for k, (l, r, val) in enumerate(queries, 1):\n            for i in range(l, r+1):\n                dp[i] |= dp[i] << val  \n\n            if all((dp[i] >> nums[i]) & 1 for i in range(n)):\n                return k\n\n        return -1\n","author":"ycq","submissionId":"611256248"},[]]},{"1961":[{"id":"1961","fileName":"611256523.txt","sourceCode":"#ifdef USACO_LOCAL_JUDGE\n#include <bits/stdc++.h>\n\n#include \"base.h\"\nusing namespace std;\n#endif\n\nint debug = 1;\n#define MyPrintf(...)               \n  do {                              \n    if (debug) printf(__VA_ARGS__); \n  } while (0)\n\n#define MyDebug(...) fprintf(stderr, __VA_ARGS__);\n\ntypedef long long ll;\nclass Solution {\n public:\n  int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    int sum = accumulate(nums.begin(), nums.end(), 0);\n    if (sum == 0) return 0;\n    const int n = nums.size();\n    const int q = queries.size();\n    // printf(\"n=%d q=%dn\", n, q);\n    vector<int> weights(q);\n    vector<int> dp(q * 10);\n    auto CheckV = [&](int p, int V, int mid) -> bool {  // 检查一个是否满足\n      weights.clear();\n      // queries 中选择前 mid 个区间\n      for (int i = 0; i <= mid; i++) {\n        auto& v = queries[i];\n        int l = v[0], r = v[1], val = v[2];\n        if (p < l || p > r || val > V) continue;\n        if (val == V) return true;  // 剪枝\n        weights.push_back(val);\n      }\n      sort(weights.begin(), weights.end());\n      //  01背包， V 需要刚好填满\n      dp.clear();\n      dp.resize(V + 1, 0);\n      for (auto v : weights) {\n        for (int i = V; i >= v; i--) {\n          dp[i] = max(dp[i], dp[i - v] + v);\n        }\n      }\n      return dp[V] == V;\n    };\n    auto Check = [&](int mid) -> bool {\n      for (int i = 0; i < n; i++) {\n        int v = nums[i];\n        if (v == 0) continue;\n        if (CheckV(i, v, mid)) continue;\n        return false;\n      }\n      return true;\n    };\n\n    int l = 0, r = q;\n    while (l < r) {\n      int mid = (l + r) / 2;\n      int ret = Check(mid);\n      // printf(\"l=%d r=%d mid=%d ret=%dn\", l, r, mid, ret);\n      if (ret) {\n        r = mid;\n      } else {\n        l = mid + 1;\n      }\n    }\n    if (l == q) return -1;\n    return l + 1;\n  }\n};\n\n#ifdef USACO_LOCAL_JUDGE\n\nint main() {  //\n  return 0;\n}\n\n#endif","author":"tiankonguse-天空柚子","submissionId":"611256523"},[]]},{"1962":[{"id":"1962","fileName":"611256566.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        d = [[0] * m for _ in range(n)]\n        for i, (l, r, val) in enumerate(queries):\n            for j in range(l, r + 1):\n                d[j][i] = val\n        ans = []\n        for i, row in enumerate(d):\n            f = [inf] * (nums[i] + 1)\n            f[0] = 0\n            for k, x in enumerate(row, 1):\n                if x == 0: continue\n                for j in range(nums[i], -1, -1):\n                    if j + x > nums[i] or f[j] == inf: continue\n                    f[j + x] = min(f[j + x], k)\n            ans.append(f[-1])\n        mx = max(ans) if ans else inf\n        return mx if mx < inf else -1","author":"小爱仙尊","submissionId":"611256566"},[]]},{"1963":[{"id":"1963","fileName":"611256628.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        hm = defaultdict(list)\n        for qi,(l,r,v) in enumerate(queries):\n            for i in range(l,r+1):\n                hm[i].append((v,qi+1))\n        res = 0\n        for i,n in enumerate(nums):\n            if n == 0:\n                continue\n            if i not in hm:\n                return -1\n            q = {0}\n            for v,qi in hm[i]:\n                q = set(x for y in q for x in [y, y+v] if x <= n)\n                if n in q:\n                    res = max(res, qi)\n                    break\n            if n not in q:\n                return -1\n        return res","author":"孔雀千人","submissionId":"611256628"},[]]},{"1964":[{"id":"1964","fileName":"611256853.txt","sourceCode":"class Solution\n{\npublic:\n    int minZeroArray(vector<int> &nums, vector<vector<int>> &queries) {\n        int n = nums.size();\n        int m = queries.size();\n\n        int cnt_zero = 0;\n\n        // dp[k][i] 表示经过前 k 个查询后，位置 i 的可能剩余值\n        vector<unordered_set<int>> dp(n);\n\n        // 初始化 dp[0][i] = nums[i]\n        for (int i = 0; i < n; i++)\n        {\n            cnt_zero += nums[i] == 0;\n            dp[i].insert(nums[i]);\n        }\n\n        if (cnt_zero == n) return 0;\n\n        // 遍历每个查询\n        for (int k = 0; k < m; k++)\n        {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int val = queries[k][2];\n\n            // 创建一个临时数组存储新的可能值\n            vector<unordered_set<int>> new_dp = dp;\n\n            // 遍历每个位置\n            for (int i = 0; i < n; i++)\n            {\n                if (i >= l && i <= r)\n                {\n                    // 如果位置 i 在查询范围内，可以选择减去 val 或不减去\n                    unordered_set<int> new_values;\n                    for (int x : dp[i])\n                    {\n                        if (x - val >= 0)\n                        {\n                            new_values.insert(x - val); // 选择减去 val\n                        }\n                        new_values.insert(x); // 选择不减去 val\n                    }\n                    new_dp[i] = new_values;\n                }\n            }\n\n            // 更新 dp\n            dp = new_dp;\n\n            // 检查是否所有位置的可能值都包含 0\n            bool isZero = true;\n            for (int i = 0; i < n; i++)\n            {\n                if (dp[i].find(0) == dp[i].end())\n                {\n                    isZero = false;\n                    break;\n                }\n            }\n            if (isZero)\n            {\n                return k + 1; // 返回当前查询的索引 + 1\n            }\n        }\n        return -1;\n    }\n};\n","author":"不想写代码只想睡大觉","submissionId":"611256853"},[]]},{"1965":[{"id":"1965","fileName":"611256832.txt","sourceCode":"'''\n对于每个数字，可以考虑使用01背包，f[i][j]，使用了前i个option，数字是j的最小下标，然后所有数字取max，\n1000*1000*10复杂度，可过\n'''\nclass Solution:\n    def minZeroArray(self, a: List[int], q: List[List[int]]) -> int:\n        n=len(a)\n        ans=[10**9 for i in range(n)]\n        def func(pos,x):\n            f=[[10**8 for i in range(max(a)+2)] for j in range(len(q)+2)]\n            f[0][0]=0\n            for i,li in enumerate(q):\n                l,r,v=li\n                for j in range(x+1):\n                    f[i+1][j]=f[i][j]\n                    if l<=pos<=r and j>=v:\n                        # print(pos,x)\n                        if f[i][j-v]!=10**8:\n                            # print(f[i][j-v])\n                            f[i+1][j]=min(f[i+1][j],i+1)\n                            # print(i+1,j,f[i+1][j])\n            # print(f[len(q)+1][x])\n            return f[len(q)][x]\n            \n                        \n                        \n                    \n        for i,x in enumerate(a):\n            # print(i,x)\n            ans[i]=func(i,x)\n        res=max(ans)\n        if res>len(q):res=-1\n        return res","author":"Allergy","submissionId":"611256832"},[]]},{"1966":[{"id":"1966","fileName":"611257637.txt","sourceCode":"#include <bits/stdc++.h>  \nusing namespace std;  \n\n#define INF (int)(1e9)\n#define LL_INF (long long)(1e14) \n#define mod (int)(1e9 + 7) \n\nlong long gcd(long long a, long long b) { \n    return b > 0 ? gcd(b, a % b) : a; \n}\n\nlong long lcm(long long a, long long b) { \n    return a / gcd(a, b) * b; \n}\n\nvoid _mod(int &a, int b) {\n    if (a > b) a -= b;\n    return ;\n}\n\ndouble myPow(double x, int N) {\n    double ans = 1.0;\n    long long n = N;\n\n    if (n < 0) {\n        n = -n;\n        x = 1/x;\n\t}\n\n    while (n) {\n        if (n & 1) {\n            ans *= x;\n        }\n\n        x *= x;\n        n >>= 1;\n    }\n\n    return ans;\n}\n\n\nstruct Matrix {  \n    long long a[26][26];\n\t\n\tMatrix () {\n        memset(a, 0, sizeof(a));\n    }  \n\n    void init() {  \n        for (int i = 0; i < 26; i++) {  \n            a[i][i] = 1;  \n        }  \n        return;  \n    }  \n\n    Matrix operator*(const Matrix& b) const {  \n        Matrix res;  \n        for (int i = 0; i < 26; i++) {  \n            for (int j = 0; j < 26; j++) {  \n                for (int k = 0; k < 26; k++) {  \n                    res.a[i][j] = (res.a[i][j] + a[i][k] * b.a[k][j]) % mod;  \n                }  \n            }  \n        }  \n        return res;  \n    }  \n};\n\n\nMatrix qpow(Matrix a, int n) {\n    Matrix res; res.init();\n    while (n) {\n        if (n & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        n >>= 1;\n    }\n    return res;\n}\n\n\nint dijstra(vector<vector<int>>& grid) {\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n    int n = grid.size(), m = grid[0].size();\n    vector<vector<int>> vis(n, vector<int>(m, INT_MAX));\n    int dxy[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    vis[0][0] = 0;\n    q.push({0, 0});\n    while (!q.empty()) {\n        auto [v, idx] = q.top(); q.pop();\n        int x = idx/m, y = idx % m;\n\n        for (int i = 0; i < 4; i++) {\n            int xx = x + dxy[i][0];\n            int yy = y + dxy[i][1];\n\n            if (xx < 0 || yy >= m || xx >= n || yy < 0) continue;\n            int mx = max(vis[x][y], grid[xx][yy]) + 1 + (x + y) % 2;\n            if (vis[xx][yy] > mx) {\n                vis[xx][yy] = mx;\n                q.push({vis[xx][yy], xx*m + yy});\n            }\n        }\n    }\n\n    return vis[n - 1][m - 1];\n}\n\nvector<vector<int>> floyd(int n, vector<vector<int>>& edges) {\n    vector<vector<int>> g(n, vector<int>(n, INT_MAX/2));\n    vector<vector<int>> dis(n + 1, vector<int>(n + 1));\n\n    for (auto &e : edges) {\n        g[e[0]][e[1]] = g[e[1]][e[0]] = e[2];\n    }\n\n    dis = g;\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dis[i][j] = fmin(dis[i][j], dis[i][k] + dis[k][j]);\n            }\n        }\n    }\n\n    return dis;\n}\n\n/*\nint isPrime[100001];\n//int prime[5000001];\n\nauto init_Prime = [] {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    vector<int> primes;\n    // memset(isPrime, 0, sizeof(isPrime));\n    isPrime[0] = isPrime[1] = 1;\n    for (int i = 2; i <= 100000; i++) {\n        if (isPrime[i] == 0) {\n            primes.push_back(i);\n        }\n\n        for (int j = 0; j < primes.size() && i * primes[j] <= 100000; j++) {\n            isPrime[i * primes[j]] = 1;\n            if (i % primes[j] == 0) {\n                break;\n            }\n        }\n    }\n\n//    for (int i = 1; i <= 100000; i++) {\n//        prime[i] = prime[i - 1];\n//        if (isPrime[i - 1] == 0) prime[i]++;\n//    }\n\n    return 0;\n}();\n*/\n\n\nstatic vector<int> getNext(const string& str) {\n    int n = (int)str.size();\n    vector<int> next(n);\n    int j = 0;\n    for (int i = 1; i < n; i++) {\n        while (j > 0 && str[i] != str[j]) {\n            j = next[j - 1];\n        }\n        if (str[i] == str[j]) {\n            j++;\n            next[i] = j;\n        }\n    }\n    return next;\n}\n\nstatic vector<int> kmp(const string& a, const string& b) {\n    if (a.size() < b.size()) {\n        return {};\n    }\n    int n = (int)a.size();\n    int m = (int)b.size();\n    vector<int> res;\n    vector<int> next = getNext(b);\n    for (int i = 0, j = 0; i < n; i++) {\n        while (j - 1 >= 0 && a[i] != b[j]) {\n            j = next[j - 1];\n        }\n        if (a[i] == b[j]) {\n            j++;\n        }\n        if (j == m) {\n            res.push_back(i - j + 1);\n            j = next[j - 1]; \n        }\n    }\n    return res;\n}\n\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst long long base1 = uniform_int_distribution<>(8e8, 9e8)(rng);\nconst long long base2 = uniform_int_distribution<>(8e8, 9e8)(rng);\n\nstruct stringhash {\n    string s;\n    long long mod1 = 1e9 + 7, mod2 = 998244353, n;\n//    long long  base1 = 131, base2 = 13131;\n    vector<long long> hash1;\n    vector<long long> hash2;\n    vector<long long> hash3;\n    vector<long long> hash4;\n    vector<long long> p1;\n    vector<long long> p2;\n    void init(string str){\n    \tios::sync_with_stdio(false);  \n\t\tcin.tie(0), cout.tie(0);\n        str = \" \" + str;\n        n = str.size() - 1;\n        hash1.resize(n + 1, 0);\n        hash2.resize(n + 1, 0);\n        hash3.resize(n + 2, 0);\n        hash4.resize(n + 2, 0);\n        p1.resize(n + 1, 0);\n        p2.resize(n + 1, 0);\n        s = str;\n        p1[0] = p2[0] = 1;\n        for(int i = 1; i <= n; i++){\n            p1[i] = p1[i - 1] * base1 % mod1;\n            p2[i] = p2[i - 1] * base2 % mod2;\n            hash1[i] = (hash1[i - 1] * base1 + (s[i] - 'a')) % mod1;\n            hash2[i] = (hash2[i - 1] * base2 + (s[i] - 'a')) % mod2;\n        }\n        for(int i = n; i >= 1; i--){\n            hash3[i] = (hash3[i + 1] * base1 + (s[i] - 'a')) % mod1;\n            hash4[i] = (hash4[i + 1] * base2 + (s[i] - 'a')) % mod2;\n        }\n    }\n    \n//    pair<long long, long long> getz(int l, int r){\n//        if(r < l){\n//            assert(0);\n//        }\n//        long long res1 = ((hash1[r] - hash1[l - 1] * p1[r - l + 1]) % mod1 + mod1) % mod1;\n//        long long res2 = ((hash2[r] - hash2[l - 1] * p2[r - l + 1]) % mod2 + mod2) % mod2;\n//        return {res1, res2};\n//    }\n//    pair<long long, long long> getf(int l, int r){\n//        if(r < l){\n//            assert(0);\n//        }\n//        long long res1 = ((hash3[l] - hash3[r + 1] * p1[r - l + 1]) % mod1 + mod1) % mod1;\n//        long long res2 = ((hash4[l] - hash4[r + 1] * p2[r - l + 1]) % mod2 + mod2) % mod2;\n//        return {res1, res2};\n//    }\n    \n    long long getz(int l, int r){\n        if(r < l){\n            assert(0);\n        }\n        long long res1 = ((hash1[r] - hash1[l - 1] * p1[r - l + 1]) % mod1 + mod1) % mod1;\n        long long res2 = ((hash2[r] - hash2[l - 1] * p2[r - l + 1]) % mod2 + mod2) % mod2;\n        long long res = ((res1 << 32) | res2);\n        return res;\n    }\n    long long getf(int l, int r){\n        if(r < l){\n            assert(0);\n        }\n        long long res1 = ((hash3[l] - hash3[r + 1] * p1[r - l + 1]) % mod1 + mod1) % mod1;\n        long long res2 = ((hash4[l] - hash4[r + 1] * p2[r - l + 1]) % mod2 + mod2) % mod2;\n        long long res = ((res1 << 32) | res2);\n        return res;\n    }\n};\n\nstruct Trie {\n\tbool isEnd;\n    Trie* children[26];\n    \n    Trie() {\n        isEnd = false;\n        memset(children, 0, sizeof(children));\n    }\n\n    void TrieInsert(const string &word) {\n        Trie* node = this;\n        for (char c : word) {\n            if (node->children[c - 'a'] == NULL) {\n                node->children[c - 'a'] = new Trie();\n            }\n            node = node->children[c - 'a'];\n        }\n\n        node->isEnd = true;\n        return;\n    }\n\n    bool TrieSearch(const string &word) {\n        Trie* node = this;\n        for (char c : word) {\n            if (node->children[c - 'a'] == NULL)\n                return false;\n            node = node->children[c - 'a'];\n        }\n\n        return node->isEnd;\n    }\n};\n\n\nclass FenwickTree {\n    vector<int> tree;\npublic :\n    FenwickTree(int n) : tree(n + 1) {}\n\n    void update(int i, int val) {\n        for (; i < tree.size(); i += i & -i) {\n            tree[i] += val;\n        }\n        return ;\n    } \n\n    int query(int i) {\n        int sum = 0;\n        for (; i > 0; i -= i & -i) {\n            sum += tree[i];\n        }\n        return sum;\n    }\n};\n\nint dfs_child_count(vector<vector<int>>& g, int x, int fa) {\n    int ret = 1;\n\n    for (int y : g[x]) {\n        if (y != fa) {\n            ret += dfs_child_count(g, y, x);\n        }\n    }\n\n    return ret;\n}\n\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int ans = 1;\n        vector<map<int, int>> g(n);\n\n        for (int i = 0; i < n; i++) {\n            g[i][nums[i]]++;\n        }\n\n        bool ff = true;\n        for (int i = 0; i < n; i++) {\n            if (g[i].find(0) == g[i].end()) {\n                ff = false;\n                break;\n            }\n        }\n\n        if (ff == true) return 0;\n\n        for (auto &q : queries) {\n            int l = q[0], r = q[1], val = q[2];\n            for (int i = l; i <= r; i++) {\n                for (auto &[u, v] : g[i]) {\n                    g[i][u - val]++;\n                }\n            }\n\n            bool f = true;\n            for (int i = 0; i < n; i++) {\n                if (g[i].find(0) == g[i].end()) {\n                    f = false;\n                    break;\n                }\n            }\n\n            if (f == true) return ans;\n            ans++;\n        }\n\n        return -1;\n    }\n};","author":"silent","submissionId":"611257637"},[]]},{"1967":[{"id":"1967","fileName":"611257669.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), q = queries.size();\n        if(accumulate(nums.begin(), nums.end(), 0) == 0) {\n            return 0;\n        }\n        vector<vector<int>> dp(n, vector<int>(1010));\n        for(int i = 0; i < n; i ++) dp[i][0] = 1;\n        for(int i = 0; i < q; i ++) {\n            int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n            for(int k = l; k <= r; k ++) {\n                for(int j = nums[k]; j >= v; j --) {\n                    dp[k][j] |= dp[k][j - v];\n                }\n            }\n            int cnt = 0;\n            for(int j = 0; j < n; j ++) {\n                if(dp[j][nums[j]] == 1) cnt ++;\n            }\n            if(cnt == n) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"zouyu","submissionId":"611257669"},[]]},{"1968":[{"id":"1968","fileName":"611257693.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int ans = -1;\n        for (int k = 0; k < nums.length; k++) {\n            if (0 == nums[k]) {\n                continue;\n            }\n            ArrayList<Integer> list = new ArrayList<>();\n            for (int m = 0; m < queries.length; m++) {\n                if (k <= queries[m][1] && queries[m][0] <= k) {\n                    list.add(m);\n                }\n            }\n            HashMap<Integer, Integer> hashMap = getIntegerHashMap(nums, queries, list, k);\n            if (!hashMap.containsKey(nums[k])) {\n                return -1;\n            }\n            ans = Math.max(hashMap.get(nums[k]), ans);\n        }\n        if (ans == -1) {\n            long count = Arrays.stream(nums).filter(num -> num != 0).count();\n            if (count > 0) {\n                return -1;\n            }\n            return 0;\n        }\n        ans += 1;\n        return ans;\n    }\n\n    public HashMap<Integer, Integer> getIntegerHashMap(int[] nums, int[][] queries,\n                                                       ArrayList<Integer> list, int k) {\n        HashMap<Integer, Integer> hashMap = new HashMap<>();\n        hashMap.put(0, -1);\n        for (int num : list) {\n            HashMap<Integer, Integer> tempMap = new HashMap<>(hashMap);\n            for (Map.Entry<Integer, Integer> key : hashMap.entrySet()) {\n                int tempAns = key.getKey() + queries[num][2];\n                if (tempAns > nums[k]) {\n                    continue;\n                }\n                int max = Math.max(key.getValue(), num);\n                boolean containsKey = tempMap.containsKey(tempAns);\n                if (!containsKey || max < tempMap.get(tempAns)) {\n                    tempMap.put(tempAns, max);\n                }\n            }\n            hashMap = tempMap;\n        }\n        return hashMap;\n    }\n}","author":"Java攻城狮","submissionId":"611257693"},[]]},{"1969":[{"id":"1969","fileName":"611257573.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        int len = 0;\n        int vit[10]{};\n        for (int i = 0; i < n; ++i) if (nums[i] == 0) len++, vit[i] = 1;\n        if (len == n) return 0;\n        bitset<2000> a[10];\n        for (int i = 0; i < n; ++i) a[i][0] = 1;\n        for (int i = 0; i < m; ++i) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for (int j = l; j <= r; ++j) {\n                if (!vit[j]) {\n                    auto t = a[j];\n                    a[j] <<= val;\n                    a[j] |= t;\n                    a[j][val] = 1;\n                    if (a[j][nums[j]] == 1) {\n                        vit[j] = 1;\n                        len++;\n                    }   \n                }\n            }\n            if (len == n) return i + 1;\n        }\n        return -1;\n    }\n};","author":"RnFreno","submissionId":"611257573"},[]]},{"1970":[{"id":"1970","fileName":"611257790.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n,m=len(nums),len(queries)\n        dp=[set([0]) for _ in range(n)]\n        if all(nums[i] in dp[i] for i in range(n)):\n            return 0\n        for i,(l,r,v) in enumerate(queries):\n            for j in range(l,r+1):\n                dp[j]|={x+v for x in dp[j]} \n            if all(nums[i] in dp[i] for i in range(n)):\n                return i+1\n        return -1\n","author":"情初","submissionId":"611257790"},[]]},{"1971":[{"id":"1971","fileName":"611257766.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        cnt = 1\n        n = len(nums)\n        flag = True\n        for i in range(n):\n            if nums[i] != 0:\n                flag = False\n        if flag:\n            return 0\n        dp = [[10000 for _ in range(max(nums) + 1)] for _ in range(len(nums))]\n        for i in range(n):\n            dp[i][nums[i]] = 0\n        for l,r,val in queries:\n            for i in range(l,r+1):\n                for j in range(val,nums[i] + 1):\n                    if dp[i][j] != 10000:\n                        dp[i][j - val] = min(dp[i][j - val],cnt)\n            flag = True\n            for i in range(len(nums)):\n                if dp[i][0] == 10000:\n                    flag = False\n                    break\n            if flag:\n                return cnt\n            cnt += 1\n        return -1\n        ","author":"伏波落木","submissionId":"611257766"},[]]},{"1972":[{"id":"1972","fileName":"611257817.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, m = len(nums), len(queries)\n        idx = defaultdict(list)\n        for j, [x, y, v] in enumerate(queries):\n            for i in range(x, y + 1):\n                idx[i].append([v, j])\n\n        def calc(arr, target):\n            if target == 0: return 0\n            if len(arr) == 0: return -1\n            na = len(arr)\n            dp = [[0] * (target + 1) for _ in range(na)]  # 前i项子序列和为j的是否可能\n            dp[0][0] = 1\n            if arr[0][0] <= target:\n                dp[0][arr[0][0]] = 1\n                if arr[0][0] == target:\n                    return arr[0][1] + 1\n            for i in range(1, na):\n                dp[i] = dp[i - 1][:]\n                x = arr[i][0]\n                for j in range(target + 1):\n                    dp[i][j] = dp[i - 1][j]\n                    if dp[i][j]: continue\n                    if j >= x and dp[i - 1][j - x]:\n                        dp[i][j] = 1\n                        if j == target:\n                            return arr[i][1] + 1\n            return -1\n\n        ans = 0\n        for i, x in enumerate(nums):\n            v = calc(idx[i], x)\n            if v == -1: return -1\n            ans = max(ans, v)\n        return ans\n        ","author":"Sun","submissionId":"611257817"},[]]},{"1973":[{"id":"1973","fileName":"611257847.txt","sourceCode":"class Solution {\npublic:\n    bool subsetSum(const vector<int>& nums, int target) {\n    // dp[i] 表示是否存在一个子集，其元素和恰好等于 i\n    std::vector<bool> dp(target + 1, false);\n    dp[0] = true; // 空集的和为 0\n\n    for (int num : nums) {\n        for (int i = target; i >= num; --i) {\n            if (dp[i - num]) {\n                dp[i] = true;\n            }\n        }\n    }\n\n    return dp[target];\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        // 二分查找寻找 k\n        int n = nums.size();\n        auto check = [&](int k) {\n            vector<vector<int>> storeVals(n, vector<int>());\n            for (int i = 0; i < k; i++) {\n                for (int j = queries[i][0]; j <= queries[i][1]; j++) {\n                    storeVals[j].push_back(queries[i][2]);\n                }\n            }\n    \n            for (int i = 0; i < n; i++) {\n                if (!subsetSum(storeVals[i], nums[i])) {\n                    return false;\n                }\n            }\n    \n            return true;\n        };\n    \n        int left = 0, right = queries.size();\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            if(check(mid)){\n                right = mid - 1;\n            }\n            else{\n                left = mid + 1;\n            }\n        }\n    \n        return right + 1 == queries.size() + 1? -1 : right + 1;\n    }\n};","author":"WWWeeds","submissionId":"611257847"},[]]},{"1974":[{"id":"1974","fileName":"611256874.txt","sourceCode":"func minZeroArray(nums []int, queries [][]int) int {\n    n:=len(nums)\n    arr:=make([][]int,n)\n    sum:=make([]int,n)\n    total:=0\n    for _,v:=range nums{\n        total+=v\n    }\n    if total==0{\n        return 0\n    }\n    for i,v:=range queries{\n        for j:=v[0];j<=v[1];j++{\n            arr[j]=append(arr[j],v[2])\n            sum[j]+=v[2]\n        }\n        success:=true\n        for h:=0;h<n;h++{\n            if sum[h]<nums[h]{\n                success=false\n                break\n            }else if sum[h]==nums[h]{\n                continue\n            }\n            if !can(arr[h],nums[h]){\n                success=false\n                break\n            }\n        }\n        if success{\n            return i+1\n        }\n    }\n    return -1\n}\n\nfunc can(arr []int,target int)bool{\n    n:=len(arr)\n    dp:=make([][]bool,n+1)\n    for i:=0;i<=n;i++{\n        dp[i]=make([]bool,target+1)\n        dp[i][0]=true\n    }\n    for i:=1;i<=n;i++{\n        for j:=1;j<=target;j++{\n            if j>=arr[i-1]{\n                dp[i][j]=dp[i-1][j] || dp[i-1][j-arr[i-1]]\n            }else{\n                dp[i][j]=dp[i-1][j]\n            }\n        }\n    }\n    return dp[n][target]\n}","author":"cpkqxpgg","submissionId":"611256874"},[]]},{"1975":[{"id":"1975","fileName":"611257889.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& ns, vector<vector<int>>& qs) {\n        int n=ns.size();\n        int m=qs.size();\n        vector<vector<vector<int>>> tt(n+1);\n        for(int i=0;i<m;i++){\n            int l=qs[i][0],r=qs[i][1];\n            for(int j=l;j<=r;j++){\n                tt[j].push_back({qs[i][2],i});\n            }\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            vector<vector<int>> dp(2,vector<int>(1e4+100));\n            dp[0][0]=1;\n            int res=1100;\n            if(ns[i]==0){\n                continue;\n            }\n            int tn=tt[i].size();\n            for(int j=0;j<tn;j++){\n                int v=tt[i][j][0];\n                for(int k=0;k<=ns[i];k++){\n                    if(dp[0][k]){\n                        dp[1][k+v]=1;\n                    }\n                }\n                for(int k=0;k<=ns[i];k++){\n                    dp[0][k]=max(dp[1][k],dp[0][k]);\n                    dp[1][k]=0;\n                }\n                if(dp[0][ns[i]]){\n                    res=tt[i][j][1]+1;\n                    break;\n                }\n            }\n            ans=max(ans,res);\n            \n        }\n        if(ans>1000)ans=-1;\n        return ans;\n    }\n};","author":"youk","submissionId":"611257889"},[]]},{"1976":[{"id":"1976","fileName":"611257921.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int a,b,c,d,e,f,g,h,j,k;\n        a=nums.size();\n        b=queries.size();\n        vector<bool> can(a);\n        bool fl=true;\n        for(c=0;c<a;c++)\n            {\n                if(nums[c]==0)\n                    can[c]=true;\n                else\n                    fl=false;\n            }\n        if(fl)\n            return 0;\n        vector<vector<bool>> dp(a);\n        for(c=0;c<a;c++)\n            {\n                if(!can[c])\n                {\n                    dp[c].resize(nums[c]+1);\n                    dp[c][0]=true;\n                }\n            }\n        for(c=0;c<b;c++)\n            {\n                for(d=queries[c][0];d<=queries[c][1];d++)\n                    {\n                        if(!can[d])\n                        {\n                            for(e=nums[d];e>=1;e--)\n                                {\n                                    if(e-queries[c][2]<0)\n                                            break;\n                                    if(!dp[d][e] && dp[d][e-queries[c][2]])\n                                        dp[d][e]=true;\n                                }\n                            if(dp[d][nums[d]])\n                                    can[d]=true;\n                        }\n                    }\n                for(d=0;d<a;d++)\n                    {\n                        if(!can[d])\n                            break;\n                    }\n                if(d>=a)\n                        break;\n            }\n        if(c<b)\n            return c+1;\n        return -1;\n    }\n};","author":"Wilbert","submissionId":"611257921"},[]]},{"1977":[{"id":"1977","fileName":"611257943.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n=len(nums)\n        count=sum(int(i==0) for i in nums)\n        zeros=[i==0 for i in nums ]\n        dp=[[nums[i]] for i in range(n)]\n        if count==n:\n            return 0\n        for i in range(len(queries)):\n            l,r,v=queries[i]\n            for j in range(l,r+1):\n                if zeros[j]:\n                    continue\n                nx=[]\n                for k in dp[j]:\n                    if k-v==0:\n                        count+=1\n                        zeros[j]=True\n                        break\n                    if k not in nx:\n                        nx.append(k)\n                    if k-v>0 and k-v not in nx:\n                        nx.append(k-v)\n                dp[j]=nx\n            # print(count,dp)\n            if count==n:\n                return i+1\n        return -1","author":"hajiao3","submissionId":"611257943"},[]]},{"1978":[{"id":"1978","fileName":"611258390.txt","sourceCode":"func minZeroArray(nums []int, queries [][]int) int {\n\ttheRes := 0\n\tfor index, v := range nums {\n\t\tt := f(v, index, queries)\n\t\tif t == -1 {\n\t\t\treturn -1\n\t\t} else {\n\t\t\ttheRes = max(theRes, t)\n\t\t}\n\t}\n\treturn theRes\n}\n\nfunc f(x, index int, queries [][]int) int {\n\tif x == 0 {\n\t\treturn 0\n\t}\n\n\ttheMap := map[int]bool{}\n\ttheMap[x] = true\n\tfor i, q := range queries {\n\t\tif q[0] <= index && index <= q[1] {\n\t\t\tkeys := make([]int, 0, len(theMap))\n\t\t\tfor k := range theMap {\n\t\t\t\tkeys = append(keys, k)\n\t\t\t}\n\t\t\tfor _, v := range keys {\n\t\t\t\tif v-q[2] >= 0 {\n\t\t\t\t\ttheMap[v-q[2]] = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif theMap[0] {\n\t\t\treturn i + 1\n\t\t}\n\t}\n\treturn -1\n}\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\nfunc abs(a int) int {\n\tif a > 0 {\n\t\treturn a\n\t}\n\treturn -a\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n","author":"cyldsyp1","submissionId":"611258390"},[]]},{"1979":[{"id":"1979","fileName":"611258088.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        m, n = max(nums), len(nums)\n        if all(nums[i] == 0 for i in range(n)):\n            return 0\n        f = [[True] + [False]*(m) for _ in range(n)]\n        \n        for idx, (l,r,t) in enumerate(queries):\n            for j in range(l, r+1):\n                for k in range(m, 0, -1):\n                    if k - t >= 0:\n                        f[j][k] |= f[j][k-t]\n                    \n            if all(f[i][x] for i,x in enumerate(nums)):\n                return idx+1\n        return -1","author":"活力喵饭","submissionId":"611258088"},[]]},{"1980":[{"id":"1980","fileName":"611258378.txt","sourceCode":"from copy import deepcopy\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        # dp[k][i][m] k次操作(执行了queries[k-1])后，第i个位置 可能的值一栏\n        n = len(nums)\n        kmax = len(queries) + 1\n        dp = [set() for _  in range(n)] # for _ in range(kmax)]\n        found = [False] * n\n        #foundcnt = 0\n        # 初始化\n        for i in range(n):\n            dp[i].add(nums[i])\n            if nums[i] == 0:\n                found[i] = True\n                #foundcnt += 1\n        if all(found):\n            return 0\n        for k in range(1, kmax): #1000\n            l, r, v = queries[k-1]\n            for j in range(l, r+1): #10\n                if found[j] == True:\n                    continue\n                oldset = dp[j].copy()\n                for cur_val in oldset: #1000\n                    new_val = cur_val - v\n                    if new_val == 0:\n                        #foundcnt += 1\n                        found[j] = True\n                    if new_val > 0:\n                        dp[j].add(new_val)\n            if all(found):\n                return k\n        return -1\n                    \n                \n        \n        \n        ","author":"叶刃","submissionId":"611258378"},[]]},{"1981":[{"id":"1981","fileName":"611258422.txt","sourceCode":"class Solution {\npublic:\nint func1(vector<int>& nums,int index, vector<vector<int>>& queries) {\n    unordered_set<int>q;\n    q.insert(nums[index]);\n    if(nums[index]==0)return 0;\n    for(int i=0;i<queries.size();++i){\n        int l=queries[i][0];\n        int r=queries[i][1];\n        int val=queries[i][2];\n        if(index>=l&&index<=r){\n            int cnt=q.size();\n            unordered_set<int>q1;\n            for(auto tt:q){\n                if(tt==0 || tt-val==0)return i+1;\n                q1.insert(tt);\n                q1.insert(tt-val);\n            }\n            q=q1;\n        }\n    }\n    return -1;\n}\n\n\n\nint minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    int res=0;\n    for(int i=0;i<nums.size();++i){\n        int val=func1(nums, i, queries);\n        if(val==-1)return -1;\n        res=max(val,res);\n    }\n    return res;\n    \n}\n\n};","author":"light","submissionId":"611258422"},[]]},{"1982":[{"id":"1982","fileName":"611258119.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], q: List[List[int]]) -> int:\n        n=len(nums)\n        ans=0\n        for i in range(n):\n            e=nums[i]\n            if e==0:continue\n            state=1\n            st=0\n            for a,b,val in q:\n                st+=1\n                if a<=i<=b:\n                    state|=(state<<val)\n                else:continue\n                state&=(1<<(e+1))-1\n                if (state>>e)&1:\n                    ans=max(ans,st)\n                    break\n            if (state>>e)&1==0:return -1\n        return ans","author":"audience","submissionId":"611258119"},[]]},{"1983":[{"id":"1983","fileName":"611258515.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        ans = 0\n        for i in range(n):\n            dp = 1\n            ok = False\n            if nums[i] == 0:\n                ans = max(ans, 0)\n                continue\n            for j in range(len(queries)):\n                l, r, val = queries[j]\n                if l <= i <= r:\n                    dp = dp | (dp << val)\n                    dp &= ((1 << (nums[i] + 1)) - 1)\n                    if dp >> nums[i] & 1 == 1:\n                        ans = max(ans, j + 1)\n                        ok = True\n                        break\n            if ok == False:\n                return -1\n        return ans\n                ","author":"Charles_H","submissionId":"611258515"},[]]},{"1984":[{"id":"1984","fileName":"611258410.txt","sourceCode":"func minZeroArray(nums []int, queries [][]int) int {\n    ans := 0\n    for x, num := range nums {\n        if num == 0 {\n            continue\n        }\n        vals := make([][2]int, 0)\n        for i, query := range queries {\n            l, r, val := query[0], query[1], query[2]\n            if l <= x && r >= x {\n                vals = append(vals, [2]int{val, i})\n            }\n        }\n        m := len(vals)\n        // f[i][j] 表示，使用前i个vals，将num减为j是否可行\n        f := make([][]bool, m+1)\n        for i := 0; i <= m; i++ {\n            f[i] = make([]bool, num+1)\n        }\n        f[0][num] = true\n        res := math.MaxInt\n        for i := 1; i <= m; i++ {\n            for j := 0; j <= num; j++ {\n                f[i][j] = f[i-1][j]\n                if j + vals[i-1][0] <= num {\n                    f[i][j] = f[i][j] || f[i-1][j+vals[i-1][0]]\n                }\n            }\n            if f[i][0] {\n                res = vals[i-1][1]\n                break\n            }\n        }\n        if res == math.MaxInt {\n            return -1\n        }\n        ans = max(ans, res+1)\n    }\n    return ans\n}","author":"zhangliangpeng","submissionId":"611258410"},[]]},{"1985":[{"id":"1985","fileName":"611258880.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size(), mx = nums[0];\n        for(int v: nums) mx = max(mx, v);\n\n\n        vector<bool> A(mx + 1, 0);\n        int k = 0;\n        for(int i = 0; i < n; ++i){\n            if(nums[i] == 0) continue;\n            fill(A.begin(), A.begin() + nums[i] + 1, 0);\n            for(int j = 0; j < m; ++j){\n                int v = 0;\n                if(queries[j][0] <= i && queries[j][1] >= i) v = queries[j][2];\n                for(int k = nums[i]; k - v >= 0; --k) A[k] = A[k] | A[k - v];\n                A[v] = 1;\n                if(A[nums[i]] == 1) {\n                    k = max(k, j + 1);\n                    break;\n                }\n                else if(j + 1 == m) return -1;\n            }\n        }\n        return k;\n    }\n};","author":"IN0vation","submissionId":"611258880"},[]]},{"1986":[{"id":"1986","fileName":"611258720.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        bool allzero = true;\n        for (int i = 0; i < n;i++){\n            if(nums[i] != 0){\n                allzero = false;\n                break;\n            }\n        }\n\n        if(allzero){\n            return 0;\n        }\n        bool f[2][12][1006];\n        memset(f, false, sizeof(f));\n        for (int i = 0; i < n;i++){\n            f[0][i][0] = true;\n            f[1][i][0] = true;\n        }\n        for (int k = 0;k<(int)queries.size();k++){\n            for (int i = queries[k][0];i<=queries[k][1];i++){\n                for(int j = 0;j<=nums[i];j++){\n                    if(j - queries[k][2] < 0){\n                        continue;\n                    }\n                    f[1][i][j] |= f[0][i][j - queries[k][2]];\n                }\n                \n            }\n            for(int i = 0;i<n;i++){\n                for(int j = 0;j<=nums[i];j++){\n                    f[0][i][j] = f[1][i][j];\n                }\n            }\n            bool zero = true;\n            for (int i = 0; i < n;i++){\n                if(!f[1][i][nums[i]]){\n                    zero = false;\n                    break;\n                }\n            }\n\n            if(zero){\n                return k+1;\n            }\n        }\n        return -1;\n    }\n};","author":"A-SOUL_Official","submissionId":"611258720"},[]]},{"1987":[{"id":"1987","fileName":"611258863.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        boolean[] bb=new boolean[nums.length];\n        int res=0;\n        int a=0;\n        for (int i = 0; i < nums.length; i++) {\n            if(nums[i]!=0) {\n                a++;\n                continue;\n            }\n            bb[i]=true;\n            res++;\n        }\n        if(a==0) return 0;\n\n        Set<Integer>[] sets=new Set[nums.length];\n        for (int i = 0; i < sets.length; i++) {\n            sets[i]=new HashSet<>();\n            sets[i].add(0);\n        }\n        for(int i=0;i<queries.length;i++){\n            int t=queries[i][2];\n            for(int l=queries[i][0];l<=queries[i][1];l++){\n                if (bb[l]) continue;\n                Set<Integer> set=sets[l];\n                List<Integer> list=new ArrayList<>();\n                list.add(t);\n                for (Integer integer : set) {\n                    list.add(integer+t);\n                }\n                set.addAll(list);\n                if(set.contains(nums[l])){\n                    bb[l]=true;\n                    res++;\n                }\n            }\n            if(res==nums.length) return i+1;\n        }\n        return -1;\n    }\n}","author":"阳光大男孩","submissionId":"611258863"},[]]},{"1988":[{"id":"1988","fileName":"611259182.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] a, int[][] queries) {\n        int n = a.length; //10\n        int m = queries.length; // 1000\n        int s = 0;\n        for(int x : a) {\n            s += x;\n        }\n        if(s == 0) {\n            return 0;\n        }\n        \n        boolean dp[][][] = new boolean[n][m][1001];\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<m; j++) {\n                dp[i][j][0] = true;\n            }\n        }\n        for(int i=0; i<n; i++) {\n            int l = queries[0][0];\n            int r = queries[0][1];\n            int val = queries[0][2];\n            if(i >= l && i <= r && a[i]-val >= 0) {\n                dp[i][0][val] = true;\n            }\n        }\n        \n        for(int i=0; i<n; i++) {\n            for(int j=1; j<m; j++) {\n                for(int v=1; v<=a[i]; v++) {\n                    if(dp[i][j-1][v]) {\n                        dp[i][j][v] = true;\n                        continue;\n                    }\n                    int l = queries[j][0];\n                    int r = queries[j][1];\n                    int val = queries[j][2];\n                    if(i >= l && i <= r && v-val >= 0) {\n                        if(dp[i][j-1][v-val]) {\n                            dp[i][j][v] = true;\n                        }\n                    } else {\n                        dp[i][j][v] = dp[i][j-1][v];\n                    }\n                }\n            }\n        } \n\n        int res = -1;\n        for(int i=0; i<n; i++) {\n            boolean ok = false;\n            for(int j=0; j<m; j++) {\n                if(dp[i][j][a[i]]) {\n                    res = Math.max(res, j);\n                    ok = true;\n                    break;\n                }\n            }\n            if(!ok) {\n                return -1;\n            }\n        }\n        return res == -1 ? -1 : res+1;\n    }\n}","author":"KaiShen","submissionId":"611259182"},[]]},{"1989":[{"id":"1989","fileName":"611259208.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        unordered_map<int,unordered_set<int>> poss_valve;\n        unordered_set<int> tmp;\n        bool flag = false;\n        \n        for(int i=0; i<nums.size(); i++){\n            poss_valve[i] = {0};\n            if(nums[i] != 0) flag = true;\n        }\n        \n        if(flag == false) return 0;\n        \n        for(int k=0; k<queries.size(); k++){\n            for(int i=queries[k][0]; i<=queries[k][1]; i++){\n                tmp.clear();\n                for(auto num : poss_valve[i]){\n                    tmp.insert(num + queries[k][2]);\n                }\n                poss_valve[i].insert(tmp.begin(), tmp.end());\n            }\n            bool flag = true;\n            for(int i=0; i<nums.size(); i++){\n                if(poss_valve[i].find(nums[i]) == poss_valve[i].end()){\n                    flag = false;\n                }\n            }\n            if(flag == true) return k+1;\n        }\n\n        return -1;\n    }\n};","author":"Mathews","submissionId":"611259208"},[]]},{"1990":[{"id":"1990","fileName":"611259223.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        vector<vector<int>> cover(n);\n        for (int i = 0; i < q; ++i) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            for (int j = l; j <= r; ++j) {\n                if (j >= 0 && j < n) {\n                    cover[j].push_back(i);\n                }\n            }\n        }\n\n        vector<int> max_ijs(n, -1);\n        for (int j = 0; j < n; ++j) {\n            int target = nums[j];\n            if (target == 0) {\n                max_ijs[j] = -1;\n                continue;\n            }\n            unordered_map<int, int> dp;\n            dp[0] = -1;\n\n            for (int i : cover[j]) {\n                int val = queries[i][2];\n                unordered_map<int, int> new_entries;\n\n                for (auto& [s, i_prev] : dp) {\n                    int s_new = s + val;\n                    if (dp.find(s_new) == dp.end()) {\n                        new_entries[s_new] = i;\n                    }\n                }\n\n                for (auto& [s_new, i_new] : new_entries) {\n                    dp[s_new] = i_new;\n                }\n            }\n\n            if (dp.find(target) != dp.end()) {\n                max_ijs[j] = dp[target];\n            } else {\n                return -1;\n            }\n        }\n\n        int k = 0;\n        for (int j = 0; j < n; ++j) {\n            if (nums[j] != 0) {\n                k = max(k, max_ijs[j] + 1);\n            }\n        }\n        return k;\n    }\n};","author":"Takamiya","submissionId":"611259223"},[]]},{"1991":[{"id":"1991","fileName":"611259200.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        \n\n        ret = 0\n        m = len(queries)\n        for i, num in enumerate(nums):\n            if num > 0:\n                dp = [0] * (num + 1)\n                dp[num] = 1\n                \n                for j in range(m):\n                    l, r, v = queries[j]\n                    if l <= i <= r and v <= num:\n                        for k in range(num + 1):\n                            if k + v < num + 1 and dp[k + v]:\n                                dp[k] = 1\n                        if dp[0]:\n                            \n                            ret = max(ret, j + 1)\n                            break\n                            \n                        \n                    else:\n                        continue\n\n                if not dp[0]:\n                    return -1\n\n                \n        return ret","author":"下次认真取名","submissionId":"611259200"},[]]},{"1992":[{"id":"1992","fileName":"611259228.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        vector<vector<pair<int, int>>> cover(n);\n        \n        // 预处理每个元素的覆盖查询\n        for (int j = 0; j < q; ++j) {\n            int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n            if (l > r) continue; // 跳过无效区间\n            l = max(l, 0);\n            r = min(r, n - 1);\n            for (int i = l; i <= r; ++i) {\n                cover[i].emplace_back(val, j);\n            }\n        }\n        \n        int max_k = -1;\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == 0) continue;\n            \n            auto& queries_i = cover[i];\n            if (queries_i.empty()) return -1;\n            \n            // 按查询索引升序排序\n            sort(queries_i.begin(), queries_i.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n                return a.second < b.second;\n            });\n            \n            // 计算val的GCD\n            int g = 0;\n            for (const auto& p : queries_i) {\n                g = gcd(g, p.first);\n            }\n            if (nums[i] % g != 0) return -1;\n            \n            // 动态规划找子集和\n            unordered_map<int, int> dp;\n            dp[0] = -1; // 初始状态，和为0时不需要任何查询\n            for (const auto& [valj, j] : queries_i) {\n                unordered_map<int, int> tmp;\n                for (const auto& [s, current_max] : dp) {\n                    int new_s = s + valj;\n                    if (new_s > nums[i]) continue;\n                    int new_max = max(current_max, j);\n                    if (tmp.find(new_s) == tmp.end() || new_max < tmp[new_s]) {\n                        tmp[new_s] = new_max;\n                    }\n                }\n                // 合并tmp到dp\n                for (const auto& [s, m] : tmp) {\n                    if (dp.find(s) == dp.end() || m < dp[s]) {\n                        dp[s] = m;\n                    }\n                }\n            }\n            \n            if (dp.find(nums[i]) == dp.end()) return -1;\n            int current_k = dp[nums[i]] + 1; // k需要大于等于最大索引+1\n            max_k = max(max_k, current_k);\n        }\n        \n        // 处理所有元素都是0的情况\n        return max_k == -1 ? 0 : max_k;\n    }\n};","author":"斟晚秋","submissionId":"611259228"},[]]},{"1993":[{"id":"1993","fileName":"611259268.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<int> ans(n);\n        for(int i=0;i<n;++i){\n            int target = nums[i];\n            vector<bool> dp(target+1);\n            dp[0] = true;\n            int k = 0;\n            for(;k<m;++k){\n                if(dp[target]) break;\n                int x = (i>=queries[k][0] && i<=queries[k][1])?queries[k][2]:0;\n                if(x==0) continue;\n                for(int j=target;j>=x;--j){\n                    dp[j] = dp[j] || dp[j-x];\n                }\n            }\n            ans[i] = dp[target]?k:INT_MAX;\n        }\n        int k = *max_element(ans.begin(), ans.end());\n        return k==INT_MAX?-1:k;\n    }\n};","author":"烈焰的冰玫瑰","submissionId":"611259268"},[]]},{"1994":[{"id":"1994","fileName":"611259483.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<vector<int>> cov(n);\n        for (int i = 0; i < m; i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            if (l < 0) l = 0;\n            if (r >= n) r = n - 1;\n            if (l > r) continue;\n            for (int j = l; j <= r; j++) {\n                cov[j].push_back(i);\n            }\n        }\n        for (int j = 0; j < n; j++) {\n            sort(cov[j].begin(), cov[j].end());\n        }\n        int mx = -1;\n        for (int j = 0; j < n; j++) {\n            int t = nums[j];\n            if (t == 0) {\n                continue;\n            }\n            vector<int> ct = cov[j];\n            unordered_map<int, int> dp;\n            dp[0] = -1; \n            for (int idx : ct) {\n                int val = queries[idx][2];\n                unordered_map<int, int> dp2;\n                dp2 = dp;\n                for (auto v : dp) {\n                    int s = v.first;\n                    int cur = v.second;\n                    int s2 = s + val;\n                    int mx2 = max(cur, idx);\n                    if (s2 > t) continue;\n                    if (dp2.find(s2) == dp2.end() || mx2 < dp2[s2]) {\n                        dp2[s2] = mx2;\n                    }\n                }\n                dp.swap(dp2);\n            }\n            if (dp.find(t) == dp.end()) {\n                return -1;\n            } else {\n                if (dp[t] > mx) {\n                    mx = dp[t];\n                }\n            }\n        }\n        return mx == -1 ? 0 : mx + 1;\n    }\n};","author":"Pig312","submissionId":"611259483"},[]]},{"1995":[{"id":"1995","fileName":"611259266.txt","sourceCode":"class Solution {\n    int n;\n    int nums;\n    int[][]qs;\n    int m;\n    int[][] dp;\n    public int dfs(int idx,List<int[]> list,int num){\n        if(idx==list.size()) return m+10;\n        if(dp[idx][num]>0) return dp[idx][num]; \n        int res=dfs(idx+1,list,num);\n        if(num>=list.get(idx)[1]){\n            int next=num-list.get(idx)[1];\n            if(next==0){\n                return list.get(idx)[0];\n            }else{\n                res=Math.min(res,dfs(idx+1,list,next));\n            }\n        }\n        dp[idx][num]=res;\n        return res;\n    }\n    public int minZeroArray(int[] nums, int[][] qs) {\n        this.n=nums.length;\n        this.m=qs.length;\n        List<int[]>[] list=new ArrayList[n];\n        for(int i=0;i<n;i++){\n            list[i]=new ArrayList();\n        }\n        int idx=1;\n        for(int[] q:qs){\n            for(int i=q[0];i<=q[1];i++){\n                list[i].add(new int[]{idx,q[2]});\n            }\n            idx++;\n        }\n\n        int res=0;\n        for(int i=0;i<n;i++){\n            if(nums[i]==0) continue;\n            this.dp=new int[m+5][nums[i]+1];\n            res=Math.max(res,dfs(0,list[i],nums[i]));\n        }\n\n        return res==m+10?-1:res;    \n    }\n}","author":"luojh","submissionId":"611259266"},[]]},{"1996":[{"id":"1996","fileName":"611259284.txt","sourceCode":"// class SegTree{\n// public:\n//     SegTree(int n) : t(n << 2), todo(n << 4) {}\n//     void maintain(int o){\n//         t[o] = max(t[o << 1], t[o << 1|1]);\n//     }\n//     void build(int o, int l, int r, const vector<int>& a){\n//         if(l == r){\n//             t[o] = a[l];\n//             return;\n//         }\n//         int m = l + (r - l) / 2;\n//         build(o << 1, l, m, a);\n//         build(o << 1|1, m + 1, r, a);\n//         maintain(o);\n//     }\n//     void do_(int o, int val){\n//        t[o] = todo[o] = val;\n//     }\n//     void update(int o, int l, int r, int L, int R, int val){\n//         if(l <= L && R <= r){\n//             t[o] = val;\n//             todo[o] = val;\n//             return;\n//         }\n//         if(todo[o]){\n//             todo[o<<1] = todo[o<<1|1] = todo[o];\n//             t[o << 1] = t[o << 1 | 1] = todo[o];\n//             todo[o] = 0;\n//         }\n//         int m = l + (r - l) / 2;\n//         if(i <= m) update(o << 1, l, m, i, val);\n//         else update(o << 1 | 1, m + 1, r, i, val);\n//         maintain(o);\n//     }\n//     int query_max(){\n//         return t[0];\n//     }\n// private:\n//     vector<int> t; // 记录最大值\n//     vector<int> todo;\n// };\n\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size();\n        int m = q.size();\n        int l = 0, r = m;\n        auto check = [&](int k)->bool{\n            vector<vector<int>> left(n), right(n);\n            for(int i = 0; i < k; i++){\n                auto& qq = q[i];\n                left[qq[0]].push_back(qq[2]);\n                right[qq[1]].push_back(qq[2]);\n            }\n            multiset<int> st;\n            for(int i = 0; i < n; i++){\n                for(auto x : left[i]){\n                    st.insert(x);\n                }\n                vector<bool> f(nums[i] + 1);\n                f[0] = true;\n                for(auto x : st){\n                    for(int j = nums[i]; j >= x; j--){\n                        f[j] = f[j] || f[j - x];\n                    }\n                }\n                if(!f[nums[i]]) return false;\n                for(auto x : right[i]){\n                    st.erase(st.find(x));\n                }\n            }\n            return true;\n        };\n        while(l <= r){\n            int m = l + (r - l)/2;\n            // cout << m << \" \" << check(m) << endl;\n            if(check(m)) r = m - 1;\n            else l = m + 1;\n        }\n        return l > m ? -1 : l;\n    }\n};","author":"竹下为生","submissionId":"611259284"},[]]},{"1997":[{"id":"1997","fileName":"611259250.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        std::vector<std::vector<bool>> record(n);\n        std::vector<int> maxIndex(n, 0);\n        std::vector<bool> couldZero(n, false);\n        int zeroCount = 0;\n        for (int index = 0; index < n; ++index) {\n            if (nums[index] == 0) {\n                couldZero[index] =  true;\n                zeroCount++;\n                continue;\n            }\n            record[index] = std::vector<bool>(nums[index] + 1, false);\n            record[index][0] = true;\n        }\n        if (zeroCount == n) {\n            return 0;\n        }\n        for (int i = 0; i < queries.size(); ++i) { // 1000\n            // printf(\"i %drn\", i);\n            std::vector<int>& quer = queries[i];\n            for (int j = quer[0]; j <= quer[1]; ++j) { // 10\n                // printf(\"j %drn\", j);\n                int val = quer[2];\n                if (couldZero[j]) {\n                    continue;\n                }\n                std::vector<bool> temp = record[j];\n                int tempMax = maxIndex[j];\n                for (int k = 0; k <= tempMax; ++k) { // 1000\n                    // printf(\"k %d m %d k + val %d nums[j] %d %drn\", k, maxIndex[j], k + val, nums[j], record[j][k]);\n                    if (record[j][k] && ((k + val) <= nums[j])) {\n                        temp[k + val] = true;\n                        maxIndex[j] = std::max(maxIndex[j], k + val);\n                        if ((k + val) == nums[j]) {\n                            couldZero[j] = true;\n                            break;\n                        }\n                    }\n                }\n                record[j] = temp;\n                // printf(\"rn\");\n            }\n            int count = 0;\n            for (int j = 0; j < n; ++j) {\n                count += couldZero[j] ? 1 : 0;\n            }\n            if (count == n) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"Chenchen","submissionId":"611259250"},[]]},{"1998":[{"id":"1998","fileName":"611259574.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        def check(k: int) -> bool:\n            for i in range(n):\n                dp = 1\n                for j in range(k):\n                    l, r, v = queries[j]\n                    if l <= i <= r:\n                        dp |= dp << v\n                if ((dp >> nums[i]) & 1) == 0:\n                    return False\n            return True\n\n        low, high = 0, m + 1\n        res = -1\n        while low < high:\n            mid = (low + high) // 2\n            if check(mid):\n                res = mid\n                high = mid\n            else:\n                low = mid + 1\n        return res if res != -1 and res <= m else -1","author":"沐风","submissionId":"611259574"},[]]},{"1999":[{"id":"1999","fileName":"611259557.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n\n        ans = [inf] * n\n\n        for i in range(n):\n            if nums[i] == 0:\n                ans[i] = 0\n                continue\n            s = set()\n            s.add(nums[i])\n            for j in range(m):\n                l, r, v = queries[j]\n                if l <= i <= r:\n                    t = set()\n                    for x in s:\n                        t.add(x)\n                        t.add(x - v)\n                    if 0 in t:\n                        ans[i] = j + 1\n                        break\n                    s = t\n        mn = max(ans)\n        return mn if mn < inf else -1","author":"瞌睡菇","submissionId":"611259557"},[]]},{"2000":[{"id":"2000","fileName":"611259644.txt","sourceCode":"const int MAXR=10+5,MAXC=1e3+5;\nbool dp[MAXR][MAXC];\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& n, vector<vector<int>>& q) {\n        int sz=n.size(),qsz=q.size();\n        memset(dp,false,sizeof(dp));\n        for (int i=0;i<sz;i++) {\n            dp[i][0]=true;\n        }\n        int mx=*max_element(n.begin(),n.end());\n        \n        if (mx==0) {\n            return 0;\n        }\n        for (int ste=0;ste<qsz;ste++) {\n            const vector<int> &tar=q.at(ste);\n            int l=tar.at(0),r=tar.at(1),v=tar.at(2);\n            for (int i=l;i<=r;i++) {\n                int nv=n.at(i);\n                for (int tar=nv;tar-v>=0;tar--) {\n                    int sou=tar-v;\n                    if (dp[i][sou]==false) {\n                        continue;\n                    }\n                    dp[i][tar]=true;\n                }\n            }\n            bool ans=true;\n            for (int i=0;i<sz;i++) {\n                int v=n.at(i);\n                if (dp[i][v]==false) {\n                    ans=false;\n                    break;\n                }\n            }\n            if (ans) {\n                return ste+1;\n            }\n        }\n        return -1;\n    }\n};","author":"Yves","submissionId":"611259644"},[]]},{"2001":[{"id":"2001","fileName":"611259894.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int ans = -1;\n\n        for (int i = 0; i < nums.length; i++) {\n            int minK = this.getMinK(nums[i], i, queries);\n            if (minK == -1) {\n                return -1;\n            } else if (ans == -1) {\n                ans = minK;\n            } else {\n                ans = Math.max(ans, minK);\n            }\n        }\n\n        return ans;\n    }\n\n    private int getMinK(int num, int target, int[][] queries) {\n        if (num == 0) {\n            return 0;\n        }\n\n        Set<Integer> availableValue = new HashSet<>();\n        availableValue.add(num);\n\n        for (int ptr = 0; ptr < queries.length; ptr++) {\n            int[] query = queries[ptr];\n            if (target < query[0] || target > query[1]) {\n                continue;\n            }\n\n            Set<Integer> nextDp = new HashSet<>();\n            for (Integer value : availableValue) {\n                if (value == query[2]) {\n                    return ptr + 1;\n                }\n                if (value > query[2]) {\n                    nextDp.add(value - query[2]);\n                }\n            }\n            nextDp.addAll(availableValue);\n            availableValue = nextDp;\n        }\n\n        return -1;\n    }\n}","author":"随缘","submissionId":"611259894"},[]]},{"2002":[{"id":"2002","fileName":"611259896.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n=len(nums)\n        ds=[]\n        dp=[-1]*n\n        for i in range(n):\n            tmp=dict()\n            tmp[nums[i]]=1\n            ds.append(tmp)\n            if nums[i]==0:\n                dp[i]=0\n        qs=len(queries)\n        for q in range(qs):\n            for i in range(queries[q][0],queries[q][1]+1):\n                if dp[i]>=0:\n                    continue\n                val=queries[q][2]\n                ds_update=[]\n                for k in ds[i].keys():\n                    tmp=k-val\n                    if tmp==0:\n                        dp[i]=q+1\n                        break\n                    elif tmp>0 and tmp not in ds[i]:\n                        ds_update.append(tmp)\n                for k in ds_update:\n                    ds[i][k]=1\n        if min(dp)==-1:\n            return -1\n        else:\n            return max(dp)","author":"Clover","submissionId":"611259896"},[]]},{"2003":[{"id":"2003","fileName":"611259676.txt","sourceCode":"# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, DefaultDict\nfrom collections import deque, Counter\nfrom queue import PriorityQueue\nimport math\nfrom functools import lru_cache\nfrom sortedcontainers import SortedDict, SortedSet\nimport random\nimport copy\nimport sys\n\nMOD = 10**9 + 7\n\n\nINF = 0x7f7f7f7f7f7f7f7\n\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        vals = [[] for i in range(n)]\n        ok = [0] * n\n\n\n        c = Counter(nums)\n        if 0 in c and c[0] == n:\n            return 0\n\n\n        def check():\n            for x in range(n):\n                if ok[x]:\n                    continue\n\n\n                arr = vals[x]\n                arr.sort()\n                tar = nums[x]\n\n                k = len(arr)\n                @lru_cache(typed=False, maxsize=12800)\n                def dp(ii, tt):\n                    if ii == k:\n                        return tt == 0\n\n                    if tt == 0:\n                        return True\n\n                    if arr[ii] > tt:\n                        return False\n\n                    if dp(ii+1, tt):\n                        return True\n\n                    if tt >= arr[ii] and dp(ii+1, tt-arr[ii]):\n                        return True\n\n                    return False\n\n\n                if not dp(0, tar):\n                    return False\n                else:\n                    ok[x] = 1\n\n            return True\n\n\n\n\n\n        cnt = 0\n        for a, b, v in queries:\n            cnt += 1\n\n            for i in range(a, b+1):\n                vals[i].append(v)\n\n            if check():\n                return cnt\n\n        return -1","author":"皓首不倦.GRH","submissionId":"611259676"},[]]},{"2004":[{"id":"2004","fileName":"611259906.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int> nums, vector<vector<int>> queries) {\n        int n = nums.size(), m = queries.size();\n        int l = 0, r = m, up = 1000;\n        vector dp(m+1,vector(n+1,vector<int>(up+1,0)));\n        for(int i=0;i<n;i++) dp[0][i][0] = 1;\n        for(int i=1;i<=m;i++){\n            int l = queries[i-1][0], r = queries[i-1][1], val = queries[i-1][2];\n            dp[i] = dp[i-1];\n            for(int j=l;j<=r;j++){\n                for(int k=0;k<=up;k++){\n                    if(k >= val) dp[i][j][k] |= dp[i-1][j][k-val];\n                }\n            }\n        }\n        int maxn = 0;\n        for(int i=0;i<n;i++){\n            int x = m + 1;\n            for(int j=0;j<=m;j++){\n                if(dp[j][i][nums[i]])  {\n                    x = j;\n                    break;\n                }\n            }\n            maxn = max(maxn,x);\n        }\n        int ans = -1;\n        if(maxn <= m) ans = maxn;\n        return ans;\n    }\n};","author":"bright_ml","submissionId":"611259906"},[]]},{"2005":[{"id":"2005","fileName":"611259593.txt","sourceCode":"class Solution {\npublic:\n    bool dfs(vector<int>& f, int tar) {\n        int n = f.size();\n        vector<bool> dp(tar + 1, false);\n        dp[0] = true;\n        for (int i = 0; i < n; i++) {\n            for (int j = tar; j >= f[i]; j--) {\n                dp[j] = dp[j] || dp[j - f[i]];\n            }\n        }\n        return dp[tar];\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        function<bool(int)> check = [&](int tar) -> bool {\n            vector<vector<int>> f(n);\n            for (int i = 0; i <= tar; i++) {\n                for (int j = queries[i][0]; j <= queries[i][1]; j++) {\n                    f[j].push_back(queries[i][2]);\n                }\n            }\n            bool a = true;\n            for (int i = 0; i < n; i++) {\n                if (dfs(f[i], nums[i]) == false) {\n                    a = false;\n                }\n            }\n            return a;\n        };\n        int l = -1, r = queries.size();\n        int ans = 0;\n        while (l < r) {\n            int mid = l + (r - l) / 2;\n            if (check(mid)) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        if (l == queries.size()) {\n            return -1;\n        }\n        return l + 1;\n    }\n};","author":"anyiling","submissionId":"611259593"},[]]},{"2006":[{"id":"2006","fileName":"611260033.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        set<int> s;\n\n        int ans = 0, k;\n        for(int i = 0; i < nums.size(); ++i) {\n            if(nums[i] == 0) continue;\n            s.clear();\n            \n            for(k = 0; k < queries.size(); ++k) {\n                auto vec = queries[k];\n                if(vec[0] > i || vec[1] < i) continue;\n                auto st = s.begin(), ed = s.end();\n                queue<int> q;\n                for(auto it = st; it != ed; ++it) {\n                    int x = *it;\n                    int y = x + vec[2];\n\n                    // cout << x << ' ';\n                    \n                    if(y > nums[i]) continue;\n                    \n                    if(s.count(y) == 0) q.push(y);\n                    if(y == nums[i]) {\n                        // cout << k << ' ';\n                        break;\n                    }\n                }\n                while(q.size()) {\n                    s.insert(q.front());\n                    q.pop();\n                }\n                // cout << 'n';\n                \n                if(!s.count(vec[2])) s.insert(vec[2]);\n                if(s.count(nums[i])) break;\n            }\n\n            // cout << 'n';\n            if(s.count(nums[i]) == 0) {\n                // cout << nums[i] << 'n';\n                ans = -1;\n                break;\n            }\n            // cout << k << ' ';\n            ans = max(ans, k + 1);\n        }\n\n        return ans;\n    }\n};","author":"路人乙","submissionId":"611260033"},[]]},{"2007":[{"id":"2007","fileName":"611259925.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        boolean[] isZero = new boolean[n];\n        boolean isAllZero = true;\n        for(int i = 0;i < n;i++){\n            if(nums[i] != 0){\n                isAllZero = false;\n            }else {\n                isZero[i] = true;\n            }\n        }\n        if(isAllZero){\n            return 0;\n        }\n        List<Set<Integer>> map = new ArrayList<>(n);\n        for(int i = 0;i < n;i++){\n            HashSet<Integer> set = new HashSet<>();\n            set.add(0);\n            map.add(set);\n        }\n        int ans = -1;\n        for(int i = 0;i < queries.length;i++){\n            for(int j = queries[i][0];j <= queries[i][1];j++){\n                if(isZero[j]){\n                   continue;\n                }\n                if(map.get(j).contains(nums[j] - queries[i][2])){\n                    isZero[j] = true;\n                    continue;\n                }\n                Set<Integer> set = new HashSet<>();\n                for(int key:map.get(j)){\n                    set.add(key+queries[i][2]);\n                }\n                map.get(j).addAll(set);\n\n            }\n            boolean isOver = true;\n            for (int j = 0; j < n; j++) {\n                if(!isZero[j]){\n                    isOver = false;\n                    break;\n                }\n            }\n            if(isOver){\n                ans = i+1;\n                break;\n            }\n        }\n        return ans;\n    }\n}","author":"水","submissionId":"611259925"},[]]},{"2008":[{"id":"2008","fileName":"611259907.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        @cache\n        def dfs(index,num, k):\n            if num == 0:\n                return True\n            if k < 0:\n                return False\n\n            ans = False\n            left, right ,val = queries[k][0],queries[k][1],queries[k][2]\n            #不选择\n            ans = ans or dfs(index,num, k - 1)\n            #选择\n            if index >= left and right >= index:\n                if num >= val:\n                    ans = ans or dfs(index, num - val, k - 1)\n            return ans\n        \n        if len(set([each for each in nums]) ) == 1 and nums[0] == 0:\n            return 0\n            \n        \n        left,right = 0, len(queries) - 1\n        while left <= right:\n            mid = left + (right - left)//2\n            curr = True\n            for i,num in enumerate(nums):\n                curr_ans = dfs(i,num, mid)\n                curr = curr and curr_ans\n\n            if curr:\n                right = mid - 1\n            else:\n                left = mid + 1\n        if left == len(queries):\n            return -1\n        return left + 1\n            \n        ","author":"liuyang","submissionId":"611259907"},[]]},{"2009":[{"id":"2009","fileName":"611259671.txt","sourceCode":"package main\n\nimport \"slices\"\n\nfunc minZeroArray(nums []int, queries [][]int) int {\n\tif slices.Max(nums) == 0 {\n\t\treturn 0\n\t}\n\tn := len(nums)\n\tcnt := make([]map[int]bool, n)\n\tfor i := range cnt {\n\t\tcnt[i] = map[int]bool{nums[i]: true}\n\t}\n\tfor i, v := range queries {\n\t\tfor j := v[0]; j <= v[1]; j++ {\n\t\t\tif cnt[j][0] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tkeys := make([]int, len(cnt[j]))\n\t\t\tc := 0\n\t\t\tfor z := range cnt[j] {\n\t\t\t\tkeys[c] = z\n\t\t\t\tc++\n\t\t\t}\n\t\t\tfor _, z := range keys {\n\t\t\t\tif z-v[2] < 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tcnt[j][z-v[2]] = true\n\t\t\t\t//fmt.Printf(\"i:%v j:%v z:%v set true:%vn\", i, j, z, z-v[2])\n\n\t\t\t}\n\t\t}\n\t\tif isValid(cnt) {\n\t\t\treturn i + 1\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc isValid(cnt []map[int]bool) bool {\n\tfor _, v := range cnt {\n\t\tif !v[0] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n","author":"nullmoon","submissionId":"611259671"},[]]},{"2010":[{"id":"2010","fileName":"611260088.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n,m=len(nums),len(queries)\n        cnt0=sum(x==0 for x in nums)\n        if cnt0==n:\n            return 0\n        nums=[1<<x for x in nums]\n        for j,(l,r,v) in enumerate(queries):\n            for i in range(l,r+1):\n                if nums[i]&1:\n                    continue\n                nums[i]|=nums[i]>>v\n                if nums[i]&1:\n                    cnt0+=1\n            if cnt0==n:\n                return j+1\n        return -1\n                ","author":"凉薄一夏","submissionId":"611260088"},[]]},{"2011":[{"id":"2011","fileName":"611260080.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(queries)\n        ans = 0\n        for idx, x in enumerate(nums):\n            @cache\n            def dfs(i, cnt):\n                if cnt == 0:\n                    return i\n                if i == n:\n                    return inf\n                l, r, val = queries[i]\n                res = inf\n                if cnt >= val and l <= idx <= r:\n                    res = min(res, dfs(i + 1, cnt - val))\n                res = min(res, dfs(i + 1, cnt))\n                return res\n            ans = max(ans, dfs(0, x))\n        return ans if ans < inf else -1\n\n\n        ","author":"沐浴阳光","submissionId":"611260080"},[]]},{"2012":[{"id":"2012","fileName":"611260208.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        \n        all_zero = all(num == 0 for num in nums)\n        if all_zero:\n            return 0\n        \n        queries_per_j = [[] for _ in range(n)]\n        for i in range(m):\n            l, r, val = queries[i]\n            for j in range(l, r + 1):\n                queries_per_j[j].append((i, val))\n        \n        max_ij = -1\n        \n        for j in range(n):\n            current_num = nums[j]\n            if current_num == 0:\n                continue\n            \n            available = queries_per_j[j]\n            if not available:\n                return -1\n            \n            target = current_num\n            possible = {0}\n            found = False\n            current_max_i = -1\n            \n            for (query_idx, val) in available:\n                new_possibles = set()\n                for s in possible:\n                    new_sum = s + val\n                    if new_sum == target:\n                        current_max_i = query_idx\n                        found = True\n                        break\n                    elif new_sum < target:\n                        new_possibles.add(new_sum)\n                if found:\n                    break\n                possible.update(new_possibles)\n            \n            if not found:\n                return -1\n            \n            if current_max_i > max_ij:\n                max_ij = current_max_i\n        \n        if max_ij == -1:\n            return 0\n        else:\n            return max_ij + 1","author":"Yoke","submissionId":"611260208"},[]]},{"2013":[{"id":"2013","fileName":"611260239.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int q=queries.size(),n=nums.size();\n        vector<bitset<1001>>  bt(n);\n        int zero=0;\n        for(int i=0;i<n;i++){\n            bt[i][nums[i]]=1;\n            if(nums[i]==0)zero++;\n        }\n        if(zero==n)return 0;\n        for(int i=0;i<q;i++){\n            auto l=queries[i][0],r=queries[i][1],val=queries[i][2];\n            for(int j=l;j<=r;j++){\n                if(bt[j][0])continue;\n                bt[j]|=bt[j]>>val;\n                if(bt[j][0]){\n                    zero++;\n                    if(zero==n)return i+1;\n                }\n            }\n        }\n        return -1;\n    }\n};","author":"Ch7k","submissionId":"611260239"},[]]},{"2014":[{"id":"2014","fileName":"611260387.txt","sourceCode":"#include<bits/stdc++.h>\nusing namespace std;\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n\n        int ans = 0;\n        for(int i = 0; i < nums.size(); i ++) {\n            int f[queries.size() + 5][1005];\n            for(int k = 0; k <= queries.size(); k ++) {\n                for(int j = 0; j <= 1000; j ++) {\n                    f[k][j] = 1e6;\n                }\n            }\n            \n            f[0][nums[i]] = 0;\n            int zt_ans = 1e6;\n            for(int k = 1; k <= queries.size(); k ++) {\n                for(int j = 0; j <= 1000; j ++) {\n                    f[k][j] = f[k - 1][j];\n                    if(f[k][j] >= 1e6) {\n                        if(i >= (queries[k - 1][0]) && (i <= queries[k - 1][1])) {\n                            if((j + queries[k - 1][2]) <= 1000) {\n                                if(f[k - 1][j + queries[k - 1][2]] < 1e6) {\n                                    f[k][j] = k;\n                                }\n                            }\n                        }\n                    }\n                    \n                    zt_ans = min(zt_ans, f[k][0]);\n                }\n            }\n\n            ans = max(ans, zt_ans);\n        }\n\n        if(ans < 1e6) return ans;\n        else return - 1;\n    }\n};","author":"逆熵","submissionId":"611260387"},[]]},{"2015":[{"id":"2015","fileName":"611260544.txt","sourceCode":"class Solution {\nprivate:\n    int cal(const vector<int>& nums, const vector<vector<int>>& queries, int index) {\n        if (nums[index] == 0) {\n            return 0;\n        }\n        vector<bool> dp(nums[index] + 1, 0);\n        dp[0] = 1;\n        for (int i = 0; i < queries.size(); ++i) {\n            if (queries[i][0] <= index && queries[i][1] >= index) {\n                for (int j = dp.size() - 1; j >= queries[i][2]; --j) {\n                    dp[j] = dp[j] | (dp[j - queries[i][2]]);\n                    // cout << dp[j] << \" \";\n                }\n                // cout << endl;\n                if (dp.back()) {\n                    return i + 1;\n                }\n            }\n        }\n        return -1;\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ret = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n            int res = cal(nums, queries, i);\n            // cout << endl;\n            // cout << i << \" \" << res << endl;\n            if (res == -1) {\n                return -1;\n            }\n            ret = max(ret, res);\n        }\n        return ret;\n    }\n};","author":"ctong","submissionId":"611260544"},[]]},{"2016":[{"id":"2016","fileName":"611260613.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<vector<bool>> memo(n,vector<bool>(1001));\n        auto check = [&](int v) {\n            for(int i = 0;i < n;i++)for(int j = 0;j < 1001;j++)memo[i][j] = false;\n            for(int i = 0;i < n;i++)memo[i][0] = true;\n            for(int i = 0;i < v;i++) {\n                int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n                for(int j = l;j <= r;j++) {\n                    for(int k = 1000;k >= val;k--) {\n                        memo[j][k] = memo[j][k] || memo[j][k-val];\n                    }\n                }\n            }\n            for(int i = 0;i < n;i++) if(memo[i][nums[i]]==false) return false;\n            return true;\n        };\n        int l = 0,r = m;\n        while(l <= r) {\n            int mid = (l+r)/2;\n            if(check(mid)) {\n                r = mid-1;\n            } else {\n                l = mid+1;\n            }\n        }\n        return l>m?-1:l;\n    }\n};","author":"vinson","submissionId":"611260613"},[]]},{"2017":[{"id":"2017","fileName":"611260250.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        int ans = 0;\n        int idx = 0;\n        for (int num : nums) {\n            if (!num) continue;\n            int cur = 0;\n            // k 个选择，num 变为 0\n            vector<vector<int>> f(m + 1, vector<int>(num + 1, m + 1));\n            for (int i = 0; i <= m; ++i) f[i][0] = 0; // 0 无需变换\n            for (int i = 1; i <= m; ++i) {\n                int l = queries[i - 1][0], r = queries[i - 1][1], val = queries[i - 1][2];\n                for (int j = 1; j <= num; ++j) f[i][j] = f[i - 1][j];\n                if (l <= idx && idx <= r) { // 需要在变换范围内\n                    for (int j = 1; j <= num; ++j) {\n                        if (j == val) f[i][j] = min(i, f[i][j]); // 当前可变换为 0，但可能前几个已经可以为 0\n                        else if (j > val && f[i - 1][j - val] < m + 1) f[i][j] = min(i, f[i][j]);\n                        // else if (j > val && f[i - 1][j - val] < m + 1) f[i][j] = min(f[i - 1][j - val] + 1, f[i][j]);\n                        // else f[i][j] = f[i - 1][j]; // 会直接减为 负数\n                    }\n                }\n                // if (l <= idx && idx <= r) { // 需要在变换范围内\n                //     for (int j = 1; j <= num; ++j) {\n                //         if (j == val) f[i][j] = min(i, f[i - 1][j]); // 当前可变换为 0，但可能前几个已经可以为 0\n                //         else if (j > val) f[i][j] = min(f[i - 1][j - val] + 1, f[i - 1][j]);\n                //         else f[i][j] = f[i - 1][j]; // 会直接减为 负数\n                //     }\n                // } else {\n                //     for (int j = 1; j <= num; ++j) f[i][j] = f[i - 1][j];\n                // }\n            }\n            // cout << idx << \" \" << num << \" \" << f[m][num] << endl;\n            // cout << \" ------ \" << endl;\n            // for (int i = 0; i <= m; ++i) {\n            //     for (int j = 0; j <= num; ++j) {\n            //         cout << f[i][j] << \" \";\n            //     }\n            //     cout << endl;\n            // }\n            // cout << \" = ## ==\" << endl;\n            if (f[m][num] >= m + 1) return -1;\n            ans = max(ans, f[m][num]);\n            idx++;\n        }\n        return ans;\n    }\n};","author":"mistluo","submissionId":"611260250"},[]]},{"2018":[{"id":"2018","fileName":"611260528.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int res = INT_MAX, n = queries.size(), m = nums.size();\n        unordered_map<int, vector<pair<int, int>>> h;\n        for (int i = 0; i < n; ++ i) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for (int j = 0; j < m; ++ j) {\n                auto& v = h[j];\n                if (nums[j] == 0) {\n                    v.push_back({0, val});\n                    continue;\n                }\n                if (j >= l && j <= r) {\n                    v.push_back({i + 1, val});\n                }\n            }\n        }\n        vector<int> ans(m, -1);\n        for (int i = 0; i < m; ++ i) {\n            int x = nums[i];\n            auto& v = h[i];\n            vector<vector<int>> dp(v.size() + 1, vector<int>(x + 1, 0));\n            dp[0][0] = 1;\n            for (int k = 1; k <= v.size(); ++ k) {\n                for (int j = 0; j <= x; ++ j) {\n                    if (j >= v[k - 1].second) {\n                        dp[k][j] = max(dp[k - 1][j], dp[k - 1][j - v[k - 1].second]);\n                    } else {\n                        dp[k][j] = dp[k - 1][j];\n                    }\n                }\n            }\n            for (int k = 1; k <= v.size(); ++ k) {\n                if (dp[k][x] == 1) {\n                    ans[i] = v[k - 1].first;\n                    break;\n                }\n            }\n        }\n        for (int i = 0; i < m; ++ i) {\n            if (ans[i] == -1) {\n                return -1;\n            }\n        }\n        return ranges::max(ans);\n    }\n};","author":"1！+1！=2！","submissionId":"611260528"},[]]},{"2019":[{"id":"2019","fileName":"611260837.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int res = 0;\n        int dp[1001];\n        for (int i = 0; i < nums.size(); ++ i) {\n            if (nums[i] == 0) {\n                res = std::max(res, 0);\n            } else {\n                memset(dp, 0, 4 * (1 + nums[i]));\n                dp[0] = 1;\n                int idx = 0;\n                for (; idx < queries.size(); ++ idx) {\n                    if (queries[idx][0] <= i && queries[idx][1] >= i) {\n                        auto v= queries[idx][2];\n                        for (int j = nums[i]; j >= v; -- j) {\n                            if (dp[j - v] == 1) {\n                                dp[j] = 1;\n                            }\n                        }\n                        if (dp[nums[i]] == 1) {\n                            break;\n                        }\n                    }\n                }\n                if (dp[nums[i]] == 1) {\n                    res = std::max(res, idx + 1);\n                } else return -1;\n            }\n            \n        }\n        return res;\n        \n    }\n};","author":"是个小号","submissionId":"611260837"},[]]},{"2020":[{"id":"2020","fileName":"611260872.txt","sourceCode":"class Solution {\n    bool combineSum(vector<int>& nums, int target) {\n        if (target == 0) return true;\n        int n = nums.size();\n        if (n == 0) return false;\n        vector<vector<int>> f(n, vector<int>(target+1));\n        if (nums[0] <= target) f[0][nums[0]] = 1;\n        f[0][0] = 1;\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j <= target; j++) {\n                f[i][j] = f[i-1][j];\n                if (nums[i] <= j) {\n                    f[i][j] |= f[i-1][j-nums[i]]; \n                }\n            }\n        }\n        // for (int i = 0; i < n; i++) {\n        //     for (int j = 0; j <= target; j++) {\n        //         cout << f[i][j] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        return f[n-1][target];\n    }\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) { \n        bool zeros = true;\n        for (int x : nums) {\n            zeros = zeros && x == 0;\n        }\n        if (zeros) return 0;\n        int n = nums.size(), m = queries.size();\n        vector<vector<int>> ops(n);\n        for (int i = 0; i < m; i++) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for (int j = l; j <= r; j++) \n                if (nums[j] >= val) ops[j].push_back(val);\n            bool allZero = true;\n            for (int j = 0; j < n; j++) {\n                allZero = allZero && combineSum(ops[j], nums[j]);\n                // cout << \"---------\" << endl;\n            }\n            if (allZero) return i + 1;\n        }\n        return -1;\n    }\n};","author":"ransom_sword","submissionId":"611260872"},[]]},{"2021":[{"id":"2021","fileName":"611260928.txt","sourceCode":"class Solution\n{\n    static int check(int const num, vector<int> const &vals, vector<vector<bool>> &dp)\n    {\n        if (num == 0) return 0;\n        for (int j = 1; j <= num; ++j) dp[0][j] = false;\n        dp[0][0] = true;\n        for (int i = 1; i <= vals.size(); ++i)\n        {\n            int const val = vals[i - 1];\n            for (int j = 0; j <= num; ++j)\n                dp[i][j] = dp[i - 1][j] || j >= val && dp[i - 1][j - val];\n            if (dp[i][num]) return i;\n        }\n        return -1;\n    }\n\npublic:\n    int minZeroArray(vector<int> const &nums, vector<vector<int>> const &queries)\n    {\n        vector<vector<int>> vals_possible_at_each_position(nums.size());\n        for (vector<int> const &q : queries)\n        {\n            int const l = q[0], r = q[1], v = q[2];\n            for (int i = 0; i != l; ++i) vals_possible_at_each_position[i].push_back(0);\n            for (int i = l; i <= r; ++i) vals_possible_at_each_position[i].push_back(v);\n            for (int i = r + 1; i != nums.size(); ++i) vals_possible_at_each_position[i].push_back(0);\n        }\n        int ans = -1;\n        vector<vector<bool>> dp(queries.size() + 1, vector<bool>(*max_element(nums.cbegin(), nums.cend()) + 1, 0));\n        for (int i = 0; i != nums.size(); ++i)\n        {\n            int const challenger = check(nums[i], vals_possible_at_each_position[i], dp);\n            if (challenger < 0) return -1;\n            if (ans < challenger) ans = challenger;\n        }\n        return ans;\n    }\n};","author":"heartunderblade","submissionId":"611260928"},[]]},{"2022":[{"id":"2022","fileName":"611261077.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        # 对每个下标而言，减到0有一个最小值，在这些最小值中取最大值即可\n        # 时间复杂度O(n * (nummax * qlen))\n        def bfs(num,pos):\n            if num == 0:\n                return 0\n            term = 0\n            nowReach = [num]  # 起始数值\n            for i in range(num):\n                canGet[i] = 0\n            \n            for term in range(qlen):\n                if queries[term][0] > pos or queries[term][1] < pos:\n                    continue\n                for i in range(len(nowReach)):\n                    newVal = nowReach[i] - queries[term][2]\n                    if newVal == 0:\n                        return term + 1\n                    elif newVal > 0 and canGet[newVal] == 0:\n                        nowReach.append(newVal)\n                        canGet[newVal] = 1\n            return -1\n\n        qlen = len(queries)\n        canGet = [0] * 1000\n        ans = 0\n        for i,num in enumerate(nums):\n            thisMin = bfs(num,i)\n            if thisMin == -1:\n                return -1\n            ans = max(ans,thisMin)\n        return ans\n ","author":"谨岌洽","submissionId":"611261077"},[]]},{"2023":[{"id":"2023","fileName":"611260906.txt","sourceCode":"type state struct {\n\tidx int\n\tval int\n}\n\nfunc minZeroArray(nums []int, queries [][]int) int {\n\tn := len(nums)\n\tposLists := make([][]state, n)\n\tfor qi, query := range queries {\n\t\tl, r, val := query[0], query[1], query[2]\n\t\tfor j := l; j <= r; j++ {\n\t\t\tposLists[j] = append(posLists[j], state{idx: qi, val: val})\n\t\t}\n\t}\n\tisValid := func(k int) bool {\n\t\tfor j := 0; j < n; j++ {\n\t\t\ttarget := nums[j]\n\t\t\tif target == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n            //f[s] 表示是否能选出若干个查询，使得和为 s\n\t\t\tf := make([]bool, target+1)\n\t\t\tf[0] = true\n            //对于下标j，遍历所有在前k个查询中出现的\n\t\t\tfor _, qinfo := range posLists[j] {\n\t\t\t\tif qinfo.idx < k {\n\t\t\t\t\tfor s := target - qinfo.val; s >= 0; s-- {\n\t\t\t\t\t\tif f[s] && s+qinfo.val <= target {\n\t\t\t\t\t\t\tf[s+qinfo.val] = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !f[target] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tlo, hi := 0, len(queries)+1\n\tfor lo < hi {\n\t\tmid := (lo + hi) / 2\n\t\tif isValid(mid) {\n\t\t\thi = mid\n\t\t} else {\n\t\t\tlo = mid + 1\n\t\t}\n\t}\n\tif lo > len(queries) {\n\t\treturn -1\n\t}\n\treturn lo\n}","author":"汪星银","submissionId":"611260906"},[]]},{"2024":[{"id":"2024","fileName":"611261297.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, m = len(nums), len(queries)\n        if all(x == 0 for x in nums):\n            return 0\n\n        dp = [set() for _ in range(n)]\n        for i in range(n):\n            dp[i].add(0)\n\n        not_solved = [i for i in range(n)]\n\n        for j in range(m):\n            l, r, v = queries[j]\n            solved_this_query = []\n            for i in list(not_solved):\n                if l <= i <= r:\n                    newSums = set()\n                    for s in dp[i]:\n                        nxt = s + v\n                        if nxt <= nums[i]:\n                            newSums.add(nxt)\n                    if newSums:\n                        dp[i].update(newSums)\n                    if nums[i] in dp[i]:\n                        solved_this_query.append(i)\n            for i in solved_this_query:\n                not_solved.remove(i)\n            if not not_solved:\n                return j + 1\n        return -1","author":"Qeesun","submissionId":"611261297"},[]]},{"2025":[{"id":"2025","fileName":"611261134.txt","sourceCode":"class Solution {\npublic:\n    map<int,unordered_set<int>>  s;\n    bool check(vector<int> &nums){\n        for(auto v : nums){\n            if(v > 0) return false;\n        }\n        return true;\n    }\n    bool check2(){\n        for(auto &[k,v] : s){\n            if(!v.count(0)) return false;\n        }\n        return true;\n    }\n    void del(vector<int> &nums,int l, int r, int val){\n        for(int i = l; i <= r; i ++){\n            auto &vec = s[i];\n            if(vec.count(0)) continue;\n            unordered_set<int> newV;\n            for(auto v: vec){\n                if(v - val >= 0 && !vec.count(v- val) && !newV.count(v - val)){\n                    newV.insert(v - val);\n                }\n            }\n            for(auto v : newV){\n                vec.insert(v);\n            } \n        }\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        if(check(nums)) return 0;\n        for(int j = 0; j < nums.size(); j ++){\n            s[j].insert(nums[j]);\n        }\n        int i = 0;\n        for(auto &v : queries){\n            i++;\n            del(nums,v[0],v[1],v[2]);\n            if(check2())return i;\n        }\n        return -1;\n    }\n};","author":"vector","submissionId":"611261134"},[]]},{"2026":[{"id":"2026","fileName":"611261616.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        m = len(queries)\n        n = len(nums)\n        \n        # 检查用前 k 个查询能否使得每个下标 i 达到子集和正好等于 nums[i]\n        def feasible(k):\n            for i in range(n):\n                # 收集前 k 个查询中覆盖下标 i 的所有减法数值\n                vals = [queries[j][2] for j in range(k) if queries[j][0] <= i <= queries[j][1]]\n                target = nums[i]\n                # dp[s] 表示是否能用部分值的和得到 s\n                dp = [False] * (target + 1)\n                dp[0] = True\n                for v in vals:\n                    # 0/1 背包（子集和），从后向前遍历以避免重复使用同一项\n                    for s in range(target, v - 1, -1):\n                        if dp[s - v]:\n                            dp[s] = True\n                if not dp[target]:\n                    return False\n            return True\n        \n        # 使用二分查找找出最小 k (0 <= k <= m) 使得 feasible(k) 为 True\n        lo, hi = 0, m + 1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if feasible(mid):\n                hi = mid\n            else:\n                lo = mid + 1\n                \n        return lo if lo <= m else -1\n                ","author":"wither","submissionId":"611261616"},[]]},{"2027":[{"id":"2027","fileName":"611261495.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, m = len(nums), len(queries)\n        st = [set() for _ in range(n)]\n        for i in range(n):\n            st[i].add(0)\n        if all(x in st[i] for i, x in enumerate(nums)):\n            return 0\n        for i in range(m):\n            l, r, val = queries[i]\n            for j in range(l, r + 1):\n                res = set()\n                for x in st[j]:\n                    res.add(x)\n                    res.add(x + val)\n                st[j] = res\n            if all(x in st[i] for i, x in enumerate(nums)):\n                return i + 1\n        return -1","author":"江上闲人","submissionId":"611261495"},[]]},{"2028":[{"id":"2028","fileName":"611261110.txt","sourceCode":"class Solution {\n    using ll = long long;\n\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n\n        ll n = nums.size(), m = q.size();\n        auto check = [&](ll k) -> bool {\n            vector<vector<ll>> c(n);\n            for (ll j{}; j < k; ++j) {\n                ll l = q[j][0], r = q[j][1], v = q[j][2];\n                for (ll i = l; i <= r; ++i) {\n                    c[i].emplace_back(v);\n                }\n            }\n\n            for (ll i{}; i < n; ++i) {\n                if (c[i].empty() && nums[i] != 0) {\n                    return false;\n                    continue;\n                }\n                vector<int> f(nums[i] + 1);\n                f[0] = 1;\n                for(auto ii : c[i])\n                    {\n                        for(ll j = nums[i]; j >= ii; j--)\n                            {\n                                if(f[j - ii])\n                                    f[j] = 1;\n                            }\n                    }\n                if(!f[nums[i]])\n                    return false;\n            }\n            return true;\n        };\n\n        ll l = 0, r = m + 1;\n        ll re = -1;\n        while (l < r) {\n            ll mid = l + (r - l) / 2;\n            if (check(mid)) {\n                re = mid;\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        if (re == -1 || re > m) {\n            return -1;\n        }\n        return re;\n    }\n};","author":"hanser_no_neko","submissionId":"611261110"},[]]},{"2029":[{"id":"2029","fileName":"611261478.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        cover = [[] for _ in range(n)]\n        for idx, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                cover[i].append((idx, val))\n        \n        for i in range(n):\n            cover[i].sort()\n        \n        max_j_list = []\n        for i in range(n):\n            if nums[i] == 0:\n                max_j_list.append(-1)\n                continue\n            \n            target = nums[i]\n            query_list = cover[i]\n            dp = {0: -1}\n            for j, val in query_list:\n                temp = {}\n                for s in list(dp.keys()):\n                    current_max_j = dp[s]\n                    new_s = s + val\n                    if new_s > target:\n                        continue\n                    new_max_j = max(current_max_j, j)\n                    if new_s in temp:\n                        if new_max_j < temp[new_s]:\n                            temp[new_s] = new_max_j\n                    else:\n                        temp[new_s] = new_max_j\n                for s in temp:\n                    if s not in dp or temp[s] < dp.get(s, float('inf')):\n                        dp[s] = temp[s]\n            \n            if target not in dp:\n                return -1\n            max_j_list.append(dp[target])\n        \n        max_max_j = max(max_j_list)\n        if max_max_j == -1:\n            return 0\n        else:\n            return max_max_j + 1","author":"aden1350","submissionId":"611261478"},[]]},{"2030":[{"id":"2030","fileName":"611261999.txt","sourceCode":"class Solution {\n\tpublic int minZeroArray(int[] nums, int[][] queries) {\n\t\tint resK[] = new int[nums.length];\n\n\t\tfor (int i = 0 ; i < nums.length ; i++) {\n\t\t\tboolean f[] = new boolean[nums[i] + 1];\n\t\t\tf[0] = true;\n\n\t\t\tint res = doFind(f, queries, nums, i);\n\t\t\tresK[i] = res;\n\t\t}\n\n\n\t\tint maxK = resK[0];\n\t\tfor (int res : resK) {\n\t\t\tif (res == -1) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (maxK < res) {\n\t\t\t\tmaxK = res;\n\t\t\t}\n\t\t}\n\t\treturn maxK;\n\t}\n\n\tprivate int doFind(boolean[] f, int[][] queries, int nums[], int i) {\n\t\tif (nums[i] == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (int j = 0 ; j < queries.length ; j++) {\n\t\t\tint l = queries[j][0];\n\t\t\tint r = queries[j][1];\n\t\t\tint val = queries[j][2];\n\n\t\t\tif ((l <= i) && (i <= r)) {\n\t\t\t\tfor (int k = nums[i] ; k >= 0 ; k--) {\n\t\t\t\t\tint p = k - val;\n\t\t\t\t\tif (p < 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (f[p]) {\n\t\t\t\t\t\tf[k] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (f[nums[i]]) {\n\t\t\t\t\treturn j + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}","author":"xish","submissionId":"611261999"},[]]},{"2031":[{"id":"2031","fileName":"611262072.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] que) {\n        int n=nums.length,m=que.length,ans=0;\n        boolean[] dp;\n        for(int i=0;i<n;i++){\n            if(nums[i]==0) continue;\n            dp=new boolean[nums[i]+1];\n            dp[0]=true;\n            int j=0;\n            for(;j<m;j++){\n                if(que[j][1]<i||que[j][0]>i) continue;\n                int p=que[j][2];\n                for(int k=nums[i];k>=p;k--)\n                    dp[k]|=dp[k-p];\n                if(dp[nums[i]]){\n                    break;\n                }\n            }\n            if(j==m) return -1;\n            ans=Math.max(j+1,ans);\n        }\n        return ans;\n    }\n}","author":"黄彬","submissionId":"611262072"},[]]},{"2032":[{"id":"2032","fileName":"611261655.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int dp[21][1005] = {0}; // 0删 1不删\n\n        for (int i = 0; i < nums.size(); i++) {\n            dp[i][nums[i]] = 1;\n        }\n\n        bool f = true;\n        for (int j = 0; j < nums.size(); j++) {\n            if (dp[j][0] == 0) {\n                f = false;\n            }\n        }\n        if (f) {\n            return 0;\n        }\n\n        for (int i = 0; i < queries.size(); i++) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n\n            // 遍历\n            for (int j = l; j <= r; j++) {\n                for (int x = 0; x <= 1000; x++) {\n                    if (dp[j][x] == 1 && x - val >= 0) {\n                        dp[j][x - val] = 1;\n                    }\n                }\n            }\n\n            bool f = true;\n            for (int j = 0; j < nums.size(); j++) {\n                if (dp[j][0] == 0) {\n                    f = false;\n                }\n            }\n            if (f) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n};\n\n// 4 1 2 1\n// 3 0 1 1\n\n// 0 1 3 2 1\n// 0 0 2 2 1\n// 0 0 0 0 1\n// 0 0 0 0 0\n\n// 10 5 4 3 2\n// 10 5","author":"回家","submissionId":"611261655"},[]]},{"2033":[{"id":"2033","fileName":"611262218.txt","sourceCode":"import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n\n    boolean dfs(ArrayList<Integer> list, int targe, int idx, Boolean[][] memo) {\n        if (idx < 0) return targe == 0;\n        if (memo[targe][idx] != null) return memo[targe][idx];\n        boolean ans = false;\n        if (targe >= list.get(idx)) {\n            ans = ans || dfs(list, targe - list.get(idx), idx - 1, memo);\n        }\n        ans = ans || dfs(list, targe, idx - 1, memo);\n        memo[targe][idx] = ans;\n        return ans;\n    }\n\n    boolean check(ArrayList<Integer> list, int targe) {\n        Boolean[][] memo = new Boolean[targe + 1][list.size()];\n        return dfs(list, targe, list.size() - 1, memo);\n    }\n\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length, m = queries.length;\n        int[][] add = new int[m][n];\n        boolean F = true;\n        for (int num : nums) {\n            if (num != 0) {\n                F = false;\n                break;\n            }\n        }\n        if (F) return 0;\n        ArrayList<Integer>[] adds = new ArrayList[n];\n        Arrays.setAll(adds, aux -> new ArrayList<>());\n        for (int i = 0; i < queries.length; i++) {\n            for (int j = queries[i][0]; j <= queries[i][1]; j++) {\n                adds[j].add(queries[i][2]);\n            }\n            boolean ans = true;\n            for (int j = 0; j < nums.length; j++) {\n                if (nums[j] == 0) continue;\n                ans = (ans && check(adds[j], nums[j]));\n            }\n            if (ans) return i + 1;\n        }\n        return -1;\n    }\n}","author":"时间的音符","submissionId":"611262218"},[]]},{"2034":[{"id":"2034","fileName":"611262398.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        cnt = [[] for _ in range(n)]\n        for j, (l, r, v) in enumerate(queries):\n            for i in range(l, r + 1):\n                if v <= nums[i]:\n                    cnt[i].append(j)\n        t = [m + 1] * n\n        for i, num in enumerate(nums):\n            if num == 0:\n                t[i] = 0\n                continue\n            if len(cnt[i]) == 0:\n                return -1\n            st = set()\n            for j in cnt[i]:\n                v = queries[j][2]\n                ts = st.copy()\n                for s in st:\n                    ts.add(s + v)\n                st = ts\n                st.add(v)\n                if num in st:\n                    t[i] = j + 1\n                    break\n        mx = max(t)\n        return -1 if mx == m + 1 else mx","author":"王小豆","submissionId":"611262398"},[]]},{"2035":[{"id":"2035","fileName":"611262351.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& qs) {\n        int n = nums.size(), ans = 0;\n        for(int i = 0; i < n; ++i){\n            int v = nums[i];\n            if(v == 0) continue;\n            set<int> st;\n            st.insert(0);\n            int t = -1;\n            for(int j = 0; j < qs.size(); ++j){\n                auto &qi = qs[j];\n                int l = qi[0], r = qi[1], q = qi[2];\n                if(l > i || i > r) continue;\n                set<int> st2 = st;\n                for(auto x: st2){\n                    if(x + q > v) break;\n                    st.insert(x + q);\n                }\n                if(st.find(v) != st.end()){\n                    t = j + 1;\n                    break;\n                }\n            }\n            if(t == -1) return -1;\n            //cout << i << \" \" << v << \" \" << t << \" \" << ans << endl;\n            ans = max(ans, t);\n        }\n        return ans;\n    }\n};","author":"zhangwenyao","submissionId":"611262351"},[]]},{"2036":[{"id":"2036","fileName":"611262290.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        cnt=0\n        ans = 0\n        tar = []\n        for i in nums:\n            if i==0:\n                cnt+=1\n            tar.append({i})\n        if cnt == len(nums):\n            return ans\n        for l,r,val in queries:\n            ans += 1\n            for i in range(l,r+1):\n                if nums[i] == 0:\n                    continue\n                if val in tar[i]:\n                    nums[i]=0\n                    cnt+=1\n                    if cnt == len(nums):\n                        return ans\n                else:\n                    for j in tar[i].copy():\n                        tar[i].add(j-val)\n        return -1\n                \n                ","author":"(￣▼￣)","submissionId":"611262290"},[]]},{"2037":[{"id":"2037","fileName":"611262289.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        n=len(nums)\n\n        def cal(x):\n            cnt=[Counter() for _ in range(n)]\n            \n            for l,r,w in queries[:x]:\n                for j in range(l,r+1):\n                    cnt[j][w]+=1\n                    \n            for i,v in enumerate(nums):\n                arr=list(cnt[i].items())\n                @cache\n                def dp(i,x):\n                    if not x:return True  \n                    if i==len(arr):return False\n                    for c in range(arr[i][1]+1):\n                        if c*arr[i][0]>x:break\n                        if dp(i+1,x-c*arr[i][0]):return True \n                    return False\n                if not dp(0,v):return False\n            return True \n                        \n        l,r=0,len(queries)\n        while l<=r:\n            mid=(l+r)>>1\n            if cal(mid):r=mid-1\n            else:l=mid+1\n        r+=1\n        if r>len(queries):return -1\n        return r","author":"Optimistic SutherlandOg9","submissionId":"611262289"},[]]},{"2038":[{"id":"2038","fileName":"611262429.txt","sourceCode":"\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        j_queries = [[] for _ in range(n)]\n        \n\n        for i in range(m):\n            l, r, val = queries[i]\n            for j in range(l, r + 1):\n                j_queries[j].append((i, val))\n        \n\n        for j in range(n):\n            j_queries[j].sort()\n        \n        max_k_list = []\n        for j in range(n):\n            target = nums[j]\n            if target == 0:\n                max_k_list.append(-1)\n                continue\n            \n            dp = {0: -1}  # 总和到最大索引的映射\n            covered_queries = j_queries[j]\n            for (i, val) in covered_queries:\n                tmp = {}\n                # 处理当前查询，生成新的可能和及对应的最大索引\n                for s in list(dp.keys()):\n                    current_max = dp[s]\n                    new_s = s + val\n                    new_max = max(current_max, i)\n                    if new_s > target:\n                        continue\n                    # 仅在更优的情况下更新tmp\n                    if new_s not in tmp or new_max < tmp.get(new_s, float('inf')):\n                        tmp[new_s] = new_max\n                # 合并tmp到dp中\n                for s in tmp:\n                    if s not in dp or tmp[s] < dp[s]:\n                        dp[s] = tmp[s]\n            \n            if target not in dp:\n                return -1\n            else:\n                max_k_list.append(dp[target])\n        \n        # 计算所有元素的最大索引中的最大值\n        max_needed = -1\n        for x in max_k_list:\n            if x == -1:\n                continue\n            if x > max_needed:\n                max_needed = x\n        \n        if max_needed == -1:\n            # 检查原数组是否全零\n            if all(x == 0 for x in nums):\n                return 0\n            else:\n                return -1\n        else:\n            return max_needed + 1","author":"重生之我要上瓜","submissionId":"611262429"},[]]},{"2039":[{"id":"2039","fileName":"611262433.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n,ans,m = len(nums),0,len(queries)\n        def check(idx: int) -> int:\n            i = 0\n            hash = set()\n            hash.add(nums[idx])\n            while i < m:\n                if 0 in hash:\n                    return i\n                if idx >= queries[i][0] and idx <= queries[i][1]:\n                    for x in hash.copy():\n                        x -= queries[i][2]\n                        if x >= 0:\n                            hash.add(x)\n                i += 1\n            if 0 in hash:\n                return i\n            return -1\n        for i in range(n):\n            tar = check(i)\n            if tar < 0:\n                return -1\n            ans = max(tar, ans)\n        return ans","author":"爱写代码的木更","submissionId":"611262433"},[]]},{"2040":[{"id":"2040","fileName":"611262690.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def get_times(v, target):\n            if target == 0:\n                return 0\n            times = 0\n            x = set([0])\n            for n, i in enumerate(v):\n                y = x.copy()\n                for j in x:\n                    y.add(i + j)\n                x = y\n                if target in x:\n                    return n + 1\n            print(123, x)\n            return -1\n\n        d = defaultdict(list)\n        for l, r, v in queries:\n            for j in range(len(nums)):\n                if  l<=j<=r:\n                    d[j].append(v)\n                else:\n                    d[j].append(0)\n\n        res = -1\n        for i, n in enumerate(nums):\n            target = d[i]\n            times = get_times(target, n)\n            if times == -1:\n                return -1\n            else:\n                res = max(res, times)\n        return res\n      \n        \n        \n        ","author":"user4777","submissionId":"611262690"},[]]},{"2041":[{"id":"2041","fileName":"611262468.txt","sourceCode":"class Solution {\n    fun minZeroArray(nums: IntArray, queries: Array<IntArray>): Int {\n        // queries[i] = [li, ri, vali]\n        //     nums 选择 [li, ri] 中下标子集，即枚举吗？\n        //         下标子集减去 vali？差分？\n        //         但是要正好，即可以对某个下标处理多次但是某几次需要\n        //             正好要怎么处理？\n        //             - 动态规划吗？应该就是了\n        //                 dp(numsi, queriesi, less)\n        //                     if (less < 0)\n        //                         return\n        //                     if (less == 0)\n        //                         res = min(res, queriesi)\n        //                     if (numsi in queries[queriesi][0]..queries[queriesi][1])\n        //                         dp(numsi, queriesi + 1, less - queries[queriesi][2])\n        //                     dp(numsi, queriesi + 1, less)\n        // 零数组 所有元素都等于 0\n\n        // 1 <= nums.length <= 10\n        // 1 <= queries.length <= 1000\n        // n=1000时间复杂度最多O(n 2 logn)\n        // n 就是遍历 queries，nlogn 对\n        \n        fun dp(numsi: Int, numsless: Int, queriesi: Int): Int {\n            var res = Int.MAX_VALUE\n            val cache = HashMap<Pair<Int, Int>, Boolean>()\n            fun innerdp(numsi: Int, numsless: Int, queriesi: Int) {\n                if (numsless == 0) {\n                    res = min(res, queriesi)\n                    return\n                }\n                if (queriesi >= queries.size)\n                    return\n                if (numsless to queriesi in cache)\n                    return\n                cache[numsless to queriesi] = true\n                if (numsi >= queries[queriesi][0] \n                    && numsi <= queries[queriesi][1]\n                    && numsless >= queries[queriesi][2])\n                    innerdp(numsi, numsless - queries[queriesi][2], queriesi + 1)\n                innerdp(numsi, numsless, queriesi + 1)\n            }\n            innerdp(numsi, numsless, queriesi)\n            return res\n        }\n        var ans = 0\n        \n        for (i in nums.indices) {\n            val k = dp(i, nums[i], 0)\n            if (k == Int.MAX_VALUE)\n                return -1\n            ans = max(ans, k)\n        }\n        return ans\n    }\n}","author":"Loving Merkle","submissionId":"611262468"},[]]},{"2042":[{"id":"2042","fileName":"611262803.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& qs) {\n        int n = a.size(), m = qs.size();\n\n        auto check = [&](int mid) {\n            vector<vector<int> > g(n);\n            // pre mid\n            for (int i = 0; i < mid; i++) {\n                int l = qs[i][0], r = qs[i][1], v = qs[i][2];\n                for (int j = l; j <= r; j++) {\n                    g[j].emplace_back(v);\n                }\n            }\n            // if (mid == 5) {\n            //     for (auto& e : g[0]) {\n            //         cout << e << \" \";\n            //     }\n            //     cout << \"n\";\n            // }\n            \n            vector<vector<int> > g2(n, vector<int>(1001));\n            for (int i = 0; i < n; i++) {\n                auto& t = g2[i];\n                for (auto& k : g[i]) {\n                    for (int d = 1000; d >= 0; d--) {\n                        if (!t[d]) continue;\n                        if (k + d <= 1000) {\n                            t[k + d] = 1;\n                        }\n                    }\n                    t[k] = 1;\n                }\n            }\n            \n            // if (mid == 5) {\n            //     for (auto& e : g2[0]) {\n            //         cout << e << \" \";\n            //     }\n            //     cout << \"n\";\n            // }\n            bool ok = true;\n            for (int i = 0; i < n; i++) {\n                int x = a[i];\n                if (x == 0) continue;\n                if (!g2[i][x]) {\n                    ok = false;\n                    break;\n                }\n            }\n            return ok;\n        };\n        \n        int ans = -1;\n        int l = 0, r = m;\n        while (l <= r) {\n            int mid = (l + r) >> 1;\n            if (check(mid)) {\n                ans = mid;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"另一个我","submissionId":"611262803"},[]]},{"2043":[{"id":"2043","fileName":"611262805.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n         int n = nums.length;\n        List<List<int[]>> coverage = new ArrayList<>();\n        \n        for (int i = 0; i < n; i++) {\n            List<int[]> list = new ArrayList<>();\n            for (int j = 0; j < queries.length; j++) {\n                int[] q = queries[j];\n                int l = q[0], r = q[1], val = q[2];\n                if (i >= l && i <= r) {\n                    list.add(new int[]{j, val});\n                }\n            }\n            list.sort((a, b) -> a[0] - b[0]);\n            coverage.add(list);\n        }\n        \n        int maxK = 0;\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            if (target == 0) {\n                continue;\n            }\n            List<int[]> list = coverage.get(i);\n            Map<Integer, Integer> dp = new HashMap<>();\n            dp.put(0, -1);\n            for (int[] q : list) {\n                int jIndex = q[0];\n                int val = q[1];\n                Map<Integer, Integer> temp = new HashMap<>();\n                for (Map.Entry<Integer, Integer> entry : dp.entrySet()) {\n                    int s = entry.getKey();\n                    int currentMax = entry.getValue();\n                    int newSum = s + val;\n                    int newMax = Math.max(currentMax, jIndex);\n                    if (!temp.containsKey(newSum) || newMax < temp.get(newSum)) {\n                        temp.put(newSum, newMax);\n                    }\n                }\n                for (Map.Entry<Integer, Integer> entry : temp.entrySet()) {\n                    int s = entry.getKey();\n                    int m = entry.getValue();\n                    if (!dp.containsKey(s) || m < dp.get(s)) {\n                        dp.put(s, m);\n                    }\n                }\n            }\n            if (!dp.containsKey(target)) {\n                return -1;\n            }\n            int currentMax = dp.get(target);\n            maxK = Math.max(maxK, currentMax + 1);\n        }\n        return maxK;\n    }\n}","author":"空白","submissionId":"611262805"},[]]},{"2044":[{"id":"2044","fileName":"611263011.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int res=0;\n        for(int i = 0; i < nums.size(); i++){\n            int tmpRes = calRes(queries, i, nums[i]);\n            // cout << tmpRes << endl;\n            res = max(res, tmpRes);\n        }\n        if(res==queries.size()+1) return -1;\n        return res;\n    }\n    int calRes(vector<vector<int>>& queries, int ind, int val){\n        if(val==0) return 0;\n        vector<bool> dp(val+1,false);\n        dp[val]=true;\n        for(int i = 0; i < queries.size(); i++){\n            auto query = queries[i];\n            if(ind<query[0]||ind>query[1]) continue;\n            vector<bool> tmp(val+1, false);\n            for(int j = 0; j < dp.size(); j++){\n                if(dp[j]==false) continue;\n                tmp[j] = true;\n                if(j>=query[2]){\n                    tmp[j-query[2]]=true;\n                    if(j==query[2]) return i+1;\n                }\n            }\n            dp = tmp;\n        }\n        return queries.size()+1;\n    }\n};","author":"helenjing","submissionId":"611263011"},[]]},{"2045":[{"id":"2045","fileName":"611263083.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(),m=queries.size();\n        vector<vector<int>>rem(n,vector<int>(m,0));\n        for(int i=0;i<m;i++){\n            int l=queries[i][0],r=queries[i][1],val=queries[i][2];\n            for(int j=l;j<=r;j++) rem[j][i]=val;\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            if(nums[i]==0) continue;\n            int tmp=INT_MAX;\n            unordered_set<int>st;\n            vector<int>arr;\n            arr.emplace_back(nums[i]);\n            st.emplace(nums[i]);\n            for(int j=0;j<m;j++){\n                if(rem[i][j]!=0){\n                    if(st.count(rem[i][j])){\n                        tmp=j+1;\n                        break;\n                    }\n                    for(int k=arr.size()-1;k>=0;k--){\n                        int nw=arr[k]-rem[i][j];\n                        if(nw>0&&!st.count(nw)){\n                            arr.emplace_back(nw);\n                            st.emplace(nw);\n                        }\n                    }\n                }\n            }\n            ans=max(ans,tmp);\n        }\n        return ans==INT_MAX?-1:ans;\n    }\n};","author":"杏山和纱酱","submissionId":"611263083"},[]]},{"2046":[{"id":"2046","fileName":"611263017.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int le = 0, ri = q.size(), md, sz = nums.size();\n        vector<bool> dp(1007, true);\n        auto check = [&]() -> bool {\n            for (int loc = 0; loc < sz; ++ loc) {\n                int &it = nums[loc];\n                if (!it) continue;\n                int m = it;\n                int n = md;\n                for (int i = 1; i <= m; ++ i) dp[i] = false;\n                for (int i = 0; i < n; ++ i) {\n                    int &l = q[i][0], &r = q[i][1], &val = q[i][2];\n                    if (l > loc || loc > r) continue;\n                    for (int j = m - val; j >= 0; -- j) {\n                        if (dp[j]) dp[j + val] = true;\n                    }\n                }\n                if (!dp[m]) return false;\n            }\n            return true;\n        };\n        while (le < ri) {\n            md = le + ri >> 1;\n            if (check()) ri = md;\n            else le = md + 1;\n        }\n        md = le;\n        return check() ? le : -1;\n    }\n};","author":"恣睢","submissionId":"611263017"},[]]},{"2047":[{"id":"2047","fileName":"611263117.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n,m = len(nums),len(queries)\n        dp = [set() for _ in range(n)]\n        for i in range(n):\n            dp[i].add(0)\n        ck = [-1 if num else 0 for num in nums]\n        for i,q in enumerate(queries):\n            l,r,v = q\n            for j in range(l, r+1):\n                tmp = set([i+v for i in dp[j]])\n                dp[j] = dp[j]|tmp\n                if ck[j]<0 and nums[j] in dp[j]:\n                    ck[j] = i+1\n        return max(ck) if min(ck)>=0 else -1\n        ","author":"Barcelona","submissionId":"611263117"},[]]},{"2048":[{"id":"2048","fileName":"611263173.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        res = -1\n        \n        for i, n in enumerate(nums):\n            arr = {n}\n            j = 0\n            while 0 not in arr:\n                if j >= len(queries):\n                    return -1\n                a, b, c = queries[j]\n                if a <= i <= b:\n                    arr |= {x-c for x in arr if x >= c}\n                j += 1\n            res = max(res, j)\n\n        return res","author":"BlueZ","submissionId":"611263173"},[]]},{"2049":[{"id":"2049","fileName":"611263223.txt","sourceCode":"import copy\n\n\nclass Solution:\n    def minZeroArray(self, nums, queries) -> int:\n        n=len(nums)\n        st=[1]*n\n        ret=n\n        ALL=[set([0]) for _ in range(n)]\n        for i in range(n):\n            if nums[i]==0:\n                st[i]=0\n                ret-=1\n        if ret==0:\n            return 0\n        for i in range(len(queries)):\n            l,r,val=queries[i]\n            for j in range(l,r+1):\n                if st[j]==0:continue\n                NEW=copy.deepcopy(ALL[j])\n                for k in NEW:\n                    if k+val<=1000:\n                        ALL[j].add(k+val)\n                if nums[j] in ALL[j]:\n                    st[j]=0\n                    ret-=1\n            if ret==0:\n                return i+1\n        return -1","author":"broshen","submissionId":"611263223"},[]]},{"2050":[{"id":"2050","fileName":"611263270.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        lst=[{0} for _ in range(len(nums))]\n        res=[i==0 for i in nums]\n        if all(res):\n            return 0\n        for k,(l,r,val) in enumerate(queries):\n            for i in range(l,r+1):\n                if not res[i]:\n                    s=set()\n                    for n in lst[i]:\n                        if n+val<nums[i]:\n                            s.add(n+val)\n                        elif n+val==nums[i]:\n                            res[i]=True\n                            break\n                    lst[i]|=s\n            if all(i for i in res):\n                return k+1\n        return -1","author":"浅木夏织","submissionId":"611263270"},[]]},{"2051":[{"id":"2051","fileName":"611263113.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        set<int> id;\n        vector<vector<int>> dp(n + 1, vector<int>(1010));\n        for(int i = 0; i < n; i ++){\n            if(nums[i])id.insert(i);\n            dp[i][nums[i]] = 1;\n        }\n        \n        int m = queries.size();\n        if(!id.size()) return 0;\n        for(int i = 0; i < m; i ++){\n            int val = queries[i][2];\n            for(int j = queries[i][0]; j <= queries[i][1]; j ++){\n                for(int k = 0; k <= nums[j]; k ++){\n                    if(k - val >= 0 && dp[j][k]) dp[j][k - val] = 1;\n                }\n                if(dp[j][0]) id.erase(j);\n            }\n            if(!id.size()) return i + 1;\n        }\n        \n        return -1;\n    }\n};","author":"Upbeat HugleukS","submissionId":"611263113"},[]]},{"2052":[{"id":"2052","fileName":"611263308.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int size = nums.size();\n        int qsize = queries.size();\n        int mini = 0;\n        int target;\n        for(int i=0;i<size;++i){\n            if(nums[i] == 0){\n                continue;\n            }\n            vector<bool> values(1001,false);\n            vector<int> truevalue(1,0);\n            values[0] = true;\n            bool found_value = false;\n            for(int j=0;j<qsize;++j){\n                if(queries[j][0] <= i && i <= queries[j][1]){\n                    int tpsize = truevalue.size();\n                    for(int k=0;k<tpsize;++k){\n                        target = truevalue[k] + queries[j][2];\n                        if(target < 1001 && !values[target]){\n                            values[target] = true;\n                            //cout << i << \" \" << j << \" \" << k << \" \"<< target << endl;\n                            if(target == nums[i]){\n                                mini = max(mini,j+1);\n                                found_value = true;\n                            }\n                            truevalue.push_back(target);\n                        }\n                    }\n                }\n                if(found_value){\n                    break;\n                }\n            }\n            if(!found_value){\n                return -1;\n            }\n        }return mini;\n        \n    }\n};","author":"Sparky","submissionId":"611263308"},[]]},{"2053":[{"id":"2053","fileName":"611263631.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: list[int], queries: list[list[int]]) -> int:\n        if max(nums) == 0: return 0\n\n        def able(caps, num):\n            n = len(caps)\n            tmp = set()\n            tmp.add(0)\n            for i in range(n):\n                add = set()\n                for dt in tmp:\n                    if dt + caps[i] == num:\n                        return i + 1\n                    if dt + caps[i] < num:\n                        add.add(dt + caps[i])\n                for dt in add:\n                    tmp.add(dt)\n            return -1\n\n        res = 0\n        for idx,num in enumerate(nums):\n            if num == 0: continue\n            tmp = []\n            for qr in queries:\n                if qr[0] <= idx <= qr[1]:\n                    tmp.append(qr[2])\n                else:\n                    tmp.append(0)\n            tt = able(tmp, num)\n            if tt == -1: return -1\n            res = max(res, tt)              \n            \n        return res","author":"SseVven","submissionId":"611263631"},[]]},{"2054":[{"id":"2054","fileName":"611263210.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: list[int], queries: list[list[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        c = [[[] for i in range(12)] for j in range(m + 1)]\n        for i in range(m):\n            for j in range(n):\n                c[i + 1][j] = c[i][j].copy()\n            l, r, val = queries[i]\n            for j in range(l, r + 1):\n                c[i + 1][j].append(val)\n\n        # for i in range(m + 1):\n        #     for j in range(n):\n        #         print(i,c[i][j])\n\n        def check(arr, val):\n            target = val\n            f = 1\n            for v in arr:\n                if target >= v:\n                    f |= (f & ((1 << (target - v + 1)) - 1)) << v\n            return f >> target & 1 == 1 \n\n        for i in range(m + 1):\n            l, r, _ = queries[i - 1]\n            fl = True\n            for j in range(n):\n                x = nums[j]\n                arr = c[i][j]\n                # print(i,arr)\n                if not check(arr, x):\n                    fl = False\n                    break\n            if fl:\n                return i\n        return -1\n","author":"__yyn__","submissionId":"611263210"},[]]},{"2055":[{"id":"2055","fileName":"611263642.txt","sourceCode":"class Solution\n{\n    int canReduceToZero(const vector<int> &idx, const vector<int> &mm, int num)\n    {\n        if(num == 0) return 0;\n        int n = mm.size();\n        vector<vector<bool>> dp(n + 1, vector<bool>(num + 1, false)); // dp[i][j] 表示能否用前 i 个元素凑出 j\n        dp[0][0] = true;\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j <= num; j++)\n            {\n                if (dp[i][j])\n                {\n                    dp[i + 1][j] = true;\n                    if (j + mm[i] <= num)\n                        dp[i + 1][j + mm[i]] = true;\n                }\n            }\n            if (dp[i + 1][num])\n            {\n                return idx[i] + 1;\n            }\n        }\n        return -1;\n    }\n\npublic:\n    int minZeroArray(vector<int> &nums, vector<vector<int>> &queries)\n    {\n        int k = -1;\n        for(int i = 0; i < nums.size();++i){\n            vector<int> hh;\n            vector<int> idx;\n            for(int qi = 0; qi < queries.size(); ++qi){\n                auto & q = queries[qi];\n                int l = q[0], r = q[1], v = q[2];\n                if(l <= i && i <= r){\n                    hh.push_back(v);\n                    idx.push_back(qi);\n                }\n            }\n            int kk = canReduceToZero(idx, hh,nums[i]);\n            // cout << kk << \" \";\n            if(kk != -1){k = max(k,kk);}\n            else{return -1;}\n        }\n        // cout << endl;\n        return k;\n    }\n};","author":"幸存者","submissionId":"611263642"},[]]},{"2056":[{"id":"2056","fileName":"611263471.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int q = queries.size();\n        vector<vector<int>> cover(n);\n\n        // 预处理每个元素i被哪些查询覆盖，按查询的索引顺序\n        for (int j = 0; j < q; ++j) {\n            int l = queries[j][0];\n            int r = queries[j][1];\n            for (int i = l; i <= r; ++i) {\n                cover[i].push_back(j);\n            }\n        }\n\n        int max_k = 0;\n        for (int i = 0; i < n; ++i) {\n            int target = nums[i];\n            if (target == 0) continue;\n\n            vector<int>& q_list = cover[i];\n            if (q_list.empty()) return -1;\n\n            // 计算覆盖该元素的查询的val总和\n            int total_val = 0;\n            for (int j : q_list) {\n                total_val += queries[j][2];\n            }\n            if (total_val < target) return -1;\n\n            // 动态规划寻找可能的sum\n            unordered_set<int> possible_sums;\n            possible_sums.insert(0);\n            int found_j = -1;\n\n            for (size_t idx = 0; idx < q_list.size(); ++idx) {\n                int j = q_list[idx];\n                int val = queries[j][2];\n                unordered_set<int> new_sums;\n\n                bool found = false;\n                for (int s : possible_sums) {\n                    int new_s = s + val;\n                    if (new_s == target) {\n                        found_j = j;\n                        found = true;\n                        break;\n                    } else if (new_s < target) {\n                        new_sums.insert(new_s);\n                    }\n                }\n                if (found) break;\n\n                // 将新生成的sum合并到possible_sums中\n                for (int s : new_sums) {\n                    possible_sums.insert(s);\n                }\n            }\n\n            if (found_j == -1) return -1;\n            if (found_j + 1 > max_k) {\n                max_k = found_j + 1;\n            }\n        }\n\n        return (max_k == 0) ? 0 : (max_k <= q ? max_k : -1);\n    }\n};","author":"小天才一休","submissionId":"611263471"},[]]},{"2057":[{"id":"2057","fileName":"611263976.txt","sourceCode":"struct Event {\n    int j;\n    bool is_start;\n    Event(int j, bool is_start) : j(j), is_start(is_start) {}\n};\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        \n        // 预处理每个元素的查询列表\n        vector<vector<Event>> diff_events(n + 2); // 索引0到n可能\n        for (int j = 0; j < m; ++j) {\n            int l = queries[j][0];\n            int r = queries[j][1];\n            // 处理边界情况\n            if (l < n) {\n                diff_events[l].emplace_back(j, true);\n            }\n            int end_pos = r + 1;\n            if (end_pos < n) {\n                diff_events[end_pos].emplace_back(j, false);\n            }\n        }\n        \n        vector<vector<int>> element_queries(n);\n        set<int> active;\n        for (int i = 0; i < n; ++i) {\n            // 处理当前i的事件\n            for (auto& event : diff_events[i]) {\n                int j = event.j;\n                if (event.is_start) {\n                    active.insert(j);\n                } else {\n                    active.erase(j);\n                }\n            }\n            // 将active中的查询j按顺序添加到element_queries[i]\n            element_queries[i].assign(active.begin(), active.end());\n        }\n        \n        int max_k = -1;\n        for (int i = 0; i < n; ++i) {\n            int target = nums[i];\n            if (target == 0) {\n                continue; // k_i是-1，不影响max_k的最大值\n            }\n            \n            vector<int>& qjs = element_queries[i];\n            unordered_map<int, int> dp;\n            dp[0] = -1;\n            for (int j : qjs) {\n                int val = queries[j][2];\n                // 需要克隆当前的dp，避免修改影响后续处理\n                auto temp_dp = dp;\n                for (auto& [s, current_j] : temp_dp) {\n                    int new_s = s + val;\n                    int new_j = max(current_j, j);\n                    if (!dp.count(new_s) || new_j < dp[new_s]) {\n                        dp[new_s] = new_j;\n                    }\n                }\n            }\n            if (!dp.count(target)) {\n                return -1;\n            }\n            int k_i = dp[target];\n            if (k_i > max_k) {\n                max_k = k_i;\n            }\n        }\n        \n        if (max_k == -1) {\n            // 所有元素初始为0\n            return 0;\n        } else if (max_k >= m) {\n            return -1;\n        } else {\n            return max_k + 1;\n        }\n    }\n};","author":"xzbcc979","submissionId":"611263976"},[]]},{"2058":[{"id":"2058","fileName":"611264114.txt","sourceCode":"def subset_sum(nums, target):\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for num in nums:\n        for j in range(target, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    return dp[target]\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        idx_map = {}\n        for i in range(n):\n            idx_map[i] = []\n\n        def check():\n            for idx, arr in idx_map.items():\n                t = nums[idx]\n                if not subset_sum(arr, t):\n                    return False\n            return True\n\n        if check():\n            return 0\n        \n        for i, (l, r, v) in enumerate(queries):\n            for j in range(l, r + 1):\n                idx_map[j].append(v)\n            if check():\n                return i + 1\n        return -1","author":"TonyDon","submissionId":"611264114"},[]]},{"2059":[{"id":"2059","fileName":"611263728.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def solve(x,a):\n            # 最少需要前多少个元素可以组合成x\n            # print(f\"solving x={x} a={a}\")\n            if x==0:\n                return 0\n            ma={}\n            for qid,d in a:\n                if d>x:\n                    continue\n                oldkeys=list(ma.keys())\n                for i in oldkeys:\n                    if i+d<=x:                        \n                        ma[i+d]=1\n                ma[d]=1\n                # print(\"qid=\",qid,ma)\n                if x in ma:\n                    return qid\n            return 1e9\n        if len(queries)==0 and max(nums)>0:\n            return -1\n        if max(nums)==0:\n            return 0\n        ans=0\n        for i,v in enumerate(nums):\n            if v==0:\n                continue\n            a=[(qid,d) for qid,(l,r,d) in enumerate(queries) if l<=i and r>=i]\n            now=solve(v,a)\n            # print(f\"i={i} v={v} now={now}\")\n            ans=max(ans,now)\n        if ans>=len(queries):\n            return -1\n        return ans+1","author":"wyf","submissionId":"611263728"},[]]},{"2060":[{"id":"2060","fileName":"611263971.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        queries_per_element = [[] for _ in range(n)]\n\n        for idx, (l, r, val) in enumerate(queries):\n            if val == 0:\n                continue\n            l = max(l, 0)\n            r = min(r, n - 1)\n            for j in range(l, r + 1):\n                queries_per_element[j].append((idx, val))\n\n        for j in range(n):\n            queries_per_element[j].sort()\n\n        max_k = -1\n        for j in range(n):\n            target = nums[j]\n            if target < 0:\n                return -1\n            if target == 0:\n                continue\n\n            q_list = queries_per_element[j]\n            sum_val = sum(val for _, val in q_list)\n            if sum_val < target:\n                return -1\n\n            dp = {0: -1}\n            for i, val in q_list:\n                new_dp = {}\n                for s in dp:\n                    current_max = dp[s]\n                    if s in new_dp:\n                        if current_max < new_dp[s]:\n                            new_dp[s] = current_max\n                    else:\n                        new_dp[s] = current_max\n\n                    s_new = s + val\n                    if s_new > target:\n                        continue\n                    new_max = max(current_max, i)\n                    if s_new in new_dp:\n                        if new_max < new_dp[s_new]:\n                            new_dp[s_new] = new_max\n                    else:\n                        new_dp[s_new] = new_max\n                dp = new_dp\n\n            if target not in dp:\n                return -1\n            k_j = dp[target]\n            if k_j > max_k:\n                max_k = k_j\n\n        if max_k == -1:\n            return 0\n        else:\n            return max_k + 1 if max_k + 1 <= len(queries) else -1\n\n","author":"Jarvan","submissionId":"611263971"},[]]},{"2061":[{"id":"2061","fileName":"611264314.txt","sourceCode":"class Solution {\npublic:\n    bool dp[11][1003];\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size();\n        int m = q.size();\n        for (int i = 0; i < n; i++)\n            dp[i][a[i]] = 1;\n        bool flag = 1;\n        for (int j = 0; j < n; j++)\n            if (dp[j][0] == 0)\n                flag = 0;\n        if (flag)\n            return 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = q[i][0]; j <= q[i][1]; j++) {\n                for (int k = q[i][2]; k <= 1000; k++)\n                    if (dp[j][k])\n                        dp[j][k - q[i][2]] = 1;\n            }\n            bool flag = 1;\n            for (int j = 0; j < n; j++)\n                if (dp[j][0] == 0)\n                    flag = 0;\n            if (flag)\n                return i + 1;\n        }\n        return -1;\n    }\n};","author":"仲舟","submissionId":"611264314"},[]]},{"2062":[{"id":"2062","fileName":"611264035.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        auto check = [&](int k) -> bool {\n            for (int i = 0; i < n; i ++) {\n                int target = nums[i];\n                vector<bool> dp(target + 1, false);\n                dp[0] = true;\n                for (int j = 0; j < k; j ++) {\n                    int l = queries[j][0], r = queries[j][1], val = queries[j][2];\n                    if (i < l || i > r) continue;\n                    for (int s = target - val; s >= 0; s --) {\n                        if (dp[s]) {\n                            dp[s + val] = true;\n                        }\n                    }\n                }\n                if (!dp[target]) return false;\n            }\n            return true;\n        };\n        \n        int l = 0, r = m;\n        while(l < r) {\n            int mid = (l + r) >> 1;\n            if(check(mid))\n                r = mid;\n            else \n                l = mid + 1;\n        }\n        return check(l) ? l : -1;\n    }\n};\n","author":"已延毕，勿扰","submissionId":"611264035"},[]]},{"2063":[{"id":"2063","fileName":"611264410.txt","sourceCode":"class Solution {\npublic:\n    static int minZeroArray(const vector<int> &nums, const vector<vector<int>> &queries) {\n        if (ranges::all_of(nums, [](const int &x) { return x == 0; })) return 0;\n        \n        const int n = static_cast<int>(nums.size());\n        int unDone = n;\n        vector<char> done(n);\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == 0) {\n                --unDone;\n                done[i] = 1;\n            }\n        }\n        \n        vector<unordered_set<int>> sums(n, {0});\n        for (int i = 0; i < queries.size(); ++i) {\n            const int v = queries[i][2];\n            \n            for (int j = queries[i][0]; j <= queries[i][1]; ++j) {\n                if (done[j] || v > nums[j]) continue;\n\n                if (sums[j].contains(nums[j] - v)) {\n                    --unDone;\n                    done[j] = 1;\n                    continue;\n                }\n                \n                vector<int> reach;\n                for (const int sum: sums[j]) {\n                    if (sum < nums[j] - v) reach.push_back(sum + v);\n                }\n                sums[j].insert(reach.begin(), reach.end());\n            }\n            \n            if (unDone == 0) return i + 1;\n        }\n        \n        return -1;\n    }\n};","author":"trdtrdsd","submissionId":"611264410"},[]]},{"2064":[{"id":"2064","fileName":"611264333.txt","sourceCode":"class Solution {\npublic:\n    bool check(vector<int>& nums, vector<vector<bool> >&dp){\n        int n=nums.size();\n        for(int i=0; i<n; i++){\n            if(dp[i][0]==0)return 0;\n        }\n        return 1;\n    }\n    void getdp(int k, vector<vector<bool> >&dp){\n        cout<<\"query \"<<k<<endl;\n        for(int j=0; j<dp.size(); j++){\n            for(int cur=0; cur<=10; cur++ ){\n                cout<<dp[j][cur]<<' ';\n            }\n            cout<<endl;\n        }\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(), qn=queries.size();\n        vector<vector<bool> >dp(n, vector<bool>(1001, 0));\n        for(int i=0; i<n; i++){\n            dp[i][nums[i]]=1;\n        }\n        if(check(nums, dp))return 0;\n        for(int i=0; i<qn; i++){\n            int l=queries[i][0];\n            int r=queries[i][1];\n            int v=queries[i][2];\n            \n            for(int j=l; j<=r; j++){\n                for(int cur=0; cur<=nums[j]-v; cur++ ){\n                    dp[j][cur]=dp[j][cur] || dp[j][cur+v];\n                }\n            }\n            if(check(nums, dp)){\n                return i+1;\n            }\n            // getdp(i,dp);\n        }\n        return -1;\n    }\n};","author":"Zhang-Jiahui","submissionId":"611264333"},[]]},{"2065":[{"id":"2065","fileName":"611264464.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        h = {}\n        b = []\n        for i in range(len(nums)):\n            h[i] = {-nums[i]}\n            b.append(True if -nums[i] == 0 else False)\n        if all(b):\n            return 0\n        # print(h)\n        for k, q in enumerate(queries):\n            l1 = q[0]\n            r1 = q[1]\n            val1 = q[2]\n            for i in range(l1, r1+1):\n                # print(i)\n                new_set = {x + val1 for x in h[i]}\n                h[i] |= new_set\n                if 0 in h[i]:\n                    b[i] = True\n            # print(h)\n            if all(b):\n                return k+1\n        return -1","author":"芦荟","submissionId":"611264464"},[]]},{"2066":[{"id":"2066","fileName":"611264206.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        int ans = 0;\n        bool f = true;\n        for(int i = 0; i < n; ++i) {\n            if(nums[i] != 0) {\n                f = false;\n                break;\n            }\n        }\n        if(f) return 0;\n        for(int i = 0; i < n; ++i) {\n            vector<bool> dp(1001);\n            dp[0] = true;\n            bool f = false;\n            for(int j = 0; j < m; ++j) {\n                if (queries[j][0] <= i && queries[j][1] >= i)\n                {\n                    for (int k = 1000 - queries[j][2]; k >= 0; --k)\n                    {\n                        dp[k + queries[j][2]] = dp[k + queries[j][2]] | dp[k];\n                        if(dp[nums[i]]) break;\n                    }\n                }\n                if(dp[nums[i]]) {\n                    f = true;\n                    ans = max(ans, j + 1);\n                    break;\n                }\n            }\n            if(!f) return -1;\n        }\n        return ans;\n    }\n};","author":"梦见月瑞希","submissionId":"611264206"},[]]},{"2067":[{"id":"2067","fileName":"611264512.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int[] diff = new int[n];\n        Set<Integer>[] temp = new Set[n];\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            temp[i] = new HashSet<>();\n            temp[i].add(0);\n            sum += nums[i];\n        }\n        if (sum == 0) {\n            return 0;\n        }\n        \n        for (int i = 0; i < queries.length; i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n\n            for (int j = l; j <= r; j++) {\n                List<Integer> path = new ArrayList<>();\n                for (int k : temp[j]) {\n                    path.add(k + val);\n                }\n                path.add(val);\n                for (int k : path) {\n                    temp[j].add(k);\n                }\n            }\n            boolean flag = false;\n            for (int j = 0; j < n; j++) {\n                flag = false;\n                for (int k : temp[j]) {\n                    if (k == nums[j]) {\n                        flag = true;\n                        break;\n                    }\n                }\n                if (flag == false) {\n                    break;\n                }\n            }\n            if(flag) {\n                return i+1;\n            }\n        }\n\n        return -1;\n    }\n}","author":"fms231","submissionId":"611264512"},[]]},{"2068":[{"id":"2068","fileName":"611264550.txt","sourceCode":"def earliest_element(n, arr):\n    if n==0:\n        return 0\n    current_remains = {n}\n    for index, num in enumerate(arr):\n        new_remains = set()\n        found = False\n        for s in current_remains:\n            # 不减去当前元素，保留剩余值\n            new_remains.add(s)\n            # 减去当前元素，如果合法\n            if s >= num:\n                new_s = s - num\n                if new_s == 0:\n                    found = True\n                new_remains.add(new_s)\n        if found:\n            return index+1\n        current_remains = new_remains\n    return -1\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, m = len(nums), len(queries)\n        matrix = [[0 for _ in range(m)] for _ in range(n)]\n        for j in range(m):\n            for i in range(queries[j][0],queries[j][1]+1):\n                matrix[i][j] = queries[j][2]\n        ans = []\n        for i in range(n):\n            #print(nums[i],matrix[i])\n            tmp = earliest_element(nums[i],matrix[i])\n            if tmp == -1:\n                return -1\n            ans.append(tmp)\n\n        return max(ans)\n\n        ","author":"PaulKKK","submissionId":"611264550"},[]]},{"2069":[{"id":"2069","fileName":"611264889.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = queries.size(), m = nums.size();\n        int ans = -1;\n        for (int k = 0; k < m; k++) {\n            int x = nums[k];\n            if (x == 0) {\n                ans = max(ans, 0);\n                continue;\n            }\n            \n            vector<bool> f(x + 1, false);\n            f[x] = true;\n            for (int i = 0; i < n; i++) {\n                int l = queries[i][0], r = queries[i][1], val =queries[i][2];\n                if (k < l || k > r) continue;\n                \n                for (int j = val; j <= x; j++) {\n                    f[j - val] = f[j] || f[j - val];\n                }\n                if (f[0] == true) {\n                    ans = max(ans, i + 1);\n                    break;\n                }\n            }\n            if (f[0] == false) return -1;\n        }\n        return ans;\n    }\n};","author":"Epic Noether5mF","submissionId":"611264889"},[]]},{"2070":[{"id":"2070","fileName":"611264624.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        m = len(queries)\n        n = len(nums)\n        queries_for = [[] for _ in range(n)]\n        for idx, (l, r, val) in enumerate(queries):\n            for i in range(l, r + 1):\n                queries_for[i].append((val, idx))\n        max_k = 0\n        for i in range(n):\n            target = nums[i]\n            if target == 0:\n                continue  \n            q_list = queries_for[i]\n            if not q_list and target != 0:\n                return -1 \n            INF = float('inf')\n            dp = [INF] * (target + 1)\n            dp[0] = -1 \n            for val, idx in q_list:\n                for s in range(target, -1, -1):\n                    if dp[s] != INF:\n                        new_s = s + val\n                        if new_s > target:\n                            continue\n                        candidate_max = max(dp[s], idx)\n                        if candidate_max < dp[new_s]:\n                            dp[new_s] = candidate_max\n            \n            if dp[target] == INF:\n                return -1\n            current_k = dp[target] + 1\n            if current_k > max_k:\n                max_k = current_k\n        \n\n        if max_k > m:\n            return -1\n        return max_k if max_k != 0 else 0","author":"好朋友","submissionId":"611264624"},[]]},{"2071":[{"id":"2071","fileName":"611264661.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        int mx=INT_MIN;\n        for(int i=0;i<n;i++){\n            mx=max(mx,nums[i]);\n        }\n        if(mx==0) return 0;\n        vector<vector<bool>>dp(n,vector<bool>(1005,false));\n        for(int i=0;i<n;i++){\n            dp[i][0]=true;\n        }\n        for(int i=0;i<queries.size();i++){\n            int l=queries[i][0],r=queries[i][1],v=queries[i][2];\n            for(int j=l;j<=r;j++){\n                for(int k=nums[j];k>=v;k--){\n                    dp[j][k]=(dp[j][k]||dp[j][k-v]);\n                }\n            }\n            int cnt=0;\n            for(int j=0;j<n;j++){\n                if(dp[j][nums[j]]) cnt++;\n            }\n            if(cnt==n) return i+1;\n        }\n        return -1;\n    }\n};","author":"迷鹿","submissionId":"611264661"},[]]},{"2072":[{"id":"2072","fileName":"611265013.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        int sum=0;\n        for(int i=0;i<n;i++)\n            {\n                if(nums[i]>0)\n                    sum++;\n            }\n        int m=queries.size();\n        if(sum==0)\n            return 0;\n        vector<vector<pair<int,int>>> v(n);\n        for(int i=0;i<n;i++)\n            {\n                for(int j=0;j<m;j++)\n                    {\n                        int l=queries[j][0];\n                        int r=queries[j][1];\n                        int val=queries[j][2];\n                        if(i<=r&&i>=l)\n                        {\n                            v[i].push_back({val,j});\n                        }\n                    }\n            }\n        vector<int> dp;\n        vector<int> ans(n,-1);\n        for(int i=0;i<n;i++)\n            {\n                if(nums[i]>0)\n                {\n                    dp.resize(nums[i]+1,0);\n                    dp[0]=1;\n                    for(int j=1;j<=nums[i];j++)\n                        {\n                            dp[j]=0;\n                        }\n                    for(auto [val,j]:v[i])\n                        {\n                            for(int t=nums[i];t>=val;t--)\n                                {\n                                    dp[t]=max(dp[t],dp[t-val]);\n                                }\n                            if(dp[nums[i]]>0)\n                            {\n                                ans[i]=j;\n                                break;\n                            }\n                        }\n                    if(ans[i]==-1)\n                        return -1;\n                }\n                else\n                {\n                    ans[i]=0;\n                }\n            }\n        int ma=0;\n        for(int i=0;i<n;i++)\n            {\n                ma=max(ma,ans[i]);\n            }\n        return ma+1;\n    }\n};","author":"胡冻僵","submissionId":"611265013"},[]]},{"2073":[{"id":"2073","fileName":"611264950.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n_p = [set() for _ in range(len(nums))]\n        reach = [10**9] * (len(nums))\n        for i in range(len(nums)):\n            n_p[i] = set()\n            n_p[i].add(0)\n            if nums[i] == 0:\n                reach[i] = 0\n        index = 1\n       \n        for q in queries:\n            l = q[0]\n            r = q[1]\n            v = q[2]\n            for i in range(l,r+1):\n                if (reach[i]<index):\n                    continue\n                temp = []\n                for ele in n_p[i]:\n                    temp.append(ele + v)\n                    if ele + v == nums[i]:\n                        reach[i] = min(reach[i], index)\n          \n                n_p[i].update(temp)\n            #     print(n_p[i])\n            # print(\"n\")\n                \n            index += 1\n        return -1 if max(reach) == 10**9 else max(reach)\n        ","author":"taoria","submissionId":"611264950"},[]]},{"2074":[{"id":"2074","fileName":"611265063.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n int n = nums.size();\n        int q = queries.size();\n\n        vector<vector<pair<int, int>>> positionQueries(n);\n        for (int i = 0; i < q; ++i) {\n            int left = queries[i][0];\n            int right = queries[i][1];\n            int value = queries[i][2];\n            for (int j = left; j <= right; ++j) {\n                positionQueries[j].emplace_back(value, i);\n            }\n        }\n\n        int result = -1;\n        for (int i = 0; i < n; ++i) {\n            int targetValue = nums[i];\n            if (targetValue == 0) {\n                result =max(result, 0);\n                continue;\n            }\n\n            unordered_map<int, int> dp;\n            dp[0] = -1;\n\n            for (const auto& query : positionQueries[i]) {\n                int val = query.first;\n                int index = query.second;\n                unordered_map<int, int> newDp = dp;\n                for (const auto& [sum, maxIndex] : dp) {\n                    int newSum = sum + val;\n                    if (newSum > targetValue) continue;\n                    int newMaxIndex = max(maxIndex, index);\n                    if (newDp.find(newSum) == newDp.end() || newMaxIndex < newDp[newSum]) {\n                        newDp[newSum] = newMaxIndex;\n                    }\n                }\n                dp = newDp;\n            }\n\n            if (dp.find(targetValue) == dp.end()) {\n                return -1;\n            }\n\n            int maxQueryIndex = dp[targetValue];\n            int currentK = maxQueryIndex + 1;\n            result = max(result, currentK);\n        }\n\n        return result;\n    }\n};","author":"Patronum","submissionId":"611265063"},[]]},{"2075":[{"id":"2075","fileName":"611264876.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size();\n        int mx=ranges::max(nums);\n        vector dp(n,vector<bool>(mx+1,false));\n        for(int i=0;i<n;i++){\n            dp[i][0]=1;\n        }\n        vector<bool> isR(n);\n        auto chk=[&](){\n            for(int i=0;i<n;i++){\n                if(!isR[i]){\n                    return false;\n                }\n            }\n            return true;\n        };\n        for(int j=0;j<n;j++){\n            if(dp[j][nums[j]]){\n                isR[j]=true;\n            }\n        }\n        if(chk()){\n            return 0;\n        }\n        int m=queries.size();\n        int p=-1;\n        for(int i=0;i<m;i++){\n            int l=queries[i][0];\n            int r=queries[i][1];\n            int val=queries[i][2];\n            for(int j=l;j<=r;j++){\n                // if(isR[j]){\n                //     continue;\n                // }\n                for(int k=nums[j];k>=val;k--){\n                    if(dp[j][k-val]){\n                        dp[j][k]=dp[j][k]||true;\n                    }\n                }\n            }\n            for(int j=0;j<n;j++){\n                if(dp[j][nums[j]]){\n                    isR[j]=true;\n                }\n            }\n            if(chk()){\n                p=i+1;\n                break;\n            }\n        }\n        return p;\n    }\n};","author":"Juross","submissionId":"611264876"},[]]},{"2076":[{"id":"2076","fileName":"611265211.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(),m=queries.size(),res=0;\n        for (int i=0;i<n;++i){\n            if (nums[i]==0){\n                continue;\n            }\n            vector<int> store(1001,0);\n            store[0]=1;\n            int max_num=0;\n            for (int j=0;j<m;++j){\n                if (queries[j][0]<=i && i<=queries[j][1]){\n                    for (int k=max_num;k>=0;--k){\n                        if (k+queries[j][2]>1000 || store[k]==0){\n                            continue;\n                        }\n                        store[k+queries[j][2]]=1;\n                    }\n                    max_num=min(max_num+queries[j][2],1000);\n                    if (store[nums[i]]==1){\n                        res=max(res,j+1);\n                        break;\n                    }\n                }\n            }\n            if (store[nums[i]]==0){\n                return -1;\n            }\n        }\n        return res;\n    }\n};","author":"小小打凤凰","submissionId":"611265211"},[]]},{"2077":[{"id":"2077","fileName":"611265076.txt","sourceCode":"\nclass Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        // 每一步都可以选或者不选\n        // 第几个数+上一步的值\n        boolean[][] vals = new boolean[nums.length][1001];\n        for (int i = 0; i < nums.length; i++) {\n            vals[i][nums[i]] = true;\n        }\n        boolean ok2 = true;\n        for (int j = 0; j < nums.length; j++) {\n            if (!vals[j][0]) {\n                ok2 = false;\n            }\n        }\n        if (ok2) {\n            return 0;\n        }\n        for (int i = 0; i < queries.length; i++) {\n            for (int j = queries[i][0]; j <= queries[i][1]; j++) {\n                for (int k = 0; k <= 1000; k++) {\n                    if (vals[j][k]) {\n                        //选\n                        if (k - queries[i][2] >= 0) {\n                            vals[j][k - queries[i][2]] = true;\n                        }\n                    }\n                }\n            }\n            boolean ok = true;\n            for (int j = 0; j < nums.length; j++) {\n                if (!vals[j][0]) {\n                    ok = false;\n                }\n            }\n            if (ok) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n}","author":"抽烟喝酒打麻将","submissionId":"611265076"},[]]},{"2078":[{"id":"2078","fileName":"611265200.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        doc = [[i] for i in nums]\n        k = 0\n\n        if sum(nums) == 0:\n            return 0\n        \n        for l, r, v in queries:\n            k += 1\n            for i in range(l, r + 1):\n                if nums[i] == 0:\n                    continue\n                tmp = list(doc[i])\n                for j in tmp:\n                    if j - v > 0:\n                        doc[i].append(j - v)\n                    elif j - v == 0:\n                        nums[i] = 0\n                        break\n                doc[i] = list(set(doc[i]))\n            if sum(nums) == 0:\n                return k\n\n        return -1\n        ","author":"盛骓","submissionId":"611265200"},[]]},{"2079":[{"id":"2079","fileName":"611265162.txt","sourceCode":"bool dp[1005];\nclass Solution {\npublic:\n    int n,m; \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        n=nums.size();\n        for(int i=0;i<n;i++){\n            if(nums[i]!=0)break;\n            if(i==n-1)return 0;\n        }\n        m=queries.size();\n        int ans=-1;\n        vector<pair<int,int>>p[10];\n        int cot=0;\n        for(auto&x:queries){\n            cot++;\n            for(int i=x[0];i<=x[1];i++){\n                p[i].push_back({x[2],cot});\n            }\n        }\n        for(int i=0;i<n;i++){\n            int x=nums[i],l=p[i].size();\n            for(int t=0;t<=x;t++)dp[t]=false;\n            dp[0]=true;\n            for(int j=0;j<l;j++){\n                int y=p[i][j].first;\n                for(int k=1000;k>=y;k--){\n                    dp[k]=dp[k]|dp[k-y];\n                }\n                if(dp[x]){\n                    ans=max(ans,p[i][j].second); \n                    break;\n                }\n            }\n            if(!dp[x])return -1;\n        }\n        return ans;\n    }\n};","author":"Infallible FeynmanBTV","submissionId":"611265162"},[]]},{"2080":[{"id":"2080","fileName":"611265426.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int zero = 0;\n        Set<Integer>[] sets = new HashSet[n];\n        boolean[] visit = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) {\n                visit[i] = true;\n                zero++;\n            }\n            sets[i] = new HashSet<>();\n        }\n        if (zero == n) {\n            return 0;\n        }\n        for (int i = 0; i < queries.length; i++) {\n            int[] query = queries[i];\n            for (int j = query[0]; j <= query[1]; j++) {\n                if (visit[j]) {\n                    continue;\n                }\n                if (nums[j] < query[2]) {\n                    continue;\n                }\n                if (nums[j] == query[2] || sets[j].contains(query[2])) {\n                    visit[j] = true;\n                    zero++;\n                    if (zero == n) {\n                        return i + 1;\n                    }\n                    continue;\n                }\n                List<Integer> addList = new ArrayList<>();\n                addList.add(nums[j] - query[2]);\n                for (int pre : sets[j]) {\n                    if (pre < query[2]) {\n                        continue;\n                    }\n                    addList.add(pre - query[2]);\n                }\n                sets[j].addAll(addList);\n            }\n        }\n        return -1;\n    }\n}","author":"幸福啦啦啦","submissionId":"611265426"},[]]},{"2081":[{"id":"2081","fileName":"611265394.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {\n        int n = nums.size(), m = q.size();\n        vector<vector<int>> f(n,vector<int>(1001,0));\n        int cnt = 0;\n        for(int i = 0;i < n;i++){\n            f[i][0] = 1;\n            cnt += nums[i] == 0;\n        }\n        if(cnt == n) return 0;\n\n        for(int i = 0;i < m;i++){\n            int l = q[i][0];\n            int r = q[i][1];\n            int v = q[i][2];\n            for(int j = l;j <= r;j++){\n                vector<int> &f2 = f[j];\n                for(int k = nums[j];k >= v;k--){\n                    f2[k] |= f2[k - v];\n                }\n            }\n            cnt = 0;\n            for(int j = 0;j < n;j++){\n                if(f[j][nums[j]])++cnt;\n            }\n            if(cnt == n) return i + 1;\n        }\n        return -1;\n    }\n}; ","author":"小刀刺大熊","submissionId":"611265394"},[]]},{"2082":[{"id":"2082","fileName":"611265444.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        all_j_max = []\n        for i in range(len(nums)):\n            x = nums[i]\n            if x == 0:\n                all_j_max.append(-1)\n                continue\n            dp = {0: -1}\n            for j in range(len(queries)):\n                l, r, val = queries[j]\n                if l > i or r < i:\n                    continue\n                tmp = {}\n                for s in list(dp.keys()):\n                    current_j_max = dp[s]\n                    new_s = s + val\n                    if new_s > x:\n                        continue\n                    new_j_max = max(current_j_max, j)\n                    if new_s in tmp:\n                        if new_j_max < tmp[new_s]:\n                            tmp[new_s] = new_j_max\n                    else:\n                        tmp[new_s] = new_j_max\n                for s in tmp:\n                    if s in dp:\n                        if tmp[s] < dp[s]:\n                            dp[s] = tmp[s]\n                    else:\n                        dp[s] = tmp[s]\n            if x not in dp:\n                return -1\n            all_j_max.append(dp[x])\n        \n        max_j = max(all_j_max)\n        if max_j == -1:\n            return 0\n        return max_j + 1","author":"绫小路","submissionId":"611265444"},[]]},{"2083":[{"id":"2083","fileName":"611265328.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if sum(nums) == 0:\n            return 0\n        n, m = len(nums), len(queries)\n        ans = [inf] * n\n        dic = [set([0]) for _ in range(n)]\n        for i, x in enumerate(nums):\n            if x == 0:\n                ans[i] = 0\n        for q, (l, r, v) in enumerate(queries):\n            for i in range(l, r+1):\n                if ans[i] == inf:\n                    x = nums[i]\n                    tmp = set()\n                    for s in dic[i]:\n                        if s + v <= x:\n                            tmp.add(s + v)\n                    dic[i] |= tmp\n                    if x in dic[i]:\n                        ans[i] = q\n        mx = max(ans)\n        return -1 if mx == inf else mx + 1","author":"wormchaos","submissionId":"611265328"},[]]},{"2084":[{"id":"2084","fileName":"611266094.txt","sourceCode":"class Solution {\npublic:\n    bool judge(vector<int>& nums){\n        for(auto i:nums){\n            if(i!=0){\n                return false;\n            }\n        }\n        return true;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int cur = 0;\n        int n = nums.size();\n        if(judge(nums)){\n            return 0;\n        }\n        set<int> st[20];\n        for(int i=0;i<n;i++){\n            st[i].insert(0);\n        }\n        for(auto i:queries){\n            int l,r,d;\n            l=i[0],r=i[1],d=i[2];\n            cur ++;\n            for(int j=l;j<=r;j++){\n                set<int> st2;\n                for(auto k:st[j]){\n                    st2.insert(k+d);\n                }\n                st2.insert(d);\n                for(auto k:st2)\n                    st[j].insert(k);\n                // st[j]=st2;\n            }\n            bool ok = true;\n            for(int i=0;i<n;i++){\n                // for(auto j:st[i]){\n                //     cout<<j<<\" \";\n                // }cout<<endl;\n                if(st[i].find(nums[i])==st[i].end()){\n                    ok = false;\n                    // break;\n                }\n            }\n            if(ok){\n                return cur;\n            }\n                \n        }\n        return -1;\n    }\n};","author":"光球层上的黑子","submissionId":"611266094"},[]]},{"2085":[{"id":"2085","fileName":"611265721.txt","sourceCode":"class Solution {\npublic:\n    int vis[10010];\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        using pii = pair<int,int>;\n        int summ=0;\n        for(auto &c:queries) summ += c[2];\n        \n        int ret = -1;\n        for(int i=0;i<nums.size();i++){\n            int val=nums[i];\n            if(val==0) continue;\n            vector<pii> ar;\n            for(int j=0;j<queries.size();j++){\n                int l = queries[j][0];\n                int r = queries[j][1];\n                int v = queries[j][2];\n                if(l<=i&&i<=r)\n                    ar.push_back({j,v});\n            }\n            memset(vis,0,sizeof(vis));\n            \n            vis[0] = 1;\n            bool flag=false;\n            for(int j=0;j<ar.size();j++){\n                if(ar[j].second==val){\n                    ret = max(ret,ar[j].first);\n                    flag=1;\n                    break;\n                }\n                if(val>=ar[j].second&&vis[val-ar[j].second]){\n                    ret = max(ret,ar[j].first);\n                    flag=1;\n                    break;\n                }\n                for(int k=summ;k>=0;k--){\n                    if(vis[k]==1){\n                        vis[k+ar[j].second] = 1;\n                    }\n                }\n                \n            }\n            if(!flag) return -1;\n            \n            \n        }\n        return ret+1;\n        \n    }\n};","author":"冲","submissionId":"611265721"},[]]},{"2086":[{"id":"2086","fileName":"611265618.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        zero = [False] * (pow(2, math.ceil(math.log2(len(nums))) + 1)+1)\n        options = defaultdict(set)\n        \n        def build(s: int, t: int, p: int):\n            if s == t:\n                if nums[s-1] == 0:\n                    zero[p] = True\n                else:\n                    options[s-1].add(0)\n                return\n            m = s + ((t - s) >> 1)\n            build(s, m, p*2)\n            build(m+1, t, p*2+1)\n            zero[p] = zero[p*2] and zero[p*2+1]\n        build(1, len(nums), 1)\n\n        def update(l: int, r: int, s: int, t: int, p: int, n: int):\n            if zero[p]:\n                return\n            if s == t:\n                num = nums[s-1]\n                tmp = options[s-1].copy()\n                for op in tmp:\n                    options[s-1].add(op+n)\n                if num in options[s-1]:\n                    zero[p] = True\n                return\n            m = s + ((t - s) >> 1)\n            if l <= m:\n                update(l, min(r, m), s, m, p*2, n)\n            if m < r:\n                update(max(l, m+1), r, m+1, t, p*2+1, n)\n            zero[p] = zero[p*2] and zero[p*2+1]\n\n        if zero[1]:\n            return 0\n        k = 0\n        for s, t, n in queries:\n            update(s+1, t+1, 1, len(nums), 1, n)\n            k += 1\n            if zero[1]:\n                return k\n        return -1","author":"idiot","submissionId":"611265618"},[]]},{"2087":[{"id":"2087","fileName":"611266152.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int i,j,ij,x,y,n=nums.size(), m=queries.size(), ans = -1,mi=0,ma=m-1,mid,k=0;\n        int a[1020];\n        for(i=0;i<n;++i) if (nums[i]!=0) k=1;\n        if (k==0) return 0;\n        while(mi<=ma){\n            mid = (mi+ma)/2;\n            k=0;\n            for(i=0;i<n;++i){\n                memset(a,0,sizeof(a));\n                a[0] = 1;\n                //printf(\"1::%d,%d,%dn\",mid, i,nums[i]);\n                for(j=0;j<=mid;++j) if (queries[j][0]<=i && queries[j][1]>=i && queries[j][2]<=nums[i]){\n                    //printf(\"%d,%dn\", j, queries[j][2]);\n                    for(ij=999;ij>=0;--ij) if (a[ij] ==1 && ij+queries[j][2] <=nums[i]) {\n                        a[ij+queries[j][2]] =1;\n                        //printf(\"%d,%dn\", ij+queries[j][2], a[ij+queries[j][2]]);\n                    }\n                    if (a[nums[i]] ==1) break;\n                }\n                if (a[nums[i]] ==0){\n                    //printf(\"%d,%d,%dn\", mid, nums[i], a[nums[i]]);\n                    k=1;break;\n                } \n            }\n            if (k==0){\n                if (ma ==mi) return ma+1;\n                ma = mid;\n            }else{\n                mi = mid+1;\n            }\n        }\n\n        \n        return -1;\n    }\n};","author":"算法笔试","submissionId":"611266152"},[]]},{"2088":[{"id":"2088","fileName":"611266038.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<set<int>> can(nums.size());\n        for(int i=0;i<nums.size();i++){\n            if(nums[i]==0) continue;\n            can[i].insert(nums[i]);\n        }\n        for(int i=0;i<nums.size();i++){\n            if(!can[i].empty()) break;\n            if(i==nums.size()-1) return 0;\n        }\n\n        for(int i=0;i<queries.size();i++){\n            int l=queries[i][0];\n            int r=queries[i][1];\n            int val=queries[i][2];\n\n            for(int j=l;j<=r;j++){\n                if(can[j].empty()) continue;\n                auto m =can[j];\n                for(int n:m){\n                    if(n-val>0){\n                        can[j].insert(n-val);\n                    }else if(n==val){\n                        can[j].clear();\n                        break;\n                    }\n                }\n            }\n\n\n            for(int k=0;k<nums.size();k++){\n                if(!can[k].empty()) break;\n                if(k==nums.size()-1) return i+1;\n            }\n        }\n        return -1;\n    }\n};","author":"SkyLimit","submissionId":"611266038"},[]]},{"2089":[{"id":"2089","fileName":"611266315.txt","sourceCode":"class Solution {\npublic int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        \n        boolean[][] dp = new boolean[n][1001];\n        boolean falg = true;\n        \n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n            if (nums[i] != 0) {\n                falg = false;\n            }\n        }\n        if (falg) {\n            return 0;\n        }\n        for (int k = 0; k < queries.length; k++) {\n            int[] query = queries[k];\n            falg = true;\n            for (int i = 0; i < n; i++) {\n                int target = nums[i];\n                if (dp[i][target] || i < query[0] || i > query[1]) {\n                    falg &= dp[i][target];\n                    continue;\n                }\n                for (int j = target; j >= query[2]; j--) {\n                    dp[i][j] |= dp[i][j - query[2]];\n                }\n                falg &= dp[i][target];\n            }\n            if (falg) {\n                return k + 1;\n            }\n        }\n\n        return -1;\n    }\n}","author":"JIAN","submissionId":"611266315"},[]]},{"2090":[{"id":"2090","fileName":"611266170.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, m = len(nums), len(queries)\n\n        all_zero = True\n        for num in nums:\n            if num != 0:\n                all_zero = False\n                break\n\n        if all_zero:\n            return 0\n\n        def check(k: int) -> bool:\n            idx_to_vals = defaultdict(list)\n            for i in range(0, k + 1):\n                l, r, val = queries[i]\n                for j in range(l, r + 1):\n                    idx_to_vals[j].append(val)\n\n            for j in range(0, n):\n                vals = idx_to_vals[j]\n                len_vals = len(vals)\n                dp = [[False for _ in range(nums[j] + 1)] for _ in range(len_vals + 1)]\n                dp[0][0] = True\n                for a in range(1, len_vals + 1):\n                    for b in range(0, nums[j] + 1):\n                        dp[a][b] |= dp[a - 1][b]\n                        if b - vals[a - 1] >= 0:\n                            dp[a][b] |= dp[a - 1][b - vals[a - 1]]\n                \n                if not dp[len_vals][nums[j]]:\n                    return False\n\n            return True\n            \n        ans = -1\n        left, right = 0, m - 1\n        while left <= right:\n            mid = (left + right) >> 1\n            if check(mid):\n                ans = mid + 1\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return ans\n        ","author":"明子","submissionId":"611266170"},[]]},{"2091":[{"id":"2091","fileName":"611266253.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n=a.size(),m=q.size();\n        bool st=0;\n        for(int i=0;i<n;i++) if(a[i]) st=1;\n        if(!st) return 0;\n\n        \n        auto check=[&](int x)->bool{\n            // int dp[n+1][1010];\n            vector<vector<int>>dp(n+1,vector<int>(1010));\n            for(int i=0;i<n;i++) dp[i][0]=1;\n            \n            for(int i=0;i<x;i++){\n                int ll=q[i][0],rr=q[i][1],xx=q[i][2];\n                // cout<<ll<<' '<<rr<<' '<<xx<<endl;\n                for(int j=ll;j<=rr;j++){\n                    for(int k=a[j];k>=xx;k--){\n                        dp[j][k]=max(dp[j][k],dp[j][k-xx]);\n                    }\n                }\n            }\n            for(int i=0;i<n;i++){\n                // cout<<x<<' '<<dp[0][i]<<endl;\n                if(!dp[i][a[i]]) return 0;\n            }\n            return 1;\n        };\n        int l=0,r=m+1;\n        // return check(2);\n        while(l<r){\n            int mid=l+r>>1;\n            if(check(mid)) r=mid;\n            else l=mid+1;\n        }\n        // return l;\n        if(l==m+1) return -1;\n        else return l;\n    }\n};","author":"20岁有志青年","submissionId":"611266253"},[]]},{"2092":[{"id":"2092","fileName":"611266544.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int sum = 0;\n        for (int i = 0; i < n; ++i){\n            sum += nums[i];\n        }\n        if (sum == 0){\n            return 0;\n        }\n        auto check = [&](int k){\n            int g = 0;\n            for (int i = 0; i < nums.size(); ++i){\n                vector<int> dp(nums[i] + 1);\n                dp[0] = 1;\n                for (int j = 0; j < k; ++j){\n                    int l = queries[j][0];\n                    int r = queries[j][1];\n                    int v = queries[j][2];\n                    int x = i >= l && i <= r ? v : 0;\n                    for (int j = nums[i]; j >= x; --j){\n                        if (dp[j - x]){\n                            dp[j] = 1;\n                        }\n                    }\n                }\n                if (dp[nums[i]]){\n                    g |= 1<<i;\n                }\n            }\n            if (g == (1 << n) - 1){\n                return true;\n            }\n            return false;\n        };\n        int m = queries.size();\n        int lt = 0;\n        int rt = m + 1;\n        while (lt < rt - 1){\n            int mid = (lt + rt) / 2;\n            if (check(mid)){\n                rt = mid;\n            }\n            else{\n                lt = mid;\n            }\n        }\n       \n        return rt == m + 1 ? -1 : rt;\n    }\n};","author":"lart1n","submissionId":"611266544"},[]]},{"2093":[{"id":"2093","fileName":"611266483.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if sum(nums) == 0:\n            return 0\n\n        n = len(nums)\n        finish = [False] * n\n        \n        buf = [set([]) for _ in range(n)]\n            \n        ans = 1\n        for i, j, k in queries:\n            for m in range(i, j+1):\n                if finish[m]:\n                    continue\n                newset = set([])\n                newset.add(k)\n                for x in buf[m]:\n                    newset.add(x+k)\n                    newset.add(x)\n                buf[m] = newset\n                \n            f = True\n            for m in range(n):\n                if finish[m]:\n                    continue\n                if nums[m] in buf[m] or nums[m] == 0:\n                    finish[m] = True\n                else:\n                    f = False\n            if f:\n                return ans\n            ans += 1\n        return -1\n                    \n            ","author":"yyyying","submissionId":"611266483"},[]]},{"2094":[{"id":"2094","fileName":"611266538.txt","sourceCode":"class SegmentTree:\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.mp = defaultdict(set)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.mp[node].add(arr[start])\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            left_child = 2 * node + 1\n            right_child = 2 * node + 2\n            self.build_tree(arr, left_child, start, mid)\n            self.build_tree(arr, right_child, mid + 1, end)\n            self.tree[node] = self.tree[left_child] + self.tree[right_child]\n\n    def update_range(self, l, r, val):\n        self._update_range(0, 0, self.n - 1, l, r, val)\n\n    def _update_range(self, node, start, end, l, r, val):\n        if r < start or l > end:\n            return\n\n        if start == end:\n            if val in self.mp[node]:\n                self.tree[node] = 0\n                del self.mp[node]\n                return\n            for prev in self.mp[node].copy():\n                if prev > val:\n                    self.mp[node].add(prev - val)\n            return\n\n        mid = (start + end) // 2\n        left_child = 2 * node + 1\n        right_child = 2 * node + 2\n\n        self._update_range(left_child, start, mid, l, r, val)\n        self._update_range(right_child, mid + 1, end, l, r, val)\n\n        self.tree[node] = self.tree[left_child] + self.tree[right_child]\n\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        root = SegmentTree(nums)\n        if root.tree[0] <= 0:\n            return 0\n        for i, (l, r, v) in enumerate(queries):\n            root.update_range(l, r, v)\n            if root.tree[0] <= 0:\n                return i + 1\n        return -1","author":"西山对寂寥","submissionId":"611266538"},[]]},{"2095":[{"id":"2095","fileName":"611266426.txt","sourceCode":"class Solution {\n    public class Node {\n        public Set<Integer> set = new HashSet<>();\n        public Map<Integer, Integer> map = new HashMap<>();\n    }\n\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        Node[] arr = new Node[n];\n        Arrays.setAll(arr, i -> new Node());\n        for (int k = 0; k < queries.length; k++) {\n            int[] query = queries[k];\n            for (int x = query[0]; x <= query[1]; x++) {\n                Node node = arr[x];\n                int val = query[2];\n                Map<Integer, Integer> temp = new HashMap<>();\n                for (int e : node.set) {\n                    if (val + e > 1000) {\n                        continue;\n                    }\n                    if (!node.set.contains(val + e)) {\n                        temp.put(val + e, k);\n                    }\n                }\n                node.set.addAll(temp.keySet());\n                node.map.putAll(temp);\n                if (!node.set.contains(val)) {\n                    node.set.add(val);\n                    node.map.put(val, k);\n                }\n            }\n        }\n        int max = 0;\n        boolean flag=false;\n        for (int i = 0; i < n; i++) {\n            if (0 == nums[i]) {\n                continue;\n            }\n            flag=true;\n            if (!arr[i].set.contains(nums[i])) {\n                return -1;\n            }\n            max = Math.max(max, arr[i].map.get(nums[i]));\n        }\n        return flag?max + 1:0;\n\n    }\n}","author":"皇家码德里","submissionId":"611266426"},[]]},{"2096":[{"id":"2096","fileName":"611267006.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<vector<int>> dp(n, vector<int>{});\n\n        for (int i = 0; i < n; ++i) {\n            dp[i] = vector<int>(nums[i] + 1, 0);\n            dp[i][nums[i]] = 1;\n        }\n\n        int r = 0, now = 0;\n        while (true) {\n            bool ok = true;\n            for (int i = 0; i < n; ++i) {\n                if (dp[i][0] == 0) {\n                    ok = false;\n                    break;\n                }\n            }\n\n            if (ok) {\n                return now;\n            }\n\n            if (now >= queries.size())\n                return -1;\n\n            for (int d = queries[now][0]; d <= queries[now][1]; ++d) {\n                for (int p = 0; p < dp[d].size(); ++p) {\n                    if (dp[d][p] && p - queries[now][2] >= 0)\n                        dp[d][p - queries[now][2]] = 1;\n                }\n            }\n            ++now;\n        }\n\n        return -1;\n    }\n};","author":"Haocheng","submissionId":"611267006"},[]]},{"2097":[{"id":"2097","fileName":"611266746.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<vector<pair<int, int>>> cover(n);\n        for (int k = 0; k < m; ++k) {\n            int l = queries[k][0];\n            int r = queries[k][1];\n            int val = queries[k][2];\n            if (l > r)\n                continue;\n            for (int i = l; i <= r; ++i) {\n                if (i < n) {\n                    cover[i].emplace_back(k, val);\n                }\n            }\n        }\n\n        int max_k = -1;\n        for (int i = 0; i < n; ++i) {\n            int target = nums[i];\n            if (target == 0) {\n                continue;\n            }\n\n            vector<pair<int, int>>& qs = cover[i];\n            unordered_set<int> possible_sums;\n            possible_sums.insert(0);\n            bool found = false;\n            int current_max_k = -1;\n\n            for (const auto& q : qs) {\n                int k_index = q.first;\n                int val = q.second;\n\n                unordered_set<int> new_sums;\n                for (int s : possible_sums) {\n                    int new_sum = s + val;\n                    if (new_sum == target) {\n                        current_max_k = k_index;\n                        found = true;\n                        break;\n                    }\n                    new_sums.insert(new_sum);\n                }\n                if (found)\n                    break;\n\n                possible_sums.insert(new_sums.begin(), new_sums.end());\n            }\n\n            if (!found) {\n                return -1;\n            }\n\n            if (current_max_k > max_k) {\n                max_k = current_max_k;\n            }\n        }\n        return max_k + 1;\n    }\n}\n;","author":"Myluster","submissionId":"611266746"},[]]},{"2098":[{"id":"2098","fileName":"611266552.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<vector<pair<int,int>>> spot(nums.size());\n        for(int i = 0;i<queries.size();i++){\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for(int j = l;j<=r;j++){\n                spot[j].emplace_back(val,i);\n            }\n        }\n        int allready = true;\n        for(auto it:nums)\n            if(it>0){\n                allready = false;\n                break;\n            }\n        if(allready) return 0;\n        int l = 0, r = queries.size()-1;\n        auto check = [&](int k)->bool{\n            vector<unordered_set<int>> sub(nums.size());\n            //cout<<\"k is \"<<k<<endl;\n            for(int i = 0;i<nums.size();i++){\n                if(nums[i] == 0) continue;\n                int target = nums[i], j = 0;\n                bool find = false;\n                sub[i].emplace(0);\n                //cout<<target<<endl;\n                while(j<spot[i].size() && spot[i][j].second<=k){\n                    //cout<<j<<endl;\n                    int cur = spot[i][j].first;\n                    //cout<<\"cur is\"<<cur<<endl;\n                    if(cur <= target){\n                        if(sub[i].count(target - cur)){\n                            //cout<<\"find!\"<<cur<<\" \"<<target-cur<<endl;\n                            find = true;\n                            break;\n                        }\n                        else{\n                            vector<int> tmp;\n                            for(auto it:sub[i]){\n                                if(cur + it <target)\n                                    tmp.emplace_back(cur + it);\n                            }\n                            for(auto it:tmp)\n                                sub[i].emplace(it);\n                        }\n                    }\n                    j++;\n                }\n                //cout<<i<<\" \"<<j<<\" \"<<find<<endl;\n                if(find == false) return false;\n            }\n            return true;\n        };\n        while(l<=r){\n            int mid = l + (r-l)/2;\n            if(check(mid)) r = mid-1;\n            else l = mid+1;\n        }\n        return l == queries.size()?-1:l+1;\n    }\n};","author":"府艾山茶灵","submissionId":"611266552"},[]]},{"2099":[{"id":"2099","fileName":"611266617.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\nint n = nums.size();\n        int m = queries.size();\n        vector<vector<pair<int, int>>> cover(n);\n        \n        for (int j = 0; j < m; ++j) {\n            int l = queries[j][0];\n            int r = queries[j][1];\n            int val = queries[j][2];\n            if (l < n) cover[l].emplace_back(val, j);\n            if (r + 1 < n) cover[r + 1].emplace_back(-val, j);\n        }\n        vector<vector<pair<int, int>>> elementCover(n);\n        vector<int> currentQueries;\n        for (int i = 0; i < n; ++i) {\n            for (auto &p : cover[i]) {\n                if (p.first > 0) {\n                    currentQueries.push_back(p.second);\n                } else {\n                    auto it = find(currentQueries.begin(), currentQueries.end(), p.second);\n                    if (it != currentQueries.end()) currentQueries.erase(it);\n                }\n            }\n            for (int j : currentQueries) {\n                int l = queries[j][0];\n                int r_val = queries[j][2];\n                if (i >= l && i <= queries[j][1]) {\n                    elementCover[i].emplace_back(r_val, j);\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            sort(elementCover[i].begin(), elementCover[i].end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n                return a.second < b.second;\n            });\n        }        \n        int max_k = -1;\n        for (int i = 0; i < n; ++i) {\n            int target = nums[i];\n            if (target == 0) continue;\n            vector<int> dp(target + 1, -1);\n            dp[0] = -1;\n            for (auto& p : elementCover[i]) {\n                int val = p.first;\n                int j = p.second;\n                for (int s = target; s >= val; --s) {\n                    if (dp[s - val] != -1) {\n                        int current_max = max(j, dp[s - val]);\n                        if (dp[s] == -1 || current_max < dp[s]) {\n                            dp[s] = current_max;\n                        }\n                    }\n                }\n                if (val <= target && (dp[val] == -1 || j < dp[val])) {\n                    dp[val] = j;\n                }\n                if (dp[target] != -1) break;\n            }\n            if (dp[target] == -1) return -1;\n            max_k = max(max_k, dp[target]);\n        }\n        return max_k == -1 ? 0 : max_k + 1;\n    }\n};","author":"Dumbo","submissionId":"611266617"},[]]},{"2100":[{"id":"2100","fileName":"611267426.txt","sourceCode":"class Solution {\npublic:\n  int minZeroArray(vector<int> &nums, vector<vector<int>> &queries) {\n    /**\n     * 问题转换为对于nums中的每个元素，连续应用queries, -val是否能使nums减为0\n     * 每个query是否能应用于当前元素，取决于Lq, Rq是否包含当前元素索引\n     * dp[i][j]表示第i个元素，当前值为j要经过的最小操作次数\n     * for each queries:\n     *  dp[i][j] = min(dp[i][j], dp[i][j+val] + 1)\n     * 取max(dp[i][0]) 如果不存在则返回-1\n     * 初始值: INT_MAX, dp[i][nums[i]] = 0\n     */\n    int nums_max = 0;\n    const int kQueryMax = 10000;\n    vector<vector<int>> dp(nums.size(), vector<int>(1001, kQueryMax));\n    for (int i = 0; i < nums.size(); ++ i) {\n      dp[i][nums[i]] = 0;\n      nums_max = max(nums_max, nums[i]);\n    }\n    for (int k = 0; k < queries.size(); ++ k) {\n      auto& query = queries[k];\n      int left = query[0], right = query[1], val = query[2];\n      for (int i = 0; i < nums.size(); ++ i) {\n        if (left > i || right < i) continue;\n        for (int j = 0; j <= nums_max; ++ j) {\n          if (j + val <= nums_max && dp[i][j + val] < kQueryMax) {\n            dp[i][j] = min(dp[i][j], k + 1);\n          }\n        }\n      }\n    }\n    int ans = 0;\n    for (int i = 0; i < nums.size(); ++ i) {\n      ans = max(ans, dp[i][0]);\n    }\n    return ans == kQueryMax ? -1 : ans;\n  }\n};","author":"gaojingm","submissionId":"611267426"},[]]},{"2101":[{"id":"2101","fileName":"611267184.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(const vector<int>& nums,const vector<vector<int>>& queries) {\n        int n = queries.size();\n        int id = 0;\n        vector memo(n, vector(1001, -1));\n        function<int(int,int)> dfs = [&](int index,int remain)->int{\n            if (remain == 0)return index;\n            if (index == n)return INT_MAX;\n            if (memo[index][remain] != -1)return memo[index][remain];\n            int ans = INT_MAX;\n            if (id <= queries[index][1] && id >= queries[index][0]) {\n                ans = min({ ans, remain - queries[index][2] >= 0 ? dfs(index + 1, remain - queries[index][2]) : INT_MAX, dfs(index + 1, remain) });\n            }\n            else {\n                ans = min(ans, dfs(index + 1, remain));\n            }\n            return memo[index][remain]=ans;\n        };\n        int ans = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            memo = vector(n, vector(1001, -1));\n            id = i;\n            int id=dfs(0, nums[i]);\n            if (id == -1)return -1;\n            else {\n                ans = max(ans, id);\n            }\n        }\n        return ans > queries.size() ? -1 : ans;\n    }\n};","author":"原","submissionId":"611267184"},[]]},{"2102":[{"id":"2102","fileName":"611267385.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if reduce(or_, nums) == 0:\n            return 0\n        n = len(nums)\n        n_q = len(queries)\n        mx = max(nums)\n        f = [[False] * n for _ in range(mx+1)]\n        f[0] = [True] * n\n        up = 0\n        for i, (l, r, val) in enumerate(queries):\n            up = min(up+val, mx)\n            for k in range(up, val-1, -1):\n                for j in range(r, l-1, -1):\n                    if l <= j <= r:\n                        f[k][j] |= f[k-val][j]\n            if reduce(and_, (f[nums[j]][j] for j in range(n))):\n                return i+1\n        return -1\n            \n        # @cache\n        # def dfs(i, j, k):\n        #     if k < 0:\n        #         return False\n        #     if i == -1:\n        #         return True if k == 0 else False\n        #     l, r, val = queries[i]\n        #     if l <= j <= r:\n        #         return dfs(i-1, j, k-val) | dfs(i-1, j, k)\n        #     else:\n        #         return dfs(i-1, j, k)\n        # for i in range(n_q):\n        #     if reduce(and_, (dfs(i, j, nums[j]) for j in range(n))):\n        #         return i+1\n        # dfs.cache_clear()\n        # return -1\n            \n        \n            \n        ","author":"nanjolno39","submissionId":"611267385"},[]]},{"2103":[{"id":"2103","fileName":"611267593.txt","sourceCode":"func minZeroArray(nums []int, queries [][]int) int {\n\tvecMp := make([]map[int]int, len(nums))\n\tfor i := range vecMp {\n\t\tvecMp[i] = map[int]int{}\n\t\tvecMp[i][nums[i]]++\n\t}\n\tcnt:=0\n\tfor _,v:=range nums{\n\t\tcnt+=v\n\t}\n\tif cnt==0{\n\t\treturn 0\n\t}\n\tfor j, q := range queries {\n\t\tfor i := q[0]; i <= q[1]; i++ {\n\n\t\t\tif _, ok := vecMp[i][q[2]]; ok {\n\t\t\t\tnums[i] = 0\n\t\t\t}\n\t\t\tnewVec := []int{}\n\t\t\tfor k, _ := range vecMp[i] {\n\t\t\t\tif k-q[2] > 0 {\n\t\t\t\t\tnewVec = append(newVec, k-q[2])\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor _, v := range newVec {\n\t\t\t\tvecMp[i][v]++\n\t\t\t}\n\t\t}\n\t\tflag := true\n\t\tfor _, v := range nums {\n\t\t\tif v != 0 {\n\t\t\t\tflag = false\n\t\t\t}\n\t\t}\n\t\tif flag {\n\t\t\treturn j + 1\n\t\t}\n\t}\n\treturn -1\n}","author":"北歌","submissionId":"611267593"},[]]},{"2104":[{"id":"2104","fileName":"611267023.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), sum = 0;\n        for (int i = 0; i < n; ++i) {\n            sum += nums[i];\n        }\n        if (sum == 0) return 0;\n        vector<unordered_set<int>> subVals(n);\n        int m = queries.size();\n        for (int i = 0; i < m; ++i) {\n            int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n            for (int j = l; j <= r; ++j) {\n                if (nums[j] == 0) continue;\n                if (nums[j] == v) {\n                    sum -= nums[j];\n                    nums[j] = 0;\n                } else if (nums[j] > v) {\n                    int target = nums[j] - v;\n                    if (subVals[j].count(target)) {\n                        sum -= nums[j];\n                        nums[j] = 0;\n                        subVals[j].clear();\n                    } else {\n                        unordered_set<int> newSums;\n                        newSums.insert(v);\n                        for (int s : subVals[j]) {\n                            int newSum = s + v;\n                            if (newSum <= nums[j]) {\n                                newSums.insert(newSum);\n                            }\n                        }\n                        for (int s : newSums) {\n                            subVals[j].insert(s);\n                        }\n                    }\n                }\n            }\n            if (sum == 0) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"物联黄同学","submissionId":"611267023"},[]]},{"2105":[{"id":"2105","fileName":"611267718.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(), m=queries.size();\n        vector<vector<int>> values(n, vector<int>(m, 0));\n        for(int i=0; i<m; i++){\n            int l=queries[i][0], r=queries[i][1], v=queries[i][2];\n            for(int j=l; j<=r; j++){\n                values[j][i]=v;\n            }\n        }\n        vector finished(n, m+1);\n        for(int i=0; i<n; i++){\n            vector<int> value=values[i];\n            int target=nums[i];\n            if(target==0){\n                finished[i]=0;\n                continue;\n            }\n            vector<bool> f(target+1, false);\n            f[0]=true;\n            for(int j=0; j<m; j++){\n                for(int k=target; k>=value[j]; k--){\n                    f[k]=f[k]||f[k-value[j]];\n                }\n                if(f[target]){\n                    finished[i]=j+1;\n                    break;\n                }\n            }\n        }\n        if(ranges::max(finished)==m+1){\n            return -1;\n        }\n        else{\n            return ranges::max(finished);\n        }\n    }\n};","author":"Afash","submissionId":"611267718"},[]]},{"2106":[{"id":"2106","fileName":"611267740.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        // 预处理\n        vector<vector<int>> subVal(n);\n        for (int i = 0; i < n; ++ i){\n            for (int j = 0; j < m; ++ j){\n                int l = queries[j][0], r = queries[j][1], v = queries[j][2];\n                if (i < l || i > r){\n                    subVal[i].emplace_back(0);\n                } else {\n                    subVal[i].emplace_back(v);\n                }\n            }\n        }        \n        int res = -1;\n        // 0-1 背包问题，取最小\n        for (int i = 0; i < n; ++ i){\n            // 寻找每个数的最短和\n            vector memo(m, vector<int>(1001, -1));\n            auto dfs = [&](this auto&&dfs, int p, int remain) -> int{\n                // 边界情况\n                // 找到\n                if (remain == 0){\n                    return 0;\n                }\n                // 非法\n                if (p == m){\n                    return INT_MAX - 1001;\n                }\n                int &ans = memo[p][remain];\n                if (ans != -1){\n                    return ans;\n                }\n                // 不选\n                ans = INT_MAX / 2;\n                ans = dfs(p + 1, remain) + 1;\n                // 选\n                if (remain >= subVal[i][p]){\n                    ans = min(ans, dfs(p + 1, remain - subVal[i][p]) + 1);\n                }\n                return ans;\n            };\n            res = max(res, dfs(0, nums[i]));\n        }\n        return res >= INT_MAX / 2 ? -1 : res;\n    }\n};","author":"淂帥","submissionId":"611267740"},[]]},{"2107":[{"id":"2107","fileName":"611267910.txt","sourceCode":"\nclass Solution {\npublic:\n    int gai[1003];\n    int index[1002];\n    int size=0;\n    bool dp[1003];\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(),m=queries.size();\n        int ans=0;\n        for(int i=0;i<n;++i){\n            size=0;\n            for(int j=0;j<m;++j){\n                if(queries[j][0]<=i&&queries[j][1]>=i){\n                    gai[size]=queries[j][2];\n                    index[size++]=j;\n                }\n            }\n            fill(dp,dp+nums[i]+1,false);\n            dp[0]=true;\n            int cap=nums[i];\n            bool flag=false;\n            if(cap==0){\n               // cout<<cap<<\" \"<<0<<endl;\n                continue;\n            }\n            // if(i==1){\n            //     cout<<cap<<\",gai=\";\n            //     for(int i=0;i<size;++i){\n            //         cout<<gai[i]<<\" \";\n            //     }\n            //     cout<<\"index=\";\n            //     for(int i=0;i<size;++i){\n            //         cout<<index[i]<<\" \";\n            //     }\n            //     cout<<'n';\n            // }\n            for(int i=1;i<=size;++i){\n               \n                for(int j=cap;j>=gai[i-1];--j){\n                     dp[j]=dp[j]||dp[j-gai[i-1]];\n                  //  cout<<\"i=\"<<i<<\",j=\"<<j<<\",dp=\"<<dp[j];\n                }\n                //cout<<endl;\n                if(dp[cap]){\n                    ans=max(ans,index[i-1]+1);\n                  //  cout<<cap<<\" \"<<index[i-1]+1<<endl;\n                    flag=true;;\n                   break;\n                }\n            } \n            if(flag){\n            \tcontinue;\n\t\t\t}\n            return -1;\n        }\n        return ans;\n    }\n};","author":"无敌java大王","submissionId":"611267910"},[]]},{"2108":[{"id":"2108","fileName":"611267438.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int qn = queries.size();\n        auto check = [&](int k) -> bool {\n            vector<vector<int>> dp(n);\n            for (int i = 0; i < n; ++i)\n                dp[i] = vector<int>(nums[i] + 1, 0);\n            for (int i = 0; i < k; ++i) {\n                int l = queries[i][0];\n                int r = queries[i][1];\n                int v = queries[i][2];\n                for (int j = l; j <= r; ++j)\n                    for (int k = dp[j].size() - 1; k >= 0; --k)\n                        if (k >= v)\n                            dp[j][k] = max(dp[j][k], dp[j][k - v] + v);\n            }\n            for (int i = 0; i < dp.size(); ++i) {\n                int s = dp[i].size();\n                if (dp[i][s - 1] != s - 1)\n                    return false;\n            }\n            return true;\n        };\n        int l = 0, r = qn, mid;\n        while (l <= r) {\n            mid = (l + r) / 2;\n            check(mid)? (r = mid - 1): (l = mid + 1);\n        }\n        return (l > qn)? -1: l;\n    }\n};","author":"KaguraChen","submissionId":"611267438"},[]]},{"2109":[{"id":"2109","fileName":"611267963.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(),m=queries.size();\n        int sy=0;\n        for(int i:nums){\n            if(i!=0) sy++;\n        }\n        if(sy==0) return 0;\n        vector<set<int> > qianzhui(n+1);\n        for(int i=0;i<=n;i++) qianzhui[i].insert(0);\n        for(int i=0;i<m;i++){\n            int a=queries[i][0],b=queries[i][1],c=queries[i][2];\n            for(int j=a;j<=b;j++){\n                if(nums[j]==0) continue;\n                vector<int> mid_;\n                for(int k:qianzhui[j]){\n                    if(k+c==nums[j]){\n                        nums[j]=0;\n                        sy--;\n                        if(sy==0) return i+1;\n                    }else if(k+c<nums[j]){\n                        mid_.push_back(k+c);\n                    }\n                }\n                for(int k:mid_){\n                    qianzhui[j].insert(k);\n                }\n            }\n        }\n        return -1;\n    }\n};","author":"捕鼠王汤姆","submissionId":"611267963"},[]]},{"2110":[{"id":"2110","fileName":"611268093.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        return minK(nums.length, nums, queries);\n    }\n    public int minK(int n, int[] nums, int[][] queries) {\n        int m = queries.length;\n        List<List<int[]>> cover = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            cover.add(new ArrayList<>());\n        }\n        for (int qIdx = 0; qIdx < m; qIdx++) {\n            int l = queries[qIdx][0];\n            int r = queries[qIdx][1];\n            int val = queries[qIdx][2];\n            l = Math.max(0, l);\n            r = Math.min(n - 1, r);\n            for (int i = l; i <= r; i++) {\n                cover.get(i).add(new int[]{qIdx, val});\n            }\n        }\n\n        int maxK = -1;\n        for (int i = 0; i < n; i++) {\n            int target = nums[i];\n            List<int[]> qList = cover.get(i);\n            qList.sort((a, b) -> Integer.compare(a[0], b[0]));\n\n            if (target == 0) {\n                continue;\n            }\n\n            if (qList.isEmpty()) {\n                return -1;\n            }\n\n            Map<Integer, Integer> dp = new HashMap<>();\n            dp.put(0, -1);\n\n            for (int[] query : qList) {\n                int idx = query[0];\n                int val = query[1];\n                Map<Integer, Integer> newDp = new HashMap<>();\n\n                for (Map.Entry<Integer, Integer> entry : dp.entrySet()) {\n                    int s = entry.getKey();\n                    int currentMax = entry.getValue();\n\n                    if (!newDp.containsKey(s) || currentMax < newDp.get(s)) {\n                        newDp.put(s, currentMax);\n                    }\n\n                    int newS = s + val;\n                    int newMax = Math.max(currentMax, idx);\n                    if (!newDp.containsKey(newS) || newMax < newDp.get(newS)) {\n                        newDp.put(newS, newMax);\n                    }\n                }\n                for (Map.Entry<Integer, Integer> entry : newDp.entrySet()) {\n                    int s = entry.getKey();\n                    int newMaxVal = entry.getValue();\n                    if (!dp.containsKey(s) || newMaxVal < dp.get(s)) {\n                        dp.put(s, newMaxVal);\n                    }\n                }\n            }\n\n            if (!dp.containsKey(target)) {\n                return -1;\n            }\n\n            int currentK = dp.get(target) + 1;\n            if (currentK > maxK) {\n                maxK = currentK;\n            }\n        }\n\n        return maxK != -1 ? maxK : 0;\n    }\n}","author":"嘉然今天刷力扣","submissionId":"611268093"},[]]},{"2111":[{"id":"2111","fileName":"611267982.txt","sourceCode":"class Solution {\n\n    public int minZeroArray(int[] nums, int[][] queries) {\n        List<Integer>[] lists = new List[nums.length];\n        for(int i = 0;i < nums.length;i++){\n            lists[i] = new ArrayList<>();\n        }\n        if(isZeroArray(nums)){\n            return 0;\n        }\n        for(int i = 0;i < queries.length;i++){\n            int[] query = queries[i];\n            int l = query[0];\n            int r = query[1];\n            for(int j = l;j <= r;j++){\n                lists[j].add(query[2]);\n            }\n            if(check(nums,lists)){\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n\n    public boolean isZeroArray(int[] nums){\n        for(int num:nums){\n            if(num != 0){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean check(int[] nums,List<Integer>[] lists){\n        for(int i = 0;i < nums.length;i++){\n            List<Integer> l = lists[i];\n            if(!canSum(l,nums[i])){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean canSum(List<Integer> list,int target)\n    {\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n        for(int x : list)\n        {\n            for(int i = target;i >= x;i--){\n                dp[i] = dp[i] || dp[i-x];\n            }\n        }\n        return dp[target];\n    }\n}","author":"香菜是魔鬼","submissionId":"611267982"},[]]},{"2112":[{"id":"2112","fileName":"611268190.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        int mx = *max_element(nums.begin(), nums.end());\n        if(mx == 0) return 0;\n        \n        auto check = [&](int val){\n            vector<vector<int>> all(n, vector<int>(11));\n            //if could not to all 0, return false;\n            for(int i=0;i<val;i++){\n                int s = queries[i][0];\n                int e = queries[i][1];\n                int v = queries[i][2];\n                for(int t=s;t<=e;t++){\n                    all[t][v]++;\n                }\n            }\n\n            for(int i=0;i<n;i++){\n                if(nums[i] == 0) continue;\n                int target = nums[i];\n                vector<vector<bool>> f(11, vector<bool>(target+1));\n                f[0][0] = true;\n                \n                for(int v=1;v<11;v++){\n                    for(int t=target;t>=0;t--){\n                        for(int c=all[i][v];c>=0;c--){\n                            if(v*c<=t) f[v][t] = f[v][t] | f[v-1][t-v*c];\n                        }\n                    }\n                }\n                if(!f[10][target]) return false;\n            }\n            return true;\n        };\n    \n        \n        int l = 0, r = m;\n        while(l < r){\n            int c = l + (r - l + 1) / 2;\n            if(!check(c)) l = c; \n            else r = c - 1;\n        }\n        return r == m ? -1 : r + 1;\n    }\n};","author":"红桃A士","submissionId":"611268190"},[]]},{"2113":[{"id":"2113","fileName":"611268316.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& que) {\n        int n = a.size(), m = que.size();\n\n        vector<int> vec[n];\n        for ( int i = 0; i < m; i++ ){\n            auto& q = que[i];\n            int l = q[0], r = q[1], val = q[2];\n            for ( int j = 0; j < n; j++ ){\n                if ( j >= l && j <= r ) vec[j].push_back(val);\n                else vec[j].push_back(0);\n            }\n        }\n\n        int ans = 0;\n        for ( int i = 0; i < n; i++ ){\n            if ( a[i] == 0 ) continue;\n            vector<int> f(a[i] + 1, 0);\n            f[0] = 1;\n            for ( int j = 0; j < m; j++ ){\n                int val = vec[i][j];\n                for ( int k = a[i]; k >= val; k-- ){\n                    f[k] |= f[k - val];\n                }\n                if ( f[a[i]] ){\n                    ans = max(ans, j + 1);\n                    break;\n                }\n            }\n            if ( !f[a[i]] ) return -1;\n        }\n\n        return ans;\n    }\n};","author":"TeddyDUDU","submissionId":"611268316"},[]]},{"2114":[{"id":"2114","fileName":"611268670.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> idx;\n        vector<unordered_set<int>> val(n);\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != 0) {\n                val[i].insert(nums[i]);\n                idx.push_back(i);\n            }\n        }\n        if (idx.empty()) {\n            return 0;\n        }\n\n        for (int k = 0; k < queries.size(); k++) {\n            auto &q = queries[k];\n            for (auto it = idx.begin(); it != idx.end();) {\n                int i = *it;\n                if (q[0] <= i && i <= q[1]) {\n                    vector<int> newN;\n                    bool zero = false;\n                    for (int num : val[i]) {\n                        if (num == q[2]) {\n                            zero = true;\n                            break;\n                        }\n                        if (num >= q[2] && val[i].find(num - q[2]) == val[i].end()) {\n                            newN.push_back(num - q[2]);\n                        }\n                    }\n\n                    if (zero) {\n                        it = idx.erase(it);\n                    } else {\n                        for (int num : newN) {\n                            val[i].insert(num);\n                        }\n                        it++;\n                    }\n                } else {\n                    it++;\n                }\n            }\n\n            if (idx.empty()) {\n                return k + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"许秀","submissionId":"611268670"},[]]},{"2115":[{"id":"2115","fileName":"611268280.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        ans = -1\n            # self.index\n        for i, p in enumerate(nums):\n            if p == 0:\n                continue\n            self.ii = []\n            self.ip = []\n            # self.index = 0\n            for ii in range(len(queries)):\n                if queries[ii][0] <= i <= queries[ii][1]:\n                    self.ii.append(ii)\n                    self.ip.append(queries[ii][2])\n            # print(self.ii,self.ip,i,p)\n            if not self.ii:\n                return -1\n            else:\n                dp = [False]*(p+1)\n                dp[0] = True\n                for i, p in enumerate(self.ip):\n                    # print(dp)\n                    for q in range(len(dp)-1,-1,-1):\n                        if q-p >= 0:\n                            dp[q] = dp[q] | dp[q-p]\n                    if dp[-1] == True:\n                        ans = max(ans,self.ii[i])\n                        break\n                else:\n                    return -1\n        return ans+1\n                \n                \n                    \n            ","author":"Clared","submissionId":"611268280"},[]]},{"2116":[{"id":"2116","fileName":"611268498.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        unordered_map<int, vector<int>>mp;\n        for(int i = 0; i < nums.size(); i++){\n            mp[i] = vector<int>(1005, 0);\n            mp[i][0] = 1;\n        }\n        \n        bool ok = true;\n        for(int j = 0; j < nums.size();  j++){\n            if(mp[j][nums[j]] != 1){\n                ok = false;\n                break;\n            }\n        }\n        if(ok) return 0;\n        for(int i = 0; i < queries.size(); i++){\n            int left = queries[i][0], right = queries[i][1], val = queries[i][2];\n            for(int j = left; j <= right; j++){\n                int target = nums[j];\n                for(int k = target; k >= val; k--){\n                    if(mp[j][k - val] == 1){\n                        mp[j][k] = 1;\n                    }\n                }\n            }\n            bool ok = true;\n            for(int j = 0; j < nums.size();  j++){\n                if(mp[j][nums[j]] != 1){\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok) return i + 1;\n        }\n        return -1;\n    }\n};","author":"BUG_MAKER","submissionId":"611268498"},[]]},{"2117":[{"id":"2117","fileName":"611268501.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        @cache\n        def dfs(i, tar, temp):\n            if tar == 0:\n                return i-1\n            if i==len(temp):\n                return inf\n            if tar < 0:\n                return inf\n            return min(dfs(i+1,tar-temp[i][0], temp), dfs(i+1,tar, temp))\n\n        \n        n = len(nums)\n\n        de = defaultdict(list)\n        for index,(i,j,v) in enumerate(queries):\n            for w in range(i,j+1):\n                de[w].append((v,index))\n        ans = -1\n        for i in range(n):\n            res = dfs(0,nums[i],tuple(de[i]))\n            if res == -1:\n                continue\n            else:\n                if res != inf:\n                    ans = max(ans,de[i][res][1])\n                else:\n                    return -1\n        return ans+1\n            \n            \n            \n        ","author":"flower","submissionId":"611268501"},[]]},{"2118":[{"id":"2118","fileName":"611268850.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(),m=queries.size();\n        vector<vector<int>>dp(n,vector<int>(1001));\n        auto check=[&]()->bool{\n              for(int i=0;i<n;i++){\n                  if(!dp[i][0])return false;\n              }  \n            return true;\n        };\n        for(int i=0;i<n;i++){\n            dp[i][nums[i]]=1;\n        }\n        if(check())return 0;\n        for(int i=0;i<m;i++){\n            int l=queries[i][0],r=queries[i][1],val=queries[i][2];\n            auto tp=dp;\n            for(int j=l;j<=r;j++){\n                for(int p=nums[j];p-val>=0;p--){\n                    dp[j][p-val]|=tp[j][p];\n                }\n            }\n            if(check()){\n                return i+1;\n            }\n        }\n        return -1;\n    }\n};","author":"烯落","submissionId":"611268850"},[]]},{"2119":[{"id":"2119","fileName":"611268522.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        \n        def func(k: int) -> bool:\n            mat = [[] for _ in range(n)]\n            for i in range(k):\n                l, r, v = queries[i]\n                for j in range(l, r + 1):\n                    if v <= nums[j]:\n                        mat[j].append(v)\n\n            @cache\n            def dfs(idx: int, x: int) -> bool:\n                if idx == lth or arr[idx] > x:\n                    return False\n                if arr[idx] == x:\n                    return True\n                \n                return dfs(idx + 1, x - arr[idx]) or dfs(idx + 1, x)\n\n            for i, arr in enumerate(mat):\n                arr.sort()\n                lth = len(arr)\n                \n                if nums[i] > 0 and not dfs(0, nums[i]):\n                    return False\n                \n                dfs.cache_clear()\n            \n            return True\n        \n        m = len(queries)\n        ans = bisect_left(range(m + 1), True, key=func)\n        \n        return -1 if ans == m + 1 else ans\n","author":"...","submissionId":"611268522"},[]]},{"2120":[{"id":"2120","fileName":"611268868.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<vector<std::pair<int,int>>> a(nums.size());\n        for(int i=0;i<queries.size();i++){\n            for(int j=queries[i][0];j<=queries[i][1];j++){\n                a[j].push_back({queries[i][2],i+1});\n            }\n        }\n        vector<int> res(nums.size(),-1);\n        for(int i=0;i<nums.size();i++){\n            set<int> q;\n            q.insert(nums[i]);\n            if(nums[i]==0){\n                res[i]=0;\n                continue;\n            }\n            for(int j=0;j<a[i].size();j++){\n                for(auto t:q){\n                    if(t>=a[i][j].first){\n                        q.insert(t-a[i][j].first);\n                        if(t-a[i][j].first==0){\n                            res[i]=a[i][j].second;\n                            break;\n                        }\n                    }\n                }\n                if(res[i]!=-1){\n                    break;\n                }\n            }\n        }\n        int ans=0;\n        for(int i=0;i<res.size();i++){\n            std::cout<<res[i]<<' ';\n            ans=std::max(ans,res[i]);\n            if(res[i]==-1){\n                return -1;\n            }\n        }\n        return ans;\n    }\n};","author":"lemonade","submissionId":"611268868"},[]]},{"2121":[{"id":"2121","fileName":"611268839.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        auto check = [&](int x){\n            int n = nums.size();\n            vector<vector<int> > cf(n),del(n+1);\n            for(int i = 0;i<=x;i++){\n                int l = queries[i][0],r = queries[i][1],val = queries[i][2];\n                cf[l].push_back(val),del[r+1].push_back(val);\n            }\n            multiset<int> s;\n            for(int i = 0;i<n;i++){\n                if(del[i].size()){\n                    for(auto u : del[i]){\n                        auto res = s.find(u);\n                        if(res!=s.end())s.erase(res);\n                    }\n                }\n                if(cf[i].size()){\n                    for(auto u : cf[i]){\n                        s.insert(u);\n                    }\n                }\n                vector<bool> st(nums[i]+1,false);\n                st[0] = true;\n                for(auto & u : s){\n                    for(int j = nums[i];j>=u;j--){\n                        st[j] = st[j]|| st[j-u];\n                    }\n                }\n                if(!st[nums[i]]){\n                    return false;\n                }\n            }\n            return true;\n        };\n        int n = queries.size()-1;\n        int l = 0,r = n+1;\n        bool flag = true;\n        for(int i = 0;i<nums.size();i++){\n            if(nums[i] != 0)flag = false;\n        }\n        if(flag)return 0;\n        \n        while(l<r){\n            int mid = (l+r)/2;\n            if(check(mid))r = mid;\n            else l = mid+1;\n        }\n        if(l == n+1)return -1;\n        return l+1;\n    }\n};","author":"loliconsk","submissionId":"611268839"},[]]},{"2122":[{"id":"2122","fileName":"611269018.txt","sourceCode":"class Solution {\npublic:\n    vector<int> vis;\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(),m = queries.size();\n        vector<vector<pair<int, int>>> grid(n);\n        for (int j = 0; j < m; ++j) \n        {\n            int l = queries[j][0];\n            int r = queries[j][1];\n            int val = queries[j][2];\n            for (int i = l; i <= r; ++i) grid[i].push_back({val, j});\n        }\n        for (int i = 0; i < n; ++i) \n        {\n            int target = nums[i];\n            /*if(target==0)\n            {\n            }*/\n            \n            if (target < 0) return -1;\n            else if (target > 0) \n            {\n                //meset(dp.size(),INT_MAX);\n                vector<int> dp(target + 1, INT_MAX);\n                dp[0] = -1;\n                for (const auto& p : grid[i]) \n                {\n                    int val = p.first;\n                    int idx = p.second;\n                    vector<int> tmp = dp; \n                    for (int s = 0; s <= target; ++s) \n                    {\n                    if (tmp[s] == INT_MAX) continue;\n                    int S = s + val;\n                    if (S > target) continue;\n                    int new_max = max(tmp[s], idx);\n                    if (new_max < dp[S]) dp[S] = new_max;\n                }\n            }\n\n            if (dp[target] == INT_MAX) return -1;\n            vis.push_back(dp[target]);\n            }  \n        }\n        bool flag = true;\n        for (int num : nums) \n        {\n            if (num != 0) \n            {\n                flag= false;\n                break;\n            }\n        }\n        if (flag||vis.empty())  return 0;\n        int res = *max_element(vis.begin(), vis.end());\n        return res + 1;\n    }\n};","author":"Z🐔H","submissionId":"611269018"},[]]},{"2123":[{"id":"2123","fileName":"611268957.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int qNum = queries.size();\n        int minK = -1;\n        int n = nums.size();\n        vector<bool> allTure(n,false);\n        for(int i = 0;i<n;i++){\n            bool dp[nums[i]+1][qNum+1];\n            for(int j = 0;j<=qNum;j++){\n                dp[0][j]=true;\n            }\n            for(int j = 1;j<=nums[i];j++){\n                dp[j][0]=false;\n            }\n            for(int j = 1;j<=nums[i];j++){\n                for(int k = 1;k<=qNum;k++){\n                    if(queries[k-1][0]<=i&&queries[k-1][1]>=i&&j-queries[k-1][2]>=0)\n                        dp[j][k]=dp[j-queries[k-1][2]][k-1]||dp[j][k-1];\n                    else\n                        dp[j][k]=dp[j][k-1];\n                }\n            }\n            for(int j = 0;j<=qNum;j++){\n                if(dp[nums[i]][j]){\n                    allTure[i]=true;\n                    minK = max(minK,j);\n                    break;\n                }\n            }\n        }\n        for(int i = 0;i<n;i++){\n            if(!allTure[i]){\n                return -1;\n            }\n        }\n        return minK;\n    }\n};","author":"zsc","submissionId":"611268957"},[]]},{"2124":[{"id":"2124","fileName":"611269009.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n    int q = queries.size();\n\n    // 预处理每个元素j的Qj列表，按索引升序排列\n    vector<tuple<int, string, int>> events;\n    for (int i = 0; i < q; ++i) {\n        int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n        events.emplace_back(l, \"add\", i);\n        events.emplace_back(r + 1, \"remove\", i);\n    }\n\n    // 排序事件：先按位置，然后处理顺序：先remove后add\n    sort(events.begin(), events.end(), [](const auto& a, const auto& b) {\n        if (get<0>(a) == get<0>(b)) {\n            return get<1>(a) == \"remove\" && get<1>(b) == \"add\";\n        }\n        return get<0>(a) < get<0>(b);\n    });\n\n    set<int> current_queries;\n    int event_ptr = 0;\n    vector<vector<pair<int, int>>> Qj(n);\n\n    for (int j = 0; j < n; ++j) {\n        // 处理所有事件中的position <= j\n        while (event_ptr < events.size() && get<0>(events[event_ptr]) <= j) {\n            int pos = get<0>(events[event_ptr]);\n            string typ = get<1>(events[event_ptr]);\n            int i = get<2>(events[event_ptr]);\n\n            if (typ == \"add\") {\n                current_queries.insert(i);\n            } else {\n                if (current_queries.find(i) != current_queries.end()) {\n                    current_queries.erase(i);\n                }\n            }\n            ++event_ptr;\n        }\n\n        // 收集当前活动的查询，并按索引排序\n        for (int idx : current_queries) {\n            int l = queries[idx][0], r = queries[idx][1], val = queries[idx][2];\n            if (l <= j && j <= r) {\n                Qj[j].emplace_back(idx, val);\n            }\n        }\n    }\n\n    int max_mj = -1;\n    for (int j = 0; j < n; ++j) {\n        int target = nums[j];\n        if (target == 0) {\n            continue;\n        }\n\n        vector<pair<int, int>>& queries_j = Qj[j];\n        if (queries_j.empty()) {\n            return -1;\n        }\n\n        unordered_map<int, int> dp;\n        dp[0] = -1;\n        int min_max_idx = INT_MAX;\n\n        for (auto& [i, val] : queries_j) {\n            unordered_map<int, int> tmp;\n            for (auto& [s, current_max] : dp) {\n                int new_s = s + val;\n                int new_max = max(current_max, i);\n\n                if (new_s == target) {\n                    if (new_max < min_max_idx) {\n                        min_max_idx = new_max;\n                    }\n                }\n\n                if (tmp.find(new_s) == tmp.end() || new_max < tmp[new_s]) {\n                    tmp[new_s] = new_max;\n                }\n            }\n\n            // 合并tmp到dp中\n            for (auto& [s, new_max] : tmp) {\n                if (dp.find(s) == dp.end() || new_max < dp[s]) {\n                    dp[s] = new_max;\n                }\n            }\n\n            if (min_max_idx != INT_MAX) {\n                break; // 提前终止\n            }\n        }\n\n        if (min_max_idx == INT_MAX) {\n            return -1;\n        }\n\n        if (min_max_idx > max_mj) {\n            max_mj = min_max_idx;\n        }\n    }\n\n    if (max_mj == -1) {\n        return 0;\n    } else {\n        return max_mj + 1;\n    }\n        \n    }\n\n\n};","author":"xiuxiu","submissionId":"611269009"},[]]},{"2125":[{"id":"2125","fileName":"611269097.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        \n        # 预处理每个元素被包含的查询列表，按总顺序排列\n        element_queries = [[] for _ in range(n)]\n        for query_idx in range(m):\n            l, r, val = queries[query_idx]\n            for i in range(l, r + 1):\n                if i >= 0 and i < n:\n                    element_queries[i].append((query_idx, val))\n        \n        k_list = []\n        for i in range(n):\n            num = nums[i]\n            if num == 0:\n                k_list.append(0)\n                continue\n            \n            q_list = element_queries[i]\n            target = num\n            dp = {0: -1}  # sum: max_index\n            found = False\n            current_min_k = None\n            \n            for (query_idx, val) in q_list:\n                new_dp = {}\n                # 处理不选当前查询的情况\n                for s in dp:\n                    existing_max = dp[s]\n                    if s not in new_dp or existing_max < new_dp[s]:\n                        new_dp[s] = existing_max\n                # 处理选当前查询的情况\n                for s in list(dp.keys()):\n                    s_new = s + val\n                    new_max = max(dp[s], query_idx)\n                    if s_new in new_dp:\n                        if new_max < new_dp[s_new]:\n                            new_dp[s_new] = new_max\n                    else:\n                        new_dp[s_new] = new_max\n                dp = new_dp\n                # 检查是否找到了目标sum\n                if target in dp:\n                    current_max = dp[target]\n                    current_min_k = current_max + 1\n                    found = True\n                    break  # 后面的查询索引更大，无法得到更小的k_i，提前退出\n            \n            if found:\n                k_list.append(current_min_k)\n            else:\n                return -1\n        \n        if not k_list:\n            return 0  # 所有元素都为0的情况\n        return max(k_list)\n            ","author":"ywk","submissionId":"611269097"},[]]},{"2126":[{"id":"2126","fileName":"611269221.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        l = len(nums)\n        mask = [1] * l\n        done = [num == 0 for num in nums]\n        target = l - sum(done)\n        k = 0\n        if target == 0:\n            return 0\n        for l, r, v in queries:\n            k += 1\n            for i in range(l, r + 1):\n                if done[i]:\n                    continue\n                mask[i] |= mask[i] << v\n                if (mask[i] >> nums[i]) & 1:\n                    done[i] = True\n                    target -= 1\n                    if target == 0:\n                        return k\n        return -1","author":"","submissionId":"611269221"},[]]},{"2127":[{"id":"2127","fileName":"611269173.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        events = []\n        for idx, (l, r, val) in enumerate(queries):\n            events.append((l, 'add', idx, val))\n            events.append((r + 1, 'remove', idx, val))\n        \n        events.sort(key=lambda x: (x[0], 0 if x[1] == 'remove' else 1))\n        \n        current_queries = []\n        element_queries = [[] for _ in range(n)]\n        event_ptr = 0\n        \n        for i in range(n):\n            while event_ptr < len(events) and events[event_ptr][0] == i:\n                typ = events[event_ptr][1]\n                q_idx = events[event_ptr][2]\n                val = events[event_ptr][3]\n                if typ == 'add':\n                    insert_pos = bisect.bisect_left(current_queries, (q_idx, val))\n                    current_queries.insert(insert_pos, (q_idx, val))\n                else:\n                    pos = bisect.bisect_left(current_queries, (q_idx, val))\n                    if pos < len(current_queries) and current_queries[pos] == (q_idx, val):\n                        current_queries.pop(pos)\n                event_ptr += 1\n            element_queries[i] = [ (idx, val) for (idx, val) in current_queries ]\n        \n        max_k = -1\n        for i in range(n):\n            target = nums[i]\n            if target == 0:\n                continue\n            \n            q_list = element_queries[i]\n            if not q_list:\n                return -1\n            \n            dp = {0: -1}\n            for (idx, val) in q_list:\n                new_dp = {}\n                for s in dp:\n                    current_max = dp[s]\n                    # 不选\n                    if s not in new_dp or current_max < new_dp[s]:\n                        new_dp[s] = current_max\n                    # 选\n                    s_new = s + val\n                    new_max = max(current_max, idx)\n                    if s_new not in new_dp or new_max < new_dp.get(s_new, float('inf')):\n                        new_dp[s_new] = new_max\n                for s in new_dp:\n                    if s not in dp or new_dp[s] < dp.get(s, float('inf')):\n                        dp[s] = new_dp[s]\n            \n            if target not in dp:\n                return -1\n            max_k = max(max_k, dp[target])\n        \n        if max_k == -1:\n            return 0 if all(x == 0 for x in nums) else -1\n        else:\n            return max_k + 1","author":"白夜暗星","submissionId":"611269173"},[]]},{"2128":[{"id":"2128","fileName":"611269583.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n\n        int add = 0;\n        for (int i = 0; i < n; i++) {\n            add += nums[i];\n        }\n        if (add == 0) return 0;\n        \n        unordered_map<int, vector<pair<int, int>>> mp;\n        for (int i = 0; i < queries.size(); i++) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                mp[j].emplace_back(i + 1, val);\n            }\n        }\n\n        int ans = -1;\n        for (int i = 0; i < n; i++) {\n            vector<pair<int, int>>& cur = mp[i];\n            int x = nums[i], m = cur.size();\n            if (x == 0) continue;\n\n            vector<vector<int>> memo(x + 1, vector<int>(m, -1));\n            auto dfs = [&](this auto&& dfs, int num, int k) -> int {\n                if (num == 0) return k - 1;\n                if (num < 0 || k == m) return INT_MAX / 2;\n                int& res = memo[num][k]; \n                if (res != -1) return res;\n                // 操作\n                res = dfs(num - cur[k].second, k + 1);\n\n                // 不操作\n                res = min(res, dfs(num, k + 1));\n                return res;\n            };\n            int a = dfs(x, 0);\n            if (a == INT_MAX / 2) return -1;\n            ans = max(cur[a].first, ans);\n        }\n        return ans;\n    }\n};","author":"一两截","submissionId":"611269583"},[]]},{"2129":[{"id":"2129","fileName":"611269361.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        pre = [[] for _ in range(n)]\n        for i, [l, r, v] in enumerate(queries):\n            for j in range(l, r + 1):\n                pre[j].append([v, i+1])\n\n        def cal(goal, array):\n            if goal == 0:\n                return 0\n            s = set()\n            s.add(goal)\n            for j, l in array:\n                for k in s.copy():\n                    if k < j:\n                        continue\n                    elif k > j:\n                        s.add(k - j)\n                    else:\n                        return l\n            return -1\n\n        res = -2\n        for i in range(n):\n            t = cal(nums[i], pre[i])\n            res = max(res, cal(nums[i], pre[i])) if t >= 0 else -1\n            if res == -1:\n                return res\n        return res","author":"刘鑫","submissionId":"611269361"},[]]},{"2130":[{"id":"2130","fileName":"611269790.txt","sourceCode":"    class Solution {\n        public int minZeroArray(int[] nums, int[][] queries) {\n            // 存储对于每个nums，能够使用的query的value以及query的下标\n            List<List<Pair<Integer, Integer>>> optionListList = new ArrayList<>();\n            for (int i = 0; i < nums.length; i++) {\n                List<Pair<Integer, Integer>> optionList = new ArrayList<>();\n                for (int j = 0; j < queries.length; j++) {\n                    int[] query = queries[j];\n                    if (query[0] <= i && query[1] >= i) {\n                        optionList.add(new Pair<>(query[2], j));\n                    }\n                }\n                optionListList.add(optionList);\n            }\n\n\n            // 找出让每个num减到0需要的index，取最大的index作为返回\n            int maxK = 0;\n            for (int i = 0; i < nums.length; i++) {\n                int target = nums[i];\n                List<Pair<Integer, Integer>> options = optionListList.get(i);\n                if (target == 0) {\n                    continue;\n                }\n\n                // 一定无法减到0，直接返回\n                int sum = options.stream().mapToInt(Pair::getKey).sum();\n                if (sum < target) {\n                    return -1;\n                }\n\n                // 找出最少使用前k的option，让target减到0\n                int[] dp = new int[target + 1];\n                Arrays.fill(dp, Integer.MAX_VALUE);\n                dp[0] = -1; // 初始状态\n\n                for (Pair<Integer, Integer> p : options) {\n                    int val = p.getKey();\n                    int idx = p.getValue();\n\n                    // 反向遍历避免覆盖\n                    for (int s = target; s >= 0; s--) {\n                        if (dp[s] != Integer.MAX_VALUE) {\n                            int newSum = s + val;\n                            if (newSum <= target) {\n                                int newMaxIdx = Math.max(dp[s], idx);\n                                dp[newSum] = Math.min(dp[newSum], newMaxIdx);\n                            }\n                        }\n                    }\n                }\n                // System.out.println(\"dp[] \" +  Arrays.toString(dp));\n                if (dp[target] == Integer.MAX_VALUE) return -1;\n                maxK = Math.max(maxK, dp[target] + 1); // 转换为查询数量\n            }\n            return maxK;\n        }\n    }","author":"Sherlocked","submissionId":"611269790"},[]]},{"2131":[{"id":"2131","fileName":"611269720.txt","sourceCode":"class Solution {\n    // 模拟？\n    // dp，看出来了\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = queries.length;\n        int ans = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int num = nums[i];\n            if (num == 0) {\n                continue;\n            }\n            boolean[] flag = new boolean[num + 1];\n            flag[0] = true;\n            int k = 0;\n            for (; k < n && !flag[num]; k++) {\n                if (queries[k][0] > i || queries[k][1] < i) {\n                    continue;\n                }\n                for (int j = num; j >= queries[k][2]; j--) {\n                    flag[j] |= flag[j - queries[k][2]];\n                }\n            }\n            if (flag[num]) {\n                ans = Math.max(ans, k);\n            } else {\n                return -1;\n            }\n        }\n        return ans;\n    }\n}","author":"CNH5","submissionId":"611269720"},[]]},{"2132":[{"id":"2132","fileName":"611269796.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if all(num == 0 for num in nums):\n            return 0\n        ans, n, q = -1, len(nums), len(queries)                 \n        op = [[0]*n for i in range(q)]\n        for i, que in enumerate(queries):\n            for j in range(que[0], que[1]+1):\n                op[i][j] = que[2] \n        for i in range(n):\n            if nums[i] == 0:\n                continue\n            count = [row[i] for row in op]\n            # print(count)\n            s, flag = defaultdict(), 1\n            for k in range(len(count)):\n                if count[k] == 0:\n                    continue\n                temp_up = defaultdict()\n                for key in s:\n                    temp_up[key + count[k]] = 1\n                s.update(temp_up)\n                s[count[k]] = 1\n                # print(s)\n                if nums[i] in s:\n                    flag = 0\n                    break\n            # print(nums[i], k)\n            if flag:\n                return -1\n            else:\n                ans = max(ans, k+1)\n        return ans","author":"怳","submissionId":"611269796"},[]]},{"2133":[{"id":"2133","fileName":"611269812.txt","sourceCode":"// 每次选中一个范围然后用这个范围子集合恰好减少val\n// nums 的个数非常少 才十个元素\n// 然后结合二分\n// 那还需要二分嘛，直接递增的时候检查就好了\nfunc minZeroArray(nums []int, queries [][]int) int {\n    if slices.Max(nums) == 0 {\n        return 0\n    }\n    return solve(nums, queries)\n}\n\nfunc solve(nums []int, queries [][]int) int {\n    n := len(nums)\n    // 初始化状态值\n    f := make([][]bool, n)\n    for i := range f {\n        f[i] = make([]bool, nums[i] + 1)\n        f[i][0] = true\n    }\n    // 依次去使用每个值\n    for k, qItem := range queries {\n        l, r, v := qItem[0], qItem[1], qItem[2]\n\n        // 背包问题子问题\n        for i := range f {\n            if i > r || i < l {\n                // 只使用在范围内的\n                // 说明这个不属于当前元素\n                continue\n            }\n            for j := nums[i] - v; j >= 0; j -- {\n                if f[i][j] {\n                    f[i][j + v] = true\n                }\n            }\n        }\n\n        flag := true\n        for i := range f {\n            if !f[i][nums[i]] {\n                flag = false\n                break\n            } \n        }\n        if flag {\n            return k + 1\n        }\n    }\n    return -1\n}\n","author":"Serendipity","submissionId":"611269812"},[]]},{"2134":[{"id":"2134","fileName":"611269999.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        for (int k = 0; k <= queries.length; k++) {\n            if (canTransformToZero(nums, queries, k)) {\n                return k;\n            }\n        }\n        return -1;\n    }\n\n    private boolean canTransformToZero(int[] nums, int[][] queries, int k) {\n        List<List<Integer>> indicesValDict = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            indicesValDict.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < k; i++) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                indicesValDict.get(j).add(val);\n            }\n        }\n\n        for (int j = 0; j < nums.length; j++) {\n            int target = nums[j];\n            if (target == 0) {\n                continue;\n            }\n            List<Integer> usableVals = indicesValDict.get(j);\n            if (!subsetSumPossible(usableVals, target)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean subsetSumPossible(List<Integer> arr, int target) {\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n        for (int v : arr) {\n            for (int x = target; x >= v; x--) {\n                if (dp[x - v]) {\n                    dp[x] = true;\n                }\n            }\n        }\n        return dp[target];\n    }\n}","author":"不懂语言的崽子","submissionId":"611269999"},[]]},{"2136":[{"id":"2136","fileName":"611270181.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size(), ans = 0, b = -1;\n        for (int i=0;i<n;i++) {\n            b=-1;\n            if (nums[i] > 0) {\n                set<int> st;\n                st.insert(nums[i]);\n                for (int j = 0; j < m; j++) {\n                    if (i >= queries[j][0] && i <= queries[j][1]) {\n                        for (const auto& e : st) {\n                            if(e-queries[j][2]==0){\n                                b=max(b,j+1);\n                                break;\n                            }else  if(e-queries[j][2]>0){\n                                st.insert(e-queries[j][2]);\n                            }\n                        }\n                    }\n                    if(b>-1){\n                        break;\n                    }\n                     //cout<<i<<\" \"<<b<<endl;\n                }\n                \n            }else{\n                b=0;\n            }\n            if(b==-1){\n                return  b;\n            }\n           \n            ans=max(ans,b);\n        }\n\n        return ans;\n    }\n};","author":"行走天地间","submissionId":"611270181"},[]]},{"2137":[{"id":"2137","fileName":"611269176.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        # 01 背包\n        # dp[i][j][num] = True 第i位，第j个查询，能否到达num\n        n,m = len(nums),len(queries)\n        \n        res = -1\n        for i,num in enumerate(nums):\n            if not num:\n                if 0 > res:\n                    res = 0\n                continue\n            \n            # 滚动数组\n            dp = [False] * (num+1)\n            \n            # init\n            dp[0] = True\n            for j,(l,r,val) in enumerate(queries):\n                if l <= i <= r:\n                    ndp = deepcopy(dp)\n                    for lnum in range(0,num+1):\n                        if lnum + val > num:\n                            break\n                        if  dp[lnum]:\n                             ndp[lnum+val] = True\n                    dp = ndp\n\n                if dp[num]:\n                    if j + 1 > res:\n                        res = j + 1\n                    break\n            else:\n                return -1\n\n        return res\n                \n                    \n                ","author":"mipha","submissionId":"611269176"},[]]},{"2138":[{"id":"2138","fileName":"611270528.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        mx = max(nums)\n        mask = (1 << (mx + 1)) - 1\n        dp = [1] * n\n        def valid():\n            for i in range(n):\n                if (dp[i] >> nums[i]) & 1 == 0:\n                    return False\n            return True\n        if valid(): return 0\n        for k, (l, r, v) in enumerate(queries):\n            for i in range(l, r + 1):\n                dp[i] |= dp[i] << v\n                dp[i] &= mask\n            if valid():\n                return k + 1\n        return -1","author":"悖谬","submissionId":"611270528"},[]]},{"2139":[{"id":"2139","fileName":"611270351.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        int res = 0;\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == 0)\n                continue;\n            vector<int> dp(nums[i] + 1, 0);\n            dp[0] = 1;\n            int index = -1;\n            for (int j = 0; j < m; ++j) {\n                int l = queries[j][0];\n                int r = queries[j][1];\n                int v = queries[j][2];\n                if (l > i || r < i)\n                    continue;\n                for (int k = nums[i]; k >= v; --k)\n                    dp[k] |= dp[k - v];\n                if (dp[nums[i]] == 1) {\n                    index = j + 1;\n                    break;\n                }\n            }\n            if (index < 0)\n                return -1;\n            res = max(res, index);\n        }\n        return res;\n    }\n};","author":"潜龙","submissionId":"611270351"},[]]},{"2140":[{"id":"2140","fileName":"611270212.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        // 先判断全0情况\n        int flag = 1;\n        for (auto &n : nums) {\n            if (n != 0) {\n                flag = 0;\n                break;\n            }\n        }\n        if (flag) return 0;\n        // 其他情况\n        vector<unordered_set<int>> M(nums.size(), {0});\n        for (int k = 0; k < queries.size(); ++k) {\n            // 把qk加入，计算所有可能值\n            for (int i = queries[k][0]; i <= queries[k][1]; ++i) {\n                int val = queries[k][2];\n                vector<int> add = {val};\n                for (auto &n : M[i]) add.push_back(n + val);\n                for (auto &n : add) M[i].insert(n);\n            }\n            // 判断\n            int flag = 0;\n            for (int i = 0; i < nums.size(); ++i) {\n                if (M[i].count(nums[i])) continue;\n                else {\n                    flag = 1;\n                    break;\n                }\n            }\n            if (!flag) return k + 1;\n        }\n        return -1;\n    }\n};","author":"","submissionId":"611270212"},[]]},{"2141":[{"id":"2141","fileName":"611270147.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int mx = ranges::max(nums);\n        if (mx == 0) return 0;\n        int m = queries.size();\n        // vector<vector<int>> a(n);\n        vector<int> vis(n, -1);\n        vector<vector<int>> f(n, vector<int>(mx + 1, 0));\n        for (int i = 0; i < n; ++ i) {\n            f[i][0] = 1;\n        }\n        for (int i = 0; i < m; ++ i) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for (int j = l; j <= r; ++ j) {\n                // a[j].push_back(val);\n                if (vis[j] != -1) continue;\n                for (int v = nums[j]; v >= 0; -- v) {\n                    if (v + val <= nums[j] && f[j][v] == 1) {\n                        f[j][val + v] = 1;\n                    }\n                }\n                if (f[j][nums[j]] == 1) {\n                    vis[j] = i;\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++ i) {\n            // cout << i << ' ' << vis[i] << endl;\n            if (vis[i] == -1) return -1;\n            ans = max(ans, vis[i]);\n        }\n        return ans + 1;\n    }\n};","author":"心里没点AC数","submissionId":"611270147"},[]]},{"2142":[{"id":"2142","fileName":"611270612.txt","sourceCode":"bool fun(int mode, unordered_map<int, int>& cnt) {\n\tvector<bool> m(mode + 1);\n\tm[0] = true;\n\tfor (auto& e : cnt) {\n\t\tint a = e.first, b = e.second;\n\t\twhile (b--) {\n\t\t\tfor (int i = mode; i >= a; i--) {\n\t\t\t\tif (m[i - a]) \n\t\t\t\t\tm[i] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn m[mode];\n}\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<unordered_map<int, int>> add(n + 1);\n        vector<unordered_map<int, int>> sub(n + 1);\n        unordered_map<int, int> cnt;\n        int pos = 0, k = 0;\n        while (pos < n) {\n            // cnt += tmp[pos];\n            for (auto& e : add[pos]) {\n                cnt[e.first] += e.second;\n            }\n            for (auto& e : sub[pos]) {\n                cnt[e.first] -= e.second;\n                if (cnt[e.first] == 0) {\n                    cnt.erase(e.first);\n                }\n            }\n            while (!fun(nums[pos],cnt)) {\n                if (k == m)\n                    return -1;\n                int l = queries[k][0], r = queries[k][1], val = queries[k][2];\n                if (l <= pos && r >= pos)\n                    cnt[val]++;\n                // tmp[l] += val, tmp[r + 1] -= val, k++;\n                add[l][val]++, sub[r + 1][val]++,k++;\n                // cout << pos << ' '  << ' ' << k << endl;\n            }\n            pos++;\n        }\n        return k;\n    }\n};","author":"苏丹.奥古斯都","submissionId":"611270612"},[]]},{"2143":[{"id":"2143","fileName":"611270737.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        opt = [[0] * n for _ in range(m)]\n        for i in range(len(queries)):\n            l,r,val = queries[i]\n            for j in range(l,r+1):\n                opt[i][j] = val\n        ans = 0\n        print(opt)\n        for column in range(n):\n            if nums[column] == 0 :\n                continue\n            num_arr = set()\n            num_arr.add(0)\n            \n            for row in range(m):\n                if opt[row][column] != 0:\n                    num_arr_ = num_arr.copy()\n                    for num in num_arr_:\n                        num_arr.add(num+opt[row][column])\n                    if nums[column] in num_arr:\n                        ans = max(ans,row+1)\n                        break\n                if row == m-1:\n                    return -1\n        return ans\n                ","author":"0907","submissionId":"611270737"},[]]},{"2144":[{"id":"2144","fileName":"611270664.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        List<List<Integer>> list = new ArrayList<>();\n        for(int i = 0;i < n; i++) {\n            list.add(new ArrayList<>());\n        }\n        for(int i = 0;i < m; i++) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            for(int j = 0; j < n; j++) {\n                List<Integer> temp = list.get(j);\n                if(l <= j && j <= r) temp.add(val);\n                else temp.add(0);\n                list.set(j,temp);\n            }\n\n        }\n        int ans= -1;\n        for(int i = 0;i < n; i++) {\n            List<Integer> temp = list.get(i);\n            int[] dp = new int[nums[i] + 1];\n            dp[0] = 1;\n            if(dp[nums[i]] == 1) {\n                ans = Math.max(ans, 0);\n                continue;\n            }\n            for(int j = 0;j < temp.size(); j++) {\n                for(int k = nums[i]; k >= 0; k--) {\n                    if(k - temp.get(j) >= 0 && dp[k - temp.get(j)] != 0) {\n                        dp[k] = 1;\n                    }\n                }\n                if(dp[nums[i]] != 0) {\n                    ans = Math.max(ans, j + 1);\n                    break;\n                }\n            }\n            if(dp[nums[i]] == 0) return -1;\n        }\n\n        return ans;\n\n    }\n}","author":"文明键盘侠","submissionId":"611270664"},[]]},{"2145":[{"id":"2145","fileName":"611270164.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int maxK = 0;\n        //每一位最快到k的时候变成0?\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 0) {\n                continue;\n            }\n            //求querys 中的val之和等于nums[i]\n            Map<Integer, Map<Integer, Integer>> map = new HashMap<>();\n            int dfs = dfs(i, nums[i], 0, 0, queries, map);\n            if (dfs == Integer.MAX_VALUE) {\n                return -1;\n            }\n            maxK = Math.max(maxK, dfs);\n        }\n        return maxK;\n    }\n\n    public int dfs(int index, int num, int cur, int qIndex, int[][] queries, Map<Integer, Map<Integer, Integer>> map) {\n        if (num == cur) {\n            return qIndex;\n        }\n        if (cur > num || qIndex >= queries.length) {\n            return Integer.MAX_VALUE;\n        }\n        if (map.containsKey(qIndex) && map.get(qIndex).containsKey(cur)) {\n            return map.get(qIndex).get(cur);\n        }\n        //遍历query\n        int left = queries[qIndex][0];\n        int right = queries[qIndex][1];\n        int val = queries[qIndex][2];\n        int ans = Integer.MAX_VALUE;\n        if (index < left || index > right) {\n            ans = Math.min(ans, dfs(index, num, cur, qIndex + 1, queries, map));\n        }else {\n            int v1 = dfs(index, num, cur + val, qIndex + 1, queries, map);\n            int v2 = dfs(index, num, cur, qIndex + 1, queries, map);\n            ans =  Math.min(v1, v2);\n        }\n        map.computeIfAbsent(qIndex, k -> new HashMap<>()).put(cur, ans);\n        return ans;\n    }\n}","author":"Yaron-Xiong","submissionId":"611270164"},[]]},{"2146":[{"id":"2146","fileName":"611270789.txt","sourceCode":"#define PI pair<int,int>\nvector<PI>v[20];\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans=0;\n        int n=nums.size();\n        int m=queries.size();\n        for(int i=0;i<11;i++){\n            v[i].clear();\n        }\n        for(int i=0;i<m;i++){\n            vector<int>x=queries[i];\n            int l=x[0],r=x[1],val=x[2];\n            for(int j=l;j<=r;j++){\n                v[j].push_back(PI{val,i+1});\n            }\n        }\n        for(int i=0;i<n;i++){\n            int x=nums[i];\n            if(x==0){\n                ans=max(ans,0);continue;\n            }\n            vector<int>dp(x+2,0);\n            int l=v[i].size();\n            dp[0]=1;\n            for(int j=0;j<l;j++){\n                PI w=v[i][j];\n                int val=w.first;\n                int id=w.second;\n                for(int k=x-val;k>=0;k--){\n                    if(dp[k]){\n                        dp[k+val]=id;\n                    }\n                }\n                if(dp[x]){\n                    ans=max(ans,dp[x]);break;\n                }\n            }\n            if(dp[x]==0){\n                ans=-1;break;\n            }\n        }\n        return ans;\n    }\n};","author":"ۣۖิۣۖิۣۣۖۖ⃟刘","submissionId":"611270789"},[]]},{"2147":[{"id":"2147","fileName":"611270806.txt","sourceCode":"class Solution {\npublic:\nint minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n  int n = nums.size(), m = queries.size(), ans = 0;\n\n  for (int i = 0; i < n; ++i) {\n    int x = nums[i];\n    if (x == 0) {\n      continue;\n    }\n\n    vector<int> dp(x + 1, INT_MAX);\n    dp[0] = -1;\n\n    for (int j = 0; j < m; ++j) {\n      auto& q = queries[j];\n      int l = q[0], r = q[1], val = q[2];\n      if (i < l || i > r)\n        continue;\n\n      for (int v = x; v >= 0; --v) {\n        if (dp[v] != INT_MAX) {\n          int new_v = v + val;\n          if (new_v > x) {\n            continue;\n          }\n          dp[new_v] = min(dp[new_v], max(dp[v], j));\n        }\n      }\n    }\n\n    if (dp[x] == INT_MAX)\n      return -1;\n    ans = max(ans, dp[x] + 1);\n  }\n\n  return ans <= m ? ans : -1;\n}\n};","author":"兜大宝","submissionId":"611270806"},[]]},{"2148":[{"id":"2148","fileName":"611270889.txt","sourceCode":"class Solution {\npublic:\n    int cal(int pos, int aim, vector<vector<int>>& queries){\n        vector<int> dp(aim + 1, -1);\n        dp[0] = 0;\n        for(int j = 0; j < queries.size(); j++){\n            if(queries[j][0] <= pos && queries[j][1] >= pos){\n                vector<int> t;\n                for(int i = 0; i <= aim; i++){\n                    if(dp[i] != -1 && i + queries[j][2] <= aim){\n                        if(dp[i + queries[j][2]] == -1){\n                            t.push_back(i + queries[j][2]);\n                        }\n                    }\n                }\n                for(auto e : t){\n                    dp[e] = j + 1;\n                }\n            }\n        }\n        return dp[aim];\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = -1;\n        for(int i = 0; i < nums.size(); i++){\n            int val = cal(i, nums[i], queries);\n            if(val == -1){\n                return -1;\n            }\n            ans = max(ans, val);\n        }\n        return ans;\n    }\n};","author":"SuperDY","submissionId":"611270889"},[{"id":"2172","similarity":0.9782608695652174,"totOverlap":180,"longestOverlap":58},{"id":"2185","similarity":0.9239130434782609,"totOverlap":170,"longestOverlap":39}]],"2172":[{"id":"2172","fileName":"611272393.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = -1;\n        for (int i = 0; i < nums.size(); i++) {\n            int val = getCal(i, nums[i], queries);\n            if (val == -1) {\n                return -1;\n            }\n            ans = max(ans, val);\n        }\n        return ans;\n    }\n    int getCal(int pos, int post, vector<vector<int>>& queries) {\n        vector<int> dp(post + 1, -1);\n        dp[0] = 0;\n        for (int j = 0; j < queries.size(); ++j) {\n            if (queries[j][0] <= pos && queries[j][1] >= pos) {\n                vector<int> tp;\n                for (int i = 0; i <= post; i++) {\n                    if (dp[i] != -1 && i + queries[j][2] <= post) {\n                        if (dp[i + queries[j][2]] == -1) {\n                            tp.push_back(i + queries[j][2]);\n                        }\n                    }\n                }\n                for (auto e : tp) {\n                    dp[e] = j + 1;\n                }\n            }\n        }\n        return dp[post];\n    }\n};\n","author":"很晚才睡","submissionId":"611272393"},[{"id":"2148","similarity":0.9782608695652174,"totOverlap":180,"longestOverlap":58}]],"2185":[{"id":"2185","fileName":"611273004.txt","sourceCode":"class Solution {\npublic:\n    int aaa(int pos, int val, vector<vector<int>>& queries) {\n        vector<int> dp(val + 1, -1);\n        dp[0] = 0;\n        for (int j = 0; j < queries.size(); j++) {\n            if (queries[j][0] <= pos && queries[j][1] >= pos) {\n                vector<int> t;\n                for (int i = 0; i <= val; i++) {\n                    if (dp[i] != -1 && i + queries[j][2] <= val && dp[i + queries[j][2]] == -1) {\n                        t.push_back(i + queries[j][2]);\n                    }\n                }\n                for (int e : t) {\n                    dp[e] = j + 1;\n                }\n            }\n        }\n        return dp[val];\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int ans = -1;\n        for (int i = 0; i < nums.size(); i++) {\n            int val = aaa(i, nums[i], queries);\n            if (val == -1) {\n                return -1;\n            }\n            ans = max(ans, val);\n        }\n        return ans;\n    }\n};\n","author":"TA很酷","submissionId":"611273004"},[{"id":"2148","similarity":0.9239130434782609,"totOverlap":170,"longestOverlap":39}]]},{"2149":[{"id":"2149","fileName":"611271288.txt","sourceCode":"/*\n0: \nval = \n\ndp[k][target-cand[k]] = dp[k-1][target]\ndp[k][target] = dp[k-1][target]\n\n*/\n\n\nclass Solution {\nprivate:\n    vector<vector<int>> dp_;\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int len = nums.size(), m = queries.size();\n        vector<vector<pair<int, int>>> candidates(len);\n        for (int j = 0; j < m; j++) {\n            auto& query = queries[j];\n            for (int i = query[0]; i < query[1] + 1; i++) {\n                candidates[i].push_back(make_pair(query[2], j));\n            }\n        }\n        int res = 0;\n        for (int i = 0; i < len; i++) {\n            int dpK = candidates[i].size() + 1;\n            int dpT = nums[i] + 1;\n            // cout << \"i=\" << i << \",K=\" << dpK << \",T=\" << dpT << endl;\n            dp_.assign(dpK, vector<int>(dpT, -2));\n            // cout << \"dp_=\" << dp_.size() << endl;\n            int k = backtrace(candidates[i], nums[i], 0);\n            if (k == -1) {\n                res = -1;\n                break;\n            } else {\n                res = max(res, k);\n            }\n        }\n        return res;\n    }\n    \n    int backtrace(vector<pair<int, int>>& candidates, int target, int k) {\n\n        int n = candidates.size();\n        if (target == 0) return k == 0 ? 0 : candidates[k - 1].second + 1;\n        if (target < 0 || n == k) return -1;\n        if (dp_[k][target] != -2) return dp_[k][target];\n        int no_sel = backtrace(candidates, target, k + 1);\n        int sel = backtrace(candidates, target - candidates[k].first, k + 1);\n        // cout << \"k=\" << k << \",no_sel=\" << no_sel << \",sel=\" << sel << \",target=\" << target << endl;\n        if (no_sel == -1 && sel == -1) return  dp_[k][target] = -1;\n        else if (no_sel == -1) dp_[k][target] = sel;\n        else if (sel == -1) dp_[k][target] = no_sel;\n        else dp_[k][target] = min(no_sel, sel);\n        // cout << \"dp_[\" << k << \"][\"<< target << \"]=\" << dp_[k][target] << endl;\n        return dp_[k][target];\n    }\n    \n    /*\n    [2,0,2]\n[[0,2,1],[0,2,1],[1,1,3]]\n[4,3,2,1]\n[[1,3,2],[0,2,1]]\n[1,2,3,2,1]\n[[0,1,1],[1,2,1],[2,3,2],[3,4,1],[4,4,1]]\n[1,2,3,2,6]\n[[0,1,1],[0,2,1],[1,4,2],[4,4,4],[3,4,1],[4,4,5]]\n[0,0,0,0,0]\n[[0,1,1],[0,2,1],[1,4,2],[4,4,4],[3,4,1],[4,4,5]]\n[2]\n[[0,0,6],[0,0,2],[0,0,9],[0,0,5],[0,0,10]]\n\n[5,23,49,38,17]\n[[1,4,8],[2,3,3],[3,4,10],[2,2,6],[0,1,1],[1,4,3],[4,4,2],[3,4,5],[1,3,1],[2,3,3],[1,1,3],[2,3,3],[3,3,3],[2,3,6],[2,2,7],[0,1,3],[0,3,1],[1,1,9],[0,1,5],[2,3,7],[2,4,3],[0,2,4],[2,2,1],[1,4,10],[0,0,8],[3,4,6],[0,0,1],[4,4,1],[0,0,2],[1,3,9],[4,4,5],[3,3,1],[4,4,3],[3,4,9],[0,0,6],[4,4,5],[1,1,4],[0,1,4],[0,2,8],[1,2,2],[1,1,2],[3,4,1],[1,3,1],[4,4,9],[4,4,3],[1,3,1],[3,3,4],[0,4,6],[1,2,6],[3,4,8],[1,2,9],[0,4,9],[2,3,8],[2,4,4],[1,2,3],[2,4,6],[1,1,6],[1,3,2],[0,2,7],[2,3,5],[4,4,4],[0,1,6],[2,4,7],[2,3,9],[3,4,5],[4,4,4]]\n    */\n    \n};","author":"Huayu Zhang","submissionId":"611271288"},[]]},{"2150":[{"id":"2150","fileName":"611270894.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if self.isOK(nums):\n            return 0\n        N, M = len(nums), len(queries)\n        ans = -1\n        for i in range(N):\n            if nums[i] == 0: continue\n            index = self.getK(i, nums[i], queries, M)\n            if index == -1:\n                return -1\n            ans = max(ans, index)\n        return ans\n\n    def isOK(self, nums):\n        for v in nums:\n            if v != 0:\n                return False\n        return True\n\n    def getK(self, i, V, queries, M):\n        pre = [False for _ in range(1001)]\n        for index in range(M):\n            [l, r, v] = queries[index]\n            if i >= l and i <= r:\n                pre2 = [v for v in pre]\n                for j in range(1001):\n                    if pre[j] and j + v <= 1000:\n                        pre2[j + v] = True\n                pre2[v] = True\n                if pre2[V]:\n                    return index + 1\n                pre = pre2\n        return -1","author":"稽函数","submissionId":"611270894"},[]]},{"2151":[{"id":"2151","fileName":"611271166.txt","sourceCode":"class Solution {\n    struct Q {\n        int id;\n        int v;\n        Q(int id, int val): id(id), v(val) {}\n    };\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int nq = queries.size();\n\n        vector<vector<Q>> vec(n);\n\n        for(int i = 0; i < nq; i ++ ) {\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int v = queries[i][2];\n            for(int j = l; j <= r; j ++ ) {\n                vec[j].emplace_back(i, v);\n            }\n        }\n\n        for(auto& v: vec) {\n            sort(v.begin(), v.end(), [](const Q& q1, const Q& q2) {return q1.id < q2.id; });\n        }\n\n        vector<int> karr(n, -1);\n        for(int i = 0; i < n; i ++ ) {\n            int t = nums[i];\n            auto& qv = vec[i];\n            unordered_map<int, int> f;\n            f[0] = -1;\n            for(auto& q: qv) {\n                int j = q.id;\n                int v = q.v;\n                vector<pair<int, int>> ff;\n                for(const auto& [s, cur]: f) {\n                    int ns = s + v;\n                    int nmax = max(cur, j);\n                    ff.emplace_back(ns, nmax);\n                }\n                for(auto& [s, cur]: ff) {\n                    if(f.find(s) == f.end() || cur < f[s]) {\n                        f[s] = cur;\n                    }\n                }\n            }\n            if(f.find(t) == f.end()) return -1;\n            karr[i] = f[t];\n        }\n        int maxk = ranges::max(karr);\n        return maxk == -1? 0: maxk + 1;\n    }\n};","author":"空梦丶繁华褪去","submissionId":"611271166"},[]]},{"2152":[{"id":"2152","fileName":"611271437.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        # cs={tuple(nums)}\n        # zero=True\n        # for x in nums:\n        #     if x!=0:\n        #         zero=False\n        #         break\n        # if zero:\n        #     return 0\n        # for k in range(len(queries)): \n        #     l=queries[k][0]\n        #     r=queries[k][1]\n        #     val=queries[k][2]\n        #     ns=set()\n        #     ccs=list(cs)\n        #     for i in range(len(ccs)):\n        #         a=list(ccs[i])\n        #         ind=[]\n        #         for j in range(l,r+1): \n        #             ind.append(j)\n        #         m=len(ind)\n        #         for d in range(1<<m):\n        #             na=list(a)\n        #             flag=True\n        #             for j in range(m):\n        #                 if (d&(1<<j))>0:\n        #                     na[ind[j]]-=val\n        #                     if na[ind[j]]<0:\n        #                         flag=False\n        #                         break\n        #             if flag:\n        #                 ns.add(tuple(na)) \n        #     for s in ns:\n        #         zero=True\n        #         for x in s:\n        #             if x!=0:\n        #                 zero=False\n        #                 break\n        #         if zero:\n        #             return k+1 \n        #     cs=ns\n        # return -1\n        n=len(nums)\n        m=len(queries)\n        zero=True\n        for x in nums:\n            if x!=0:\n                zero=False\n                break\n        if zero:\n            return 0\n        def can_achieve(k):\n            for i in range(n):\n                t=nums[i]\n                dp=1 \n                for j in range(k):\n                    l,r,val=queries[j]\n                    if l<=i<=r:\n                        dp|=dp<<val\n                        dp&=(1<<(t+1))-1\n                if (dp>>t)&1==0:\n                    return False\n            return True\n        l,r=0,m+1\n        ans=-1\n        while l<r:\n            mid=(l+r)//2\n            if can_achieve(mid):\n                ans=mid\n                r=mid\n            else:\n                l=mid+1\n        return ans if ans!=-1 and ans<=m else -1","author":"琉璃丶","submissionId":"611271437"},[]]},{"2153":[{"id":"2153","fileName":"611271337.txt","sourceCode":"class Solution {\npublic:\n    int check(vector<int>& val_list,int target){\n        vector<bool> dp(target+1,false);\n        dp[0] = true;\n        if(target == 0)return 0;\n        for(int i = 0;i<val_list.size();++i){\n            for(int p = target;p>=val_list[i];--p){\n                dp[p] = dp[p-val_list[i]] || dp[p];\n                if(dp[target]){\n                    return i+1;\n                }\n            }\n        }\n        return -1;\n    }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        vector<vector<int>> candidates(n);\n        for(auto q:queries){\n            int l = q[0],r = q[1],val = q[2];\n            for(int j = 0;j<n;++j){\n                if(j >= l && j <= r){\n                    candidates[j].push_back(val);\n                }else candidates[j].push_back(0);\n            }\n        }\n        int k = -1;\n        for(int i = 0;i<n;++i){\n            int kk = check(candidates[i],nums[i]);\n            if(kk < 0)return -1;\n            else k = max(k,kk);\n        }\n        return k;\n    }\n};","author":"Yhc8Lx5g9O","submissionId":"611271337"},[]]},{"2154":[{"id":"2154","fileName":"611271366.txt","sourceCode":"class Solution {\npublic:\n    vector<int> w;\n    vector<vector<int>> q;\n    vector<vector<int>> g;\n    int n, mm;\n\n    int minZeroArray(vector<int>& _w, vector<vector<int>>& _q) {\n        w = _w, q = _q;\n        n = w.size(), mm = q.size();\n        int ok = 1;\n        for (auto x : w) if (x) ok = 0;\n        if (ok) return 0;\n        \n        int l = 0, r = mm;\n\n        g.resize(n);\n        while (l < r) {  // 修正二分查找边界\n            int m = l + r >> 1;\n            if (m == mm) return -1;\n            if (check(m))\n                r = m;\n            else\n                l = m + 1;\n        }\n        return r == mm ? -1 : r + 1;\n    }\n\n    bool check(int m) {\n        g.assign(n, vector<int>());  // 清空并初始化 g\n        for (int i = 0; i <= m; i++) {\n            int ll = q[i][0], rr = q[i][1], val = q[i][2];\n            for (int j = ll; j <= rr; j++) {  // 避免越界\n                g[j].emplace_back(val);\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (!canPartition(g[i], w[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool canPartition(vector<int>& nums, int target) {\n        vector<bool> dp(target + 1, false);\n        dp[0] = true;\n\n        for (int num : nums) {\n            for (int j = target; j >= num; j--) {\n                dp[j] = dp[j] | dp[j - num];\n            }\n        }\n        return dp[target];\n    }\n};\n","author":"Lambda","submissionId":"611271366"},[]]},{"2155":[{"id":"2155","fileName":"611271412.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int max = 0;\n        for(int i : nums) {\n            max = Math.max(max, i);\n        }\n        if(max == 0) {\n            return 0;\n        }\n        int l = 0, r = queries.length, m;\n        while(l < r) {\n            m = l + (r - l) / 2;\n            boolean f = func(nums, queries, m);\n            if(f) {\n                r = m;\n            } else {\n                l = m + 1;\n            }\n        }\n        return l >= queries.length ? -1 : l + 1;\n    }\n\n    private boolean func(int[] nums, int[][] queries, int limit) {\n        int N = nums.length;\n        List<Integer>[] lists = new List[N];\n        for(int i = 0; i < lists.length; i++) {\n            lists[i] = new ArrayList<>();\n        }\n        for(int i = 0; i <= limit; i++) {\n            int[] q = queries[i];\n            for(int j = q[0]; j <= q[1]; j++) {\n                lists[j].add(q[2]);\n            }\n        }\n        for(int i = 0; i < lists.length; i++) {\n            Collections.sort(lists[i]);\n        }\n        boolean flag = true;\n        for(int i = 0; i < N; i++) {\n            flag = flag && check(nums[i], lists[i]);\n        }\n        return flag;\n    }\n\n    private boolean check(int V, List<Integer> list) {\n        int N = list.size();\n        boolean[][] dp = new boolean[N + 1][V + 1];\n        dp[0][0] = true;\n        for(int i = 0; i < N; i++) {\n            int t = list.get(i);\n            for(int j = 0; j <= V; j++) {\n                dp[i + 1][j] = dp[i][j];\n                if(j >= t) {\n                    dp[i + 1][j] =  dp[i + 1][j] || dp[i][j - t];\n                } \n            }\n        }\n        return dp[N][V];\n    }\n }","author":"朝花夕拾","submissionId":"611271412"},[]]},{"2156":[{"id":"2156","fileName":"611271440.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def minKToZero(nums, queries):\n            # 检查是否存在负数元素\n            for num in nums:\n                if num < 0:\n                    return -1\n        \n            n = len(nums)\n            m = len(queries)\n        \n            # 预处理每个元素，收集覆盖它的查询并按索引排序\n            cover = [[] for _ in range(n)]\n            for j in range(m):\n                l, r, val = queries[j]\n                if l > r:\n                    continue  # 无效区间\n                # 为每个元素i在[l, r]区间内添加该查询\n                for i in range(l, r + 1):\n                    if i < n:\n                        cover[i].append((j, val))\n        \n            max_j_list = []\n            for i in range(n):\n                if nums[i] == 0:\n                    max_j_list.append(-1)\n                    continue\n        \n                queries_i = cover[i]\n                if not queries_i:\n                    return -1  # 该元素无法被任何查询覆盖\n        \n                # 按查询索引排序\n                queries_i.sort()\n        \n                # 动态规划求解最小最大j\n                dp = {0: -1}\n                for (j, val) in queries_i:\n                    new_dp = {}\n                    # 不选当前查询\n                    for s in dp:\n                        current_max = dp[s]\n                        if s in new_dp:\n                            if current_max < new_dp[s]:\n                                new_dp[s] = current_max\n                        else:\n                            new_dp[s] = current_max\n                        # 选当前查询\n                        new_s = s + val\n                        new_max = max(current_max, j)\n                        if new_s in new_dp:\n                            if new_max < new_dp[new_s]:\n                                new_dp[new_s] = new_max\n                        else:\n                            new_dp[new_s] = new_max\n                    dp = new_dp\n        \n                target = nums[i]\n                if target not in dp:\n                    return -1\n                max_j_list.append(dp[target])\n        \n            if not max_j_list:\n                return 0  # 所有元素都是0\n        \n            max_j = max(max_j_list)\n            k = max_j + 1\n            if k > m:\n                return -1\n            return k\n        return minKToZero(nums, queries)","author":"Cthva十十","submissionId":"611271440"},[]]},{"2157":[{"id":"2157","fileName":"611271543.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& qs) {\n        int n = nums.size(), m = qs.size();\n        int l = -1, r = m, all = accumulate(nums.begin(), nums.end(), 0);\n        if (all == 0) {\n            return 0;\n        }\n        auto check = [&](int idx) -> bool {\n            vector dp(n, vector<bool>());\n            for (int i = 0; i < n; i++) {\n                dp[i].resize(nums[i] + 1, false);\n                dp[i][0] = true;\n            }\n            \n            for (int i = 0; i <= idx; i++) {\n                int l = qs[i][0], r = qs[i][1], val = qs[i][2];\n                for (int j = l; j <= r; j++) {\n                    for (int k = nums[j]; k >= val; k--) {\n                        dp[j][k] = (dp[j][k] || dp[j][k - val]);\n                    }\n                }\n            }\n            \n            bool ok = true;\n            for (int i = 0; i < n; i++)\n                ok = (ok && dp[i][nums[i]]);\n            return ok;\n        };\n        while (l + 1 != r) {\n            int mid = l + r >> 1;\n            if (check(mid))\n                r = mid;\n            else\n                l = mid;\n        }\n        return (r == m ? -1 : r + 1);\n    }\n};","author":"赌怪","submissionId":"611271543"},[]]},{"2158":[{"id":"2158","fileName":"611271272.txt","sourceCode":"type query struct {\n    idx, val int\n}\n\nfunc minZeroArray(nums []int, queries [][]int) int {\n    n := len(nums)\n    m := len(queries)\n    c := make([][]query, n)\n    for j := 0; j < m; j++ {\n        l, r, val := queries[j][0], queries[j][1], queries[j][2]\n        for i := l; i <= r; i++ {\n            c[i] = append(c[i], query{j, val})\n        }\n    }\n\n    maxK := -1\n    possible := true\n\n    for i := 0; i < n; i++ {\n        target := nums[i]\n        if target == 0 {\n            continue\n        }\n        dp := make(map[int]int)\n        dp[0] = -1\n        for _, q := range c[i] {\n            j, val := q.idx, q.val\n            newDp := make(map[int]int)\n            for s, k := range dp {\n                newDp[s] = k\n                newS := s + val\n                if newS <= target {\n                    newK := max(k, j)\n                    if e, ok := newDp[newS]; !ok || newK < e {\n                        newDp[newS] = newK\n                    }\n                }\n            }\n            dp = newDp\n        }\n        if k, ok := dp[target]; ok {\n            if k > maxK {\n                maxK = k\n            }\n        } else {\n            possible = false\n            break\n        }\n    }\n\n    if !possible {\n        return -1\n    }\n    return maxK + 1\n}","author":"无名客","submissionId":"611271272"},[]]},{"2159":[{"id":"2159","fileName":"611271588.txt","sourceCode":"class Solution {\npublic:\nclass segmentTreeMax {\n    public:\n        segmentTreeMax() {}\n        segmentTreeMax(vector<int>& arr) {\n            this->size = arr.size();\n            this->arrTree.resize(arr.size() * 4, 0);\n            this->lazy.resize(arr.size() * 4, 0);\n            structSegmentTree(arr, 1, 0, arr.size() - 1);\n        }\n\n        void updateArea(int L, int R, int val){\n            updateAreaTree(1, 0, this->size - 1, L, R, val);\n        }\n\n        int findMax(int L, int R){\n            return getAreaSum(1, 0, this->size - 1, L, R);\n        }\n\n    private:\n        void push_down(int index, int l, int r) {\n            if (lazy[index]) {\n                int mid = l + (r - l) / 2;\n                lazy[index * 2] += lazy[index];\n                arrTree[index * 2] -= lazy[index];\n                lazy[index * 2 + 1] += lazy[index];\n                arrTree[index * 2 + 1] -= lazy[index];\n                lazy[index] = 0;\n            }\n        }\n\n        void push_up(int index) {\n            arrTree[index] =\n                max(arrTree[index * 2], arrTree[index * 2 + 1]);\n        }\n\n        void updateAreaTree(int index, int l, int r, int L, int R, int val) { // 区间修改\n            if (L <= l && r <= R) {\n                lazy[index] += val;\n                arrTree[index] -= val;\n                return;\n            }\n            push_down(index, l, r);\n            int mid = l + (r - l) / 2;\n            if (L <= mid) {\n                updateAreaTree(index * 2, l, mid, L, R, val);\n            }\n            if (R > mid) {\n                updateAreaTree(index * 2 + 1, mid + 1, r, L, R, val);\n            }\n            push_up(index);\n        }\n\n        int getAreaSum(int index, int l, int r, int L, int R) { // L查询左端点，R查询右端点\n            // return this->arrTree[1];\n            if (L <= l && r <= R) {\n                return this->arrTree[index];\n            }\n            push_down(index, l, r);\n            int res = INT_MIN;\n            int mid = l + (r - l) / 2;\n            if (L <= mid) {\n                res = max(res, getAreaSum(index * 2, l, mid, L, R));\n            }\n            if (R > mid) {\n                res = max(res, getAreaSum(index * 2 + 1, mid + 1, r, L, R));\n            }\n            push_up(index);\n            return res;\n        }\n\n    \n        void structSegmentTree(vector<int>& arr, int index, int l, int r) { // 构造线段树\n            if (l == r) {\n                this->arrTree[index] = arr[l];\n                return;\n            }\n            int mid = l + (r - l) / 2;\n            structSegmentTree(arr, index * 2, l, mid);\n            structSegmentTree(arr, index * 2 + 1, mid + 1, r);\n            push_up(index);\n        }\n        vector<int> lazy;\n        vector<int> arrTree;\n        int size;\n};\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        auto dfs = [&](auto&& dfs, int n, int i, vector<int>& a, vector<vector<int>>& dp)->int{\n            if(n == 0){\n                return i;\n            }\n            if(i == a.size()){\n                return n == 0 ? i : INT_MAX;\n            }\n            int& ret = dp[n][i];\n            if(ret != -1){\n                return ret;\n            }\n            ret = dfs(dfs, n, i + 1, a, dp);\n            if(a[i] <= n)\n                ret = min(ret, dfs(dfs, n - a[i], i + 1, a, dp));\n            return ret;\n        };\n        int ans = -1;\n        int i = 0;\n        for(int n : nums){\n            vector<int> a;\n            for(auto v : queries){\n                if(v[0] <= i && v[1] >= i){\n                    a.push_back(v[2]);\n                }else{\n                    a.push_back(INT_MAX);\n                }\n                \n            }\n            // for(int b : a){\n            //     cout << b << \" \";\n            // }\n            // cout << endl;\n            vector<vector<int>> dp(n + 1, vector<int>(a.size(), -1));\n            int tmp = dfs(dfs, n, 0, a, dp);\n            // cout << tmp << endl;\n            if(tmp == INT_MAX) return -1;\n            ans = max(ans, tmp);\n            i++;\n        }\n        return ans;\n    }\n};","author":"橙猫猫","submissionId":"611271588"},[]]},{"2160":[{"id":"2160","fileName":"611271654.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        len_q = len(queries)\n\n        @cache\n        def dfs(index, cur, k):\n            nonlocal min_k\n            if cur == 0:\n                min_k = k\n                return k\n            if k == len_q:\n                return k + 1\n            if k > min_k:\n                return k\n            left, right, val = queries[k]\n            if index < left or index > right:\n                return dfs(index, cur, k + 1)\n            return min(dfs(index, cur, k + 1), dfs(index, cur - val, k + 1))\n\n        res = 0\n        for i, num in enumerate(nums):\n            if num != 0:\n                min_k = len_q + 1\n                res = max(res, dfs(i, num, 0))\n                if res == len_q + 1:\n                    break\n        return res if res != len_q + 1 else -1\n","author":"Lewis.Finch","submissionId":"611271654"},[]]},{"2161":[{"id":"2161","fileName":"611271554.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n=nums.length;\n        int cnt=0;\n        boolean[]stop=new boolean[n];\n        HashMap<Integer, HashSet<Integer>> sum = new HashMap<>();\n        int maxK=queries.length;\n        int l;\n        int r;\n        int v;\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==0){\n                stop[i]=true;\n                cnt++;\n            }\n        }\n        if(cnt==n)return 0;\n        for(int k=0;k<maxK;k++){\n            l=queries[k][0];\n            r=queries[k][1];\n            v=queries[k][2];\n            for(int pos=l;pos<=r;pos++){\n                if(stop[pos])continue;\n                HashSet<Integer> set = sum.computeIfAbsent(pos,key->{\n                    HashSet<Integer> temp = new HashSet<>();\n                    temp.add(0);\n                    return temp;\n                });\n                HashSet<Integer> temp = new HashSet<>();\n                for(int num:set){\n                    if(num+v<=nums[pos])temp.add(num+v);\n                }\n                set.addAll(temp);\n                if(set.contains(nums[pos])){\n                    cnt++;\n                    stop[pos]=true;\n                }\n                if(cnt==n)return k+1;\n            }\n        }\n        HashMap temp=sum;\n        return -1;\n    }\n}","author":"辛世纪","submissionId":"611271554"},[]]},{"2162":[{"id":"2162","fileName":"611271687.txt","sourceCode":"class Solution {\npublic:\n    void print(vector<pair<int,int>>& x){\n        int n=x.size();\n        for(int i=0;i<n;i++){\n            cout << x[i].first << \" \" << x[i].second << endl;\n        }\n        cout << endl;\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int sum=accumulate(nums.begin(),nums.end(),0);\n        if(sum==0) return 0;\n        int n=nums.size(),m=queries.size();\n        vector q(n,vector<pair<int,int>>());\n        for(int i=0;i<m;i++){\n            int l=queries[i][0],r=queries[i][1],val=queries[i][2];\n            for(int j=l;j<=r;j++){\n                q[j].push_back({val,i});\n            }\n        }\n        vector<int> res(n,-1);\n        for(int i=0;i<n;i++){\n            vector<pair<int,int>> x=q[i];\n            int sz=x.size();\n            vector f(sz+1,vector<bool>(nums[i]+1,false));\n            for(int j=0;j<=sz;j++){\n                f[j][0]=true;\n            }\n            for(int j=1;j<=sz;j++){\n                for(int k=0;k<=nums[i];k++){\n                    f[j][k]=f[j][k]|f[j-1][k];\n                    if(k>=x[j-1].first)\n                        f[j][k]=f[j][k]|f[j-1][k-x[j-1].first];\n                }\n                if(f[j][nums[i]]) {\n                    res[i]=x[j-1].second;\n                    break;\n                }\n            }\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            if(res[i]==-1) return -1;\n            ans=max(ans,res[i]);\n        }\n        return ans+1;\n    }\n};","author":"zero","submissionId":"611271687"},[]]},{"2163":[{"id":"2163","fileName":"611271562.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n, m = len(nums), len(queries)\n    \n        def check(k: int) -> bool:\n            ji = [[] for _ in range(n)]\n            for i in range(k):\n                l, r, val = queries[i]\n                for j in range(l, r + 1):\n                    ji[j].append(val)\n            for i in range(n):\n                ji[i].sort(reverse=True)\n    \n            @cache\n            def dfs(i: int, j: int) -> bool:\n                if j == 0:\n                    return True\n                if j < 0 or i == len(p):\n                    return False\n                return dfs(i + 1, j) or dfs(i + 1, j - p[i])\n    \n            for i in range(n):\n                p = ji[i]\n                dfs.cache_clear()\n                if not dfs(0, nums[i]):\n                    dfs.cache_clear()\n                    return False\n            dfs.cache_clear()\n            return True\n    \n        left, right = 0, m\n        while left <= right:\n            mid = left + right >> 1\n            if check(mid):\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left if left <= m else -1","author":"星开祈灵","submissionId":"611271562"},[]]},{"2164":[{"id":"2164","fileName":"611271626.txt","sourceCode":"class Solution {\npublic:\n    bool canSum(vector<int>& nums, int target, int k) {\n        if (target < 0) return false; // 目标为负数直接返回false\n        vector<bool> dp(target + 1, false);\n        dp[0] = true; // 空集和为0\n        // for (int num : nums) {\n        for (int i=0; i<k ; ++i) {\n            int num = nums[i];\n            // 从后向前遍历，确保每个元素只用一次\n            for (int j = target; j >= num; j--) {\n                if (dp[j - num]) {\n                    dp[j] = true;\n                }\n            }\n        }\n        return dp[target];\n    }\n\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n=nums.size(), nq=queries.size();\n        vector<vector<int>> range_q(n, vector<int>(nq, 0) );\n        for(int i=0; i<nq; ++i){ // 转换数组\n            vector<int> & q1 = queries[i];\n            for(int j=q1[0]; j<= q1[1]; ++j){\n                range_q[j][i] = q1[2];\n            }\n        }\n        // for(auto q:range_q){\n        //     for(auto x:q){\n        //         cout << x << \" \";\n        //     }\n        //     cout << endl;\n        // }\n\n        auto check = [&] (int k) -> bool{\n            for(int i=0; i<n; ++i){\n                int num=nums[i];\n                if(!canSum(range_q[i], nums[i], k)){\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        // 二分的方法\n        int l=0, r=nq;\n        while(l<=r){\n            int mid = l+(r-l)/2;\n            if(check(mid)){\n                r = mid-1;\n            }else {\n                l = mid+1;\n            }\n        }\n        return l>nq? -1 : l;\n    }\n};","author":"junw59","submissionId":"611271626"},[]]},{"2165":[{"id":"2165","fileName":"611271751.txt","sourceCode":"class Solution {\npublic:\n    vector<pair<int,int>> f[10];\n    int check(int idx,int k){\n        int tmp[1050] = {0};\n        tmp[0] = 1;\n        int len = f[idx].size();\n        int sum = 0;\n        for(int i = 0;i<len;i++){\n            //cout<<f[idx][i].first<<\" \"<<f[idx][i].second<<endl;\n            int num = f[idx][i].first;\n            for(int i = sum;i>=0;i--){\n                tmp[i+num] = tmp[i+num]|tmp[i];\n            }\n            if(tmp[k] == 1) return f[idx][i].second;\n            sum += num;\n        }\n        //cout<<endl;\n        return -1;\n    }\n\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int lq = queries.size();\n        for(int i = 0;i<lq;i++){\n            for(int j = queries[i][0];j<=queries[i][1];j++){\n                f[j].push_back({queries[i][2],i+1});\n            }\n        }\n        int ans = 0;\n        for(int i = 0;i<nums.size();i++){\n            if(nums[i] == 0)    continue;\n            int res = check(i,nums[i]);\n            if(res != -1){\n                ans = max(ans,res);\n            }else{\n                return res;\n            }\n        }\n        return ans;\n    }\n};\n/*\n[2]\n[[0,0,6],[0,0,2],[0,0,9],[0,0,5],[0,0,10]]\n*/","author":"pan","submissionId":"611271751"},[]]},{"2166":[{"id":"2166","fileName":"611271801.txt","sourceCode":"public class Solution {\n    public int MinZeroArray(int[] nums, int[][] queries)\n    {\n        bool isOnlyZero = true;\n        for (int i = 0; i < nums.Length; ++i) if (nums[i] != 0) isOnlyZero = false;\n        if (isOnlyZero) return 0;\n        int left = -1, right = queries.Length;\n        while (left + 1 < right)\n        {\n            int mid = (left + right) / 2;\n            List<List<int>> list = GetList(queries, nums.Length, mid);\n            if (Check(nums, list)) right = mid;\n            else left = mid;\n        }\n\n        return right == queries.Length ? -1 : right + 1;\n    }\n\n    public List<List<int>> GetList(int[][] queries, int len, int queriesLen)\n    {\n        List<List<int>> list = new List<List<int>>();\n        for (int i = 0; i < len; ++i) list.Add(new List<int>());\n        for (int i = 0; i <= queriesLen; ++i)\n        {\n            for (int j = queries[i][0]; j <= queries[i][1]; ++j)\n            {\n                list[j].Add(queries[i][2]);\n            }\n        }\n        return list;\n    }\n\n    public bool Check(int[] nums, List<List<int>> list)\n    {\n        for (int i = 0; i < list.Count; ++i)\n        {\n            bool b = nums[i] == 0;\n            if (!b)\n            {\n                bool[] ck = new bool[nums[i] + 2];\n                ck[0] = true;\n                foreach (int j in list[i])\n                {\n                    for (int k = ck.Length - 1; k >= j; --k)\n                    {\n                        if (ck[k - j]) ck[k] = true;\n                    }\n                }\n                b = ck[nums[i]];\n            }\n                \n            if (!b) return false;\n        }\n        return true;\n    }\n}","author":"dyx0727","submissionId":"611271801"},[]]},{"2167":[{"id":"2167","fileName":"611271735.txt","sourceCode":"func minZeroArray(nums []int, queries [][]int) int {\n    n := len(nums)\n\tcover := make([][][2]int, n)\n\tfor i := range n {\n\t\tcover[i] = make([][2]int, 0)\n\t}\n\tfor j, q := range queries {\n        l, r, val := q[0], q[1], q[2]\n        for i := l; i <= r; i++ {\n            if i >= 0 && i < n {\n                cover[i] = append(cover[i], [2]int{val, j})\n            }\n        }\n\t}\n\tmx := 0\n\tfor i := 0; i < n; i++ {\n        target := nums[i]\n        if target == 0 {\n            continue\n        }\n        coveredQueries := cover[i]\n        if len(coveredQueries) == 0 {\n            return -1\n        }\n        found := false\n        minMaxIdx := math.MaxInt\n        curr := make(map[int]int)\n        curr[0] = -1\n        for _, q := range coveredQueries {\n            val := q[0]\n            idx := q[1]\n            next := make(map[int]int)\n            for s, maxIdx := range curr {\n                if existing, existed := next[s]; !existed || maxIdx < existing {\n                    next[s] = maxIdx\n                }\n            }\n            for s, maxIdx := range curr {\n                newSum := s + val\n                if newSum > target {\n                    continue\n                }\n                newMaxIdx := max(maxIdx, idx)\n                if existing, existed := next[newSum]; !existed || newMaxIdx < existing {\n                    next[newSum] = newMaxIdx\n                }\n            }\n            curr = next\n            if currMaxIdx, existed := curr[target]; existed {\n                if currMaxIdx < minMaxIdx {\n                    minMaxIdx = currMaxIdx\n                    found = true\n                }\n            }\n        }\n        if currMaxIdx, existed := curr[target]; existed {\n            if currMaxIdx < minMaxIdx {\n                minMaxIdx = currMaxIdx\n                found = true\n            }\n        }\n        if !found {\n            return -1\n        }\n        mx = max(mx, minMaxIdx + 1)\n\t}\n\treturn mx\n}\n","author":"二本吊车尾","submissionId":"611271735"},[]]},{"2168":[{"id":"2168","fileName":"611271849.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int> ans(nums.size(),-1);\n        bool f=true;\n        for (int i=0;i<nums.size();i++) {\n            if (nums[i]!=0) {\n                f=false;\n                break;\n            }\n        }\n        if (f) {\n            return 0;\n        }\n        for (int i = 0; i < nums.size(); i++) {\n            vector<bool> isValid(nums[i]+1, false);\n            isValid[nums[i]] = true;\n            for (int j = 0; j < queries.size(); j++) {\n                if (i>=queries[j][0] && i<=queries[j][1]) {\n                    for (int k = 0; k <= nums[i]-queries[j][2]; k++) {\n                        isValid[k] = isValid[k] || isValid[k+queries[j][2]];\n                    }\n                    if (isValid[0]) {\n                        ans[i]=j+1;\n                        break;\n                    }\n                }\n            }\n        }\n        int res=-1;\n        for (int i = 0; i < nums.size(); i++) {\n            if (ans[i]!=-1) {\n                res=max(res,ans[i]);\n            }else {\n                return -1;\n            }\n        }\n        return res;\n    }\n};\n","author":"摆渡人","submissionId":"611271849"},[]]},{"2169":[{"id":"2169","fileName":"611272065.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        bool allZero = true;\n        for (int x : nums) if (x != 0) allZero = false;\n        if (allZero) return 0;\n        \n        int n = (int)nums.size(), q = queries.size();\n        vector<vector<int>> dp(n);\n        for (int i = 0; i < n; i++) {\n            dp[i].resize(nums[i]+1);\n            dp[i][0] = 1;\n        }\n    \n        for (int i = 0; i < q; i++) {\n            int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n            for (int j = l; j <= r; j++) {\n                for (int k = nums[j]-val; k >= 0; k--) {\n                    if (dp[j][k]) {\n                        dp[j][k+val] = 1;\n                    }\n                }\n            }\n            bool ok = true;\n            for (int i = 0; i < n; i++) {\n                if (!dp[i][nums[i]]) ok = false;\n            }\n            if (ok) return i+1;\n        }\n        return -1;\n    }\n};","author":"upk1_dwk2","submissionId":"611272065"},[]]},{"2170":[{"id":"2170","fileName":"611271973.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n\n        \n        # n = len(nums)\n        # # 把 nums 变为 0 的差分数组\n        # # 差分数组\n        # diff = [0]*n\n        # for ind, (l, r, v) in enumerate(queries):\n        #     not_enough = False\n        #     diff[l] -= v\n        #     if r < n-1:\n        #         diff[r+1] += v\n        #     cur = 0\n        #     for i, val in enumerate(nums):\n        #         cur += val + diff[i]\n        #         if cur > 0:\n        #             not_enough = True\n        #             break\n        #     if not not_enough:\n        #         return ind+1\n        # # for l, r, v in queries:\n        # return -1\n\n        # for ind, (l, r, v) in enumerate(queries):\n        #     for i in range(l, r+1):\n        #         nums[i] -= v\n        #     fail = False\n        #     for val in nums:\n        #         if val > 0:\n        #             fail = True\n        #     if not fail:\n        #         return ind+1\n        # return -1\n        def checkValid(num, array):\n            array.sort()\n            n = len(array)\n            any_suc = False\n            def dfs(i, tar):\n                nonlocal any_suc\n                if tar == 0:\n                    any_suc = True\n                    return True\n                if i == n:\n                    return False\n                if tar >= array[i]:\n                    dfs(i+1, tar-array[i])\n                    dfs(i+1, tar)\n            dfs(0, num)\n            return any_suc\n\n        def find_smallest(num, i, queries):\n            ans = -1\n            if num == 0:\n                return 0\n            array = []\n            cur_sum = 0\n            for ind, q in enumerate(queries):\n                l, r, v = q\n                if l > i or r < i:\n                    continue\n                else:\n                    if v > num:\n                        continue\n                    elif v == num:\n                        return ind+1\n                    array.append(v)\n                    cur_sum += v\n                    if cur_sum == num:\n                        return ind+1\n                    if cur_sum > num:\n                        valid = checkValid(num, array)\n                        # print(valid, num, array)\n                        if valid:\n                            return ind+1\n            return ans\n        ans = -1 \n        for i, num in enumerate(nums):\n            cur = find_smallest(num, i, queries)\n            # print(i, num, cur)\n            if cur == -1:\n                return -1\n            else:\n                ans = max(ans, cur)\n        return ans\n            \n            ","author":"raphael","submissionId":"611271973"},[]]},{"2171":[{"id":"2171","fileName":"611272160.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        int mx = ranges::max(nums);\n        //dp[i][j][k]表示nums[i]执行到第i个查询能否变为k\n        vector<vector<vector<int>>> dp(n, vector(m + 1, vector<int>(mx + 1, 0)));\n        vector<int> ans(n, INT_MAX);\n        for(int i = 0; i < n; ++i){\n            dp[i][0][nums[i]] = 1;\n            if(nums[i] == 0){\n                ans[i] = 0;\n            }\n        }\n        for(int i = 0; i < n; ++i){\n            for(int j = 1; j <= m; ++j){\n                int l = queries[j - 1][0], r = queries[j - 1][1], val = queries[j - 1][2];\n                for(int k = 0; k <= nums[i]; ++k){\n                    dp[i][j][k] = dp[i][j - 1][k];\n                    if(l <= i && r >= i && dp[i][j - 1][k] && k >= val){\n                        dp[i][j][k - val] = 1;\n                        if(k == val){\n                            ans[i] = min(ans[i], j);\n                        }\n                    }\n                }\n            }\n        }\n        int res = 0;\n        for(int i = 0; i < n; ++i){\n            if(ans[i] == INT_MAX)\n                return -1;\n            else{\n                res = max(res, ans[i]);\n            }\n        }\n        return res;\n    }\n};","author":"歌者","submissionId":"611272160"},[]]},{"2173":[{"id":"2173","fileName":"611272389.txt","sourceCode":"use std::collections::HashSet;\n\nimpl Solution {\n    pub fn min_zero_array(v: Vec<i32>, q: Vec<Vec<i32>>) -> i32 {\n        let n = v.len();\n        let mut p = vec![vec![]; n];\n\n        for (i, q) in q.into_iter().enumerate() {\n            let (l, r, x) = (q[0] as usize, q[1] as usize, q[2]);\n            (l..=r).for_each(|j| p[j].push((i, x)));\n        }\n\n        let mut ans = 0;\n\n        p.into_iter().zip(v.into_iter()).for_each(|(p, x)| {\n            if ans != -1 {\n                let mut y = x;\n                let mut s: HashSet<i32> = HashSet::new();\n                let mut k = -1;\n                s.insert(x);\n\n                for p in p {\n                    if s.contains(&p.1) {\n                        k = p.0 as i32 + 1;\n                        break;\n                    } else {\n                        for z in s.clone() {\n                            if z >= p.1 {\n                                s.insert(z - p.1);\n                            }\n                        }\n                        if p.1 <= y {\n                            y -= p.1;\n                            s.insert(y);\n                            if y == 0 {\n                                k = p.0 as i32 + 1;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if k > 0 {\n                    ans = ans.max(k);\n                } else if x != 0 {\n                    ans = -1;\n                }\n            }\n        });\n\n        ans\n    }\n}","author":"Somnia1337x","submissionId":"611272389"},[]]},{"2174":[{"id":"2174","fileName":"611272391.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n=len(nums)\n        m=len(queries)\n        cnt=0\n        t=[set() for i in range(n)]\n        def op(l,r,val):\n            nonlocal cnt\n            for i in range(l,r+1):\n                if nums[i]!=0:\n                    if val in t[i]:\n                        cnt+=1\n                        nums[i]=0\n                    else:\n                        temp=deepcopy(t[i]) #不选\n                        for x in t[i]:\n                            if x-val>0:\n                                temp.add(x-val)\n                        t[i]=temp\n                \n        ans=0\n        for i in range(n):\n            if nums[i]==0:\n                cnt+=1\n            else:\n                t[i].add(nums[i])\n        if cnt==n:\n            return 0\n        for i in range(m):\n            l,r,val=queries[i][0],queries[i][1],queries[i][2]\n            op(l,r,val)\n            # print(t)\n            ans+=1\n            if cnt==n:\n                return ans\n        \n        return -1","author":"炼红心","submissionId":"611272391"},[]]},{"2175":[{"id":"2175","fileName":"611272633.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def ok(target,list):\n            if target==0:\n                return 0\n            cnt0={0}\n            cnt1=set()\n            for i in range(0,len(list)):\n                for j in cnt0:\n                    cnt1.add(j+list[i])\n                if target in cnt1:\n                    return i+1\n                else:\n                    cnt0=cnt0|cnt1\n                    cnt1=cnt0.copy()\n            return 100000\n        n=len(nums)\n        answer=0\n        for i in range(0,n):\n            dp=[]\n            for p,q,r in queries:\n                if p<=i<=q:\n                    dp.append(r)\n                else:\n                    dp.append(0)\n            answer=max(answer,ok(nums[i],dp))\n        if answer==100000:\n            return -1\n        else:\n            return answer","author":"94664","submissionId":"611272633"},[]]},{"2176":[{"id":"2176","fileName":"611272461.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n=len(nums)\n        nq=len(queries)\n        ans=[2000]*n\n        for i in range(n):\n            num=nums[i]\n            if num==0:\n                ans[i]=0\n                continue\n            f=[-2000]*(num+1)\n            f[0]=1\n            for j in range(nq):\n                if queries[j][0]<=i and queries[j][1]>=i:\n                    for k in range(num,queries[j][2]-1,-1):\n                        f[k]=max(f[k],f[k-queries[j][2]])\n                if f[num]==1:\n                    ans[i]=j+1\n                    break\n        if max(ans)!=2000:\n            return max(ans)\n        return -1\n                    \n                ","author":"...","submissionId":"611272461"},[]]},{"2177":[{"id":"2177","fileName":"611272816.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        const int N = 1010;\n        bitset<N> f[N];\n        for(int i = 0; i < N; i ++) f[i].reset();\n        for(int i = 0; i < N; i ++) f[i][0] = 1;\n        int n = nums.size(), m = queries.size();\n        vector<int> cnt(n, m + 1);\n        for(int i = 0; i < n; i ++)\n            if(nums[i] == 0) cnt[i] = 0;\n        for(int i = 0; i < nums.size(); i ++)\n        {\n            int x = nums[i];\n            for(int j = 0; j < m; j ++)\n            {\n                int l = queries[j][0], r = queries[j][1], v = queries[j][2];\n                if(l <= i && r >= i)\n                {\n                    f[i] |= (f[i] << v);\n                    if(f[i][x] == 1) cnt[i] = min(cnt[i], j + 1);\n                }\n            }\n        }\n        int ans = 0;\n        for(int i = 0; i < nums.size(); i ++)\n        {\n            int x = nums[i];\n            ans = max(ans, cnt[i]);\n        }\n        if(ans > m) ans = -1;\n        return ans;\n    }\n};","author":"肥工第一深情","submissionId":"611272816"},[]]},{"2178":[{"id":"2178","fileName":"611272676.txt","sourceCode":"class Solution {\n    public:\n        int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n            int n = nums.size();\n            int m = queries.size();\n            vector<vector<int>> vvt(n);\n            vector<vector<int>> vvtt(n);\n            for (int i = 0; i < m; i++){\n                for (int j = queries[i][0]; j <= queries[i][1]; j++){\n                    vvt[j].push_back(queries[i][2]);\n                    vvtt[j].push_back(i);\n                }\n            }\n            vector<set<int>> status(n);\n            for (int i = 0; i < n; i++){\n                status[i].emplace(nums[i]);\n            }\n            vector<int> res(n,-1);\n            for (int i = 0; i < n; i++){\n                int n1 = vvt[i].size();\n                int f = 0;\n                if(nums[i]==0){\n                    res[i] = 0;\n                    continue;\n                }\n                for (int j = 0; j < n1; j++){\n                    if(f) break;\n                    for(auto k : status[i]){\n                        int t = k-vvt[i][j];\n                        if(t<0)continue;\n                        else if(t==0){\n                            res[i] = vvtt[i][j]+1;\n                            f = 1;\n                            break;\n                        }\n                        else{\n                            status[i].emplace(t);\n                        }\n                    }\n                }\n                \n                \n            }\n            if(find(res.begin(),res.end(),-1)!=res.end())return -1;\n            return *max_element(res.begin(),res.end());\n        }\n    };","author":"AwakeFantasy","submissionId":"611272676"},[]]},{"2179":[{"id":"2179","fileName":"611272832.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        auto isZero = [](vector<int>& nums){\n            for(auto x : nums) {\n                if (x > 0) return false;\n            }\n            return true;\n        };\n        if (isZero(nums)) {\n            return 0;\n        }\n        unordered_map<int,map<int,bool>> mp;\n        for (int i = 0; i < nums.size(); ++i) {\n            mp[i][nums[i]] = true;\n            mp[i][0] = true;\n        }\n        for (int i = 0; i < queries.size(); ++i) {\n            auto tuple = queries[i];\n            for (int j = tuple[0]; j <= tuple[1]; ++j) {\n                auto it= mp[j].find(tuple[2]);\n                if (it != mp[j].end() && it->second) {\n                    nums[j] = 0;\n                    continue;\n                }\n                for(auto x : mp[j]) {\n                    if (x.second && x.first >= tuple[2]) {\n                        mp[j][x.first - tuple[2]] = true;\n                    }\n                }\n\n            }\n            if (isZero(nums)) {\n                return i+1;\n            }\n        }\n        return -1;\n    }\n};","author":"躺平选手","submissionId":"611272832"},[]]},{"2180":[{"id":"2180","fileName":"611272965.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int m = queries.size();\n        \n        vector<vector<pair<int, int>>> tmp(n);\n        for (int idx = 0; idx < m; ++idx) {\n            int l = queries[idx][0];\n            int r = queries[idx][1];\n            int val = queries[idx][2];\n            for (int i = l; i <= r; ++i) {\n                tmp[i].emplace_back(val, idx);\n            }\n        }\n        \n        int maxK = -1;\n        for (int i = 0; i < n; ++i) {\n            int target = nums[i];\n            if (target == 0) {\n                continue;\n            }\n            \n            auto& qs = tmp[i];\n            unordered_map<int, int> dp{};\n            dp[0] = -1;\n            \n            for (auto& [val, idx] : qs) {\n                unordered_map<int, int> tmp;\n                for (auto& [s, current_max] : dp) {\n                    int newS = s + val;\n                    if (newS > target) continue;\n\n                    int maxVal = max(current_max, idx);\n                    if (!tmp.contains(newS) || maxVal < tmp[newS]) {\n                        tmp[newS] = maxVal;\n                    }\n                }\n                \n                for (auto& [s, maxVal] : tmp) {\n                    if (!dp.contains(s) || maxVal < dp[s]) {\n                        dp[s] = maxVal;\n                    }\n                }\n            }\n            \n            if (!dp.contains(target)) return -1;\n            \n            maxK = max(maxK, dp[target]);\n        }\n        \n        if (maxK == -1) {\n            return 0;\n        }\n\n        return (maxK + 1 <= m) ? maxK + 1 : -1;\n    }\n};\n","author":"不到2000非好汉","submissionId":"611272965"},[]]},{"2181":[{"id":"2181","fileName":"611272608.txt","sourceCode":"#include <bits/stdc++.h>\n#define debug(a) cout<<#a<<\"=\"<<a<<\"n\"\n#define EPS 1e-8\n#define IOS ios::sync_with_stdio(0),cin.tie(0)\n#define all(v) v.begin(),v.end()\nusing namespace std;\nusing i64 = long long;\nusing ull = unsigned long long;\nusing pi = pair<int,int>;\nusing pl = pair<long long,long long>;\nstatic constexpr int ALPHABET_SIZE = 26;\nstatic constexpr i64 N = 1000000 + 5;\nstatic constexpr int MOD = 998244353;\nclass Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        //1 <= queries.length <= 1000; 1 <= nums.length <= 10; 0 <= nums[i] <= 1000\n        //对于每个位置，可以选择减，也可以不减\n        //计算每个位置变为0的最小次数\n        //dp[i][n]: 前q次查询该位置变为n的最小次数\n        int n = nums.size(), q = queries.size();\n        vector<int> times;\n        for (int i = 0; i < n; i++) {\n            int cur = nums[i];\n            vector dp(q + 1, vector<int>(cur + 1, INT_MAX / 2));\n            dp[0][cur] = 0;\n            for (int j = 1; j <= q; j++) {\n                int l = queries[j - 1][0], r = queries[j - 1][1], v = queries[j - 1][2];\n                \n           \n                for (int k = 0; k <= cur; k++) {\n                    dp[j][k] = dp[j - 1][k];\n                    //选\n                    if (l <= i && i <= r && k + v <= cur) {\n                        dp[j][k] = min(dp[j][k], dp[j - 1][k + v] + 1);\n                    }\n                }\n            \n            }\n            int time = INT_MAX;\n            for (int j = 0; j <= q; j++) {\n                if (dp[j][0] < 10000)\n                    time = min(time, j);\n            }\n            times.emplace_back(time);\n        }\n        sort(all(times));\n        if (times[n - 1] > 10000) {\n            return -1;\n        } else {\n            return times[n - 1];\n        }\n    }\n};","author":"千早爱音","submissionId":"611272608"},[]]},{"2182":[{"id":"2182","fileName":"611273012.txt","sourceCode":"class Solution {\n    fun minZeroArray(nums: IntArray, queries: Array<IntArray>): Int {\n        val n = nums.size\n        val elementQueries = Array(n) { mutableListOf<Pair<Int, Int>>() }\n\n        for (qIdx in queries.indices) {\n            val (l, r, v) = queries[qIdx]\n            for (i in l..r) {\n                if (i in 0 until n) {\n                    elementQueries[i].add(qIdx to v)\n                }\n            }\n        }\n\n        var maxK = 0\n        for (i in 0 until n) {\n            val target = nums[i]\n            if (target == 0) {\n                maxK = maxOf(maxK, 0)\n                continue\n            }\n\n            val qList = elementQueries[i]\n            val dp = mutableMapOf(0 to -1)\n            for ((qIdx, v) in qList) {\n                val newDp = dp.toMutableMap()\n                for ((s, currentMax) in dp) {\n                    val sNew = s + v\n                    if (sNew > target) continue\n                    val newMax = maxOf(currentMax, qIdx)\n                    if (sNew in newDp) {\n                        if (newMax < newDp[sNew]!!) {\n                            newDp[sNew] = newMax\n                        }\n                    } else {\n                        newDp[sNew] = newMax\n                    }\n                }\n                dp.clear()\n                dp.putAll(newDp)\n            }\n\n            if (target !in dp) return -1\n            val kI = dp[target]!! + 1\n            if (kI > queries.size) return -1\n            maxK = maxOf(maxK, kI)\n        }\n\n        return maxK\n    }\n}","author":"兴禾","submissionId":"611273012"},[]]},{"2183":[{"id":"2183","fileName":"611272682.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        if (allZero(nums)) {\n            return 0;\n        }\n        boolean[][] dp = new boolean[nums.length][1001];\n        for (boolean[] arr : dp) {\n            arr[0] = true;\n        }\n\n        for (int qi = 0; qi < queries.length; qi++) {\n            int l = queries[qi][0];\n            int r = queries[qi][1];\n            int val = queries[qi][2];\n\n            for (int i = l; i <= r; i++) {\n                for (int j = dp[i].length - 1; j >= 0; j--) {\n                    if (dp[i][j] && j + val < dp[i].length) {\n                        dp[i][j + val] = true;\n                    }\n                }\n            }\n            // after query\n            boolean allZero = true;\n            for (int i = 0; i < nums.length; i++) {\n                if (!dp[i][nums[i]]) {\n                    allZero = false;\n                    break;\n                }\n            }\n\n            if (allZero) {\n                return qi + 1;\n            }\n        }\n        return -1;\n    }\n\n    private boolean allZero(int[] nums) {\n        for (int num : nums) {\n            if (num != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}","author":"peterqiu-007","submissionId":"611272682"},[]]},{"2184":[{"id":"2184","fileName":"611273090.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& a, vector<vector<int>>& query) {\n        int n = a.size();\n        int m = query.size();\n        int l = 0, r = m, ans = -1;\n\n        auto check = [](vector<int> &has, int target) -> bool {\n            int siz = has.size();\n            if (siz == 0) {\n                return target == 0;\n            }\n            vector<vector<bool>> dp(siz, vector<bool>(target + 1));\n            for (int i = 0; i < siz; i++) {\n                dp[i][0] = true;\n            }\n            if (has[0] <= target) {\n                dp[0][has[0]] = true;\n            }\n            for (int i = 1; i < siz; i++) {\n                for (int j = 1; j <= target; j++) {\n                    dp[i][j] = dp[i][j] | dp[i - 1][j];\n                    if (j - has[i] >= 0) {\n                        dp[i][j] = dp[i][j] | dp[i - 1][j - has[i]];\n                    }\n                }\n            }\n            return dp[siz - 1][target];\n        };\n        \n        while (l <= r) {\n            int mid = (l + r) / 2;\n            vector<vector<int>> staff(n);\n            for (int i = 0; i < mid; i++) {\n                int L = query[i][0];\n                int R = query[i][1];\n                int v = query[i][2];\n                \n                for (int j = L; j <= R; j++) {\n                    staff[j].push_back(v);\n                }\n            }\n            bool ok = true;\n            for (int i = 0; i < n; i++) {\n                auto &has = staff[i];\n                if (!check(has, a[i])) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) {\n                r = mid - 1;\n                ans = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","author":"Leesuhyun","submissionId":"611273090"},[]]},{"2186":[{"id":"2186","fileName":"611273015.txt","sourceCode":"class Solution {\npublic:\n\nint minZeroArray(vector<int> &nums, vector<vector<int>> &queries) {\n    int n = nums.size();\n    unordered_map<int, unordered_set<int>> st;\n    for (int i = 0; i < n; ++i) {\n        st[i].insert(0);\n    }\n    auto check = [&]() -> bool {\n        for (int i = 0; i < n; ++i) {\n            if (!st[i].count(nums[i]))return false;\n        }\n        return true;\n    };\n    if (check())return 0;\n    for (int i = 0; i < queries.size(); ++i) {\n        int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n        for (int j = l; j <= r; ++j) {\n            vector<int> tmp;\n            for (int x:st[j]) {\n                tmp.push_back(x + val);\n            }\n            st[j].insert(tmp.begin(), tmp.end());\n        }\n        if (check())return i + 1;\n    }\n    return -1;\n}\n};","author":"致命之足","submissionId":"611273015"},[]]},{"2187":[{"id":"2187","fileName":"611273262.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = queries.size(), m = nums.size();\n        bool allzero = true;\n        for(int i = 0; i < m; i++){\n            if(nums[i] != 0){\n                allzero = false;\n                break;\n            }\n        }\n        if(allzero) return 0;\n        vector<vector<int>> mp(n + 1, vector<int>(m, 0));\n        for(int i = 0; i < n; i++){\n            int l = queries[i][0], r = queries[i][1], v = queries[i][2];\n            for(int j = l; j <= r; j++){\n                mp[i + 1][j] = v;\n            }\n        }\n        //\n        //dp[i][j]  考虑1~n行，最短长度，\n        vector<bool> dp;\n        int minlen = 0;\n        for(int k = 0; k < m; k++){\n            int x = nums[k];  // 目标为x\n            // 初始化dp\n            dp = vector<bool>(1010, false);\n            dp[0] = true;\n            for(int i = 1; i <= n; i++){\n                for(int j = x; j - mp[i][k] >= 0; j--){\n                    dp[j] = dp[j] || dp[j - mp[i][k]];\n                }\n                if(dp[x] == true){\n                    minlen = max(minlen, i);\n                    break;\n                }\n            }\n            // 检查\n            if(dp[x] == false) return -1;\n        }\n        return minlen;\n    }\n};","author":"Ged_Relay","submissionId":"611273262"},[]]},{"2188":[{"id":"2188","fileName":"611273132.txt","sourceCode":"class Solution {\npublic:\n    bool cal(vector<int> &k, int m) {\n        int n = k.size() - 1;\n        vector<bool> dp(m + 1, false);\n        dp[0] = true;\n        \n        vector<int> w;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= k[i]; j <<= 1) {\n                w.push_back(j * i);\n                k[i] -= j;\n            }\n            if (k[i] > 0) {\n                w.push_back(k[i] * i);\n            }\n        }\n        \n        for (int i = 0; i < w.size(); i++) {\n            for (int j = m; j >= w[i]; j--) {\n                dp[j] = dp[j] || dp[j - w[i]];\n            }\n        }\n        return dp[m];\n    }\n    int minZeroArray(vector<int>& a, vector<vector<int>>& q) {\n        int n = a.size(), m = q.size();\n        bool all_zero = true;\n        for (int i = 0; i < n; i++) {\n            if (a[i] != 0) {\n                all_zero = false;\n                break;\n            }\n        }\n        if (all_zero) {\n            return 0;\n        }\n        for (int mid = 0; mid < m; mid++) {\n            bool ok = true;\n            for (int i = 0; i < n; i++) {\n                vector<int> k(11, 0);\n                for (int j = 0; j <= mid; j++) {\n                    if (q[j][0] <= i && q[j][1] >= i) {\n                        ++k[q[j][2]];\n                    }\n                }\n                if (!cal(k, a[i])) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) {\n                return mid + 1;\n            }\n        }\n        return -1;\n    }\n};","author":"muffin","submissionId":"611273132"},[]]},{"2189":[{"id":"2189","fileName":"611273409.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        if(accumulate(nums.begin(), nums.end(), 0) == 0) return 0;\n        if(nums.size() == 3 && queries.size() == 3) {\n            if(nums == vector<int>{2, 0, 2} && queries[0] == vector<int>{0, 2, 1} && queries[1] == vector<int>{0,2, 1} && queries[2] == vector<int>{1,1,3}) return 2;\n        } \n        const int n = nums.size();\n        vector<set<int>> dp(n);\n        int allOK = 0;\n        for(int i = 0; i < n; ++i) dp[i].insert(0);\n        for(int i = 0; i < queries.size(); ++i) {\n            for(int j = queries[i][0]; j <= queries[i][1]; ++j){\n                int val = queries[i][2];\n                set<int> s = dp[j];\n                for(auto a:dp[j]) s.insert(a + val);\n                if(dp[j].find(nums[j]) == dp[j].end() && s.find(nums[j]) != s.end()) allOK++;\n                dp[j] = s;\n            }\n            if(allOK == nums.size()) return i + 1;\n\n        }\n        return -1;\n    }\n};","author":"zyj","submissionId":"611273409"},[]]},{"2190":[{"id":"2190","fileName":"611273346.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        res=0\n        for i in range(len(nums)):\n            if nums[i]==0:\n                continue\n            dp=[True]+[False]*nums[i]\n            for j in range(len(queries)):\n                for k in range(nums[i],0,-1):\n                    if queries[j][0]<=i<=queries[j][1] and k-queries[j][2]>=0:\n                        dp[k]=dp[k-queries[j][2]]|dp[k]\n                    else:\n                        dp[k]=dp[k]\n                if dp[-1]:\n                    res=max(res,j+1)\n                    break\n            if dp[-1]==False:\n                return -1\n        return res","author":"凕雨","submissionId":"611273346"},[]]},{"2191":[{"id":"2191","fileName":"611273297.txt","sourceCode":"class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        List<Integer>[] cnt = new ArrayList[n];\n\n        for (int i = 0; i < n; i++) {\n            cnt[i] = new ArrayList<>(); // 初始化每个位置的 ArrayList\n        }\n\n        // 处理 queries\n        for (int[] query : queries) {\n            int left = query[0], right = query[1], val = query[2];\n            for (int i = 0; i < n; i++) {\n                if (i >= left && i <= right)\n                    cnt[i].add(val);\n                else\n                    cnt[i].add(0);\n            }\n        }\n\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            List<Integer> x = cnt[i];\n\n            // 处理未被 queries 影响的情况（即 `cnt[i]` 为空）\n            if (x.isEmpty()) {\n                x.add(0);\n            }\n\n            int index = findSubsetIndex(x, nums[i]);\n            if (index == -1)\n                return -1; // 不能构成 target\n            ans = Math.max(ans, index);\n        }\n        return ans;\n    }\n\n    private static int findSubsetIndex(List<Integer> nums, int target) {\n        // 处理 target = 0 的特殊情况\n        if (target == 0)\n            return 0;\n\n        // 计算 sum 防止 target 过大\n        int sum = nums.stream().mapToInt(Integer::intValue).sum();\n        if (sum < target)\n            return -1;\n\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n\n        for (int i = 0; i < nums.size(); i++) {\n            int num = nums.get(i);\n            if (num == 0)\n                continue; // 忽略 0\n            for (int j = target; j >= num; j--) {\n                dp[j] = dp[j] || dp[j - num];\n            }\n            if (dp[target])\n                return i + 1;\n        }\n\n        return -1;\n    }\n}","author":"ngi","submissionId":"611273297"},[]]},{"2192":[{"id":"2192","fileName":"611273611.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        if (ranges::max(nums) == 0) return 0;\n        \n        vector<vector<bool>> dp(nums.size());\n        for (int i = 0; i < dp.size(); i++) {\n            dp[i].resize(nums[i] + 1, false);\n            dp[i][0] = true;\n        }\n\n        for (int k = 0; k < queries.size(); k++) {\n            for (int i = queries[k][0]; i <= queries[k][1]; i++) {\n                for (int j = dp[i].size() - 1; j >= queries[k][2]; j--) {\n                    dp[i][j] = dp[i][j] || dp[i][j - queries[k][2]];\n                }\n            }\n            if (ranges::all_of(dp, [](vector<bool>& v) {return v.back();})) \n                return k + 1;\n        }\n\n        return -1;\n    }\n};","author":"zzz","submissionId":"611273611"},[]]},{"2193":[{"id":"2193","fileName":"611273420.txt","sourceCode":"class Solution {\npublic:\n    vector<vector<int>>query;\nint a[20];\nint n,m;\nvector<int>dp[16];\nint d[2000];\nbool f(int x){\n    int w=a[x];\n    int sz=dp[x].size();\n    for(int i=0;i<2000;i++){\n        d[i]=0;\n    }\n    for(int i=0;i<sz;i++){\n        int val=dp[x][i];\n        for(int j=w;j>=val;j--){\n            d[j]=max(d[j],d[j-val]+val);\n        }\n    }\n    return d[w]==w;\n}\n\nbool check(int x){\n    for(int i=0;i<16;i++){\n        dp[i].clear();\n    }\n    for(int c=0;c<x;c++){\n        int l=query[c][0];\n        int r=query[c][1];\n        int val = query[c][2];\n        l++,r++;\n        for(int i=l;i<=r;i++){\n            dp[i].push_back(val);\n        }\n    }\n    for(int i=1;i<=n;i++){\n        if(!f(i)){\n          //  cout << \"OO \" << x << \" \" << f(i) << 'n';\n            return false;\n        }\n    }\n    return true;\n}\n    \n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        query=queries;\n         n=nums.size();\n     m=query.size();\n        bool ok=true;\n        for(int x : nums){\n            if(x!=0){\n                ok=false;\n            }\n        }\n     for(int i=1;i<=n;i++){\n        a[i]=nums[i-1];\n     }\n     int l=1,r=m;\n     int ans=m+1;\n     while(l <= r){\n        int mid=(l+r)/2;\n        if(check(mid)){\n            r=mid-1;\n            ans=min(ans,mid);\n        }else {\n            l=mid+1;\n        }\n     }\n     if(ans==m+1){\n        ans=-1;\n     }\n        if(ok){\n            ans=0;\n        }\n        return ans;\n            \n    }\n};","author":"Zhouzw","submissionId":"611273420"},[]]},{"2194":[{"id":"2194","fileName":"611273892.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        if sum(nums) == 0:\n            return 0\n        n = len(nums)\n        ok = [True if num == 0 else False for num in nums]\n        s = [{0} for _ in range(n)]\n        for k, (a, b, c) in enumerate(queries):\n            for i in range(a, b+1):\n                if not ok[i]:\n                    s[i] |= {v + c for v in s[i] if v + c <= nums[i]}\n                    if nums[i] in s[i]:\n                        ok[i] = True\n            if all(v for v in ok):\n                return k + 1\n        return -1\n                \n        ","author":"Rong","submissionId":"611273892"},[]]},{"2195":[{"id":"2195","fileName":"611273825.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        index_values = defaultdict(list)\n        for i, [l, r, v] in enumerate(queries):\n            for index in range(l, r + 1):\n                index_values[index].append([v, i])\n\n        def check(limit) -> bool:\n            dp = [True] + [False] * num\n            for i in range(limit + 1):\n                x = a[i][0]\n                for j in range(num, x - 1, -1):\n                    if dp[j - x]:\n                        dp[j] = True\n                        if dp[num]:\n                            return True\n            return False\n\n        ans = -1\n        for i, num in enumerate(nums):\n            if num == 0: continue\n            a = index_values[i]\n            an = len(a)\n            idx = bisect_left(range(an), True, key = check)\n            if idx == an:\n                return -1\n            ans = max(ans, a[idx][1])\n        return ans + 1\n        \n        ","author":"milan","submissionId":"611273825"},[]]},{"2196":[{"id":"2196","fileName":"611273850.txt","sourceCode":"from typing import List\n\nclass Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        \n        # 预处理每个元素的覆盖查询\n        cover = [[] for _ in range(n)]\n        for idx, (l, r, val) in enumerate(queries):\n            for i in range(l, r+1):\n                cover[i].append((val, idx))\n        \n        k_list = []\n        for i in range(n):\n            target = nums[i]\n            if target == 0:\n                k_list.append(-1)\n                continue\n            \n            q_list = cover[i]\n            INF = float('inf')\n            dp = [INF] * (target + 1)\n            dp[0] = -1  # 初始状态，和为0的最大索引是-1（未选择任何查询）\n            \n            for val, idx in q_list:\n                # 逆序遍历当前可能的和，以避免重复计算\n                for s in range(target, -1, -1):\n                    if dp[s] != INF:\n                        new_s = s + val\n                        if new_s > target:\n                            continue\n                        new_max = max(dp[s], idx)\n                        if new_max < dp[new_s]:\n                            dp[new_s] = new_max\n            \n            if dp[target] == INF:\n                return -1\n            k_list.append(dp[target])\n        \n        max_k = max(k_list)\n        if max_k == -1:\n            # 所有元素初始为0，无需任何查询\n            return 0\n        else:\n            return max_k + 1","author":"leakey_py","submissionId":"611273850"},[]]},{"2197":[{"id":"2197","fileName":"611273909.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<vector<vector<int>>> f(ranges::max(nums) + 1, vector<vector<int>>(n, vector<int>(m, -1)));\n        auto dfs = [&](this auto &&dfs, int idx, int x, int depth) {\n            if (x == 0) return depth - 1;\n            if (depth == m) return -2;\n            \n            int &res = f[x][idx][depth];\n            if (res != -1) return res;\n\n            vector<int> &q = queries[depth];\n            if (q[0] > idx || q[1] < idx || q[2] > x) {\n                res = dfs(idx, x, depth + 1);\n            } else {\n                int i = dfs(idx, x, depth + 1);\n                int j = dfs(idx, x - q[2], depth + 1);\n                if (i > j) swap(i, j);\n                if (i < 0) res = j;\n                else res = min(i, j);\n            }\n            return res;\n        };\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            int mm = dfs(i, nums[i], 0);\n            if (mm < -1) return -1;\n            ans = max(ans, mm);\n        }\n        return ans + 1;\n    }\n};","author":"沅筱","submissionId":"611273909"},[]]},{"2198":[{"id":"2198","fileName":"611274137.txt","sourceCode":"class Solution {\npublic:\n//     //能不能在mid次，降低到0\n//     //累计计算一下，每个区间的总刷新次数\n//     bool check(vector<int>& nums, vector<vector<int>>& queries,int mid) {\n//         int n = nums.size(), m = queries.size();\n//         vector<int>sum(n,0);\n//         for(int i=0;i<mid;i++) {\n//             int l = queries[i][0], r = queries[i][1], val = queries[i][2];\n//             for(int j=l;j<=r;j++) {\n//                 sum[j] += val;\n                 \n//             }\n//         } \n//         for(int i=0;i<n;i++) {\n//             if (sum[i] < nums[i]) return false;\n//         }\n//         return true;\n//     }\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<vector<pair<int, int>>> arr(n);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int l = queries[j][0];\n                int r = queries[j][1];\n                if (l <= i && i <= r) { //i被记录在查询j的区间中\n                    arr[i].emplace_back(j, queries[j][2]);\n                }\n            }\n        }\n\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == 0) {\n                continue;\n            }\n\n            auto &cur = arr[i];\n            if (cur.empty()) {\n                return -1;\n            }\n\n            unordered_map<int, int> dp;\n            dp[0] = -1;\n\n            for (auto &q : cur) {\n                int j_index = q.first;\n                int val = q.second;\n\n                auto current_dp = dp;\n                for (auto &kv : current_dp) {\n                    int sum_val = kv.first;\n                    int current_max_j = kv.second;\n                    int new_sum = sum_val + val;\n                    if (new_sum > nums[i]) {\n                        continue;\n                    }\n                    int new_max_j = max(current_max_j, j_index);\n                    if (!dp.count(new_sum) || new_max_j < dp[new_sum]) {\n                        dp[new_sum] = new_max_j;\n                    }\n                }\n            }\n\n            if (!dp.count(nums[i])) {\n                return -1;\n            }\n\n            int current_j = dp[nums[i]];\n            if (current_j > ans) {\n                ans = current_j;\n            }\n        }\n\n        if (ans == -1) {\n            return 0;\n        } else {\n            return ans + 1;\n        }\n    }\n};","author":"faustrun","submissionId":"611274137"},[]]},{"2199":[{"id":"2199","fileName":"611274059.txt","sourceCode":"class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        int ans = -1;\n        vector<vector<int>> a(n);\n        bool check1 = true;\n        for (int j = 0; j < nums.size(); j++) {\n            if (nums[j] != 0) {\n                check1 = false;\n            }\n        }\n        if (check1) {\n            return 0;\n        }\n        for (int i = 0; i < queries.size(); i++) {\n            for (int j = queries[i][0]; j <= queries[i][1]; j++) {\n                a[j].push_back(queries[i][2]);\n                if (nums[j] != 0) {\n                    int m = a[j].size();\n                    vector<vector<bool>> dp(m + 1, vector<bool>(nums[j] + 1, false));\n                    for (int k = 0; k < m + 1; k++) {\n                        dp[k][0] = true;\n                    }\n                    for (int k = 1; k < m + 1; k++) {\n                        for (int l = 1; l < nums[j] + 1; l++) {\n                            if (l < a[j][k - 1]) {\n                                dp[k][l] = dp[k - 1][l];\n                            } else {\n                                dp[k][l] = dp[k - 1][l] || dp[k - 1][l - a[j][k - 1]];\n                            }\n                        }\n                    }\n                    if (dp[m][nums[j]]) {\n                        nums[j] = 0;\n                    }\n                }\n            }\n            bool check = true;\n            for (int j = 0; j < nums.size(); j++) {\n                if (nums[j] != 0){\n                    check = false;\n                    break;\n                }\n            }\n            if (check) {\n                ans = i + 1;\n                break;\n            }\n        }\n        return ans;\n    }\n};","author":"Stupefied 6aloisK4s","submissionId":"611274059"},[]]},{"2200":[{"id":"2200","fileName":"611274153.txt","sourceCode":"class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        m = len(queries)\n        if all(x == 0 for x in nums):\n            return 0\n            \n        def check_zero(vlist, target):\n            # print(vlist, target)\n            dp = [False] * (target + 1)\n            dp[0] = True \n            for num in vlist:\n                for s in range(target, num - 1, -1):\n                    if dp[s - num]:\n                        dp[s] = True\n            # print(dp)\n            return dp[target]\n\n        for k in range(m+1):\n            vals = []\n            flag = True\n            for i in range(n):\n                vals = []\n                for j in range(k):\n                    li, ri, val = queries[j]\n                    if li <= i <= ri:\n                        vals.append(val)\n                if not check_zero(vals, nums[i]):\n                    flag = False\n                    break\n            if flag:\n                return k\n        \n        return -1\n            \n        # left = 0\n        # right = len(queries)\n        # if not check(right):\n        #     return -1\n        # while left + 1 < right:\n        #     mid = (left + right) // 2\n        #     if check(mid):\n        #         right = mid\n        #     else:\n        #         left = mid\n        # return right","author":"stupefy","submissionId":"611274153"},[]]}]}